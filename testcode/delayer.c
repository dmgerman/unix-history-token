begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/delayer.c - debug program that delays queries to a server.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This program delays queries made. It performs as a proxy to another  * server and delays queries to it.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/** number of reads per select for delayer */
end_comment

begin_define
define|#
directive|define
name|TRIES_PER_SELECT
value|100
end_define

begin_comment
comment|/**  * The ring buffer  */
end_comment

begin_struct
struct|struct
name|ringbuf
block|{
comment|/** base of buffer */
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/** size of buffer */
name|size_t
name|size
decl_stmt|;
comment|/** low mark, items start here */
name|size_t
name|low
decl_stmt|;
comment|/** high mark, items end here */
name|size_t
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * List of proxy fds that return replies from the server to our clients.  */
end_comment

begin_struct
struct|struct
name|proxy
block|{
comment|/** the fd to listen for replies from server */
name|int
name|s
decl_stmt|;
comment|/** last time this was used */
name|struct
name|timeval
name|lastuse
decl_stmt|;
comment|/** remote address */
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
comment|/** length of addr */
name|socklen_t
name|addr_len
decl_stmt|;
comment|/** number of queries waiting (in total) */
name|size_t
name|numwait
decl_stmt|;
comment|/** number of queries sent to server (in total) */
name|size_t
name|numsent
decl_stmt|;
comment|/** numberof answers returned to client (in total) */
name|size_t
name|numreturn
decl_stmt|;
comment|/** how many times repurposed */
name|size_t
name|numreuse
decl_stmt|;
comment|/** next in proxylist */
name|struct
name|proxy
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * An item that has to be TCP relayed  */
end_comment

begin_struct
struct|struct
name|tcp_send_list
block|{
comment|/** the data item */
name|uint8_t
modifier|*
name|item
decl_stmt|;
comment|/** size of item */
name|size_t
name|len
decl_stmt|;
comment|/** time when the item can be transmitted on */
name|struct
name|timeval
name|wait
decl_stmt|;
comment|/** how much of the item has already been transmitted */
name|size_t
name|done
decl_stmt|;
comment|/** next in list */
name|struct
name|tcp_send_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * List of TCP proxy fd pairs to TCP connect client to server   */
end_comment

begin_struct
struct|struct
name|tcp_proxy
block|{
comment|/** the fd to listen for client query */
name|int
name|client_s
decl_stmt|;
comment|/** the fd to listen for server answer */
name|int
name|server_s
decl_stmt|;
comment|/** remote client address */
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
comment|/** length of address */
name|socklen_t
name|addr_len
decl_stmt|;
comment|/** timeout on this entry */
name|struct
name|timeval
name|timeout
decl_stmt|;
comment|/** list of query items to send to server */
name|struct
name|tcp_send_list
modifier|*
name|querylist
decl_stmt|;
comment|/** last in query list */
name|struct
name|tcp_send_list
modifier|*
name|querylast
decl_stmt|;
comment|/** list of answer items to send to client */
name|struct
name|tcp_send_list
modifier|*
name|answerlist
decl_stmt|;
comment|/** last in answerlist */
name|struct
name|tcp_send_list
modifier|*
name|answerlast
decl_stmt|;
comment|/** next in list */
name|struct
name|tcp_proxy
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** usage information for delayer */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|printf
argument_list|(
literal|"usage: %s [options]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-f addr : use addr, forward to that server, @port.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-b addr : bind to this address to listen.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-p port : bind to this port (use 0 for random).\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-m mem	: use this much memory for waiting queries.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-d delay: UDP queries are delayed n milliseconds.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		  TCP is delayed twice (on send, on recv).\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-h 	: this help message\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** timeval compare, t1< t2 */
end_comment

begin_function
specifier|static
name|int
name|dl_tv_smaller
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
if|if
condition|(
name|t1
operator|->
name|tv_sec
operator|<
name|t2
operator|->
name|tv_sec
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|->
name|tv_sec
operator|==
name|t2
operator|->
name|tv_sec
operator|&&
name|t1
operator|->
name|tv_usec
operator|<
name|t2
operator|->
name|tv_usec
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** timeval add, t1 += t2 */
end_comment

begin_function
specifier|static
name|void
name|dl_tv_add
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|t1
operator|->
name|tv_sec
operator|+=
name|t2
operator|->
name|tv_sec
expr_stmt|;
name|t1
operator|->
name|tv_usec
operator|+=
name|t2
operator|->
name|tv_usec
expr_stmt|;
while|while
condition|(
name|t1
operator|->
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|t1
operator|->
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|t1
operator|->
name|tv_sec
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** timeval subtract, t1 -= t2 */
end_comment

begin_function
specifier|static
name|void
name|dl_tv_subtract
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|t1
operator|->
name|tv_sec
operator|-=
name|t2
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|tv_usec
operator|>=
name|t2
operator|->
name|tv_usec
condition|)
block|{
name|t1
operator|->
name|tv_usec
operator|-=
name|t2
operator|->
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|t1
operator|->
name|tv_sec
operator|--
expr_stmt|;
name|t1
operator|->
name|tv_usec
operator|=
literal|1000000
operator|-
operator|(
name|t2
operator|->
name|tv_usec
operator|-
name|t1
operator|->
name|tv_usec
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** create new ring buffer */
end_comment

begin_function
specifier|static
name|struct
name|ringbuf
modifier|*
name|ring_create
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
name|struct
name|ringbuf
modifier|*
name|r
init|=
operator|(
expr|struct
name|ringbuf
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|r
operator|->
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|buf
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|sz
expr_stmt|;
name|r
operator|->
name|low
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|high
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** delete ring buffer */
end_comment

begin_function
specifier|static
name|void
name|ring_delete
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|r
condition|)
return|return;
name|free
argument_list|(
name|r
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** add entry to ringbuffer */
end_comment

begin_function
specifier|static
name|void
name|ring_add
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|r
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|delay
parameter_list|,
name|struct
name|proxy
modifier|*
name|p
parameter_list|)
block|{
comment|/* time -- proxy* -- 16bitlen -- message */
name|uint16_t
name|len
init|=
operator|(
name|uint16_t
operator|)
name|ldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|when
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|uint8_t
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|log_assert
argument_list|(
name|ldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<=
literal|65535
argument_list|)
expr_stmt|;
name|needed
operator|=
sizeof|sizeof
argument_list|(
name|when
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|len
argument_list|)
operator|+
name|len
expr_stmt|;
comment|/* put item into ringbuffer */
if|if
condition|(
name|r
operator|->
name|low
operator|<
name|r
operator|->
name|high
condition|)
block|{
comment|/* used part is in the middle */
if|if
condition|(
name|r
operator|->
name|size
operator|-
name|r
operator|->
name|high
operator|>=
name|needed
condition|)
block|{
name|where
operator|=
name|r
operator|->
name|buf
operator|+
name|r
operator|->
name|high
expr_stmt|;
name|r
operator|->
name|high
operator|+=
name|needed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|low
operator|>
name|needed
condition|)
block|{
comment|/* wrap around ringbuffer */
comment|/* make sure r->low == r->high means empty */
comment|/* so r->low == r->high cannot be used to signify 			 * a completely full ringbuf */
if|if
condition|(
name|r
operator|->
name|size
operator|-
name|r
operator|->
name|high
operator|>
sizeof|sizeof
argument_list|(
name|when
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* zero entry at end of buffer */
name|memset
argument_list|(
name|r
operator|->
name|buf
operator|+
name|r
operator|->
name|high
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|when
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|where
operator|=
name|r
operator|->
name|buf
expr_stmt|;
name|r
operator|->
name|high
operator|=
name|needed
expr_stmt|;
block|}
else|else
block|{
comment|/* drop message */
name|log_warn
argument_list|(
literal|"warning: mem full, dropped message"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* empty */
if|if
condition|(
name|r
operator|->
name|high
operator|==
name|r
operator|->
name|low
condition|)
block|{
name|where
operator|=
name|r
operator|->
name|buf
expr_stmt|;
name|r
operator|->
name|low
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|high
operator|=
name|needed
expr_stmt|;
comment|/* unused part is in the middle */
comment|/* so ringbuffer has wrapped around */
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|low
operator|-
name|r
operator|->
name|high
operator|>
name|needed
condition|)
block|{
name|where
operator|=
name|r
operator|->
name|buf
operator|+
name|r
operator|->
name|high
expr_stmt|;
name|r
operator|->
name|high
operator|+=
name|needed
expr_stmt|;
block|}
else|else
block|{
name|log_warn
argument_list|(
literal|"warning: mem full, dropped message"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|when
operator|=
operator|*
name|now
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|when
argument_list|,
name|delay
argument_list|)
expr_stmt|;
comment|/* copy it at where part */
name|log_assert
argument_list|(
name|where
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|where
argument_list|,
operator|&
name|when
argument_list|,
sizeof|sizeof
argument_list|(
name|when
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|where
operator|+
sizeof|sizeof
argument_list|(
name|when
argument_list|)
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|where
operator|+
sizeof|sizeof
argument_list|(
name|when
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|where
operator|+
sizeof|sizeof
argument_list|(
name|when
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** see if the ringbuffer is empty */
end_comment

begin_function
specifier|static
name|int
name|ring_empty
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|low
operator|==
name|r
operator|->
name|high
operator|)
return|;
block|}
end_function

begin_comment
comment|/** peek at timevalue for next item in ring */
end_comment

begin_function
specifier|static
name|struct
name|timeval
modifier|*
name|ring_peek_time
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|ring_empty
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|r
operator|->
name|buf
index|[
name|r
operator|->
name|low
index|]
return|;
block|}
end_function

begin_comment
comment|/** get entry from ringbuffer */
end_comment

begin_function
specifier|static
name|int
name|ring_pop
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|r
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
name|struct
name|proxy
modifier|*
modifier|*
name|p
parameter_list|)
block|{
comment|/* time -- proxy* -- 16bitlen -- message */
name|uint16_t
name|len
decl_stmt|;
name|uint8_t
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|size_t
name|done
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|low
operator|==
name|r
operator|->
name|high
condition|)
return|return
literal|0
return|;
name|where
operator|=
name|r
operator|->
name|buf
operator|+
name|r
operator|->
name|low
expr_stmt|;
name|memmove
argument_list|(
name|tv
argument_list|,
name|where
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|where
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|len
argument_list|,
name|where
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|where
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ldns_buffer_set_limit
argument_list|(
name|pkt
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|done
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|len
argument_list|)
operator|+
name|len
expr_stmt|;
comment|/* move lowmark */
if|if
condition|(
name|r
operator|->
name|low
operator|<
name|r
operator|->
name|high
condition|)
block|{
comment|/* used part in middle */
name|log_assert
argument_list|(
name|r
operator|->
name|high
operator|-
name|r
operator|->
name|low
operator|>=
name|done
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|+=
name|done
expr_stmt|;
block|}
else|else
block|{
comment|/* unused part in middle */
name|log_assert
argument_list|(
name|r
operator|->
name|size
operator|-
name|r
operator|->
name|low
operator|>=
name|done
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|+=
name|done
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|size
operator|-
name|r
operator|->
name|low
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* see if it is zeroed; means end of buffer */
name|struct
name|proxy
modifier|*
name|pz
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|pz
argument_list|,
name|r
operator|->
name|buf
operator|+
name|r
operator|->
name|low
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
name|r
operator|->
name|low
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|r
operator|->
name|low
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|low
operator|==
name|r
operator|->
name|high
condition|)
block|{
name|r
operator|->
name|low
operator|=
literal|0
expr_stmt|;
comment|/* reset if empty */
name|r
operator|->
name|high
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** signal handler global info */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|do_quit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** signal handler for user quit */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|delayer_sigh
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|printf
argument_list|(
literal|"exit on signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|do_quit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** send out waiting packets */
end_comment

begin_function
specifier|static
name|void
name|service_send
parameter_list|(
name|struct
name|ringbuf
modifier|*
name|ring
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|srv_addr
parameter_list|,
name|socklen_t
name|srv_len
parameter_list|)
block|{
name|struct
name|proxy
modifier|*
name|p
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|ssize_t
name|sent
decl_stmt|;
while|while
condition|(
operator|!
name|ring_empty
argument_list|(
name|ring
argument_list|)
operator|&&
name|dl_tv_smaller
argument_list|(
name|ring_peek_time
argument_list|(
name|ring
argument_list|)
argument_list|,
name|now
argument_list|)
condition|)
block|{
comment|/* this items needs to be sent out */
if|if
condition|(
operator|!
name|ring_pop
argument_list|(
name|ring
argument_list|,
name|pkt
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"ringbuf error: pop failed"
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"send out query %d.%6.6d"
argument_list|,
operator|(
name|unsigned
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"from client"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
comment|/* send it */
name|sent
operator|=
name|sendto
argument_list|(
name|p
operator|->
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|ldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|srv_addr
argument_list|,
name|srv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"sendto: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"sendto: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sent
operator|!=
operator|(
name|ssize_t
operator|)
name|ldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"sendto: partial send"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|lastuse
operator|=
operator|*
name|now
expr_stmt|;
name|p
operator|->
name|numsent
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** do proxy for one readable client */
end_comment

begin_function
specifier|static
name|void
name|do_proxy
parameter_list|(
name|struct
name|proxy
modifier|*
name|p
parameter_list|,
name|int
name|retsock
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRIES_PER_SELECT
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|recv
argument_list|(
name|p
operator|->
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|ldns_buffer_capacity
argument_list|(
name|pkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
return|return;
name|log_err
argument_list|(
literal|"recv: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
return|return;
name|log_err
argument_list|(
literal|"recv: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ldns_buffer_set_limit
argument_list|(
name|pkt
argument_list|,
operator|(
name|size_t
operator|)
name|r
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"return reply to client"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
comment|/* send reply back to the real client */
name|p
operator|->
name|numreturn
operator|++
expr_stmt|;
name|r
operator|=
name|sendto
argument_list|(
name|retsock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|r
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"sendto: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"sendto: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/** proxy return replies to clients */
end_comment

begin_function
specifier|static
name|void
name|service_proxy
parameter_list|(
name|fd_set
modifier|*
name|rset
parameter_list|,
name|int
name|retsock
parameter_list|,
name|struct
name|proxy
modifier|*
name|proxies
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|struct
name|proxy
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|proxies
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|p
operator|->
name|s
argument_list|,
name|rset
argument_list|)
condition|)
block|{
name|p
operator|->
name|lastuse
operator|=
operator|*
name|now
expr_stmt|;
name|do_proxy
argument_list|(
name|p
argument_list|,
name|retsock
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** find or else create proxy for this remote client */
end_comment

begin_function
specifier|static
name|struct
name|proxy
modifier|*
name|find_create_proxy
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|from
parameter_list|,
name|socklen_t
name|from_len
parameter_list|,
name|fd_set
modifier|*
name|rorig
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|struct
name|proxy
modifier|*
modifier|*
name|proxies
parameter_list|,
name|int
name|serv_ip6
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|reuse_timeout
parameter_list|)
block|{
name|struct
name|proxy
modifier|*
name|p
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|proxies
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sockaddr_cmp
argument_list|(
name|from
argument_list|,
name|from_len
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
block|}
comment|/* possibly: reuse lapsed entries */
for|for
control|(
name|p
operator|=
operator|*
name|proxies
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|numwait
operator|>
name|p
operator|->
name|numsent
operator|||
name|p
operator|->
name|numsent
operator|>
name|p
operator|->
name|numreturn
condition|)
continue|continue;
name|t
operator|=
operator|*
name|now
expr_stmt|;
name|dl_tv_subtract
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|p
operator|->
name|lastuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl_tv_smaller
argument_list|(
operator|&
name|t
argument_list|,
name|reuse_timeout
argument_list|)
condition|)
continue|continue;
comment|/* yes! */
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"reuse existing entry"
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
name|from
argument_list|,
name|from_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|addr_len
operator|=
name|from_len
expr_stmt|;
name|p
operator|->
name|numreuse
operator|++
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* create new */
name|p
operator|=
operator|(
expr|struct
name|proxy
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|p
operator|->
name|s
operator|=
name|socket
argument_list|(
name|serv_ip6
condition|?
name|AF_INET6
else|:
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|s
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fd_set_nonblock
argument_list|(
name|p
operator|->
name|s
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
name|from
argument_list|,
name|from_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|addr_len
operator|=
name|from_len
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|proxies
expr_stmt|;
operator|*
name|proxies
operator|=
name|p
expr_stmt|;
name|FD_SET
argument_list|(
argument|FD_SET_T p->s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|s
operator|+
literal|1
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|p
operator|->
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/** recv new waiting packets */
end_comment

begin_function
specifier|static
name|void
name|service_recv
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|ringbuf
modifier|*
name|ring
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|fd_set
modifier|*
name|rorig
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|struct
name|proxy
modifier|*
modifier|*
name|proxies
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|srv_addr
parameter_list|,
name|socklen_t
name|srv_len
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|delay
parameter_list|,
name|struct
name|timeval
modifier|*
name|reuse
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
name|socklen_t
name|from_len
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|proxy
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRIES_PER_SELECT
condition|;
name|i
operator|++
control|)
block|{
name|from_len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|len
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|ldns_buffer_capacity
argument_list|(
name|pkt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
return|return;
name|fatal_exit
argument_list|(
literal|"recvfrom: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return;
name|fatal_exit
argument_list|(
literal|"recvfrom: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ldns_buffer_set_limit
argument_list|(
name|pkt
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* find its proxy element */
name|p
operator|=
name|find_create_proxy
argument_list|(
operator|&
name|from
argument_list|,
name|from_len
argument_list|,
name|rorig
argument_list|,
name|max
argument_list|,
name|proxies
argument_list|,
name|addr_is_ip6
argument_list|(
name|srv_addr
argument_list|,
name|srv_len
argument_list|)
argument_list|,
name|now
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal_exit
argument_list|(
literal|"error: cannot find or create proxy"
argument_list|)
expr_stmt|;
name|p
operator|->
name|lastuse
operator|=
operator|*
name|now
expr_stmt|;
name|ring_add
argument_list|(
name|ring
argument_list|,
name|pkt
argument_list|,
name|now
argument_list|,
name|delay
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|numwait
operator|++
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"recv from client"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** delete tcp proxy */
end_comment

begin_function
specifier|static
name|void
name|tcp_proxy_delete
parameter_list|(
name|struct
name|tcp_proxy
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tcp_send_list
modifier|*
name|s
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"delete tcp proxy"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|querylist
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|sn
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sn
expr_stmt|;
block|}
name|s
operator|=
name|p
operator|->
name|answerlist
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|sn
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sn
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|p
operator|->
name|client_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|p
operator|->
name|client_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
condition|)
name|closesocket
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** accept new TCP connections, and set them up */
end_comment

begin_function
specifier|static
name|void
name|service_tcp_listen
parameter_list|(
name|int
name|s
parameter_list|,
name|fd_set
modifier|*
name|rorig
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|struct
name|tcp_proxy
modifier|*
modifier|*
name|proxies
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|srv_addr
parameter_list|,
name|socklen_t
name|srv_len
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|tcp_timeout
parameter_list|)
block|{
name|int
name|newfd
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|struct
name|tcp_proxy
modifier|*
name|p
decl_stmt|;
name|socklen_t
name|addr_len
decl_stmt|;
name|newfd
operator|=
name|accept
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
return|return;
name|fatal_exit
argument_list|(
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNRESET
condition|)
return|return;
name|fatal_exit
argument_list|(
literal|"accept: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
operator|(
expr|struct
name|tcp_proxy
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|addr_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|addr_len
operator|=
name|addr_len
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"new tcp proxy"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|client_s
operator|=
name|newfd
expr_stmt|;
name|p
operator|->
name|server_s
operator|=
name|socket
argument_list|(
name|addr_is_ip6
argument_list|(
name|srv_addr
argument_list|,
name|srv_len
argument_list|)
condition|?
name|AF_INET6
else|:
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|server_s
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"tcp socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"tcp socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fd_set_nonblock
argument_list|(
name|p
operator|->
name|client_s
argument_list|)
expr_stmt|;
name|fd_set_nonblock
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|p
operator|->
name|server_s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|srv_addr
argument_list|,
name|srv_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
name|log_err
argument_list|(
literal|"tcp connect: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|client_s
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINPROGRESS
condition|)
block|{
name|log_err
argument_list|(
literal|"tcp connect: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|p
operator|->
name|client_s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|->
name|timeout
operator|=
operator|*
name|now
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|p
operator|->
name|timeout
argument_list|,
name|tcp_timeout
argument_list|)
expr_stmt|;
comment|/* listen to client and server */
name|FD_SET
argument_list|(
argument|FD_SET_T p->client_s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
name|FD_SET
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|client_s
operator|+
literal|1
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|p
operator|->
name|client_s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|server_s
operator|+
literal|1
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|p
operator|->
name|server_s
operator|+
literal|1
expr_stmt|;
comment|/* add into proxy list */
name|p
operator|->
name|next
operator|=
operator|*
name|proxies
expr_stmt|;
operator|*
name|proxies
operator|=
name|p
expr_stmt|;
block|}
comment|/** relay TCP, read a part */
specifier|static
name|int
name|tcp_relay_read
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|tcp_send_list
modifier|*
modifier|*
name|first
parameter_list|,
name|struct
name|tcp_send_list
modifier|*
modifier|*
name|last
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|delay
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|tcp_send_list
modifier|*
name|item
decl_stmt|;
name|ssize_t
name|r
init|=
name|recv
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|ldns_buffer_capacity
argument_list|(
name|pkt
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp read: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* connection closed */
return|return
literal|0
return|;
block|}
name|item
operator|=
operator|(
expr|struct
name|tcp_send_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"read item len %d"
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|item
operator|->
name|len
operator|=
operator|(
name|size_t
operator|)
name|r
expr_stmt|;
name|item
operator|->
name|item
operator|=
name|memdup
argument_list|(
name|ldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|item
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|item
condition|)
block|{
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|item
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|wait
operator|=
operator|*
name|now
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|item
operator|->
name|wait
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* link in */
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|(
operator|*
name|last
operator|)
operator|->
name|next
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|item
expr_stmt|;
block|}
operator|*
name|last
operator|=
name|item
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/** relay TCP, write a part */
specifier|static
name|int
name|tcp_relay_write
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|tcp_send_list
modifier|*
modifier|*
name|first
parameter_list|,
name|struct
name|tcp_send_list
modifier|*
modifier|*
name|last
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|ssize_t
name|r
decl_stmt|;
name|struct
name|tcp_send_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|first
condition|)
block|{
name|p
operator|=
operator|*
name|first
expr_stmt|;
comment|/* is the item ready? */
if|if
condition|(
operator|!
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|wait
argument_list|,
name|now
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* write it */
name|r
operator|=
name|send
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|p
operator|->
name|item
operator|+
name|p
operator|->
name|done
operator|)
argument_list|,
name|p
operator|->
name|len
operator|-
name|p
operator|->
name|done
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp write: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* closed */
return|return
literal|0
return|;
block|}
comment|/* account it */
name|p
operator|->
name|done
operator|+=
operator|(
name|size_t
operator|)
name|r
expr_stmt|;
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"write item %d of %d"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|done
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|done
operator|>=
name|p
operator|->
name|len
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|item
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|first
condition|)
operator|*
name|last
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* partial write */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/** perform TCP relaying */
specifier|static
name|void
name|service_tcp_relay
parameter_list|(
name|struct
name|tcp_proxy
modifier|*
modifier|*
name|tcp_proxies
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|delay
parameter_list|,
name|struct
name|timeval
modifier|*
name|tcp_timeout
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|,
name|fd_set
modifier|*
name|rset
parameter_list|,
name|fd_set
modifier|*
name|rorig
parameter_list|,
name|fd_set
modifier|*
name|worig
parameter_list|)
block|{
name|struct
name|tcp_proxy
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|;
name|int
name|delete_it
decl_stmt|;
name|p
operator|=
operator|*
name|tcp_proxies
expr_stmt|;
name|prev
operator|=
name|tcp_proxies
expr_stmt|;
name|tout
operator|=
operator|*
name|now
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|tout
argument_list|,
name|tcp_timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|delete_it
operator|=
literal|0
expr_stmt|;
comment|/* can we receive further queries? */
if|if
condition|(
operator|!
name|delete_it
operator|&&
name|FD_ISSET
argument_list|(
name|p
operator|->
name|client_s
argument_list|,
name|rset
argument_list|)
condition|)
block|{
name|p
operator|->
name|timeout
operator|=
name|tout
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"read tcp query"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcp_relay_read
argument_list|(
name|p
operator|->
name|client_s
argument_list|,
operator|&
name|p
operator|->
name|querylist
argument_list|,
operator|&
name|p
operator|->
name|querylast
argument_list|,
name|now
argument_list|,
name|delay
argument_list|,
name|pkt
argument_list|)
condition|)
name|delete_it
operator|=
literal|1
expr_stmt|;
block|}
comment|/* can we receive further answers? */
if|if
condition|(
operator|!
name|delete_it
operator|&&
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|p
operator|->
name|server_s
argument_list|,
name|rset
argument_list|)
condition|)
block|{
name|p
operator|->
name|timeout
operator|=
name|tout
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"read tcp answer"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcp_relay_read
argument_list|(
name|p
operator|->
name|server_s
argument_list|,
operator|&
name|p
operator|->
name|answerlist
argument_list|,
operator|&
name|p
operator|->
name|answerlast
argument_list|,
name|now
argument_list|,
name|delay
argument_list|,
name|pkt
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|p
operator|->
name|server_s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_CLR
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
name|FD_CLR
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
name|p
operator|->
name|server_s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* can we send on further queries */
if|if
condition|(
operator|!
name|delete_it
operator|&&
name|p
operator|->
name|querylist
operator|&&
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
condition|)
block|{
name|p
operator|->
name|timeout
operator|=
name|tout
expr_stmt|;
if|if
condition|(
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|querylist
operator|->
name|wait
argument_list|,
name|now
argument_list|)
condition|)
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"write tcp query"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcp_relay_write
argument_list|(
name|p
operator|->
name|server_s
argument_list|,
operator|&
name|p
operator|->
name|querylist
argument_list|,
operator|&
name|p
operator|->
name|querylast
argument_list|,
name|now
argument_list|)
condition|)
name|delete_it
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|querylist
operator|&&
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
operator|&&
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|querylist
operator|->
name|wait
argument_list|,
name|now
argument_list|)
condition|)
name|FD_SET
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
else|else
name|FD_CLR
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
block|}
comment|/* can we send on further answers */
if|if
condition|(
operator|!
name|delete_it
operator|&&
name|p
operator|->
name|answerlist
condition|)
block|{
name|p
operator|->
name|timeout
operator|=
name|tout
expr_stmt|;
if|if
condition|(
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|answerlist
operator|->
name|wait
argument_list|,
name|now
argument_list|)
condition|)
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"write tcp answer"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcp_relay_write
argument_list|(
name|p
operator|->
name|client_s
argument_list|,
operator|&
name|p
operator|->
name|answerlist
argument_list|,
operator|&
name|p
operator|->
name|answerlast
argument_list|,
name|now
argument_list|)
condition|)
name|delete_it
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|answerlist
operator|&&
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|answerlist
operator|->
name|wait
argument_list|,
name|now
argument_list|)
condition|)
name|FD_SET
argument_list|(
argument|FD_SET_T p->client_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
else|else
name|FD_CLR
argument_list|(
argument|FD_SET_T p->client_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|answerlist
operator|&&
name|p
operator|->
name|server_s
operator|==
operator|-
literal|1
condition|)
name|delete_it
operator|=
literal|1
expr_stmt|;
block|}
comment|/* does this entry timeout? (unused too long) */
if|if
condition|(
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|timeout
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|delete_it
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delete_it
condition|)
block|{
name|struct
name|tcp_proxy
modifier|*
name|np
init|=
name|p
operator|->
name|next
decl_stmt|;
operator|*
name|prev
operator|=
name|np
expr_stmt|;
name|FD_CLR
argument_list|(
argument|FD_SET_T p->client_s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
name|FD_CLR
argument_list|(
argument|FD_SET_T p->client_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|server_s
operator|!=
operator|-
literal|1
condition|)
block|{
name|FD_CLR
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|rorig
argument_list|)
empty_stmt|;
name|FD_CLR
argument_list|(
argument|FD_SET_T p->server_s
argument_list|,
argument|worig
argument_list|)
empty_stmt|;
block|}
name|tcp_proxy_delete
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/** find waiting time */
specifier|static
name|int
name|service_findwait
parameter_list|(
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|timeval
modifier|*
name|wait
parameter_list|,
name|struct
name|ringbuf
modifier|*
name|ring
parameter_list|,
name|struct
name|tcp_proxy
modifier|*
name|tcplist
parameter_list|)
block|{
comment|/* first item is the time to wait */
name|struct
name|timeval
modifier|*
name|peek
init|=
name|ring_peek_time
argument_list|(
name|ring
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tcv
decl_stmt|;
name|int
name|have_tcpval
init|=
literal|0
decl_stmt|;
name|struct
name|tcp_proxy
modifier|*
name|p
decl_stmt|;
comment|/* also for TCP list the first in sendlists is the time to wait */
for|for
control|(
name|p
operator|=
name|tcplist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|have_tcpval
condition|)
name|tcv
operator|=
name|p
operator|->
name|timeout
expr_stmt|;
name|have_tcpval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|timeout
argument_list|,
operator|&
name|tcv
argument_list|)
condition|)
name|tcv
operator|=
name|p
operator|->
name|timeout
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|querylist
operator|&&
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|querylist
operator|->
name|wait
argument_list|,
operator|&
name|tcv
argument_list|)
condition|)
name|tcv
operator|=
name|p
operator|->
name|querylist
operator|->
name|wait
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|answerlist
operator|&&
name|dl_tv_smaller
argument_list|(
operator|&
name|p
operator|->
name|answerlist
operator|->
name|wait
argument_list|,
operator|&
name|tcv
argument_list|)
condition|)
name|tcv
operator|=
name|p
operator|->
name|answerlist
operator|->
name|wait
expr_stmt|;
block|}
if|if
condition|(
name|peek
condition|)
block|{
comment|/* peek can be unaligned */
comment|/* use wait as a temp variable */
name|memmove
argument_list|(
name|wait
argument_list|,
name|peek
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wait
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_tcpval
condition|)
name|tcv
operator|=
operator|*
name|wait
expr_stmt|;
elseif|else
if|if
condition|(
name|dl_tv_smaller
argument_list|(
name|wait
argument_list|,
operator|&
name|tcv
argument_list|)
condition|)
name|tcv
operator|=
operator|*
name|wait
expr_stmt|;
name|have_tcpval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_tcpval
condition|)
block|{
operator|*
name|wait
operator|=
name|tcv
expr_stmt|;
name|dl_tv_subtract
argument_list|(
name|wait
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* nothing, block */
return|return
literal|0
return|;
block|}
comment|/** clear proxy list */
specifier|static
name|void
name|proxy_list_clear
parameter_list|(
name|struct
name|proxy
modifier|*
name|p
parameter_list|)
block|{
name|char
name|from
index|[
literal|109
index|]
decl_stmt|;
name|struct
name|proxy
modifier|*
name|np
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|port
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|port
operator|=
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|p
operator|->
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addr_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|p
operator|->
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|,
name|from
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|from
argument_list|,
literal|"err"
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|p
operator|->
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
name|from
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|from
argument_list|,
literal|"err"
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"client[%d]: last %s@%d of %d : %u in, %u out, "
literal|"%u returned\n"
argument_list|,
name|i
operator|++
argument_list|,
name|from
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|numreuse
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|p
operator|->
name|numwait
argument_list|,
operator|(
name|unsigned
operator|)
name|p
operator|->
name|numsent
argument_list|,
operator|(
name|unsigned
operator|)
name|p
operator|->
name|numreturn
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|p
operator|->
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|p
operator|->
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
comment|/** clear TCP proxy list */
specifier|static
name|void
name|tcp_proxy_list_clear
parameter_list|(
name|struct
name|tcp_proxy
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tcp_proxy
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|tcp_proxy_delete
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
comment|/** delayer service loop */
specifier|static
name|void
name|service_loop
parameter_list|(
name|int
name|udp_s
parameter_list|,
name|int
name|listen_s
parameter_list|,
name|struct
name|ringbuf
modifier|*
name|ring
parameter_list|,
name|struct
name|timeval
modifier|*
name|delay
parameter_list|,
name|struct
name|timeval
modifier|*
name|reuse
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|srv_addr
parameter_list|,
name|socklen_t
name|srv_len
parameter_list|,
name|ldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|fd_set
name|rset
decl_stmt|,
name|rorig
decl_stmt|;
name|fd_set
name|wset
decl_stmt|,
name|worig
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|wait
decl_stmt|;
name|int
name|max
decl_stmt|,
name|have_wait
init|=
literal|0
decl_stmt|;
name|struct
name|proxy
modifier|*
name|proxies
init|=
name|NULL
decl_stmt|;
name|struct
name|tcp_proxy
modifier|*
name|tcp_proxies
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tcp_timeout
decl_stmt|;
name|tcp_timeout
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
name|tcp_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|FD_ZERO
argument_list|(
operator|&
name|rorig
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|worig
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
argument|FD_SET_T udp_s
argument_list|,
argument|&rorig
argument_list|)
empty_stmt|;
name|FD_SET
argument_list|(
argument|FD_SET_T listen_s
argument_list|,
argument|&rorig
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|max
operator|=
name|udp_s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|listen_s
operator|+
literal|1
operator|>
name|max
condition|)
name|max
operator|=
name|listen_s
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|do_quit
condition|)
block|{
comment|/* wait for events */
name|rset
operator|=
name|rorig
expr_stmt|;
name|wset
operator|=
name|worig
expr_stmt|;
if|if
condition|(
name|have_wait
condition|)
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"wait for %d.%6.6d"
argument_list|,
operator|(
name|unsigned
operator|)
name|wait
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
operator|)
name|wait
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|max
argument_list|,
operator|&
name|rset
argument_list|,
operator|&
name|wset
argument_list|,
name|NULL
argument_list|,
name|have_wait
condition|?
operator|&
name|wait
else|:
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|fatal_exit
argument_list|(
literal|"select: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* get current time */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|fatal_exit
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"process at %u.%6.6u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|now
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
operator|)
name|now
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* sendout delayed queries to master server (frees up buffer)*/
name|service_send
argument_list|(
name|ring
argument_list|,
operator|&
name|now
argument_list|,
name|pkt
argument_list|,
name|srv_addr
argument_list|,
name|srv_len
argument_list|)
expr_stmt|;
comment|/* proxy return replies */
name|service_proxy
argument_list|(
operator|&
name|rset
argument_list|,
name|udp_s
argument_list|,
name|proxies
argument_list|,
name|pkt
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* see what can be received to start waiting */
name|service_recv
argument_list|(
name|udp_s
argument_list|,
name|ring
argument_list|,
name|pkt
argument_list|,
operator|&
name|rorig
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|proxies
argument_list|,
name|srv_addr
argument_list|,
name|srv_len
argument_list|,
operator|&
name|now
argument_list|,
name|delay
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
comment|/* see if there are new tcp connections */
name|service_tcp_listen
argument_list|(
name|listen_s
argument_list|,
operator|&
name|rorig
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|tcp_proxies
argument_list|,
name|srv_addr
argument_list|,
name|srv_len
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|tcp_timeout
argument_list|)
expr_stmt|;
comment|/* service tcp connections */
name|service_tcp_relay
argument_list|(
operator|&
name|tcp_proxies
argument_list|,
operator|&
name|now
argument_list|,
name|delay
argument_list|,
operator|&
name|tcp_timeout
argument_list|,
name|pkt
argument_list|,
operator|&
name|rset
argument_list|,
operator|&
name|rorig
argument_list|,
operator|&
name|worig
argument_list|)
expr_stmt|;
comment|/* see what next timeout is (if any) */
name|have_wait
operator|=
name|service_findwait
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|wait
argument_list|,
name|ring
argument_list|,
name|tcp_proxies
argument_list|)
expr_stmt|;
block|}
name|proxy_list_clear
argument_list|(
name|proxies
argument_list|)
expr_stmt|;
name|tcp_proxy_list_clear
argument_list|(
name|tcp_proxies
argument_list|)
expr_stmt|;
block|}
comment|/** delayer main service routine */
specifier|static
name|void
name|service
parameter_list|(
specifier|const
name|char
modifier|*
name|bind_str
parameter_list|,
name|int
name|bindport
parameter_list|,
specifier|const
name|char
modifier|*
name|serv_str
parameter_list|,
name|size_t
name|memsize
parameter_list|,
name|int
name|delay_msec
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|bind_addr
decl_stmt|,
name|srv_addr
decl_stmt|;
name|socklen_t
name|bind_len
decl_stmt|,
name|srv_len
decl_stmt|;
name|struct
name|ringbuf
modifier|*
name|ring
init|=
name|ring_create
argument_list|(
name|memsize
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|delay
decl_stmt|,
name|reuse
decl_stmt|;
name|ldns_buffer
modifier|*
name|pkt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|listen_s
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|delay
operator|.
name|tv_sec
operator|=
name|delay_msec
operator|/
literal|1000
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
operator|(
name|delay_msec
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
name|reuse
operator|=
name|delay
expr_stmt|;
comment|/* reuse is max(4*delay, 1 second) */
name|dl_tv_add
argument_list|(
operator|&
name|reuse
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|reuse
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
name|dl_tv_add
argument_list|(
operator|&
name|reuse
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|reuse
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|reuse
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|serv_str
argument_list|,
operator|&
name|srv_addr
argument_list|,
operator|&
name|srv_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot parse forward address: %s\n"
argument_list|,
name|serv_str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pkt
operator|=
name|ldns_buffer_new
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkt
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBREAK
name|signal
argument_list|(
name|SIGBREAK
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGALRM
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|delayer_sigh
argument_list|)
operator|==
name|SIG_ERR
condition|)
name|fatal_exit
argument_list|(
literal|"could not bind to signal"
argument_list|)
expr_stmt|;
comment|/* bind UDP port */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|str_is_ip6
argument_list|(
name|bind_str
argument_list|)
condition|?
name|AF_INET6
else|:
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bindport
operator|==
literal|0
condition|)
block|{
name|bindport
operator|=
literal|1024
operator|+
name|random
argument_list|()
operator|%
literal|64000
expr_stmt|;
name|i
operator|=
literal|100
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ipstrtoaddr
argument_list|(
name|bind_str
argument_list|,
name|bindport
argument_list|,
operator|&
name|bind_addr
argument_list|,
operator|&
name|bind_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot parse listen address: %s\n"
argument_list|,
name|bind_str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
name|bind_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"bind: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|--
operator|==
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"cannot bind any port"
argument_list|)
expr_stmt|;
name|bindport
operator|=
literal|1024
operator|+
name|random
argument_list|()
operator|%
literal|64000
expr_stmt|;
block|}
else|else
break|break;
block|}
name|fd_set_nonblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* and TCP port */
if|if
condition|(
operator|(
name|listen_s
operator|=
name|socket
argument_list|(
name|str_is_ip6
argument_list|(
name|bind_str
argument_list|)
condition|?
name|AF_INET6
else|:
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"tcp socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"tcp socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SO_REUSEADDR
if|if
condition|(
literal|1
condition|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|listen_s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|listen_s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
name|bind_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"tcp bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"tcp bind: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|listen
argument_list|(
name|listen_s
argument_list|,
literal|5
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"tcp listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"tcp listen: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fd_set_nonblock
argument_list|(
name|listen_s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"listening on port: %d\n"
argument_list|,
name|bindport
argument_list|)
expr_stmt|;
comment|/* process loop */
name|do_quit
operator|=
literal|0
expr_stmt|;
name|service_loop
argument_list|(
name|s
argument_list|,
name|listen_s
argument_list|,
name|ring
argument_list|,
operator|&
name|delay
argument_list|,
operator|&
name|reuse
argument_list|,
operator|&
name|srv_addr
argument_list|,
name|srv_len
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|verbose
argument_list|(
literal|1
argument_list|,
literal|"cleanup"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|listen_s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|listen_s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ldns_buffer_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|ring_delete
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/** main program for delayer */
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* defaults */
specifier|const
name|char
modifier|*
name|server
init|=
literal|"127.0.0.1@53"
decl_stmt|;
specifier|const
name|char
modifier|*
name|bindto
init|=
literal|"0.0.0.0"
decl_stmt|;
name|int
name|bindport
init|=
literal|0
decl_stmt|;
name|size_t
name|memsize
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|int
name|delay
init|=
literal|100
decl_stmt|;
name|verbosity
operator|=
literal|0
expr_stmt|;
name|log_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_ident_set
argument_list|(
literal|"delayer"
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|usage
argument_list|(
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:d:f:hm:p:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|bindto
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bad delay: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|delay
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|server
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|cfg_parse_memsize
argument_list|(
name|optarg
argument_list|,
operator|&
name|memsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad memsize: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bad port nr: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bindport
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bind to %s @ %d and forward to %s after %d msec\n"
argument_list|,
name|bindto
argument_list|,
name|bindport
argument_list|,
name|server
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|service
argument_list|(
name|bindto
argument_list|,
name|bindport
argument_list|,
name|server
argument_list|,
name|memsize
argument_list|,
name|delay
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

