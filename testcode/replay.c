begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/replay.c - store and use a replay of events for the DNS resolver.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *   * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Store and use a replay of events for the DNS resolver.  * Used to test known scenarios to get known outcomes.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* for strtod prototype */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"testcode/replay.h"
end_include

begin_include
include|#
directive|include
file|"testcode/testpkts.h"
end_include

begin_include
include|#
directive|include
file|"testcode/fake_event.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_comment
comment|/** max length of lines in file */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE_LEN
value|10240
end_define

begin_comment
comment|/**  * Expand a macro  * @param store: value storage  * @param runtime: replay runtime for other stuff.  * @param text: the macro text, after the ${, Updated to after the } when   * 	done (successfully).  * @return expanded text, malloced. NULL on failure.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|macro_expand
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|char
modifier|*
modifier|*
name|text
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** compare of time values */
end_comment

begin_function
specifier|static
name|int
name|timeval_smaller
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|x
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|y
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
if|if
condition|(
name|x
operator|->
name|tv_sec
operator|<
name|y
operator|->
name|tv_sec
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|x
operator|->
name|tv_sec
operator|==
name|y
operator|->
name|tv_sec
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|tv_usec
operator|<=
name|y
operator|->
name|tv_usec
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** parse keyword in string.   * @param line: if found, the line is advanced to after the keyword.  * @param keyword: string.  * @return: true if found, false if not.   */
end_comment

begin_function
specifier|static
name|int
name|parse_keyword
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|)
block|{
name|size_t
name|len
init|=
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
name|keyword
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|line
argument_list|,
name|keyword
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|line
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** delete moment */
end_comment

begin_function
specifier|static
name|void
name|replay_moment_delete
parameter_list|(
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mom
condition|)
return|return;
if|if
condition|(
name|mom
operator|->
name|match
condition|)
block|{
name|delete_entry
argument_list|(
name|mom
operator|->
name|match
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mom
operator|->
name|autotrust_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
operator|->
name|variable
argument_list|)
expr_stmt|;
name|config_delstrlist
argument_list|(
name|mom
operator|->
name|file_content
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** delete range */
end_comment

begin_function
specifier|static
name|void
name|replay_range_delete
parameter_list|(
name|struct
name|replay_range
modifier|*
name|rng
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rng
condition|)
return|return;
name|delete_entry
argument_list|(
name|rng
operator|->
name|match
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rng
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** strip whitespace from end of string */
end_comment

begin_function
specifier|static
name|void
name|strip_end_white
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
return|return;
block|}
block|}
end_function

begin_comment
comment|/**   * Read a range from file.   * @param remain: Rest of line (after RANGE keyword).  * @param in: file to read from.  * @param name: name to print in errors.  * @param pstate: read state structure with  * 	with lineno : incremented as lines are read.  * 	ttl, origin, prev for readentry.  * @param line: line buffer.  * @return: range object to add to list, or NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|replay_range
modifier|*
name|replay_range_read
parameter_list|(
name|char
modifier|*
name|remain
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|sldns_file_parse_state
modifier|*
name|pstate
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|replay_range
modifier|*
name|rng
init|=
operator|(
expr|struct
name|replay_range
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|replay_range
argument_list|)
argument_list|)
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
name|char
modifier|*
name|parse
decl_stmt|;
name|struct
name|entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|rng
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|rng
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rng
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read time range */
if|if
condition|(
name|sscanf
argument_list|(
name|remain
argument_list|,
literal|" %d %d"
argument_list|,
operator|&
name|rng
operator|->
name|start_step
argument_list|,
operator|&
name|rng
operator|->
name|end_step
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not read time range: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rng
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* read entries */
name|pos
operator|=
name|ftello
argument_list|(
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_LINE_LEN
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|pstate
operator|->
name|lineno
operator|++
expr_stmt|;
name|parse
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|parse
argument_list|)
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
operator|||
operator|*
name|parse
operator|==
literal|';'
condition|)
block|{
name|pos
operator|=
name|ftello
argument_list|(
name|in
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"ADDRESS"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|parse
argument_list|)
condition|)
name|parse
operator|++
expr_stmt|;
name|strip_end_white
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|parse
argument_list|,
operator|&
name|rng
operator|->
name|addr
argument_list|,
operator|&
name|rng
operator|->
name|addrlen
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Line %d: could not read ADDRESS: %s"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rng
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pos
operator|=
name|ftello
argument_list|(
name|in
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"RANGE_END"
argument_list|)
condition|)
block|{
return|return
name|rng
return|;
block|}
comment|/* set position before line; read entry */
name|pstate
operator|->
name|lineno
operator|--
expr_stmt|;
name|fseeko
argument_list|(
name|in
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|entry
operator|=
name|read_entry
argument_list|(
name|in
argument_list|,
name|name
argument_list|,
name|pstate
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
name|fatal_exit
argument_list|(
literal|"%d: bad entry"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
else|else
name|rng
operator|->
name|match
operator|=
name|entry
expr_stmt|;
name|last
operator|=
name|entry
expr_stmt|;
name|pos
operator|=
name|ftello
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|replay_range_delete
argument_list|(
name|rng
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** Read FILE match content */
end_comment

begin_function
specifier|static
name|void
name|read_file_content
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|int
modifier|*
name|lineno
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
name|char
name|line
index|[
name|MAX_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|remain
init|=
name|line
decl_stmt|;
name|struct
name|config_strlist
modifier|*
modifier|*
name|last
init|=
operator|&
name|mom
operator|->
name|file_content
decl_stmt|;
name|line
index|[
name|MAX_LINE_LEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_LINE_LEN
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"FILE_BEGIN expected at line %d"
argument_list|,
operator|*
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"FILE_BEGIN"
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"FILE_BEGIN expected at line %d"
argument_list|,
operator|*
name|lineno
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_LINE_LEN
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
operator|(
operator|*
name|lineno
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"FILE_END"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
name|last
argument_list|,
name|strdup
argument_list|(
name|line
argument_list|)
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
name|last
operator|=
operator|&
operator|(
operator|(
operator|*
name|last
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|fatal_exit
argument_list|(
literal|"no FILE_END in input file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** read assign step info */
end_comment

begin_function
specifier|static
name|void
name|read_assign_step
parameter_list|(
name|char
modifier|*
name|remain
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|eq
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|remain
argument_list|,
literal|" %1023s %c %n"
argument_list|,
name|buf
argument_list|,
operator|&
name|eq
argument_list|,
operator|&
name|skip
argument_list|)
operator|!=
literal|2
condition|)
name|fatal_exit
argument_list|(
literal|"cannot parse assign: %s"
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|mom
operator|->
name|variable
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|!=
literal|'='
condition|)
name|fatal_exit
argument_list|(
literal|"no '=' in assign: %s"
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|remain
operator|+=
name|skip
expr_stmt|;
if|if
condition|(
name|remain
index|[
literal|0
index|]
condition|)
name|remain
index|[
name|strlen
argument_list|(
name|remain
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|mom
operator|->
name|string
operator|=
name|strdup
argument_list|(
name|remain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|variable
operator|||
operator|!
name|mom
operator|->
name|string
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Read a replay moment 'STEP' from file.   * @param remain: Rest of line (after STEP keyword).  * @param in: file to read from.  * @param name: name to print in errors.  * @param pstate: with lineno, ttl, origin, prev for parse state.  * 	lineno is incremented.  * @return: range object to add to list, or NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|replay_moment
modifier|*
name|replay_moment_read
parameter_list|(
name|char
modifier|*
name|remain
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|sldns_file_parse_state
modifier|*
name|pstate
parameter_list|)
block|{
name|struct
name|replay_moment
modifier|*
name|mom
init|=
operator|(
expr|struct
name|replay_moment
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|replay_moment
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|int
name|readentry
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mom
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|mom
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mom
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|remain
argument_list|,
literal|" %d%n"
argument_list|,
operator|&
name|mom
operator|->
name|time_step
argument_list|,
operator|&
name|skip
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"%d: cannot read number: %s"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|remain
operator|+=
name|skip
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"NOTHING"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_nothing
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"QUERY"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_front_query
expr_stmt|;
name|readentry
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
literal|"127.0.0.1"
argument_list|,
operator|&
name|mom
operator|->
name|addr
argument_list|,
operator|&
name|mom
operator|->
name|addrlen
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"CHECK_ANSWER"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_front_reply
expr_stmt|;
name|readentry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"CHECK_OUT_QUERY"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_back_query
expr_stmt|;
name|readentry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"REPLY"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_back_reply
expr_stmt|;
name|readentry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"TIMEOUT"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_timeout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"TIME_PASSES"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_time_passes
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"EVAL"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
name|mom
operator|->
name|string
operator|=
name|strdup
argument_list|(
name|remain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|string
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|mom
operator|->
name|string
argument_list|)
operator|>
literal|0
condition|)
name|mom
operator|->
name|string
index|[
name|strlen
argument_list|(
name|mom
operator|->
name|string
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|remain
operator|+=
name|strlen
argument_list|(
name|mom
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"CHECK_AUTOTRUST"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_autotrust_check
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|remain
argument_list|)
operator|>
literal|0
operator|&&
name|remain
index|[
name|strlen
argument_list|(
name|remain
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|remain
index|[
name|strlen
argument_list|(
name|remain
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mom
operator|->
name|autotrust_id
operator|=
name|strdup
argument_list|(
name|remain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|autotrust_id
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|read_file_content
argument_list|(
name|in
argument_list|,
operator|&
name|pstate
operator|->
name|lineno
argument_list|,
name|mom
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"ERROR"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"TRAFFIC"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_traffic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"ASSIGN"
argument_list|)
condition|)
block|{
name|mom
operator|->
name|evt_type
operator|=
name|repevt_assign
expr_stmt|;
name|read_assign_step
argument_list|(
name|remain
argument_list|,
name|mom
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"INFRA_RTT"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|mom
operator|->
name|evt_type
operator|=
name|repevt_infra_rtt
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
name|s
operator|=
name|remain
expr_stmt|;
name|remain
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remain
condition|)
name|fatal_exit
argument_list|(
literal|"expected three args for INFRA_RTT"
argument_list|)
expr_stmt|;
name|remain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|remain
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
name|m
operator|=
name|strchr
argument_list|(
name|remain
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|fatal_exit
argument_list|(
literal|"expected three args for INFRA_RTT"
argument_list|)
expr_stmt|;
name|m
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|m
argument_list|)
condition|)
name|m
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|s
argument_list|,
operator|&
name|mom
operator|->
name|addr
argument_list|,
operator|&
name|mom
operator|->
name|addrlen
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"bad infra_rtt address %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|m
argument_list|)
operator|>
literal|0
operator|&&
name|m
index|[
name|strlen
argument_list|(
name|m
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|m
index|[
name|strlen
argument_list|(
name|m
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mom
operator|->
name|variable
operator|=
name|strdup
argument_list|(
name|remain
argument_list|)
expr_stmt|;
name|mom
operator|->
name|string
operator|=
name|strdup
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|string
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|variable
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
literal|"%d: unknown event type %s"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"ADDRESS"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|remain
argument_list|)
condition|)
name|remain
operator|++
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|remain
argument_list|)
operator|>
literal|0
condition|)
comment|/* remove \n */
name|remain
index|[
name|strlen
argument_list|(
name|remain
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|remain
argument_list|,
operator|&
name|mom
operator|->
name|addr
argument_list|,
operator|&
name|mom
operator|->
name|addrlen
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d: could not parse ADDRESS: %s"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|remain
argument_list|,
literal|"ELAPSE"
argument_list|)
condition|)
block|{
name|double
name|sec
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sec
operator|=
name|strtod
argument_list|(
name|remain
argument_list|,
operator|&
name|remain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
literal|0.
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d: could not parse ELAPSE: %s (%s)"
argument_list|,
name|pstate
operator|->
name|lineno
argument_list|,
name|remain
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|mom
operator|->
name|elapse
operator|.
name|tv_sec
operator|=
operator|(
name|int
operator|)
name|sec
expr_stmt|;
name|mom
operator|->
name|elapse
operator|.
name|tv_usec
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|sec
operator|-
operator|(
name|double
operator|)
name|mom
operator|->
name|elapse
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000.
operator|+
literal|0.5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|readentry
condition|)
block|{
name|mom
operator|->
name|match
operator|=
name|read_entry
argument_list|(
name|in
argument_list|,
name|name
argument_list|,
name|pstate
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mom
operator|->
name|match
condition|)
block|{
name|free
argument_list|(
name|mom
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|mom
return|;
block|}
end_function

begin_comment
comment|/** makes scenario with title on rest of line */
end_comment

begin_function
specifier|static
name|struct
name|replay_scenario
modifier|*
name|make_scenario
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|replay_scenario
modifier|*
name|scen
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|log_err
argument_list|(
literal|"scenario: no title given"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|scen
operator|=
operator|(
expr|struct
name|replay_scenario
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|replay_scenario
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scen
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|scen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scen
argument_list|)
argument_list|)
expr_stmt|;
name|scen
operator|->
name|title
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scen
operator|->
name|title
condition|)
block|{
name|free
argument_list|(
name|scen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|scen
return|;
block|}
end_function

begin_function
name|struct
name|replay_scenario
modifier|*
name|replay_scenario_read
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|lineno
parameter_list|)
block|{
name|char
name|line
index|[
name|MAX_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|parse
decl_stmt|;
name|struct
name|replay_scenario
modifier|*
name|scen
init|=
name|NULL
decl_stmt|;
name|struct
name|sldns_file_parse_state
name|pstate
decl_stmt|;
name|line
index|[
name|MAX_LINE_LEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pstate
argument_list|)
argument_list|)
expr_stmt|;
name|pstate
operator|.
name|default_ttl
operator|=
literal|3600
expr_stmt|;
name|pstate
operator|.
name|lineno
operator|=
operator|*
name|lineno
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_LINE_LEN
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|parse
operator|=
name|line
expr_stmt|;
name|pstate
operator|.
name|lineno
operator|++
expr_stmt|;
operator|(
operator|*
name|lineno
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|parse
argument_list|)
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
continue|continue;
comment|/* empty line */
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|";"
argument_list|)
condition|)
continue|continue;
comment|/* comment */
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"SCENARIO_BEGIN"
argument_list|)
condition|)
block|{
name|scen
operator|=
name|make_scenario
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scen
condition|)
name|fatal_exit
argument_list|(
literal|"%d: could not make scen"
argument_list|,
operator|*
name|lineno
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|scen
condition|)
name|fatal_exit
argument_list|(
literal|"%d: expected SCENARIO"
argument_list|,
operator|*
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"RANGE_BEGIN"
argument_list|)
condition|)
block|{
name|struct
name|replay_range
modifier|*
name|newr
init|=
name|replay_range_read
argument_list|(
name|parse
argument_list|,
name|in
argument_list|,
name|name
argument_list|,
operator|&
name|pstate
argument_list|,
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newr
condition|)
name|fatal_exit
argument_list|(
literal|"%d: bad range"
argument_list|,
name|pstate
operator|.
name|lineno
argument_list|)
expr_stmt|;
operator|*
name|lineno
operator|=
name|pstate
operator|.
name|lineno
expr_stmt|;
name|newr
operator|->
name|next_range
operator|=
name|scen
operator|->
name|range_list
expr_stmt|;
name|scen
operator|->
name|range_list
operator|=
name|newr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"STEP"
argument_list|)
condition|)
block|{
name|struct
name|replay_moment
modifier|*
name|mom
init|=
name|replay_moment_read
argument_list|(
name|parse
argument_list|,
name|in
argument_list|,
name|name
argument_list|,
operator|&
name|pstate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mom
condition|)
name|fatal_exit
argument_list|(
literal|"%d: bad moment"
argument_list|,
name|pstate
operator|.
name|lineno
argument_list|)
expr_stmt|;
operator|*
name|lineno
operator|=
name|pstate
operator|.
name|lineno
expr_stmt|;
if|if
condition|(
name|scen
operator|->
name|mom_last
operator|&&
name|scen
operator|->
name|mom_last
operator|->
name|time_step
operator|>=
name|mom
operator|->
name|time_step
condition|)
name|fatal_exit
argument_list|(
literal|"%d: time goes backwards"
argument_list|,
operator|*
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|scen
operator|->
name|mom_last
condition|)
name|scen
operator|->
name|mom_last
operator|->
name|mom_next
operator|=
name|mom
expr_stmt|;
else|else
name|scen
operator|->
name|mom_first
operator|=
name|mom
expr_stmt|;
name|scen
operator|->
name|mom_last
operator|=
name|mom
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_keyword
argument_list|(
operator|&
name|parse
argument_list|,
literal|"SCENARIO_END"
argument_list|)
condition|)
block|{
name|struct
name|replay_moment
modifier|*
name|p
init|=
name|scen
operator|->
name|mom_first
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|mom_next
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"Scenario has %d steps"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|scen
return|;
block|}
block|}
name|replay_scenario_delete
argument_list|(
name|scen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|replay_scenario_delete
parameter_list|(
name|struct
name|replay_scenario
modifier|*
name|scen
parameter_list|)
block|{
name|struct
name|replay_moment
modifier|*
name|mom
decl_stmt|,
modifier|*
name|momn
decl_stmt|;
name|struct
name|replay_range
modifier|*
name|rng
decl_stmt|,
modifier|*
name|rngn
decl_stmt|;
if|if
condition|(
operator|!
name|scen
condition|)
return|return;
if|if
condition|(
name|scen
operator|->
name|title
condition|)
name|free
argument_list|(
name|scen
operator|->
name|title
argument_list|)
expr_stmt|;
name|mom
operator|=
name|scen
operator|->
name|mom_first
expr_stmt|;
while|while
condition|(
name|mom
condition|)
block|{
name|momn
operator|=
name|mom
operator|->
name|mom_next
expr_stmt|;
name|replay_moment_delete
argument_list|(
name|mom
argument_list|)
expr_stmt|;
name|mom
operator|=
name|momn
expr_stmt|;
block|}
name|rng
operator|=
name|scen
operator|->
name|range_list
expr_stmt|;
while|while
condition|(
name|rng
condition|)
block|{
name|rngn
operator|=
name|rng
operator|->
name|next_range
expr_stmt|;
name|replay_range_delete
argument_list|(
name|rng
argument_list|)
expr_stmt|;
name|rng
operator|=
name|rngn
expr_stmt|;
block|}
name|free
argument_list|(
name|scen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** fetch oldest timer in list that is enabled */
end_comment

begin_function
specifier|static
name|struct
name|fake_timer
modifier|*
name|first_timer
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|p
decl_stmt|,
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|p
operator|=
name|runtime
operator|->
name|timer_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|timeval_smaller
argument_list|(
operator|&
name|p
operator|->
name|tv
argument_list|,
operator|&
name|res
operator|->
name|tv
argument_list|)
condition|)
name|res
operator|=
name|p
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|struct
name|fake_timer
modifier|*
name|replay_get_oldest_timer
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|t
init|=
name|first_timer
argument_list|(
name|runtime
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|timeval_smaller
argument_list|(
operator|&
name|t
operator|->
name|tv
argument_list|,
operator|&
name|runtime
operator|->
name|now_tv
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|replay_var_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|x
init|=
operator|(
expr|struct
name|replay_var
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|replay_var
modifier|*
name|y
init|=
operator|(
expr|struct
name|replay_var
operator|*
operator|)
name|b
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|x
operator|->
name|name
argument_list|,
name|y
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|rbtree_t
modifier|*
name|macro_store_create
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|rbtree_create
argument_list|(
operator|&
name|replay_var_compare
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** helper function to delete macro values */
end_comment

begin_function
specifier|static
name|void
name|del_macro
parameter_list|(
name|rbnode_t
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|v
init|=
operator|(
expr|struct
name|replay_var
operator|*
operator|)
name|x
decl_stmt|;
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|macro_store_delete
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|)
block|{
if|if
condition|(
operator|!
name|store
condition|)
return|return;
name|traverse_postorder
argument_list|(
name|store
argument_list|,
name|del_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** return length of macro */
end_comment

begin_function
specifier|static
name|size_t
name|macro_length
parameter_list|(
name|char
modifier|*
name|text
parameter_list|)
block|{
comment|/* we are after ${, looking for } */
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|text
condition|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
name|depth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
name|text
operator|++
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/** insert new stuff at start of buffer */
end_comment

begin_function
specifier|static
name|int
name|do_buf_insert
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|remain
parameter_list|,
name|char
modifier|*
name|after
parameter_list|,
name|char
modifier|*
name|inserted
parameter_list|)
block|{
name|char
modifier|*
name|save
init|=
name|strdup
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|save
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strlen
argument_list|(
name|inserted
argument_list|)
operator|>
name|remain
condition|)
block|{
name|free
argument_list|(
name|save
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|inserted
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|remain
operator|-=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|save
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** do macro recursion */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|do_macro_recursion
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|char
modifier|*
name|at
parameter_list|,
name|size_t
name|remain
parameter_list|)
block|{
name|char
modifier|*
name|after
init|=
name|at
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|expand
init|=
name|macro_expand
argument_list|(
name|store
argument_list|,
name|runtime
argument_list|,
operator|&
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expand
condition|)
return|return
name|NULL
return|;
comment|/* expansion failed */
if|if
condition|(
operator|!
name|do_buf_insert
argument_list|(
name|at
argument_list|,
name|remain
argument_list|,
name|after
argument_list|,
name|expand
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|expand
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|expand
argument_list|)
expr_stmt|;
return|return
name|at
return|;
comment|/* and parse over the expanded text to see if again */
block|}
end_function

begin_comment
comment|/** get var from store */
end_comment

begin_function
specifier|static
name|struct
name|replay_var
modifier|*
name|macro_getvar
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|replay_var
name|k
decl_stmt|;
name|k
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|k
expr_stmt|;
name|k
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
expr|struct
name|replay_var
operator|*
operator|)
name|rbtree_search
argument_list|(
name|store
argument_list|,
operator|&
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** do macro variable */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|do_macro_variable
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|remain
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|at
init|=
name|buf
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|at
decl_stmt|;
name|char
name|sv
decl_stmt|;
if|if
condition|(
name|at
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* no variable name after $ */
while|while
condition|(
operator|*
name|at
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|int
operator|)
operator|*
name|at
argument_list|)
operator|||
operator|*
name|at
operator|==
literal|'_'
operator|)
condition|)
block|{
name|at
operator|++
expr_stmt|;
block|}
comment|/* terminator, we are working in macro_expand() buffer */
name|sv
operator|=
operator|*
name|at
expr_stmt|;
operator|*
name|at
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|macro_getvar
argument_list|(
name|store
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|at
operator|=
name|sv
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
block|{
name|log_err
argument_list|(
literal|"variable is not defined: $%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* variable undefined is error for now */
block|}
comment|/* insert the variable contents */
if|if
condition|(
operator|!
name|do_buf_insert
argument_list|(
name|buf
argument_list|,
name|remain
argument_list|,
name|at
argument_list|,
name|v
operator|->
name|value
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|buf
return|;
comment|/* and expand the variable contents */
block|}
end_function

begin_comment
comment|/** do ctime macro on argument */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|do_macro_ctime
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|time_t
name|tt
init|=
operator|(
name|time_t
operator|)
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|tt
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"macro ctime: expected number, not: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctime_r
argument_list|(
operator|&
name|tt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove trailing newline */
return|return
name|strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** perform arithmetic operator */
end_comment

begin_function
specifier|static
name|double
name|perform_arith
parameter_list|(
name|double
name|x
parameter_list|,
name|char
name|op
parameter_list|,
name|double
name|y
parameter_list|,
name|double
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'+'
case|:
operator|*
name|res
operator|=
name|x
operator|+
name|y
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|*
name|res
operator|=
name|x
operator|-
name|y
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
operator|*
name|res
operator|=
name|x
operator|/
name|y
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
operator|*
name|res
operator|=
name|x
operator|*
name|y
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** do macro arithmetic on two numbers and operand */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|do_macro_arith
parameter_list|(
name|char
modifier|*
name|orig
parameter_list|,
name|size_t
name|remain
parameter_list|,
name|char
modifier|*
modifier|*
name|arithstart
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|result
decl_stmt|;
name|char
name|operator
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
comment|/* not yet done? we want number operand number expanded first. */
if|if
condition|(
operator|!
operator|*
name|arithstart
condition|)
block|{
comment|/* remember start pos of expr, skip the first number */
name|at
operator|=
name|orig
expr_stmt|;
operator|*
name|arithstart
operator|=
name|at
expr_stmt|;
while|while
condition|(
operator|*
name|at
operator|&&
operator|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|at
argument_list|)
operator|||
operator|*
name|at
operator|==
literal|'.'
operator|)
condition|)
name|at
operator|++
expr_stmt|;
return|return
name|at
return|;
block|}
comment|/* move back to start */
name|remain
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|orig
operator|-
operator|*
name|arithstart
argument_list|)
expr_stmt|;
name|at
operator|=
operator|*
name|arithstart
expr_stmt|;
comment|/* parse operands */
if|if
condition|(
name|sscanf
argument_list|(
name|at
argument_list|,
literal|" %lf %c %lf%n"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|operator
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|skip
argument_list|)
operator|!=
literal|3
condition|)
block|{
operator|*
name|arithstart
operator|=
name|NULL
expr_stmt|;
return|return
name|do_macro_arith
argument_list|(
name|orig
argument_list|,
name|remain
argument_list|,
name|arithstart
argument_list|)
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|operator
argument_list|)
condition|)
block|{
operator|*
name|arithstart
operator|=
name|orig
expr_stmt|;
return|return
name|at
operator|+
name|skip
return|;
comment|/* do nothing, but setup for later number */
block|}
comment|/* calculate result */
if|if
condition|(
operator|!
name|perform_arith
argument_list|(
name|x
argument_list|,
name|operator
argument_list|,
name|y
argument_list|,
operator|&
name|result
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"unknown operator: %s"
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* put result back in buffer */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.12g"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_buf_insert
argument_list|(
name|at
argument_list|,
name|remain
argument_list|,
name|at
operator|+
name|skip
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* the result can be part of another expression, restart that */
operator|*
name|arithstart
operator|=
name|NULL
expr_stmt|;
return|return
name|at
return|;
block|}
end_function

begin_comment
comment|/** Do range macro on expanded buffer */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|do_macro_range
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|" %lf %lf %lf"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|z
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|log_err
argument_list|(
literal|"range func requires 3 args: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|x
operator|<=
name|y
operator|&&
name|y
operator|<=
name|z
condition|)
block|{
name|char
name|res
index|[
literal|1024
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|res
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|,
literal|"%.24g"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|res
argument_list|)
return|;
block|}
name|fatal_exit
argument_list|(
literal|"value %.24g not in range [%.24g, %.24g]"
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|macro_expand
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|char
modifier|*
modifier|*
name|text
parameter_list|)
block|{
name|char
name|buf
index|[
literal|10240
index|]
decl_stmt|;
name|char
modifier|*
name|at
init|=
operator|*
name|text
decl_stmt|;
name|size_t
name|len
init|=
name|macro_length
argument_list|(
name|at
argument_list|)
decl_stmt|;
name|int
name|dofunc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arithstart
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* too long */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|at
argument_list|,
name|len
operator|+
literal|1
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* do not copy last '}' character */
name|at
operator|=
name|buf
expr_stmt|;
comment|/* check for functions */
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"time"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ARG_LL
literal|"d"
argument_list|,
operator|(
name|long
name|long
operator|)
name|runtime
operator|->
name|now_secs
argument_list|)
expr_stmt|;
operator|*
name|text
operator|+=
name|len
expr_stmt|;
return|return
name|strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"timeout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|struct
name|fake_timer
modifier|*
name|t
init|=
name|first_timer
argument_list|(
name|runtime
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
name|time_t
operator|)
name|t
operator|->
name|tv
operator|.
name|tv_sec
operator|>=
name|runtime
operator|->
name|now_secs
condition|)
name|res
operator|=
operator|(
name|time_t
operator|)
name|t
operator|->
name|tv
operator|.
name|tv_sec
operator|-
name|runtime
operator|->
name|now_secs
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ARG_LL
literal|"d"
argument_list|,
operator|(
name|long
name|long
operator|)
name|res
argument_list|)
expr_stmt|;
operator|*
name|text
operator|+=
name|len
expr_stmt|;
return|return
name|strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"ctime "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"ctime\t"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|at
operator|+=
literal|6
expr_stmt|;
name|dofunc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"range "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"range\t"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|at
operator|+=
literal|6
expr_stmt|;
name|dofunc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* actual macro text expansion */
while|while
condition|(
operator|*
name|at
condition|)
block|{
name|size_t
name|remain
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|at
argument_list|,
literal|"${"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|at
operator|=
name|do_macro_recursion
argument_list|(
name|store
argument_list|,
name|runtime
argument_list|,
name|at
argument_list|,
name|remain
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|at
operator|==
literal|'$'
condition|)
block|{
name|at
operator|=
name|do_macro_variable
argument_list|(
name|store
argument_list|,
name|at
argument_list|,
name|remain
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|at
argument_list|)
condition|)
block|{
name|at
operator|=
name|do_macro_arith
argument_list|(
name|at
argument_list|,
name|remain
argument_list|,
operator|&
name|arithstart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy until whitespace or operator */
if|if
condition|(
operator|*
name|at
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|int
operator|)
operator|*
name|at
argument_list|)
operator|||
operator|*
name|at
operator|==
literal|'_'
operator|)
condition|)
block|{
name|at
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|at
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|int
operator|)
operator|*
name|at
argument_list|)
operator|||
operator|*
name|at
operator|==
literal|'_'
operator|)
condition|)
name|at
operator|++
expr_stmt|;
block|}
else|else
name|at
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|at
condition|)
return|return
name|NULL
return|;
comment|/* failure */
block|}
operator|*
name|text
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|dofunc
condition|)
block|{
comment|/* post process functions, buf has the argument(s) */
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"ctime"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|do_macro_ctime
argument_list|(
name|buf
operator|+
literal|6
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"range"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|do_macro_range
argument_list|(
name|buf
operator|+
literal|6
argument_list|)
return|;
block|}
block|}
return|return
name|strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|macro_process
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|char
name|buf
index|[
literal|10240
index|]
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|,
modifier|*
name|expand
decl_stmt|;
name|char
modifier|*
name|at
init|=
name|text
decl_stmt|;
if|if
condition|(
operator|!
name|strstr
argument_list|(
name|text
argument_list|,
literal|"${"
argument_list|)
condition|)
return|return
name|strdup
argument_list|(
name|text
argument_list|)
return|;
comment|/* no macros */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|strstr
argument_list|(
name|at
argument_list|,
literal|"${"
argument_list|)
operator|)
condition|)
block|{
comment|/* copy text before next macro */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|at
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* string too long */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|at
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|at
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process the macro itself */
name|next
operator|+=
literal|2
expr_stmt|;
name|expand
operator|=
name|macro_expand
argument_list|(
name|store
argument_list|,
name|runtime
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand
condition|)
return|return
name|NULL
return|;
comment|/* expansion failed */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|expand
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expand
argument_list|)
expr_stmt|;
name|at
operator|=
name|next
expr_stmt|;
block|}
comment|/* copy remainder fixed text */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|macro_lookup
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|x
init|=
name|macro_getvar
argument_list|(
name|store
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|strdup
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|strdup
argument_list|(
name|x
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|macro_print_debug
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|x
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|x
argument_list|,
argument|struct replay_var*
argument_list|,
argument|store
argument_list|)
block|{
name|log_info
argument_list|(
literal|"%s = %s"
argument_list|,
name|x
operator|->
name|name
argument_list|,
name|x
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|macro_assign
parameter_list|(
name|rbtree_t
modifier|*
name|store
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|replay_var
modifier|*
name|x
init|=
name|macro_getvar
argument_list|(
name|store
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|free
argument_list|(
name|x
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|(
expr|struct
name|replay_var
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|x
operator|->
name|node
operator|.
name|key
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
name|store
argument_list|,
operator|&
name|x
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|x
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|x
operator|->
name|value
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|testbound_selftest
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* test the macro store */
name|rbtree_t
modifier|*
name|store
init|=
name|macro_store_create
argument_list|()
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|r
decl_stmt|;
name|log_assert
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"vlerk"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|,
literal|"waarde1"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"vlerk"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"waarde1"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"vlerk"
argument_list|,
literal|"kanteel"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"waarde1"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"vlerk"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"kanteel"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|,
literal|"ww"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_lookup
argument_list|(
name|store
argument_list|,
literal|"bla"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"ww"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|macro_length
argument_list|(
literal|"}"
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|macro_length
argument_list|(
literal|"blabla}"
argument_list|)
operator|==
literal|7
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|macro_length
argument_list|(
literal|"bla${zoink}bla}"
argument_list|)
operator|==
literal|7
operator|+
literal|8
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|macro_length
argument_list|(
literal|"bla${zoink}${bla}bla}"
argument_list|)
operator|==
literal|7
operator|+
literal|8
operator|+
literal|6
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"blabla ${} dinges"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"blabla  dinges"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"1${$bla}2${$bla}3"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"1ww2ww3"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"it is ${ctime 123456}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"it is Fri Jan  2 10:17:36 1970"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"t1"
argument_list|,
literal|"123456"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"it is ${ctime ${$t1}}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"it is Fri Jan  2 10:17:36 1970"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"it is ${ctime $t1}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"it is Fri Jan  2 10:17:36 1970"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"x"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|macro_assign
argument_list|(
name|store
argument_list|,
literal|"y"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${$x + $x}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"2"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${$x - $x}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${$y * $y}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"4"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${32 / $y + $x + $y}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"19"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${32 / ${$y+$y} + ${${100*3}/3}}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"108"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${1 2 33 2 1}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"1 2 33 2 1"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${123 3 + 5}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"123 8"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|macro_process
argument_list|(
name|store
argument_list|,
name|NULL
argument_list|,
literal|"${123 glug 3 + 5}"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|v
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"123 glug 8"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|macro_store_delete
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

