begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/unitregional.c - unit test for regional allocator.  *  * Copyright (c) 2010, NLnet Labs. All rights reserved.  *  * This software is open source.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * \file  * Tests the regional special purpose allocator.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"testcode/unitmain.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_comment
comment|/** test regional corner cases, zero, one, end of structure */
end_comment

begin_function
specifier|static
name|void
name|corner_cases
parameter_list|(
name|struct
name|regional
modifier|*
name|r
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
comment|/* shadow count of allocated memory */
name|void
modifier|*
name|a
decl_stmt|;
name|size_t
name|minsize
init|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|size_t
name|mysize
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unit_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* alloc cases: 	 * 0, 1, 2. 	 * smaller than LARGE_OBJECT_SIZE. 	 * smaller but does not fit in remainder in regional. 	 * smaller but exactly fits in remainder of regional. 	 * size is remainder of regional - 8. 	 * size is remainder of regional + 8. 	 * larger than LARGE_OBJECT_SIZE. 	 */
name|s
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|regional
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
operator|(
name|s
operator|%
name|minsize
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|large_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Note an alloc of 0 gets a pointer to current last 	 * position (where you should then use 0 bytes) */
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|0
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|minsize
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|+=
name|minsize
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|128
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|large_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|10240
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|large_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|10240
argument_list|)
expr_stmt|;
comment|/* s does not change */
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|total_large
operator|==
literal|10240
operator|+
name|minsize
argument_list|)
expr_stmt|;
comment|/* go towards the end of the current chunk */
while|while
condition|(
name|r
operator|->
name|available
operator|>
literal|1024
condition|)
block|{
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|1024
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
name|r
operator|->
name|first_size
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
name|unit_assert
argument_list|(
name|r
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mysize
operator|=
literal|1280
expr_stmt|;
comment|/* does not fit in current chunk */
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* go towards the end of the current chunk */
while|while
condition|(
name|r
operator|->
name|available
operator|>
literal|864
condition|)
block|{
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|864
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|864
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|864
expr_stmt|;
block|}
name|mysize
operator|=
name|r
operator|->
name|available
expr_stmt|;
comment|/* exactly fits */
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* implementation does not go ahead*/
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
comment|/* another large allocation */
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|total_large
operator|==
literal|10240
operator|+
literal|8192
operator|+
literal|2
operator|*
name|minsize
argument_list|)
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* make new chunk */
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|>
literal|0
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|total_large
operator|==
literal|10240
operator|+
literal|8192
operator|+
literal|2
operator|*
name|minsize
argument_list|)
expr_stmt|;
comment|/* go towards the end of the current chunk */
while|while
condition|(
name|r
operator|->
name|available
operator|>
literal|1320
condition|)
block|{
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|1320
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|1320
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|1320
expr_stmt|;
block|}
name|mysize
operator|=
name|r
operator|->
name|available
operator|+
literal|8
expr_stmt|;
comment|/* exact + 8 ; does not fit */
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* new chunk */
comment|/* go towards the end of the current chunk */
while|while
condition|(
name|r
operator|->
name|available
operator|>
literal|1480
condition|)
block|{
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
literal|1480
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
literal|1480
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|1480
expr_stmt|;
block|}
name|mysize
operator|=
name|r
operator|->
name|available
operator|-
literal|8
expr_stmt|;
comment|/* exact - 8 ; fits. */
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x42
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|r
operator|->
name|available
operator|==
literal|8
argument_list|)
expr_stmt|;
comment|/* test if really copied over */
name|str
operator|=
literal|"test12345"
expr_stmt|;
name|a
operator|=
name|regional_alloc_init
argument_list|(
name|r
argument_list|,
name|str
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|str
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* test if really zeroed */
name|a
operator|=
name|regional_alloc_zero
argument_list|(
name|r
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|str
argument_list|,
literal|32
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* test if copied over (and null byte) */
name|str
operator|=
literal|"an interesting string"
expr_stmt|;
name|a
operator|=
name|regional_strdup
argument_list|(
name|r
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** test specific cases */
end_comment

begin_function
specifier|static
name|void
name|specific_cases
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|regional
modifier|*
name|r
init|=
name|regional_create
argument_list|()
decl_stmt|;
name|corner_cases
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|regional_create_custom
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
comment|/* a small regional */
name|unit_assert
argument_list|(
name|r
operator|->
name|first_size
operator|==
literal|2048
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|regional_get_mem
argument_list|(
name|r
argument_list|)
operator|==
literal|2048
argument_list|)
expr_stmt|;
name|corner_cases
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|regional_get_mem
argument_list|(
name|r
argument_list|)
operator|==
literal|2048
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** put random stuff in a region and free it */
end_comment

begin_function
specifier|static
name|void
name|burden_test
parameter_list|(
name|size_t
name|max
parameter_list|)
block|{
name|size_t
name|get
decl_stmt|;
name|void
modifier|*
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|regional
modifier|*
name|r
init|=
name|regional_create_custom
argument_list|(
literal|2048
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|get
operator|=
name|random
argument_list|()
operator|%
name|max
expr_stmt|;
name|a
operator|=
name|regional_alloc
argument_list|(
name|r
argument_list|,
name|get
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0x54
argument_list|,
name|get
argument_list|)
expr_stmt|;
block|}
name|regional_free_all
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** randomly allocate stuff */
end_comment

begin_function
specifier|static
name|void
name|random_burden
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|max_alloc
init|=
literal|2048
operator|+
literal|128
decl_stmt|;
comment|/* small chance of LARGE */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|burden_test
argument_list|(
name|max_alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regional_test
parameter_list|(
name|void
parameter_list|)
block|{
name|unit_show_feature
argument_list|(
literal|"regional"
argument_list|)
expr_stmt|;
name|specific_cases
argument_list|()
expr_stmt|;
name|random_burden
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

