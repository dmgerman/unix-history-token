begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/streamtcp.c - debug program perform multiple DNS queries on tcp.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This program performs multiple DNS queries on a TCP stream.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PF_INET6
end_ifndef

begin_comment
comment|/** define in case streamtcp is compiled on legacy systems */
end_comment

begin_define
define|#
directive|define
name|PF_INET6
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** usage information for streamtcp */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|printf
argument_list|(
literal|"usage: %s [options] name type class ...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sends the name-type-class queries over TCP.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-f server	what ipaddr@portnr to send the queries to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-u 		use UDP. No retries are attempted.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-n 		do not wait for an answer.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-s		use ssl\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-h 		this help text\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** open TCP socket to svr */
end_comment

begin_function
specifier|static
name|int
name|open_svr
parameter_list|(
specifier|const
name|char
modifier|*
name|svr
parameter_list|,
name|int
name|udp
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* svr can be ip@port */
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|svr
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fatal: bad server specs '%s'\n"
argument_list|,
name|svr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|socket
argument_list|(
name|addr_is_ip6
argument_list|(
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|?
name|PF_INET6
else|:
name|PF_INET
argument_list|,
name|udp
condition|?
name|SOCK_DGRAM
else|:
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"socket() error"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"socket: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"connect() error"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"connect: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/** write a query over the TCP fd */
end_comment

begin_function
specifier|static
name|void
name|write_q
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|udp
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|strname
parameter_list|,
specifier|const
name|char
modifier|*
name|strtype
parameter_list|,
specifier|const
name|char
modifier|*
name|strclass
parameter_list|)
block|{
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|ldns_rdf
modifier|*
name|rdf
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
comment|/* qname */
name|rdf
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|strname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdf
condition|)
block|{
name|printf
argument_list|(
literal|"cannot parse query name: '%s'\n"
argument_list|,
name|strname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|qinfo
operator|.
name|qname
operator|=
name|memdup
argument_list|(
name|ldns_rdf_data
argument_list|(
name|rdf
argument_list|)
argument_list|,
name|ldns_rdf_size
argument_list|(
name|rdf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|.
name|qname
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dname_count_size_labels
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|,
operator|&
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|rdf
argument_list|)
expr_stmt|;
comment|/* qtype and qclass */
name|qinfo
operator|.
name|qtype
operator|=
name|ldns_get_rr_type_by_name
argument_list|(
name|strtype
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|qclass
operator|=
name|ldns_get_rr_class_by_name
argument_list|(
name|strclass
argument_list|)
expr_stmt|;
comment|/* make query */
name|qinfo_query_encode
argument_list|(
name|buf
argument_list|,
operator|&
name|qinfo
argument_list|)
expr_stmt|;
name|ldns_buffer_write_u16_at
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ldns_buffer_write_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|,
name|BIT_RD
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
comment|/* add EDNS DO */
name|struct
name|edns_data
name|edns
decl_stmt|;
name|memset
argument_list|(
operator|&
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|.
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
literal|4096
expr_stmt|;
name|attach_edns_record
argument_list|(
name|buf
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
block|}
comment|/* send it */
if|if
condition|(
operator|!
name|udp
condition|)
block|{
name|len
operator|=
operator|(
name|uint16_t
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
condition|)
block|{
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"cannot SSL_write"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|send
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|len
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"send() len failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"send len: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ssl
condition|)
block|{
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"cannot SSL_write"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|send
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
operator|(
name|ssize_t
operator|)
name|ldns_buffer_limit
argument_list|(
name|buf
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"send() data failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"send data: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** receive DNS datagram over TCP and print it */
end_comment

begin_function
specifier|static
name|void
name|recv_one
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|udp
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|ldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|;
name|ldns_pkt
modifier|*
name|pkt
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|udp
condition|)
block|{
if|if
condition|(
name|ssl
condition|)
block|{
if|if
condition|(
name|SSL_read
argument_list|(
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|len
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"read() len failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"read len: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|ntohs
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
condition|)
block|{
name|int
name|r
init|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
operator|(
name|int
operator|)
name|len
condition|)
name|fatal_exit
argument_list|(
literal|"ssl_read %d of %d"
argument_list|,
name|r
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|<
operator|(
name|ssize_t
operator|)
name|len
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"read() data failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"read data: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ssize_t
name|l
decl_stmt|;
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ldns_buffer_capacity
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|perror
argument_list|(
literal|"read() data failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"read data: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|l
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|size_t
operator|)
name|l
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nnext received packet\n"
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
literal|0
argument_list|,
literal|"data"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|status
operator|=
name|ldns_wire2pkt
argument_list|(
operator|&
name|pkt
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|printf
argument_list|(
literal|"could not parse incoming packet: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
literal|0
argument_list|,
literal|"data was"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** send the TCP queries and print answers */
end_comment

begin_function
specifier|static
name|void
name|send_em
parameter_list|(
specifier|const
name|char
modifier|*
name|svr
parameter_list|,
name|int
name|udp
parameter_list|,
name|int
name|usessl
parameter_list|,
name|int
name|noanswer
parameter_list|,
name|int
name|num
parameter_list|,
name|char
modifier|*
modifier|*
name|qs
parameter_list|)
block|{
name|ldns_buffer
modifier|*
name|buf
init|=
name|ldns_buffer_new
argument_list|(
literal|65553
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|open_svr
argument_list|(
name|svr
argument_list|,
name|udp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|SSL
modifier|*
name|ssl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usessl
condition|)
block|{
name|ctx
operator|=
name|connect_sslctx_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
name|fatal_exit
argument_list|(
literal|"cannot create ssl ctx"
argument_list|)
expr_stmt|;
name|ssl
operator|=
name|outgoing_ssl_fd
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
name|fatal_exit
argument_list|(
literal|"cannot create ssl"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|r
decl_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|ssl
argument_list|)
operator|)
operator|==
literal|1
condition|)
break|break;
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_WANT_READ
operator|&&
name|r
operator|!=
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not ssl_handshake"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|X509
modifier|*
name|x
init|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|printf
argument_list|(
literal|"SSL: no peer certificate\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|printf
argument_list|(
literal|"\nNext query is %s %s %s\n"
argument_list|,
name|qs
index|[
name|i
index|]
argument_list|,
name|qs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|qs
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|write_q
argument_list|(
name|fd
argument_list|,
name|udp
argument_list|,
name|ssl
argument_list|,
name|buf
argument_list|,
name|ldns_get_random
argument_list|()
argument_list|,
name|qs
index|[
name|i
index|]
argument_list|,
name|qs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|qs
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* print at least one result */
if|if
condition|(
operator|!
name|noanswer
condition|)
name|recv_one
argument_list|(
name|fd
argument_list|,
name|udp
argument_list|,
name|ssl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usessl
condition|)
block|{
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ldns_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"orderly exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGPIPE
end_ifdef

begin_comment
comment|/** SIGPIPE handler */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|sigh
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|sig
operator|==
name|SIGPIPE
condition|)
block|{
name|printf
argument_list|(
literal|"got SIGPIPE, remote connection gone\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Got unhandled signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGPIPE */
end_comment

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** main program for streamtcp */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|svr
init|=
literal|"127.0.0.1"
decl_stmt|;
name|int
name|udp
init|=
literal|0
decl_stmt|;
name|int
name|noanswer
init|=
literal|0
decl_stmt|;
name|int
name|usessl
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSADATA
name|wsa_data
decl_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"WSAStartup failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* lock debug start (if any) */
name|log_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checklock_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|sigh
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|perror
argument_list|(
literal|"could not install signal handler"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* command line options */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|usage
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:hnsu"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|svr
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noanswer
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|udp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|usessl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"queries must be multiples of name,type,class\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|usessl
condition|)
block|{
name|ERR_load_SSL_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
block|}
name|send_em
argument_list|(
name|svr
argument_list|,
name|udp
argument_list|,
name|usessl
argument_list|,
name|noanswer
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|checklock_stop
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

