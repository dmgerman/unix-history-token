begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/unitmsgparse.c - unit test for msg parse routines.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * \file  * Calls msg parse unit tests. Exits with code 1 on a failure.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"testcode/unitmain.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"testcode/readhex.h"
end_include

begin_include
include|#
directive|include
file|"testcode/testpkts.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"sldns/str2wire.h"
end_include

begin_include
include|#
directive|include
file|"sldns/wire2str.h"
end_include

begin_comment
comment|/** verbose message parse unit test */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vbmp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** do not accept formerr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_formerr_gone
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** if matching within a section should disregard the order of RRs. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|matches_nolocation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** see if RRSIGs are properly matched to RRsets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_rrsigs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** do not check buffer sameness */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_nosameness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** see if buffers contain the same packet */
end_comment

begin_function
specifier|static
name|int
name|test_buffers
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|)
block|{
comment|/* check binary same */
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|==
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vbmp
condition|)
name|printf
argument_list|(
literal|"binary the same (length=%u)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|vbmp
condition|)
block|{
name|size_t
name|sz
init|=
literal|16
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|lim
init|=
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<
name|lim
condition|)
name|lim
operator|=
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|lim
condition|;
name|count
operator|+=
name|sz
control|)
block|{
name|size_t
name|rem
init|=
name|sz
decl_stmt|;
if|if
condition|(
name|lim
operator|-
name|count
operator|<
name|sz
condition|)
name|rem
operator|=
name|lim
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|count
argument_list|)
argument_list|,
name|sldns_buffer_at
argument_list|(
name|out
argument_list|,
name|count
argument_list|)
argument_list|,
name|rem
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_info
argument_list|(
literal|"same %d %d"
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
operator|(
name|int
operator|)
name|rem
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"same: "
argument_list|,
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|count
argument_list|)
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_info
argument_list|(
literal|"diff %d %d"
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
operator|(
name|int
operator|)
name|rem
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"difp: "
argument_list|,
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|count
argument_list|)
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"difo: "
argument_list|,
name|sldns_buffer_at
argument_list|(
name|out
argument_list|,
name|count
argument_list|)
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* check if it 'means the same' */
if|if
condition|(
name|vbmp
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|log_buf
argument_list|(
literal|0
argument_list|,
literal|"orig in hex"
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
literal|0
argument_list|,
literal|"unbound out in hex"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\npacket from unbound (%d):\n"
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|sldns_wire2str_pkt
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s1
condition|?
name|s1
else|:
literal|"null"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\npacket original (%d):\n"
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|=
name|sldns_wire2str_pkt
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s2
condition|?
name|s2
else|:
literal|"null"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* if it had two EDNS sections, skip comparison */
if|if
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|sldns_wire2str_pkt
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|e1
init|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"; EDNS:"
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|&&
name|strstr
argument_list|(
name|e1
operator|+
literal|4
argument_list|,
literal|"; EDNS:"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* compare packets */
name|unit_assert
argument_list|(
name|match_all
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|matches_nolocation
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** check if unbound formerr equals ldns formerr */
end_comment

begin_function
specifier|static
name|void
name|checkformerr
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|sldns_wire2str_pkt
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"Error"
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"error"
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Formerr, but ldns gives packet:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|status
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** performance test message encoding */
end_comment

begin_function
specifier|static
name|void
name|perf_encode
parameter_list|(
name|struct
name|query_info
modifier|*
name|qi
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|,
name|time_t
name|timenow
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|size_t
name|max
init|=
literal|10000
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|,
name|end
decl_stmt|;
name|double
name|dt
decl_stmt|;
name|struct
name|regional
modifier|*
name|r2
init|=
name|regional_create
argument_list|()
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* encode a couple times */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|reply_info_encode
argument_list|(
name|qi
argument_list|,
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|out
argument_list|,
name|timenow
argument_list|,
name|r2
argument_list|,
literal|65535
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|->
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* udp packets should fit */
name|attach_edns_record
argument_list|(
name|out
argument_list|,
name|edns
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|r2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|end
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* time in millisec */
name|dt
operator|=
call|(
name|double
call|)
argument_list|(
name|end
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
argument_list|)
operator|*
literal|1000.
operator|+
operator|(
operator|(
name|double
operator|)
name|end
operator|.
name|tv_usec
operator|-
operator|(
name|double
operator|)
name|start
operator|.
name|tv_usec
operator|)
operator|/
literal|1000.
expr_stmt|;
name|printf
argument_list|(
literal|"[%d] did %u in %g msec for %f encode/sec size %d\n"
argument_list|,
name|num
operator|++
argument_list|,
operator|(
name|unsigned
operator|)
name|max
argument_list|,
name|dt
argument_list|,
operator|(
name|double
operator|)
name|max
operator|/
operator|(
name|dt
operator|/
literal|1000.
operator|)
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|r2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** perf test a packet */
end_comment

begin_function
specifier|static
name|void
name|perftestpkt
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|hex
parameter_list|)
block|{
name|struct
name|query_info
name|qi
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|time_t
name|timenow
init|=
literal|0
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|regional_create
argument_list|()
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|hex_to_buf
argument_list|(
name|pkt
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|id
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<
literal|2
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|&
name|flags
argument_list|,
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ntohs
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reply_info_parse
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
operator|&
name|qi
argument_list|,
operator|&
name|rep
argument_list|,
name|region
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|rbuf
index|[
literal|16
index|]
decl_stmt|;
name|sldns_wire2str_rcode_buf
argument_list|(
name|ret
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbmp
condition|)
name|printf
argument_list|(
literal|"parse code %d: %s\n"
argument_list|,
name|ret
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LDNS_RCODE_FORMERR
condition|)
name|checkformerr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|ret
operator|!=
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perf_encode
argument_list|(
operator|&
name|qi
argument_list|,
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|out
argument_list|,
name|timenow
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
block|}
name|query_info_clear
argument_list|(
operator|&
name|qi
argument_list|)
expr_stmt|;
name|reply_info_parsedelete
argument_list|(
name|rep
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** print packed rrset */
end_comment

begin_function
specifier|static
name|void
name|print_rrset
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|char
name|buf
index|[
literal|65535
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packed_rr_to_string
argument_list|(
name|rrset
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"failedtoconvert %d\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** debug print a packet that failed */
end_comment

begin_function
specifier|static
name|void
name|print_packet_rrsets
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|log_query_info
argument_list|(
literal|0
argument_list|,
literal|"failed query"
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; ANSWER SECTION (%d rrsets)\n"
argument_list|,
operator|(
name|int
operator|)
name|rep
operator|->
name|an_numrrsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"; rrset %d\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|print_rrset
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|";; AUTHORITY SECTION (%d rrsets)\n"
argument_list|,
operator|(
name|int
operator|)
name|rep
operator|->
name|ns_numrrsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"; rrset %d\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|print_rrset
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|";; ADDITIONAL SECTION (%d rrsets)\n"
argument_list|,
operator|(
name|int
operator|)
name|rep
operator|->
name|ar_numrrsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"; rrset %d\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|print_rrset
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|";; packet end\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** check that there is no data element that matches the RRSIG */
end_comment

begin_function
specifier|static
name|int
name|no_data_for_rrsig
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrsig
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_RRSIG
condition|)
continue|continue;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|rrsig
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
comment|/* only name is compared right now */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** check RRSIGs in packet */
end_comment

begin_function
specifier|static
name|void
name|check_the_rrsigs
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* every RRSIG must be matched to an RRset */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
comment|/* see if really a problem, i.e. is there a data 			 * element. */
if|if
condition|(
name|no_data_for_rrsig
argument_list|(
name|rep
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|log_dns_msg
argument_list|(
literal|"rrsig failed for packet"
argument_list|,
name|qinfo
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|print_packet_rrsets
argument_list|(
name|qinfo
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"failed rrset is nr %d\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** test a packet */
end_comment

begin_function
specifier|static
name|void
name|testpkt
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|hex
parameter_list|)
block|{
name|struct
name|query_info
name|qi
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint32_t
name|timenow
init|=
literal|0
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|regional_create
argument_list|()
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|hex_to_buf
argument_list|(
name|pkt
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|id
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<
literal|2
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|&
name|flags
argument_list|,
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ntohs
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reply_info_parse
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
operator|&
name|qi
argument_list|,
operator|&
name|rep
argument_list|,
name|region
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|rbuf
index|[
literal|16
index|]
decl_stmt|;
name|sldns_wire2str_rcode_buf
argument_list|(
name|ret
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbmp
condition|)
name|printf
argument_list|(
literal|"parse code %d: %s\n"
argument_list|,
name|ret
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LDNS_RCODE_FORMERR
condition|)
block|{
name|unit_assert
argument_list|(
operator|!
name|check_formerr_gone
argument_list|)
expr_stmt|;
name|checkformerr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
name|unit_assert
argument_list|(
name|ret
operator|!=
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_formerr_gone
condition|)
block|{
specifier|const
name|size_t
name|lim
init|=
literal|512
decl_stmt|;
name|ret
operator|=
name|reply_info_encode
argument_list|(
operator|&
name|qi
argument_list|,
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|out
argument_list|,
name|timenow
argument_list|,
name|region
argument_list|,
literal|65535
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|.
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* udp packets should fit */
name|attach_edns_record
argument_list|(
name|out
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbmp
condition|)
name|printf
argument_list|(
literal|"inlen %u outlen %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_nosameness
condition|)
name|test_buffers
argument_list|(
name|pkt
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_rrsigs
condition|)
name|check_the_rrsigs
argument_list|(
operator|&
name|qi
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
operator|>
name|lim
condition|)
block|{
name|ret
operator|=
name|reply_info_encode
argument_list|(
operator|&
name|qi
argument_list|,
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|out
argument_list|,
name|timenow
argument_list|,
name|region
argument_list|,
name|lim
operator|-
name|calc_edns_field_size
argument_list|(
operator|&
name|edns
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|.
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|)
expr_stmt|;
name|unit_assert
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* should fit, but with TC */
name|attach_edns_record
argument_list|(
name|out
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|)
operator|!=
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|||
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|)
operator|!=
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|||
name|LDNS_NSCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|)
operator|!=
name|LDNS_NSCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
condition|)
name|unit_assert
argument_list|(
name|LDNS_TC_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* must set TC bit if shortened */
name|unit_assert
argument_list|(
name|sldns_buffer_limit
argument_list|(
name|out
argument_list|)
operator|<=
name|lim
argument_list|)
expr_stmt|;
block|}
block|}
name|query_info_clear
argument_list|(
operator|&
name|qi
argument_list|)
expr_stmt|;
name|reply_info_parsedelete
argument_list|(
name|rep
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** simple test of parsing */
end_comment

begin_function
specifier|static
name|void
name|simpletest
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|)
block|{
comment|/* a root query  drill -q - */
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
literal|" c5 40 01 00 00 01 00 00 00 00 00 00 00 00 02 00 01 "
argument_list|)
expr_stmt|;
comment|/* very small packet */
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
literal|"; 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\n"
literal|";-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n"
literal|"74 0c 85 83 00 01 00 00 00 01 00 00 03 62 6c 61 09 6e 6c 6e    ;          1-  20\n"
literal|"65 74 6c 61 62 73 02 6e 6c 00 00 0f 00 01 09 6e 6c 6e 65 74    ;         21-  40\n"
literal|"6c 61 62 73 02 6e 6c 00 00 06 00 01 00 00 46 50 00 40 04 6f    ;         41-  60\n"
literal|"70 65 6e 09 6e 6c 6e 65 74 6c 61 62 73 02 6e 6c 00 0a 68 6f    ;         61-  80\n"
literal|"73 74 6d 61 73 74 65 72 09 6e 6c 6e 65 74 6c 61 62 73 02 6e    ;         81- 100\n"
literal|"6c 00 77 a1 02 58 00 00 70 80 00 00 1c 20 00 09 3a 80 00 00    ;        101- 120\n"
literal|"46 50\n"
argument_list|)
expr_stmt|;
comment|/* a root reply  drill -w - */
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
literal|" ; 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\n"
literal|" ;-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n"
literal|" 97 3f 81 80 00 01 00 0d 00 00 00 02 00 00 02 00 01 00 00 02    ;          1-  20\n"
literal|" 00 01 00 06 6d 38 00 14 01 49 0c 52 4f 4f 54 2d 53 45 52 56    ;         21-  40\n"
literal|" 45 52 53 03 4e 45 54 00 00 00 02 00 01 00 06 6d 38 00 14 01    ;         41-  60\n"
literal|" 4a 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00 00    ;         61-  80\n"
literal|" 00 02 00 01 00 06 6d 38 00 14 01 4b 0c 52 4f 4f 54 2d 53 45    ;         81- 100\n"
literal|" 52 56 45 52 53 03 4e 45 54 00 00 00 02 00 01 00 06 6d 38 00    ;        101- 120\n"
literal|" 14 01 4c 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54    ;        121- 140\n"
literal|" 00 00 00 02 00 01 00 06 6d 38 00 14 01 4d 0c 52 4f 4f 54 2d    ;        141- 160\n"
literal|" 53 45 52 56 45 52 53 03 4e 45 54 00 00 00 02 00 01 00 06 6d    ;        161- 180\n"
literal|" 38 00 14 01 41 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e    ;        181- 200\n"
literal|" 45 54 00 00 00 02 00 01 00 06 6d 38 00 14 01 42 0c 52 4f 4f    ;        201- 220\n"
literal|" 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00 00 00 02 00 01 00    ;        221- 240\n"
literal|" 06 6d 38 00 14 01 43 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53    ;        241- 260\n"
literal|" 03 4e 45 54 00 00 00 02 00 01 00 06 6d 38 00 14 01 44 0c 52    ;        261- 280\n"
literal|" 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00 00 00 02 00    ;        281- 300\n"
literal|" 01 00 06 6d 38 00 14 01 45 0c 52 4f 4f 54 2d 53 45 52 56 45    ;        301- 320\n"
literal|" 52 53 03 4e 45 54 00 00 00 02 00 01 00 06 6d 38 00 14 01 46    ;        321- 340\n"
literal|" 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00 00 00    ;        341- 360\n"
literal|" 02 00 01 00 06 6d 38 00 14 01 47 0c 52 4f 4f 54 2d 53 45 52    ;        361- 380\n"
literal|" 56 45 52 53 03 4e 45 54 00 00 00 02 00 01 00 06 6d 38 00 14    ;        381- 400\n"
literal|" 01 48 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00    ;        401- 420\n"
literal|" 01 41 0c 52 4f 4f 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00    ;        421- 440\n"
literal|" 00 01 00 01 00 02 64 b9 00 04 c6 29 00 04 01 4a 0c 52 4f 4f    ;        441- 460\n"
literal|" 54 2d 53 45 52 56 45 52 53 03 4e 45 54 00 00 01 00 01 00 02    ;        461- 480\n"
literal|" 64 b9 00 04 c0 3a 80 1e  "
argument_list|)
expr_stmt|;
comment|/* root delegation from unbound trace with new AAAA glue */
name|perftestpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
literal|"55BC84000001000D00000014000002000100000200010007E900001401610C726F6F742D73657276657273036E65740000000200010007E90000040162C01E00000200010007E90000040163C01E00000200010007E90000040164C01E00000200010007E90000040165C01E00000200010007E90000040166C01E00000200010007E90000040167C01E00000200010007E90000040168C01E00000200010007E90000040169C01E00000200010007E9000004016AC01E00000200010007E9000004016BC01E00000200010007E9000004016CC01E00000200010007E9000004016DC01EC01C000100010007E9000004C6290004C03B000100010007E9000004C0E44FC9C04A000100010007E9000004C021040CC059000100010007E900000480080A5AC068000100010007E9000004C0CBE60AC077000100010007E9000004C00505F1C086000100010007E9000004C0702404C095000100010007E9000004803F0235C0A4000100010007E9000004C0249411C0B3000100010007E9000004C03A801EC0C2000100010007E9000004C1000E81C0D1000100010007E9000004C707532AC0E0000100010007E9000004CA0C1B21C01C001C00010007E900001020010503BA3E00000000000000020030C077001C00010007E900001020010500002F0000000000000000000FC095001C00010007E90000102001050000010000"
literal|"00000000803F0235C0B3001C00010007E9000010200105030C2700000000000000020030C0C2001C00010007E9000010200107FD000000000000000000000001C0E0001C00010007E900001020010DC30000000000000000000000350000291000000000000000"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** simple test of parsing, pcat file */
end_comment

begin_function
specifier|static
name|void
name|testfromfile
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|102400
index|]
decl_stmt|;
name|int
name|no
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|perror
argument_list|(
literal|"fname"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
comment|/* comment */
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|10
condition|)
comment|/* skip pcat line numbers. */
continue|continue;
if|if
condition|(
name|vbmp
condition|)
block|{
name|printf
argument_list|(
literal|"test no %d: %s"
argument_list|,
name|no
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|no
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** simple test of parsing, drill file */
end_comment

begin_function
specifier|static
name|void
name|testfromdrillfile
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|sldns_buffer
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
comment|/*  ;-- is used to indicate a new message */
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|102400
index|]
decl_stmt|;
name|char
modifier|*
name|np
init|=
name|buf
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|perror
argument_list|(
literal|"fname"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|np
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|np
operator|-
name|buf
operator|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|np
argument_list|,
literal|";--"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* new entry */
comment|/* test previous */
if|if
condition|(
name|np
operator|!=
name|buf
condition|)
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* set for new entry */
name|np
operator|=
name|buf
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|np
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
comment|/* comment */
continue|continue;
name|np
operator|=
operator|&
name|np
index|[
name|strlen
argument_list|(
name|np
argument_list|)
index|]
expr_stmt|;
block|}
name|testpkt
argument_list|(
name|pkt
argument_list|,
name|alloc
argument_list|,
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msgparse_test
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|origttl
init|=
name|MAX_NEG_TTL
decl_stmt|;
name|sldns_buffer
modifier|*
name|pkt
init|=
name|sldns_buffer_new
argument_list|(
literal|65553
argument_list|)
decl_stmt|;
name|sldns_buffer
modifier|*
name|out
init|=
name|sldns_buffer_new
argument_list|(
literal|65553
argument_list|)
decl_stmt|;
name|struct
name|alloc_cache
name|super_a
decl_stmt|,
name|alloc
decl_stmt|;
name|MAX_NEG_TTL
operator|=
literal|86400
expr_stmt|;
comment|/* init */
name|alloc_init
argument_list|(
operator|&
name|super_a
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alloc_init
argument_list|(
operator|&
name|alloc
argument_list|,
operator|&
name|super_a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unit_show_feature
argument_list|(
literal|"message parse"
argument_list|)
expr_stmt|;
name|simpletest
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* plain hex dumps, like pcat */
name|testfromfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.1"
argument_list|)
expr_stmt|;
name|testfromfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.2"
argument_list|)
expr_stmt|;
name|testfromfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.3"
argument_list|)
expr_stmt|;
comment|/* like from drill -w - */
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.4"
argument_list|)
expr_stmt|;
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.5"
argument_list|)
expr_stmt|;
name|matches_nolocation
operator|=
literal|1
expr_stmt|;
comment|/* RR order not important for the next test */
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.6"
argument_list|)
expr_stmt|;
name|check_rrsigs
operator|=
literal|1
expr_stmt|;
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.7"
argument_list|)
expr_stmt|;
name|check_rrsigs
operator|=
literal|0
expr_stmt|;
name|matches_nolocation
operator|=
literal|0
expr_stmt|;
name|check_formerr_gone
operator|=
literal|1
expr_stmt|;
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.8"
argument_list|)
expr_stmt|;
name|check_formerr_gone
operator|=
literal|0
expr_stmt|;
name|check_rrsigs
operator|=
literal|1
expr_stmt|;
name|check_nosameness
operator|=
literal|1
expr_stmt|;
name|testfromdrillfile
argument_list|(
name|pkt
argument_list|,
operator|&
name|alloc
argument_list|,
name|out
argument_list|,
literal|"testdata/test_packets.9"
argument_list|)
expr_stmt|;
name|check_nosameness
operator|=
literal|0
expr_stmt|;
name|check_rrsigs
operator|=
literal|0
expr_stmt|;
comment|/* cleanup */
name|alloc_clear
argument_list|(
operator|&
name|alloc
argument_list|)
expr_stmt|;
name|alloc_clear
argument_list|(
operator|&
name|super_a
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|MAX_NEG_TTL
operator|=
name|origttl
expr_stmt|;
block|}
end_function

end_unit

