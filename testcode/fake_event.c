begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/fake_event.c - fake event handling that replays existing scenario.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *   * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Event service that replays a scenario.  * This implements the same exported symbols as the files:  * util/netevent.c  * services/listen_dnsport.c  * services/outside_network.c  * But these do not actually access the network or events, instead  * the scenario is played.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"testcode/fake_event.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"testcode/replay.h"
end_include

begin_include
include|#
directive|include
file|"testcode/testpkts.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"sldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"sldns/str2wire.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_struct_decl
struct_decl|struct
name|worker
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|daemon_remote
struct_decl|;
end_struct_decl

begin_comment
comment|/** Global variable: the scenario. Saved here for when event_init is done. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|replay_scenario
modifier|*
name|saved_scenario
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** add timers and the values do not overflow or become negative */
end_comment

begin_function
specifier|static
name|void
name|timeval_add
parameter_list|(
name|struct
name|timeval
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|add
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|d
operator|->
name|tv_sec
operator|+=
name|add
operator|->
name|tv_sec
expr_stmt|;
name|d
operator|->
name|tv_usec
operator|+=
name|add
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|d
operator|->
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|d
operator|->
name|tv_sec
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fake_temp_file
parameter_list|(
specifier|const
name|char
modifier|*
name|adj
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"testbound_%u%s%s.tmp"
argument_list|,
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
argument_list|,
name|adj
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"/tmp/testbound_%u%s%s.tmp"
argument_list|,
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
argument_list|,
name|adj
argument_list|,
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fake_event_init
parameter_list|(
name|struct
name|replay_scenario
modifier|*
name|scen
parameter_list|)
block|{
name|saved_scenario
operator|=
name|scen
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fake_event_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|replay_scenario_delete
argument_list|(
name|saved_scenario
argument_list|)
expr_stmt|;
name|saved_scenario
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/** helper function that logs a sldns_pkt packet to logfile */
end_comment

begin_function
specifier|static
name|void
name|log_pkt
parameter_list|(
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|uint8_t
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|sldns_wire2str_pkt
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|fatal_exit
argument_list|(
literal|"%s: (failed out of memory wire2str_pkt)"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
else|else
block|{
name|log_info
argument_list|(
literal|"%s%s"
argument_list|,
name|desc
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Returns a string describing the event type.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|repevt_string
parameter_list|(
name|enum
name|replay_event_type
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|repevt_nothing
case|:
return|return
literal|"NOTHING"
return|;
case|case
name|repevt_front_query
case|:
return|return
literal|"QUERY"
return|;
case|case
name|repevt_front_reply
case|:
return|return
literal|"CHECK_ANSWER"
return|;
case|case
name|repevt_timeout
case|:
return|return
literal|"TIMEOUT"
return|;
case|case
name|repevt_time_passes
case|:
return|return
literal|"TIME_PASSES"
return|;
case|case
name|repevt_back_reply
case|:
return|return
literal|"REPLY"
return|;
case|case
name|repevt_back_query
case|:
return|return
literal|"CHECK_OUT_QUERY"
return|;
case|case
name|repevt_autotrust_check
case|:
return|return
literal|"CHECK_AUTOTRUST"
return|;
case|case
name|repevt_error
case|:
return|return
literal|"ERROR"
return|;
case|case
name|repevt_assign
case|:
return|return
literal|"ASSIGN"
return|;
case|case
name|repevt_traffic
case|:
return|return
literal|"TRAFFIC"
return|;
case|case
name|repevt_infra_rtt
case|:
return|return
literal|"INFRA_RTT"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_comment
comment|/** delete a fake pending */
end_comment

begin_function
specifier|static
name|void
name|delete_fake_pending
parameter_list|(
name|struct
name|fake_pending
modifier|*
name|pend
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pend
condition|)
return|return;
name|free
argument_list|(
name|pend
operator|->
name|zone
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pend
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** delete a replay answer */
end_comment

begin_function
specifier|static
name|void
name|delete_replay_answer
parameter_list|(
name|struct
name|replay_answer
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
condition|)
return|return;
if|if
condition|(
name|a
operator|->
name|repinfo
operator|.
name|c
condition|)
block|{
name|sldns_buffer_free
argument_list|(
name|a
operator|->
name|repinfo
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|repinfo
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|a
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * return: true if pending query matches the now event.  */
end_comment

begin_function
specifier|static
name|int
name|pending_matches_current
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|entry
modifier|*
modifier|*
name|entry
parameter_list|,
name|struct
name|fake_pending
modifier|*
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
name|p
decl_stmt|;
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|->
name|now
operator|||
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|!=
name|repevt_back_query
operator|||
operator|!
name|runtime
operator|->
name|pending_list
condition|)
return|return
literal|0
return|;
comment|/* see if any of the pending queries matches */
for|for
control|(
name|p
operator|=
name|runtime
operator|->
name|pending_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|runtime
operator|->
name|now
operator|->
name|addrlen
operator|!=
literal|0
operator|&&
name|sockaddr_cmp
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|,
operator|&
name|runtime
operator|->
name|now
operator|->
name|addr
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|addrlen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|e
operator|=
name|find_match
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|match
argument_list|,
name|p
operator|->
name|pkt
argument_list|,
name|p
operator|->
name|pkt_len
argument_list|,
name|p
operator|->
name|transport
argument_list|)
operator|)
condition|)
block|{
operator|*
name|entry
operator|=
name|e
expr_stmt|;
operator|*
name|pend
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Find the range that matches this pending message.  * @param runtime: runtime with current moment, and range list.  * @param entry: returns the pointer to entry that matches.  * @param pend: the pending that the entry must match.  * @return: true if a match is found.  */
end_comment

begin_function
specifier|static
name|int
name|pending_find_match
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|entry
modifier|*
modifier|*
name|entry
parameter_list|,
name|struct
name|fake_pending
modifier|*
name|pend
parameter_list|)
block|{
name|int
name|timenow
init|=
name|runtime
operator|->
name|now
operator|->
name|time_step
decl_stmt|;
name|struct
name|replay_range
modifier|*
name|p
init|=
name|runtime
operator|->
name|scenario
operator|->
name|range_list
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|start_step
operator|<=
name|timenow
operator|&&
name|timenow
operator|<=
name|p
operator|->
name|end_step
operator|&&
operator|(
name|p
operator|->
name|addrlen
operator|==
literal|0
operator|||
name|sockaddr_cmp
argument_list|(
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|,
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|entry
operator|=
name|find_match
argument_list|(
name|p
operator|->
name|match
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|,
name|pend
operator|->
name|transport
argument_list|)
operator|)
condition|)
block|{
name|log_info
argument_list|(
literal|"matched query time %d in range [%d, %d] "
literal|"with entry line %d"
argument_list|,
name|timenow
argument_list|,
name|p
operator|->
name|start_step
argument_list|,
name|p
operator|->
name|end_step
argument_list|,
operator|(
operator|*
name|entry
operator|)
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|addrlen
operator|!=
literal|0
condition|)
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"matched ip"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|log_pkt
argument_list|(
literal|"matched pkt: "
argument_list|,
operator|(
operator|*
name|entry
operator|)
operator|->
name|reply_list
operator|->
name|reply_pkt
argument_list|,
operator|(
operator|*
name|entry
operator|)
operator|->
name|reply_list
operator|->
name|reply_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|p
operator|->
name|next_range
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * See if outgoing pending query matches an entry.  * @param runtime: runtime.  * @param entry: if true, the entry that matches is returned.  * @param pend: if true, the outgoing message that matches is returned.  * @return: true if pending query matches the now event.  */
end_comment

begin_function
specifier|static
name|int
name|pending_matches_range
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|entry
modifier|*
modifier|*
name|entry
parameter_list|,
name|struct
name|fake_pending
modifier|*
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
name|p
init|=
name|runtime
operator|->
name|pending_list
decl_stmt|;
comment|/* slow, O(N*N), but it works as advertised with weird matching */
while|while
condition|(
name|p
condition|)
block|{
name|log_info
argument_list|(
literal|"check of pending"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_find_match
argument_list|(
name|runtime
argument_list|,
name|entry
argument_list|,
name|p
argument_list|)
condition|)
block|{
operator|*
name|pend
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Remove the item from the pending list.  */
end_comment

begin_function
specifier|static
name|void
name|pending_list_delete
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|fake_pending
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
modifier|*
name|prev
init|=
operator|&
name|runtime
operator|->
name|pending_list
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|p
init|=
name|runtime
operator|->
name|pending_list
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
operator|*
name|prev
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|delete_fake_pending
argument_list|(
name|pend
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Fill buffer with reply from the entry.  */
end_comment

begin_function
specifier|static
name|void
name|fill_buffer_with_reply
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|entry
modifier|*
name|entry
parameter_list|,
name|uint8_t
modifier|*
name|q
parameter_list|,
name|size_t
name|qlen
parameter_list|)
block|{
name|uint8_t
modifier|*
name|c
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|log_assert
argument_list|(
name|entry
operator|&&
name|entry
operator|->
name|reply_list
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|reply_list
operator|->
name|reply_from_hex
condition|)
block|{
name|c
operator|=
name|sldns_buffer_begin
argument_list|(
name|entry
operator|->
name|reply_list
operator|->
name|reply_from_hex
argument_list|)
expr_stmt|;
name|clen
operator|=
name|sldns_buffer_limit
argument_list|(
name|entry
operator|->
name|reply_list
operator|->
name|reply_from_hex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|entry
operator|->
name|reply_list
operator|->
name|reply_pkt
expr_stmt|;
name|clen
operator|=
name|entry
operator|->
name|reply_list
operator|->
name|reply_len
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|q
condition|)
name|adjust_packet
argument_list|(
name|entry
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|clen
argument_list|,
name|q
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buffer
argument_list|,
name|c
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_flip
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform range entry on pending message.  * @param runtime: runtime buffer size preference.  * @param entry: entry that codes for the reply to do.  * @param pend: pending query that is answered, callback called.  */
end_comment

begin_function
specifier|static
name|void
name|answer_callback_from_entry
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|entry
modifier|*
name|entry
parameter_list|,
name|struct
name|fake_pending
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|comm_point
name|c
decl_stmt|;
name|struct
name|comm_reply
name|repinfo
decl_stmt|;
name|void
modifier|*
name|cb_arg
init|=
name|pend
operator|->
name|cb_arg
decl_stmt|;
name|comm_point_callback_t
modifier|*
name|cb
init|=
name|pend
operator|->
name|callback
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|.
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|runtime
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|type
operator|=
name|comm_udp
expr_stmt|;
if|if
condition|(
name|pend
operator|->
name|transport
operator|==
name|transport_tcp
condition|)
name|c
operator|.
name|type
operator|=
name|comm_tcp
expr_stmt|;
name|fill_buffer_with_reply
argument_list|(
name|c
operator|.
name|buffer
argument_list|,
name|entry
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
name|repinfo
operator|.
name|c
operator|=
operator|&
name|c
expr_stmt|;
name|repinfo
operator|.
name|addrlen
operator|=
name|pend
operator|->
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|serviced
condition|)
name|pending_list_delete
argument_list|(
name|runtime
argument_list|,
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|cb
call|)
argument_list|(
operator|&
name|c
argument_list|,
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
operator|&
name|repinfo
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"testbound: unexpected: callback returned 1"
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_free
argument_list|(
name|c
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Check the now moment answer check event */
end_comment

begin_function
specifier|static
name|void
name|answer_check_it
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|replay_answer
modifier|*
name|ans
init|=
name|runtime
operator|->
name|answer_list
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|log_assert
argument_list|(
name|runtime
operator|&&
name|runtime
operator|->
name|now
operator|&&
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|==
name|repevt_front_reply
argument_list|)
expr_stmt|;
while|while
condition|(
name|ans
condition|)
block|{
name|enum
name|transport_type
name|tr
init|=
name|transport_tcp
decl_stmt|;
if|if
condition|(
name|ans
operator|->
name|repinfo
operator|.
name|c
operator|->
name|type
operator|==
name|comm_udp
condition|)
name|tr
operator|=
name|transport_udp
expr_stmt|;
if|if
condition|(
operator|(
name|runtime
operator|->
name|now
operator|->
name|addrlen
operator|==
literal|0
operator|||
name|sockaddr_cmp
argument_list|(
operator|&
name|runtime
operator|->
name|now
operator|->
name|addr
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|addrlen
argument_list|,
operator|&
name|ans
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|ans
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|find_match
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|match
argument_list|,
name|ans
operator|->
name|pkt
argument_list|,
name|ans
operator|->
name|pkt_len
argument_list|,
name|tr
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"testbound matched event entry from line %d"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|match
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|ans
operator|->
name|next
expr_stmt|;
else|else
name|runtime
operator|->
name|answer_list
operator|=
name|ans
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ans
operator|->
name|next
condition|)
name|runtime
operator|->
name|answer_last
operator|=
name|prev
expr_stmt|;
name|delete_replay_answer
argument_list|(
name|ans
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|prev
operator|=
name|ans
expr_stmt|;
name|ans
operator|=
name|ans
operator|->
name|next
expr_stmt|;
block|}
block|}
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"testbound: not matched"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create commpoint (as return address) for a fake incoming query.  */
end_comment

begin_function
specifier|static
name|void
name|fake_front_query
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|todo
parameter_list|)
block|{
name|struct
name|comm_reply
name|repinfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|repinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|repinfo
argument_list|)
argument_list|)
expr_stmt|;
name|repinfo
operator|.
name|c
operator|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
expr_stmt|;
name|repinfo
operator|.
name|addrlen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|todo
operator|->
name|addrlen
operator|!=
literal|0
condition|)
block|{
name|repinfo
operator|.
name|addrlen
operator|=
name|todo
operator|->
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|todo
operator|->
name|addr
argument_list|,
name|todo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
block|}
name|repinfo
operator|.
name|c
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|repinfo
operator|.
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|runtime
expr_stmt|;
name|repinfo
operator|.
name|c
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|runtime
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|todo
operator|->
name|match
operator|->
name|match_transport
operator|==
name|transport_tcp
condition|)
name|repinfo
operator|.
name|c
operator|->
name|type
operator|=
name|comm_tcp
expr_stmt|;
else|else
name|repinfo
operator|.
name|c
operator|->
name|type
operator|=
name|comm_udp
expr_stmt|;
name|fill_buffer_with_reply
argument_list|(
name|repinfo
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|todo
operator|->
name|match
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: incoming QUERY"
argument_list|)
expr_stmt|;
name|log_pkt
argument_list|(
literal|"query pkt"
argument_list|,
name|todo
operator|->
name|match
operator|->
name|reply_list
operator|->
name|reply_pkt
argument_list|,
name|todo
operator|->
name|match
operator|->
name|reply_list
operator|->
name|reply_len
argument_list|)
expr_stmt|;
comment|/* call the callback for incoming queries */
if|if
condition|(
call|(
modifier|*
name|runtime
operator|->
name|callback_query
call|)
argument_list|(
name|repinfo
operator|.
name|c
argument_list|,
name|runtime
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
operator|&
name|repinfo
argument_list|)
condition|)
block|{
comment|/* send immediate reply */
name|comm_point_send_reply
argument_list|(
operator|&
name|repinfo
argument_list|)
expr_stmt|;
block|}
comment|/* clear it again, in case copy not done properly */
name|memset
argument_list|(
operator|&
name|repinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|repinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform callback for fake pending message.  */
end_comment

begin_function
specifier|static
name|void
name|fake_pending_callback
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|todo
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
name|p
init|=
name|runtime
operator|->
name|pending_list
decl_stmt|;
name|struct
name|comm_reply
name|repinfo
decl_stmt|;
name|struct
name|comm_point
name|c
decl_stmt|;
name|void
modifier|*
name|cb_arg
decl_stmt|;
name|comm_point_callback_t
modifier|*
name|cb
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal_exit
argument_list|(
literal|"No pending queries."
argument_list|)
expr_stmt|;
name|cb_arg
operator|=
name|p
operator|->
name|cb_arg
expr_stmt|;
name|cb
operator|=
name|p
operator|->
name|callback
expr_stmt|;
name|c
operator|.
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|runtime
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|c
operator|.
name|type
operator|=
name|comm_udp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|transport
operator|==
name|transport_tcp
condition|)
name|c
operator|.
name|type
operator|=
name|comm_tcp
expr_stmt|;
if|if
condition|(
name|todo
operator|->
name|evt_type
operator|==
name|repevt_back_reply
operator|&&
name|todo
operator|->
name|match
condition|)
block|{
name|fill_buffer_with_reply
argument_list|(
name|c
operator|.
name|buffer
argument_list|,
name|todo
operator|->
name|match
argument_list|,
name|p
operator|->
name|pkt
argument_list|,
name|p
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
block|}
name|repinfo
operator|.
name|c
operator|=
operator|&
name|c
expr_stmt|;
name|repinfo
operator|.
name|addrlen
operator|=
name|p
operator|->
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|serviced
condition|)
name|pending_list_delete
argument_list|(
name|runtime
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|cb
call|)
argument_list|(
operator|&
name|c
argument_list|,
name|cb_arg
argument_list|,
name|error
argument_list|,
operator|&
name|repinfo
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"unexpected: pending callback returned 1"
argument_list|)
expr_stmt|;
block|}
comment|/* delete the pending item. */
name|sldns_buffer_free
argument_list|(
name|c
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** pass time */
end_comment

begin_function
specifier|static
name|void
name|moment_assign
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
name|char
modifier|*
name|value
init|=
name|macro_process
argument_list|(
name|runtime
operator|->
name|vars
argument_list|,
name|runtime
argument_list|,
name|mom
operator|->
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|fatal_exit
argument_list|(
literal|"could not process macro step %d"
argument_list|,
name|mom
operator|->
name|time_step
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"assign %s = %s"
argument_list|,
name|mom
operator|->
name|variable
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro_assign
argument_list|(
name|runtime
operator|->
name|vars
argument_list|,
name|mom
operator|->
name|variable
argument_list|,
name|value
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory storing macro"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|macro_print_debug
argument_list|(
name|runtime
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** pass time */
end_comment

begin_function
specifier|static
name|void
name|time_passes
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|t
decl_stmt|;
name|struct
name|timeval
name|tv
init|=
name|mom
operator|->
name|elapse
decl_stmt|;
if|if
condition|(
name|mom
operator|->
name|string
condition|)
block|{
name|char
modifier|*
name|xp
init|=
name|macro_process
argument_list|(
name|runtime
operator|->
name|vars
argument_list|,
name|runtime
argument_list|,
name|mom
operator|->
name|string
argument_list|)
decl_stmt|;
name|double
name|sec
decl_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
name|fatal_exit
argument_list|(
literal|"could not macro expand %s"
argument_list|,
name|mom
operator|->
name|string
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"EVAL %s"
argument_list|,
name|mom
operator|->
name|string
argument_list|)
expr_stmt|;
name|sec
operator|=
name|atof
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|tv
operator|.
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|sec
operator|-
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000.
operator|+
literal|0.5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|timeval_add
argument_list|(
operator|&
name|runtime
operator|->
name|now_tv
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|runtime
operator|->
name|now_secs
operator|=
operator|(
name|time_t
operator|)
name|runtime
operator|->
name|now_tv
operator|.
name|tv_sec
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|log_info
argument_list|(
literal|"elapsed %d.%6.6d  now %d.%6.6d"
argument_list|,
operator|(
name|int
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|tv
operator|.
name|tv_usec
argument_list|,
operator|(
name|int
operator|)
name|runtime
operator|->
name|now_tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|runtime
operator|->
name|now_tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* see if any timers have fired; and run them */
while|while
condition|(
operator|(
name|t
operator|=
name|replay_get_oldest_timer
argument_list|(
name|runtime
argument_list|)
operator|)
condition|)
block|{
name|t
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|log_info
argument_list|(
literal|"fake_timer callback"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_timer
argument_list|(
name|t
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|t
operator|->
name|cb
call|)
argument_list|(
name|t
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** check autotrust file contents */
end_comment

begin_function
specifier|static
name|void
name|autotrust_check
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|,
name|struct
name|replay_moment
modifier|*
name|mom
parameter_list|)
block|{
name|char
name|name
index|[
literal|1024
index|]
decl_stmt|,
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|,
name|oke
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|expanded
decl_stmt|;
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|log_assert
argument_list|(
name|mom
operator|->
name|autotrust_id
argument_list|)
expr_stmt|;
name|fake_temp_file
argument_list|(
literal|"_auto_"
argument_list|,
name|mom
operator|->
name|autotrust_id
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
name|fatal_exit
argument_list|(
literal|"could not open %s: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mom
operator|->
name|file_content
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"autotrust check failed, could not read line"
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"file %s, line %d"
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"should be: %s"
argument_list|,
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"autotrust_check failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|expanded
operator|=
name|macro_process
argument_list|(
name|runtime
operator|->
name|vars
argument_list|,
name|runtime
argument_list|,
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expanded
condition|)
name|fatal_exit
argument_list|(
literal|"could not expand macro line %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|7
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|str
argument_list|,
name|expanded
argument_list|)
operator|!=
literal|0
condition|)
name|log_info
argument_list|(
literal|"expanded '%s' to '%s'"
argument_list|,
name|p
operator|->
name|str
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|expanded
argument_list|,
name|line
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"mismatch in file %s, line %d"
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"file has : %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"should be: %s"
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|oke
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%2d ok : %s\n"
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"autotrust check failed, extra lines in %s after %d"
argument_list|,
name|name
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file has: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
do|;
name|oke
operator|=
literal|0
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oke
condition|)
name|fatal_exit
argument_list|(
literal|"autotrust_check STEP %d failed"
argument_list|,
name|mom
operator|->
name|time_step
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"autotrust %s is OK"
argument_list|,
name|mom
operator|->
name|autotrust_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Store RTT in infra cache */
end_comment

begin_function
specifier|static
name|void
name|do_infra_rtt
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|replay_moment
modifier|*
name|now
init|=
name|runtime
operator|->
name|now
decl_stmt|;
name|int
name|rto
decl_stmt|;
name|size_t
name|dplen
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|dp
init|=
name|sldns_str2wire_dname
argument_list|(
name|now
operator|->
name|variable
argument_list|,
operator|&
name|dplen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
name|fatal_exit
argument_list|(
literal|"cannot parse %s"
argument_list|,
name|now
operator|->
name|variable
argument_list|)
expr_stmt|;
name|rto
operator|=
name|infra_rtt_update
argument_list|(
name|runtime
operator|->
name|infra
argument_list|,
operator|&
name|now
operator|->
name|addr
argument_list|,
name|now
operator|->
name|addrlen
argument_list|,
name|dp
argument_list|,
name|dplen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|atoi
argument_list|(
name|now
operator|->
name|string
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|runtime
operator|->
name|now_secs
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"INFRA_RTT for"
argument_list|,
operator|&
name|now
operator|->
name|addr
argument_list|,
name|now
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"INFRA_RTT(%s roundtrip %d): rto of %d"
argument_list|,
name|now
operator|->
name|variable
argument_list|,
name|atoi
argument_list|(
name|now
operator|->
name|string
argument_list|)
argument_list|,
name|rto
argument_list|)
expr_stmt|;
if|if
condition|(
name|rto
operator|==
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"infra_rtt_update failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** perform exponential backoff on the timout */
end_comment

begin_function
specifier|static
name|void
name|expon_timeout_backoff
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
name|p
init|=
name|runtime
operator|->
name|pending_list
decl_stmt|;
name|int
name|rtt
decl_stmt|,
name|vs
decl_stmt|;
name|uint8_t
name|edns_lame_known
decl_stmt|;
name|int
name|last_rtt
decl_stmt|,
name|rto
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|/* no pending packet to backoff */
if|if
condition|(
operator|!
name|infra_host
argument_list|(
name|runtime
operator|->
name|infra
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|,
name|p
operator|->
name|zone
argument_list|,
name|p
operator|->
name|zonelen
argument_list|,
name|runtime
operator|->
name|now_secs
argument_list|,
operator|&
name|vs
argument_list|,
operator|&
name|edns_lame_known
argument_list|,
operator|&
name|rtt
argument_list|)
condition|)
return|return;
name|last_rtt
operator|=
name|rtt
expr_stmt|;
name|rto
operator|=
name|infra_rtt_update
argument_list|(
name|runtime
operator|->
name|infra
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|,
name|p
operator|->
name|zone
argument_list|,
name|p
operator|->
name|zonelen
argument_list|,
name|p
operator|->
name|qtype
argument_list|,
operator|-
literal|1
argument_list|,
name|last_rtt
argument_list|,
name|runtime
operator|->
name|now_secs
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"infra_rtt_update returned rto %d"
argument_list|,
name|rto
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Advance to the next moment.  */
end_comment

begin_function
specifier|static
name|void
name|advance_moment
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|runtime
operator|->
name|now
condition|)
name|runtime
operator|->
name|now
operator|=
name|runtime
operator|->
name|scenario
operator|->
name|mom_first
expr_stmt|;
else|else
name|runtime
operator|->
name|now
operator|=
name|runtime
operator|->
name|now
operator|->
name|mom_next
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform actions or checks determined by the moment.  * Also advances the time by one step.  * @param runtime: scenario runtime information.  */
end_comment

begin_function
specifier|static
name|void
name|do_moment_and_advance
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|replay_moment
modifier|*
name|mom
decl_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|->
name|now
condition|)
block|{
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
condition|)
block|{
case|case
name|repevt_nothing
case|:
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_front_query
case|:
comment|/* advance moment before doing the step, so that the next 		   moment which may check some result of the mom step 		   can catch those results. */
name|mom
operator|=
name|runtime
operator|->
name|now
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|fake_front_query
argument_list|(
name|runtime
argument_list|,
name|mom
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_front_reply
case|:
if|if
condition|(
name|runtime
operator|->
name|answer_list
condition|)
name|log_err
argument_list|(
literal|"testbound: There are unmatched answers."
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"testbound: query answer not matched"
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_timeout
case|:
name|mom
operator|=
name|runtime
operator|->
name|now
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|expon_timeout_backoff
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|fake_pending_callback
argument_list|(
name|runtime
argument_list|,
name|mom
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_back_reply
case|:
name|mom
operator|=
name|runtime
operator|->
name|now
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|fake_pending_callback
argument_list|(
name|runtime
argument_list|,
name|mom
argument_list|,
name|NETEVENT_NOERROR
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_back_query
case|:
comment|/* Back queries are matched when they are sent out. */
name|log_err
argument_list|(
literal|"No query matching the current moment was sent."
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"testbound: back query not matched"
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_error
case|:
name|mom
operator|=
name|runtime
operator|->
name|now
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|fake_pending_callback
argument_list|(
name|runtime
argument_list|,
name|mom
argument_list|,
name|NETEVENT_CLOSED
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_time_passes
case|:
name|time_passes
argument_list|(
name|runtime
argument_list|,
name|runtime
operator|->
name|now
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_autotrust_check
case|:
name|autotrust_check
argument_list|(
name|runtime
argument_list|,
name|runtime
operator|->
name|now
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_assign
case|:
name|moment_assign
argument_list|(
name|runtime
argument_list|,
name|runtime
operator|->
name|now
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_traffic
case|:
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|repevt_infra_rtt
case|:
name|do_infra_rtt
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_exit
argument_list|(
literal|"testbound: unknown event type %d"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** run the scenario in event callbacks */
end_comment

begin_function
specifier|static
name|void
name|run_scenario
parameter_list|(
name|struct
name|replay_runtime
modifier|*
name|runtime
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|pending
init|=
name|NULL
decl_stmt|;
name|int
name|max_rounds
init|=
literal|5000
decl_stmt|;
name|int
name|rounds
init|=
literal|0
decl_stmt|;
name|runtime
operator|->
name|now
operator|=
name|runtime
operator|->
name|scenario
operator|->
name|mom_first
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: entering fake runloop"
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* if moment matches pending query do it. */
comment|/* else if moment matches given answer, do it */
comment|/* else if precoded_range matches pending, do it */
comment|/* else do the current moment */
if|if
condition|(
name|pending_matches_current
argument_list|(
name|runtime
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|pending
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"testbound: do STEP %d CHECK_OUT_QUERY"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|copy_id
condition|)
name|answer_callback_from_entry
argument_list|(
name|runtime
argument_list|,
name|entry
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|runtime
operator|->
name|answer_list
operator|&&
name|runtime
operator|->
name|now
operator|&&
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|==
name|repevt_front_reply
condition|)
block|{
name|answer_check_it
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pending_matches_range
argument_list|(
name|runtime
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|pending
argument_list|)
condition|)
block|{
name|answer_callback_from_entry
argument_list|(
name|runtime
argument_list|,
name|entry
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_moment_and_advance
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"testbound: end of event stage"
argument_list|)
expr_stmt|;
name|rounds
operator|++
expr_stmt|;
if|if
condition|(
name|rounds
operator|>
name|max_rounds
condition|)
name|fatal_exit
argument_list|(
literal|"testbound: too many rounds, it loops."
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|runtime
operator|->
name|now
condition|)
do|;
if|if
condition|(
name|runtime
operator|->
name|pending_list
condition|)
block|{
name|struct
name|fake_pending
modifier|*
name|p
decl_stmt|;
name|log_err
argument_list|(
literal|"testbound: there are still messages pending."
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|runtime
operator|->
name|pending_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|log_pkt
argument_list|(
literal|"pending msg"
argument_list|,
name|p
operator|->
name|pkt
argument_list|,
name|p
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"pending to"
argument_list|,
operator|&
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|addrlen
argument_list|)
expr_stmt|;
block|}
name|fatal_exit
argument_list|(
literal|"testbound: there are still messages pending."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|runtime
operator|->
name|answer_list
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"testbound: there are unmatched answers."
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"testbound: exiting fake runloop."
argument_list|)
expr_stmt|;
name|runtime
operator|->
name|exit_cleanly
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********** Dummy routines ***********/
end_comment

begin_decl_stmt
name|struct
name|listen_dnsport
modifier|*
name|listen_create
argument_list|(
expr|struct
name|comm_base
operator|*
name|base
argument_list|,
expr|struct
name|listen_port
operator|*
name|ATTR_UNUSED
argument_list|(
name|ports
argument_list|)
argument_list|,
name|size_t
name|bufsize
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|tcp_accept_count
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|sslctx
argument_list|)
argument_list|,
expr|struct
name|dt_env
operator|*
name|ATTR_UNUSED
argument_list|(
name|dtenv
argument_list|)
argument_list|,
name|comm_point_callback_t
operator|*
name|cb
argument_list|,
name|void
operator|*
name|cb_arg
argument_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|base
decl_stmt|;
name|struct
name|listen_dnsport
modifier|*
name|l
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|listen_dnsport
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
name|NULL
return|;
name|l
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|l
operator|->
name|udp_buff
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
operator|->
name|udp_buff
condition|)
block|{
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|runtime
operator|->
name|callback_query
operator|=
name|cb
expr_stmt|;
name|runtime
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|runtime
operator|->
name|bufsize
operator|=
name|bufsize
expr_stmt|;
return|return
name|l
return|;
block|}
end_decl_stmt

begin_function
name|void
name|listen_delete
parameter_list|(
name|struct
name|listen_dnsport
modifier|*
name|listen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|listen
condition|)
return|return;
name|sldns_buffer_free
argument_list|(
name|listen
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|listen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|comm_base
modifier|*
name|comm_base_create
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|sigs
parameter_list|)
parameter_list|)
block|{
comment|/* we return the runtime structure instead. */
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|replay_runtime
argument_list|)
argument_list|)
decl_stmt|;
name|runtime
operator|->
name|scenario
operator|=
name|saved_scenario
expr_stmt|;
name|runtime
operator|->
name|vars
operator|=
name|macro_store_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|->
name|vars
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|comm_base
operator|*
operator|)
name|runtime
return|;
block|}
end_function

begin_function
name|void
name|comm_base_delete
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|b
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|replay_answer
modifier|*
name|a
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|struct
name|fake_timer
modifier|*
name|t
decl_stmt|,
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
operator|!
name|runtime
condition|)
return|return;
name|runtime
operator|->
name|scenario
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|runtime
operator|->
name|pending_list
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|delete_fake_pending
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|a
operator|=
name|runtime
operator|->
name|answer_list
expr_stmt|;
while|while
condition|(
name|a
condition|)
block|{
name|na
operator|=
name|a
operator|->
name|next
expr_stmt|;
name|delete_replay_answer
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|na
expr_stmt|;
block|}
name|t
operator|=
name|runtime
operator|->
name|timer_list
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|nt
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|nt
expr_stmt|;
block|}
name|macro_store_delete
argument_list|(
name|runtime
operator|->
name|vars
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_timept
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|,
name|time_t
modifier|*
modifier|*
name|tt
parameter_list|,
name|struct
name|timeval
modifier|*
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|b
decl_stmt|;
operator|*
name|tt
operator|=
operator|&
name|runtime
operator|->
name|now_secs
expr_stmt|;
operator|*
name|tv
operator|=
operator|&
name|runtime
operator|->
name|now_tv
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_dispatch
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|b
decl_stmt|;
name|run_scenario
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|runtime
operator|->
name|sig_cb
condition|)
call|(
modifier|*
name|runtime
operator|->
name|sig_cb
call|)
argument_list|(
name|SIGTERM
argument_list|,
name|runtime
operator|->
name|sig_cb_arg
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* OK exit when LIBEVENT_SIGNAL_PROBLEM exists */
block|}
end_function

begin_function
name|void
name|comm_base_exit
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|->
name|exit_cleanly
condition|)
block|{
comment|/* some sort of failure */
name|fatal_exit
argument_list|(
literal|"testbound: comm_base_exit was called."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|comm_signal
modifier|*
name|comm_signal_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|base
decl_stmt|;
name|runtime
operator|->
name|sig_cb
operator|=
name|callback
expr_stmt|;
name|runtime
operator|->
name|sig_cb_arg
operator|=
name|cb_arg
expr_stmt|;
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_signal
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|comm_signal_bind
argument_list|(
expr|struct
name|comm_signal
operator|*
name|ATTR_UNUSED
argument_list|(
name|comsig
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|sig
argument_list|)
argument_list|)
block|{
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|void
name|comm_signal_delete
parameter_list|(
name|struct
name|comm_signal
modifier|*
name|comsig
parameter_list|)
block|{
name|free
argument_list|(
name|comsig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_send_reply
parameter_list|(
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
name|struct
name|replay_answer
modifier|*
name|ans
init|=
operator|(
expr|struct
name|replay_answer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|replay_answer
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|repinfo
operator|->
name|c
operator|->
name|ev
decl_stmt|;
name|log_info
argument_list|(
literal|"testbound: comm_point_send_reply fake"
argument_list|)
expr_stmt|;
comment|/* dump it into the todo list */
name|log_assert
argument_list|(
name|ans
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ans
operator|->
name|repinfo
argument_list|,
name|repinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_reply
argument_list|)
argument_list|)
expr_stmt|;
name|ans
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|runtime
operator|->
name|answer_last
condition|)
name|runtime
operator|->
name|answer_last
operator|->
name|next
operator|=
name|ans
expr_stmt|;
else|else
name|runtime
operator|->
name|answer_list
operator|=
name|ans
expr_stmt|;
name|runtime
operator|->
name|answer_last
operator|=
name|ans
expr_stmt|;
comment|/* try to parse packet */
name|ans
operator|->
name|pkt
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|ans
operator|->
name|repinfo
operator|.
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|ans
operator|->
name|repinfo
operator|.
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|ans
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|ans
operator|->
name|repinfo
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ans
operator|->
name|pkt
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|log_pkt
argument_list|(
literal|"reply pkt: "
argument_list|,
name|ans
operator|->
name|pkt
argument_list|,
name|ans
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_drop_reply
parameter_list|(
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"comm_point_drop_reply fake"
argument_list|)
expr_stmt|;
if|if
condition|(
name|repinfo
operator|->
name|c
condition|)
block|{
name|sldns_buffer_free
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repinfo
operator|->
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|outside_network
modifier|*
name|outside_network_create
argument_list|(
expr|struct
name|comm_base
operator|*
name|base
argument_list|,
name|size_t
name|bufsize
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|num_ports
argument_list|)
argument_list|,
name|char
operator|*
operator|*
name|ATTR_UNUSED
argument_list|(
name|ifs
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|num_ifs
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|do_ip4
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|do_ip6
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|num_tcp
argument_list|)
argument_list|,
expr|struct
name|infra_cache
operator|*
name|infra
argument_list|,
expr|struct
name|ub_randstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|rnd
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|use_caps_for_id
argument_list|)
argument_list|,
name|int
operator|*
name|ATTR_UNUSED
argument_list|(
name|availports
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|numavailports
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|unwanted_threshold
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|unwanted_action
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|unwanted_param
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|do_udp
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|sslctx
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|delayclose
argument_list|)
argument_list|,
expr|struct
name|dt_env
operator|*
name|ATTR_UNUSED
argument_list|(
name|dtenv
argument_list|)
argument_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|base
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|outside_network
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|unwanted_action
expr_stmt|;
if|if
condition|(
operator|!
name|outnet
condition|)
return|return
name|NULL
return|;
name|runtime
operator|->
name|infra
operator|=
name|infra
expr_stmt|;
name|outnet
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|outnet
operator|->
name|udp_buff
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outnet
operator|->
name|udp_buff
condition|)
block|{
name|free
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|outnet
return|;
block|}
end_decl_stmt

begin_function
name|void
name|outside_network_delete
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
if|if
condition|(
operator|!
name|outnet
condition|)
return|return;
name|sldns_buffer_free
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|outside_network_quit_prepare
argument_list|(
expr|struct
name|outside_network
operator|*
name|ATTR_UNUSED
argument_list|(
name|outnet
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_function
name|struct
name|pending
modifier|*
name|pending_udp_query
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|int
name|timeout
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|sq
operator|->
name|outnet
operator|->
name|base
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|fake_pending
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fake_pending
argument_list|)
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|pend
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|sldns_buffer_capacity
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pend
operator|->
name|addr
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|pend
operator|->
name|addrlen
operator|=
name|sq
operator|->
name|addrlen
expr_stmt|;
name|pend
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|pend
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|pend
operator|->
name|timeout
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|pend
operator|->
name|transport
operator|=
name|transport_udp
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|serviced
operator|=
literal|0
expr_stmt|;
name|pend
operator|->
name|runtime
operator|=
name|runtime
expr_stmt|;
name|pend
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|pkt
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|log_pkt
argument_list|(
literal|"pending udp pkt: "
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
comment|/* see if it matches the current moment */
if|if
condition|(
name|runtime
operator|->
name|now
operator|&&
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|==
name|repevt_back_query
operator|&&
operator|(
name|runtime
operator|->
name|now
operator|->
name|addrlen
operator|==
literal|0
operator|||
name|sockaddr_cmp
argument_list|(
operator|&
name|runtime
operator|->
name|now
operator|->
name|addr
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|addrlen
argument_list|,
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|find_match
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|match
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|,
name|pend
operator|->
name|transport
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"testbound: matched pending to event. "
literal|"advance time between events."
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
comment|/* still create the pending, because we need it to callback */
block|}
name|log_info
argument_list|(
literal|"testbound: created fake pending"
argument_list|)
expr_stmt|;
comment|/* add to list */
name|pend
operator|->
name|next
operator|=
name|runtime
operator|->
name|pending_list
expr_stmt|;
name|runtime
operator|->
name|pending_list
operator|=
name|pend
expr_stmt|;
return|return
operator|(
expr|struct
name|pending
operator|*
operator|)
name|pend
return|;
block|}
end_function

begin_function
name|struct
name|waiting_tcp
modifier|*
name|pending_tcp_query
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|int
name|timeout
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|sq
operator|->
name|outnet
operator|->
name|base
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|fake_pending
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fake_pending
argument_list|)
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|pend
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|sldns_buffer_capacity
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pend
operator|->
name|addr
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|pend
operator|->
name|addrlen
operator|=
name|sq
operator|->
name|addrlen
expr_stmt|;
name|pend
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|pend
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|pend
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|pend
operator|->
name|transport
operator|=
name|transport_tcp
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|runtime
operator|=
name|runtime
expr_stmt|;
name|pend
operator|->
name|serviced
operator|=
literal|0
expr_stmt|;
name|pend
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|pkt
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|log_pkt
argument_list|(
literal|"pending tcp pkt: "
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
comment|/* see if it matches the current moment */
if|if
condition|(
name|runtime
operator|->
name|now
operator|&&
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|==
name|repevt_back_query
operator|&&
operator|(
name|runtime
operator|->
name|now
operator|->
name|addrlen
operator|==
literal|0
operator|||
name|sockaddr_cmp
argument_list|(
operator|&
name|runtime
operator|->
name|now
operator|->
name|addr
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|addrlen
argument_list|,
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|find_match
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|match
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|,
name|pend
operator|->
name|transport
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"testbound: matched pending to event. "
literal|"advance time between events."
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
comment|/* still create the pending, because we need it to callback */
block|}
name|log_info
argument_list|(
literal|"testbound: created fake pending"
argument_list|)
expr_stmt|;
comment|/* add to list */
name|pend
operator|->
name|next
operator|=
name|runtime
operator|->
name|pending_list
expr_stmt|;
name|runtime
operator|->
name|pending_list
operator|=
name|pend
expr_stmt|;
return|return
operator|(
expr|struct
name|waiting_tcp
operator|*
operator|)
name|pend
return|;
block|}
end_function

begin_function
name|struct
name|serviced_query
modifier|*
name|outnet_serviced_query
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|want_dnssec
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|nocaps
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|tcp_upstream
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|ssl_upstream
parameter_list|)
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|sldns_buffer
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|buff
parameter_list|)
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|outnet
operator|->
name|base
decl_stmt|;
name|struct
name|fake_pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|fake_pending
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fake_pending
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|z
index|[
literal|256
index|]
decl_stmt|;
name|log_assert
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_OPS
argument_list|,
literal|"pending serviced query"
argument_list|,
name|qname
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|dname_str
argument_list|(
name|zone
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"pending serviced query zone %s flags%s%s%s%s"
argument_list|,
name|z
argument_list|,
operator|(
name|flags
operator|&
name|BIT_RD
operator|)
condition|?
literal|" RD"
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|BIT_CD
operator|)
condition|?
literal|" CD"
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
operator|~
operator|(
name|BIT_RD
operator||
name|BIT_CD
operator|)
operator|)
condition|?
literal|" MORE"
else|:
literal|""
argument_list|,
operator|(
name|dnssec
operator|)
condition|?
literal|" DO"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* create packet with EDNS */
name|pend
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id */
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* qdcount */
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ancount */
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nscount */
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* arcount */
name|sldns_buffer_write
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
comment|/* add edns */
name|struct
name|edns_data
name|edns
decl_stmt|;
name|edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnssec
condition|)
name|edns
operator|.
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
name|attach_edns_record
argument_list|(
name|pend
operator|->
name|buffer
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|pend
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|pend
operator|->
name|zone
operator|=
name|memdup
argument_list|(
name|zone
argument_list|,
name|zonelen
argument_list|)
expr_stmt|;
name|pend
operator|->
name|zonelen
operator|=
name|zonelen
expr_stmt|;
name|pend
operator|->
name|qtype
operator|=
operator|(
name|int
operator|)
name|qtype
expr_stmt|;
name|log_assert
argument_list|(
name|pend
operator|->
name|zone
argument_list|)
expr_stmt|;
name|pend
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|pend
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|pend
operator|->
name|timeout
operator|=
name|UDP_AUTH_QUERY_TIMEOUT
expr_stmt|;
name|pend
operator|->
name|transport
operator|=
name|transport_udp
expr_stmt|;
comment|/* pretend UDP */
name|pend
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|runtime
operator|=
name|runtime
expr_stmt|;
name|pend
operator|->
name|serviced
operator|=
literal|1
expr_stmt|;
name|pend
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pend
operator|->
name|buffer
argument_list|)
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|pkt
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/*log_pkt("pending serviced query: ", pend->pkt, pend->pkt_len);*/
comment|/* see if it matches the current moment */
if|if
condition|(
name|runtime
operator|->
name|now
operator|&&
name|runtime
operator|->
name|now
operator|->
name|evt_type
operator|==
name|repevt_back_query
operator|&&
operator|(
name|runtime
operator|->
name|now
operator|->
name|addrlen
operator|==
literal|0
operator|||
name|sockaddr_cmp
argument_list|(
operator|&
name|runtime
operator|->
name|now
operator|->
name|addr
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|addrlen
argument_list|,
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|find_match
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|match
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|,
name|pend
operator|->
name|transport
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"testbound: matched pending to event. "
literal|"advance time between events."
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"testbound: do STEP %d %s"
argument_list|,
name|runtime
operator|->
name|now
operator|->
name|time_step
argument_list|,
name|repevt_string
argument_list|(
name|runtime
operator|->
name|now
operator|->
name|evt_type
argument_list|)
argument_list|)
expr_stmt|;
name|advance_moment
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
comment|/* still create the pending, because we need it to callback */
block|}
name|log_info
argument_list|(
literal|"testbound: created fake pending"
argument_list|)
expr_stmt|;
comment|/* add to list */
name|pend
operator|->
name|next
operator|=
name|runtime
operator|->
name|pending_list
expr_stmt|;
name|runtime
operator|->
name|pending_list
operator|=
name|pend
expr_stmt|;
return|return
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|pend
return|;
block|}
end_function

begin_function
name|void
name|outnet_serviced_query_stop
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|fake_pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|fake_pending
operator|*
operator|)
name|sq
decl_stmt|;
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
name|pend
operator|->
name|runtime
decl_stmt|;
comment|/* delete from the list */
name|struct
name|fake_pending
modifier|*
name|p
init|=
name|runtime
operator|->
name|pending_list
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|log_assert
argument_list|(
name|p
operator|->
name|cb_arg
operator|==
name|cb_arg
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"serviced pending delete"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|runtime
operator|->
name|pending_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"double delete of pending serviced query"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|listen_port
modifier|*
name|listening_ports_open
argument_list|(
expr|struct
name|config_file
operator|*
name|ATTR_UNUSED
argument_list|(
name|cfg
argument_list|)
argument_list|,
name|int
operator|*
name|ATTR_UNUSED
argument_list|(
name|reuseport
argument_list|)
argument_list|)
block|{
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|listening_ports_free
parameter_list|(
name|struct
name|listen_port
modifier|*
name|list
parameter_list|)
block|{
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|comm_point
modifier|*
name|comm_point_create_local
argument_list|(
expr|struct
name|comm_base
operator|*
name|ATTR_UNUSED
argument_list|(
name|base
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|fd
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|bufsize
argument_list|)
argument_list|,
name|comm_point_callback_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|callback
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|callback_arg
argument_list|)
argument_list|)
block|{
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|struct
name|comm_point
modifier|*
name|comm_point_create_raw
argument_list|(
expr|struct
name|comm_base
operator|*
name|ATTR_UNUSED
argument_list|(
name|base
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|fd
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|writing
argument_list|)
argument_list|,
name|comm_point_callback_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|callback
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|callback_arg
argument_list|)
argument_list|)
block|{
comment|/* no pipe comm possible */
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|comm_point_start_listening
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|newfd
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|sec
argument_list|)
argument_list|)
block|{
comment|/* no bg write pipe comm possible */
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|comm_point_stop_listening
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|)
block|{
comment|/* no bg write pipe comm possible */
block|}
end_decl_stmt

begin_comment
comment|/* only cmd com _local gets deleted */
end_comment

begin_function
name|void
name|comm_point_delete
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|size_t
name|listen_get_mem
argument_list|(
expr|struct
name|listen_dnsport
operator|*
name|ATTR_UNUSED
argument_list|(
name|listen
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_t
name|outnet_get_mem
argument_list|(
expr|struct
name|outside_network
operator|*
name|ATTR_UNUSED
argument_list|(
name|outnet
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_t
name|comm_point_get_mem
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_t
name|serviced_get_mem
argument_list|(
expr|struct
name|serviced_query
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* fake for fptr wlist */
end_comment

begin_decl_stmt
name|int
name|outnet_udp_cb
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|outnet_tcp_cb
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|void
name|pending_udp_timer_cb
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pending_udp_timer_delay_cb
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|outnet_tcptimer
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_udp_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_udp_ancil_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_tcp_accept_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_tcp_handle_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_timer_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_signal_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_local_handle_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_point_raw_handle_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_handle_slow_accept
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|serviced_udp_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|serviced_tcp_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|int
name|pending_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|serviced_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* timers in testbound for autotrust. statistics tested in tpkg. */
end_comment

begin_function
name|struct
name|comm_timer
modifier|*
name|comm_timer_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|replay_runtime
modifier|*
name|runtime
init|=
operator|(
expr|struct
name|replay_runtime
operator|*
operator|)
name|base
decl_stmt|;
name|struct
name|fake_timer
modifier|*
name|t
init|=
operator|(
expr|struct
name|fake_timer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|t
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_timer
argument_list|(
name|t
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check in advance */
name|t
operator|->
name|runtime
operator|=
name|runtime
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|runtime
operator|->
name|timer_list
expr_stmt|;
name|runtime
operator|->
name|timer_list
operator|=
name|t
expr_stmt|;
return|return
operator|(
expr|struct
name|comm_timer
operator|*
operator|)
name|t
return|;
block|}
end_function

begin_function
name|void
name|comm_timer_disable
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|t
init|=
operator|(
expr|struct
name|fake_timer
operator|*
operator|)
name|timer
decl_stmt|;
name|log_info
argument_list|(
literal|"fake timer disabled"
argument_list|)
expr_stmt|;
name|t
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_timer_set
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|t
init|=
operator|(
expr|struct
name|fake_timer
operator|*
operator|)
name|timer
decl_stmt|;
name|t
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|tv
operator|=
operator|*
name|tv
expr_stmt|;
name|log_info
argument_list|(
literal|"fake timer set %d.%6.6d"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|timeval_add
argument_list|(
operator|&
name|t
operator|->
name|tv
argument_list|,
operator|&
name|t
operator|->
name|runtime
operator|->
name|now_tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_timer_delete
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
name|struct
name|fake_timer
modifier|*
name|t
init|=
operator|(
expr|struct
name|fake_timer
operator|*
operator|)
name|timer
decl_stmt|;
name|struct
name|fake_timer
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
comment|/* remove from linked list */
name|pp
operator|=
operator|&
name|t
operator|->
name|runtime
operator|->
name|timer_list
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|runtime
operator|->
name|timer_list
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|t
condition|)
block|{
comment|/* snip from list */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|comm_base_set_slow_accept_handlers
argument_list|(
expr|struct
name|comm_base
operator|*
name|ATTR_UNUSED
argument_list|(
name|b
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|stop_acc
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|start_acc
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|)
block|{
comment|/* ignore this */
operator|(
name|void
operator|)
name|stop_acc
expr_stmt|;
operator|(
name|void
operator|)
name|start_acc
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|struct
name|event_base
modifier|*
name|comm_base_internal
argument_list|(
expr|struct
name|comm_base
operator|*
name|ATTR_UNUSED
argument_list|(
name|b
argument_list|)
argument_list|)
block|{
comment|/* no pipe comm possible in testbound */
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|daemon_remote_exec
argument_list|(
expr|struct
name|worker
operator|*
name|ATTR_UNUSED
argument_list|(
name|worker
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|void
name|listen_start_accept
argument_list|(
expr|struct
name|listen_dnsport
operator|*
name|ATTR_UNUSED
argument_list|(
name|listen
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|void
name|listen_stop_accept
argument_list|(
expr|struct
name|listen_dnsport
operator|*
name|ATTR_UNUSED
argument_list|(
name|listen
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|void
name|daemon_remote_start_accept
argument_list|(
expr|struct
name|daemon_remote
operator|*
name|ATTR_UNUSED
argument_list|(
name|rc
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|void
name|daemon_remote_stop_accept
argument_list|(
expr|struct
name|daemon_remote
operator|*
name|ATTR_UNUSED
argument_list|(
name|rc
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_comment
comment|/*********** End of Dummy routines ***********/
end_comment

end_unit

