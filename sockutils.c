begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 - 2003  * NetGroup, Politecnico di Torino (Italy)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Politecnico di Torino nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * \file sockutils.c  *  * The goal of this file is to provide a common set of primitives for socket  * manipulation.  *  * Although the socket interface defined in the RFC 2553 (and its updates)  * is excellent, there are still differences between the behavior of those  * routines on UN*X and Windows, and between UN*Xes.  *  * These calls provide an interface similar to the socket interface, but  * that hides the differences between operating systems.  It does not  * attempt to significantly improve on the socket interface in other  * ways.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* for strerror() */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* for the errno variable */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* for the stderr file */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for malloc() and free() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INT_MAX
value|2147483647
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"portability.h"
end_include

begin_include
include|#
directive|include
file|"sockutils.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/*    * Winsock initialization.    *    * Ask for WinSock 2.2.    */
end_comment

begin_define
define|#
directive|define
name|WINSOCK_MAJOR_VERSION
value|2
end_define

begin_define
define|#
directive|define
name|WINSOCK_MINOR_VERSION
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|sockcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!< Variable that allows calling the WSAStartup() only one time */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some minor differences between UNIX and Win32 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|SHUT_WR
value|SD_SEND
end_define

begin_comment
comment|/* The control code for shutdown() is different in Win32 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of the buffer that has to keep error messages */
end_comment

begin_define
define|#
directive|define
name|SOCK_ERRBUF_SIZE
value|1024
end_define

begin_comment
comment|/* Constants; used in order to keep strings here */
end_comment

begin_define
define|#
directive|define
name|SOCKET_NO_NAME_AVAILABLE
value|"No name available"
end_define

begin_define
define|#
directive|define
name|SOCKET_NO_PORT_AVAILABLE
value|"No port available"
end_define

begin_define
define|#
directive|define
name|SOCKET_NAME_NULL_DAD
value|"Null address (possibly DAD Phase)"
end_define

begin_comment
comment|/****************************************************  *                                                  *  * Locally defined functions                        *  *                                                  *  ****************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|sock_ismcastaddr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|saddr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************  *                                                  *  * Function bodies                                  *  *                                                  *  ****************************************************/
end_comment

begin_comment
comment|/*  * \brief It retrieves the error message after an error occurred in the socket interface.  *  * This function is defined because of the different way errors are returned in UNIX  * and Win32. This function provides a consistent way to retrieve the error message  * (after a socket error occurred) on all the platforms.  *  * \param caller: a pointer to a user-allocated string which contains a message that has  * to be printed *before* the true error message. It could be, for example, 'this error  * comes from the recv() call at line 31'. It may be NULL.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return No return values. The error message is returned in the 'string' parameter.  */
end_comment

begin_function
name|void
name|sock_geterror
parameter_list|(
specifier|const
name|char
modifier|*
name|caller
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|int
name|retval
decl_stmt|;
name|int
name|code
decl_stmt|;
name|TCHAR
name|message
index|[
name|SOCK_ERRBUF_SIZE
index|]
decl_stmt|;
comment|/* It will be char (if we're using ascii) or wchar_t (if we're using unicode) */
if|if
condition|(
name|errbuf
operator|==
name|NULL
condition|)
return|return;
name|code
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|retval
operator|=
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
operator||
name|FORMAT_MESSAGE_MAX_WIDTH_MASK
argument_list|,
name|NULL
argument_list|,
name|code
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|TCHAR
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|caller
operator|)
operator|&&
operator|(
operator|*
name|caller
operator|)
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"%sUnable to get the exact error message"
argument_list|,
name|caller
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"Unable to get the exact error message"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|caller
operator|)
operator|&&
operator|(
operator|*
name|caller
operator|)
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"%s%s (code %d)"
argument_list|,
name|caller
argument_list|,
name|message
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"%s (code %d)"
argument_list|,
name|message
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|errbuf
operator|==
name|NULL
condition|)
return|return;
name|message
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|caller
operator|)
operator|&&
operator|(
operator|*
name|caller
operator|)
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"%s%s (code %d)"
argument_list|,
name|caller
argument_list|,
name|message
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"%s (code %d)"
argument_list|,
name|message
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * \brief It initializes sockets.  *  * This function is pretty useless on UNIX, since socket initialization is not required.  * However it is required on Win32. In UNIX, this function appears to be completely empty.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|sock_init
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|sockcount
operator|==
literal|0
condition|)
block|{
name|WSADATA
name|wsaData
decl_stmt|;
comment|/* helper variable needed to initialize Winsock */
if|if
condition|(
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
name|WINSOCK_MAJOR_VERSION
argument_list|,
name|WINSOCK_MINOR_VERSION
argument_list|)
argument_list|,
operator|&
name|wsaData
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"Failed to initialize Winsock\n"
argument_list|)
expr_stmt|;
name|WSACleanup
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|sockcount
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It deallocates sockets.  *  * This function is pretty useless on UNIX, since socket deallocation is not required.  * However it is required on Win32. In UNIX, this function appears to be completely empty.  *  * \return No error values.  */
end_comment

begin_function
name|void
name|sock_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|sockcount
operator|--
expr_stmt|;
if|if
condition|(
name|sockcount
operator|==
literal|0
condition|)
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * \brief It checks if the sockaddr variable contains a multicast address.  *  * \return '0' if the address is multicast, '-1' if it is not.  */
end_comment

begin_function
specifier|static
name|int
name|sock_ismcastaddr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|saddr
parameter_list|)
block|{
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|PF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|saddr4
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr
decl_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|saddr4
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|saddr6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|saddr
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|saddr6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief It initializes a network connection both from the client and the server side.  *  * In case of a client socket, this function calls socket() and connect().  * In the meanwhile, it checks for any socket error.  * If an error occurs, it writes the error message into 'errbuf'.  *  * In case of a server socket, the function calls socket(), bind() and listen().  *  * This function is usually preceeded by the sock_initaddress().  *  * \param addrinfo: pointer to an addrinfo variable which will be used to  * open the socket and such. This variable is the one returned by the previous call to  * sock_initaddress().  *  * \param server: '1' if this is a server socket, '0' otherwise.  *  * \param nconn: number of the connections that are allowed to wait into the listen() call.  * This value has no meanings in case of a client socket.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return the socket that has been opened (that has to be used in the following sockets calls)  * if everything is fine, '0' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
name|SOCKET
name|sock_open
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|addrinfo
parameter_list|,
name|int
name|server
parameter_list|,
name|int
name|nconn
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|SOCKET
name|sock
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|addrinfo
operator|->
name|ai_family
argument_list|,
name|addrinfo
operator|->
name|ai_socktype
argument_list|,
name|addrinfo
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"socket(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* This is a server socket */
if|if
condition|(
name|server
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
comment|/* 		 * Force the use of IPv6-only addresses; in BSD you can accept both v4 and v6 		 * connections if you have a "NULL" pointer as the nodename in the getaddrinfo() 		 * This behavior is not clear in the RFC 2553, so each system implements the 		 * bind() differently from this point of view 		 */
if|if
condition|(
name|addrinfo
operator|->
name|ai_family
operator|==
name|PF_INET6
condition|)
block|{
name|int
name|on
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_BINDV6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"setsockopt(IPV6_BINDV6ONLY)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* WARNING: if the address is a mcast one, I should place the proper Win32 code here */
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|addrinfo
operator|->
name|ai_addr
argument_list|,
operator|(
name|int
operator|)
name|addrinfo
operator|->
name|ai_addrlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"bind(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|addrinfo
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
condition|)
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|nconn
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"listen(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* server side ended */
return|return
name|sock
return|;
block|}
else|else
comment|/* we're the client */
block|{
name|struct
name|addrinfo
modifier|*
name|tempaddrinfo
decl_stmt|;
name|char
modifier|*
name|errbufptr
decl_stmt|;
name|size_t
name|bufspaceleft
decl_stmt|;
name|tempaddrinfo
operator|=
name|addrinfo
expr_stmt|;
name|errbufptr
operator|=
name|errbuf
expr_stmt|;
name|bufspaceleft
operator|=
name|errbuflen
expr_stmt|;
operator|*
name|errbufptr
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We have to loop though all the addinfo returned. 		 * For instance, we can have both IPv6 and IPv4 addresses, but the service we're trying 		 * to connect to is unavailable in IPv6, so we have to try in IPv4 as well 		 */
while|while
condition|(
name|tempaddrinfo
condition|)
block|{
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|tempaddrinfo
operator|->
name|ai_addr
argument_list|,
operator|(
name|int
operator|)
name|tempaddrinfo
operator|->
name|ai_addrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|size_t
name|msglen
decl_stmt|;
name|char
name|TmpBuffer
index|[
literal|100
index|]
decl_stmt|;
name|char
name|SocketErrorMessage
index|[
name|SOCK_ERRBUF_SIZE
index|]
decl_stmt|;
comment|/* 				 * We have to retrieve the error message before any other socket call completes, otherwise 				 * the error message is lost 				 */
name|sock_geterror
argument_list|(
name|NULL
argument_list|,
name|SocketErrorMessage
argument_list|,
sizeof|sizeof
argument_list|(
name|SocketErrorMessage
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Returns the numeric address of the host that triggered the error */
name|sock_getascii_addrport
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|tempaddrinfo
operator|->
name|ai_addr
argument_list|,
name|TmpBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|TmpBuffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|,
name|TmpBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|TmpBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbufptr
argument_list|,
name|bufspaceleft
argument_list|,
literal|"Is the server properly installed on %s?  connect() failed: %s"
argument_list|,
name|TmpBuffer
argument_list|,
name|SocketErrorMessage
argument_list|)
expr_stmt|;
comment|/* In case more then one 'connect' fails, we manage to keep all the error messages */
name|msglen
operator|=
name|strlen
argument_list|(
name|errbufptr
argument_list|)
expr_stmt|;
name|errbufptr
index|[
name|msglen
index|]
operator|=
literal|' '
expr_stmt|;
name|errbufptr
index|[
name|msglen
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|bufspaceleft
operator|=
name|bufspaceleft
operator|-
operator|(
name|msglen
operator|+
literal|1
operator|)
expr_stmt|;
name|errbufptr
operator|+=
operator|(
name|msglen
operator|+
literal|1
operator|)
expr_stmt|;
name|tempaddrinfo
operator|=
name|tempaddrinfo
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* 		 * Check how we exit from the previous loop 		 * If tempaddrinfo is equal to NULL, it means that all the connect() failed. 		 */
if|if
condition|(
name|tempaddrinfo
operator|==
name|NULL
condition|)
block|{
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
name|sock
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief Closes the present (TCP and UDP) socket connection.  *  * This function sends a shutdown() on the socket in order to disable send() calls  * (while recv() ones are still allowed). Then, it closes the socket.  *  * \param sock: the socket identifier of the connection that has to be closed.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|sock_close
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
comment|/* 	 * SHUT_WR: subsequent calls to the send function are disallowed. 	 * For TCP sockets, a FIN will be sent after all data is sent and 	 * acknowledged by the Server. 	 */
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
name|SHUT_WR
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"shutdown(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
comment|/* close the socket anyway */
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Checks that the address, port and flags given are valids and it returns an 'addrinfo' structure.  *  * This function basically calls the getaddrinfo() calls, and it performs a set of sanity checks  * to control that everything is fine (e.g. a TCP socket cannot have a mcast address, and such).  * If an error occurs, it writes the error message into 'errbuf'.  *  * \param host: a pointer to a string identifying the host. It can be  * a host name, a numeric literal address, or NULL or "" (useful  * in case of a server socket which has to bind to all addresses).  *  * \param port: a pointer to a user-allocated buffer containing the network port to use.  *  * \param hints: an addrinfo variable (passed by reference) containing the flags needed to create the  * addrinfo structure appropriately.  *  * \param addrinfo: it represents the true returning value. This is a pointer to an addrinfo variable  * (passed by reference), which will be allocated by this function and returned back to the caller.  * This variable will be used in the next sockets calls.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable. The addrinfo variable that has to be used in the following sockets calls is  * returned into the addrinfo parameter.  *  * \warning The 'addrinfo' variable has to be deleted by the programmer by calling freeaddrinfo() when  * it is no longer needed.  *  * \warning This function requires the 'hints' variable as parameter. The semantic of this variable is the same  * of the one of the corresponding variable used into the standard getaddrinfo() socket function. We suggest  * the programmer to look at that function in order to set the 'hints' variable appropriately.  */
end_comment

begin_function
name|int
name|sock_initaddress
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|addrinfo
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * if the getaddrinfo() fails, you have to use gai_strerror(), instead of using the standard 		 * error routines (errno) in UNIX; Winsock suggests using the GetLastError() instead. 		 */
if|if
condition|(
name|errbuf
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|sock_geterror
argument_list|(
literal|"getaddrinfo(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"getaddrinfo() %s"
argument_list|,
name|gai_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * \warning SOCKET: I should check all the accept() in order to bind to all addresses in case 	 * addrinfo has more han one pointers 	 */
comment|/* 	 * This software only supports PF_INET and PF_INET6. 	 * 	 * XXX - should we just check that at least *one* address is 	 * either PF_INET or PF_INET6, and, when using the list, 	 * ignore all addresses that are neither?  (What, no IPX 	 * support? :-)) 	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|addrinfo
operator|)
operator|->
name|ai_family
operator|!=
name|PF_INET
operator|)
operator|&&
operator|(
operator|(
operator|*
name|addrinfo
operator|)
operator|->
name|ai_family
operator|!=
name|PF_INET6
operator|)
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"getaddrinfo(): socket type not supported"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * You can't do multicast (or broadcast) TCP. 	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|addrinfo
operator|)
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
operator|)
operator|&&
operator|(
name|sock_ismcastaddr
argument_list|(
operator|(
operator|*
name|addrinfo
operator|)
operator|->
name|ai_addr
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"getaddrinfo(): multicast addresses are not valid when using TCP streams"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It sends the amount of data contained into 'buffer' on the given socket.  *  * This function basically calls the send() socket function and it checks that all  * the data specified in 'buffer' (of size 'size') will be sent. If an error occurs,  * it writes the error message into 'errbuf'.  * In case the socket buffer does not have enough space, it loops until all data  * has been sent.  *  * \param socket: the connected socket currently opened.  *  * \param buffer: a char pointer to a user-allocated buffer in which data is contained.  *  * \param size: number of bytes that have to be sent.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned  * in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|sock_send
parameter_list|(
name|SOCKET
name|socket
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|int
name|nsent
decl_stmt|;
name|send
label|:
ifdef|#
directive|ifdef
name|linux
comment|/* 	 * Another pain... in Linux there's this flag 	 * MSG_NOSIGNAL 	 * Requests not to send SIGPIPE on errors on stream-oriented 	 * sockets when the other end breaks the connection. 	 * The EPIPE error is still returned. 	 */
name|nsent
operator|=
name|send
argument_list|(
name|socket
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
name|MSG_NOSIGNAL
argument_list|)
expr_stmt|;
else|#
directive|else
name|nsent
operator|=
name|send
argument_list|(
name|socket
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nsent
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"send(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nsent
operator|!=
name|size
condition|)
block|{
name|size
operator|-=
name|nsent
expr_stmt|;
name|buffer
operator|+=
name|nsent
expr_stmt|;
goto|goto
name|send
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It copies the amount of data contained into 'buffer' into 'tempbuf'.  * and it checks for buffer overflows.  *  * This function basically copies 'size' bytes of data contained into 'buffer'  * into 'tempbuf', starting at offset 'offset'. Before that, it checks that the  * resulting buffer will not be larger	than 'totsize'. Finally, it updates  * the 'offset' variable in order to point to the first empty location of the buffer.  *  * In case the function is called with 'checkonly' equal to 1, it does not copy  * the data into the buffer. It only checks for buffer overflows and it updates the  * 'offset' variable. This mode can be useful when the buffer already contains the  * data (maybe because the producer writes directly into the target buffer), so  * only the buffer overflow check has to be made.  * In this case, both 'buffer' and 'tempbuf' can be NULL values.  *  * This function is useful in case the userland application does not know immediately  * all the data it has to write into the socket. This function provides a way to create  * the "stream" step by step, appending the new data to the old one. Then, when all the  * data has been bufferized, the application can call the sock_send() function.  *  * \param buffer: a char pointer to a user-allocated buffer that keeps the data  * that has to be copied.  *  * \param size: number of bytes that have to be copied.  *  * \param tempbuf: user-allocated buffer (of size 'totsize') in which data  * has to be copied.  *  * \param offset: an index into 'tempbuf' which keeps the location of its first  * empty location.  *  * \param totsize: total size of the buffer in which data is being copied.  *  * \param checkonly: '1' if we do not want to copy data into the buffer and we  * want just do a buffer ovreflow control, '0' if data has to be copied as well.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred. The error message  * is returned in the 'errbuf' variable. When the function returns, 'tempbuf' will  * have the new string appended, and 'offset' will keep the length of that buffer.  * In case of 'checkonly == 1', data is not copied, but 'offset' is updated in any case.  *  * \warning This function assumes that the buffer in which data has to be stored is  * large 'totbuf' bytes.  *  * \warning In case of 'checkonly', be carefully to call this function *before* copying  * the data into the buffer. Otherwise, the control about the buffer overflow is useless.  */
end_comment

begin_function
name|int
name|sock_bufferize
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|tempbuf
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|totsize
parameter_list|,
name|int
name|checkonly
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|offset
operator|+
name|size
operator|)
operator|>
name|totsize
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"Not enough space in the temporary send buffer."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|checkonly
condition|)
name|memcpy
argument_list|(
name|tempbuf
operator|+
operator|(
operator|*
name|offset
operator|)
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It waits on a connected socket and it manages to receive data.  *  * This function basically calls the recv() socket function and it checks that no  * error occurred. If that happens, it writes the error message into 'errbuf'.  *  * This function changes its behavior according to the 'receiveall' flag: if we  * want to receive exactly 'size' byte, it loops on the recv()	until all the requested  * data is arrived. Otherwise, it returns the data currently available.  *  * In case the socket does not have enough data available, it cycles on the recv()  * until the requested data (of size 'size') is arrived.  * In this case, it blocks until the number of bytes read is equal to 'size'.  *  * \param sock: the connected socket currently opened.  *  * \param buffer: a char pointer to a user-allocated buffer in which data has to be stored  *  * \param size: size of the allocated buffer. WARNING: this indicates the number of bytes  * that we are expecting to be read.  *  * \param receiveall: if '0' (or SOCK_RECEIVEALL_NO), it returns as soon as some data  * is ready; otherwise, (or SOCK_RECEIVEALL_YES) it waits until 'size' data has been  * received (in case the socket does not have enough data available).  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return the number of bytes read if everything is fine, '-1' if some errors occurred.  * The error message is returned in the 'errbuf' variable.  */
end_comment

begin_comment
comment|/*  * On UN*X, recv() returns ssize_t.  * On Windows, there *is* no ssize_t, and it returns an int.  * Define ssize_t as int on Windows so we can use it as the return value  * from recv().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_typedef
typedef|typedef
name|int
name|ssize_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sock_recv
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|receiveall
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|char
modifier|*
name|bufp
init|=
name|buffer
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|ssize_t
name|nread
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|SOCK_ASSERT
argument_list|(
literal|"I have been requested to read zero bytes"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|size
operator|>
name|INT_MAX
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"Can't read more than %u bytes with sock_recv"
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
name|remaining
operator|=
operator|(
name|int
operator|)
name|size
expr_stmt|;
comment|/* 	 * We don't use MSG_WAITALL because it's not supported in 	 * Win32. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|nread
operator|=
name|recv
argument_list|(
name|sock
argument_list|,
name|bufp
argument_list|,
name|remaining
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return
operator|-
literal|3
return|;
endif|#
directive|endif
name|sock_geterror
argument_list|(
literal|"recv(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"The other host terminated the connection."
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * Do we want to read the amount requested, or just return 		 * what we got? 		 */
if|if
condition|(
operator|!
name|receiveall
condition|)
block|{
comment|/* 			 * Just return what we got. 			 */
return|return
operator|(
name|int
operator|)
name|nread
return|;
block|}
name|bufp
operator|+=
name|nread
expr_stmt|;
name|remaining
operator|-=
name|nread
expr_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
return|return
operator|(
name|int
operator|)
name|size
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief It discards N bytes that are currently waiting to be read on the current socket.  *  * This function is useful in case we receive a message we cannot understand (e.g.  * wrong version number when receiving a network packet), so that we have to discard all  * data before reading a new message.  *  * This function will read 'size' bytes from the socket and discard them.  * It defines an internal buffer in which data will be copied; however, in case  * this buffer is not large enough, it will cycle in order to read everything as well.  *  * \param sock: the connected socket currently opened.  *  * \param size: number of bytes that have to be discarded.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '0' if everything is fine, '-1' if some errors occurred.  * The error message is returned in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|sock_discard
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
define|#
directive|define
name|TEMP_BUF_SIZE
value|32768
name|char
name|buffer
index|[
name|TEMP_BUF_SIZE
index|]
decl_stmt|;
comment|/* network buffer, to be used when the message is discarded */
comment|/* 	 * A static allocation avoids the need of a 'malloc()' each time we want to discard a message 	 * Our feeling is that a buffer if 32KB is enough for most of the application; 	 * in case this is not enough, the "while" loop discards the message by calling the 	 * sockrecv() several times. 	 * We do not want to create a bigger variable because this causes the program to exit on 	 * some platforms (e.g. BSD) 	 */
while|while
condition|(
name|size
operator|>
name|TEMP_BUF_SIZE
condition|)
block|{
if|if
condition|(
name|sock_recv
argument_list|(
name|sock
argument_list|,
name|buffer
argument_list|,
name|TEMP_BUF_SIZE
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|size
operator|-=
name|TEMP_BUF_SIZE
expr_stmt|;
block|}
comment|/* 	 * If there is still data to be discarded 	 * In this case, the data can fit into the temporary buffer 	 */
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|sock_recv
argument_list|(
name|sock
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|SOCK_ASSERT
argument_list|(
literal|"I'm currently discarding data\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Checks that one host (identified by the sockaddr_storage structure) belongs to an 'allowed list'.  *  * This function is useful after an accept() call in order to check if the connecting  * host is allowed to connect to me. To do that, we have a buffer that keeps the list of the  * allowed host; this function checks the sockaddr_storage structure of the connecting host  * against this host list, and it returns '0' is the host is included in this list.  *  * \param hostlist: pointer to a string that contains the list of the allowed host.  *  * \param sep: a string that keeps the separators used between the hosts (for example the  * space character) in the host list.  *  * \param from: a sockaddr_storage structure, as it is returned by the accept() call.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return It returns:  * - '1' if the host list is empty  * - '0' if the host belongs to the host list (and therefore it is allowed to connect)  * - '-1' in case the host does not belong to the host list (and therefore it is not allowed to connect  * - '-2' in case or error. The error message is returned in the 'errbuf' variable.  */
end_comment

begin_function
name|int
name|sock_check_hostlist
parameter_list|(
name|char
modifier|*
name|hostlist
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
comment|/* checks if the connecting host is among the ones allowed */
if|if
condition|(
operator|(
name|hostlist
operator|)
operator|&&
operator|(
name|hostlist
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
comment|/* temp, needed to separate items into the hostlist */
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|,
modifier|*
name|ai_next
decl_stmt|;
name|char
modifier|*
name|temphostlist
decl_stmt|;
name|char
modifier|*
name|lasts
decl_stmt|;
comment|/* 		 * The problem is that strtok modifies the original variable by putting '0' at the end of each token 		 * So, we have to create a new temporary string in which the original content is kept 		 */
name|temphostlist
operator|=
name|strdup
argument_list|(
name|hostlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|temphostlist
operator|==
name|NULL
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"sock_check_hostlist(), malloc() failed"
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|token
operator|=
name|pcap_strtok_r
argument_list|(
name|temphostlist
argument_list|,
name|sep
argument_list|,
operator|&
name|lasts
argument_list|)
expr_stmt|;
comment|/* it avoids a warning in the compilation ('addrinfo used but not initialized') */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|token
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"getaddrinfo() %s"
argument_list|,
name|gai_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Get next token */
name|token
operator|=
name|pcap_strtok_r
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|,
operator|&
name|lasts
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ai_next is required to preserve the content of addrinfo, in order to deallocate it properly */
name|ai_next
operator|=
name|addrinfo
expr_stmt|;
while|while
condition|(
name|ai_next
condition|)
block|{
if|if
condition|(
name|sock_cmpaddr
argument_list|(
name|from
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|ai_next
operator|->
name|ai_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temphostlist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 				 * If we are here, it means that the current address does not matches 				 * Let's try with the next one in the header chain 				 */
name|ai_next
operator|=
name|ai_next
operator|->
name|ai_next
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
comment|/* Get next token */
name|token
operator|=
name|pcap_strtok_r
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|,
operator|&
name|lasts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrinfo
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"The host is not in the allowed host list. Connection refused."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temphostlist
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* No hostlist, so we have to return 'empty list' */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Compares two addresses contained into two sockaddr_storage structures.  *  * This function is useful to compare two addresses, given their internal representation,  * i.e. an sockaddr_storage structure.  *  * The two structures do not need to be sockaddr_storage; you can have both 'sockaddr_in' and  * sockaddr_in6, properly acsted in order to be compliant to the function interface.  *  * This function will return '0' if the two addresses matches, '-1' if not.  *  * \param first: a sockaddr_storage structure, (for example the one that is returned by an  * accept() call), containing the first address to compare.  *  * \param second: a sockaddr_storage structure containing the second address to compare.  *  * \return '0' if the addresses are equal, '-1' if they are different.  */
end_comment

begin_function
name|int
name|sock_cmpaddr
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|first
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|->
name|ss_family
operator|==
name|second
operator|->
name|ss_family
condition|)
block|{
if|if
condition|(
name|first
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|first
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|second
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
comment|/* address family is AF_INET6 */
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|first
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|second
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It gets the address/port the system picked for this socket (on connected sockets).  *  * It is used to return the address and port the server picked for our socket on the local machine.  * It works only on:  * - connected sockets  * - server sockets  *  * On unconnected client sockets it does not work because the system dynamically chooses a port  * only when the socket calls a send() call.  *  * \param sock: the connected socket currently opened.  *  * \param address: it contains the address that will be returned by the function. This buffer  * must be properly allocated by the user. The address can be either literal or numeric depending  * on the value of 'Flags'.  *  * \param addrlen: the length of the 'address' buffer.  *  * \param port: it contains the port that will be returned by the function. This buffer  * must be properly allocated by the user.  *  * \param portlen: the length of the 'port' buffer.  *  * \param flags: a set of flags (the ones defined into the getnameinfo() standard socket function)  * that determine if the resulting address must be in numeric / literal form, and so on.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return It returns '-1' if this function succeeds, '0' otherwise.  * The address and port corresponding are returned back in the buffers 'address' and 'port'.  * In any case, the returned strings are '0' terminated.  *  * \warning If the socket is using a connectionless protocol, the address may not be available  * until I/O occurs on the socket.  */
end_comment

begin_function
name|int
name|sock_getmyinfo
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|char
modifier|*
name|address
parameter_list|,
name|int
name|addrlen
parameter_list|,
name|char
modifier|*
name|port
parameter_list|,
name|int
name|portlen
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|mysockaddr
decl_stmt|;
name|socklen_t
name|sockaddrlen
decl_stmt|;
name|sockaddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mysockaddr
argument_list|,
operator|&
name|sockaddrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getsockname(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Returns the numeric address of the host that triggered the error */
return|return
name|sock_getascii_addrport
argument_list|(
operator|&
name|mysockaddr
argument_list|,
name|address
argument_list|,
name|addrlen
argument_list|,
name|port
argument_list|,
name|portlen
argument_list|,
name|flags
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It retrieves two strings containing the address and the port of a given 'sockaddr' variable.  *  * This function is basically an extended version of the inet_ntop(), which does not exist in  * Winsock because the same result can be obtained by using the getnameinfo().  * However, differently from inet_ntop(), this function is able to return also literal names  * (e.g. 'localhost') dependently from the 'Flags' parameter.  *  * The function accepts a sockaddr_storage variable (which can be returned by several functions  * like bind(), connect(), accept(), and more) and it transforms its content into a 'human'  * form. So, for instance, it is able to translate an hex address (stored in binary form) into  * a standard IPv6 address like "::1".  *  * The behavior of this function depends on the parameters we have in the 'Flags' variable, which  * are the ones allowed in the standard getnameinfo() socket function.  *  * \param sockaddr: a 'sockaddr_in' or 'sockaddr_in6' structure containing the address that  * need to be translated from network form into the presentation form. This structure must be  * zero-ed prior using it, and the address family field must be filled with the proper value.  * The user must cast any 'sockaddr_in' or 'sockaddr_in6' structures to 'sockaddr_storage' before  * calling this function.  *  * \param address: it contains the address that will be returned by the function. This buffer  * must be properly allocated by the user. The address can be either literal or numeric depending  * on the value of 'Flags'.  *  * \param addrlen: the length of the 'address' buffer.  *  * \param port: it contains the port that will be returned by the function. This buffer  * must be properly allocated by the user.  *  * \param portlen: the length of the 'port' buffer.  *  * \param flags: a set of flags (the ones defined into the getnameinfo() standard socket function)  * that determine if the resulting address must be in numeric / literal form, and so on.  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return It returns '-1' if this function succeeds, '0' otherwise.  * The address and port corresponding to the given SockAddr are returned back in the buffers 'address'  * and 'port'.  * In any case, the returned strings are '0' terminated.  */
end_comment

begin_function
name|int
name|sock_getascii_addrport
parameter_list|(
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|sockaddr
parameter_list|,
name|char
modifier|*
name|address
parameter_list|,
name|int
name|addrlen
parameter_list|,
name|char
modifier|*
name|port
parameter_list|,
name|int
name|portlen
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|socklen_t
name|sockaddrlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Variable that keeps the return value; */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|sockaddr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|sockaddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
else|else
name|sockaddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|#
directive|else
name|sockaddrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|flags
operator|&
name|NI_NUMERICHOST
operator|)
operator|==
literal|0
condition|)
comment|/* Check that we want literal names */
block|{
if|if
condition|(
operator|(
name|sockaddr
operator|->
name|ss_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin6_addr
argument_list|,
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|address
condition|)
name|strlcpy
argument_list|(
name|address
argument_list|,
name|SOCKET_NAME_NULL_DAD
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sockaddr
argument_list|,
name|sockaddrlen
argument_list|,
name|address
argument_list|,
name|addrlen
argument_list|,
name|port
argument_list|,
name|portlen
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If the user wants to receive an error message */
if|if
condition|(
name|errbuf
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
expr_stmt|;
name|errbuf
index|[
name|errbuflen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|address
condition|)
block|{
name|strlcpy
argument_list|(
name|address
argument_list|,
name|SOCKET_NO_NAME_AVAILABLE
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|address
index|[
name|addrlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|port
condition|)
block|{
name|strlcpy
argument_list|(
name|port
argument_list|,
name|SOCKET_NO_PORT_AVAILABLE
argument_list|,
name|portlen
argument_list|)
expr_stmt|;
name|port
index|[
name|portlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * \brief It translates an address from the 'presentation' form into the 'network' form.  *  * This function basically replaces inet_pton(), which does not exist in Winsock because  * the same result can be obtained by using the getaddrinfo().  * An additional advantage is that 'Address' can be both a numeric address (e.g. '127.0.0.1',  * like in inet_pton() ) and a literal name (e.g. 'localhost').  *  * This function does the reverse job of sock_getascii_addrport().  *  * \param address: a zero-terminated string which contains the name you have to  * translate. The name can be either literal (e.g. 'localhost') or numeric (e.g. '::1').  *  * \param sockaddr: a user-allocated sockaddr_storage structure which will contains the  * 'network' form of the requested address.  *  * \param addr_family: a constant which can assume the following values:  * - 'AF_INET' if we want to ping an IPv4 host  * - 'AF_INET6' if we want to ping an IPv6 host  * - 'AF_UNSPEC' if we do not have preferences about the protocol used to ping the host  *  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete  * error message. This buffer has to be at least 'errbuflen' in length.  * It can be NULL; in this case the error cannot be printed.  *  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.  *  * \return '-1' if the translation succeeded, '-2' if there was some non critical error, '0'  * otherwise. In case it fails, the content of the SockAddr variable remains unchanged.  * A 'non critical error' can occur in case the 'Address' is a literal name, which can be mapped  * to several network addresses (e.g. 'foo.bar.com' => '10.2.2.2' and '10.2.2.3'). In this case  * the content of the SockAddr parameter will be the address corresponding to the first mapping.  *  * \warning The sockaddr_storage structure MUST be allocated by the user.  */
end_comment

begin_function
name|int
name|sock_present2network
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sockaddr
parameter_list|,
name|int
name|addr_family
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuflen
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|addr_family
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|sock_initaddress
argument_list|(
name|address
argument_list|,
literal|"22222"
comment|/* fake port */
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|errbuf
argument_list|,
name|errbuflen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addrinfo
operator|->
name|ai_family
operator|==
name|PF_INET
condition|)
name|memcpy
argument_list|(
name|sockaddr
argument_list|,
name|addrinfo
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|sockaddr
argument_list|,
name|addrinfo
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|->
name|ai_next
operator|!=
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuflen
argument_list|,
literal|"More than one socket requested; using the first one returned"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

