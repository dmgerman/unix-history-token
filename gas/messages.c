begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* messages.c - error reporter -    Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,    2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_function_decl
specifier|static
name|void
name|identify
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|as_show_where
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|as_warn_internal
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|as_bad_internal
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Despite the rest of the comments in this file, (FIXME-SOON),    here is the current scheme for error messages etc:     as_fatal() is used when gas is quite confused and    continuing the assembly is pointless.  In this case we    exit immediately with error status.     as_bad() is used to mark errors that result in what we    presume to be a useless object file.  Say, we ignored    something that might have been vital.  If we see any of    these, assembly will continue to the end of the source,    no object file will be produced, and we will terminate    with error status.  The new option, -Z, tells us to    produce an object file anyway but we still exit with    error status.  The assumption here is that you don't want    this object file but we could be wrong.     as_warn() is used when we have an error from which we    have a plausible error recovery.  eg, masking the top    bits of a constant that is longer than will fit in the    destination.  In this case we will continue to assemble    the source, although we may have made a bad assumption,    and we will produce an object file and return normal exit    status (ie, no error).  The new option -X tells us to    treat all as_warn() errors as as_bad() errors.  That is,    no object file will be produced and we will exit with    error status.  The idea here is that we don't kill an    entire make because of an error that we knew how to    correct.  On the other hand, sometimes you might want to    stop the make at these points.     as_tsktsk() is used when we see a minor error for which    our error recovery action is almost certainly correct.    In this case, we print a message and then assembly    continues as though no error occurred.  */
end_comment

begin_function
specifier|static
name|void
name|identify
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
specifier|static
name|int
name|identified
decl_stmt|;
if|if
condition|(
name|identified
condition|)
return|return;
name|identified
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assembler messages:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The number of warnings issued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warning_count
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|had_warnings
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|warning_count
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we've hit a 'bad error', and should not write an obj file,    and exit with a nonzero error code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|had_errors
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|error_count
return|;
block|}
end_function

begin_comment
comment|/* Print the current location to stderr.  */
end_comment

begin_function
specifier|static
name|void
name|as_show_where
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send to stderr a string as a warning, and locate warning    in input file(s).    Please only use this for when we have some recovery action.    Please explain in string (which may have '\n's) what recovery was    done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_tsktsk
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_tsktsk
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* The common portion of as_warn and as_warn_where.  */
end_comment

begin_function
specifier|static
name|void
name|as_warn_internal
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
operator|++
name|warning_count
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Warning: "
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_warning
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Send to stderr a string as a warning, and locate warning    in input file(s).    Please only use this for when we have some recovery action.    Please explain in string (which may have '\n's) what recovery was    done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_warn
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* Like as_bad but the file name and line number are passed in.    Unfortunately, we have to repeat the function in order to handle    the varargs correctly and portably.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_warn_where
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_warn_where
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_warnings
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_warn_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* The common portion of as_bad and as_bad_where.  */
end_comment

begin_function
specifier|static
name|void
name|as_bad_internal
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
operator|++
name|error_count
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|identify
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Error: "
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_error
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Send to stderr a string as a warning, and locate warning in input    file(s).  Please us when there is no recovery, but we want to    continue processing but not produce an object file.    Please explain in string (which may have '\n's) what recovery was    done.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_bad
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_bad
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* Like as_bad but the file name and line number are passed in.    Unfortunately, we have to repeat the function in order to handle    the varargs correctly and portably.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_bad_where
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_bad_where
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|as_bad_internal
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* Send to stderr a string as a fatal message, and print location of    error in input file(s).    Please only use this for when we DON'T have some recovery action.    It xexit()s with a warning status.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_function
name|void
name|as_fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Fatal error: "
argument_list|)
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Delete the output file, if it exists.  This will prevent make from      thinking that a file was created and hence does not need rebuilding.  */
if|if
condition|(
name|out_file_name
operator|!=
name|NULL
condition|)
name|unlink_if_ordinary
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|as_fatal
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|as_show_where
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Fatal error: "
argument_list|)
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NO_STDARG */
end_comment

begin_comment
comment|/* Indicate assertion failure.    Arguments: Filename, line number, optional function name.  */
end_comment

begin_function
name|void
name|as_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|as_show_where
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error!\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assertion failure in %s at %s line %d.\n"
argument_list|)
argument_list|,
name|fn
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Assertion failure at %s line %d.\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Please report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* as_abort: Print a friendly message saying how totally hosed we are,    and exit without producing a core file.  */
end_comment

begin_function
name|void
name|as_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|as_show_where
argument_list|()
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error, aborting at %s line %d in %s\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error, aborting at %s line %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Please report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support routines.  */
end_comment

begin_function
name|void
name|sprint_value
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HEX_MAX_THRESHOLD
value|1024
end_define

begin_define
define|#
directive|define
name|HEX_MIN_THRESHOLD
value|-(HEX_MAX_THRESHOLD)
end_define

begin_function
specifier|static
name|void
name|as_internal_value_out_of_range
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|offsetT
name|val
parameter_list|,
name|offsetT
name|min
parameter_list|,
name|offsetT
name|max
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|line
parameter_list|,
name|int
name|bad
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
name|prefix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|min
operator|&&
name|val
operator|<=
name|max
condition|)
block|{
name|addressT
name|right
init|=
name|max
operator|&
operator|-
name|max
decl_stmt|;
if|if
condition|(
name|max
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* xgettext:c-format  */
name|err
operator|=
name|_
argument_list|(
literal|"%s out of domain (%d is not a multiple of %d)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
operator|(
name|int
operator|)
name|right
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
operator|(
name|int
operator|)
name|right
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|val
operator|<
name|HEX_MAX_THRESHOLD
operator|&&
name|min
operator|<
name|HEX_MAX_THRESHOLD
operator|&&
name|max
operator|<
name|HEX_MAX_THRESHOLD
operator|&&
name|val
operator|>
name|HEX_MIN_THRESHOLD
operator|&&
name|min
operator|>
name|HEX_MIN_THRESHOLD
operator|&&
name|max
operator|>
name|HEX_MIN_THRESHOLD
condition|)
block|{
comment|/* xgettext:c-format  */
name|err
operator|=
name|_
argument_list|(
literal|"%s out of range (%d is not between %d and %d)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|val_buf
index|[
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|min_buf
index|[
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|max_buf
index|[
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf_vma
argument_list|(
name|val_buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|min_buf
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|max_buf
argument_list|,
name|max
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format.  */
name|err
operator|=
name|_
argument_list|(
literal|"%s out of range (0x%s is not between 0x%s and 0x%s)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
name|val_buf
argument_list|,
name|min_buf
argument_list|,
name|max_buf
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|prefix
argument_list|,
name|val_buf
argument_list|,
name|min_buf
argument_list|,
name|max_buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|as_warn_value_out_of_range
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|offsetT
name|value
parameter_list|,
name|offsetT
name|min
parameter_list|,
name|offsetT
name|max
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|line
parameter_list|)
block|{
name|as_internal_value_out_of_range
argument_list|(
name|prefix
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|as_bad_value_out_of_range
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|offsetT
name|value
parameter_list|,
name|offsetT
name|min
parameter_list|,
name|offsetT
name|max
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|line
parameter_list|)
block|{
name|as_internal_value_out_of_range
argument_list|(
name|prefix
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

