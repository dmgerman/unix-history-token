begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|TEST_GEN_C
end_ifndef

begin_define
define|#
directive|define
name|TEST_GEN_C
value|1
end_define

begin_comment
comment|/* Copyright (C) 2000, 2003 Free Software Foundation    Contributed by Alexandre Oliva<aoliva@cygnus.com>     This file is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is a source file with infra-structure to test generators for    assemblers and disassemblers.     The strategy to generate testcases is as follows.  We'll output to    two streams: one will get the assembly source, and the other will    get regexps that match the expected binary patterns.     To generate each instruction, the functions of a func[] are called,    each with the corresponding func_arg.  Each function should set    members of insn_data, to decide what it's going to output to the    assembly source, the corresponding output for the disassembler    tester, and the bits to be set in the instruction word.  The    strings to be output must have been allocated with strdup() or    malloc(), so that they can be freed.  A function may also modify    insn_size.  More details in test-gen.c     Because this would have generated too many tests, we have chosen to    define ``random'' sequences of numbers/registers, and simply    generate each instruction a couple of times, which should get us    enough coverage.     In general, test generators should be compiled/run as follows:       % gcc test.c -o test    % ./test> test.s 2> test.d     Please note that this file contains a couple of GCC-isms, such as    macro varargs (also available in C99, but with a difference syntax)    and labeled elements in initializers (so that insn definitions are    simpler and safer).     It is assumed that the test generator #includes this file after    defining any of the preprocessor macros documented below.  The test    generator is supposed to define instructions, at least one group of    instructions, optionally, a sequence of groups.     It should also define a main() function that outputs the initial    lines of the assembler input and of the test control file, that    also contains the disassembler output.  The main() funcion may    optionally set skip_list too, before calling output_groups() or    output_insns().  */
end_comment

begin_comment
comment|/* Define to 1 to avoid repeating instructions and to use a simpler    register/constant generation mechanism.  This makes it much easier    to verify that the generated bit patterns are correct.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIMPLIFY_OUTPUT
end_ifndef

begin_define
define|#
directive|define
name|SIMPLIFY_OUTPUT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define to 0 to avoid generating disassembler tests.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DISASSEMBLER_TEST
end_ifndef

begin_define
define|#
directive|define
name|DISASSEMBLER_TEST
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define to the number of times to repeat the generation of each    insn.  It's best to use prime numbers, to improve randomization.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_REPEAT
end_ifndef

begin_define
define|#
directive|define
name|INSN_REPEAT
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define in order to get randomization_counter printed, as a comment,    in the disassembler output, after each insn is emitted.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OUTPUT_RANDOMIZATION_COUNTER
end_ifndef

begin_define
define|#
directive|define
name|OUTPUT_RANDOMIZATION_COUNTER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Other configuration macros are DEFINED_WORD and DEFINED_FUNC_ARG,    see below.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* It is expected that the main program defines the type `word' before    includeing this.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_WORD
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|word
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This struct is used as the output area for each function.  It    should store in as_in a pointer to the string to be output to the    assembler; in dis_out, the string to be expected in return from the    disassembler, and in bits the bits of the instruction word that are    enabled by the assembly fragment.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|as_in
decl_stmt|;
name|char
modifier|*
name|dis_out
decl_stmt|;
name|word
name|bits
decl_stmt|;
block|}
name|insn_data
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|DEFINED_FUNC_ARG
end_ifndef

begin_comment
comment|/* This is the struct that feeds information to each function.  You're    free to extend it, by `typedef'ing it before including this file,    and defining DEFINED_FUNC_ARG.  You may even reorder the fields,    but do not remove any of the existing fields.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|i1
decl_stmt|;
name|int
name|i2
decl_stmt|;
name|int
name|i3
decl_stmt|;
name|void
modifier|*
name|p1
decl_stmt|;
name|void
modifier|*
name|p2
decl_stmt|;
name|word
name|w
decl_stmt|;
block|}
name|func_arg
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the struct whose arrays define insns.  Each func in the    array will be called, in sequence, being given a pointer to the    associated arg and a pointer to a zero-initialized output area,    that it may fill in.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|func_arg
modifier|*
parameter_list|,
name|insn_data
modifier|*
parameter_list|)
function_decl|;
name|func_arg
name|arg
decl_stmt|;
block|}
name|func
typedef|;
end_typedef

begin_comment
comment|/* Use this to group insns under a name.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|func
modifier|*
modifier|*
name|insns
decl_stmt|;
block|}
name|group_t
typedef|;
end_typedef

begin_comment
comment|/* This is the size of each instruction.  Use `insn_size_bits' instead    of `insn_bits' in an insn defition to modify it.  */
end_comment

begin_decl_stmt
name|int
name|insn_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset of the next insn, as expected in the disassembler    output.  */
end_comment

begin_decl_stmt
name|int
name|current_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset and name of the last label to be emitted.  */
end_comment

begin_decl_stmt
name|int
name|last_label_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|last_label_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable may be initialized in main() to `argv+1', if    `argc>1', so that tests are emitted only for instructions that    match exactly one of the given command-line arguments.  If it is    NULL, tests for all instructions are emitted.  It must be a    NULL-terminated array of pointers to strings (just like    `argv+1').  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|skip_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a counter used to walk the various arrays of ``random''    operand generation.  In simplified output mode, it is zeroed after    each insn, otherwise it just keeps growing.  */
end_comment

begin_decl_stmt
name|unsigned
name|randomization_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `define_insn' to create an array of funcs to define an insn,    then `insn' to refer to that insn when defining an insn group.  */
end_comment

begin_define
define|#
directive|define
name|define_insn
parameter_list|(
name|insname
parameter_list|,
name|funcs
modifier|...
parameter_list|)
define|\
value|func i_ ## insname[] = { funcs, { 0 } }
end_define

begin_define
define|#
directive|define
name|insn
parameter_list|(
name|insname
parameter_list|)
value|(i_ ## insname)
end_define

begin_comment
comment|/* Use these to output a comma followed by an optional space, a single    space, a plus sign, left and right square brackets and parentheses,    all of them properly quoted.  */
end_comment

begin_define
define|#
directive|define
name|comma
value|literal_q (", ", ", ?")
end_define

begin_define
define|#
directive|define
name|space
value|literal (" ")
end_define

begin_define
define|#
directive|define
name|tab
value|literal ("\t")
end_define

begin_define
define|#
directive|define
name|plus
value|literal_q ("+", "\\+")
end_define

begin_define
define|#
directive|define
name|lsqbkt
value|literal_q ("[", "\\[")
end_define

begin_define
define|#
directive|define
name|rsqbkt
value|literal_q ("]", "\\]")
end_define

begin_define
define|#
directive|define
name|lparen
value|literal_q ("(", "\\(")
end_define

begin_define
define|#
directive|define
name|rparen
value|literal_q (")", "\\)")
end_define

begin_comment
comment|/* Use this as a placeholder when you define a macro that expects an    argument, but you don't have anything to output there.  */
end_comment

begin_function
name|int
name|nothing
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|nothing
value|{ nothing }
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is to be used in the argument list of define_insn, causing a    string to be copied into both the assembly and the expected    disassembler output.  It is assumed not to modify the binary    encoding of the insn.  */
end_comment

begin_function
name|int
name|literal
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|literal
parameter_list|(
name|s
parameter_list|)
value|{ literal, { p1: (s) } }
block|{
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The characters `[', `]', `\\' and `^' must be quoted in the    disassembler-output matcher.  If a literal string contains any of    these characters, use literal_q instead of literal, and specify the    unquoted version (for as input) as the first argument, and the    quoted version (for expected disassembler output) as the second    one.  */
end_comment

begin_function
name|int
name|literal_q
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|literal_q
parameter_list|(
name|s
parameter_list|,
name|q
parameter_list|)
value|{ literal_q, { p1: (s), p2: (q) } }
block|{
name|data
operator|->
name|as_in
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
expr_stmt|;
name|data
operator|->
name|dis_out
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an insn name, check whether it should be skipped or not,    depending on skip_list.  Return non-zero if the insn is to be    skipped.  */
end_comment

begin_function
name|int
name|skip_insn
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|test
decl_stmt|;
if|if
condition|(
operator|!
name|skip_list
condition|)
return|return
literal|0
return|;
for|for
control|(
name|test
operator|=
name|skip_list
init|;
operator|*
name|test
condition|;
operator|++
name|test
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|*
name|test
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Use this to emit the actual insn name, with its opcode, in    architectures with fixed-length instructions.  */
end_comment

begin_function
name|int
name|insn_bits
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|insn_bits
parameter_list|(
name|name
parameter_list|,
name|bits
parameter_list|)
define|\
value|{ insn_bits, { p1: # name, w: bits } }
block|{
if|if
condition|(
name|skip_insn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
condition|)
return|return
literal|1
return|;
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
expr_stmt|;
name|data
operator|->
name|bits
operator|=
name|arg
operator|->
name|w
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to emit the insn name and its opcode in architectures    without a variable instruction length.  */
end_comment

begin_function
name|int
name|insn_size_bits
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|insn_size_bits
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|,
name|bits
parameter_list|)
define|\
value|{ insn_size_bits, { p1: # name, i1: size, w: bits } }
block|{
if|if
condition|(
name|skip_insn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
condition|)
return|return
literal|1
return|;
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
argument_list|)
expr_stmt|;
name|data
operator|->
name|bits
operator|=
name|arg
operator|->
name|w
expr_stmt|;
name|insn_size
operator|=
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to advance the random generator by one, in case it is    generating repetitive patterns.  It is usually good to arrange that    each insn consumes a prime number of ``random'' numbers, or, at    least, that it does not consume an exact power of two ``random''    numbers.  */
end_comment

begin_function
name|int
name|tick_random
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|tick_random
value|{ tick_random }
block|{
operator|++
name|randomization_counter
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Select the next ``random'' number from the array V of size S, and    advance the counter.  */
end_comment

begin_define
define|#
directive|define
name|get_bits_from_size
parameter_list|(
name|V
parameter_list|,
name|S
parameter_list|)
define|\
value|((V)[randomization_counter ++ % (S)])
end_define

begin_comment
comment|/* Utility macros.  `_get_bits_var', used in some macros below, assume    the names of the arrays used to define the ``random'' orders start    with `random_order_'.  */
end_comment

begin_define
define|#
directive|define
name|_get_bits_var
parameter_list|(
name|N
parameter_list|)
value|(random_order_ ## N)
end_define

begin_define
define|#
directive|define
name|_get_bits_size
parameter_list|(
name|V
parameter_list|)
value|(sizeof (V) / sizeof * (V))
end_define

begin_comment
comment|/* Use this within a `func_arg' to select one of the arrays below (or    any other array that starts with random_order_N.  */
end_comment

begin_define
define|#
directive|define
name|mk_get_bits
parameter_list|(
name|N
parameter_list|)
define|\
value|p2: _get_bits_var (N), i3: _get_bits_size (_get_bits_var (N))
end_define

begin_comment
comment|/* Simplified versions of get_bits_from_size for when you have access    to the array, so that its size can be implicitly calculated.  */
end_comment

begin_define
define|#
directive|define
name|get_bits_from
parameter_list|(
name|V
parameter_list|)
value|get_bits_from_size ((V),_get_bits_size ((V)))
end_define

begin_define
define|#
directive|define
name|get_bits
parameter_list|(
name|N
parameter_list|)
value|get_bits_from (_get_bits_var (N))
end_define

begin_comment
comment|/* Use `2u' to generate 2-bit unsigned values.  Good for selecting    registers randomly from a set of 4 registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|random_order_2u
index|[]
init|=
block|{
comment|/* This sequence was generated by hand so that no digit appers more        than once in any horizontal or vertical line.  */
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `3u' to generate 3-bit unsigned values.  Good for selecting    registers randomly from a set of 8 registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|random_order_3u
index|[]
init|=
block|{
comment|/* This sequence was generated by:        f(k) = 3k mod 8        except that the middle pairs were swapped.  */
literal|0
block|,
literal|6
block|,
literal|3
block|,
literal|1
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|5
block|,
comment|/* This sequence was generated by:        f(k) = 5k mod 8        except that the middle pairs were swapped.  */
literal|0
block|,
literal|2
block|,
literal|5
block|,
literal|7
block|,
literal|4
block|,
literal|6
block|,
literal|1
block|,
literal|3
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `4u' to generate 4-bit unsigned values.  Good for selecting    registers randomly from a set of 16 registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|random_order_4u
index|[]
init|=
block|{
comment|/* This sequence was generated by:        f(k) = 5k mod 16        except that the middle pairs were swapped.  */
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|10
block|,
literal|9
block|,
literal|4
block|,
literal|14
block|,
literal|3
block|,
literal|8
block|,
literal|13
block|,
literal|7
block|,
literal|2
block|,
literal|1
block|,
literal|12
block|,
literal|6
block|,
literal|11
block|,
comment|/* This sequence was generated by:        f(k) = 7k mod 16        except that the middle pairs were swapped.  */
literal|0
block|,
literal|7
block|,
literal|5
block|,
literal|14
block|,
literal|3
block|,
literal|12
block|,
literal|10
block|,
literal|1
block|,
literal|8
block|,
literal|15
block|,
literal|13
block|,
literal|6
block|,
literal|11
block|,
literal|4
block|,
literal|2
block|,
literal|9
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `5u' to generate 5-bit unsigned values.  Good for selecting    registers randomly from a set of 32 registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|random_order_5u
index|[]
init|=
block|{
comment|/* This sequence was generated by:        f(k) = (13k) mod 32        except that the middle pairs were swapped.  */
literal|0
block|,
literal|26
block|,
literal|13
block|,
literal|7
block|,
literal|20
block|,
literal|14
block|,
literal|1
block|,
literal|27
block|,
literal|8
block|,
literal|2
block|,
literal|21
block|,
literal|15
block|,
literal|28
block|,
literal|22
block|,
literal|9
block|,
literal|3
block|,
literal|16
block|,
literal|10
block|,
literal|29
block|,
literal|23
block|,
literal|4
block|,
literal|30
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|18
block|,
literal|5
block|,
literal|31
block|,
literal|12
block|,
literal|6
block|,
literal|25
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `7s' to generate 7-bit signed values.  Good for selecting    ``interesting'' constants from -64 to +63.  */
end_comment

begin_decl_stmt
name|int
name|random_order_7s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|64
block|,
literal|63
block|,
operator|-
literal|32
block|,
literal|32
block|,
literal|24
block|,
operator|-
literal|20
block|,
literal|9
block|,
operator|-
literal|27
block|,
operator|-
literal|31
block|,
literal|33
block|,
literal|40
block|,
operator|-
literal|2
block|,
operator|-
literal|5
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `8s' to generate 8-bit signed values.  Good for selecting    ``interesting'' constants from -128 to +127.  */
end_comment

begin_decl_stmt
name|int
name|random_order_8s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|128
block|,
literal|127
block|,
operator|-
literal|32
block|,
literal|32
block|,
literal|24
block|,
operator|-
literal|20
block|,
literal|73
block|,
operator|-
literal|27
block|,
operator|-
literal|95
block|,
literal|33
block|,
literal|104
block|,
operator|-
literal|2
block|,
operator|-
literal|69
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `9s' to generate 9-bit signed values.  Good for selecting    ``interesting'' constants from -256 to +255.  */
end_comment

begin_decl_stmt
name|int
name|random_order_9s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|256
block|,
literal|255
block|,
operator|-
literal|64
block|,
literal|64
block|,
literal|72
block|,
operator|-
literal|40
block|,
literal|73
block|,
operator|-
literal|137
block|,
operator|-
literal|158
block|,
literal|37
block|,
literal|104
block|,
operator|-
literal|240
block|,
operator|-
literal|69
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `16s' to generate 16-bit signed values.  Good for selecting    ``interesting'' constants from -32768 to +32767.  */
end_comment

begin_decl_stmt
name|int
name|random_order_16s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
operator|-
literal|32768
block|,
literal|32767
block|,
operator|(
operator|-
literal|1
operator|<<
literal|15
operator|)
operator||
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
block|,
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
block|,
literal|0x1234
block|,
operator|(
operator|-
literal|1
operator|<<
literal|15
operator|)
operator||
literal|0x8765
block|,
literal|0x0180
block|,
operator|(
operator|-
literal|1
operator|<<
literal|15
operator|)
operator||
literal|0x8001
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `24s' to generate 24-bit signed values.  Good for selecting    ``interesting'' constants from -2^23 to 2^23-1.  */
end_comment

begin_decl_stmt
name|int
name|random_order_24s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
operator|-
literal|1
operator|<<
literal|23
block|,
literal|1
operator|<<
literal|23
operator|-
literal|1
block|,
operator|(
operator|-
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
operator|(
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
operator|)
operator|<<
literal|8
operator|)
operator||
literal|16
block|,
operator|(
operator|(
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
operator|)
operator|<<
literal|8
operator|)
operator||
literal|16
block|,
literal|0x123456
block|,
operator|(
operator|-
literal|1
operator|<<
literal|23
operator|)
operator||
literal|0x876543
block|,
literal|0x01ff80
block|,
operator|(
operator|-
literal|1
operator|<<
literal|23
operator|)
operator||
literal|0x80ff01
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `32s' to generate 32-bit signed values.  Good for selecting    ``interesting'' constants from -2^31 to 2^31-1.  */
end_comment

begin_decl_stmt
name|int
name|random_order_32s
index|[]
init|=
block|{
comment|/* Sequence generated by hand, to explore limit values and a few        intermediate values selected by chance.  Keep the number of        intermediate values low, to ensure that the limit values are        generated often enough.  */
operator|-
literal|1
operator|<<
literal|31
block|,
literal|1
operator|<<
literal|31
operator|-
literal|1
block|,
operator|(
operator|-
literal|1
operator|<<
literal|31
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
operator|)
operator|<<
literal|8
operator|)
operator||
literal|16
operator|)
operator|<<
literal|8
operator|)
operator||
literal|8
block|,
operator|(
operator|(
operator|(
operator|(
operator|(
literal|64
operator|<<
literal|8
operator|)
operator||
literal|32
operator|)
operator|<<
literal|8
operator|)
operator||
literal|16
operator|)
operator|<<
literal|8
operator|)
operator||
literal|8
block|,
literal|0x12345678
block|,
operator|(
operator|-
literal|1
operator|<<
literal|31
operator|)
operator||
literal|0x87654321
block|,
literal|0x01ffff80
block|,
operator|(
operator|-
literal|1
operator|<<
literal|31
operator|)
operator||
literal|0x80ffff01
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function computes the number of digits needed to represent a    given number.  */
end_comment

begin_function
name|unsigned
name|long
name|ulen
parameter_list|(
name|unsigned
name|long
name|i
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|count
control|)
name|i
operator|/=
name|base
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Use this to generate a signed constant of the given size, shifted    by the given amount, with the specified endianness.  */
end_comment

begin_function
name|int
name|signed_constant
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|signed_constant
parameter_list|(
name|bits
parameter_list|,
name|shift
parameter_list|,
name|revert
parameter_list|)
define|\
value|{ signed_constant, { i1: shift, i2: bits * (revert ? -1 : 1), \ 		       mk_get_bits (bits ## s) } }
block|{
name|long
name|val
init|=
name|get_bits_from_size
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|,
name|arg
operator|->
name|i3
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|val
operator|>=
literal|0
condition|?
name|ulen
argument_list|(
name|val
argument_list|,
literal|10
argument_list|)
else|:
operator|(
literal|1
operator|+
name|ulen
argument_list|(
operator|-
name|val
argument_list|,
literal|10
argument_list|)
operator|)
operator|)
decl_stmt|;
name|int
name|nbits
init|=
operator|(
name|arg
operator|->
name|i2
operator|>=
literal|0
condition|?
name|arg
operator|->
name|i2
else|:
operator|-
name|arg
operator|->
name|i2
operator|)
decl_stmt|;
name|word
name|bits
init|=
operator|(
operator|(
name|word
operator|)
name|val
operator|)
operator|&
operator|(
operator|(
operator|(
operator|(
operator|(
name|word
operator|)
literal|1
operator|)
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
operator|->
name|as_in
argument_list|,
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|i2
operator|<
literal|0
condition|)
block|{
name|word
name|rbits
init|=
literal|0
decl_stmt|;
do|do
block|{
name|rbits
operator|<<=
literal|8
expr_stmt|;
name|rbits
operator||=
name|bits
operator|&
literal|0xff
expr_stmt|;
name|bits
operator|>>=
literal|8
expr_stmt|;
name|nbits
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|nbits
operator|>
literal|0
condition|)
do|;
name|bits
operator|=
name|rbits
expr_stmt|;
block|}
name|data
operator|->
name|bits
operator|=
name|bits
operator|<<
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to generate a unsigned constant of the given size, shifted    by the given amount, with the specified endianness.  */
end_comment

begin_function
name|int
name|unsigned_constant
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|unsigned_constant
parameter_list|(
name|bits
parameter_list|,
name|shift
parameter_list|,
name|revert
parameter_list|)
define|\
value|{ unsigned_constant, { i1: shift, i2: bits * (revert ? -1 : 1), \ 			 mk_get_bits (bits ## s) } }
block|{
name|int
name|nbits
init|=
operator|(
name|arg
operator|->
name|i2
operator|>=
literal|0
condition|?
name|arg
operator|->
name|i2
else|:
operator|-
name|arg
operator|->
name|i2
operator|)
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|get_bits_from_size
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|,
name|arg
operator|->
name|i3
argument_list|)
operator|&
operator|(
operator|(
operator|(
operator|(
operator|(
name|word
operator|)
literal|1
operator|)
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|len
init|=
name|ulen
argument_list|(
name|val
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|word
name|bits
init|=
name|val
decl_stmt|;
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
operator|->
name|as_in
argument_list|,
literal|"%lu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|i2
operator|<
literal|0
condition|)
block|{
name|word
name|rbits
init|=
literal|0
decl_stmt|;
do|do
block|{
name|rbits
operator|<<=
literal|8
expr_stmt|;
name|rbits
operator||=
name|bits
operator|&
literal|0xff
expr_stmt|;
name|bits
operator|>>=
literal|8
expr_stmt|;
name|nbits
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|nbits
operator|>
literal|0
condition|)
do|;
name|bits
operator|=
name|rbits
expr_stmt|;
block|}
name|data
operator|->
name|bits
operator|=
name|bits
operator|<<
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to generate an absolute address of the given size, shifted    by the given amount, with the specified endianness.  */
end_comment

begin_function
name|int
name|absolute_address
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|absolute_address
value|(bits, shift, revert) \   { absolute_address, { i1: shift, i2: bits * (revert ? -1 : 1), \ 			mk_get_bits (bits ## s) } }
block|{
name|int
name|nbits
init|=
operator|(
name|arg
operator|->
name|i2
operator|>=
literal|0
condition|?
name|arg
operator|->
name|i2
else|:
operator|-
name|arg
operator|->
name|i2
operator|)
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|get_bits_from_size
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|,
name|arg
operator|->
name|i3
argument_list|)
operator|&
operator|(
operator|(
operator|(
operator|(
operator|(
name|word
operator|)
literal|1
operator|)
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|word
name|bits
init|=
name|val
decl_stmt|;
name|data
operator|->
name|as_in
operator|=
name|malloc
argument_list|(
name|ulen
argument_list|(
name|val
argument_list|,
literal|10
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
operator|->
name|as_in
argument_list|,
literal|"%lu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|data
operator|->
name|dis_out
operator|=
name|malloc
argument_list|(
name|nbits
operator|/
literal|4
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
operator|->
name|dis_out
argument_list|,
literal|"0*%0*lx<[^>]*>"
argument_list|,
name|nbits
operator|/
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|i2
operator|<
literal|0
condition|)
block|{
name|word
name|rbits
init|=
literal|0
decl_stmt|;
do|do
block|{
name|rbits
operator|<<=
literal|8
expr_stmt|;
name|rbits
operator||=
name|bits
operator|&
literal|0xff
expr_stmt|;
name|bits
operator|>>=
literal|8
expr_stmt|;
name|nbits
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|nbits
operator|>
literal|0
condition|)
do|;
name|bits
operator|=
name|rbits
expr_stmt|;
block|}
name|data
operator|->
name|bits
operator|=
name|bits
operator|<<
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to generate a register name that starts with a given    prefix, and is followed by a number generated by `gen' (see    mk_get_bits below).  The register number is shifted `shift' bits    left before being stored in the binary insn.  */
end_comment

begin_function
name|int
name|reg_p
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|reg_p
parameter_list|(
name|prefix
parameter_list|,
name|shift
parameter_list|,
name|gen
parameter_list|)
define|\
value|{ reg_p, { i1: (shift), p1: (prefix), gen } }
block|{
name|unsigned
name|reg
init|=
name|get_bits_from_size
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|,
name|arg
operator|->
name|i3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|regname
init|=
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|p1
decl_stmt|;
name|data
operator|->
name|as_in
operator|=
name|data
operator|->
name|dis_out
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|regname
argument_list|)
operator|+
name|ulen
argument_list|(
name|reg
argument_list|,
literal|10
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
operator|->
name|as_in
argument_list|,
literal|"%s%u"
argument_list|,
name|regname
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|data
operator|->
name|bits
operator|=
name|reg
expr_stmt|;
name|data
operator|->
name|bits
operator|<<=
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Use this to generate a register name taken from an array.  The    index into the array `names' is to be produced by `gen', but `mask'    may be used to filter out some of the bits before choosing the    disassembler output and the bits for the binary insn, shifted left    by `shift'.  For example, if registers have canonical names, but    can also be referred to by aliases, the array can be n times larger    than the actual number of registers, and the mask is then used to    pick the canonical name for the disassembler output, and to    eliminate the extra bits from the binary output.  */
end_comment

begin_function
name|int
name|reg_r
parameter_list|(
name|func_arg
modifier|*
name|arg
parameter_list|,
name|insn_data
modifier|*
name|data
parameter_list|)
define|#
directive|define
name|reg_r
parameter_list|(
name|names
parameter_list|,
name|shift
parameter_list|,
name|mask
parameter_list|,
name|gen
parameter_list|)
define|\
value|{ reg_r, { i1: (shift), i2: (mask), p1: (names), gen } }
block|{
name|unsigned
name|reg
init|=
name|get_bits_from_size
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|arg
operator|->
name|p2
argument_list|,
name|arg
operator|->
name|i3
argument_list|)
decl_stmt|;
name|data
operator|->
name|as_in
operator|=
name|strdup
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg
operator|->
name|p1
operator|)
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|reg
operator|&=
name|arg
operator|->
name|i2
expr_stmt|;
name|data
operator|->
name|dis_out
operator|=
name|strdup
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg
operator|->
name|p1
operator|)
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|data
operator|->
name|bits
operator|=
name|reg
expr_stmt|;
name|data
operator|->
name|bits
operator|<<=
name|arg
operator|->
name|i1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a NULL-terminated array of insns-definitions (pointers to    arrays of funcs), output test code for the insns to as_in (assembly    input) and dis_out (expected disassembler output).  */
end_comment

begin_function
name|void
name|output_insns
parameter_list|(
name|func
modifier|*
modifier|*
name|insn
parameter_list|,
name|FILE
modifier|*
name|as_in
parameter_list|,
name|FILE
modifier|*
name|dis_out
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|insn
condition|;
operator|++
name|insn
control|)
block|{
name|insn_data
modifier|*
name|data
decl_stmt|;
name|func
modifier|*
name|parts
init|=
operator|*
name|insn
decl_stmt|;
name|int
name|part_count
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
comment|/* Figure out how many funcs have to be called.  */
while|while
condition|(
name|parts
index|[
name|part_count
index|]
operator|.
name|func
condition|)
operator|++
name|part_count
expr_stmt|;
comment|/* Allocate storage for the output area of each func.  */
name|data
operator|=
operator|(
name|insn_data
operator|*
operator|)
name|malloc
argument_list|(
name|part_count
operator|*
sizeof|sizeof
argument_list|(
name|insn_data
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SIMPLIFY_OUTPUT
name|randomization_counter
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Repeat each insn several times.  */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|INSN_REPEAT
condition|;
operator|++
name|r
control|)
endif|#
directive|endif
block|{
name|unsigned
name|saved_rc
init|=
name|randomization_counter
decl_stmt|;
name|int
name|part
decl_stmt|;
name|word
name|bits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|part_count
condition|;
operator|++
name|part
control|)
block|{
comment|/* Zero-initialize the storage.  */
name|data
index|[
name|part
index|]
operator|.
name|as_in
operator|=
name|data
index|[
name|part
index|]
operator|.
name|dis_out
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|part
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
comment|/* If a func returns non-zero, skip this line.  */
if|if
condition|(
name|parts
index|[
name|part
index|]
operator|.
name|func
argument_list|(
operator|&
name|parts
index|[
name|part
index|]
operator|.
name|arg
argument_list|,
operator|&
name|data
index|[
name|part
index|]
argument_list|)
condition|)
goto|goto
name|skip
goto|;
comment|/* Otherwise, get its output bit pattern into the total 	         bit pattern.  */
name|bits
operator||=
name|data
index|[
name|part
index|]
operator|.
name|bits
expr_stmt|;
block|}
if|if
condition|(
name|as_in
condition|)
block|{
comment|/* Output the whole assembly line.  */
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|as_in
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|part_count
condition|;
operator|++
name|part
control|)
if|if
condition|(
name|data
index|[
name|part
index|]
operator|.
name|as_in
condition|)
name|fputs
argument_list|(
name|data
index|[
name|part
index|]
operator|.
name|as_in
argument_list|,
name|as_in
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|as_in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dis_out
condition|)
block|{
comment|/* Output the disassembler expected output line, 	         starting with the offset and the insn binary pattern, 	         just like objdump outputs.  Because objdump sometimes 	         inserts spaces between each byte in the insn binary 	         pattern, make the space optional.  */
name|fprintf
argument_list|(
name|dis_out
argument_list|,
literal|"0*%x<"
argument_list|,
name|current_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_label_name
condition|)
if|if
condition|(
name|current_offset
operator|==
name|last_label_offset
condition|)
name|fputs
argument_list|(
name|last_label_name
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dis_out
argument_list|,
literal|"%s\\+0x%x"
argument_list|,
name|last_label_name
argument_list|,
name|current_offset
operator|-
name|last_label_offset
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"[^>]*"
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
name|insn_size
init|;
name|part
operator|--
operator|>
literal|0
condition|;
control|)
name|fprintf
argument_list|(
name|dis_out
argument_list|,
literal|"%02x ?"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|bits
operator|>>
operator|(
name|part
operator|*
literal|8
operator|)
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" *\t"
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
if|#
directive|if
name|DISASSEMBLER_TEST
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|part_count
condition|;
operator|++
name|part
control|)
if|if
condition|(
name|data
index|[
name|part
index|]
operator|.
name|dis_out
condition|)
name|fputs
argument_list|(
name|data
index|[
name|part
index|]
operator|.
name|dis_out
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If we're not testing the DISASSEMBLER, just match 	         anything.  */
name|fputs
argument_list|(
literal|".*"
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
if|#
directive|if
name|OUTPUT_RANDOMIZATION_COUNTER
name|fprintf
argument_list|(
name|dis_out
argument_list|,
literal|"# %i\n"
argument_list|,
name|randomization_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Account for the insn_size bytes we've just output.  */
name|current_offset
operator|+=
name|insn_size
expr_stmt|;
comment|/* Release the memory that each func may have allocated.  */
for|for
control|(
init|;
name|part
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|skip
label|:
if|if
condition|(
name|data
index|[
name|part
index|]
operator|.
name|as_in
condition|)
name|free
argument_list|(
name|data
index|[
name|part
index|]
operator|.
name|as_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
index|[
name|part
index|]
operator|.
name|dis_out
operator|&&
name|data
index|[
name|part
index|]
operator|.
name|dis_out
operator|!=
name|data
index|[
name|part
index|]
operator|.
name|as_in
condition|)
name|free
argument_list|(
name|data
index|[
name|part
index|]
operator|.
name|dis_out
argument_list|)
expr_stmt|;
block|}
comment|/* There's nothing random here, don't repeat this insn.  */
if|if
condition|(
name|randomization_counter
operator|==
name|saved_rc
condition|)
break|break;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each group, output an asm label and the insns of the group.  */
end_comment

begin_function
name|void
name|output_groups
parameter_list|(
name|group_t
name|group
index|[]
parameter_list|,
name|FILE
modifier|*
name|as_in
parameter_list|,
name|FILE
modifier|*
name|dis_out
parameter_list|)
block|{
for|for
control|(
init|;
name|group
operator|->
name|name
condition|;
operator|++
name|group
control|)
block|{
name|fprintf
argument_list|(
name|as_in
argument_list|,
literal|"%s:\n"
argument_list|,
name|group
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dis_out
argument_list|,
literal|"# %s:\n"
argument_list|,
name|group
operator|->
name|name
argument_list|)
expr_stmt|;
name|last_label_offset
operator|=
name|current_offset
expr_stmt|;
name|last_label_name
operator|=
name|group
operator|->
name|name
expr_stmt|;
name|output_insns
argument_list|(
name|group
operator|->
name|insns
argument_list|,
name|as_in
argument_list|,
name|dis_out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

