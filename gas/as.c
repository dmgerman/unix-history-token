begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* as.c - GAS main program.    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Main program for AS; a 32-bit assembler of GNU.    Understands command arguments.    Has a few routines that don't fit in other modules because they    are shared.      			bugs       : initialisers   	Since no-one else says they will support them in future: I    don't support them now.  */
end_comment

begin_define
define|#
directive|define
name|COMMON
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_include
include|#
directive|include
file|"bfdver.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ITBL_CPU
end_ifdef

begin_include
include|#
directive|include
file|"itbl-ops.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|itbl_parse
parameter_list|(
name|itbl_file
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|itbl_init
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_SBRK
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USING_CGEN
end_ifdef

begin_comment
comment|/* Perform any cgen specific initialisation for gas.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|gas_cgen_begin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Keep a record of the itbl files we read in.  */
end_comment

begin_struct
struct|struct
name|itbl_file_list
block|{
name|struct
name|itbl_file_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We build a list of defsyms as we read the options, and then define    them after we have initialized everything.  */
end_comment

begin_struct
struct|struct
name|defsym_list
block|{
name|struct
name|defsym_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|valueT
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* True if a listing is wanted.  */
end_comment

begin_decl_stmt
name|int
name|listing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of debugging to generate.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|debug_type
init|=
name|DEBUG_UNSPECIFIED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_gnu_debug_info_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MD_DEBUG_FORMAT_SELECTOR
end_ifndef

begin_define
define|#
directive|define
name|MD_DEBUG_FORMAT_SELECTOR
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|enum
name|debug_info_type
function_decl|(
modifier|*
name|md_debug_format_selector
function_decl|)
parameter_list|(
name|int
modifier|*
parameter_list|)
init|=
name|MD_DEBUG_FORMAT_SELECTOR
function_decl|;
end_function_decl

begin_comment
comment|/* Maximum level of macro nesting.  */
end_comment

begin_decl_stmt
name|int
name|max_macro_nest
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv[0]  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default obstack chunk size.  If we set this to zero, the    obstack code will use whatever will fit in a 4096 byte block.  */
end_comment

begin_decl_stmt
name|int
name|chunksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To monitor memory allocation more effectively, make this non-zero.    Then the chunk sizes for gas and bfd will be reduced.  */
end_comment

begin_decl_stmt
name|int
name|debug_memory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable verbose mode.  */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|reg_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|expr_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|text_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|data_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|segT
name|bss_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of listing file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|listing_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|defsym_list
modifier|*
name|defsyms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|itbl_file_list
modifier|*
name|itbl_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|start_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flag_macro_alternate
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USE_EMULATIONS
end_ifdef

begin_define
define|#
directive|define
name|EMULATION_ENVIRON
value|"AS_EMULATION"
end_define

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|mipsbelf
decl_stmt|,
name|mipslelf
decl_stmt|,
name|mipself
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|mipsbecoff
decl_stmt|,
name|mipslecoff
decl_stmt|,
name|mipsecoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|i386coff
decl_stmt|,
name|i386elf
decl_stmt|,
name|i386aout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|emulation
name|crisaout
decl_stmt|,
name|criself
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|emulation
modifier|*
specifier|const
name|emulations
index|[]
init|=
block|{
name|EMULATIONS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|n_emulations
init|=
sizeof|sizeof
argument_list|(
name|emulations
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|emulations
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|select_emulation_mode
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|em
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"--em"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|argc
condition|)
goto|goto
name|do_default
goto|;
name|p
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"missing emulation mode name"
argument_list|)
argument_list|)
expr_stmt|;
name|em
operator|=
name|p
expr_stmt|;
name|do_default
label|:
if|if
condition|(
name|em
operator|==
literal|0
condition|)
name|em
operator|=
name|getenv
argument_list|(
name|EMULATION_ENVIRON
argument_list|)
expr_stmt|;
if|if
condition|(
name|em
operator|==
literal|0
condition|)
name|em
operator|=
name|DEFAULT_EMULATION
expr_stmt|;
if|if
condition|(
name|em
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_emulations
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|emulations
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|em
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_emulations
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized emulation name `%s'"
argument_list|)
argument_list|,
name|em
argument_list|)
expr_stmt|;
name|this_emulation
operator|=
name|emulations
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|this_emulation
operator|=
name|emulations
index|[
literal|0
index|]
expr_stmt|;
name|this_emulation
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|default_emul_bfd_name
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|common_emul_init
parameter_list|(
name|void
parameter_list|)
block|{
name|this_format
operator|=
name|this_emulation
operator|->
name|format
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|leading_underscore
operator|==
literal|2
condition|)
name|this_emulation
operator|->
name|leading_underscore
operator|=
name|this_format
operator|->
name|dfl_leading_underscore
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|default_endian
operator|!=
literal|2
condition|)
name|target_big_endian
operator|=
name|this_emulation
operator|->
name|default_endian
expr_stmt|;
if|if
condition|(
name|this_emulation
operator|->
name|fake_label_name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|this_emulation
operator|->
name|leading_underscore
condition|)
name|this_emulation
operator|->
name|fake_label_name
operator|=
literal|"L0\001"
expr_stmt|;
else|else
comment|/* What other parameters should we test?  */
name|this_emulation
operator|->
name|fake_label_name
operator|=
literal|".L0\001"
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_version_id
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|printed
decl_stmt|;
if|if
condition|(
name|printed
condition|)
return|return;
name|printed
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"GNU assembler version %s (%s) using BFD version %s\n"
argument_list|)
argument_list|,
name|VERSION
argument_list|,
name|TARGET_ALIAS
argument_list|,
name|BFD_VERSION_STRING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option...] [asmfile...]\n"
argument_list|)
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ Options:\n\   -a[sub-option...]	  turn on listings\n\                       	  Sub-options [default hls]:\n\                       	  c      omit false conditionals\n\                       	  d      omit debugging directives\n\                       	  h      include high-level source\n\                       	  l      include assembly\n\                       	  m      include macro expansions\n\                       	  n      omit forms processing\n\                       	  s      include symbols\n\                       	  =FILE  list to FILE (must be last sub-option)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --alternate             initially turn on alternate macro syntax\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -D                      produce assembler debugging messages\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --defsym SYM=VAL        define symbol SYM to given value\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMULATIONS
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|def_em
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\   --em=["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_emulations
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s | "
argument_list|,
name|emulations
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s]\n"
argument_list|,
name|emulations
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|def_em
operator|=
name|getenv
argument_list|(
name|EMULATION_ENVIRON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def_em
condition|)
name|def_em
operator|=
name|DEFAULT_EMULATION
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\                           emulate output (default %s)\n"
argument_list|)
argument_list|,
name|def_em
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_MAYBE_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --execstack             require executable stack for this object\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --noexecstack           don't require executable stack for this object\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -f                      skip whitespace and comment preprocessing\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -g --gen-debug          generate debugging information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --gstabs                generate STABS debugging information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --gstabs+               generate STABS debug info with GNU extensions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --gdwarf-2              generate DWARF2 debugging information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --hash-size=<value>     set the hash table size close to<value>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --help                  show this message and exit\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --target-help           show target specific options\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I DIR                  add DIR to search list for .include directives\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -J                      don't warn about signed overflow\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -K                      warn when differences altered for long displacements\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -L,--keep-locals        keep local symbols (e.g. starting with `L')\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -M,--mri                assemble in MRI compatibility mode\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --MD FILE               write dependency information in FILE (default none)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -nocpp                  ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -o OBJFILE              name the object-file output OBJFILE (default a.out)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -R                      fold data section into text section\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --reduce-memory-overheads \n\                           prefer smaller memory use at the cost of longer\n\                           assembly times\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --statistics            print various measured statistics from execution\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --strip-local-absolute  strip local absolute symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --traditional-format    Use same format as native assembler when possible\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --version               print assembler version number and exit\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -W  --no-warn           suppress warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --warn                  don't suppress warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --fatal-warnings        treat warnings as errors\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --itbl INSTTBL          extend instruction set to include instructions\n\                           matching the specifications defined in file INSTTBL\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -w                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -X                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Z                      generate object file even after errors\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --listing-lhs-width     set the width in words of the output data column of\n\                           the listing\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --listing-lhs-width2    set the width in words of the continuation lines\n\                           of the output data column; ignored if smaller than\n\                           the width of the first line\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --listing-rhs-width     set the max width in characters of the lines from\n\                           the source file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   --listing-cont-lines    set the maximum number of continuation lines used\n\                           for the output data column of the listing\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   @FILE                   read options from FILE\n"
argument_list|)
argument_list|)
expr_stmt|;
name|md_show_usage
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
operator|&&
name|stream
operator|==
name|stdout
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Since it is easy to do here we interpret the special arg "-"    to mean "use stdin" and we set that argv[] pointing to "".    After we have munged argv[], the only things left are source file    name(s) and ""(s) denoting stdin. These file names are used    (perhaps more than once) later.     check for new machine-dep cmdline options in    md_parse_option definitions in config/tc-*.c.  */
end_comment

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
modifier|*
name|pargc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|pargv
parameter_list|)
block|{
name|int
name|old_argc
decl_stmt|;
name|int
name|new_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
comment|/* Starting the short option string with '-' is for programs that      expect options and other ARGV-elements in any order and that care about      the ordering of the two.  We describe each non-option ARGV-element      as if it were the argument of an option with character code 1.  */
name|char
modifier|*
name|shortopts
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
name|md_shortopts
decl_stmt|;
specifier|static
specifier|const
name|char
name|std_shortopts
index|[]
init|=
block|{
literal|'-'
block|,
literal|'J'
block|,
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* -K is not meaningful if .word is not being hacked.  */
literal|'K'
block|,
endif|#
directive|endif
literal|'L'
block|,
literal|'M'
block|,
literal|'R'
block|,
literal|'W'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|':'
block|,
literal|':'
block|,
literal|'D'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|':'
block|,
literal|':'
block|,
literal|'I'
block|,
literal|':'
block|,
literal|'o'
block|,
literal|':'
block|,
ifndef|#
directive|ifndef
name|VMS
comment|/* -v takes an argument on VMS, so we don't make it a generic        option.  */
literal|'v'
block|,
endif|#
directive|endif
literal|'w'
block|,
literal|'X'
block|,
comment|/* New option for extending instruction set (see also --itbl below).  */
literal|'t'
block|,
literal|':'
block|,
literal|'\0'
block|}
decl_stmt|;
name|struct
name|option
modifier|*
name|longopts
decl_stmt|;
specifier|extern
name|struct
name|option
name|md_longopts
index|[]
decl_stmt|;
specifier|extern
name|size_t
name|md_longopts_size
decl_stmt|;
comment|/* Codes used for the long options with no short synonyms.  */
enum|enum
name|option_values
block|{
name|OPTION_HELP
init|=
name|OPTION_STD_BASE
block|,
name|OPTION_NOCPP
block|,
name|OPTION_STATISTICS
block|,
name|OPTION_VERSION
block|,
name|OPTION_DUMPCONFIG
block|,
name|OPTION_VERBOSE
block|,
name|OPTION_EMULATION
block|,
name|OPTION_DEFSYM
block|,
name|OPTION_INSTTBL
block|,
name|OPTION_LISTING_LHS_WIDTH
block|,
name|OPTION_LISTING_LHS_WIDTH2
block|,
name|OPTION_LISTING_RHS_WIDTH
block|,
name|OPTION_LISTING_CONT_LINES
block|,
name|OPTION_DEPFILE
block|,
name|OPTION_GSTABS
block|,
name|OPTION_GSTABS_PLUS
block|,
name|OPTION_GDWARF2
block|,
name|OPTION_STRIP_LOCAL_ABSOLUTE
block|,
name|OPTION_TRADITIONAL_FORMAT
block|,
name|OPTION_WARN
block|,
name|OPTION_TARGET_HELP
block|,
name|OPTION_EXECSTACK
block|,
name|OPTION_NOEXECSTACK
block|,
name|OPTION_ALTERNATE
block|,
name|OPTION_AL
block|,
name|OPTION_HASH_TABLE_SIZE
block|,
name|OPTION_REDUCE_MEMORY_OVERHEADS
block|,
name|OPTION_WARN_FATAL
comment|/* When you add options here, check that they do        not collide with OPTION_MD_BASE.  See as.h.  */
block|}
enum|;
specifier|static
specifier|const
name|struct
name|option
name|std_longopts
index|[]
init|=
block|{
comment|/* Note: commas are placed at the start of the line rather than        the end of the preceeding line so that it is simpler to        selectively add and remove lines from this list.  */
block|{
literal|"alternate"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ALTERNATE
block|}
comment|/* The entry for "a" is here to prevent getopt_long_only() from        considering that -a is an abbreviation for --alternate.  This is        necessary because -a=<FILE> is a valid switch but getopt would        normally reject it since --alternate does not take an argument.  */
block|,
block|{
literal|"a"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'a'
block|}
comment|/* Handle -al=<FILE>.  */
block|,
block|{
literal|"al"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_AL
block|}
block|,
block|{
literal|"defsym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFSYM
block|}
block|,
block|{
literal|"dump-config"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DUMPCONFIG
block|}
block|,
block|{
literal|"emulation"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_EMULATION
block|}
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_MAYBE_ELF
block|,
block|{
literal|"execstack"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EXECSTACK
block|}
block|,
block|{
literal|"noexecstack"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOEXECSTACK
block|}
endif|#
directive|endif
block|,
block|{
literal|"fatal-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_FATAL
block|}
block|,
block|{
literal|"gdwarf-2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GDWARF2
block|}
comment|/* GCC uses --gdwarf-2 but GAS uses to use --gdwarf2,        so we keep it here for backwards compatibility.  */
block|,
block|{
literal|"gdwarf2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GDWARF2
block|}
block|,
block|{
literal|"gen-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"gstabs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GSTABS
block|}
block|,
block|{
literal|"gstabs+"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GSTABS_PLUS
block|}
block|,
block|{
literal|"hash-size"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_HASH_TABLE_SIZE
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_HELP
block|}
comment|/* New option for extending instruction set (see also -t above).        The "-t file" or "--itbl file" option extends the basic set of        valid instructions by reading "file", a text file containing a        list of instruction formats.  The additional opcodes and their        formats are added to the built-in set of instructions, and        mnemonics for new registers may also be defined.  */
block|,
block|{
literal|"itbl"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_INSTTBL
block|}
comment|/* getopt allows abbreviations, so we do this to stop it from        treating -k as an abbreviation for --keep-locals.  Some        ports use -k to enable PIC assembly.  */
block|,
block|{
literal|"keep-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"keep-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"listing-lhs-width"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_LHS_WIDTH
block|}
block|,
block|{
literal|"listing-lhs-width2"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_LHS_WIDTH2
block|}
block|,
block|{
literal|"listing-rhs-width"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_RHS_WIDTH
block|}
block|,
block|{
literal|"listing-cont-lines"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_LISTING_CONT_LINES
block|}
block|,
block|{
literal|"MD"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEPFILE
block|}
block|,
block|{
literal|"mri"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"nocpp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOCPP
block|}
block|,
block|{
literal|"no-warn"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'W'
block|}
block|,
block|{
literal|"reduce-memory-overheads"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_REDUCE_MEMORY_OVERHEADS
block|}
block|,
block|{
literal|"statistics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STATISTICS
block|}
block|,
block|{
literal|"strip-local-absolute"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STRIP_LOCAL_ABSOLUTE
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERSION
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
block|{
literal|"target-help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TARGET_HELP
block|}
block|,
block|{
literal|"traditional-format"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRADITIONAL_FORMAT
block|}
block|,
block|{
literal|"warn"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN
block|}
block|}
decl_stmt|;
comment|/* Construct the option lists from the standard list and the target      dependent list.  Include space for an extra NULL option and      always NULL terminate.  */
name|shortopts
operator|=
name|concat
argument_list|(
name|std_shortopts
argument_list|,
name|md_shortopts
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|longopts
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
operator|+
name|md_longopts_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|option
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|longopts
argument_list|,
name|std_longopts
argument_list|,
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|longopts
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
argument_list|,
name|md_longopts
argument_list|,
name|md_longopts_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|longopts
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|std_longopts
argument_list|)
operator|+
name|md_longopts_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|option
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a local copy of the old argv.  */
name|old_argc
operator|=
operator|*
name|pargc
expr_stmt|;
name|old_argv
operator|=
operator|*
name|pargv
expr_stmt|;
comment|/* Initialize a new argv that contains no options.  */
name|new_argv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|old_argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|old_argv
index|[
literal|0
index|]
expr_stmt|;
name|new_argc
operator|=
literal|1
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* getopt_long_only is like getopt_long, but '-' as well as '--' can 	 indicate a long option.  */
name|int
name|longind
decl_stmt|;
name|int
name|optc
init|=
name|getopt_long_only
argument_list|(
name|old_argc
argument_list|,
name|old_argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
decl_stmt|;
if|if
condition|(
name|optc
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|optc
condition|)
block|{
default|default:
comment|/* md_parse_option should return 1 if it recognizes optc, 	     0 if not.  */
if|if
condition|(
name|md_parse_option
argument_list|(
name|optc
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* `-v' isn't included in the general short_opts list, so check for 	     it explicitly here before deciding we've gotten a bad argument.  */
if|if
condition|(
name|optc
operator|==
literal|'v'
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* Telling getopt to treat -v's value as optional can result 		 in it picking up a following filename argument here.  The 		 VMS code in md_parse_option can return 0 in that case, 		 but it has no way of pushing the filename argument back.  */
if|if
condition|(
name|optarg
operator|&&
operator|*
name|optarg
condition|)
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|optarg
operator|,
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
else|else
else|#
directive|else
case|case
literal|'v'
case|:
endif|#
directive|endif
case|case
name|OPTION_VERBOSE
case|:
name|print_version_id
argument_list|()
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized option -%c%s"
argument_list|)
argument_list|,
name|optc
argument_list|,
name|optarg
condition|?
name|optarg
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'?'
case|:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* File name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
condition|)
name|optarg
operator|=
literal|""
expr_stmt|;
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|new_argv
index|[
name|new_argc
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPTION_TARGET_HELP
case|:
name|md_show_usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_HELP
case|:
name|show_usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_NOCPP
case|:
break|break;
case|case
name|OPTION_STATISTICS
case|:
name|flag_print_statistics
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_LOCAL_ABSOLUTE
case|:
name|flag_strip_local_absolute
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_TRADITIONAL_FORMAT
case|:
name|flag_traditional_format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
comment|/* This output is intended to follow the GNU standards document.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"GNU assembler %s\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright 2007 Free Software Foundation, Inc.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ This program is free software; you may redistribute it under the terms of\n\ the GNU General Public License.  This program has absolutely no warranty.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"This assembler was configured for a target of `%s'.\n"
argument_list|)
argument_list|,
name|TARGET_ALIAS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_EMULATION
case|:
ifdef|#
directive|ifdef
name|USE_EMULATIONS
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|this_emulation
operator|->
name|name
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"multiple emulation names specified"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"emulations not handled in this configuration"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OPTION_DUMPCONFIG
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"alias = %s\n"
argument_list|)
argument_list|,
name|TARGET_ALIAS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"canonical = %s\n"
argument_list|)
argument_list|,
name|TARGET_CANONICAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"cpu-type = %s\n"
argument_list|)
argument_list|,
name|TARGET_CPU
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_OBJ_FORMAT
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"format = %s\n"
argument_list|)
argument_list|,
name|TARGET_OBJ_FORMAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_FORMAT
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"bfd-target = %s\n"
argument_list|)
argument_list|,
name|TARGET_FORMAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|OPTION_DEFSYM
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|valueT
name|i
decl_stmt|;
name|struct
name|defsym_list
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|s
operator|=
name|optarg
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"bad defsym; format is --defsym name=value"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|bfd_scan_vma
argument_list|(
name|s
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|defsyms
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|i
expr_stmt|;
name|defsyms
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_INSTTBL
case|:
case|case
literal|'t'
case|:
block|{
comment|/* optarg is the name of the file containing the instruction 	       formats, opcodes, register names, etc.  */
name|struct
name|itbl_file_list
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"no file name following -t option"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|itbl_files
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|itbl_files
operator|=
name|n
expr_stmt|;
comment|/* Parse the file and add the new instructions to our internal 	       table.  If multiple instruction tables are specified, the 	       information from this table gets appended onto the existing 	       internal table.  */
name|itbl_files
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|itbl_parse
argument_list|(
name|itbl_files
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed to read instruction table %s\n"
argument_list|)
argument_list|,
name|itbl_files
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_DEPFILE
case|:
name|start_dependencies
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Some backends, eg Alpha and Mips, use the -g switch for their 	     own purposes.  So we check here for an explicit -g and allow 	     the backend to decide if it wants to process it.  */
if|if
condition|(
name|old_argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|md_parse_option
argument_list|(
name|optc
argument_list|,
name|optarg
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|md_debug_format_selector
condition|)
name|debug_type
operator|=
name|md_debug_format_selector
argument_list|(
operator|&
name|use_gnu_debug_info_extensions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_ELF
condition|)
name|debug_type
operator|=
name|DEBUG_DWARF2
expr_stmt|;
else|else
name|debug_type
operator|=
name|DEBUG_STABS
expr_stmt|;
break|break;
case|case
name|OPTION_GSTABS_PLUS
case|:
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|OPTION_GSTABS
case|:
name|debug_type
operator|=
name|DEBUG_STABS
expr_stmt|;
break|break;
case|case
name|OPTION_GDWARF2
case|:
name|debug_type
operator|=
name|DEBUG_DWARF2
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|flag_signed_overflow_ok
operator|=
literal|1
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
literal|'K'
case|:
name|flag_warn_displacement
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'L'
case|:
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_LHS_WIDTH
case|:
name|listing_lhs_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|listing_lhs_width_second
operator|<
name|listing_lhs_width
condition|)
name|listing_lhs_width_second
operator|=
name|listing_lhs_width
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_LHS_WIDTH2
case|:
block|{
name|int
name|tmp
init|=
name|atoi
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
name|listing_lhs_width
condition|)
name|listing_lhs_width_second
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_LISTING_RHS_WIDTH
case|:
name|listing_rhs_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LISTING_CONT_LINES
case|:
name|listing_lhs_cont_lines
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|flag_mri
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|flag_m68k_mri
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'R'
case|:
name|flag_readonly_data_in_text
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|flag_no_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_WARN
case|:
name|flag_no_warnings
operator|=
literal|0
expr_stmt|;
name|flag_fatal_warnings
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_FATAL
case|:
name|flag_no_warnings
operator|=
literal|0
expr_stmt|;
name|flag_fatal_warnings
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_MAYBE_ELF
case|case
name|OPTION_EXECSTACK
case|:
name|flag_execstack
operator|=
literal|1
expr_stmt|;
name|flag_noexecstack
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NOEXECSTACK
case|:
name|flag_noexecstack
operator|=
literal|1
expr_stmt|;
name|flag_execstack
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'Z'
case|:
name|flag_always_generate_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_AL
case|:
name|listing
operator||=
name|LISTING_LISTING
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
name|listing_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ALTERNATE
case|:
name|optarg
operator|=
name|old_argv
index|[
name|optind
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|==
literal|'-'
condition|)
name|optarg
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"alternate"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flag_macro_alternate
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|optarg
operator|++
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'a'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|optarg
operator|!=
name|old_argv
index|[
name|optind
index|]
operator|&&
name|optarg
index|[
operator|-
literal|1
index|]
operator|==
literal|'='
condition|)
operator|--
name|optarg
expr_stmt|;
if|if
condition|(
name|md_parse_option
argument_list|(
name|optc
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
while|while
condition|(
operator|*
name|optarg
condition|)
block|{
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
case|case
literal|'c'
case|:
name|listing
operator||=
name|LISTING_NOCOND
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|listing
operator||=
name|LISTING_NODEBUG
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|listing
operator||=
name|LISTING_HLL
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|listing
operator||=
name|LISTING_LISTING
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|listing
operator||=
name|LISTING_MACEXP
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|listing
operator||=
name|LISTING_NOFORM
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|listing
operator||=
name|LISTING_SYMBOLS
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|listing_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|optarg
operator|+=
name|strlen
argument_list|(
name|listing_filename
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid listing option `%c'"
argument_list|)
argument_list|,
operator|*
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
name|optarg
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|listing
condition|)
name|listing
operator|=
name|LISTING_DEFAULT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* DEBUG is implemented: it debugs different 	     things from other people's assemblers.  */
name|flag_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flag_no_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
comment|/* Include file directory.  */
name|char
modifier|*
name|temp
init|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
name|add_include_dir
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
name|out_file_name
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
break|break;
case|case
literal|'X'
case|:
comment|/* -X means treat warnings as errors.  */
break|break;
case|case
name|OPTION_REDUCE_MEMORY_OVERHEADS
case|:
comment|/* The only change we make at the moment is to reduce 	     the size of the hash tables that we use.  */
name|set_gas_hash_table_size
argument_list|(
literal|4051
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_HASH_TABLE_SIZE
case|:
block|{
name|unsigned
name|long
name|new_size
decl_stmt|;
name|new_size
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
condition|)
name|set_gas_hash_table_size
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"--hash-size needs a numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|shortopts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|longopts
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
name|new_argc
expr_stmt|;
operator|*
name|pargv
operator|=
name|new_argv
expr_stmt|;
ifdef|#
directive|ifdef
name|md_after_parse_args
name|md_after_parse_args
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dump_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|long
name|run_time
init|=
name|get_run_time
argument_list|()
operator|-
name|start_time
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: total time in assembly: %ld.%06ld\n"
argument_list|)
argument_list|,
name|myname
argument_list|,
name|run_time
operator|/
literal|1000000
argument_list|,
name|run_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: data size %ld\n"
argument_list|)
argument_list|,
name|myname
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|subsegs_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|write_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|symbol_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|read_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_print_statistics
name|tc_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_print_statistics
name|obj_print_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_VMS
end_ifndef

begin_function
specifier|static
name|void
name|close_output_file
parameter_list|(
name|void
parameter_list|)
block|{
name|output_file_close
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The interface between the macro code and gas expression handling.  */
end_comment

begin_function
specifier|static
name|int
name|macro_expr
parameter_list|(
specifier|const
name|char
modifier|*
name|emsg
parameter_list|,
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|sb_terminate
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|in
operator|->
name|ptr
operator|+
name|idx
expr_stmt|;
name|expression_and_evaluate
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|idx
operator|=
name|input_line_pointer
operator|-
name|in
operator|->
name|ptr
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|int
operator|)
name|ex
operator|.
name|X_add_number
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to attempt 1 pass over each input file.    We scan argv[*] looking for filenames or exactly "" which is    shorthand for stdin. Any argv that is NULL is not a file-name.    We set need_pass_2 TRUE if, after this, we still have unresolved    expressions of the form (unknown value)+-(unknown value).     Note the un*x semantics: there is only 1 logical input file, but it    may be a catenation of many 'physical' input files.  */
end_comment

begin_function
specifier|static
name|void
name|perform_an_assembly_pass
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|saw_a_file
init|=
literal|0
decl_stmt|;
name|flagword
name|applicable
decl_stmt|;
name|need_pass_2
operator|=
literal|0
expr_stmt|;
comment|/* Create the standard sections, and those the assembler uses      internally.  */
name|text_section
operator|=
name|subseg_new
argument_list|(
name|TEXT_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_section
operator|=
name|subseg_new
argument_list|(
name|DATA_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bss_section
operator|=
name|subseg_new
argument_list|(
name|BSS_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* @@ FIXME -- we're setting the RELOC flag so that sections are assumed      to have relocs, otherwise we don't find out in time.  */
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|bss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|bss_section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
name|subseg_new
argument_list|(
name|BFD_ABS_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_new
argument_list|(
name|BFD_UND_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_section
operator|=
name|subseg_new
argument_list|(
literal|"*GAS `reg' section*"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr_section
operator|=
name|subseg_new
argument_list|(
literal|"*GAS `expr' section*"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This may add symbol table entries, which requires having an open BFD,      and sections already created.  */
name|md_begin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_CGEN
name|gas_cgen_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_begin
name|obj_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Skip argv[0].  */
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argc
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|argv
condition|)
block|{
comment|/* Is it a file-name argument?  */
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|saw_a_file
operator|++
expr_stmt|;
comment|/* argv->"" if stdin desired, else->filename.  */
name|read_a_source_file
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
comment|/* Completed that argv.  */
block|}
if|if
condition|(
operator|!
name|saw_a_file
condition|)
name|read_a_source_file
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|void
name|create_obj_attrs_section
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|addressT
name|addr
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size
operator|=
name|bfd_elf_obj_attr_size
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|name
operator|=
name|get_elf_backend_data
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|obj_attrs_section
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|".gnu.attributes"
expr_stmt|;
name|s
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elf_section_type
argument_list|(
name|s
argument_list|)
operator|=
name|get_elf_backend_data
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|obj_attrs_section_type
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|s
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
name|addr
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bfd_elf_set_obj_attr_contents
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|macro_strip_at
decl_stmt|;
name|int
name|keep_it
decl_stmt|;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_memory
condition|)
name|chunksize
operator|=
literal|64
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_SPECIAL_INIT
name|HOST_SPECIAL_INIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
define|#
directive|define
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
value|"a.out"
endif|#
directive|endif
name|out_file_name
operator|=
name|OBJ_DEFAULT_OUTPUT_FILE_NAME
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|bfd_set_error_program_name
argument_list|(
name|myname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMULATIONS
name|select_emulation_mode
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Call parse_args before any of the init/begin functions      so that switches like --hash-size can be honored.  */
name|parse_args
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|symbol_begin
argument_list|()
expr_stmt|;
name|frag_init
argument_list|()
expr_stmt|;
name|subsegs_begin
argument_list|()
expr_stmt|;
name|read_begin
argument_list|()
expr_stmt|;
name|input_scrub_begin
argument_list|()
expr_stmt|;
name|expr_begin
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_VMS
comment|/* Does its own file handling.  */
comment|/* It has to be called after dump_statistics ().  */
name|xatexit
argument_list|(
name|close_output_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_print_statistics
condition|)
name|xatexit
argument_list|(
name|dump_statistics
argument_list|)
expr_stmt|;
name|macro_strip_at
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
name|macro_strip_at
operator|=
name|flag_mri
expr_stmt|;
endif|#
directive|endif
name|macro_init
argument_list|(
name|flag_macro_alternate
argument_list|,
name|flag_mri
argument_list|,
name|macro_strip_at
argument_list|,
name|macro_expr
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|output_file_create
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stdoutput
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_init_after_args
name|tc_init_after_args
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|itbl_init
argument_list|()
expr_stmt|;
comment|/* Now that we have fully initialized, and have created the output      file, define any symbols requested by --defsym command line      arguments.  */
while|while
condition|(
name|defsyms
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|struct
name|defsym_list
modifier|*
name|next
decl_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
name|defsyms
operator|->
name|name
argument_list|,
name|absolute_section
argument_list|,
name|defsyms
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Make symbols defined on the command line volatile, so that they 	 can be redefined inside a source file.  This makes this assembler's 	 behaviour compatible with earlier versions, but it may not be 	 completely intuitive.  */
name|S_SET_VOLATILE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|next
operator|=
name|defsyms
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|defsyms
argument_list|)
expr_stmt|;
name|defsyms
operator|=
name|next
expr_stmt|;
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Assemble it.  */
name|perform_an_assembly_pass
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|cond_finish_check
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_end
name|md_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|IS_ELF
condition|)
name|create_obj_attrs_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_MAYBE_ELF
if|if
condition|(
operator|(
name|flag_execstack
operator|||
name|flag_noexecstack
operator|)
operator|&&
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|segT
name|gnustack
decl_stmt|;
name|gnustack
operator|=
name|subseg_new
argument_list|(
literal|".note.GNU-stack"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|gnustack
argument_list|,
name|SEC_READONLY
operator||
operator|(
name|flag_execstack
condition|?
name|SEC_CODE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we've been collecting dwarf2 .debug_line info, either for      assembly debugging or on behalf of the compiler, emit it now.  */
name|dwarf2_finish
argument_list|()
expr_stmt|;
comment|/* If we constructed dwarf2 .eh_frame info, either via .cfi       directives from the user or by the backend, emit it now.  */
name|cfi_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|seen_at_least_1_file
argument_list|()
operator|&&
operator|(
name|flag_always_generate_output
operator|||
name|had_errors
argument_list|()
operator|==
literal|0
operator|)
condition|)
name|keep_it
operator|=
literal|1
expr_stmt|;
else|else
name|keep_it
operator|=
literal|0
expr_stmt|;
comment|/* This used to be done at the start of write_object_file in      write.c, but that caused problems when doing listings when      keep_it was zero.  This could probably be moved above md_end, but      I didn't want to risk the change.  */
name|subsegs_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|keep_it
condition|)
name|write_object_file
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
name|listing_print
argument_list|(
name|listing_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_fatal_warnings
operator|&&
name|had_warnings
argument_list|()
operator|>
literal|0
operator|&&
name|had_errors
argument_list|()
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%d warnings, treating warnings as errors"
argument_list|)
argument_list|,
name|had_warnings
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_errors
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|flag_always_generate_output
condition|)
name|keep_it
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep_it
condition|)
name|unlink_if_ordinary
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|input_scrub_end
argument_list|()
expr_stmt|;
name|END_PROGRESS
argument_list|(
name|myname
argument_list|)
expr_stmt|;
comment|/* Use xexit instead of return, because under VMS environments they      may not place the same interpretation on the value given.  */
if|if
condition|(
name|had_errors
argument_list|()
operator|>
literal|0
condition|)
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* Only generate dependency file if assembler was successful.  */
name|print_dependencies
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

