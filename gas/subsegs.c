begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* subsegs.c - subsegments -    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Segments& sub-segments.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|frchainS
modifier|*
name|frchain_root
decl_stmt|,
modifier|*
name|frchain_now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|frchains
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Gas segment information for bfd_abs_section_ptr and    bfd_und_section_ptr.  */
end_comment

begin_decl_stmt
specifier|static
name|segment_info_type
modifier|*
name|abs_seg_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segment_info_type
modifier|*
name|und_seg_info
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|subseg_set_rest
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|fragS
name|dummy_frag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|frchainS
name|absolute_frchain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|subsegs_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_begin
argument_list|(
operator|&
name|frchains
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|obstack_alignment_mask
argument_list|(
operator|&
name|frchains
argument_list|)
operator|=
name|__alignof__
argument_list|(
name|frchainS
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|frchain_root
operator|=
name|NULL
expr_stmt|;
name|frchain_now
operator|=
name|NULL
expr_stmt|;
comment|/* Warn new_subseg() that we are booting.  */
name|frag_now
operator|=
operator|&
name|dummy_frag
expr_stmt|;
name|absolute_frchain
operator|.
name|frch_seg
operator|=
name|absolute_section
expr_stmt|;
name|absolute_frchain
operator|.
name|frch_subseg
operator|=
literal|0
expr_stmt|;
name|absolute_frchain
operator|.
name|fix_root
operator|=
name|absolute_frchain
operator|.
name|fix_tail
operator|=
literal|0
expr_stmt|;
name|absolute_frchain
operator|.
name|frch_frag_now
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|absolute_frchain
operator|.
name|frch_root
operator|=
name|absolute_frchain
operator|.
name|frch_last
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			subseg_change()  *  * Change the subsegment we are in, BUT DO NOT MAKE A NEW FRAG for the  * subsegment. If we are already in the correct subsegment, change nothing.  * This is used eg as a worker for subseg_set [which does make a new frag_now]  * and for changing segments after we have read the source. We construct eg  * fixSs even after the source file is read, so we do have to keep the  * segment context correct.  */
end_comment

begin_function
name|void
name|subseg_change
parameter_list|(
specifier|register
name|segT
name|seg
parameter_list|,
specifier|register
name|int
name|subseg
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|now_seg
operator|=
name|seg
expr_stmt|;
name|now_subseg
operator|=
name|subseg
expr_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
return|return;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|bfd_get_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|seginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|seg
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|bfd_abs_section_ptr
condition|)
name|abs_seg_info
operator|=
name|seginfo
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
name|bfd_und_section_ptr
condition|)
name|und_seg_info
operator|=
name|seginfo
expr_stmt|;
else|else
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|PTR
operator|)
name|seginfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|subseg_set_rest
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
specifier|register
name|frchainS
modifier|*
name|frcP
decl_stmt|;
comment|/* crawl frchain chain */
specifier|register
name|frchainS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
comment|/* address of last pointer */
name|frchainS
modifier|*
name|newP
decl_stmt|;
comment|/* address of new frchain */
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|frag_now
operator|&&
name|frchain_now
condition|)
name|frchain_now
operator|->
name|frch_frag_now
operator|=
name|frag_now
expr_stmt|;
name|assert
argument_list|(
name|frchain_now
operator|==
literal|0
operator|||
name|now_seg
operator|==
name|undefined_section
operator|||
name|now_seg
operator|==
name|absolute_section
operator|||
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
name|subseg_change
argument_list|(
name|seg
argument_list|,
operator|(
name|int
operator|)
name|subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|absolute_section
condition|)
block|{
name|frchain_now
operator|=
operator|&
name|absolute_frchain
expr_stmt|;
name|frag_now
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|frchain_now
operator|==
literal|0
operator|||
name|now_seg
operator|==
name|undefined_section
operator|||
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
comment|/*    * Attempt to find or make a frchain for that sub seg.    * Crawl along chain of frchainSs, begins @ frchain_root.    * If we need to make a frchainS, link it into correct    * position of chain rooted in frchain_root.    */
for|for
control|(
name|frcP
operator|=
operator|*
operator|(
name|lastPP
operator|=
operator|&
name|frchain_root
operator|)
init|;
name|frcP
operator|&&
name|frcP
operator|->
name|frch_seg
operator|<=
name|seg
condition|;
name|frcP
operator|=
operator|*
operator|(
name|lastPP
operator|=
operator|&
name|frcP
operator|->
name|frch_next
operator|)
control|)
block|{
if|if
condition|(
name|frcP
operator|->
name|frch_seg
operator|==
name|seg
operator|&&
name|frcP
operator|->
name|frch_subseg
operator|>=
name|subseg
condition|)
block|{
break|break;
block|}
block|}
comment|/*    * frcP:		Address of the 1st frchainS in correct segment with    *		frch_subseg>= subseg.    *		We want to either use this frchainS, or we want    *		to insert a new frchainS just before it.    *    *		If frcP==NULL, then we are at the end of the chain    *		of frchainS-s. A NULL frcP means we fell off the end    *		of the chain looking for a    *		frch_subseg>= subseg, so we    *		must make a new frchainS.    *    *		If we ever maintain a pointer to    *		the last frchainS in the chain, we change that pointer    *		ONLY when frcP==NULL.    *    * lastPP:	Address of the pointer with value frcP;    *		Never NULL.    *		May point to frchain_root.    *    */
if|if
condition|(
operator|!
name|frcP
operator|||
operator|(
name|frcP
operator|->
name|frch_seg
operator|>
name|seg
operator|||
name|frcP
operator|->
name|frch_subseg
operator|>
name|subseg
operator|)
condition|)
comment|/* Kinky logic only works with 2 segments.  */
block|{
comment|/*        * This should be the only code that creates a frchainS.        */
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|newP
operator|=
operator|(
name|frchainS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frchains
argument_list|,
sizeof|sizeof
argument_list|(
name|frchainS
argument_list|)
argument_list|)
expr_stmt|;
name|newP
operator|->
name|frch_subseg
operator|=
name|subseg
expr_stmt|;
name|newP
operator|->
name|frch_seg
operator|=
name|seg
expr_stmt|;
name|newP
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|newP
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|obstack_alignment_mask
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|)
operator|=
name|__alignof__
argument_list|(
name|fragS
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|newP
operator|->
name|frch_frag_now
operator|=
name|frag_alloc
argument_list|(
operator|&
name|newP
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|newP
operator|->
name|frch_frag_now
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|newP
operator|->
name|frch_root
operator|=
name|newP
operator|->
name|frch_last
operator|=
name|newP
operator|->
name|frch_frag_now
expr_stmt|;
operator|*
name|lastPP
operator|=
name|newP
expr_stmt|;
name|newP
operator|->
name|frch_next
operator|=
name|frcP
expr_stmt|;
comment|/* perhaps NULL */
name|seginfo
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|&&
operator|(
operator|!
name|seginfo
operator|->
name|frchainP
operator|||
name|seginfo
operator|->
name|frchainP
operator|==
name|frcP
operator|)
condition|)
name|seginfo
operator|->
name|frchainP
operator|=
name|newP
expr_stmt|;
name|frcP
operator|=
name|newP
expr_stmt|;
block|}
comment|/*    * Here with frcP pointing to the frchainS for subseg.    */
name|frchain_now
operator|=
name|frcP
expr_stmt|;
name|frag_now
operator|=
name|frcP
operator|->
name|frch_frag_now
expr_stmt|;
name|assert
argument_list|(
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			subseg_set(segT, subsegT)  *  * If you attempt to change to the current subsegment, nothing happens.  *  * In:	segT, subsegT code for new subsegment.  *	frag_now -> incomplete frag for current subsegment.  *	If frag_now==NULL, then there is no old, incomplete frag, so  *	the old frag is not closed off.  *  * Out:	now_subseg, now_seg updated.  *	Frchain_now points to the (possibly new) struct frchain for this  *	sub-segment.  *	Frchain_root updated if needed.  */
end_comment

begin_function
name|segT
name|subseg_get
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|int
name|force_new
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|now_seg_name
init|=
operator|(
name|now_seg
condition|?
name|bfd_get_section_name
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|force_new
operator|&&
name|now_seg_name
operator|&&
operator|(
name|now_seg_name
operator|==
name|segname
operator|||
operator|!
name|strcmp
argument_list|(
name|now_seg_name
argument_list|,
name|segname
argument_list|)
operator|)
condition|)
return|return
name|now_seg
return|;
if|if
condition|(
operator|!
name|force_new
condition|)
name|secptr
operator|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|segname
argument_list|)
expr_stmt|;
else|else
name|secptr
operator|=
name|bfd_make_section_anyway
argument_list|(
name|stdoutput
argument_list|,
name|segname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obj_sec_set_private_data
name|obj_sec_set_private_data
argument_list|(
name|stdoutput
argument_list|,
name|secptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seginfo
operator|=
name|seg_info
argument_list|(
name|secptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
comment|/* Check whether output_section is set first because secptr may 	 be bfd_abs_section_ptr.  */
if|if
condition|(
name|secptr
operator|->
name|output_section
operator|!=
name|secptr
condition|)
name|secptr
operator|->
name|output_section
operator|=
name|secptr
expr_stmt|;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|seginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|secptr
expr_stmt|;
if|if
condition|(
name|secptr
operator|==
name|bfd_abs_section_ptr
condition|)
name|abs_seg_info
operator|=
name|seginfo
expr_stmt|;
elseif|else
if|if
condition|(
name|secptr
operator|==
name|bfd_und_section_ptr
condition|)
name|und_seg_info
operator|=
name|seginfo
expr_stmt|;
else|else
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|secptr
argument_list|,
operator|(
name|PTR
operator|)
name|seginfo
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|frchainP
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|lineno_list_head
operator|=
name|seginfo
operator|->
name|lineno_list_tail
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|dot
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|secptr
return|;
block|}
end_function

begin_function
name|segT
name|subseg_new
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|secptr
operator|=
name|subseg_get
argument_list|(
name|segname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|secptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
operator|->
name|frchainP
condition|)
name|seginfo
operator|->
name|frchainP
operator|=
name|frchain_now
expr_stmt|;
return|return
name|secptr
return|;
block|}
end_function

begin_comment
comment|/* Like subseg_new, except a new section is always created, even if    a section with that name already exists.  */
end_comment

begin_function
name|segT
name|subseg_force_new
parameter_list|(
specifier|const
name|char
modifier|*
name|segname
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|segT
name|secptr
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|secptr
operator|=
name|subseg_get
argument_list|(
name|segname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|secptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
operator|->
name|frchainP
condition|)
name|seginfo
operator|->
name|frchainP
operator|=
name|frchain_now
expr_stmt|;
return|return
name|secptr
return|;
block|}
end_function

begin_function
name|void
name|subseg_set
parameter_list|(
name|segT
name|secptr
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|secptr
operator|==
name|now_seg
operator|&&
name|subseg
operator|==
name|now_subseg
operator|)
condition|)
name|subseg_set_rest
argument_list|(
name|secptr
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|obj_sec_sym_ok_for_reloc
end_ifndef

begin_define
define|#
directive|define
name|obj_sec_sym_ok_for_reloc
parameter_list|(
name|SEC
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the gas information we are storing for a section.  */
end_comment

begin_function
name|segment_info_type
modifier|*
name|seg_info
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|==
name|bfd_abs_section_ptr
condition|)
return|return
name|abs_seg_info
return|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|bfd_und_section_ptr
condition|)
return|return
name|und_seg_info
return|;
else|else
return|return
operator|(
name|segment_info_type
operator|*
operator|)
name|bfd_get_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|section_symbol
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|symbolS
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|seginfo
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|sym
condition|)
return|return
name|seginfo
operator|->
name|sym
return|;
ifndef|#
directive|ifndef
name|EMIT_SECTION_SYMBOLS
define|#
directive|define
name|EMIT_SECTION_SYMBOLS
value|1
endif|#
directive|endif
if|if
condition|(
operator|!
name|EMIT_SECTION_SYMBOLS
operator|||
name|symbol_table_frozen
condition|)
block|{
comment|/* Here we know it won't be going into the symbol table.  */
name|s
operator|=
name|symbol_create
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segT
name|seg
decl_stmt|;
name|s
operator|=
name|symbol_find
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* We have to make sure it is the right symbol when we 	 have multiple sections with the same section name.  */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
operator|(
name|seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|sec
operator|&&
name|seg
operator|!=
name|undefined_section
operator|)
condition|)
name|s
operator|=
name|symbol_new
argument_list|(
name|sec
operator|->
name|symbol
operator|->
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
name|undefined_section
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|s
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|s
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
block|}
name|S_CLEAR_EXTERNAL
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Use the BFD section symbol, if possible.  */
if|if
condition|(
name|obj_sec_sym_ok_for_reloc
argument_list|(
name|sec
argument_list|)
condition|)
name|symbol_set_bfdsym
argument_list|(
name|s
argument_list|,
name|sec
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|symbol_get_bfdsym
argument_list|(
name|s
argument_list|)
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return whether the specified segment is thought to hold text.  */
end_comment

begin_function
name|int
name|subseg_text_p
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
return|return
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non zero if SEC has at least one byte of data.  It is    possible that we'll return zero even on a non-empty section because    we don't know all the fragment types, and it is possible that an    fr_fix == 0 one still contributes data.  Think of this as    seg_definitely_not_empty_p.  */
end_comment

begin_function
name|int
name|seg_not_empty_p
parameter_list|(
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|frchainS
modifier|*
name|chain
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
return|return
literal|0
return|;
for|for
control|(
name|chain
operator|=
name|seginfo
operator|->
name|frchainP
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|frch_next
control|)
block|{
for|for
control|(
name|frag
operator|=
name|chain
operator|->
name|frch_root
init|;
name|frag
condition|;
name|frag
operator|=
name|frag
operator|->
name|fr_next
control|)
if|if
condition|(
name|frag
operator|->
name|fr_fix
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|obstack_next_free
argument_list|(
operator|&
name|chain
operator|->
name|frch_obstack
argument_list|)
operator|!=
name|chain
operator|->
name|frch_last
operator|->
name|fr_literal
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|subsegs_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchp
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"frag chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|frchp
operator|=
name|frchain_root
init|;
name|frchp
condition|;
name|frchp
operator|=
name|frchp
operator|->
name|frch_next
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
comment|/* If frch_subseg is non-zero, it's probably been chained onto 	 the end of a previous subsection.  Don't count it again.  */
if|if
condition|(
name|frchp
operator|->
name|frch_subseg
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Skip gas-internal sections.  */
if|if
condition|(
name|segment_name
argument_list|(
name|frchp
operator|->
name|frch_seg
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
continue|continue;
for|for
control|(
name|fragp
operator|=
name|frchp
operator|->
name|frch_root
init|;
name|fragp
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%p %-10s\t%10d frags\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|frchp
argument_list|,
name|segment_name
argument_list|(
name|frchp
operator|->
name|frch_seg
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of subsegs.c */
end_comment

end_unit

