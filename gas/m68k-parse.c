begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A Bison parser, made by GNU Bison 2.1.  */
end_comment

begin_comment
comment|/* Skeleton parser for Yacc-like parsing with Bison,    Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, when this file is copied by Bison into a    Bison output file, you may use that output file without restriction.    This special exception was added by the Free Software Foundation    in version 1.24 of Bison.  */
end_comment

begin_comment
comment|/* Written by Richard Stallman by simplifying the original so called    ``semantic'' parser.  */
end_comment

begin_comment
comment|/* All symbols defined below should begin with yy or YY, to avoid    infringing on user name space.  This should be done even for local    variables, as they might otherwise be expanded by user macros.    There are some unavoidable exceptions within include files to    define necessary library symbols; they are noted "INFRINGES ON    USER NAME SPACE" below.  */
end_comment

begin_comment
comment|/* Identify Bison output.  */
end_comment

begin_define
define|#
directive|define
name|YYBISON
value|1
end_define

begin_comment
comment|/* Bison version.  */
end_comment

begin_define
define|#
directive|define
name|YYBISON_VERSION
value|"2.1"
end_define

begin_comment
comment|/* Skeleton name.  */
end_comment

begin_define
define|#
directive|define
name|YYSKELETON_NAME
value|"yacc.c"
end_define

begin_comment
comment|/* Pure parsers.  */
end_comment

begin_define
define|#
directive|define
name|YYPURE
value|0
end_define

begin_comment
comment|/* Using locations.  */
end_comment

begin_define
define|#
directive|define
name|YYLSP_NEEDED
value|0
end_define

begin_comment
comment|/* Tokens.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYTOKENTYPE
end_ifndef

begin_define
define|#
directive|define
name|YYTOKENTYPE
end_define

begin_comment
comment|/* Put the tokens into the symbol table, so that GDB and other debuggers       know about them.  */
end_comment

begin_enum
enum|enum
name|yytokentype
block|{
name|DR
init|=
literal|258
block|,
name|AR
init|=
literal|259
block|,
name|FPR
init|=
literal|260
block|,
name|FPCR
init|=
literal|261
block|,
name|LPC
init|=
literal|262
block|,
name|ZAR
init|=
literal|263
block|,
name|ZDR
init|=
literal|264
block|,
name|LZPC
init|=
literal|265
block|,
name|CREG
init|=
literal|266
block|,
name|INDEXREG
init|=
literal|267
block|,
name|EXPR
init|=
literal|268
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tokens.  */
end_comment

begin_define
define|#
directive|define
name|DR
value|258
end_define

begin_define
define|#
directive|define
name|AR
value|259
end_define

begin_define
define|#
directive|define
name|FPR
value|260
end_define

begin_define
define|#
directive|define
name|FPCR
value|261
end_define

begin_define
define|#
directive|define
name|LPC
value|262
end_define

begin_define
define|#
directive|define
name|ZAR
value|263
end_define

begin_define
define|#
directive|define
name|ZDR
value|264
end_define

begin_define
define|#
directive|define
name|LZPC
value|265
end_define

begin_define
define|#
directive|define
name|CREG
value|266
end_define

begin_define
define|#
directive|define
name|INDEXREG
value|267
end_define

begin_define
define|#
directive|define
name|EXPR
value|268
end_define

begin_comment
comment|/* Copy the first part of user declarations.  */
end_comment

begin_line
line|#
directive|line
number|28
file|"m68k-parse.y"
end_line

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"tc-m68k.h"
end_include

begin_include
include|#
directive|include
file|"m68k-parse.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/* Remap normal yacc parser interface names (yyparse, yylex, yyerror,    etc), as well as gratuitously global symbol names If other parser    generators (bison, byacc, etc) produce additional global names that    conflict at link time, then those parser generators need to be    fixed instead of adding those names to this list.  */
end_comment

begin_define
define|#
directive|define
name|yymaxdepth
value|m68k_maxdepth
end_define

begin_define
define|#
directive|define
name|yyparse
value|m68k_parse
end_define

begin_define
define|#
directive|define
name|yylex
value|m68k_lex
end_define

begin_define
define|#
directive|define
name|yyerror
value|m68k_error
end_define

begin_define
define|#
directive|define
name|yylval
value|m68k_lval
end_define

begin_define
define|#
directive|define
name|yychar
value|m68k_char
end_define

begin_define
define|#
directive|define
name|yydebug
value|m68k_debug
end_define

begin_define
define|#
directive|define
name|yypact
value|m68k_pact
end_define

begin_define
define|#
directive|define
name|yyr1
value|m68k_r1
end_define

begin_define
define|#
directive|define
name|yyr2
value|m68k_r2
end_define

begin_define
define|#
directive|define
name|yydef
value|m68k_def
end_define

begin_define
define|#
directive|define
name|yychk
value|m68k_chk
end_define

begin_define
define|#
directive|define
name|yypgo
value|m68k_pgo
end_define

begin_define
define|#
directive|define
name|yyact
value|m68k_act
end_define

begin_define
define|#
directive|define
name|yyexca
value|m68k_exca
end_define

begin_define
define|#
directive|define
name|yyerrflag
value|m68k_errflag
end_define

begin_define
define|#
directive|define
name|yynerrs
value|m68k_nerrs
end_define

begin_define
define|#
directive|define
name|yyps
value|m68k_ps
end_define

begin_define
define|#
directive|define
name|yypv
value|m68k_pv
end_define

begin_define
define|#
directive|define
name|yys
value|m68k_s
end_define

begin_define
define|#
directive|define
name|yy_yys
value|m68k_yys
end_define

begin_define
define|#
directive|define
name|yystate
value|m68k_state
end_define

begin_define
define|#
directive|define
name|yytmp
value|m68k_tmp
end_define

begin_define
define|#
directive|define
name|yyv
value|m68k_v
end_define

begin_define
define|#
directive|define
name|yy_yyv
value|m68k_yyv
end_define

begin_define
define|#
directive|define
name|yyval
value|m68k_val
end_define

begin_define
define|#
directive|define
name|yylloc
value|m68k_lloc
end_define

begin_define
define|#
directive|define
name|yyreds
value|m68k_reds
end_define

begin_comment
comment|/* With YYDEBUG defined */
end_comment

begin_define
define|#
directive|define
name|yytoks
value|m68k_toks
end_define

begin_comment
comment|/* With YYDEBUG defined */
end_comment

begin_define
define|#
directive|define
name|yylhs
value|m68k_yylhs
end_define

begin_define
define|#
directive|define
name|yylen
value|m68k_yylen
end_define

begin_define
define|#
directive|define
name|yydefred
value|m68k_yydefred
end_define

begin_define
define|#
directive|define
name|yydgoto
value|m68k_yydgoto
end_define

begin_define
define|#
directive|define
name|yysindex
value|m68k_yysindex
end_define

begin_define
define|#
directive|define
name|yyrindex
value|m68k_yyrindex
end_define

begin_define
define|#
directive|define
name|yygindex
value|m68k_yygindex
end_define

begin_define
define|#
directive|define
name|yytable
value|m68k_yytable
end_define

begin_define
define|#
directive|define
name|yycheck
value|m68k_yycheck
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal functions.  */
end_comment

begin_function_decl
specifier|static
name|enum
name|m68k_register
name|m68k_reg_parse
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The parser sets fields pointed to by this global variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m68k_op
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enabling traces.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Enabling verbose error messages.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYERROR_VERBOSE
end_ifdef

begin_undef
undef|#
directive|undef
name|YYERROR_VERBOSE
end_undef

begin_define
define|#
directive|define
name|YYERROR_VERBOSE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYERROR_VERBOSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Enabling the token table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYTOKEN_TABLE
end_ifndef

begin_define
define|#
directive|define
name|YYTOKEN_TABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSTYPE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|YYSTYPE_IS_DECLARED
argument_list|)
end_if

begin_line
line|#
directive|line
number|96
file|"m68k-parse.y"
end_line

begin_typedef
typedef|typedef
union|union
name|YYSTYPE
block|{
name|struct
name|m68k_indexreg
name|indexreg
decl_stmt|;
name|enum
name|m68k_register
name|reg
decl_stmt|;
name|struct
name|m68k_exp
name|exp
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|int
name|onereg
decl_stmt|;
name|int
name|trailing_ampersand
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_comment
comment|/* Line 196 of yacc.c.  */
end_comment

begin_line
line|#
directive|line
number|187
file|"m68k-parse.c"
end_line

begin_define
define|#
directive|define
name|yystype
value|YYSTYPE
end_define

begin_comment
comment|/* obsolescent; will be withdrawn */
end_comment

begin_define
define|#
directive|define
name|YYSTYPE_IS_DECLARED
value|1
end_define

begin_define
define|#
directive|define
name|YYSTYPE_IS_TRIVIAL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copy the second part of user declarations.  */
end_comment

begin_comment
comment|/* Line 219 of yacc.c.  */
end_comment

begin_line
line|#
directive|line
number|199
file|"m68k-parse.c"
end_line

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SIZE_TYPE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|__SIZE_TYPE__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|size_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_
end_ifndef

begin_if
if|#
directive|if
name|YYENABLE_NLS
end_if

begin_if
if|#
directive|if
name|ENABLE_NLS
end_if

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YY_
parameter_list|(
name|msgid
parameter_list|)
value|dgettext ("bison-runtime", msgid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_
end_ifndef

begin_define
define|#
directive|define
name|YY_
parameter_list|(
name|msgid
parameter_list|)
value|msgid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|yyoverflow
argument_list|)
operator|||
name|YYERROR_VERBOSE
end_if

begin_comment
comment|/* The parser invokes alloca or malloc; define the necessary symbols.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACK_USE_ALLOCA
end_ifdef

begin_if
if|#
directive|if
name|YYSTACK_USE_ALLOCA
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|alloca
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYINCLUDED_STDLIB_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACK_ALLOC
end_ifdef

begin_comment
comment|/* Pacify GCC's `empty if-body' warning. */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_FREE
parameter_list|(
name|Ptr
parameter_list|)
value|do {
comment|/* empty */
value|; } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTACK_ALLOC_MAXIMUM
end_ifndef

begin_comment
comment|/* The OS might guarantee only one guard page at the bottom of the stack,        and a page size can be as small as 4096 bytes.  So we cannot safely        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number        to allow for a few compiler-allocated temporary stack slots.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_ALLOC_MAXIMUM
value|4032
end_define

begin_comment
comment|/* reasonable circa 2005 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|YYMALLOC
end_define

begin_define
define|#
directive|define
name|YYSTACK_FREE
value|YYFREE
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTACK_ALLOC_MAXIMUM
end_ifndef

begin_define
define|#
directive|define
name|YYSTACK_ALLOC_MAXIMUM
value|((YYSIZE_T) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|YYMALLOC
define|#
directive|define
name|YYMALLOC
value|malloc
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|malloc
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|YYINCLUDED_STDLIB_H
argument_list|)
expr|\
operator|&&
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
operator|)
name|void
modifier|*
name|malloc
parameter_list|(
name|YYSIZE_T
parameter_list|)
function_decl|;
comment|/* INFRINGES ON USER NAME SPACE */
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|YYFREE
define|#
directive|define
name|YYFREE
value|free
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|free
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|YYINCLUDED_STDLIB_H
argument_list|)
expr|\
operator|&&
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
operator|)
name|void
name|free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* INFRINGES ON USER NAME SPACE */
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (yyoverflow) || YYERROR_VERBOSE */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|yyoverflow
argument_list|)
expr|\
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|YYSTYPE_IS_TRIVIAL
argument_list|)
operator|&&
name|YYSTYPE_IS_TRIVIAL
operator|)
operator|)
operator|)
end_if

begin_comment
comment|/* A type that is properly aligned for any stack member.  */
end_comment

begin_union
union|union
name|yyalloc
block|{
name|short
name|int
name|yyss
decl_stmt|;
name|YYSTYPE
name|yyvs
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* The size of the maximum gap between one aligned stack and the next.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_GAP_MAXIMUM
value|(sizeof (union yyalloc) - 1)
end_define

begin_comment
comment|/* The size of an array large to enough to hold all stacks, each with    N elements.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_BYTES
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) * (sizeof (short int) + sizeof (YYSTYPE))			\       + YYSTACK_GAP_MAXIMUM)
end_define

begin_comment
comment|/* Copy COUNT objects from FROM to TO.  The source and destination do    not overlap.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYCOPY
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
literal|1
operator|<
name|__GNUC__
end_if

begin_define
define|#
directive|define
name|YYCOPY
parameter_list|(
name|To
parameter_list|,
name|From
parameter_list|,
name|Count
parameter_list|)
define|\
value|__builtin_memcpy (To, From, (Count) * sizeof (*(From)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYCOPY
parameter_list|(
name|To
parameter_list|,
name|From
parameter_list|,
name|Count
parameter_list|)
define|\
value|do					\ 	{					\ 	  YYSIZE_T yyi;				\ 	  for (yyi = 0; yyi< (Count); yyi++)	\ 	    (To)[yyi] = (From)[yyi];		\ 	}					\       while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Relocate STACK from its old location to the new one.  The    local variables YYSIZE and YYSTACKSIZE give the old and new number of    elements in the stack, and YYPTR gives the new location of the    stack.  Advance YYPTR to a properly aligned location for the next    stack.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_RELOCATE
parameter_list|(
name|Stack
parameter_list|)
define|\
value|do									\       {									\ 	YYSIZE_T yynewbytes;						\ 	YYCOPY (&yyptr->Stack, Stack, yysize);				\ 	Stack =&yyptr->Stack;						\ 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \ 	yyptr += yynewbytes / sizeof (*yyptr);				\       }									\     while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_typedef
typedef|typedef
name|signed
name|char
name|yysigned_char
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|short
name|int
name|yysigned_char
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYFINAL -- State number of the termination state. */
end_comment

begin_define
define|#
directive|define
name|YYFINAL
value|44
end_define

begin_comment
comment|/* YYLAST -- Last index in YYTABLE.  */
end_comment

begin_define
define|#
directive|define
name|YYLAST
value|215
end_define

begin_comment
comment|/* YYNTOKENS -- Number of terminals. */
end_comment

begin_define
define|#
directive|define
name|YYNTOKENS
value|27
end_define

begin_comment
comment|/* YYNNTS -- Number of nonterminals. */
end_comment

begin_define
define|#
directive|define
name|YYNNTS
value|21
end_define

begin_comment
comment|/* YYNRULES -- Number of rules. */
end_comment

begin_define
define|#
directive|define
name|YYNRULES
value|89
end_define

begin_comment
comment|/* YYNRULES -- Number of states. */
end_comment

begin_define
define|#
directive|define
name|YYNSTATES
value|180
end_define

begin_comment
comment|/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
end_comment

begin_define
define|#
directive|define
name|YYUNDEFTOK
value|2
end_define

begin_define
define|#
directive|define
name|YYMAXUTOK
value|268
end_define

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|YYX
parameter_list|)
define|\
value|((unsigned int) (YYX)<= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
end_define

begin_comment
comment|/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|yytranslate
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|17
block|,
literal|2
block|,
literal|2
block|,
literal|14
block|,
literal|2
block|,
literal|18
block|,
literal|19
block|,
literal|2
block|,
literal|20
block|,
literal|22
block|,
literal|21
block|,
literal|2
block|,
literal|26
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|15
block|,
literal|2
block|,
literal|16
block|,
literal|2
block|,
literal|25
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|23
block|,
literal|2
block|,
literal|24
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_comment
comment|/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in    YYRHS.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|int
name|yyprhs
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|11
block|,
literal|12
block|,
literal|14
block|,
literal|17
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|26
block|,
literal|28
block|,
literal|30
block|,
literal|32
block|,
literal|35
block|,
literal|38
block|,
literal|40
block|,
literal|44
block|,
literal|49
block|,
literal|54
block|,
literal|60
block|,
literal|66
block|,
literal|71
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|91
block|,
literal|99
block|,
literal|106
block|,
literal|112
block|,
literal|119
block|,
literal|125
block|,
literal|132
block|,
literal|138
block|,
literal|144
block|,
literal|149
block|,
literal|159
block|,
literal|167
block|,
literal|176
block|,
literal|183
block|,
literal|194
block|,
literal|203
block|,
literal|214
block|,
literal|223
block|,
literal|232
block|,
literal|235
block|,
literal|239
block|,
literal|243
block|,
literal|249
block|,
literal|256
block|,
literal|267
block|,
literal|277
block|,
literal|288
block|,
literal|290
block|,
literal|292
block|,
literal|294
block|,
literal|296
block|,
literal|298
block|,
literal|300
block|,
literal|302
block|,
literal|304
block|,
literal|306
block|,
literal|308
block|,
literal|310
block|,
literal|312
block|,
literal|314
block|,
literal|316
block|,
literal|317
block|,
literal|319
block|,
literal|321
block|,
literal|323
block|,
literal|324
block|,
literal|327
block|,
literal|328
block|,
literal|331
block|,
literal|332
block|,
literal|335
block|,
literal|337
block|,
literal|341
block|,
literal|345
block|,
literal|347
block|,
literal|349
block|,
literal|353
block|,
literal|357
block|,
literal|361
block|,
literal|363
block|,
literal|365
block|,
literal|367
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYRHS -- A `-1'-separated list of the rules' RHS. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|yysigned_char
name|yyrhs
index|[]
init|=
block|{
literal|28
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|30
block|,
operator|-
literal|1
block|,
literal|31
block|,
literal|29
block|,
operator|-
literal|1
block|,
literal|32
block|,
literal|29
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|14
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|15
block|,
operator|-
literal|1
block|,
literal|16
block|,
literal|16
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|6
block|,
operator|-
literal|1
block|,
literal|11
block|,
operator|-
literal|1
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|17
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|14
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|44
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|4
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|4
block|,
literal|19
block|,
literal|20
block|,
operator|-
literal|1
block|,
literal|21
block|,
literal|18
block|,
literal|4
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|13
block|,
literal|22
block|,
literal|38
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|38
block|,
literal|22
block|,
literal|13
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|18
block|,
literal|38
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|7
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|8
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|10
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|13
block|,
literal|22
block|,
literal|38
block|,
literal|22
block|,
literal|33
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|13
block|,
literal|22
block|,
literal|38
block|,
literal|22
block|,
literal|40
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|13
block|,
literal|22
block|,
literal|34
block|,
literal|41
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|34
block|,
literal|22
block|,
literal|13
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|18
block|,
literal|38
block|,
literal|22
block|,
literal|33
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|38
block|,
literal|22
block|,
literal|33
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|18
block|,
literal|38
block|,
literal|22
block|,
literal|40
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|38
block|,
literal|22
block|,
literal|40
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|18
block|,
literal|34
block|,
literal|41
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|34
block|,
literal|41
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|13
block|,
literal|41
block|,
literal|24
block|,
literal|22
block|,
literal|33
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|13
block|,
literal|41
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|38
block|,
literal|24
block|,
literal|22
block|,
literal|33
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|38
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|13
block|,
literal|22
block|,
literal|38
block|,
literal|22
block|,
literal|33
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|38
block|,
literal|22
block|,
literal|33
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|13
block|,
literal|22
block|,
literal|38
block|,
literal|22
block|,
literal|40
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|38
block|,
literal|22
block|,
literal|40
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|18
block|,
literal|23
block|,
literal|43
block|,
literal|34
block|,
literal|41
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|20
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|21
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|18
block|,
literal|43
block|,
literal|33
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
literal|25
block|,
literal|18
block|,
literal|43
block|,
literal|33
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
literal|25
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|39
block|,
literal|25
block|,
literal|18
block|,
literal|43
block|,
literal|33
block|,
literal|19
block|,
literal|25
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|12
block|,
operator|-
literal|1
block|,
literal|35
block|,
operator|-
literal|1
block|,
literal|12
block|,
operator|-
literal|1
block|,
literal|36
block|,
operator|-
literal|1
block|,
literal|36
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|8
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|9
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|7
block|,
operator|-
literal|1
block|,
literal|37
block|,
operator|-
literal|1
block|,
literal|10
block|,
operator|-
literal|1
block|,
literal|8
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|38
block|,
operator|-
literal|1
block|,
literal|7
block|,
operator|-
literal|1
block|,
literal|10
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|22
block|,
literal|38
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|22
block|,
literal|13
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|22
block|,
operator|-
literal|1
block|,
literal|46
block|,
operator|-
literal|1
block|,
literal|46
block|,
literal|26
block|,
literal|45
block|,
operator|-
literal|1
block|,
literal|47
block|,
literal|26
block|,
literal|45
block|,
operator|-
literal|1
block|,
literal|47
block|,
operator|-
literal|1
block|,
literal|46
block|,
operator|-
literal|1
block|,
literal|46
block|,
literal|26
block|,
literal|45
block|,
operator|-
literal|1
block|,
literal|47
block|,
literal|26
block|,
literal|45
block|,
operator|-
literal|1
block|,
literal|47
block|,
literal|21
block|,
literal|47
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|6
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|int
name|yyrline
index|[]
init|=
block|{
literal|0
block|,
literal|121
block|,
literal|121
block|,
literal|122
block|,
literal|126
block|,
literal|135
block|,
literal|136
block|,
literal|143
block|,
literal|148
block|,
literal|153
block|,
literal|158
block|,
literal|163
block|,
literal|168
block|,
literal|173
block|,
literal|178
block|,
literal|183
block|,
literal|188
block|,
literal|193
block|,
literal|206
block|,
literal|211
block|,
literal|216
block|,
literal|221
block|,
literal|231
block|,
literal|241
block|,
literal|251
block|,
literal|256
block|,
literal|261
block|,
literal|266
block|,
literal|273
block|,
literal|284
block|,
literal|291
block|,
literal|297
block|,
literal|304
block|,
literal|310
block|,
literal|321
block|,
literal|331
block|,
literal|338
block|,
literal|344
block|,
literal|352
block|,
literal|359
block|,
literal|366
block|,
literal|372
block|,
literal|380
block|,
literal|387
block|,
literal|399
block|,
literal|410
block|,
literal|423
block|,
literal|431
block|,
literal|439
block|,
literal|447
block|,
literal|457
block|,
literal|464
block|,
literal|472
block|,
literal|479
block|,
literal|493
block|,
literal|494
block|,
literal|507
block|,
literal|508
block|,
literal|520
block|,
literal|521
block|,
literal|522
block|,
literal|528
block|,
literal|529
block|,
literal|535
block|,
literal|536
block|,
literal|543
block|,
literal|544
block|,
literal|545
block|,
literal|552
block|,
literal|555
block|,
literal|561
block|,
literal|562
block|,
literal|569
block|,
literal|572
block|,
literal|582
block|,
literal|586
block|,
literal|596
block|,
literal|600
block|,
literal|609
block|,
literal|610
block|,
literal|614
block|,
literal|626
block|,
literal|630
block|,
literal|631
block|,
literal|635
block|,
literal|642
block|,
literal|652
block|,
literal|656
block|,
literal|660
block|,
literal|664
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYDEBUG
operator|||
name|YYERROR_VERBOSE
operator|||
name|YYTOKEN_TABLE
end_if

begin_comment
comment|/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.    First, the terminals, then, starting at YYNTOKENS, nonterminals. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yytname
index|[]
init|=
block|{
literal|"$end"
block|,
literal|"error"
block|,
literal|"$undefined"
block|,
literal|"DR"
block|,
literal|"AR"
block|,
literal|"FPR"
block|,
literal|"FPCR"
block|,
literal|"LPC"
block|,
literal|"ZAR"
block|,
literal|"ZDR"
block|,
literal|"LZPC"
block|,
literal|"CREG"
block|,
literal|"INDEXREG"
block|,
literal|"EXPR"
block|,
literal|"'&'"
block|,
literal|"'<'"
block|,
literal|"'>'"
block|,
literal|"'#'"
block|,
literal|"'('"
block|,
literal|"')'"
block|,
literal|"'+'"
block|,
literal|"'-'"
block|,
literal|"','"
block|,
literal|"'['"
block|,
literal|"']'"
block|,
literal|"'@'"
block|,
literal|"'/'"
block|,
literal|"$accept"
block|,
literal|"operand"
block|,
literal|"optional_ampersand"
block|,
literal|"generic_operand"
block|,
literal|"motorola_operand"
block|,
literal|"mit_operand"
block|,
literal|"zireg"
block|,
literal|"zdireg"
block|,
literal|"zadr"
block|,
literal|"zdr"
block|,
literal|"apc"
block|,
literal|"zapc"
block|,
literal|"optzapc"
block|,
literal|"zpc"
block|,
literal|"optczapc"
block|,
literal|"optcexpr"
block|,
literal|"optexprc"
block|,
literal|"reglist"
block|,
literal|"ireglist"
block|,
literal|"reglistpair"
block|,
literal|"reglistreg"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YYPRINT
end_ifdef

begin_comment
comment|/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to    token YYLEX-NUM.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|int
name|yytoknum
index|[]
init|=
block|{
literal|0
block|,
literal|256
block|,
literal|257
block|,
literal|258
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|262
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
literal|266
block|,
literal|267
block|,
literal|268
block|,
literal|38
block|,
literal|60
block|,
literal|62
block|,
literal|35
block|,
literal|40
block|,
literal|41
block|,
literal|43
block|,
literal|45
block|,
literal|44
block|,
literal|91
block|,
literal|93
block|,
literal|64
block|,
literal|47
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|27
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|29
block|,
literal|29
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|33
block|,
literal|33
block|,
literal|34
block|,
literal|34
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|36
block|,
literal|36
block|,
literal|37
block|,
literal|37
block|,
literal|38
block|,
literal|38
block|,
literal|38
block|,
literal|39
block|,
literal|39
block|,
literal|40
block|,
literal|40
block|,
literal|41
block|,
literal|41
block|,
literal|42
block|,
literal|42
block|,
literal|43
block|,
literal|43
block|,
literal|44
block|,
literal|44
block|,
literal|44
block|,
literal|45
block|,
literal|45
block|,
literal|45
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|9
block|,
literal|7
block|,
literal|8
block|,
literal|6
block|,
literal|10
block|,
literal|8
block|,
literal|10
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|10
block|,
literal|9
block|,
literal|10
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero    means the default is an error.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|yydefact
index|[]
init|=
block|{
literal|68
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|64
block|,
literal|67
block|,
literal|66
block|,
literal|13
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|5
block|,
literal|5
block|,
literal|65
block|,
literal|69
block|,
literal|0
block|,
literal|17
block|,
literal|78
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|61
block|,
literal|63
block|,
literal|64
block|,
literal|67
block|,
literal|62
block|,
literal|66
block|,
literal|56
block|,
literal|0
block|,
literal|76
block|,
literal|72
block|,
literal|57
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|6
block|,
literal|3
block|,
literal|4
block|,
literal|46
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|63
block|,
literal|72
block|,
literal|0
block|,
literal|18
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|0
block|,
literal|72
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|76
block|,
literal|47
block|,
literal|48
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|79
block|,
literal|82
block|,
literal|81
block|,
literal|85
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|23
block|,
literal|0
block|,
literal|19
block|,
literal|72
block|,
literal|0
block|,
literal|77
block|,
literal|0
block|,
literal|0
block|,
literal|74
block|,
literal|72
block|,
literal|0
block|,
literal|73
block|,
literal|36
block|,
literal|59
block|,
literal|70
block|,
literal|60
block|,
literal|71
block|,
literal|54
block|,
literal|0
block|,
literal|0
block|,
literal|55
block|,
literal|58
block|,
literal|0
block|,
literal|20
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|35
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|0
block|,
literal|73
block|,
literal|74
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|22
block|,
literal|32
block|,
literal|34
block|,
literal|49
block|,
literal|77
block|,
literal|0
block|,
literal|83
block|,
literal|84
block|,
literal|31
block|,
literal|33
block|,
literal|29
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|74
block|,
literal|74
block|,
literal|75
block|,
literal|74
block|,
literal|40
block|,
literal|74
block|,
literal|0
block|,
literal|50
block|,
literal|27
block|,
literal|28
block|,
literal|0
block|,
literal|0
block|,
literal|74
block|,
literal|38
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|76
block|,
literal|0
block|,
literal|74
block|,
literal|74
block|,
literal|0
block|,
literal|42
block|,
literal|44
block|,
literal|39
block|,
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|37
block|,
literal|52
block|,
literal|0
block|,
literal|0
block|,
literal|41
block|,
literal|43
block|,
literal|51
block|,
literal|53
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYDEFGOTO[NTERM-NUM]. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|yysigned_char
name|yydefgoto
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|16
block|,
literal|46
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|100
block|,
literal|40
block|,
literal|101
block|,
literal|102
block|,
literal|20
block|,
literal|92
block|,
literal|22
block|,
literal|103
block|,
literal|64
block|,
literal|120
block|,
literal|62
block|,
literal|23
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing    STATE-NUM.  */
end_comment

begin_define
define|#
directive|define
name|YYPACT_NINF
value|-98
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|yypact
index|[]
init|=
block|{
literal|89
block|,
literal|14
block|,
literal|9
block|,
literal|31
block|,
literal|35
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|0
block|,
literal|36
block|,
literal|42
block|,
literal|28
block|,
literal|56
block|,
literal|63
block|,
literal|67
block|,
literal|90
block|,
operator|-
literal|98
block|,
literal|75
block|,
literal|75
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|86
block|,
operator|-
literal|98
block|,
literal|96
block|,
operator|-
literal|15
block|,
literal|123
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|97
block|,
literal|115
block|,
literal|119
block|,
operator|-
literal|98
block|,
literal|120
block|,
operator|-
literal|98
block|,
literal|122
block|,
literal|16
block|,
literal|126
block|,
operator|-
literal|98
block|,
literal|127
block|,
literal|157
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|19
block|,
literal|154
block|,
literal|154
block|,
literal|154
block|,
operator|-
literal|98
block|,
literal|140
block|,
literal|29
block|,
literal|144
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|123
block|,
literal|141
block|,
literal|99
block|,
literal|18
block|,
literal|70
block|,
literal|147
block|,
literal|105
block|,
literal|148
block|,
literal|152
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|142
block|,
operator|-
literal|13
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|146
block|,
literal|150
block|,
operator|-
literal|98
block|,
literal|133
block|,
operator|-
literal|98
block|,
literal|140
block|,
literal|60
block|,
literal|146
block|,
literal|149
block|,
literal|133
block|,
literal|153
block|,
literal|140
block|,
literal|151
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|155
block|,
literal|158
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|159
block|,
operator|-
literal|98
block|,
literal|62
block|,
literal|143
block|,
literal|154
block|,
literal|154
block|,
operator|-
literal|98
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
operator|-
literal|98
block|,
literal|133
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|116
block|,
literal|168
block|,
literal|167
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|169
block|,
operator|-
literal|98
block|,
literal|173
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|174
block|,
literal|176
block|,
literal|133
block|,
literal|116
block|,
literal|177
block|,
literal|175
block|,
literal|175
block|,
operator|-
literal|98
block|,
literal|175
block|,
operator|-
literal|98
block|,
literal|175
block|,
literal|170
block|,
literal|178
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|180
block|,
literal|181
block|,
literal|175
block|,
operator|-
literal|98
block|,
literal|171
block|,
literal|179
block|,
literal|182
block|,
literal|183
block|,
literal|187
block|,
literal|186
block|,
literal|189
block|,
literal|175
block|,
literal|175
block|,
literal|190
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|79
block|,
literal|143
block|,
literal|195
block|,
literal|191
block|,
literal|192
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|193
block|,
literal|194
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYPGOTO[NTERM-NUM].  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|yypgoto
index|[]
init|=
block|{
operator|-
literal|98
block|,
operator|-
literal|98
block|,
literal|196
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|98
block|,
operator|-
literal|81
block|,
literal|6
block|,
operator|-
literal|98
block|,
operator|-
literal|9
block|,
operator|-
literal|98
block|,
literal|2
block|,
operator|-
literal|98
block|,
operator|-
literal|78
block|,
operator|-
literal|38
block|,
operator|-
literal|97
block|,
operator|-
literal|67
block|,
operator|-
literal|98
block|,
operator|-
literal|48
block|,
literal|172
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If    positive, shift that token.  If negative, reduce the rule which    number is the opposite.  If zero, do what YYDEFACT says.    If YYTABLE_NINF, syntax error.  */
end_comment

begin_define
define|#
directive|define
name|YYTABLE_NINF
value|-64
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|yytable
index|[]
init|=
block|{
literal|106
block|,
literal|110
block|,
literal|21
block|,
literal|78
block|,
literal|111
block|,
literal|41
block|,
literal|50
block|,
literal|117
block|,
literal|50
block|,
operator|-
literal|10
block|,
literal|118
block|,
literal|51
block|,
literal|25
block|,
literal|108
block|,
operator|-
literal|9
block|,
literal|80
block|,
literal|42
block|,
literal|41
block|,
literal|26
block|,
literal|138
block|,
literal|52
block|,
literal|31
block|,
literal|87
block|,
literal|5
block|,
literal|6
block|,
literal|128
block|,
literal|7
block|,
literal|35
block|,
literal|54
block|,
literal|60
block|,
literal|37
block|,
operator|-
literal|11
block|,
literal|53
block|,
literal|134
block|,
operator|-
literal|63
block|,
operator|-
literal|12
block|,
literal|135
block|,
literal|67
block|,
literal|142
block|,
literal|68
block|,
literal|69
block|,
literal|61
block|,
literal|154
block|,
literal|155
block|,
literal|29
block|,
literal|156
block|,
literal|112
block|,
literal|157
block|,
literal|81
block|,
literal|27
block|,
literal|41
block|,
literal|82
block|,
literal|121
block|,
literal|41
block|,
literal|162
block|,
literal|149
block|,
literal|151
block|,
literal|28
block|,
literal|150
block|,
literal|129
block|,
literal|130
block|,
literal|85
block|,
literal|77
block|,
literal|170
block|,
literal|171
block|,
literal|84
block|,
literal|31
block|,
literal|32
block|,
literal|90
block|,
literal|30
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|52
block|,
literal|37
block|,
literal|38
block|,
literal|5
block|,
literal|6
block|,
literal|113
block|,
literal|7
block|,
literal|126
block|,
literal|114
block|,
literal|91
block|,
literal|127
block|,
literal|43
block|,
literal|39
block|,
literal|174
block|,
literal|115
block|,
literal|45
block|,
literal|44
block|,
literal|168
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|173
block|,
literal|7
block|,
literal|8
block|,
literal|127
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|31
block|,
literal|94
block|,
literal|15
block|,
literal|48
block|,
literal|95
block|,
literal|96
block|,
literal|35
block|,
literal|97
block|,
literal|55
block|,
literal|98
block|,
literal|99
block|,
literal|31
block|,
literal|94
block|,
literal|88
block|,
literal|49
block|,
literal|89
block|,
literal|96
block|,
literal|35
block|,
literal|31
block|,
literal|52
block|,
literal|98
block|,
literal|141
block|,
literal|5
block|,
literal|6
block|,
literal|35
block|,
literal|7
block|,
literal|56
block|,
literal|37
block|,
literal|31
block|,
literal|94
block|,
literal|57
block|,
literal|58
block|,
literal|95
block|,
literal|96
block|,
literal|35
block|,
literal|97
block|,
literal|59
block|,
literal|98
block|,
literal|31
block|,
literal|94
block|,
literal|63
block|,
literal|65
block|,
literal|52
block|,
literal|96
block|,
literal|35
block|,
literal|5
block|,
literal|6
block|,
literal|98
block|,
literal|7
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|66
block|,
literal|79
block|,
literal|86
block|,
literal|83
block|,
literal|105
block|,
literal|93
block|,
literal|104
block|,
literal|107
block|,
literal|109
block|,
literal|122
block|,
literal|0
block|,
literal|24
block|,
literal|116
block|,
literal|123
block|,
literal|119
block|,
literal|0
block|,
literal|124
block|,
literal|125
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|0
block|,
literal|0
block|,
literal|141
block|,
literal|136
block|,
literal|137
block|,
literal|143
block|,
literal|158
block|,
literal|139
block|,
literal|140
block|,
literal|144
block|,
literal|146
block|,
literal|147
block|,
literal|145
block|,
literal|148
block|,
literal|152
block|,
literal|153
block|,
literal|163
block|,
literal|167
block|,
literal|0
block|,
literal|164
block|,
literal|165
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|166
block|,
literal|169
block|,
literal|175
block|,
literal|172
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|0
block|,
literal|47
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|yycheck
index|[]
init|=
block|{
literal|67
block|,
literal|82
block|,
literal|0
block|,
literal|51
block|,
literal|82
block|,
literal|14
block|,
literal|21
block|,
literal|88
block|,
literal|21
block|,
literal|0
block|,
literal|88
block|,
literal|26
block|,
literal|0
block|,
literal|26
block|,
literal|0
block|,
literal|53
block|,
literal|14
block|,
literal|26
block|,
literal|18
block|,
literal|116
block|,
literal|4
block|,
literal|3
block|,
literal|60
block|,
literal|7
block|,
literal|8
block|,
literal|106
block|,
literal|10
block|,
literal|9
block|,
literal|26
block|,
literal|13
block|,
literal|12
block|,
literal|0
block|,
literal|26
block|,
literal|114
block|,
literal|25
block|,
literal|0
block|,
literal|114
block|,
literal|18
block|,
literal|119
block|,
literal|20
block|,
literal|21
block|,
literal|39
block|,
literal|139
block|,
literal|140
block|,
literal|16
block|,
literal|142
block|,
literal|84
block|,
literal|144
block|,
literal|19
block|,
literal|13
block|,
literal|59
block|,
literal|22
block|,
literal|90
block|,
literal|62
block|,
literal|151
block|,
literal|136
block|,
literal|137
block|,
literal|15
block|,
literal|136
block|,
literal|107
block|,
literal|108
block|,
literal|59
block|,
literal|50
block|,
literal|160
block|,
literal|161
block|,
literal|59
block|,
literal|3
block|,
literal|4
block|,
literal|62
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|4
block|,
literal|12
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|19
block|,
literal|10
block|,
literal|19
block|,
literal|22
block|,
literal|13
block|,
literal|22
block|,
literal|18
block|,
literal|23
block|,
literal|168
block|,
literal|86
block|,
literal|14
block|,
literal|0
block|,
literal|158
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|19
block|,
literal|10
block|,
literal|11
block|,
literal|22
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|3
block|,
literal|4
block|,
literal|21
block|,
literal|25
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|19
block|,
literal|12
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|22
block|,
literal|26
block|,
literal|24
block|,
literal|8
block|,
literal|9
block|,
literal|3
block|,
literal|4
block|,
literal|12
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|19
block|,
literal|12
block|,
literal|3
block|,
literal|4
block|,
literal|19
block|,
literal|19
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|22
block|,
literal|12
block|,
literal|3
block|,
literal|4
block|,
literal|22
block|,
literal|22
block|,
literal|4
block|,
literal|8
block|,
literal|9
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|4
block|,
literal|22
block|,
literal|22
block|,
literal|20
block|,
literal|13
block|,
literal|19
block|,
literal|19
block|,
literal|26
block|,
literal|19
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|24
block|,
literal|19
block|,
literal|22
block|,
operator|-
literal|1
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|13
block|,
literal|22
block|,
literal|22
block|,
literal|19
block|,
literal|18
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|19
block|,
literal|19
block|,
literal|25
block|,
literal|19
block|,
literal|19
block|,
literal|22
block|,
literal|19
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|19
block|,
literal|19
block|,
literal|25
block|,
literal|24
block|,
literal|24
block|,
literal|19
block|,
literal|18
block|,
literal|13
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing    symbol of state STATE-NUM.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|yystos
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|21
block|,
literal|28
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|44
block|,
literal|46
block|,
literal|47
block|,
literal|18
block|,
literal|13
block|,
literal|15
block|,
literal|16
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|12
block|,
literal|13
block|,
literal|23
block|,
literal|34
block|,
literal|36
block|,
literal|38
block|,
literal|18
block|,
literal|0
block|,
literal|14
block|,
literal|29
block|,
literal|29
block|,
literal|25
block|,
literal|26
block|,
literal|21
block|,
literal|26
block|,
literal|4
block|,
literal|34
block|,
literal|38
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|22
block|,
literal|13
block|,
literal|38
block|,
literal|43
block|,
literal|22
block|,
literal|41
block|,
literal|22
block|,
literal|4
block|,
literal|18
block|,
literal|20
block|,
literal|21
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|47
block|,
literal|45
block|,
literal|22
block|,
literal|41
block|,
literal|19
block|,
literal|22
block|,
literal|20
block|,
literal|34
block|,
literal|38
block|,
literal|22
block|,
literal|41
block|,
literal|22
block|,
literal|24
block|,
literal|34
block|,
literal|13
block|,
literal|38
block|,
literal|19
block|,
literal|4
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|13
block|,
literal|33
block|,
literal|35
block|,
literal|36
block|,
literal|40
block|,
literal|19
block|,
literal|13
block|,
literal|43
block|,
literal|26
block|,
literal|26
block|,
literal|19
block|,
literal|33
block|,
literal|40
block|,
literal|41
block|,
literal|19
block|,
literal|22
block|,
literal|38
block|,
literal|24
block|,
literal|33
block|,
literal|40
block|,
literal|22
block|,
literal|42
block|,
literal|41
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|22
block|,
literal|33
block|,
literal|45
block|,
literal|45
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|33
block|,
literal|40
block|,
literal|22
block|,
literal|22
block|,
literal|42
block|,
literal|24
block|,
literal|24
block|,
literal|13
block|,
literal|33
block|,
literal|19
block|,
literal|24
block|,
literal|25
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|33
block|,
literal|40
block|,
literal|33
block|,
literal|19
block|,
literal|22
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|18
block|,
literal|25
block|,
literal|24
block|,
literal|24
block|,
literal|42
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|13
block|,
literal|43
block|,
literal|18
block|,
literal|42
block|,
literal|42
block|,
literal|19
block|,
literal|19
block|,
literal|33
block|,
literal|13
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrstatus = 0)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|(-2)
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyacceptlab
end_define

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabortlab
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrorlab
end_define

begin_comment
comment|/* Like YYERROR except do call yyerror.  This remains here temporarily    to ease the transition to the new meaning of YYERROR, for GCC.    Once GCC version 2 has supplanted version 1, this can go.  */
end_comment

begin_define
define|#
directive|define
name|YYFAIL
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(!!yyerrstatus)
end_define

begin_define
define|#
directive|define
name|YYBACKUP
parameter_list|(
name|Token
parameter_list|,
name|Value
parameter_list|)
define|\
value|do								\   if (yychar == YYEMPTY&& yylen == 1)				\     {								\       yychar = (Token);						\       yylval = (Value);						\       yytoken = YYTRANSLATE (yychar);				\       YYPOPSTACK;						\       goto yybackup;						\     }								\   else								\     {								\       yyerror (YY_("syntax error: cannot back up")); \       YYERROR;							\     }								\ while (0)
end_define

begin_define
define|#
directive|define
name|YYTERROR
value|1
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_comment
comment|/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].    If N is 0, then set CURRENT to the empty location which ends    the previous symbol: RHS[0] (always defined).  */
end_comment

begin_define
define|#
directive|define
name|YYRHSLOC
parameter_list|(
name|Rhs
parameter_list|,
name|K
parameter_list|)
value|((Rhs)[K])
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYLLOC_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|YYLLOC_DEFAULT
parameter_list|(
name|Current
parameter_list|,
name|Rhs
parameter_list|,
name|N
parameter_list|)
define|\
value|do									\       if (N)								\ 	{								\ 	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\ 	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\ 	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\ 	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\ 	}								\       else								\ 	{								\ 	  (Current).first_line   = (Current).last_line   =		\ 	    YYRHSLOC (Rhs, 0).last_line;				\ 	  (Current).first_column = (Current).last_column =		\ 	    YYRHSLOC (Rhs, 0).last_column;				\ 	}								\     while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YY_LOCATION_PRINT -- Print the location on the stream.    This macro was not mandated originally: define only if we know    we won't break user code: when these are the locations we know.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_LOCATION_PRINT
end_ifndef

begin_if
if|#
directive|if
name|YYLTYPE_IS_TRIVIAL
end_if

begin_define
define|#
directive|define
name|YY_LOCATION_PRINT
parameter_list|(
name|File
parameter_list|,
name|Loc
parameter_list|)
define|\
value|fprintf (File, "%d.%d-%d.%d",			\               (Loc).first_line, (Loc).first_column,	\               (Loc).last_line,  (Loc).last_column)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YY_LOCATION_PRINT
parameter_list|(
name|File
parameter_list|,
name|Loc
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYLEX -- calling `yylex' with the right arguments.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
value|yylex (YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX
value|yylex ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Enable debugging if requested.  */
end_comment

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|YYFPRINTF
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYFPRINTF
value|fprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
define|\
value|do {						\   if (yydebug)					\     YYFPRINTF Args;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|YY_SYMBOL_PRINT
parameter_list|(
name|Title
parameter_list|,
name|Type
parameter_list|,
name|Value
parameter_list|,
name|Location
parameter_list|)
define|\
value|do {								\   if (yydebug)							\     {								\       YYFPRINTF (stderr, "%s ", Title);				\       yysymprint (stderr,					\                   Type, Value);	\       YYFPRINTF (stderr, "\n");					\     }								\ } while (0)
end_define

begin_comment
comment|/*------------------------------------------------------------------. | yy_stack_print -- Print the state stack from its BOTTOM up to its | | TOP (included).                                                   | `------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yy_stack_print
parameter_list|(
name|short
name|int
modifier|*
name|bottom
parameter_list|,
name|short
name|int
modifier|*
name|top
parameter_list|)
else|#
directive|else
function|static void yy_stack_print
parameter_list|(
name|bottom
parameter_list|,
name|top
parameter_list|)
name|short
name|int
modifier|*
name|bottom
decl_stmt|;
name|short
name|int
modifier|*
name|top
decl_stmt|;
endif|#
directive|endif
block|{
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"Stack now"
argument_list|)
expr_stmt|;
for|for
control|(
comment|/* Nothing. */
init|;
name|bottom
operator|<=
name|top
condition|;
operator|++
name|bottom
control|)
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|bottom
argument_list|)
expr_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|YY_STACK_PRINT
parameter_list|(
name|Bottom
parameter_list|,
name|Top
parameter_list|)
define|\
value|do {								\   if (yydebug)							\     yy_stack_print ((Bottom), (Top));				\ } while (0)
end_define

begin_comment
comment|/*------------------------------------------------. | Report that the YYRULE is going to be reduced.  | `------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yy_reduce_print
parameter_list|(
name|int
name|yyrule
parameter_list|)
else|#
directive|else
function|static void yy_reduce_print
parameter_list|(
name|yyrule
parameter_list|)
name|int
name|yyrule
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|yyi
decl_stmt|;
name|unsigned
name|long
name|int
name|yylno
init|=
name|yyrline
index|[
name|yyrule
index|]
decl_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"Reducing stack by rule %d (line %lu), "
argument_list|,
name|yyrule
operator|-
literal|1
argument_list|,
name|yylno
argument_list|)
expr_stmt|;
comment|/* Print the symbols being reduced, and their result.  */
for|for
control|(
name|yyi
operator|=
name|yyprhs
index|[
name|yyrule
index|]
init|;
literal|0
operator|<=
name|yyrhs
index|[
name|yyi
index|]
condition|;
name|yyi
operator|++
control|)
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|yytname
index|[
name|yyrhs
index|[
name|yyi
index|]
index|]
argument_list|)
expr_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"-> %s\n"
argument_list|,
name|yytname
index|[
name|yyr1
index|[
name|yyrule
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|YY_REDUCE_PRINT
parameter_list|(
name|Rule
parameter_list|)
define|\
value|do {					\   if (yydebug)				\     yy_reduce_print (Rule);		\ } while (0)
end_define

begin_comment
comment|/* Nonzero means print parse trace.  It is left uninitialized so that    multiple parsers can coexist.  */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
end_define

begin_define
define|#
directive|define
name|YY_SYMBOL_PRINT
parameter_list|(
name|Title
parameter_list|,
name|Type
parameter_list|,
name|Value
parameter_list|,
name|Location
parameter_list|)
end_define

begin_define
define|#
directive|define
name|YY_STACK_PRINT
parameter_list|(
name|Bottom
parameter_list|,
name|Top
parameter_list|)
end_define

begin_define
define|#
directive|define
name|YY_REDUCE_PRINT
parameter_list|(
name|Rule
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_comment
comment|/* YYINITDEPTH -- initial size of the parser's stacks.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYINITDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYINITDEPTH
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only    if the built-in stack extension method is used).     Do not make this value too large; the results are undefined if    YYSTACK_ALLOC_MAXIMUM< YYSTACK_BYTES (YYMAXDEPTH)    evaluated with infinite-precision integer arithmetic.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|YYERROR_VERBOSE
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|yystrlen
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_STRING_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|yystrlen
value|strlen
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Return the length of YYSTR.  */
end_comment

begin_function
specifier|static
name|YYSIZE_T
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|yystrlen
parameter_list|(
specifier|const
name|char
modifier|*
name|yystr
parameter_list|)
else|#
directive|else
function|yystrlen
parameter_list|(
name|yystr
parameter_list|)
specifier|const
name|char
modifier|*
name|yystr
decl_stmt|;
endif|#
directive|endif
block|{
specifier|const
name|char
modifier|*
name|yys
init|=
name|yystr
decl_stmt|;
while|while
condition|(
operator|*
name|yys
operator|++
operator|!=
literal|'\0'
condition|)
continue|continue;
return|return
name|yys
operator|-
name|yystr
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|yystpcpy
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_STRING_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|_GNU_SOURCE
argument_list|)
end_if

begin_define
define|#
directive|define
name|yystpcpy
value|stpcpy
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in    YYDEST.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|yystpcpy
parameter_list|(
name|char
modifier|*
name|yydest
parameter_list|,
specifier|const
name|char
modifier|*
name|yysrc
parameter_list|)
else|#
directive|else
function|yystpcpy
parameter_list|(
name|yydest
parameter_list|,
name|yysrc
parameter_list|)
name|char
modifier|*
name|yydest
decl_stmt|;
specifier|const
name|char
modifier|*
name|yysrc
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|yyd
init|=
name|yydest
decl_stmt|;
specifier|const
name|char
modifier|*
name|yys
init|=
name|yysrc
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|yyd
operator|++
operator|=
operator|*
name|yys
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
continue|continue;
return|return
name|yyd
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|yytnamerr
end_ifndef

begin_comment
comment|/* Copy to YYRES the contents of YYSTR after stripping away unnecessary    quotes and backslashes, so that it's suitable for yyerror.  The    heuristic is that double-quoting is unnecessary unless the string    contains an apostrophe, a comma, or backslash (other than    backslash-backslash).  YYSTR is taken from yytname.  If YYRES is    null, do not copy; instead, return the length of what the result    would have been.  */
end_comment

begin_function
specifier|static
name|YYSIZE_T
name|yytnamerr
parameter_list|(
name|char
modifier|*
name|yyres
parameter_list|,
specifier|const
name|char
modifier|*
name|yystr
parameter_list|)
block|{
if|if
condition|(
operator|*
name|yystr
operator|==
literal|'"'
condition|)
block|{
name|size_t
name|yyn
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|yyp
init|=
name|yystr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
operator|++
name|yyp
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|','
case|:
goto|goto
name|do_not_strip_quotes
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
operator|++
name|yyp
operator|!=
literal|'\\'
condition|)
goto|goto
name|do_not_strip_quotes
goto|;
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|yyres
condition|)
name|yyres
index|[
name|yyn
index|]
operator|=
operator|*
name|yyp
expr_stmt|;
name|yyn
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|yyres
condition|)
name|yyres
index|[
name|yyn
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|yyn
return|;
block|}
name|do_not_strip_quotes
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|yyres
condition|)
return|return
name|yystrlen
argument_list|(
name|yystr
argument_list|)
return|;
return|return
name|yystpcpy
argument_list|(
name|yyres
argument_list|,
name|yystr
argument_list|)
operator|-
name|yyres
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYERROR_VERBOSE */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_comment
comment|/*--------------------------------. | Print this symbol on YYOUTPUT.  | `--------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yysymprint
parameter_list|(
name|FILE
modifier|*
name|yyoutput
parameter_list|,
name|int
name|yytype
parameter_list|,
name|YYSTYPE
modifier|*
name|yyvaluep
parameter_list|)
else|#
directive|else
function|static void yysymprint
parameter_list|(
name|yyoutput
parameter_list|,
name|yytype
parameter_list|,
name|yyvaluep
parameter_list|)
name|FILE
modifier|*
name|yyoutput
decl_stmt|;
name|int
name|yytype
decl_stmt|;
name|YYSTYPE
modifier|*
name|yyvaluep
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* Pacify ``unused variable'' warnings.  */
operator|(
name|void
operator|)
name|yyvaluep
expr_stmt|;
if|if
condition|(
name|yytype
operator|<
name|YYNTOKENS
condition|)
name|YYFPRINTF
argument_list|(
name|yyoutput
argument_list|,
literal|"token %s ("
argument_list|,
name|yytname
index|[
name|yytype
index|]
argument_list|)
expr_stmt|;
else|else
name|YYFPRINTF
argument_list|(
name|yyoutput
argument_list|,
literal|"nterm %s ("
argument_list|,
name|yytname
index|[
name|yytype
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYPRINT
if|if
condition|(
name|yytype
operator|<
name|YYNTOKENS
condition|)
name|YYPRINT
argument_list|(
name|yyoutput
argument_list|,
name|yytoknum
index|[
name|yytype
index|]
argument_list|,
operator|*
name|yyvaluep
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|yytype
condition|)
block|{
default|default:
break|break;
block|}
name|YYFPRINTF
argument_list|(
name|yyoutput
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! YYDEBUG */
end_comment

begin_comment
comment|/*-----------------------------------------------. | Release the memory associated to this symbol.  | `-----------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|yydestruct
argument_list|(
specifier|const
name|char
operator|*
name|yymsg
argument_list|,
name|int
name|yytype
argument_list|,
name|YYSTYPE
operator|*
name|yyvaluep
argument_list|)
else|#
directive|else
decl|static
name|void
name|yydestruct
argument_list|(
name|yymsg
argument_list|,
name|yytype
argument_list|,
name|yyvaluep
argument_list|)
decl|const
name|char
modifier|*
name|yymsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yytype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
modifier|*
name|yyvaluep
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
comment|/* Pacify ``unused variable'' warnings.  */
operator|(
name|void
operator|)
name|yyvaluep
expr_stmt|;
if|if
condition|(
operator|!
name|yymsg
condition|)
name|yymsg
operator|=
literal|"Deleting"
expr_stmt|;
name|YY_SYMBOL_PRINT
argument_list|(
name|yymsg
argument_list|,
name|yytype
argument_list|,
name|yyvaluep
argument_list|,
name|yylocationp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yytype
condition|)
block|{
default|default:
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Prevent warnings from -Wmissing-prototypes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
modifier|*
name|YYPARSE_PARAM
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|yyparse
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! YYPARSE_PARAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|yyparse
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! YYPARSE_PARAM */
end_comment

begin_comment
comment|/* The look-ahead symbol.  */
end_comment

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The semantic value of the look-ahead symbol.  */
end_comment

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of syntax errors so far.  */
end_comment

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------. | yyparse.  | `----------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_decl_stmt
name|int
name|yyparse
argument_list|(
name|void
operator|*
name|YYPARSE_PARAM
argument_list|)
else|#
directive|else
name|int
name|yyparse
argument_list|(
name|YYPARSE_PARAM
argument_list|)
name|void
modifier|*
name|YYPARSE_PARAM
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! YYPARSE_PARAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|int yyparse
parameter_list|()
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|yystate
decl_stmt|;
name|int
name|yyn
decl_stmt|;
name|int
name|yyresult
decl_stmt|;
comment|/* Number of tokens to shift before error messages enabled.  */
name|int
name|yyerrstatus
decl_stmt|;
comment|/* Look-ahead token as an internal (translated) token number.  */
name|int
name|yytoken
init|=
literal|0
decl_stmt|;
comment|/* Three stacks and their tools:      `yyss': related to states,      `yyvs': related to semantic values,      `yyls': related to locations.       Refer to the stacks thru separate pointers, to allow yyoverflow      to reallocate them elsewhere.  */
comment|/* The state stack.  */
name|short
name|int
name|yyssa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|short
name|int
modifier|*
name|yyss
init|=
name|yyssa
decl_stmt|;
name|short
name|int
modifier|*
name|yyssp
decl_stmt|;
comment|/* The semantic value stack.  */
name|YYSTYPE
name|yyvsa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|YYSTYPE
modifier|*
name|yyvs
init|=
name|yyvsa
decl_stmt|;
name|YYSTYPE
modifier|*
name|yyvsp
decl_stmt|;
define|#
directive|define
name|YYPOPSTACK
value|(yyvsp--, yyssp--)
name|YYSIZE_T
name|yystacksize
init|=
name|YYINITDEPTH
decl_stmt|;
comment|/* The variables used to return semantic value and location from the      action routines.  */
name|YYSTYPE
name|yyval
decl_stmt|;
comment|/* When reducing, the number of symbols on the RHS of the reduced      rule.  */
name|int
name|yylen
decl_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Starting parse\n"
operator|)
argument_list|)
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yyerrstatus
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
comment|/* Cause a token to be read.  */
comment|/* Initialize stack pointers.      Waste one element of value and location stack      so that they stay on the same level as the state stack.      The wasted elements are never initialized.  */
name|yyssp
operator|=
name|yyss
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
expr_stmt|;
goto|goto
name|yysetstate
goto|;
comment|/*------------------------------------------------------------. | yynewstate -- Push a new state, which is found in yystate.  | `------------------------------------------------------------*/
name|yynewstate
label|:
comment|/* In all cases, when you get here, the value and location stacks      have just been pushed. so pushing a state here evens the stacks.      */
name|yyssp
operator|++
expr_stmt|;
name|yysetstate
label|:
operator|*
name|yyssp
operator|=
name|yystate
expr_stmt|;
if|if
condition|(
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
operator|<=
name|yyssp
condition|)
block|{
comment|/* Get the current used size of the three stacks, in elements.  */
name|YYSIZE_T
name|yysize
init|=
name|yyssp
operator|-
name|yyss
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|yyoverflow
block|{
comment|/* Give user a chance to reallocate the stack. Use copies of 	   these so that the&'s don't force the real ones into 	   memory.  */
name|YYSTYPE
modifier|*
name|yyvs1
init|=
name|yyvs
decl_stmt|;
name|short
name|int
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
comment|/* Each stack pointer address is followed by the size of the 	   data in use in that stack, in bytes.  This used to be a 	   conditional around just the two extra args, but that might 	   be undefined if yyoverflow is a macro.  */
name|yyoverflow
argument_list|(
name|YY_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
operator|&
name|yyss1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
operator|&
name|yystacksize
argument_list|)
expr_stmt|;
name|yyss
operator|=
name|yyss1
expr_stmt|;
name|yyvs
operator|=
name|yyvs1
expr_stmt|;
block|}
else|#
directive|else
comment|/* no yyoverflow */
ifndef|#
directive|ifndef
name|YYSTACK_RELOCATE
goto|goto
name|yyexhaustedlab
goto|;
else|#
directive|else
comment|/* Extend the stack our own way.  */
if|if
condition|(
name|YYMAXDEPTH
operator|<=
name|yystacksize
condition|)
goto|goto
name|yyexhaustedlab
goto|;
name|yystacksize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|YYMAXDEPTH
operator|<
name|yystacksize
condition|)
name|yystacksize
operator|=
name|YYMAXDEPTH
expr_stmt|;
block|{
name|short
name|int
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
name|union
name|yyalloc
modifier|*
name|yyptr
init|=
operator|(
expr|union
name|yyalloc
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|YYSTACK_BYTES
argument_list|(
name|yystacksize
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|yyptr
condition|)
goto|goto
name|yyexhaustedlab
goto|;
name|YYSTACK_RELOCATE
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
name|YYSTACK_RELOCATE
argument_list|(
name|yyvs
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|YYSTACK_RELOCATE
if|if
condition|(
name|yyss1
operator|!=
name|yyssa
condition|)
name|YYSTACK_FREE
argument_list|(
name|yyss1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* no yyoverflow */
name|yyssp
operator|=
name|yyss
operator|+
name|yysize
operator|-
literal|1
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
operator|+
name|yysize
operator|-
literal|1
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Stack size increased to %lu\n"
operator|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|yystacksize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
operator|<=
name|yyssp
condition|)
name|YYABORT
expr_stmt|;
block|}
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Entering state %d\n"
operator|,
name|yystate
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|yybackup
goto|;
comment|/*-----------. | yybackup.  | `-----------*/
name|yybackup
label|:
comment|/* Do appropriate processing given the current state.  */
comment|/* Read a look-ahead token if we need one and don't already have one.  */
comment|/* yyresume: */
comment|/* First try to decide what to do without reference to look-ahead token.  */
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYPACT_NINF
condition|)
goto|goto
name|yydefault
goto|;
comment|/* Not known => get a look-ahead token if don't already have one.  */
comment|/* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
block|{
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Reading a token: "
operator|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYLEX
expr_stmt|;
block|}
if|if
condition|(
name|yychar
operator|<=
name|YYEOF
condition|)
block|{
name|yychar
operator|=
name|yytoken
operator|=
name|YYEOF
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Now at end of input.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yytoken
operator|=
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
name|YY_SYMBOL_PRINT
argument_list|(
literal|"Next token is"
argument_list|,
name|yytoken
argument_list|,
operator|&
name|yylval
argument_list|,
operator|&
name|yylloc
argument_list|)
expr_stmt|;
block|}
comment|/* If the proper action on seeing token YYTOKEN is to reduce or to      detect an error, take that action.  */
name|yyn
operator|+=
name|yytoken
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|YYLAST
operator|<
name|yyn
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|yytoken
condition|)
goto|goto
name|yydefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
literal|0
operator|||
name|yyn
operator|==
name|YYTABLE_NINF
condition|)
goto|goto
name|yyerrlab
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
comment|/* Shift the look-ahead token.  */
name|YY_SYMBOL_PRINT
argument_list|(
literal|"Shifting"
argument_list|,
name|yytoken
argument_list|,
operator|&
name|yylval
argument_list|,
operator|&
name|yylloc
argument_list|)
expr_stmt|;
comment|/* Discard the token being shifted unless it is eof.  */
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
condition|)
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
comment|/* Count tokens shifted since error; after three, turn off error      status.  */
if|if
condition|(
name|yyerrstatus
condition|)
name|yyerrstatus
operator|--
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-----------------------------------------------------------. | yydefault -- do the default action for the current state.  | `-----------------------------------------------------------*/
name|yydefault
label|:
name|yyn
operator|=
name|yydefact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
goto|goto
name|yyreduce
goto|;
comment|/*-----------------------------. | yyreduce -- Do a reduction.  | `-----------------------------*/
name|yyreduce
label|:
comment|/* yyn is the number of a rule to reduce with.  */
name|yylen
operator|=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
comment|/* If YYLEN is nonzero, implement the default value of the action:      `$$ = $1'.       Otherwise, the following line sets YYVAL to garbage.      This behavior is undocumented and Bison      users should not rely upon it.  Assigning to YYVAL      unconditionally makes the parser a bit smaller, and it avoids a      GCC warning that YYVAL may be used uninitialized.  */
name|yyval
operator|=
name|yyvsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
name|YY_REDUCE_PRINT
argument_list|(
name|yyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|3
case|:
line|#
directive|line
number|123
file|"m68k-parse.y"
block|{
name|op
operator|->
name|trailing_ampersand
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|trailing_ampersand
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
line|#
directive|line
number|127
file|"m68k-parse.y"
block|{
name|op
operator|->
name|trailing_ampersand
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|trailing_ampersand
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
line|#
directive|line
number|135
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|trailing_ampersand
operator|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|137
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|trailing_ampersand
operator|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|144
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|LSH
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|149
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|RSH
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
line|#
directive|line
number|154
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|DREG
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
line|#
directive|line
number|159
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|AREG
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|164
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|FPREG
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
line|#
directive|line
number|169
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|CONTROL
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
line|#
directive|line
number|174
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|CONTROL
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|14
case|:
line|#
directive|line
number|179
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|ABSL
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
line|#
directive|line
number|184
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|IMMED
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|189
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|IMMED
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|194
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
name|op
operator|->
name|mask
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|mask
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
line|#
directive|line
number|207
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|AINDR
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|212
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|AINC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|217
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|ADEC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|21
case|:
line|#
directive|line
number|222
file|"m68k-parse.y"
block|{
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|exp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|>=
name|ZADDR0
operator|&&
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|<=
name|ZADDR7
operator|)
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
else|else
name|op
operator|->
name|mode
operator|=
name|DISP
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
line|#
directive|line
number|232
file|"m68k-parse.y"
block|{
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|>=
name|ZADDR0
operator|&&
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|<=
name|ZADDR7
operator|)
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
else|else
name|op
operator|->
name|mode
operator|=
name|DISP
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|242
file|"m68k-parse.y"
block|{
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|exp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|>=
name|ZADDR0
operator|&&
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|<=
name|ZADDR7
operator|)
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
else|else
name|op
operator|->
name|mode
operator|=
name|DISP
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
line|#
directive|line
number|252
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|DISP
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|25
case|:
line|#
directive|line
number|257
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|262
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|27
case|:
line|#
directive|line
number|267
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|28
case|:
line|#
directive|line
number|274
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|PC
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|29
case|:
line|#
directive|line
number|285
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|30
case|:
line|#
directive|line
number|292
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|31
case|:
line|#
directive|line
number|298
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
line|#
directive|line
number|305
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|33
case|:
line|#
directive|line
number|311
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|PC
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|34
case|:
line|#
directive|line
number|322
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|PC
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|35
case|:
line|#
directive|line
number|332
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
line|#
directive|line
number|339
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
line|#
directive|line
number|345
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|6
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|38
case|:
line|#
directive|line
number|353
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|39
case|:
line|#
directive|line
number|360
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
line|#
directive|line
number|367
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|41
case|:
line|#
directive|line
number|373
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|7
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|42
case|:
line|#
directive|line
number|381
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|43
case|:
line|#
directive|line
number|388
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
operator|==
name|PC
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|7
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|44
case|:
line|#
directive|line
number|400
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
operator|==
name|PC
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
name|op
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|45
case|:
line|#
directive|line
number|411
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|46
case|:
line|#
directive|line
number|424
file|"m68k-parse.y"
block|{
comment|/* We use optzapc to avoid a shift/reduce conflict.  */
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|<
name|ADDR0
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
operator|>
name|ADDR7
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|AINDR
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|47
case|:
line|#
directive|line
number|432
file|"m68k-parse.y"
block|{
comment|/* We use optzapc to avoid a shift/reduce conflict.  */
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
operator|<
name|ADDR0
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
operator|>
name|ADDR7
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|AINC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|48
case|:
line|#
directive|line
number|440
file|"m68k-parse.y"
block|{
comment|/* We use optzapc to avoid a shift/reduce conflict.  */
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
operator|<
name|ADDR0
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
operator|>
name|ADDR7
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|ADEC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|49
case|:
line|#
directive|line
number|448
file|"m68k-parse.y"
block|{
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|reg
operator|)
operator|>=
name|ZADDR0
operator|&&
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|reg
operator|)
operator|<=
name|ZADDR7
operator|)
operator|||
operator|(
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|reg
operator|)
operator|==
name|ZPC
condition|)
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
else|else
name|op
operator|->
name|mode
operator|=
name|DISP
expr_stmt|;
block|}
break|break;
case|case
literal|50
case|:
line|#
directive|line
number|458
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|BASE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|51
case|:
line|#
directive|line
number|465
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|9
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|6
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|52
case|:
line|#
directive|line
number|473
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|POST
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|8
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|53
case|:
line|#
directive|line
number|480
file|"m68k-parse.y"
block|{
name|op
operator|->
name|mode
operator|=
name|PRE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|9
index|]
operator|.
name|reg
operator|)
expr_stmt|;
name|op
operator|->
name|disp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|6
index|]
operator|.
name|exp
operator|)
expr_stmt|;
name|op
operator|->
name|index
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|indexreg
operator|)
expr_stmt|;
name|op
operator|->
name|odisp
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|55
case|:
line|#
directive|line
number|495
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|57
case|:
line|#
directive|line
number|509
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|reg
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
operator|(
name|yyval
operator|.
name|indexreg
operator|)
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|68
case|:
line|#
directive|line
number|552
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|reg
operator|)
operator|=
name|ZADDR0
expr_stmt|;
block|}
break|break;
case|case
literal|72
case|:
line|#
directive|line
number|569
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|reg
operator|)
operator|=
name|ZADDR0
expr_stmt|;
block|}
break|break;
case|case
literal|73
case|:
line|#
directive|line
number|573
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|reg
operator|)
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|74
case|:
line|#
directive|line
number|582
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
block|}
break|break;
case|case
literal|75
case|:
line|#
directive|line
number|587
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|76
case|:
line|#
directive|line
number|596
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
block|}
break|break;
case|case
literal|77
case|:
line|#
directive|line
number|601
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|exp
operator|)
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|exp
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|79
case|:
line|#
directive|line
number|611
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|mask
operator|)
operator||
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|mask
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|80
case|:
line|#
directive|line
number|615
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
literal|1
operator|<<
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|onereg
operator|)
operator|)
operator||
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|mask
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|81
case|:
line|#
directive|line
number|627
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
literal|1
operator|<<
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|onereg
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|83
case|:
line|#
directive|line
number|632
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|mask
operator|)
operator||
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|mask
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|84
case|:
line|#
directive|line
number|636
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
literal|1
operator|<<
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|onereg
operator|)
operator|)
operator||
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|mask
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|85
case|:
line|#
directive|line
number|643
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|onereg
operator|)
operator|<=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|onereg
operator|)
condition|)
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|onereg
operator|)
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|-
operator|(
operator|(
literal|1
operator|<<
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|onereg
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
else|else
operator|(
name|yyval
operator|.
name|mask
operator|)
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|onereg
operator|)
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|-
operator|(
operator|(
literal|1
operator|<<
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|onereg
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|86
case|:
line|#
directive|line
number|653
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|-
name|DATA0
expr_stmt|;
block|}
break|break;
case|case
literal|87
case|:
line|#
directive|line
number|657
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|-
name|ADDR0
operator|+
literal|8
expr_stmt|;
block|}
break|break;
case|case
literal|88
case|:
line|#
directive|line
number|661
file|"m68k-parse.y"
block|{
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|-
name|FP0
operator|+
literal|16
expr_stmt|;
block|}
break|break;
case|case
literal|89
case|:
line|#
directive|line
number|665
file|"m68k-parse.y"
block|{
if|if
condition|(
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|==
name|FPI
condition|)
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|==
name|FPS
condition|)
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
literal|25
expr_stmt|;
else|else
operator|(
name|yyval
operator|.
name|onereg
operator|)
operator|=
literal|26
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Line 1126 of yacc.c.  */
line|#
directive|line
number|1986
file|"m68k-parse.c"
name|yyvsp
operator|-=
name|yylen
expr_stmt|;
name|yyssp
operator|-=
name|yylen
expr_stmt|;
name|YY_STACK_PRINT
argument_list|(
name|yyss
argument_list|,
name|yyssp
argument_list|)
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
comment|/* Now `shift' the result of the reduction.  Determine what state      that goes to, based on the state we popped back to and the rule      number reduced by.  */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yystate
operator|=
name|yypgoto
index|[
name|yyn
operator|-
name|YYNTOKENS
index|]
operator|+
operator|*
name|yyssp
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|yystate
operator|&&
name|yystate
operator|<=
name|YYLAST
operator|&&
name|yycheck
index|[
name|yystate
index|]
operator|==
operator|*
name|yyssp
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yystate
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydefgoto
index|[
name|yyn
operator|-
name|YYNTOKENS
index|]
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*------------------------------------. | yyerrlab -- here on detecting error | `------------------------------------*/
name|yyerrlab
label|:
comment|/* If not already recovering from an error, report this error.  */
if|if
condition|(
operator|!
name|yyerrstatus
condition|)
block|{
operator|++
name|yynerrs
expr_stmt|;
if|#
directive|if
name|YYERROR_VERBOSE
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|YYPACT_NINF
operator|<
name|yyn
operator|&&
name|yyn
operator|<
name|YYLAST
condition|)
block|{
name|int
name|yytype
init|=
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
decl_stmt|;
name|YYSIZE_T
name|yysize0
init|=
name|yytnamerr
argument_list|(
literal|0
argument_list|,
name|yytname
index|[
name|yytype
index|]
argument_list|)
decl_stmt|;
name|YYSIZE_T
name|yysize
init|=
name|yysize0
decl_stmt|;
name|YYSIZE_T
name|yysize1
decl_stmt|;
name|int
name|yysize_overflow
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|yymsg
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|YYERROR_VERBOSE_ARGS_MAXIMUM
value|5
name|char
specifier|const
modifier|*
name|yyarg
index|[
name|YYERROR_VERBOSE_ARGS_MAXIMUM
index|]
decl_stmt|;
name|int
name|yyx
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is so xgettext sees the translatable formats that are 	     constructed on the fly.  */
block|YY_("syntax error, unexpected %s"); 	  YY_("syntax error, unexpected %s, expecting %s"); 	  YY_("syntax error, unexpected %s, expecting %s or %s"); 	  YY_("syntax error, unexpected %s, expecting %s or %s or %s"); 	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
endif|#
directive|endif
name|char
modifier|*
name|yyfmt
decl_stmt|;
name|char
specifier|const
modifier|*
name|yyf
decl_stmt|;
specifier|static
name|char
specifier|const
name|yyunexpected
index|[]
init|=
literal|"syntax error, unexpected %s"
decl_stmt|;
specifier|static
name|char
specifier|const
name|yyexpecting
index|[]
init|=
literal|", expecting %s"
decl_stmt|;
specifier|static
name|char
specifier|const
name|yyor
index|[]
init|=
literal|" or %s"
decl_stmt|;
name|char
name|yyformat
index|[
sizeof|sizeof
name|yyunexpected
operator|+
sizeof|sizeof
name|yyexpecting
operator|-
literal|1
operator|+
operator|(
operator|(
name|YYERROR_VERBOSE_ARGS_MAXIMUM
operator|-
literal|2
operator|)
operator|*
operator|(
sizeof|sizeof
name|yyor
operator|-
literal|1
operator|)
operator|)
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|yyprefix
init|=
name|yyexpecting
decl_stmt|;
comment|/* Start YYX at -YYN if negative to avoid negative indexes in 	     YYCHECK.  */
name|int
name|yyxbegin
init|=
name|yyn
operator|<
literal|0
condition|?
operator|-
name|yyn
else|:
literal|0
decl_stmt|;
comment|/* Stay within bounds of both yycheck and yytname.  */
name|int
name|yychecklim
init|=
name|YYLAST
operator|-
name|yyn
decl_stmt|;
name|int
name|yyxend
init|=
name|yychecklim
operator|<
name|YYNTOKENS
condition|?
name|yychecklim
else|:
name|YYNTOKENS
decl_stmt|;
name|int
name|yycount
init|=
literal|1
decl_stmt|;
name|yyarg
index|[
literal|0
index|]
operator|=
name|yytname
index|[
name|yytype
index|]
expr_stmt|;
name|yyfmt
operator|=
name|yystpcpy
argument_list|(
name|yyformat
argument_list|,
name|yyunexpected
argument_list|)
expr_stmt|;
for|for
control|(
name|yyx
operator|=
name|yyxbegin
init|;
name|yyx
operator|<
name|yyxend
condition|;
operator|++
name|yyx
control|)
if|if
condition|(
name|yycheck
index|[
name|yyx
operator|+
name|yyn
index|]
operator|==
name|yyx
operator|&&
name|yyx
operator|!=
name|YYTERROR
condition|)
block|{
if|if
condition|(
name|yycount
operator|==
name|YYERROR_VERBOSE_ARGS_MAXIMUM
condition|)
block|{
name|yycount
operator|=
literal|1
expr_stmt|;
name|yysize
operator|=
name|yysize0
expr_stmt|;
name|yyformat
index|[
sizeof|sizeof
name|yyunexpected
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|yyarg
index|[
name|yycount
operator|++
index|]
operator|=
name|yytname
index|[
name|yyx
index|]
expr_stmt|;
name|yysize1
operator|=
name|yysize
operator|+
name|yytnamerr
argument_list|(
literal|0
argument_list|,
name|yytname
index|[
name|yyx
index|]
argument_list|)
expr_stmt|;
name|yysize_overflow
operator||=
name|yysize1
operator|<
name|yysize
expr_stmt|;
name|yysize
operator|=
name|yysize1
expr_stmt|;
name|yyfmt
operator|=
name|yystpcpy
argument_list|(
name|yyfmt
argument_list|,
name|yyprefix
argument_list|)
expr_stmt|;
name|yyprefix
operator|=
name|yyor
expr_stmt|;
block|}
name|yyf
operator|=
name|YY_
argument_list|(
name|yyformat
argument_list|)
expr_stmt|;
name|yysize1
operator|=
name|yysize
operator|+
name|yystrlen
argument_list|(
name|yyf
argument_list|)
expr_stmt|;
name|yysize_overflow
operator||=
name|yysize1
operator|<
name|yysize
expr_stmt|;
name|yysize
operator|=
name|yysize1
expr_stmt|;
if|if
condition|(
operator|!
name|yysize_overflow
operator|&&
name|yysize
operator|<=
name|YYSTACK_ALLOC_MAXIMUM
condition|)
name|yymsg
operator|=
operator|(
name|char
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|yysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymsg
condition|)
block|{
comment|/* Avoid sprintf, as that infringes on the user's name space. 		 Don't have undefined behavior even if the translation 		 produced a string with the wrong number of "%s"s.  */
name|char
modifier|*
name|yyp
init|=
name|yymsg
decl_stmt|;
name|int
name|yyi
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|yyp
operator|=
operator|*
name|yyf
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|yyp
operator|==
literal|'%'
operator|&&
name|yyf
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|yyi
operator|<
name|yycount
condition|)
block|{
name|yyp
operator|+=
name|yytnamerr
argument_list|(
name|yyp
argument_list|,
name|yyarg
index|[
name|yyi
operator|++
index|]
argument_list|)
expr_stmt|;
name|yyf
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|yyp
operator|++
expr_stmt|;
name|yyf
operator|++
expr_stmt|;
block|}
block|}
name|yyerror
argument_list|(
name|yymsg
argument_list|)
expr_stmt|;
name|YYSTACK_FREE
argument_list|(
name|yymsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
name|YY_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|yyexhaustedlab
goto|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* YYERROR_VERBOSE */
name|yyerror
argument_list|(
name|YY_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyerrstatus
operator|==
literal|3
condition|)
block|{
comment|/* If just tried and failed to reuse look-ahead token after an 	 error, discard it.  */
if|if
condition|(
name|yychar
operator|<=
name|YYEOF
condition|)
block|{
comment|/* Return failure if at end of input.  */
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
name|YYABORT
expr_stmt|;
block|}
else|else
block|{
name|yydestruct
argument_list|(
literal|"Error: discarding"
argument_list|,
name|yytoken
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
block|}
comment|/* Else will try to reuse look-ahead token after shifting the error      token.  */
goto|goto
name|yyerrlab1
goto|;
comment|/*---------------------------------------------------. | yyerrorlab -- error raised explicitly by YYERROR.  | `---------------------------------------------------*/
name|yyerrorlab
label|:
comment|/* Pacify compilers like GCC when the user code never invokes      YYERROR and the label yyerrorlab therefore never appears in user      code.  */
if|if
condition|(
literal|0
condition|)
goto|goto
name|yyerrorlab
goto|;
name|yyvsp
operator|-=
name|yylen
expr_stmt|;
name|yyssp
operator|-=
name|yylen
expr_stmt|;
name|yystate
operator|=
operator|*
name|yyssp
expr_stmt|;
goto|goto
name|yyerrlab1
goto|;
comment|/*-------------------------------------------------------------. | yyerrlab1 -- common code for both syntax error and YYERROR.  | `-------------------------------------------------------------*/
name|yyerrlab1
label|:
name|yyerrstatus
operator|=
literal|3
expr_stmt|;
comment|/* Each real token shifted decrements this.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|!=
name|YYPACT_NINF
condition|)
block|{
name|yyn
operator|+=
name|YYTERROR
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|yyn
operator|&&
name|yyn
operator|<=
name|YYLAST
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|YYTERROR
condition|)
block|{
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|yyn
condition|)
break|break;
block|}
block|}
comment|/* Pop the current state because it cannot handle the error token.  */
if|if
condition|(
name|yyssp
operator|==
name|yyss
condition|)
name|YYABORT
expr_stmt|;
name|yydestruct
argument_list|(
literal|"Error: popping"
argument_list|,
name|yystos
index|[
name|yystate
index|]
argument_list|,
name|yyvsp
argument_list|)
expr_stmt|;
name|YYPOPSTACK
expr_stmt|;
name|yystate
operator|=
operator|*
name|yyssp
expr_stmt|;
name|YY_STACK_PRINT
argument_list|(
name|yyss
argument_list|,
name|yyssp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
comment|/* Shift the error token. */
name|YY_SYMBOL_PRINT
argument_list|(
literal|"Shifting"
argument_list|,
name|yystos
index|[
name|yyn
index|]
argument_list|,
name|yyvsp
argument_list|,
name|yylsp
argument_list|)
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-------------------------------------. | yyacceptlab -- YYACCEPT comes here.  | `-------------------------------------*/
name|yyacceptlab
label|:
name|yyresult
operator|=
literal|0
expr_stmt|;
goto|goto
name|yyreturn
goto|;
comment|/*-----------------------------------. | yyabortlab -- YYABORT comes here.  | `-----------------------------------*/
name|yyabortlab
label|:
name|yyresult
operator|=
literal|1
expr_stmt|;
goto|goto
name|yyreturn
goto|;
ifndef|#
directive|ifndef
name|yyoverflow
comment|/*-------------------------------------------------. | yyexhaustedlab -- memory exhaustion comes here.  | `-------------------------------------------------*/
name|yyexhaustedlab
label|:
name|yyerror
argument_list|(
name|YY_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|yyresult
operator|=
literal|2
expr_stmt|;
comment|/* Fall through.  */
endif|#
directive|endif
name|yyreturn
label|:
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
operator|&&
name|yychar
operator|!=
name|YYEMPTY
condition|)
name|yydestruct
argument_list|(
literal|"Cleanup: discarding lookahead"
argument_list|,
name|yytoken
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
while|while
condition|(
name|yyssp
operator|!=
name|yyss
condition|)
block|{
name|yydestruct
argument_list|(
literal|"Cleanup: popping"
argument_list|,
name|yystos
index|[
operator|*
name|yyssp
index|]
argument_list|,
name|yyvsp
argument_list|)
expr_stmt|;
name|YYPOPSTACK
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|yyoverflow
if|if
condition|(
name|yyss
operator|!=
name|yyssa
condition|)
name|YYSTACK_FREE
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|yyresult
return|;
block|}
end_block

begin_line
line|#
directive|line
number|675
file|"m68k-parse.y"
end_line

begin_comment
comment|/* The string to parse is stored here, and modified by yylex.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The original string pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strorig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If *CCP could be a register, return the register number and advance    *CCP.  Otherwise don't change *CCP, and return 0.  */
end_comment

begin_function
specifier|static
name|enum
name|m68k_register
name|m68k_reg_parse
parameter_list|(
name|ccp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ccp
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbolp
decl_stmt|;
if|if
condition|(
name|flag_reg_prefix_optional
condition|)
block|{
if|if
condition|(
operator|*
name|start
operator|==
name|REGISTER_PREFIX
condition|)
name|start
operator|++
expr_stmt|;
name|p
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|start
operator|!=
name|REGISTER_PREFIX
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|start
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolp
operator|=
name|symbol_find
argument_list|(
name|start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|symbolp
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolp
argument_list|)
operator|==
name|reg_section
condition|)
block|{
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|S_GET_VALUE
argument_list|(
name|symbolp
argument_list|)
return|;
block|}
comment|/* In MRI mode, something like foo.bar can be equated to a register      name.  */
while|while
condition|(
name|flag_mri
operator|&&
name|c
operator|==
literal|'.'
condition|)
block|{
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|symbolp
operator|=
name|symbol_find
argument_list|(
name|start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|symbolp
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolp
argument_list|)
operator|==
name|reg_section
condition|)
block|{
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|S_GET_VALUE
argument_list|(
name|symbolp
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The lexer.  */
end_comment

begin_function
specifier|static
name|int
name|yylex
parameter_list|()
block|{
name|enum
name|m68k_register
name|reg
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|parens
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|tail
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Various special characters are just returned directly.  */
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'@'
case|:
comment|/* In MRI mode, this can be the start of an octal number.  */
if|if
condition|(
name|flag_mri
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|str
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|','
case|:
case|case
literal|')'
case|:
case|case
literal|'/'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
return|return
operator|*
name|str
operator|++
return|;
case|case
literal|'+'
case|:
comment|/* It so happens that a '+' can only appear at the end of an 	 operand, or if it is trailed by an '&'(see mac load insn). 	 If it appears anywhere else, it must be a unary.  */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'&'
operator|&&
name|str
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|*
name|str
operator|++
return|;
break|break;
case|case
literal|'-'
case|:
comment|/* A '-' can only appear in -(ar), rn-rn, or ar@-.  If it          appears anywhere else, it must be a unary minus on an          expression, unless it it trailed by a '&'(see mac load insn).  */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'&'
operator|&&
name|str
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|*
name|str
operator|++
return|;
name|s
operator|=
name|str
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|m68k_reg_parse
argument_list|(
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|*
name|str
operator|++
return|;
break|break;
case|case
literal|'('
case|:
comment|/* A '(' can only appear in `(reg)', `(expr,...', `([', `@(', or          `)('.  If it appears anywhere else, it must be starting an          expression.  */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'['
operator|||
operator|(
name|str
operator|>
name|strorig
operator|&&
operator|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|'@'
operator|||
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
condition|)
return|return
operator|*
name|str
operator|++
return|;
name|s
operator|=
name|str
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|m68k_reg_parse
argument_list|(
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|*
name|str
operator|++
return|;
comment|/* Check for the case of '(expr,...' by scanning ahead.  If we          find a comma outside of balanced parentheses, we return '('.          If we find an unbalanced right parenthesis, then presumably          the '(' really starts an expression.  */
name|parens
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
operator|+
literal|1
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
operator|++
name|parens
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|parens
operator|==
literal|0
condition|)
break|break;
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|parens
operator|==
literal|0
condition|)
block|{
comment|/* A comma can not normally appear in an expression, so 		 this is a case of '(expr,...'.  */
return|return
operator|*
name|str
operator|++
return|;
block|}
block|}
block|}
comment|/* See if it's a register.  */
name|reg
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|yylval
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|DATA0
operator|&&
name|reg
operator|<=
name|DATA7
condition|)
name|ret
operator|=
name|DR
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
name|ADDR0
operator|&&
name|reg
operator|<=
name|ADDR7
condition|)
name|ret
operator|=
name|AR
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
name|FP0
operator|&&
name|reg
operator|<=
name|FP7
condition|)
return|return
name|FPR
return|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|FPI
operator|||
name|reg
operator|==
name|FPS
operator|||
name|reg
operator|==
name|FPC
condition|)
return|return
name|FPCR
return|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
return|return
name|LPC
return|;
elseif|else
if|if
condition|(
name|reg
operator|>=
name|ZDATA0
operator|&&
name|reg
operator|<=
name|ZDATA7
condition|)
name|ret
operator|=
name|ZDR
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
name|ZADDR0
operator|&&
name|reg
operator|<=
name|ZADDR7
condition|)
name|ret
operator|=
name|ZAR
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|ZPC
condition|)
return|return
name|LZPC
return|;
else|else
return|return
name|CREG
return|;
comment|/* If we get here, we have a data or address register.  We 	 must check for a size or scale; if we find one, we must 	 return INDEXREG.  */
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|&&
operator|*
name|s
operator|!=
literal|'*'
condition|)
return|return
name|ret
return|;
name|yylval
operator|.
name|indexreg
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
name|yylval
operator|.
name|indexreg
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
else|else
block|{
operator|++
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|yylval
operator|.
name|indexreg
operator|.
name|size
operator|=
name|SIZE_WORD
expr_stmt|;
operator|++
name|s
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|yylval
operator|.
name|indexreg
operator|.
name|size
operator|=
name|SIZE_LONG
expr_stmt|;
operator|++
name|s
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"illegal size specification"
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|indexreg
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
break|break;
block|}
block|}
name|yylval
operator|.
name|indexreg
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|expressionS
name|scale
decl_stmt|;
operator|++
name|s
expr_stmt|;
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|scale
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|scale
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"scale specification must resolve to a number"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|scale
operator|.
name|X_add_number
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
name|yylval
operator|.
name|indexreg
operator|.
name|scale
operator|=
name|scale
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
name|_
argument_list|(
literal|"invalid scale value"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|str
operator|=
name|s
expr_stmt|;
return|return
name|INDEXREG
return|;
block|}
comment|/* It must be an expression.  Before we call expression, we need to      look ahead to see if there is a size specification.  We must do      that first, because otherwise foo.l will be treated as the symbol      foo.l, rather than as the symbol foo with a long size      specification.  The grammar requires that all expressions end at      the end of the operand, or with ',', '(', ']', ')'.  */
name|parens
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|parens
operator|==
literal|0
operator|&&
name|s
operator|>
name|str
operator|&&
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
operator|||
name|ISALNUM
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
break|break;
operator|++
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|parens
operator|==
literal|0
condition|)
break|break;
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parens
operator|==
literal|0
operator|&&
operator|(
operator|*
name|s
operator|==
literal|','
operator|||
operator|*
name|s
operator|==
literal|']'
operator|)
condition|)
break|break;
block|}
name|yylval
operator|.
name|exp
operator|.
name|size
operator|=
name|SIZE_UNSPEC
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|str
operator|+
literal|2
operator|||
operator|(
name|s
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
operator|&&
name|s
index|[
operator|-
literal|2
index|]
operator|!=
literal|':'
operator|)
condition|)
name|tail
operator|=
literal|0
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|s
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|yylval
operator|.
name|exp
operator|.
name|size
operator|=
name|SIZE_BYTE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|yylval
operator|.
name|exp
operator|.
name|size
operator|=
name|SIZE_WORD
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|yylval
operator|.
name|exp
operator|.
name|size
operator|=
name|SIZE_LONG
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|yylval
operator|.
name|exp
operator|.
name|size
operator|!=
name|SIZE_UNSPEC
condition|)
name|tail
operator|=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
comment|/* Look for @PLTPC, etc.  */
name|char
modifier|*
name|cp
decl_stmt|;
name|yylval
operator|.
name|exp
operator|.
name|pic_reloc
operator|=
name|pic_none
expr_stmt|;
name|cp
operator|=
name|s
operator|-
name|tail
expr_stmt|;
if|if
condition|(
name|cp
operator|-
literal|6
operator|>
name|str
operator|&&
name|cp
index|[
operator|-
literal|6
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|-
literal|6
argument_list|,
literal|"@PLTPC"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|exp
operator|.
name|pic_reloc
operator|=
name|pic_plt_pcrel
expr_stmt|;
name|tail
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|-
literal|6
argument_list|,
literal|"@GOTPC"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|exp
operator|.
name|pic_reloc
operator|=
name|pic_got_pcrel
expr_stmt|;
name|tail
operator|+=
literal|6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|-
literal|4
operator|>
name|str
operator|&&
name|cp
index|[
operator|-
literal|4
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|-
literal|4
argument_list|,
literal|"@PLT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|exp
operator|.
name|pic_reloc
operator|=
name|pic_plt_off
expr_stmt|;
name|tail
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|-
literal|4
argument_list|,
literal|"@GOT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|exp
operator|.
name|pic_reloc
operator|=
name|pic_got_off
expr_stmt|;
name|tail
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|s
index|[
operator|-
name|tail
index|]
expr_stmt|;
name|s
index|[
operator|-
name|tail
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|yylval
operator|.
name|exp
operator|.
name|exp
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
name|s
index|[
operator|-
name|tail
index|]
operator|=
name|c
expr_stmt|;
name|str
operator|=
name|s
expr_stmt|;
block|}
return|return
name|EXPR
return|;
block|}
end_function

begin_comment
comment|/* Parse an m68k operand.  This is the only function which is called    from outside this file.  */
end_comment

begin_function
name|int
name|m68k_ip_op
parameter_list|(
name|s
parameter_list|,
name|oparg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|m68k_op
modifier|*
name|oparg
decl_stmt|;
block|{
name|memset
argument_list|(
name|oparg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|oparg
argument_list|)
expr_stmt|;
name|oparg
operator|->
name|error
operator|=
name|NULL
expr_stmt|;
name|oparg
operator|->
name|index
operator|.
name|reg
operator|=
name|ZDATA0
expr_stmt|;
name|oparg
operator|->
name|index
operator|.
name|scale
operator|=
literal|1
expr_stmt|;
name|oparg
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|oparg
operator|->
name|odisp
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|str
operator|=
name|strorig
operator|=
name|s
expr_stmt|;
name|op
operator|=
name|oparg
expr_stmt|;
return|return
name|yyparse
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* The error handler.  */
end_comment

begin_function
specifier|static
name|void
name|yyerror
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|op
operator|->
name|error
operator|=
name|s
expr_stmt|;
block|}
end_function

end_unit

