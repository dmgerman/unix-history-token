begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ECOFF debugging support.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005    Free Software Foundation, Inc.    Contributed by Cygnus Support.    This file was put together by Ian Lance Taylor<ian@cygnus.com>.  A    good deal of it comes directly from mips-tfile.c, by Michael    Meissner<meissner@osf.org>.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* This file is compiled conditionally for those targets which use    ECOFF debugging information (e.g., MIPS ECOFF, MIPS ELF, Alpha    ECOFF).  */
end_comment

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ECOFF_DEBUGGING
end_ifdef

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/* Why isn't this in coff/sym.h?  */
end_comment

begin_define
define|#
directive|define
name|ST_RFDESCAPE
value|0xfff
end_define

begin_comment
comment|/* This file constructs the information used by the ECOFF debugging    format.  It just builds a large block of data.     We support both ECOFF style debugging and stabs debugging (the    stabs symbols are encapsulated in ECOFF symbols).  This should let    us handle anything the compiler might throw at us.  */
end_comment

begin_comment
comment|/* Here is a brief description of the MIPS ECOFF symbol table, by    Michael Meissner.  The MIPS symbol table has the following pieces:  	Symbolic Header 	    | 	    +--	Auxiliary Symbols 	    | 	    +--	Dense number table 	    | 	    +--	Optimizer Symbols 	    | 	    +--	External Strings 	    | 	    +--	External Symbols 	    | 	    +--	Relative file descriptors 	    | 	    +--	File table 		    | 		    +--	Procedure table 		    | 		    +--	Line number table 		    | 		    +--	Local Strings 		    | 		    +--	Local Symbols     The symbolic header points to each of the other tables, and also    contains the number of entries.  It also contains a magic number    and MIPS compiler version number, such as 2.0.     The auxiliary table is a series of 32 bit integers, that are    referenced as needed from the local symbol table.  Unlike standard    COFF, the aux.  information does not follow the symbol that uses    it, but rather is a separate table.  In theory, this would allow    the MIPS compilers to collapse duplicate aux. entries, but I've not    noticed this happening with the 1.31 compiler suite.  The different    types of aux. entries are:      1)	dnLow: Low bound on array dimension.      2)	dnHigh: High bound on array dimension.      3)	isym: Index to the local symbol which is the start of the 	function for the end of function first aux. entry.      4)	width: Width of structures and bitfields.      5)	count: Count of ranges for variant part.      6)	rndx: A relative index into the symbol table.  The relative 	index field has two parts: rfd which is a pointer into the 	relative file index table or ST_RFDESCAPE which says the next 	aux. entry is the file number, and index: which is the pointer 	into the local symbol within a given file table.  This is for 	things like references to types defined in another file.      7)	Type information: This is like the COFF type bits, except it 	is 32 bits instead of 16; they still have room to add new 	basic types; and they can handle more than 6 levels of array, 	pointer, function, etc.  Each type information field contains 	the following structure members:  	    a)	fBitfield: a bit that says this is a bitfield, and the 		size in bits follows as the next aux. entry.  	    b)	continued: a bit that says the next aux. entry is a 		continuation of the current type information (in case 		there are more than 6 levels of array/ptr/function).  	    c)	bt: an integer containing the base type before adding 		array, pointer, function, etc. qualifiers.  The 		current base types that I have documentation for are:  			btNil		-- undefined 			btAdr		-- address - integer same size as ptr 			btChar		-- character 			btUChar		-- unsigned character 			btShort		-- short 			btUShort	-- unsigned short 			btInt		-- int 			btUInt		-- unsigned int 			btLong		-- long 			btULong		-- unsigned long 			btFloat		-- float (real) 			btDouble	-- Double (real) 			btStruct	-- Structure (Record) 			btUnion		-- Union (variant) 			btEnum		-- Enumerated 			btTypedef	-- defined via a typedef isymRef 			btRange		-- subrange of int 			btSet		-- pascal sets 			btComplex	-- fortran complex 			btDComplex	-- fortran double complex 			btIndirect	-- forward or unnamed typedef 			btFixedDec	-- Fixed Decimal 			btFloatDec	-- Float Decimal 			btString	-- Varying Length Character String 			btBit		-- Aligned Bit String 			btPicture	-- Picture 			btVoid		-- Void (MIPS cc revision>= 2.00)  	    d)	tq0 - tq5: type qualifier fields as needed.  The 		current type qualifier fields I have documentation for 		are:  			tqNil		-- no more qualifiers 			tqPtr		-- pointer 			tqProc		-- procedure 			tqArray		-- array 			tqFar		-- 8086 far pointers 			tqVol		-- volatile     The dense number table is used in the front ends, and disappears by    the time the .o is created.     With the 1.31 compiler suite, the optimization symbols don't seem    to be used as far as I can tell.     The linker is the first entity that creates the relative file    descriptor table, and I believe it is used so that the individual    file table pointers don't have to be rewritten when the objects are    merged together into the program file.     Unlike COFF, the basic symbol& string tables are split into    external and local symbols/strings.  The relocation information    only goes off of the external symbol table, and the debug    information only goes off of the internal symbol table.  The    external symbols can have links to an appropriate file index and    symbol within the file to give it the appropriate type information.    Because of this, the external symbols are actually larger than the    internal symbols (to contain the link information), and contain the    local symbol structure as a member, though this member is not the    first member of the external symbol structure (!).  I suspect this    split is to make strip easier to deal with.     Each file table has offsets for where the line numbers, local    strings, local symbols, and procedure table starts from within the    global tables, and the indexs are reset to 0 for each of those    tables for the file.     The procedure table contains the binary equivalents of the .ent    (start of the function address), .frame (what register is the    virtual frame pointer, constant offset from the register to obtain    the VFP, and what register holds the return address), .mask/.fmask    (bitmask of saved registers, and where the first register is stored    relative to the VFP) assembler directives.  It also contains the    low and high bounds of the line numbers if debugging is turned on.     The line number table is a compressed form of the normal COFF line    table.  Each line number entry is either 1 or 3 bytes long, and    contains a signed delta from the previous line, and an unsigned    count of the number of instructions this statement takes.     The local symbol table contains the following fields:      1)	iss: index to the local string table giving the name of the 	symbol.      2)	value: value of the symbol (address, register number, etc.).      3)	st: symbol type.  The current symbol types are:  	    stNil	  -- Nuthin' special 	    stGlobal	  -- external symbol 	    stStatic	  -- static 	    stParam	  -- procedure argument 	    stLocal	  -- local variable 	    stLabel	  -- label 	    stProc	  -- External Procedure 	    stBlock	  -- beginning of block 	    stEnd	  -- end (of anything) 	    stMember	  -- member (of anything) 	    stTypedef	  -- type definition 	    stFile	  -- file name 	    stRegReloc	  -- register relocation 	    stForward	  -- forwarding address 	    stStaticProc  -- Static procedure 	    stConstant	  -- const      4)	sc: storage class.  The current storage classes are:  	    scText	  -- text symbol 	    scData	  -- initialized data symbol 	    scBss	  -- un-initialized data symbol 	    scRegister	  -- value of symbol is register number 	    scAbs	  -- value of symbol is absolute 	    scUndefined   -- who knows? 	    scCdbLocal	  -- variable's value is IN se->va.?? 	    scBits	  -- this is a bit field 	    scCdbSystem	  -- value is IN debugger's address space 	    scRegImage	  -- register value saved on stack 	    scInfo	  -- symbol contains debugger information 	    scUserStruct  -- addr in struct user for current process 	    scSData	  -- load time only small data 	    scSBss	  -- load time only small common 	    scRData	  -- load time only read only data 	    scVar	  -- Var parameter (fortranpascal) 	    scCommon	  -- common variable 	    scSCommon	  -- small common 	    scVarRegister -- Var parameter in a register 	    scVariant	  -- Variant record 	    scSUndefined  -- small undefined(external) data 	    scInit	  -- .init section symbol      5)	index: pointer to a local symbol or aux. entry.     For the following program:  	#include<stdio.h>  	main(){ 		printf("Hello World!\n"); 		return 0; 	}     Mips-tdump produces the following information:     Global file header:        magic number             0x162        # sections               2        timestamp                645311799, Wed Jun 13 17:16:39 1990        symbolic header offset   284        symbolic header size     96        optional header          56        flags                    0x0     Symbolic header, magic number = 0x7009, vstamp = 1.31:         Info                      Offset      Number       Bytes        ====                      ======      ======      =====         Line numbers                 380           4           4 [13]        Dense numbers                  0           0           0        Procedures Tables            384           1          52        Local Symbols                436          16         192        Optimization Symbols           0           0           0        Auxiliary Symbols            628          39         156        Local Strings                784          80          80        External Strings             864         144         144        File Tables                 1008           2         144        Relative Files                 0           0           0        External Symbols            1152          20         320     File #0, "hello2.c"         Name index  = 1          Readin      = No        Merge       = No         Endian      = LITTLE        Debug level = G2         Language    = C        Adr         = 0x00000000         Info                       Start      Number        Size      Offset        ====                       =====      ======        ====      ======        Local strings                  0          15          15         784        Local symbols                  0           6          72         436        Line numbers                   0          13          13         380        Optimization symbols           0           0           0           0        Procedures                     0           1          52         384        Auxiliary symbols              0          14          56         628        Relative Files                 0           0           0           0      There are 6 local symbols, starting at 436  	Symbol# 0: "hello2.c" 	    End+1 symbol  = 6 	    String index  = 1 	    Storage class = Text        Index  = 6 	    Symbol type   = File        Value  = 0  	Symbol# 1: "main" 	    End+1 symbol  = 5 	    Type          = int 	    String index  = 10 	    Storage class = Text        Index  = 12 	    Symbol type   = Proc        Value  = 0  	Symbol# 2: "" 	    End+1 symbol  = 4 	    String index  = 0 	    Storage class = Text        Index  = 4 	    Symbol type   = Block       Value  = 8  	Symbol# 3: "" 	    First symbol  = 2 	    String index  = 0 	    Storage class = Text        Index  = 2 	    Symbol type   = End         Value  = 28  	Symbol# 4: "main" 	    First symbol  = 1 	    String index  = 10 	    Storage class = Text        Index  = 1 	    Symbol type   = End         Value  = 52  	Symbol# 5: "hello2.c" 	    First symbol  = 0 	    String index  = 1 	    Storage class = Text        Index  = 0 	    Symbol type   = End         Value  = 0      There are 14 auxiliary table entries, starting at 628.  	* #0               0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #1              24, [  24/      0], [ 6 0:0 0:0:0:0:0:0] 	* #2               8, [   8/      0], [ 2 0:0 0:0:0:0:0:0] 	* #3              16, [  16/      0], [ 4 0:0 0:0:0:0:0:0] 	* #4              24, [  24/      0], [ 6 0:0 0:0:0:0:0:0] 	* #5              32, [  32/      0], [ 8 0:0 0:0:0:0:0:0] 	* #6              40, [  40/      0], [10 0:0 0:0:0:0:0:0] 	* #7              44, [  44/      0], [11 0:0 0:0:0:0:0:0] 	* #8              12, [  12/      0], [ 3 0:0 0:0:0:0:0:0] 	* #9              20, [  20/      0], [ 5 0:0 0:0:0:0:0:0] 	* #10             28, [  28/      0], [ 7 0:0 0:0:0:0:0:0] 	* #11             36, [  36/      0], [ 9 0:0 0:0:0:0:0:0] 	  #12              5, [   5/      0], [ 1 1:0 0:0:0:0:0:0] 	  #13             24, [  24/      0], [ 6 0:0 0:0:0:0:0:0]      There are 1 procedure descriptor entries, starting at 0.  	Procedure descriptor 0: 	    Name index   = 10          Name          = "main" 	    .mask 0x80000000,-4        .fmask 0x00000000,0 	    .frame $29,24,$31 	    Opt. start   = -1          Symbols start = 1 	    First line # = 3           Last line #   = 6 	    Line Offset  = 0           Address       = 0x00000000  	There are 4 bytes holding line numbers, starting at 380. 	    Line           3,   delta     0,   count  2 	    Line           4,   delta     1,   count  3 	    Line           5,   delta     1,   count  2 	    Line           6,   delta     1,   count  6     File #1, "/usr/include/stdio.h"      Name index  = 1          Readin      = No     Merge       = Yes        Endian      = LITTLE     Debug level = G2         Language    = C     Adr         = 0x00000000      Info                       Start      Number        Size      Offset     ====                       =====      ======        ====      ======     Local strings                 15          65          65         799     Local symbols                  6          10         120         508     Line numbers                   0           0           0         380     Optimization symbols           0           0           0           0     Procedures                     1           0           0         436     Auxiliary symbols             14          25         100         684     Relative Files                 0           0           0           0      There are 10 local symbols, starting at 442  	Symbol# 0: "/usr/include/stdio.h" 	    End+1 symbol  = 10 	    String index  = 1 	    Storage class = Text        Index  = 10 	    Symbol type   = File        Value  = 0  	Symbol# 1: "_iobuf" 	    End+1 symbol  = 9 	    String index  = 22 	    Storage class = Info        Index  = 9 	    Symbol type   = Block       Value  = 20  	Symbol# 2: "_cnt" 	    Type          = int 	    String index  = 29 	    Storage class = Info        Index  = 4 	    Symbol type   = Member      Value  = 0  	Symbol# 3: "_ptr" 	    Type          = ptr to char 	    String index  = 34 	    Storage class = Info        Index  = 15 	    Symbol type   = Member      Value  = 32  	Symbol# 4: "_base" 	    Type          = ptr to char 	    String index  = 39 	    Storage class = Info        Index  = 16 	    Symbol type   = Member      Value  = 64  	Symbol# 5: "_bufsiz" 	    Type          = int 	    String index  = 45 	    Storage class = Info        Index  = 4 	    Symbol type   = Member      Value  = 96  	Symbol# 6: "_flag" 	    Type          = short 	    String index  = 53 	    Storage class = Info        Index  = 3 	    Symbol type   = Member      Value  = 128  	Symbol# 7: "_file" 	    Type          = char 	    String index  = 59 	    Storage class = Info        Index  = 2 	    Symbol type   = Member      Value  = 144  	Symbol# 8: "" 	    First symbol  = 1 	    String index  = 0 	    Storage class = Info        Index  = 1 	    Symbol type   = End         Value  = 0  	Symbol# 9: "/usr/include/stdio.h" 	    First symbol  = 0 	    String index  = 1 	    Storage class = Text        Index  = 0 	    Symbol type   = End         Value  = 0      There are 25 auxiliary table entries, starting at 642.  	* #14             -1, [4095/1048575], [63 1:1 f:f:f:f:f:f] 	  #15          65544, [   8/     16], [ 2 0:0 1:0:0:0:0:0] 	  #16          65544, [   8/     16], [ 2 0:0 1:0:0:0:0:0] 	* #17         196656, [  48/     48], [12 0:0 3:0:0:0:0:0] 	* #18           8191, [4095/      1], [63 1:1 0:0:0:0:f:1] 	* #19              1, [   1/      0], [ 0 1:0 0:0:0:0:0:0] 	* #20          20479, [4095/      4], [63 1:1 0:0:0:0:f:4] 	* #21              1, [   1/      0], [ 0 1:0 0:0:0:0:0:0] 	* #22              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #23              2, [   2/      0], [ 0 0:1 0:0:0:0:0:0] 	* #24            160, [ 160/      0], [40 0:0 0:0:0:0:0:0] 	* #25              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #26              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #27              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #28              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #29              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #30              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #31              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #32              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #33              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #34              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #35              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #36              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #37              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #38              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0]      There are 0 procedure descriptor entries, starting at 1.     There are 20 external symbols, starting at 1152  	Symbol# 0: "_iob" 	    Type          = array [3 {160}] of struct _iobuf { ifd = 1, index = 1 } 	    String index  = 0           Ifd    = 1 	    Storage class = Nil         Index  = 17 	    Symbol type   = Global      Value  = 60  	Symbol# 1: "fopen" 	    String index  = 5           Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 2: "fdopen" 	    String index  = 11          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 3: "freopen" 	    String index  = 18          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 4: "popen" 	    String index  = 26          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 5: "tmpfile" 	    String index  = 32          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 6: "ftell" 	    String index  = 40          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 7: "rewind" 	    String index  = 46          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 8: "setbuf" 	    String index  = 53          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 9: "setbuffer" 	    String index  = 60          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 10: "setlinebuf" 	    String index  = 70          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 11: "fgets" 	    String index  = 81          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 12: "gets" 	    String index  = 87          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 13: "ctermid" 	    String index  = 92          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 14: "cuserid" 	    String index  = 100         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 15: "tempnam" 	    String index  = 108         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 16: "tmpnam" 	    String index  = 116         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 17: "sprintf" 	    String index  = 123         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 18: "main" 	    Type          = int 	    String index  = 131         Ifd    = 0 	    Storage class = Text        Index  = 1 	    Symbol type   = Proc        Value  = 0  	Symbol# 19: "printf" 	    String index  = 136         Ifd    = 0 	    Storage class = Undefined   Index  = 1048575 	    Symbol type   = Proc        Value  = 0     The following auxiliary table entries were unused:      #0               0  0x00000000  void     #2               8  0x00000008  char     #3              16  0x00000010  short     #4              24  0x00000018  int     #5              32  0x00000020  long     #6              40  0x00000028  float     #7              44  0x0000002c  double     #8              12  0x0000000c  unsigned char     #9              20  0x00000014  unsigned short     #10             28  0x0000001c  unsigned int     #11             36  0x00000024  unsigned long     #14              0  0x00000000  void     #15             24  0x00000018  int     #19             32  0x00000020  long     #20             40  0x00000028  float     #21             44  0x0000002c  double     #22             12  0x0000000c  unsigned char     #23             20  0x00000014  unsigned short     #24             28  0x0000001c  unsigned int     #25             36  0x00000024  unsigned long     #26             48  0x00000030  struct no name { ifd = -1, index = 1048575 } */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Redefinition of of storage classes as an enumeration for better    debugging.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|sc
block|{
name|sc_Nil
init|=
name|scNil
block|,
comment|/* no storage class */
name|sc_Text
init|=
name|scText
block|,
comment|/* text symbol */
name|sc_Data
init|=
name|scData
block|,
comment|/* initialized data symbol */
name|sc_Bss
init|=
name|scBss
block|,
comment|/* un-initialized data symbol */
name|sc_Register
init|=
name|scRegister
block|,
comment|/* value of symbol is register number */
name|sc_Abs
init|=
name|scAbs
block|,
comment|/* value of symbol is absolute */
name|sc_Undefined
init|=
name|scUndefined
block|,
comment|/* who knows? */
name|sc_CdbLocal
init|=
name|scCdbLocal
block|,
comment|/* variable's value is IN se->va.?? */
name|sc_Bits
init|=
name|scBits
block|,
comment|/* this is a bit field */
name|sc_CdbSystem
init|=
name|scCdbSystem
block|,
comment|/* value is IN CDB's address space */
name|sc_RegImage
init|=
name|scRegImage
block|,
comment|/* register value saved on stack */
name|sc_Info
init|=
name|scInfo
block|,
comment|/* symbol contains debugger information */
name|sc_UserStruct
init|=
name|scUserStruct
block|,
comment|/* addr in struct user for current process */
name|sc_SData
init|=
name|scSData
block|,
comment|/* load time only small data */
name|sc_SBss
init|=
name|scSBss
block|,
comment|/* load time only small common */
name|sc_RData
init|=
name|scRData
block|,
comment|/* load time only read only data */
name|sc_Var
init|=
name|scVar
block|,
comment|/* Var parameter (fortran,pascal) */
name|sc_Common
init|=
name|scCommon
block|,
comment|/* common variable */
name|sc_SCommon
init|=
name|scSCommon
block|,
comment|/* small common */
name|sc_VarRegister
init|=
name|scVarRegister
block|,
comment|/* Var parameter in a register */
name|sc_Variant
init|=
name|scVariant
block|,
comment|/* Variant record */
name|sc_SUndefined
init|=
name|scSUndefined
block|,
comment|/* small undefined(external) data */
name|sc_Init
init|=
name|scInit
block|,
comment|/* .init section symbol */
name|sc_Max
init|=
name|scMax
comment|/* Max storage class+1 */
block|}
name|sc_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of symbol type.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|st
block|{
name|st_Nil
init|=
name|stNil
block|,
comment|/* Nuthin' special */
name|st_Global
init|=
name|stGlobal
block|,
comment|/* external symbol */
name|st_Static
init|=
name|stStatic
block|,
comment|/* static */
name|st_Param
init|=
name|stParam
block|,
comment|/* procedure argument */
name|st_Local
init|=
name|stLocal
block|,
comment|/* local variable */
name|st_Label
init|=
name|stLabel
block|,
comment|/* label */
name|st_Proc
init|=
name|stProc
block|,
comment|/*     "      "	 Procedure */
name|st_Block
init|=
name|stBlock
block|,
comment|/* beginning of block */
name|st_End
init|=
name|stEnd
block|,
comment|/* end (of anything) */
name|st_Member
init|=
name|stMember
block|,
comment|/* member (of anything	- struct/union/enum */
name|st_Typedef
init|=
name|stTypedef
block|,
comment|/* type definition */
name|st_File
init|=
name|stFile
block|,
comment|/* file name */
name|st_RegReloc
init|=
name|stRegReloc
block|,
comment|/* register relocation */
name|st_Forward
init|=
name|stForward
block|,
comment|/* forwarding address */
name|st_StaticProc
init|=
name|stStaticProc
block|,
comment|/* load time only static procs */
name|st_Constant
init|=
name|stConstant
block|,
comment|/* const */
name|st_Str
init|=
name|stStr
block|,
comment|/* string */
name|st_Number
init|=
name|stNumber
block|,
comment|/* pure number (ie. 4 NOR 2+2) */
name|st_Expr
init|=
name|stExpr
block|,
comment|/* 2+2 vs. 4 */
name|st_Type
init|=
name|stType
block|,
comment|/* post-coercion SER */
name|st_Max
init|=
name|stMax
comment|/* max type+1 */
block|}
name|st_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of type qualifiers.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|tq
block|{
name|tq_Nil
init|=
name|tqNil
block|,
comment|/* bt is what you see */
name|tq_Ptr
init|=
name|tqPtr
block|,
comment|/* pointer */
name|tq_Proc
init|=
name|tqProc
block|,
comment|/* procedure */
name|tq_Array
init|=
name|tqArray
block|,
comment|/* duh */
name|tq_Far
init|=
name|tqFar
block|,
comment|/* longer addressing - 8086/8 land */
name|tq_Vol
init|=
name|tqVol
block|,
comment|/* volatile */
name|tq_Max
init|=
name|tqMax
comment|/* Max type qualifier+1 */
block|}
name|tq_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of basic types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|bt
block|{
name|bt_Nil
init|=
name|btNil
block|,
comment|/* undefined */
name|bt_Adr
init|=
name|btAdr
block|,
comment|/* address - integer same size as pointer */
name|bt_Char
init|=
name|btChar
block|,
comment|/* character */
name|bt_UChar
init|=
name|btUChar
block|,
comment|/* unsigned character */
name|bt_Short
init|=
name|btShort
block|,
comment|/* short */
name|bt_UShort
init|=
name|btUShort
block|,
comment|/* unsigned short */
name|bt_Int
init|=
name|btInt
block|,
comment|/* int */
name|bt_UInt
init|=
name|btUInt
block|,
comment|/* unsigned int */
name|bt_Long
init|=
name|btLong
block|,
comment|/* long */
name|bt_ULong
init|=
name|btULong
block|,
comment|/* unsigned long */
name|bt_Float
init|=
name|btFloat
block|,
comment|/* float (real) */
name|bt_Double
init|=
name|btDouble
block|,
comment|/* Double (real) */
name|bt_Struct
init|=
name|btStruct
block|,
comment|/* Structure (Record) */
name|bt_Union
init|=
name|btUnion
block|,
comment|/* Union (variant) */
name|bt_Enum
init|=
name|btEnum
block|,
comment|/* Enumerated */
name|bt_Typedef
init|=
name|btTypedef
block|,
comment|/* defined via a typedef, isymRef points */
name|bt_Range
init|=
name|btRange
block|,
comment|/* subrange of int */
name|bt_Set
init|=
name|btSet
block|,
comment|/* pascal sets */
name|bt_Complex
init|=
name|btComplex
block|,
comment|/* fortran complex */
name|bt_DComplex
init|=
name|btDComplex
block|,
comment|/* fortran double complex */
name|bt_Indirect
init|=
name|btIndirect
block|,
comment|/* forward or unnamed typedef */
name|bt_FixedDec
init|=
name|btFixedDec
block|,
comment|/* Fixed Decimal */
name|bt_FloatDec
init|=
name|btFloatDec
block|,
comment|/* Float Decimal */
name|bt_String
init|=
name|btString
block|,
comment|/* Varying Length Character String */
name|bt_Bit
init|=
name|btBit
block|,
comment|/* Aligned Bit String */
name|bt_Picture
init|=
name|btPicture
block|,
comment|/* Picture */
name|bt_Void
init|=
name|btVoid
block|,
comment|/* Void */
name|bt_Max
init|=
name|btMax
comment|/* Max basic type+1 */
block|}
name|bt_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|N_TQ
value|itqMax
end_define

begin_comment
comment|/* States for whether to hash type or not.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|hash_state
block|{
name|hash_no
init|=
literal|0
block|,
comment|/* Don't hash type */
name|hash_yes
init|=
literal|1
block|,
comment|/* OK to hash type, or use previous hash */
name|hash_record
init|=
literal|2
comment|/* OK to record hash, but don't use prev.  */
block|}
name|hash_state_t
typedef|;
end_typedef

begin_comment
comment|/* Types of different sized allocation requests.  */
end_comment

begin_enum
enum|enum
name|alloc_type
block|{
name|alloc_type_none
block|,
comment|/* dummy value */
name|alloc_type_scope
block|,
comment|/* nested scopes linked list */
name|alloc_type_vlinks
block|,
comment|/* glue linking pages in varray */
name|alloc_type_shash
block|,
comment|/* string hash element */
name|alloc_type_thash
block|,
comment|/* type hash element */
name|alloc_type_tag
block|,
comment|/* struct/union/tag element */
name|alloc_type_forward
block|,
comment|/* element to hold unknown tag */
name|alloc_type_thead
block|,
comment|/* head of type hash list */
name|alloc_type_varray
block|,
comment|/* general varray allocation */
name|alloc_type_lineno
block|,
comment|/* line number list */
name|alloc_type_last
comment|/* last+1 element for array bounds */
block|}
enum|;
end_enum

begin_comment
comment|/* Types of auxiliary type information.  */
end_comment

begin_enum
enum|enum
name|aux_type
block|{
name|aux_tir
block|,
comment|/* TIR type information */
name|aux_rndx
block|,
comment|/* relative index into symbol table */
name|aux_dnLow
block|,
comment|/* low dimension */
name|aux_dnHigh
block|,
comment|/* high dimension */
name|aux_isym
block|,
comment|/* symbol table index (end of proc) */
name|aux_iss
block|,
comment|/* index into string space (not used) */
name|aux_width
block|,
comment|/* width for non-default sized struc fields */
name|aux_count
comment|/* count of ranges for variant arm */
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Structures to provide n-number of virtual arrays, each of which can    grow linearly, and which are written in the object file as    sequential pages.  On systems with a BSD malloc, the    MAX_CLUSTER_PAGES should be 1 less than a power of two, since    malloc adds it's overhead, and rounds up to the next power of 2.    Pages are linked together via a linked list.     If PAGE_SIZE is> 4096, the string length in the shash_t structure    can't be represented (assuming there are strings> 4096 bytes).  */
end_comment

begin_comment
comment|/* FIXME: Yes, there can be such strings while emitting C++ class debug    info.  Templates are the offender here, the test case in question    having a mangled class name of       t7rb_tree4Z4xkeyZt4pair2ZC4xkeyZt7xsocket1Z4UserZt9select1st2Zt4pair\      2ZC4xkeyZt7xsocket1Z4UserZ4xkeyZt4less1Z4xkey     Repeat that a couple dozen times while listing the class members and    you've got strings over 4k.  Hack around this for now by increasing    the page size.  A proper solution would abandon this structure scheme    certainly for very large strings, and possibly entirely.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PAGE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PAGE_SIZE
value|(8*1024)
end_define

begin_comment
comment|/* size of varray pages */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAGE_USIZE
value|((unsigned long) PAGE_SIZE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CLUSTER_PAGES
end_ifndef

begin_comment
comment|/* # pages to get from system */
end_comment

begin_define
define|#
directive|define
name|MAX_CLUSTER_PAGES
value|63
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Linked list connecting separate page allocations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|vlinks
block|{
name|struct
name|vlinks
modifier|*
name|prev
decl_stmt|;
comment|/* previous set of pages */
name|struct
name|vlinks
modifier|*
name|next
decl_stmt|;
comment|/* next set of pages */
name|union
name|page
modifier|*
name|datum
decl_stmt|;
comment|/* start of page */
name|unsigned
name|long
name|start_index
decl_stmt|;
comment|/* starting index # of page */
block|}
name|vlinks_t
typedef|;
end_typedef

begin_comment
comment|/* Virtual array header.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|varray
block|{
name|vlinks_t
modifier|*
name|first
decl_stmt|;
comment|/* first page link */
name|vlinks_t
modifier|*
name|last
decl_stmt|;
comment|/* last page link */
name|unsigned
name|long
name|num_allocated
decl_stmt|;
comment|/* # objects allocated */
name|unsigned
name|short
name|object_size
decl_stmt|;
comment|/* size in bytes of each object */
name|unsigned
name|short
name|objects_per_page
decl_stmt|;
comment|/* # objects that can fit on a page */
name|unsigned
name|short
name|objects_last_page
decl_stmt|;
comment|/* # objects allocated on last page */
block|}
name|varray_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|type
parameter_list|)
value|(PAGE_SIZE / sizeof (type))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|type
parameter_list|)
value|((sizeof (type)> 1) ? 1 : PAGE_SIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INIT_VARRAY
parameter_list|(
name|type
parameter_list|)
value|{
comment|/* macro to initialize a varray */
value|\   (vlinks_t *)0,
comment|/* first */
value|\   (vlinks_t *)0,
comment|/* last */
value|\   0,
comment|/* num_allocated */
value|\   sizeof (type),
comment|/* object_size */
value|\   OBJECTS_PER_PAGE (type),
comment|/* objects_per_page */
value|\   OBJECTS_PER_PAGE (type),
comment|/* objects_last_page */
value|\ }
end_define

begin_comment
comment|/* Master type for indexes within the symbol table.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|symint_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list support for nested scopes (file, block, structure, etc.).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scope
block|{
name|struct
name|scope
modifier|*
name|prev
decl_stmt|;
comment|/* previous scope level */
name|struct
name|scope
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|struct
name|localsym
modifier|*
name|lsym
decl_stmt|;
comment|/* pointer to local symbol node */
name|st_t
name|type
decl_stmt|;
comment|/* type of the node */
block|}
name|scope_t
typedef|;
end_typedef

begin_comment
comment|/* For a local symbol we store a gas symbol as well as the debugging    information we generate.  The gas symbol will be NULL if this is    only a debugging symbol.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|localsym
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* symbol name */
name|symbolS
modifier|*
name|as_sym
decl_stmt|;
comment|/* symbol as seen by gas */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* addend to as_sym value */
name|struct
name|efdr
modifier|*
name|file_ptr
decl_stmt|;
comment|/* file pointer */
name|struct
name|ecoff_proc
modifier|*
name|proc_ptr
decl_stmt|;
comment|/* proc pointer */
name|struct
name|localsym
modifier|*
name|begin_ptr
decl_stmt|;
comment|/* symbol at start of block */
name|struct
name|ecoff_aux
modifier|*
name|index_ptr
decl_stmt|;
comment|/* index value to be filled in */
name|struct
name|forward
modifier|*
name|forward_ref
decl_stmt|;
comment|/* forward references to this symbol */
name|long
name|sym_index
decl_stmt|;
comment|/* final symbol index */
name|EXTR
name|ecoff_sym
decl_stmt|;
comment|/* ECOFF debugging symbol */
block|}
name|localsym_t
typedef|;
end_typedef

begin_comment
comment|/* For aux information we keep the type and the data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ecoff_aux
block|{
name|enum
name|aux_type
name|type
decl_stmt|;
comment|/* aux type */
name|AUXU
name|data
decl_stmt|;
comment|/* aux data */
block|}
name|aux_t
typedef|;
end_typedef

begin_comment
comment|/* For a procedure we store the gas symbol as well as the PDR    debugging information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ecoff_proc
block|{
name|localsym_t
modifier|*
name|sym
decl_stmt|;
comment|/* associated symbol */
name|PDR
name|pdr
decl_stmt|;
comment|/* ECOFF debugging info */
block|}
name|proc_t
typedef|;
end_typedef

begin_comment
comment|/* Number of proc_t structures allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|proc_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward reference list for tags referenced, but not yet defined.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|forward
block|{
name|struct
name|forward
modifier|*
name|next
decl_stmt|;
comment|/* next forward reference */
name|struct
name|forward
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|aux_t
modifier|*
name|ifd_ptr
decl_stmt|;
comment|/* pointer to store file index */
name|aux_t
modifier|*
name|index_ptr
decl_stmt|;
comment|/* pointer to store symbol index */
block|}
name|forward_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list support for tags.  The first tag in the list is always    the current tag for that block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tag
block|{
name|struct
name|tag
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|struct
name|shash
modifier|*
name|hash_ptr
decl_stmt|;
comment|/* pointer to the hash table head */
name|struct
name|tag
modifier|*
name|same_name
decl_stmt|;
comment|/* tag with same name in outer scope */
name|struct
name|tag
modifier|*
name|same_block
decl_stmt|;
comment|/* next tag defined in the same block.  */
name|struct
name|forward
modifier|*
name|forward_ref
decl_stmt|;
comment|/* list of forward references */
name|bt_t
name|basic_type
decl_stmt|;
comment|/* bt_Struct, bt_Union, or bt_Enum */
name|symint_t
name|ifd
decl_stmt|;
comment|/* file # tag defined in */
name|localsym_t
modifier|*
name|sym
decl_stmt|;
comment|/* file's local symbols */
block|}
name|tag_t
typedef|;
end_typedef

begin_comment
comment|/* Head of a block's linked list of tags.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thead
block|{
name|struct
name|thead
modifier|*
name|prev
decl_stmt|;
comment|/* previous block */
name|struct
name|thead
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|struct
name|tag
modifier|*
name|first_tag
decl_stmt|;
comment|/* first tag in block defined */
block|}
name|thead_t
typedef|;
end_typedef

begin_comment
comment|/* Union containing pointers to each the small structures which are freed up.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|small_free
block|{
name|scope_t
modifier|*
name|f_scope
decl_stmt|;
comment|/* scope structure */
name|thead_t
modifier|*
name|f_thead
decl_stmt|;
comment|/* tag head structure */
name|tag_t
modifier|*
name|f_tag
decl_stmt|;
comment|/* tag element structure */
name|forward_t
modifier|*
name|f_forward
decl_stmt|;
comment|/* forward tag reference */
block|}
name|small_free_t
typedef|;
end_typedef

begin_comment
comment|/* String hash table entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shash
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string we are hashing */
name|symint_t
name|indx
decl_stmt|;
comment|/* index within string table */
name|EXTR
modifier|*
name|esym_ptr
decl_stmt|;
comment|/* global symbol pointer */
name|localsym_t
modifier|*
name|sym_ptr
decl_stmt|;
comment|/* local symbol pointer */
name|localsym_t
modifier|*
name|end_ptr
decl_stmt|;
comment|/* symbol pointer to end block */
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
comment|/* tag pointer */
name|proc_t
modifier|*
name|proc_ptr
decl_stmt|;
comment|/* procedure descriptor pointer */
block|}
name|shash_t
typedef|;
end_typedef

begin_comment
comment|/* Type hash table support.  The size of the hash table must fit    within a page with the other extended file descriptor information.    Because unique types which are hashed are fewer in number than    strings, we use a smaller hash value.  */
end_comment

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|THASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|THASH_SIZE
value|113
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|thash
block|{
name|struct
name|thash
modifier|*
name|next
decl_stmt|;
comment|/* next hash value */
name|AUXU
name|type
decl_stmt|;
comment|/* type we are hashing */
name|symint_t
name|indx
decl_stmt|;
comment|/* index within string table */
block|}
name|thash_t
typedef|;
end_typedef

begin_comment
comment|/* Extended file descriptor that contains all of the support necessary    to add things to each file separately.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|efdr
block|{
name|FDR
name|fdr
decl_stmt|;
comment|/* File header to be written out */
name|FDR
modifier|*
name|orig_fdr
decl_stmt|;
comment|/* original file header */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|int
name|fake
decl_stmt|;
comment|/* whether this is faked .file */
name|symint_t
name|void_type
decl_stmt|;
comment|/* aux. pointer to 'void' type */
name|symint_t
name|int_type
decl_stmt|;
comment|/* aux. pointer to 'int' type */
name|scope_t
modifier|*
name|cur_scope
decl_stmt|;
comment|/* current nested scopes */
name|symint_t
name|file_index
decl_stmt|;
comment|/* current file number */
name|int
name|nested_scopes
decl_stmt|;
comment|/* # nested scopes */
name|varray_t
name|strings
decl_stmt|;
comment|/* local strings */
name|varray_t
name|symbols
decl_stmt|;
comment|/* local symbols */
name|varray_t
name|procs
decl_stmt|;
comment|/* procedures */
name|varray_t
name|aux_syms
decl_stmt|;
comment|/* auxiliary symbols */
name|struct
name|efdr
modifier|*
name|next_file
decl_stmt|;
comment|/* next file descriptor */
comment|/* string/type hash tables */
name|struct
name|hash_control
modifier|*
name|str_hash
decl_stmt|;
comment|/* string hash table */
name|thash_t
modifier|*
name|thash_head
index|[
name|THASH_SIZE
index|]
decl_stmt|;
block|}
name|efdr_t
typedef|;
end_typedef

begin_comment
comment|/* Pre-initialized extended file structure.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|efdr_t
name|init_file
init|=
block|{
block|{
comment|/* FDR structure */
literal|0
block|,
comment|/* adr:		memory address of beginning of file */
literal|0
block|,
comment|/* rss:		file name (of source, if known) */
literal|0
block|,
comment|/* issBase:	file's string space */
literal|0
block|,
comment|/* cbSs:	number of bytes in the ss */
literal|0
block|,
comment|/* isymBase:	beginning of symbols */
literal|0
block|,
comment|/* csym:	count file's of symbols */
literal|0
block|,
comment|/* ilineBase:	file's line symbols */
literal|0
block|,
comment|/* cline:	count of file's line symbols */
literal|0
block|,
comment|/* ioptBase:	file's optimization entries */
literal|0
block|,
comment|/* copt:	count of file's optimization entries */
literal|0
block|,
comment|/* ipdFirst:	start of procedures for this file */
literal|0
block|,
comment|/* cpd:		count of procedures for this file */
literal|0
block|,
comment|/* iauxBase:	file's auxiliary entries */
literal|0
block|,
comment|/* caux:	count of file's auxiliary entries */
literal|0
block|,
comment|/* rfdBase:	index into the file indirect table */
literal|0
block|,
comment|/* crfd:	count file indirect entries */
name|langC
block|,
comment|/* lang:	language for this file */
literal|1
block|,
comment|/* fMerge:	whether this file can be merged */
literal|0
block|,
comment|/* fReadin:	true if read in (not just created) */
name|TARGET_BYTES_BIG_ENDIAN
block|,
comment|/* fBigendian:	if 1, compiled on big endian machine */
name|GLEVEL_2
block|,
comment|/* glevel:	level this file was compiled with */
literal|0
block|,
comment|/* reserved:	reserved for future use */
literal|0
block|,
comment|/* cbLineOffset: byte offset from header for this file ln's */
literal|0
block|,
comment|/* cbLine:	size of lines for this file */
block|}
block|,
operator|(
name|FDR
operator|*
operator|)
literal|0
block|,
comment|/* orig_fdr:	original file header pointer */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
comment|/* name:	pointer to filename */
literal|0
block|,
comment|/* fake:	whether this is a faked .file */
literal|0
block|,
comment|/* void_type:	ptr to aux node for void type */
literal|0
block|,
comment|/* int_type:	ptr to aux node for int type */
operator|(
name|scope_t
operator|*
operator|)
literal|0
block|,
comment|/* cur_scope:	current scope being processed */
literal|0
block|,
comment|/* file_index:	current file # */
literal|0
block|,
comment|/* nested_scopes: # nested scopes */
name|INIT_VARRAY
argument_list|(
name|char
argument_list|)
block|,
comment|/* strings:	local string varray */
name|INIT_VARRAY
argument_list|(
name|localsym_t
argument_list|)
block|,
comment|/* symbols:	local symbols varray */
name|INIT_VARRAY
argument_list|(
name|proc_t
argument_list|)
block|,
comment|/* procs:	procedure varray */
name|INIT_VARRAY
argument_list|(
name|aux_t
argument_list|)
block|,
comment|/* aux_syms:	auxiliary symbols varray */
operator|(
expr|struct
name|efdr
operator|*
operator|)
literal|0
block|,
comment|/* next_file:	next file structure */
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
block|,
comment|/* str_hash:	string hash table */
block|{
literal|0
block|}
block|,
comment|/* thash_head:	type hash table */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
name|first_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
modifier|*
name|last_file_ptr
init|=
operator|&
name|first_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor tail */
end_comment

begin_comment
comment|/* Line number information is kept in a list until the assembly is    finished.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lineno_list
block|{
name|struct
name|lineno_list
modifier|*
name|next
decl_stmt|;
comment|/* next element in list */
name|efdr_t
modifier|*
name|file
decl_stmt|;
comment|/* file this line is in */
name|proc_t
modifier|*
name|proc
decl_stmt|;
comment|/* procedure this line is in */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* fragment this line number is in */
name|unsigned
name|long
name|paddr
decl_stmt|;
comment|/* offset within fragment */
name|long
name|lineno
decl_stmt|;
comment|/* actual line number */
block|}
name|lineno_list_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|lineno_list_t
modifier|*
name|first_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lineno_list_t
modifier|*
name|last_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lineno_list_t
modifier|*
modifier|*
name|last_lineno_ptr
init|=
operator|&
name|first_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sometimes there will be some .loc statements before a .ent.  We    keep them in this list so that we can fill in the procedure pointer    after we see the .ent.  */
end_comment

begin_decl_stmt
specifier|static
name|lineno_list_t
modifier|*
name|noproc_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Union of various things that are held in pages.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|page
block|{
name|char
name|byte
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|ubyte
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|efdr_t
name|file
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|efdr_t
argument_list|)
index|]
decl_stmt|;
name|FDR
name|ofile
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
index|]
decl_stmt|;
name|proc_t
name|proc
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|proc_t
argument_list|)
index|]
decl_stmt|;
name|localsym_t
name|sym
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|localsym_t
argument_list|)
index|]
decl_stmt|;
name|aux_t
name|aux
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|aux_t
argument_list|)
index|]
decl_stmt|;
name|DNR
name|dense
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
index|]
decl_stmt|;
name|scope_t
name|scope
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
index|]
decl_stmt|;
name|vlinks_t
name|vlinks
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
index|]
decl_stmt|;
name|shash_t
name|shash
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
index|]
decl_stmt|;
name|thash_t
name|thash
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
index|]
decl_stmt|;
name|tag_t
name|tag
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
index|]
decl_stmt|;
name|forward_t
name|forward
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
index|]
decl_stmt|;
name|thead_t
name|thead
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
index|]
decl_stmt|;
name|lineno_list_t
name|lineno
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|lineno_list_t
argument_list|)
index|]
decl_stmt|;
block|}
name|page_type
typedef|;
end_typedef

begin_comment
comment|/* Structure holding allocation information for small sized structures.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alloc_info
block|{
name|char
modifier|*
name|alloc_name
decl_stmt|;
comment|/* name of this allocation type (must be first) */
name|page_type
modifier|*
name|cur_page
decl_stmt|;
comment|/* current page being allocated from */
name|small_free_t
name|free_list
decl_stmt|;
comment|/* current free list if any */
name|int
name|unallocated
decl_stmt|;
comment|/* number of elements unallocated on page */
name|int
name|total_alloc
decl_stmt|;
comment|/* total number of allocations */
name|int
name|total_free
decl_stmt|;
comment|/* total number of frees */
name|int
name|total_pages
decl_stmt|;
comment|/* total number of pages allocated */
block|}
name|alloc_info_t
typedef|;
end_typedef

begin_comment
comment|/* Type information collected together.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|type_info
block|{
name|bt_t
name|basic_type
decl_stmt|;
comment|/* basic type */
name|int
name|orig_type
decl_stmt|;
comment|/* original COFF-based type */
name|int
name|num_tq
decl_stmt|;
comment|/* # type qualifiers */
name|int
name|num_dims
decl_stmt|;
comment|/* # dimensions */
name|int
name|num_sizes
decl_stmt|;
comment|/* # sizes */
name|int
name|extra_sizes
decl_stmt|;
comment|/* # extra sizes not tied with dims */
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
comment|/* tag pointer */
name|int
name|bitfield
decl_stmt|;
comment|/* symbol is a bitfield */
name|tq_t
name|type_qualifiers
index|[
name|N_TQ
index|]
decl_stmt|;
comment|/* type qualifiers (ptr, func, array)*/
name|symint_t
name|dimensions
index|[
name|N_TQ
index|]
decl_stmt|;
comment|/* dimensions for each array */
name|symint_t
name|sizes
index|[
name|N_TQ
operator|+
literal|2
index|]
decl_stmt|;
comment|/* sizes of each array slice + size of 					   struct/union/enum + bitfield size */
block|}
name|type_info_t
typedef|;
end_typedef

begin_comment
comment|/* Pre-initialized type_info struct.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|type_info_t
name|type_info_init
init|=
block|{
name|bt_Nil
block|,
comment|/* basic type */
name|T_NULL
block|,
comment|/* original COFF-based type */
literal|0
block|,
comment|/* # type qualifiers */
literal|0
block|,
comment|/* # dimensions */
literal|0
block|,
comment|/* # sizes */
literal|0
block|,
comment|/* sizes not tied with dims */
name|NULL
block|,
comment|/* ptr to tag */
literal|0
block|,
comment|/* bitfield */
block|{
comment|/* type qualifiers */
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,   }
block|,
block|{
comment|/* dimensions */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
comment|/* sizes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,   }
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global hash table for the tags table and global table for file    descriptors.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_t
name|file_desc
init|=
name|INIT_VARRAY
argument_list|(
name|efdr_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tag_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static types for int and void.  Also, remember the last function's    type (which is set up when we encounter the declaration for the    function, and used when the end block for the function is emitted.  */
end_comment

begin_decl_stmt
specifier|static
name|type_info_t
name|int_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_info_t
name|void_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_info_t
name|last_func_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|last_func_sym_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF basic type to ECOFF basic type.  The T_NULL type    really should use bt_Void, but this causes the current ecoff GDB to    issue unsupported type messages, and the Ultrix 4.00 dbx (aka MIPS    2.0) doesn't understand it, even though the compiler generates it.    Maybe this will be fixed in 2.10 or 2.20 of the MIPS compiler    suite, but for now go with what works.     It would make sense for the .type and .scl directives to use the    ECOFF numbers directly, rather than using the COFF numbers and    mapping them.  Unfortunately, this is historically what mips-tfile    expects, and changing gcc now would be a considerable pain (the    native compiler generates debugging information internally, rather    than via the assembler, so it will never use .type or .scl).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bt_t
name|map_coff_types
index|[]
init|=
block|{
name|bt_Nil
block|,
comment|/* T_NULL */
name|bt_Nil
block|,
comment|/* T_ARG */
name|bt_Char
block|,
comment|/* T_CHAR */
name|bt_Short
block|,
comment|/* T_SHORT */
name|bt_Int
block|,
comment|/* T_INT */
name|bt_Long
block|,
comment|/* T_LONG */
name|bt_Float
block|,
comment|/* T_FLOAT */
name|bt_Double
block|,
comment|/* T_DOUBLE */
name|bt_Struct
block|,
comment|/* T_STRUCT */
name|bt_Union
block|,
comment|/* T_UNION */
name|bt_Enum
block|,
comment|/* T_ENUM */
name|bt_Enum
block|,
comment|/* T_MOE */
name|bt_UChar
block|,
comment|/* T_UCHAR */
name|bt_UShort
block|,
comment|/* T_USHORT */
name|bt_UInt
block|,
comment|/* T_UINT */
name|bt_ULong
comment|/* T_ULONG */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF storage class to ECOFF storage class.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|sc_t
name|map_coff_storage
index|[]
init|=
block|{
name|sc_Nil
block|,
comment|/*   0: C_NULL */
name|sc_Abs
block|,
comment|/*   1: C_AUTO	  auto var */
name|sc_Undefined
block|,
comment|/*   2: C_EXT	  external */
name|sc_Data
block|,
comment|/*   3: C_STAT	  static */
name|sc_Register
block|,
comment|/*   4: C_REG	  register */
name|sc_Undefined
block|,
comment|/*   5: C_EXTDEF  ??? */
name|sc_Text
block|,
comment|/*   6: C_LABEL	  label */
name|sc_Text
block|,
comment|/*   7: C_ULABEL  user label */
name|sc_Info
block|,
comment|/*   8: C_MOS	  member of struct */
name|sc_Abs
block|,
comment|/*   9: C_ARG	  argument */
name|sc_Info
block|,
comment|/*  10: C_STRTAG  struct tag */
name|sc_Info
block|,
comment|/*  11: C_MOU	  member of union */
name|sc_Info
block|,
comment|/*  12: C_UNTAG   union tag */
name|sc_Info
block|,
comment|/*  13: C_TPDEF	  typedef */
name|sc_Data
block|,
comment|/*  14: C_USTATIC ??? */
name|sc_Info
block|,
comment|/*  15: C_ENTAG	  enum tag */
name|sc_Info
block|,
comment|/*  16: C_MOE	  member of enum */
name|sc_Register
block|,
comment|/*  17: C_REGPARM register parameter */
name|sc_Bits
block|,
comment|/*  18; C_FIELD	  bitfield */
name|sc_Nil
block|,
comment|/*  19 */
name|sc_Nil
block|,
comment|/*  20 */
name|sc_Nil
block|,
comment|/*  21 */
name|sc_Nil
block|,
comment|/*  22 */
name|sc_Nil
block|,
comment|/*  23 */
name|sc_Nil
block|,
comment|/*  24 */
name|sc_Nil
block|,
comment|/*  25 */
name|sc_Nil
block|,
comment|/*  26 */
name|sc_Nil
block|,
comment|/*  27 */
name|sc_Nil
block|,
comment|/*  28 */
name|sc_Nil
block|,
comment|/*  29 */
name|sc_Nil
block|,
comment|/*  30 */
name|sc_Nil
block|,
comment|/*  31 */
name|sc_Nil
block|,
comment|/*  32 */
name|sc_Nil
block|,
comment|/*  33 */
name|sc_Nil
block|,
comment|/*  34 */
name|sc_Nil
block|,
comment|/*  35 */
name|sc_Nil
block|,
comment|/*  36 */
name|sc_Nil
block|,
comment|/*  37 */
name|sc_Nil
block|,
comment|/*  38 */
name|sc_Nil
block|,
comment|/*  39 */
name|sc_Nil
block|,
comment|/*  40 */
name|sc_Nil
block|,
comment|/*  41 */
name|sc_Nil
block|,
comment|/*  42 */
name|sc_Nil
block|,
comment|/*  43 */
name|sc_Nil
block|,
comment|/*  44 */
name|sc_Nil
block|,
comment|/*  45 */
name|sc_Nil
block|,
comment|/*  46 */
name|sc_Nil
block|,
comment|/*  47 */
name|sc_Nil
block|,
comment|/*  48 */
name|sc_Nil
block|,
comment|/*  49 */
name|sc_Nil
block|,
comment|/*  50 */
name|sc_Nil
block|,
comment|/*  51 */
name|sc_Nil
block|,
comment|/*  52 */
name|sc_Nil
block|,
comment|/*  53 */
name|sc_Nil
block|,
comment|/*  54 */
name|sc_Nil
block|,
comment|/*  55 */
name|sc_Nil
block|,
comment|/*  56 */
name|sc_Nil
block|,
comment|/*  57 */
name|sc_Nil
block|,
comment|/*  58 */
name|sc_Nil
block|,
comment|/*  59 */
name|sc_Nil
block|,
comment|/*  60 */
name|sc_Nil
block|,
comment|/*  61 */
name|sc_Nil
block|,
comment|/*  62 */
name|sc_Nil
block|,
comment|/*  63 */
name|sc_Nil
block|,
comment|/*  64 */
name|sc_Nil
block|,
comment|/*  65 */
name|sc_Nil
block|,
comment|/*  66 */
name|sc_Nil
block|,
comment|/*  67 */
name|sc_Nil
block|,
comment|/*  68 */
name|sc_Nil
block|,
comment|/*  69 */
name|sc_Nil
block|,
comment|/*  70 */
name|sc_Nil
block|,
comment|/*  71 */
name|sc_Nil
block|,
comment|/*  72 */
name|sc_Nil
block|,
comment|/*  73 */
name|sc_Nil
block|,
comment|/*  74 */
name|sc_Nil
block|,
comment|/*  75 */
name|sc_Nil
block|,
comment|/*  76 */
name|sc_Nil
block|,
comment|/*  77 */
name|sc_Nil
block|,
comment|/*  78 */
name|sc_Nil
block|,
comment|/*  79 */
name|sc_Nil
block|,
comment|/*  80 */
name|sc_Nil
block|,
comment|/*  81 */
name|sc_Nil
block|,
comment|/*  82 */
name|sc_Nil
block|,
comment|/*  83 */
name|sc_Nil
block|,
comment|/*  84 */
name|sc_Nil
block|,
comment|/*  85 */
name|sc_Nil
block|,
comment|/*  86 */
name|sc_Nil
block|,
comment|/*  87 */
name|sc_Nil
block|,
comment|/*  88 */
name|sc_Nil
block|,
comment|/*  89 */
name|sc_Nil
block|,
comment|/*  90 */
name|sc_Nil
block|,
comment|/*  91 */
name|sc_Nil
block|,
comment|/*  92 */
name|sc_Nil
block|,
comment|/*  93 */
name|sc_Nil
block|,
comment|/*  94 */
name|sc_Nil
block|,
comment|/*  95 */
name|sc_Nil
block|,
comment|/*  96 */
name|sc_Nil
block|,
comment|/*  97 */
name|sc_Nil
block|,
comment|/*  98 */
name|sc_Nil
block|,
comment|/*  99 */
name|sc_Text
block|,
comment|/* 100: C_BLOCK  block start/end */
name|sc_Text
block|,
comment|/* 101: C_FCN	 function start/end */
name|sc_Info
block|,
comment|/* 102: C_EOS	 end of struct/union/enum */
name|sc_Nil
block|,
comment|/* 103: C_FILE	 file start */
name|sc_Nil
block|,
comment|/* 104: C_LINE	 line number */
name|sc_Nil
block|,
comment|/* 105: C_ALIAS	 combined type info */
name|sc_Nil
block|,
comment|/* 106: C_HIDDEN ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF storage class to ECOFF symbol type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|st_t
name|map_coff_sym_type
index|[]
init|=
block|{
name|st_Nil
block|,
comment|/*   0: C_NULL */
name|st_Local
block|,
comment|/*   1: C_AUTO	  auto var */
name|st_Global
block|,
comment|/*   2: C_EXT	  external */
name|st_Static
block|,
comment|/*   3: C_STAT	  static */
name|st_Local
block|,
comment|/*   4: C_REG	  register */
name|st_Global
block|,
comment|/*   5: C_EXTDEF  ??? */
name|st_Label
block|,
comment|/*   6: C_LABEL	  label */
name|st_Label
block|,
comment|/*   7: C_ULABEL  user label */
name|st_Member
block|,
comment|/*   8: C_MOS	  member of struct */
name|st_Param
block|,
comment|/*   9: C_ARG	  argument */
name|st_Block
block|,
comment|/*  10: C_STRTAG  struct tag */
name|st_Member
block|,
comment|/*  11: C_MOU	  member of union */
name|st_Block
block|,
comment|/*  12: C_UNTAG   union tag */
name|st_Typedef
block|,
comment|/*  13: C_TPDEF	  typedef */
name|st_Static
block|,
comment|/*  14: C_USTATIC ??? */
name|st_Block
block|,
comment|/*  15: C_ENTAG	  enum tag */
name|st_Member
block|,
comment|/*  16: C_MOE	  member of enum */
name|st_Param
block|,
comment|/*  17: C_REGPARM register parameter */
name|st_Member
block|,
comment|/*  18; C_FIELD	  bitfield */
name|st_Nil
block|,
comment|/*  19 */
name|st_Nil
block|,
comment|/*  20 */
name|st_Nil
block|,
comment|/*  21 */
name|st_Nil
block|,
comment|/*  22 */
name|st_Nil
block|,
comment|/*  23 */
name|st_Nil
block|,
comment|/*  24 */
name|st_Nil
block|,
comment|/*  25 */
name|st_Nil
block|,
comment|/*  26 */
name|st_Nil
block|,
comment|/*  27 */
name|st_Nil
block|,
comment|/*  28 */
name|st_Nil
block|,
comment|/*  29 */
name|st_Nil
block|,
comment|/*  30 */
name|st_Nil
block|,
comment|/*  31 */
name|st_Nil
block|,
comment|/*  32 */
name|st_Nil
block|,
comment|/*  33 */
name|st_Nil
block|,
comment|/*  34 */
name|st_Nil
block|,
comment|/*  35 */
name|st_Nil
block|,
comment|/*  36 */
name|st_Nil
block|,
comment|/*  37 */
name|st_Nil
block|,
comment|/*  38 */
name|st_Nil
block|,
comment|/*  39 */
name|st_Nil
block|,
comment|/*  40 */
name|st_Nil
block|,
comment|/*  41 */
name|st_Nil
block|,
comment|/*  42 */
name|st_Nil
block|,
comment|/*  43 */
name|st_Nil
block|,
comment|/*  44 */
name|st_Nil
block|,
comment|/*  45 */
name|st_Nil
block|,
comment|/*  46 */
name|st_Nil
block|,
comment|/*  47 */
name|st_Nil
block|,
comment|/*  48 */
name|st_Nil
block|,
comment|/*  49 */
name|st_Nil
block|,
comment|/*  50 */
name|st_Nil
block|,
comment|/*  51 */
name|st_Nil
block|,
comment|/*  52 */
name|st_Nil
block|,
comment|/*  53 */
name|st_Nil
block|,
comment|/*  54 */
name|st_Nil
block|,
comment|/*  55 */
name|st_Nil
block|,
comment|/*  56 */
name|st_Nil
block|,
comment|/*  57 */
name|st_Nil
block|,
comment|/*  58 */
name|st_Nil
block|,
comment|/*  59 */
name|st_Nil
block|,
comment|/*  60 */
name|st_Nil
block|,
comment|/*  61 */
name|st_Nil
block|,
comment|/*  62 */
name|st_Nil
block|,
comment|/*  63 */
name|st_Nil
block|,
comment|/*  64 */
name|st_Nil
block|,
comment|/*  65 */
name|st_Nil
block|,
comment|/*  66 */
name|st_Nil
block|,
comment|/*  67 */
name|st_Nil
block|,
comment|/*  68 */
name|st_Nil
block|,
comment|/*  69 */
name|st_Nil
block|,
comment|/*  70 */
name|st_Nil
block|,
comment|/*  71 */
name|st_Nil
block|,
comment|/*  72 */
name|st_Nil
block|,
comment|/*  73 */
name|st_Nil
block|,
comment|/*  74 */
name|st_Nil
block|,
comment|/*  75 */
name|st_Nil
block|,
comment|/*  76 */
name|st_Nil
block|,
comment|/*  77 */
name|st_Nil
block|,
comment|/*  78 */
name|st_Nil
block|,
comment|/*  79 */
name|st_Nil
block|,
comment|/*  80 */
name|st_Nil
block|,
comment|/*  81 */
name|st_Nil
block|,
comment|/*  82 */
name|st_Nil
block|,
comment|/*  83 */
name|st_Nil
block|,
comment|/*  84 */
name|st_Nil
block|,
comment|/*  85 */
name|st_Nil
block|,
comment|/*  86 */
name|st_Nil
block|,
comment|/*  87 */
name|st_Nil
block|,
comment|/*  88 */
name|st_Nil
block|,
comment|/*  89 */
name|st_Nil
block|,
comment|/*  90 */
name|st_Nil
block|,
comment|/*  91 */
name|st_Nil
block|,
comment|/*  92 */
name|st_Nil
block|,
comment|/*  93 */
name|st_Nil
block|,
comment|/*  94 */
name|st_Nil
block|,
comment|/*  95 */
name|st_Nil
block|,
comment|/*  96 */
name|st_Nil
block|,
comment|/*  97 */
name|st_Nil
block|,
comment|/*  98 */
name|st_Nil
block|,
comment|/*  99 */
name|st_Block
block|,
comment|/* 100: C_BLOCK  block start/end */
name|st_Proc
block|,
comment|/* 101: C_FCN	 function start/end */
name|st_End
block|,
comment|/* 102: C_EOS	 end of struct/union/enum */
name|st_File
block|,
comment|/* 103: C_FILE	 file start */
name|st_Nil
block|,
comment|/* 104: C_LINE	 line number */
name|st_Nil
block|,
comment|/* 105: C_ALIAS	 combined type info */
name|st_Nil
block|,
comment|/* 106: C_HIDDEN ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of different sized allocation requests.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_info_t
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_last
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Record whether we have seen any debugging information.  */
end_comment

begin_decl_stmt
name|int
name|ecoff_debugging_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various statics.  */
end_comment

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
name|cur_file_ptr
init|=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file desc. header */
end_comment

begin_decl_stmt
specifier|static
name|proc_t
modifier|*
name|cur_proc_ptr
init|=
operator|(
name|proc_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current procedure header */
end_comment

begin_decl_stmt
specifier|static
name|proc_t
modifier|*
name|first_proc_ptr
init|=
operator|(
name|proc_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first procedure header */
end_comment

begin_decl_stmt
specifier|static
name|thead_t
modifier|*
name|top_tag_head
init|=
operator|(
name|thead_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top level tag head */
end_comment

begin_decl_stmt
specifier|static
name|thead_t
modifier|*
name|cur_tag_head
init|=
operator|(
name|thead_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current tag head */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace functions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|stabs_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if stabs have been seen */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_file_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_stabs_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo symbol to use when putting stabs into the symbol table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STABS_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|STABS_SYMBOL
value|"@stabs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|stabs_symbol
index|[]
init|=
name|STABS_SYMBOL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prototypes for functions defined in this file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|add_varray_page
parameter_list|(
name|varray_t
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symint_t
name|add_string
parameter_list|(
name|varray_t
modifier|*
name|vp
parameter_list|,
name|struct
name|hash_control
modifier|*
name|hash_tbl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|shash_t
modifier|*
modifier|*
name|ret_hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|localsym_t
modifier|*
name|add_ecoff_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|st_t
name|type
parameter_list|,
name|sc_t
name|storage
parameter_list|,
name|symbolS
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|symint_t
name|value
parameter_list|,
name|symint_t
name|indx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symint_t
name|add_aux_sym_symint
parameter_list|(
name|symint_t
name|aux_word
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symint_t
name|add_aux_sym_rndx
parameter_list|(
name|int
name|file_index
parameter_list|,
name|symint_t
name|sym_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symint_t
name|add_aux_sym_tir
parameter_list|(
name|type_info_t
modifier|*
name|t
parameter_list|,
name|hash_state_t
name|state
parameter_list|,
name|thash_t
modifier|*
modifier|*
name|hash_tbl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tag_t
modifier|*
name|get_tag
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|localsym_t
modifier|*
name|sym
parameter_list|,
name|bt_t
name|basic_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_unknown_tag
parameter_list|(
name|tag_t
modifier|*
name|ptag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_procedure
parameter_list|(
name|char
modifier|*
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|int
name|indx
parameter_list|,
name|int
name|fake
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|sc_to_string
parameter_list|(
name|sc_t
name|storage_class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|st_to_string
parameter_list|(
name|st_t
name|symbol_type
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mark_stabs
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ecoff_add_bytes
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|char
modifier|*
name|bufptr
parameter_list|,
name|unsigned
name|long
name|need
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_padding_adjust
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
modifier|*
name|bufptrptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_lineno
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|long
modifier|*
name|linecntptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_symbols
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_procs
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_aux
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_strings
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|varray_t
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_ss
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ecoff_build_fdr
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecoff_setup_ext
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|page_type
modifier|*
name|allocate_cluster
parameter_list|(
name|unsigned
name|long
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|page_type
modifier|*
name|allocate_page
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scope_t
modifier|*
name|allocate_scope
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_scope
parameter_list|(
name|scope_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vlinks_t
modifier|*
name|allocate_vlinks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|shash_t
modifier|*
name|allocate_shash
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|thash_t
modifier|*
name|allocate_thash
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tag_t
modifier|*
name|allocate_tag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tag
parameter_list|(
name|tag_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|forward_t
modifier|*
name|allocate_forward
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|thead_t
modifier|*
name|allocate_thead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_thead
parameter_list|(
name|thead_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lineno_list_t
modifier|*
name|allocate_lineno_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This function should be called when the assembler starts up.  */
end_comment

begin_function
name|void
name|ecoff_read_begin_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|tag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|top_tag_head
operator|=
name|allocate_thead
argument_list|()
expr_stmt|;
name|top_tag_head
operator|->
name|first_tag
operator|=
operator|(
name|tag_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|top_tag_head
operator|->
name|free
operator|=
operator|(
name|thead_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|top_tag_head
operator|->
name|prev
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|top_tag_head
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function should be called when a symbol is created.  */
end_comment

begin_function
name|void
name|ecoff_symbol_new_hook
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|OBJ_SYMFIELD_TYPE
modifier|*
name|obj
decl_stmt|;
comment|/* Make sure that we have a file pointer, but only if we have seen a      file.  If we haven't seen a file, then this is a probably special      symbol created by md_begin which may required special handling at      some point.  Creating a dummy file with a dummy name is certainly      wrong.  */
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
operator|&&
name|seen_at_least_1_file
argument_list|()
condition|)
name|add_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obj
operator|=
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ecoff_file
operator|=
name|cur_file_ptr
expr_stmt|;
name|obj
operator|->
name|ecoff_symbol
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|ecoff_extern_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a page to a varray object.  */
end_comment

begin_function
specifier|static
name|void
name|add_varray_page
parameter_list|(
name|varray_t
modifier|*
name|vp
comment|/* varray to add page to */
parameter_list|)
block|{
name|vlinks_t
modifier|*
name|new_links
init|=
name|allocate_vlinks
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_CHECK
if|if
condition|(
name|vp
operator|->
name|object_size
operator|>
literal|1
condition|)
name|new_links
operator|->
name|datum
operator|=
operator|(
name|page_type
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|vp
operator|->
name|object_size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|new_links
operator|->
name|datum
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_varray
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_varray
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
name|new_links
operator|->
name|start_index
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|vp
operator|->
name|objects_last_page
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|first
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
comment|/* first allocation? */
name|vp
operator|->
name|first
operator|=
name|vp
operator|->
name|last
operator|=
name|new_links
expr_stmt|;
else|else
block|{
comment|/* 2nd or greater allocation */
name|new_links
operator|->
name|prev
operator|=
name|vp
operator|->
name|last
expr_stmt|;
name|vp
operator|->
name|last
operator|->
name|next
operator|=
name|new_links
expr_stmt|;
name|vp
operator|->
name|last
operator|=
name|new_links
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a string (and null pad) to one of the string tables.  */
end_comment

begin_function
specifier|static
name|symint_t
name|add_string
parameter_list|(
name|varray_t
modifier|*
name|vp
parameter_list|,
comment|/* string obstack */
name|struct
name|hash_control
modifier|*
name|hash_tbl
parameter_list|,
comment|/* ptr to hash table */
specifier|const
name|char
modifier|*
name|str
parameter_list|,
comment|/* string */
name|shash_t
modifier|*
modifier|*
name|ret_hash
comment|/* return hash pointer */
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|register
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|PAGE_USIZE
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"string too big (%lu bytes)"
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hash_ptr
operator|=
operator|(
name|shash_t
operator|*
operator|)
name|hash_find
argument_list|(
name|hash_tbl
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|+
name|len
operator|>=
name|PAGE_USIZE
condition|)
block|{
name|vp
operator|->
name|num_allocated
operator|=
operator|(
operator|(
name|vp
operator|->
name|num_allocated
operator|+
name|PAGE_USIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_USIZE
operator|)
operator|*
name|PAGE_USIZE
expr_stmt|;
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|hash_ptr
operator|=
name|allocate_shash
argument_list|()
expr_stmt|;
name|hash_ptr
operator|->
name|indx
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|hash_ptr
operator|->
name|string
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|byte
index|[
name|vp
operator|->
name|objects_last_page
index|]
expr_stmt|;
name|vp
operator|->
name|objects_last_page
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|vp
operator|->
name|num_allocated
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|hash_ptr
operator|->
name|string
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|hash_tbl
argument_list|,
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hash_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into string hash table: %s"
argument_list|)
argument_list|,
name|str
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_hash
operator|!=
operator|(
name|shash_t
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|ret_hash
operator|=
name|hash_ptr
expr_stmt|;
return|return
name|hash_ptr
operator|->
name|indx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add debugging information for a symbol.  */
end_comment

begin_function
specifier|static
name|localsym_t
modifier|*
name|add_ecoff_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
comment|/* symbol name */
name|st_t
name|type
parameter_list|,
comment|/* symbol type */
name|sc_t
name|storage
parameter_list|,
comment|/* storage class */
name|symbolS
modifier|*
name|sym_value
parameter_list|,
comment|/* associated symbol.  */
name|bfd_vma
name|addend
parameter_list|,
comment|/* addend to sym_value.  */
name|symint_t
name|value
parameter_list|,
comment|/* value of symbol */
name|symint_t
name|indx
comment|/* index to local/aux. syms */
parameter_list|)
block|{
name|localsym_t
modifier|*
name|psym
decl_stmt|;
specifier|register
name|scope_t
modifier|*
name|pscope
decl_stmt|;
specifier|register
name|thead_t
modifier|*
name|ptag_head
decl_stmt|;
specifier|register
name|tag_t
modifier|*
name|ptag
decl_stmt|;
specifier|register
name|tag_t
modifier|*
name|ptag_next
decl_stmt|;
specifier|register
name|varray_t
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|scope_delta
init|=
literal|0
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
init|=
operator|(
name|shash_t
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|cur_file_ptr
operator|->
name|symbols
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|psym
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|sym
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|str
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|&&
name|sym_value
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|psym
operator|->
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|sym_value
argument_list|)
expr_stmt|;
else|else
name|psym
operator|->
name|name
operator|=
name|str
expr_stmt|;
name|psym
operator|->
name|as_sym
operator|=
name|sym_value
expr_stmt|;
if|if
condition|(
name|sym_value
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|symbol_get_obj
argument_list|(
name|sym_value
argument_list|)
operator|->
name|ecoff_symbol
operator|=
name|psym
expr_stmt|;
name|psym
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|psym
operator|->
name|file_ptr
operator|=
name|cur_file_ptr
expr_stmt|;
name|psym
operator|->
name|proc_ptr
operator|=
name|cur_proc_ptr
expr_stmt|;
name|psym
operator|->
name|begin_ptr
operator|=
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|psym
operator|->
name|index_ptr
operator|=
operator|(
name|aux_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|psym
operator|->
name|forward_ref
operator|=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|psym
operator|->
name|sym_index
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psym
operator|->
name|ecoff_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|=
operator|(
name|unsigned
operator|)
name|type
expr_stmt|;
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|=
operator|(
name|unsigned
operator|)
name|storage
expr_stmt|;
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|indx
expr_stmt|;
comment|/* If there is an associated symbol, we wait until the end of the      assembly before deciding where to put the name (it may be just an      external symbol).  Otherwise, this is just a debugging symbol and      the name should go with the current file.  */
if|if
condition|(
name|sym_value
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|iss
operator|=
operator|(
operator|(
name|str
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|)
condition|?
literal|0
else|:
name|add_string
argument_list|(
operator|&
name|cur_file_ptr
operator|->
name|strings
argument_list|,
name|cur_file_ptr
operator|->
name|str_hash
argument_list|,
name|str
argument_list|,
operator|&
name|hash_ptr
argument_list|)
operator|)
expr_stmt|;
operator|++
name|vp
operator|->
name|num_allocated
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|psym
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|)
condition|)
return|return
name|psym
return|;
comment|/* Save the symbol within the hash table if this is a static      item, and it has a name.  */
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|type
operator|==
name|st_Global
operator|||
name|type
operator|==
name|st_Static
operator|||
name|type
operator|==
name|st_Label
operator|||
name|type
operator|==
name|st_Proc
operator|||
name|type
operator|==
name|st_StaticProc
operator|)
condition|)
name|hash_ptr
operator|->
name|sym_ptr
operator|=
name|psym
expr_stmt|;
comment|/* push or pop a scope if appropriate.  */
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|st_File
case|:
comment|/* beginning of file */
case|case
name|st_Proc
case|:
comment|/* procedure */
case|case
name|st_StaticProc
case|:
comment|/* static procedure */
case|case
name|st_Block
case|:
comment|/* begin scope */
name|pscope
operator|=
name|allocate_scope
argument_list|()
expr_stmt|;
name|pscope
operator|->
name|prev
operator|=
name|cur_file_ptr
operator|->
name|cur_scope
expr_stmt|;
name|pscope
operator|->
name|lsym
operator|=
name|psym
expr_stmt|;
name|pscope
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cur_file_ptr
operator|->
name|cur_scope
operator|=
name|pscope
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|st_File
condition|)
name|scope_delta
operator|=
literal|1
expr_stmt|;
comment|/* For every block type except file, struct, union, or          enumeration blocks, push a level on the tag stack.  We omit          file types, so that tags can span file boundaries.  */
if|if
condition|(
name|type
operator|!=
name|st_File
operator|&&
name|storage
operator|!=
name|sc_Info
condition|)
block|{
name|ptag_head
operator|=
name|allocate_thead
argument_list|()
expr_stmt|;
name|ptag_head
operator|->
name|first_tag
operator|=
literal|0
expr_stmt|;
name|ptag_head
operator|->
name|prev
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
expr_stmt|;
block|}
break|break;
case|case
name|st_End
case|:
name|pscope
operator|=
name|cur_file_ptr
operator|->
name|cur_scope
expr_stmt|;
if|if
condition|(
name|pscope
operator|==
operator|(
name|scope_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many st_End's"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|st_t
name|begin_type
init|=
operator|(
name|st_t
operator|)
name|pscope
operator|->
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
decl_stmt|;
name|psym
operator|->
name|begin_ptr
operator|=
name|pscope
operator|->
name|lsym
expr_stmt|;
if|if
condition|(
name|begin_type
operator|!=
name|st_File
condition|)
name|scope_delta
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Except for file, structure, union, or enumeration end 	     blocks remove all tags created within this scope.  */
if|if
condition|(
name|begin_type
operator|!=
name|st_File
operator|&&
name|storage
operator|!=
name|sc_Info
condition|)
block|{
name|ptag_head
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|ptag
operator|=
name|ptag_head
operator|->
name|first_tag
init|;
name|ptag
operator|!=
operator|(
name|tag_t
operator|*
operator|)
name|NULL
condition|;
name|ptag
operator|=
name|ptag_next
control|)
block|{
if|if
condition|(
name|ptag
operator|->
name|forward_ref
operator|!=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
condition|)
name|add_unknown_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
name|ptag_next
operator|=
name|ptag
operator|->
name|same_block
expr_stmt|;
name|ptag
operator|->
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|ptag
operator|->
name|same_name
expr_stmt|;
name|free_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
block|}
name|free_thead
argument_list|(
name|ptag_head
argument_list|)
expr_stmt|;
block|}
name|cur_file_ptr
operator|->
name|cur_scope
operator|=
name|pscope
operator|->
name|prev
expr_stmt|;
comment|/* block begin gets next sym #.  This is set when we know 	     the symbol index value.  */
comment|/* Functions push two or more aux words as follows: 	     1st word: index+1 of the end symbol (filled in later). 	     2nd word: type of the function (plus any aux words needed). 	     Also, tie the external pointer back to the function begin symbol.  */
if|if
condition|(
name|begin_type
operator|!=
name|st_File
operator|&&
name|begin_type
operator|!=
name|st_Block
condition|)
block|{
name|symint_t
name|ty
decl_stmt|;
name|varray_t
modifier|*
name|svp
init|=
operator|&
name|cur_file_ptr
operator|->
name|aux_syms
decl_stmt|;
name|pscope
operator|->
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|add_aux_sym_symint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pscope
operator|->
name|lsym
operator|->
name|index_ptr
operator|=
operator|&
name|svp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|svp
operator|->
name|objects_last_page
operator|-
literal|1
index|]
expr_stmt|;
name|ty
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|last_func_type_info
argument_list|,
name|hash_no
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* This seems to be unnecessary.  I'm not even sure what it is  * intended to do.  It's from mips-tfile.  *	      if (last_func_sym_value != (symbolS *) NULL)  *		{  *		  last_func_sym_value->ifd = cur_file_ptr->file_index;  *		  last_func_sym_value->index = ty;  *		}  */
block|}
name|free_scope
argument_list|(
name|pscope
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_file_ptr
operator|->
name|nested_scopes
operator|+=
name|scope_delta
expr_stmt|;
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
if|if
condition|(
name|debug
operator|&&
name|type
operator|!=
name|st_File
operator|&&
operator|(
name|debug
operator|>
literal|2
operator|||
name|type
operator|==
name|st_Block
operator|||
name|type
operator|==
name|st_End
operator|||
name|type
operator|==
name|st_Proc
operator|||
name|type
operator|==
name|st_StaticProc
operator|)
condition|)
block|{
name|char
modifier|*
name|sc_str
init|=
name|sc_to_string
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|char
modifier|*
name|st_str
init|=
name|st_to_string
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
name|cur_file_ptr
operator|->
name|nested_scopes
operator|+
operator|(
name|scope_delta
operator|<
literal|0
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlsym\tv= %10ld, depth= %2d, sc= %-12s"
argument_list|,
name|value
argument_list|,
name|depth
argument_list|,
name|sc_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_start
operator|&&
name|str_end_p1
operator|-
name|str_start
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %-11s name= %.*s\n"
argument_list|,
name|st_str
argument_list|,
name|str_end_p1
operator|-
name|str_start
argument_list|,
name|str_start
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|len
init|=
name|strlen
argument_list|(
name|st_str
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %.*s\n"
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|st_str
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|psym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an auxiliary symbol (passing a symint).  This is actually used    for integral aux types, not just symints.  */
end_comment

begin_function
specifier|static
name|symint_t
name|add_aux_sym_symint
parameter_list|(
name|symint_t
name|aux_word
comment|/* auxiliary information word */
parameter_list|)
block|{
specifier|register
name|varray_t
modifier|*
name|vp
decl_stmt|;
specifier|register
name|aux_t
modifier|*
name|aux_ptr
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|cur_file_ptr
operator|->
name|aux_syms
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|aux_ptr
operator|->
name|type
operator|=
name|aux_isym
expr_stmt|;
name|aux_ptr
operator|->
name|data
operator|.
name|isym
operator|=
name|aux_word
expr_stmt|;
return|return
name|vp
operator|->
name|num_allocated
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Add an auxiliary symbol (passing a file/symbol index combo).  */
end_comment

begin_function
specifier|static
name|symint_t
name|add_aux_sym_rndx
parameter_list|(
name|int
name|file_index
parameter_list|,
name|symint_t
name|sym_index
parameter_list|)
block|{
specifier|register
name|varray_t
modifier|*
name|vp
decl_stmt|;
specifier|register
name|aux_t
modifier|*
name|aux_ptr
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|cur_file_ptr
operator|->
name|aux_syms
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|aux_ptr
operator|->
name|type
operator|=
name|aux_rndx
expr_stmt|;
name|aux_ptr
operator|->
name|data
operator|.
name|rndx
operator|.
name|rfd
operator|=
name|file_index
expr_stmt|;
name|aux_ptr
operator|->
name|data
operator|.
name|rndx
operator|.
name|index
operator|=
name|sym_index
expr_stmt|;
return|return
name|vp
operator|->
name|num_allocated
operator|++
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an auxiliary symbol (passing the basic type and possibly    type qualifiers).  */
end_comment

begin_function
specifier|static
name|symint_t
name|add_aux_sym_tir
parameter_list|(
name|type_info_t
modifier|*
name|t
parameter_list|,
comment|/* current type information */
name|hash_state_t
name|state
parameter_list|,
comment|/* whether to hash type or not */
name|thash_t
modifier|*
modifier|*
name|hash_tbl
comment|/* pointer to hash table to use */
parameter_list|)
block|{
specifier|register
name|varray_t
modifier|*
name|vp
decl_stmt|;
specifier|register
name|aux_t
modifier|*
name|aux_ptr
decl_stmt|;
specifier|static
name|AUXU
name|init_aux
decl_stmt|;
name|symint_t
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|AUXU
name|aux
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|cur_file_ptr
operator|->
name|aux_syms
expr_stmt|;
name|aux
operator|=
name|init_aux
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|bt
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|basic_type
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|continued
operator|=
literal|0
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|fBitfield
operator|=
name|t
operator|->
name|bitfield
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq0
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|0
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq1
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|1
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq2
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|2
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq3
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|3
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq4
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|4
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq5
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|5
index|]
expr_stmt|;
comment|/* For anything that adds additional information, we must not hash,      so check here, and reset our state.  */
if|if
condition|(
name|state
operator|!=
name|hash_no
operator|&&
operator|(
name|t
operator|->
name|type_qualifiers
index|[
literal|0
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|1
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|2
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|3
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|4
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|5
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Struct
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Union
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Enum
operator|||
name|t
operator|->
name|bitfield
operator|||
name|t
operator|->
name|num_dims
operator|>
literal|0
operator|)
condition|)
name|state
operator|=
name|hash_no
expr_stmt|;
comment|/* See if we can hash this type, and save some space, but some types      can't be hashed (because they contain arrays or continuations),      and others can be put into the hash list, but cannot use existing      types because other aux entries precede this one.  */
if|if
condition|(
name|state
operator|!=
name|hash_no
condition|)
block|{
specifier|register
name|thash_t
modifier|*
name|hash_ptr
decl_stmt|;
specifier|register
name|symint_t
name|hi
decl_stmt|;
name|hi
operator|=
name|aux
operator|.
name|isym
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|hi
operator|%=
name|THASH_SIZE
expr_stmt|;
for|for
control|(
name|hash_ptr
operator|=
name|hash_tbl
index|[
name|hi
index|]
init|;
name|hash_ptr
operator|!=
operator|(
name|thash_t
operator|*
operator|)
literal|0
condition|;
name|hash_ptr
operator|=
name|hash_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|aux
operator|.
name|isym
operator|==
name|hash_ptr
operator|->
name|type
operator|.
name|isym
condition|)
break|break;
block|}
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|thash_t
operator|*
operator|)
name|NULL
operator|&&
name|state
operator|==
name|hash_yes
condition|)
return|return
name|hash_ptr
operator|->
name|indx
return|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|thash_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|hash_ptr
operator|=
name|allocate_thash
argument_list|()
expr_stmt|;
name|hash_ptr
operator|->
name|next
operator|=
name|hash_tbl
index|[
name|hi
index|]
expr_stmt|;
name|hash_ptr
operator|->
name|type
operator|=
name|aux
expr_stmt|;
name|hash_ptr
operator|->
name|indx
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|hash_tbl
index|[
name|hi
index|]
operator|=
name|hash_ptr
expr_stmt|;
block|}
block|}
comment|/* Everything is set up, add the aux symbol.  */
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|aux_ptr
operator|->
name|type
operator|=
name|aux_tir
expr_stmt|;
name|aux_ptr
operator|->
name|data
operator|=
name|aux
expr_stmt|;
name|ret
operator|=
name|vp
operator|->
name|num_allocated
operator|++
expr_stmt|;
comment|/* Add bitfield length if it exists.       NOTE:  Mips documentation claims bitfield goes at the end of the      AUX record, but the DECstation compiler emits it here.      (This would only make a difference for enum bitfields.)       Also note:  We use the last size given since gcc may emit 2      for an enum bitfield.  */
if|if
condition|(
name|t
operator|->
name|bitfield
condition|)
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|symint_t
operator|)
name|t
operator|->
name|sizes
index|[
name|t
operator|->
name|num_sizes
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Add tag information if needed.  Structure, union, and enum      references add 2 aux symbols: a [file index, symbol index]      pointer to the structure type, and the current file index.  */
if|if
condition|(
name|t
operator|->
name|basic_type
operator|==
name|bt_Struct
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Union
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Enum
condition|)
block|{
specifier|register
name|symint_t
name|file_index
init|=
name|t
operator|->
name|tag_ptr
operator|->
name|ifd
decl_stmt|;
specifier|register
name|localsym_t
modifier|*
name|sym
init|=
name|t
operator|->
name|tag_ptr
operator|->
name|sym
decl_stmt|;
specifier|register
name|forward_t
modifier|*
name|forward_ref
init|=
name|allocate_forward
argument_list|()
decl_stmt|;
if|if
condition|(
name|sym
operator|!=
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|forward_ref
operator|->
name|next
operator|=
name|sym
operator|->
name|forward_ref
expr_stmt|;
name|sym
operator|->
name|forward_ref
operator|=
name|forward_ref
expr_stmt|;
block|}
else|else
block|{
name|forward_ref
operator|->
name|next
operator|=
name|t
operator|->
name|tag_ptr
operator|->
name|forward_ref
expr_stmt|;
name|t
operator|->
name|tag_ptr
operator|->
name|forward_ref
operator|=
name|forward_ref
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|indexNil
argument_list|)
expr_stmt|;
name|forward_ref
operator|->
name|index_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|file_index
argument_list|)
expr_stmt|;
name|forward_ref
operator|->
name|ifd_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* Add information about array bounds if they exist.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|num_dims
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|cur_file_ptr
operator|->
name|int_type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|cur_file_ptr
operator|->
name|file_index
argument_list|)
expr_stmt|;
comment|/* file index*/
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* low bound */
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|t
operator|->
name|dimensions
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* high bound*/
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|t
operator|->
name|dimensions
index|[
name|i
index|]
operator|==
literal|0
operator|)
comment|/* stride */
condition|?
literal|0
else|:
operator|(
name|t
operator|->
name|sizes
index|[
name|i
index|]
operator|*
literal|8
operator|)
operator|/
name|t
operator|->
name|dimensions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* NOTE:  Mips documentation claims that the bitfield width goes here.      But it needs to be emitted earlier.  */
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a tag to the tag table (unless it already exists).  */
end_comment

begin_function
specifier|static
name|tag_t
modifier|*
name|get_tag
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
comment|/* tag name */
name|localsym_t
modifier|*
name|sym
parameter_list|,
comment|/* tag start block */
name|bt_t
name|basic_type
comment|/* bt_Struct, bt_Union, or bt_Enum */
parameter_list|)
block|{
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|hash_ptr
operator|=
operator|(
name|shash_t
operator|*
operator|)
name|hash_find
argument_list|(
name|tag_hash
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
name|NULL
operator|&&
name|hash_ptr
operator|->
name|tag_ptr
operator|!=
operator|(
name|tag_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|tag_ptr
operator|=
name|hash_ptr
operator|->
name|tag_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|tag_ptr
operator|->
name|basic_type
operator|=
name|basic_type
expr_stmt|;
name|tag_ptr
operator|->
name|ifd
operator|=
name|cur_file_ptr
operator|->
name|file_index
expr_stmt|;
name|tag_ptr
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
block|}
return|return
name|tag_ptr
return|;
block|}
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|perm
decl_stmt|;
name|perm
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|hash_ptr
operator|=
name|allocate_shash
argument_list|()
expr_stmt|;
name|err
operator|=
name|hash_insert
argument_list|(
name|tag_hash
argument_list|,
name|perm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hash_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into tag hash table: %s"
argument_list|)
argument_list|,
name|tag
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|hash_ptr
operator|->
name|string
operator|=
name|perm
expr_stmt|;
block|}
name|tag_ptr
operator|=
name|allocate_tag
argument_list|()
expr_stmt|;
name|tag_ptr
operator|->
name|forward_ref
operator|=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|tag_ptr
operator|->
name|hash_ptr
operator|=
name|hash_ptr
expr_stmt|;
name|tag_ptr
operator|->
name|same_name
operator|=
name|hash_ptr
operator|->
name|tag_ptr
expr_stmt|;
name|tag_ptr
operator|->
name|basic_type
operator|=
name|basic_type
expr_stmt|;
name|tag_ptr
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|tag_ptr
operator|->
name|ifd
operator|=
operator|(
operator|(
name|sym
operator|==
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
operator|)
condition|?
operator|(
name|symint_t
operator|)
operator|-
literal|1
else|:
name|cur_file_ptr
operator|->
name|file_index
operator|)
expr_stmt|;
name|tag_ptr
operator|->
name|same_block
operator|=
name|cur_tag_head
operator|->
name|first_tag
expr_stmt|;
name|cur_tag_head
operator|->
name|first_tag
operator|=
name|tag_ptr
expr_stmt|;
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|tag_ptr
expr_stmt|;
return|return
name|tag_ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an unknown {struct, union, enum} tag.  */
end_comment

begin_function
specifier|static
name|void
name|add_unknown_tag
parameter_list|(
name|tag_t
modifier|*
name|ptag
comment|/* pointer to tag information */
parameter_list|)
block|{
name|shash_t
modifier|*
name|hash_ptr
init|=
name|ptag
operator|->
name|hash_ptr
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|hash_ptr
operator|->
name|string
decl_stmt|;
name|localsym_t
modifier|*
name|sym
decl_stmt|;
name|forward_t
modifier|*
modifier|*
name|pf
decl_stmt|;
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|agg_type
init|=
literal|"{unknown aggregate type}"
decl_stmt|;
switch|switch
condition|(
name|ptag
operator|->
name|basic_type
condition|)
block|{
case|case
name|bt_Struct
case|:
name|agg_type
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|bt_Union
case|:
name|agg_type
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|bt_Enum
case|:
name|agg_type
operator|=
literal|"enum"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown %s %.*s found\n"
argument_list|,
name|agg_type
argument_list|,
name|hash_ptr
operator|->
name|len
argument_list|,
name|name_start
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sym
operator|=
name|add_ecoff_symbol
argument_list|(
name|name
argument_list|,
name|st_Block
argument_list|,
name|sc_Info
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
name|name
argument_list|,
name|st_End
argument_list|,
name|sc_Info
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
operator|&
name|sym
operator|->
name|forward_ref
init|;
operator|*
name|pf
operator|!=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pf
operator|=
name|ptag
operator|->
name|forward_ref
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a procedure to the current file's list of procedures, and record    this is the current procedure.  */
end_comment

begin_function
specifier|static
name|void
name|add_procedure
parameter_list|(
name|char
modifier|*
name|func
comment|/* func name */
parameter_list|)
block|{
specifier|register
name|varray_t
modifier|*
name|vp
decl_stmt|;
specifier|register
name|proc_t
modifier|*
name|new_proc_ptr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
if|if
condition|(
name|debug
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"no current file pointer"
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|cur_file_ptr
operator|->
name|procs
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|=
name|new_proc_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|proc
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|first_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
name|first_proc_ptr
operator|=
name|new_proc_ptr
expr_stmt|;
name|vp
operator|->
name|num_allocated
operator|++
expr_stmt|;
name|new_proc_ptr
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|-
literal|1
expr_stmt|;
name|new_proc_ptr
operator|->
name|pdr
operator|.
name|iline
operator|=
operator|-
literal|1
expr_stmt|;
name|new_proc_ptr
operator|->
name|pdr
operator|.
name|lnLow
operator|=
operator|-
literal|1
expr_stmt|;
name|new_proc_ptr
operator|->
name|pdr
operator|.
name|lnHigh
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set the BSF_FUNCTION flag for the symbol.  */
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
comment|/* Push the start of the function.  */
name|new_proc_ptr
operator|->
name|sym
operator|=
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_Proc
argument_list|,
name|sc_Text
argument_list|,
name|sym
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|++
name|proc_cnt
expr_stmt|;
comment|/* Fill in the linenos preceding the .ent, if any.  */
if|if
condition|(
name|noproc_lineno
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|lineno_list_t
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|noproc_lineno
init|;
name|l
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|l
operator|->
name|proc
operator|=
name|new_proc_ptr
expr_stmt|;
operator|*
name|last_lineno_ptr
operator|=
name|noproc_lineno
expr_stmt|;
while|while
condition|(
operator|*
name|last_lineno_ptr
operator|!=
name|NULL
condition|)
block|{
name|last_lineno
operator|=
operator|*
name|last_lineno_ptr
expr_stmt|;
name|last_lineno_ptr
operator|=
operator|&
name|last_lineno
operator|->
name|next
expr_stmt|;
block|}
name|noproc_lineno
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|symbolS
modifier|*
name|ecoff_get_cur_proc_sym
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cur_proc_ptr
condition|?
name|cur_proc_ptr
operator|->
name|sym
operator|->
name|as_sym
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new filename, and set up all of the file relative    virtual arrays (strings, symbols, aux syms, etc.).  Record    where the current file structure lives.  */
end_comment

begin_function
specifier|static
name|void
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|int
name|indx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fake
parameter_list|)
block|{
specifier|register
name|int
name|first_ch
decl_stmt|;
specifier|register
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfile\t%.*s\n"
argument_list|,
name|len
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the file name is NULL, then no .file symbol appeared, and we      want to use the actual file name.  */
if|if
condition|(
name|file_name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|first_file
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"fake .file after real one"
argument_list|)
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|file_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|file
expr_stmt|;
comment|/* Automatically generate ECOFF debugging information, since I          think that's what other ECOFF assemblers do.  We don't do          this if we see a .file directive with a string, since that          implies that some sort of debugging information is being          provided.  */
if|if
condition|(
operator|!
name|symbol_table_frozen
operator|&&
name|debug_type
operator|==
name|DEBUG_UNSPECIFIED
condition|)
name|debug_type
operator|=
name|DEBUG_ECOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_UNSPECIFIED
condition|)
name|debug_type
operator|=
name|DEBUG_NONE
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_file
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_stabs_filename
operator|=
name|file_name
expr_stmt|;
comment|/* If we're creating stabs, then we don't actually make a new FDR.      Instead, we just create a stabs symbol.  */
if|if
condition|(
name|stabs_seen
condition|)
block|{
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
name|file_name
argument_list|,
name|st_Nil
argument_list|,
name|sc_Nil
argument_list|,
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|ECOFF_MARK_STAB
argument_list|(
name|N_SOL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|first_ch
operator|=
operator|*
name|file_name
expr_stmt|;
comment|/* FIXME: We can't safely merge files which have line number      information (fMerge will be zero in this case).  Otherwise, we      get incorrect line number debugging info.  See for instance      ecoff_build_lineno, which will end up setting all file->fdr.*      fields multiple times, resulting in incorrect debug info.  In      order to make this work right, all line number and symbol info      for the same source file has to be adjacent in the object file,      so that a single file descriptor can be used to point to them.      This would require maintaining file specific lists of line      numbers and symbols for each file, so that they can be merged      together (or output together) when two .file pseudo-ops are      merged into one file descriptor.  */
comment|/* See if the file has already been created.  */
for|for
control|(
name|fil_ptr
operator|=
name|first_file
init|;
name|fil_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|;
name|fil_ptr
operator|=
name|fil_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|first_ch
operator|==
name|fil_ptr
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|fil_ptr
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|fil_ptr
operator|->
name|fdr
operator|.
name|fMerge
condition|)
block|{
name|cur_file_ptr
operator|=
name|fil_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|fake
condition|)
name|cur_file_ptr
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is a new file, create it.  */
if|if
condition|(
name|fil_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|file_desc
operator|.
name|objects_last_page
operator|==
name|file_desc
operator|.
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
operator|&
name|file_desc
argument_list|)
expr_stmt|;
name|fil_ptr
operator|=
name|cur_file_ptr
operator|=
operator|&
name|file_desc
operator|.
name|last
operator|->
name|datum
operator|->
name|file
index|[
name|file_desc
operator|.
name|objects_last_page
operator|++
index|]
expr_stmt|;
operator|*
name|fil_ptr
operator|=
name|init_file
expr_stmt|;
name|fil_ptr
operator|->
name|file_index
operator|=
name|current_file_idx
operator|++
expr_stmt|;
operator|++
name|file_desc
operator|.
name|num_allocated
expr_stmt|;
name|fil_ptr
operator|->
name|fake
operator|=
name|fake
expr_stmt|;
comment|/* Allocate the string hash table.  */
name|fil_ptr
operator|->
name|str_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Make sure 0 byte in string table is null  */
name|add_string
argument_list|(
operator|&
name|fil_ptr
operator|->
name|strings
argument_list|,
name|fil_ptr
operator|->
name|str_hash
argument_list|,
literal|""
argument_list|,
operator|(
name|shash_t
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|>
name|PAGE_USIZE
operator|-
literal|2
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"filename goes over one page boundary"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push the start of the filename. We assume that the filename          will be stored at string offset 1.  */
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
name|file_name
argument_list|,
name|st_File
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|rss
operator|=
literal|1
expr_stmt|;
name|fil_ptr
operator|->
name|name
operator|=
operator|&
name|fil_ptr
operator|->
name|strings
operator|.
name|last
operator|->
name|datum
operator|->
name|byte
index|[
literal|1
index|]
expr_stmt|;
comment|/* Update the linked list of file descriptors.  */
operator|*
name|last_file_ptr
operator|=
name|fil_ptr
expr_stmt|;
name|last_file_ptr
operator|=
operator|&
name|fil_ptr
operator|->
name|next_file
expr_stmt|;
comment|/* Add void& int types to the file (void should be first to catch          errant 0's within the index fields).  */
name|fil_ptr
operator|->
name|void_type
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|void_type_info
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fil_ptr
operator|->
name|int_type
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|int_type_info
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called when the assembler notices a preprocessor    directive switching to a new file.  This will not happen in    compiler output, only in hand coded assembler.  */
end_comment

begin_function
name|void
name|ecoff_new_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|appfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|cur_file_ptr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cur_file_ptr
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|add_file
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a hand coded assembler file, so automatically turn on      debugging information.  */
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_UNSPECIFIED
condition|)
name|debug_type
operator|=
name|DEBUG_ECOFF
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
end_ifdef

begin_comment
comment|/* Convert storage class to string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sc_to_string
parameter_list|(
name|storage_class
parameter_list|)
name|sc_t
name|storage_class
decl_stmt|;
block|{
switch|switch
condition|(
name|storage_class
condition|)
block|{
case|case
name|sc_Nil
case|:
return|return
literal|"Nil,"
return|;
case|case
name|sc_Text
case|:
return|return
literal|"Text,"
return|;
case|case
name|sc_Data
case|:
return|return
literal|"Data,"
return|;
case|case
name|sc_Bss
case|:
return|return
literal|"Bss,"
return|;
case|case
name|sc_Register
case|:
return|return
literal|"Register,"
return|;
case|case
name|sc_Abs
case|:
return|return
literal|"Abs,"
return|;
case|case
name|sc_Undefined
case|:
return|return
literal|"Undefined,"
return|;
case|case
name|sc_CdbLocal
case|:
return|return
literal|"CdbLocal,"
return|;
case|case
name|sc_Bits
case|:
return|return
literal|"Bits,"
return|;
case|case
name|sc_CdbSystem
case|:
return|return
literal|"CdbSystem,"
return|;
case|case
name|sc_RegImage
case|:
return|return
literal|"RegImage,"
return|;
case|case
name|sc_Info
case|:
return|return
literal|"Info,"
return|;
case|case
name|sc_UserStruct
case|:
return|return
literal|"UserStruct,"
return|;
case|case
name|sc_SData
case|:
return|return
literal|"SData,"
return|;
case|case
name|sc_SBss
case|:
return|return
literal|"SBss,"
return|;
case|case
name|sc_RData
case|:
return|return
literal|"RData,"
return|;
case|case
name|sc_Var
case|:
return|return
literal|"Var,"
return|;
case|case
name|sc_Common
case|:
return|return
literal|"Common,"
return|;
case|case
name|sc_SCommon
case|:
return|return
literal|"SCommon,"
return|;
case|case
name|sc_VarRegister
case|:
return|return
literal|"VarRegister,"
return|;
case|case
name|sc_Variant
case|:
return|return
literal|"Variant,"
return|;
case|case
name|sc_SUndefined
case|:
return|return
literal|"SUndefined,"
return|;
case|case
name|sc_Init
case|:
return|return
literal|"Init,"
return|;
case|case
name|sc_Max
case|:
return|return
literal|"Max,"
return|;
block|}
return|return
literal|"???,"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
end_ifdef

begin_comment
comment|/* Convert symbol type to string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|st_to_string
parameter_list|(
name|symbol_type
parameter_list|)
name|st_t
name|symbol_type
decl_stmt|;
block|{
switch|switch
condition|(
name|symbol_type
condition|)
block|{
case|case
name|st_Nil
case|:
return|return
literal|"Nil,"
return|;
case|case
name|st_Global
case|:
return|return
literal|"Global,"
return|;
case|case
name|st_Static
case|:
return|return
literal|"Static,"
return|;
case|case
name|st_Param
case|:
return|return
literal|"Param,"
return|;
case|case
name|st_Local
case|:
return|return
literal|"Local,"
return|;
case|case
name|st_Label
case|:
return|return
literal|"Label,"
return|;
case|case
name|st_Proc
case|:
return|return
literal|"Proc,"
return|;
case|case
name|st_Block
case|:
return|return
literal|"Block,"
return|;
case|case
name|st_End
case|:
return|return
literal|"End,"
return|;
case|case
name|st_Member
case|:
return|return
literal|"Member,"
return|;
case|case
name|st_Typedef
case|:
return|return
literal|"Typedef,"
return|;
case|case
name|st_File
case|:
return|return
literal|"File,"
return|;
case|case
name|st_RegReloc
case|:
return|return
literal|"RegReloc,"
return|;
case|case
name|st_Forward
case|:
return|return
literal|"Forward,"
return|;
case|case
name|st_StaticProc
case|:
return|return
literal|"StaticProc,"
return|;
case|case
name|st_Constant
case|:
return|return
literal|"Constant,"
return|;
case|case
name|st_Str
case|:
return|return
literal|"String,"
return|;
case|case
name|st_Number
case|:
return|return
literal|"Number,"
return|;
case|case
name|st_Expr
case|:
return|return
literal|"Expr,"
return|;
case|case
name|st_Type
case|:
return|return
literal|"Type,"
return|;
case|case
name|st_Max
case|:
return|return
literal|"Max,"
return|;
block|}
return|return
literal|"???,"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Parse .begin directives which have a label as the first argument    which gives the location of the start of the block.  */
end_comment

begin_function
name|void
name|ecoff_directive_begin
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin directive without a preceding .file directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin directive without a preceding .ent directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_Block
argument_list|,
name|sc_Text
argument_list|,
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
comment|/* The line number follows, but we don't use it.  */
operator|(
name|void
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .bend directives which have a label as the first argument    which gives the location of the end of the block.  */
end_comment

begin_function
name|void
name|ecoff_directive_bend
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
name|symbolS
modifier|*
name|endsym
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".bend directive without a preceding .file directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".bend directive without a preceding .ent directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* The value is the distance between the .bend directive and the      corresponding symbol.  We fill in the offset when we write out      the symbol.  */
name|endsym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|endsym
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".bend directive names unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
name|endsym
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
comment|/* The line number follows, but we don't use it.  */
operator|(
name|void
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* COFF debugging information is provided as a series of directives    (.def, .scl, etc.).  We build up information as we read the    directives in the following static variables, and file it away when    we reach the .endef directive.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|coff_sym_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_info_t
name|coff_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sc_t
name|coff_storage_class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_t
name|coff_symbol_typ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coff_is_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|coff_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|coff_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|coff_sym_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|coff_sym_addend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coff_inside_enumeration
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a .def directive: start defining a symbol.  */
end_comment

begin_function
name|void
name|ecoff_directive_def
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
name|ecoff_debugging_seen
operator|=
literal|1
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|coff_sym_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".def pseudo-op used inside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"empty symbol name in .def; ignored"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|coff_sym_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|coff_sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_tag
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|coff_tag
argument_list|)
expr_stmt|;
name|coff_sym_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|coff_type
operator|=
name|type_info_init
expr_stmt|;
name|coff_storage_class
operator|=
name|sc_Nil
expr_stmt|;
name|coff_symbol_typ
operator|=
name|st_Nil
expr_stmt|;
name|coff_is_function
operator|=
literal|0
expr_stmt|;
name|coff_tag
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff_value
operator|=
literal|0
expr_stmt|;
name|coff_sym_value
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff_sym_addend
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .dim directive, used to give dimensions for an array.  The    arguments are comma separated numbers.  mips-tfile assumes that    there will not be more than 6 dimensions, and gdb won't read any    more than that anyhow, so I will also make that assumption.  */
end_comment

begin_function
name|void
name|ecoff_directive_dim
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|dimens
index|[
name|N_TQ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_TQ
condition|;
name|i
operator|++
control|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|dimens
index|[
name|i
index|]
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|';'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .dim directive"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|N_TQ
condition|)
operator|--
name|i
expr_stmt|;
comment|/* The dimensions are stored away in reverse order.  */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|coff_type
operator|.
name|num_dims
operator|>=
name|N_TQ
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many .dim entries"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|coff_type
operator|.
name|dimensions
index|[
name|coff_type
operator|.
name|num_dims
index|]
operator|=
name|dimens
index|[
name|i
index|]
expr_stmt|;
operator|++
name|coff_type
operator|.
name|num_dims
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .scl directive, which sets the COFF storage class of the    symbol.  */
end_comment

begin_function
name|void
name|ecoff_directive_scl
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|coff_symbol_typ
operator|=
name|map_coff_sym_type
index|[
name|val
index|]
expr_stmt|;
name|coff_storage_class
operator|=
name|map_coff_storage
index|[
name|val
index|]
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .size directive.  For some reason mips-tfile.c thinks that    .size can have multiple arguments.  We humor it, although gcc will    never generate more than one argument.  */
end_comment

begin_function
name|void
name|ecoff_directive_size
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|sizes
index|[
name|N_TQ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".size pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_TQ
condition|;
name|i
operator|++
control|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|sizes
index|[
name|i
index|]
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|';'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .size directive"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|N_TQ
condition|)
operator|--
name|i
expr_stmt|;
comment|/* The sizes are stored away in reverse order.  */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|coff_type
operator|.
name|num_sizes
operator|>=
name|N_TQ
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many .size entries"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|coff_type
operator|.
name|sizes
index|[
name|coff_type
operator|.
name|num_sizes
index|]
operator|=
name|sizes
index|[
name|i
index|]
expr_stmt|;
operator|++
name|coff_type
operator|.
name|num_sizes
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .type directive, which gives the COFF type of the    symbol.  */
end_comment

begin_function
name|void
name|ecoff_directive_type
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|tq_t
modifier|*
name|tq_ptr
decl_stmt|;
name|tq_t
modifier|*
name|tq_shft
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".type pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|coff_type
operator|.
name|orig_type
operator|=
name|BTYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|coff_type
operator|.
name|basic_type
operator|=
name|map_coff_types
index|[
name|coff_type
operator|.
name|orig_type
index|]
expr_stmt|;
name|tq_ptr
operator|=
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
name|N_TQ
index|]
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|~
name|N_BTMASK
condition|)
block|{
if|if
condition|(
name|tq_ptr
operator|==
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
literal|0
index|]
condition|)
block|{
comment|/* FIXME: We could handle this by setting the continued bit. 	     There would still be a limit: the .type argument can not 	     be infinite.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"the type of %s is too complex; it will be simplified"
argument_list|)
argument_list|,
name|coff_sym_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ISPTR
argument_list|(
name|val
argument_list|)
condition|)
operator|*
operator|--
name|tq_ptr
operator|=
name|tq_Ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFCN
argument_list|(
name|val
argument_list|)
condition|)
operator|*
operator|--
name|tq_ptr
operator|=
name|tq_Proc
expr_stmt|;
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|val
argument_list|)
condition|)
operator|*
operator|--
name|tq_ptr
operator|=
name|tq_Array
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unrecognized .type argument"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|DECREF
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|tq_shft
operator|=
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|tq_ptr
operator|!=
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
name|N_TQ
index|]
condition|)
operator|*
name|tq_shft
operator|++
operator|=
operator|*
name|tq_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|tq_shft
operator|!=
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
literal|0
index|]
operator|&&
name|tq_shft
index|[
operator|-
literal|1
index|]
operator|==
name|tq_Proc
condition|)
block|{
comment|/* If this is a function, ignore it, so that we don't get two          entries (one from the .ent, and one for the .def that          precedes it).  Save the type information so that the end          block can properly add it after the begin block index.  For          MIPS knows what reason, we must strip off the function type          at this point.  */
name|coff_is_function
operator|=
literal|1
expr_stmt|;
name|tq_shft
index|[
operator|-
literal|1
index|]
operator|=
name|tq_Nil
expr_stmt|;
block|}
while|while
condition|(
name|tq_shft
operator|!=
operator|&
name|coff_type
operator|.
name|type_qualifiers
index|[
name|N_TQ
index|]
condition|)
operator|*
name|tq_shft
operator|++
operator|=
name|tq_Nil
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .tag directive, which gives the name of a structure,    union or enum.  */
end_comment

begin_function
name|void
name|ecoff_directive_tag
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|coff_tag
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .val directive, which gives the value of the symbol.  It    may be the name of a static or global symbol.  */
end_comment

begin_function
name|void
name|ecoff_directive_val
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".val pseudo-op used outside of .def/.endef; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".val expression is too copmlex"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|coff_value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
else|else
block|{
name|coff_sym_value
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|coff_sym_addend
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .endef directive, which terminates processing of COFF    debugging information for a symbol.  */
end_comment

begin_function
name|void
name|ecoff_directive_endef
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|symint_t
name|indx
decl_stmt|;
name|localsym_t
modifier|*
name|sym
decl_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|coff_sym_name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".endef pseudo-op used before .def; ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|coff_sym_name
expr_stmt|;
name|coff_sym_name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* If the symbol is a static or external, we have already gotten the      appropriate type and class, so make sure we don't override those      values.  This is needed because there are some type and classes      that are not in COFF, such as short data, etc.  */
if|if
condition|(
name|coff_sym_value
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|coff_symbol_typ
operator|=
name|st_Nil
expr_stmt|;
name|coff_storage_class
operator|=
name|sc_Nil
expr_stmt|;
block|}
name|coff_type
operator|.
name|extra_sizes
operator|=
name|coff_tag
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|coff_type
operator|.
name|num_dims
operator|>
literal|0
condition|)
block|{
name|int
name|diff
init|=
name|coff_type
operator|.
name|num_dims
operator|-
name|coff_type
operator|.
name|num_sizes
decl_stmt|;
name|int
name|i
init|=
name|coff_type
operator|.
name|num_dims
operator|-
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|coff_type
operator|.
name|num_sizes
operator|!=
literal|1
operator|||
name|diff
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bad COFF debugging information"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is an array, make sure the same number of dimensions          and sizes were passed, creating extra sizes for multiply          dimensioned arrays if not passed.  */
name|coff_type
operator|.
name|extra_sizes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
name|j
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|coff_type
operator|.
name|sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|coff_type
operator|.
name|sizes
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|coff_type
operator|.
name|sizes
index|[
name|j
index|]
operator|=
operator|(
operator|(
operator|(
name|j
operator|-
name|diff
operator|)
operator|>=
literal|0
operator|)
condition|?
name|coff_type
operator|.
name|sizes
index|[
name|j
operator|-
name|diff
index|]
else|:
literal|0
operator|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|coff_type
operator|.
name|num_sizes
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|coff_type
operator|.
name|sizes
index|[
name|i
index|]
operator|=
operator|(
name|coff_type
operator|.
name|dimensions
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|coff_type
operator|.
name|sizes
index|[
name|i
operator|+
literal|1
index|]
operator|/
name|coff_type
operator|.
name|dimensions
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|coff_symbol_typ
operator|==
name|st_Member
operator|&&
name|coff_type
operator|.
name|num_sizes
operator|-
name|coff_type
operator|.
name|extra_sizes
operator|==
literal|1
condition|)
block|{
comment|/* Is this a bitfield?  This is indicated by a structure member          having a size field that isn't an array.  */
name|coff_type
operator|.
name|bitfield
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Except for enumeration members& begin/ending of scopes, put the      type word in the aux. symbol table.  */
if|if
condition|(
name|coff_symbol_typ
operator|==
name|st_Block
operator|||
name|coff_symbol_typ
operator|==
name|st_End
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|coff_inside_enumeration
condition|)
name|indx
operator|=
name|cur_file_ptr
operator|->
name|void_type
expr_stmt|;
else|else
block|{
if|if
condition|(
name|coff_type
operator|.
name|basic_type
operator|==
name|bt_Struct
operator|||
name|coff_type
operator|.
name|basic_type
operator|==
name|bt_Union
operator|||
name|coff_type
operator|.
name|basic_type
operator|==
name|bt_Enum
condition|)
block|{
if|if
condition|(
name|coff_tag
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"no tag specified for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|coff_type
operator|.
name|tag_ptr
operator|=
name|get_tag
argument_list|(
name|coff_tag
argument_list|,
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
argument_list|,
name|coff_type
operator|.
name|basic_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coff_is_function
condition|)
block|{
name|last_func_type_info
operator|=
name|coff_type
expr_stmt|;
name|last_func_sym_value
operator|=
name|coff_sym_value
expr_stmt|;
return|return;
block|}
name|indx
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|coff_type
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Do any last minute adjustments that are necessary.  */
switch|switch
condition|(
name|coff_symbol_typ
condition|)
block|{
default|default:
break|break;
comment|/* For the beginning of structs, unions, and enumerations, the          size info needs to be passed in the value field.  */
case|case
name|st_Block
case|:
if|if
condition|(
name|coff_type
operator|.
name|num_sizes
operator|-
name|coff_type
operator|.
name|num_dims
operator|-
name|coff_type
operator|.
name|extra_sizes
operator|!=
literal|1
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bad COFF debugging information"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|coff_value
operator|=
name|coff_type
operator|.
name|sizes
index|[
literal|0
index|]
expr_stmt|;
name|coff_inside_enumeration
operator|=
operator|(
name|coff_type
operator|.
name|orig_type
operator|==
name|T_ENUM
operator|)
expr_stmt|;
break|break;
comment|/* For the end of structs, unions, and enumerations, omit the          name which is always ".eos".  This needs to be done last, so          that any error reporting above gives the correct name.  */
case|case
name|st_End
case|:
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff_value
operator|=
literal|0
expr_stmt|;
name|coff_inside_enumeration
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Members of structures and unions that aren't bitfields, need          to adjust the value from a byte offset to a bit offset.          Members of enumerations do not have the value adjusted, and          can be distinguished by indx == indexNil.  For enumerations,          update the maximum enumeration value.  */
case|case
name|st_Member
case|:
if|if
condition|(
operator|!
name|coff_type
operator|.
name|bitfield
operator|&&
operator|!
name|coff_inside_enumeration
condition|)
name|coff_value
operator|*=
literal|8
expr_stmt|;
break|break;
block|}
comment|/* Add the symbol.  */
name|sym
operator|=
name|add_ecoff_symbol
argument_list|(
name|name
argument_list|,
name|coff_symbol_typ
argument_list|,
name|coff_storage_class
argument_list|,
name|coff_sym_value
argument_list|,
name|coff_sym_addend
argument_list|,
operator|(
name|symint_t
operator|)
name|coff_value
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* deal with struct, union, and enum tags.  */
if|if
condition|(
name|coff_symbol_typ
operator|==
name|st_Block
condition|)
block|{
comment|/* Create or update the tag information.  */
name|tag_t
modifier|*
name|tag_ptr
init|=
name|get_tag
argument_list|(
name|name
argument_list|,
name|sym
argument_list|,
name|coff_type
operator|.
name|basic_type
argument_list|)
decl_stmt|;
name|forward_t
modifier|*
modifier|*
name|pf
decl_stmt|;
comment|/* Remember any forward references.  */
for|for
control|(
name|pf
operator|=
operator|&
name|sym
operator|->
name|forward_ref
init|;
operator|*
name|pf
operator|!=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pf
operator|=
name|tag_ptr
operator|->
name|forward_ref
expr_stmt|;
name|tag_ptr
operator|->
name|forward_ref
operator|=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .end directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_end
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
name|symbolS
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .file directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .ent directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|input_line_pointer
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive has no name"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* The value is the distance between the .end directive and the      corresponding symbol.  We create a fake symbol to hold the      current location, and put in the offset when we write out the      symbol.  */
name|ent
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive names unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .ent directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_ent
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|add_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"second .ent directive found before .end directive"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|input_line_pointer
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ent directive has no name"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|add_procedure
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
comment|/* The .ent directive is sometimes followed by a number.  I'm not      really sure what the number means.  I don't see any way to store      the information in the PDR.  The Irix 4 assembler seems to ignore      the information.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
operator|(
name|void
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .extern directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_extern
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolp
decl_stmt|;
name|valueT
name|size
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolp
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|symbolp
argument_list|)
operator|->
name|ecoff_extern_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .file directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_file
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|indx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"no way to handle .file within .ent/.end section"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|indx
operator|=
operator|(
name|int
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* FIXME: we don't have to save the name here.  */
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|add_file
argument_list|(
name|name
argument_list|,
name|indx
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .fmask directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_fmask
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".fmask outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bad .fmask directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|fregmask
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|fregoffset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .frame directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_frame
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".frame outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|framereg
operator|=
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
operator|||
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bad .frame directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|frameoffset
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Alpha-OSF1 adds "the offset of saved $a0 from $sp", according to      Sandro.  I don't yet know where this value should be stored, if      anywhere.  Don't call demand_empty_rest_of_line ().  */
name|s_ignore
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .mask directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_mask
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".mask outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bad .mask directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|regmask
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|regoffset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .loc directives.  */
end_comment

begin_function
name|void
name|ecoff_directive_loc
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|lineno_list_t
modifier|*
name|list
decl_stmt|;
name|symint_t
name|lineno
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc before .file"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc outside of .text"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip the file number.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we're building stabs, then output a special label rather than      ECOFF line number info.  */
if|if
condition|(
name|stabs_seen
condition|)
block|{
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_Label
argument_list|,
name|sc_Text
argument_list|,
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|allocate_lineno_list
argument_list|()
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|->
name|file
operator|=
name|cur_file_ptr
expr_stmt|;
name|list
operator|->
name|proc
operator|=
name|cur_proc_ptr
expr_stmt|;
name|list
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|list
operator|->
name|paddr
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|list
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
comment|/* We don't want to merge files which have line numbers.  */
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|fMerge
operator|=
literal|0
expr_stmt|;
comment|/* A .loc directive will sometimes appear before a .ent directive,      which means that cur_proc_ptr will be NULL here.  Arrange to      patch this up.  */
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|lineno_list_t
modifier|*
modifier|*
name|pl
decl_stmt|;
name|pl
operator|=
operator|&
name|noproc_lineno
expr_stmt|;
while|while
condition|(
operator|*
name|pl
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|)
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pl
operator|=
name|list
expr_stmt|;
block|}
else|else
block|{
name|last_lineno
operator|=
name|list
expr_stmt|;
operator|*
name|last_lineno_ptr
operator|=
name|list
expr_stmt|;
name|last_lineno_ptr
operator|=
operator|&
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The MIPS assembler sometimes inserts nop instructions in the    instruction stream.  When this happens, we must patch up the .loc    information so that it points to the instruction after the nop.  */
end_comment

begin_function
name|void
name|ecoff_fix_loc
parameter_list|(
name|fragS
modifier|*
name|old_frag
parameter_list|,
name|unsigned
name|long
name|old_frag_offset
parameter_list|)
block|{
if|if
condition|(
name|last_lineno
operator|!=
name|NULL
operator|&&
name|last_lineno
operator|->
name|frag
operator|==
name|old_frag
operator|&&
name|last_lineno
operator|->
name|paddr
operator|==
name|old_frag_offset
condition|)
block|{
name|last_lineno
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|last_lineno
operator|->
name|paddr
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure the @stabs symbol is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|mark_stabs
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|stabs_seen
condition|)
block|{
comment|/* Add a dummy @stabs dymbol.  */
name|stabs_seen
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
name|stabs_symbol
argument_list|,
name|stNil
argument_list|,
name|scInfo
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
operator|-
literal|1
argument_list|,
name|ECOFF_MARK_STAB
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .weakext directives.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_MIPS
end_ifndef

begin_comment
comment|/* For TC_MIPS use the version in tc-mips.c.  */
end_comment

begin_function
name|void
name|ecoff_directive_weakext
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .weakext directive"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not TC_MIPS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle .stabs directives.  The actual parsing routine is done by a    generic routine.  This routine is called via OBJ_PROCESS_STAB.    When this is called, input_line_pointer will be pointing at the    value field of the stab.     .stabs directives have five fields: 	"string"	a string, encoding the type information. 	code		a numeric code, defined in<stab.h> 	0		a zero 	desc		a zero or line number 	value		a numeric value or an address.      If the value is relocatable, we transform this into: 	iss		points as an index into string space 	value		value from lookup of the name 	st		st from lookup of the name 	sc		sc from lookup of the name 	index		code|CODE_MASK      If the value is not relocatable, we transform this into: 	iss		points as an index into string space 	value		value 	st		st_Nil 	sc		sc_Nil 	index		code|CODE_MASK      .stabn directives have four fields (string is null): 	code		a numeric code, defined in<stab.h> 	0		a zero 	desc		a zero or a line number 	value		a numeric value or an address.  */
end_comment

begin_function
name|void
name|ecoff_stab
parameter_list|(
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|other
parameter_list|,
name|int
name|desc
parameter_list|)
block|{
name|efdr_t
modifier|*
name|save_file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symint_t
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|st_t
name|st
decl_stmt|;
name|sc_t
name|sc
decl_stmt|;
name|symint_t
name|indx
decl_stmt|;
name|localsym_t
modifier|*
name|hold
init|=
name|NULL
decl_stmt|;
name|ecoff_debugging_seen
operator|=
literal|1
expr_stmt|;
comment|/* We don't handle .stabd.  */
if|if
condition|(
name|what
operator|!=
literal|'s'
operator|&&
name|what
operator|!=
literal|'n'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".stab%c is not supported"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* A .stabn uses a null name, not an empty string.  */
if|if
condition|(
name|what
operator|==
literal|'n'
condition|)
name|string
operator|=
name|NULL
expr_stmt|;
comment|/* We ignore the other field.  */
if|if
condition|(
name|other
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".stab%c: ignoring non-zero other field"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
comment|/* Make sure we have a current file.  */
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|add_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_file_ptr
operator|=
name|cur_file_ptr
expr_stmt|;
block|}
comment|/* For stabs in ECOFF, the first symbol must be @stabs.  This is a      signal to gdb.  */
if|if
condition|(
name|stabs_seen
operator|==
literal|0
condition|)
name|mark_stabs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Line number stabs are handled differently, since they have two      values, the line number and the address of the label.  We use the      index field (aka desc) to hold the line number, and the value      field to hold the address.  The symbol type is st_Label, which      should be different from the other stabs, so that gdb can      recognize it.  */
if|if
condition|(
name|type
operator|==
name|N_SLINE
condition|)
block|{
name|SYMR
name|dummy_symr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dummy_symr
operator|.
name|index
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|dummy_symr
operator|.
name|index
operator|!=
name|desc
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"line number (%d) for .stab%c directive cannot fit in index field (20 bits)"
argument_list|)
argument_list|,
name|desc
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|st_Label
expr_stmt|;
name|sc
operator|=
name|sc_Text
expr_stmt|;
name|indx
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|listing
operator|&&
operator|(
name|type
operator|==
name|N_SO
operator|||
name|type
operator|==
name|N_SOL
operator|)
condition|)
name|listing_source_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'+'
condition|)
block|{
name|st
operator|=
name|st_Nil
expr_stmt|;
name|sc
operator|=
name|sc_Nil
expr_stmt|;
name|sym
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
expr_stmt|;
name|value
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"illegal .stab%c directive, bad character"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|sc
operator|=
name|sc_Nil
expr_stmt|;
name|st
operator|=
name|st_Nil
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|sym
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|sym
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|indx
operator|=
name|ECOFF_MARK_STAB
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Don't store the stabs symbol we are creating as the type of the      ECOFF symbol.  We want to compute the type of the ECOFF symbol      independently.  */
if|if
condition|(
name|sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|hold
operator|=
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
expr_stmt|;
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
name|string
argument_list|,
name|st
argument_list|,
name|sc
argument_list|,
name|sym
argument_list|,
name|addend
argument_list|,
name|value
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
operator|=
name|hold
expr_stmt|;
comment|/* Restore normal file type.  */
name|cur_file_ptr
operator|=
name|save_file_ptr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Frob an ECOFF symbol.  Small common symbols go into a special    .scommon section rather than bfd_com_section.  */
end_comment

begin_function
name|void
name|ecoff_frob_symbol
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|>
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|<=
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
condition|)
block|{
specifier|static
name|asection
name|scom_section
decl_stmt|;
specifier|static
name|asymbol
name|scom_symbol
decl_stmt|;
comment|/* We must construct a fake section similar to bfd_com_section          but with the name .scommon.  */
if|if
condition|(
name|scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|scom_section
operator|=
name|bfd_com_section
expr_stmt|;
name|scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|scom_section
operator|.
name|output_section
operator|=
operator|&
name|scom_section
expr_stmt|;
name|scom_section
operator|.
name|symbol
operator|=
operator|&
name|scom_symbol
expr_stmt|;
name|scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|scom_section
operator|.
name|symbol
expr_stmt|;
name|scom_symbol
operator|=
operator|*
name|bfd_com_section
operator|.
name|symbol
expr_stmt|;
name|scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|scom_symbol
operator|.
name|section
operator|=
operator|&
name|scom_section
expr_stmt|;
block|}
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
operator|&
name|scom_section
argument_list|)
expr_stmt|;
block|}
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add bytes to the symbolic information buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ecoff_add_bytes
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|char
modifier|*
name|bufptr
parameter_list|,
name|unsigned
name|long
name|need
parameter_list|)
block|{
name|unsigned
name|long
name|at
decl_stmt|;
name|unsigned
name|long
name|want
decl_stmt|;
name|at
operator|=
name|bufptr
operator|-
operator|*
name|buf
expr_stmt|;
name|need
operator|-=
operator|*
name|bufend
operator|-
name|bufptr
expr_stmt|;
if|if
condition|(
name|need
operator|<
name|PAGE_SIZE
condition|)
name|need
operator|=
name|PAGE_SIZE
expr_stmt|;
name|want
operator|=
operator|(
operator|*
name|bufend
operator|-
operator|*
name|buf
operator|)
operator|+
name|need
expr_stmt|;
operator|*
name|buf
operator|=
name|xrealloc
argument_list|(
operator|*
name|buf
argument_list|,
name|want
argument_list|)
expr_stmt|;
operator|*
name|bufend
operator|=
operator|*
name|buf
operator|+
name|want
expr_stmt|;
return|return
operator|*
name|buf
operator|+
name|at
return|;
block|}
end_function

begin_comment
comment|/* Adjust the symbolic information buffer to the alignment required    for the ECOFF target debugging information.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_padding_adjust
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
modifier|*
name|bufptrptr
parameter_list|)
block|{
name|bfd_size_type
name|align
decl_stmt|;
name|align
operator|=
name|backend
operator|->
name|debug_align
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|long
name|add
decl_stmt|;
name|add
operator|=
name|align
operator|-
operator|(
name|offset
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
name|bufend
operator|-
operator|(
operator|*
name|buf
operator|+
name|offset
operator|)
argument_list|)
operator|<
name|add
condition|)
operator|(
name|void
operator|)
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
operator|*
name|buf
operator|+
name|offset
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|buf
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|bufptrptr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|bufptrptr
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Build the line number information.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_lineno
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|long
modifier|*
name|linecntptr
parameter_list|)
block|{
name|char
modifier|*
name|bufptr
decl_stmt|;
specifier|register
name|lineno_list_t
modifier|*
name|l
decl_stmt|;
name|lineno_list_t
modifier|*
name|last
decl_stmt|;
name|efdr_t
modifier|*
name|file
decl_stmt|;
name|proc_t
modifier|*
name|proc
decl_stmt|;
name|unsigned
name|long
name|c
decl_stmt|;
name|long
name|iline
decl_stmt|;
name|long
name|totcount
decl_stmt|;
name|lineno_list_t
name|first
decl_stmt|;
name|lineno_list_t
modifier|*
name|local_first_lineno
init|=
name|first_lineno
decl_stmt|;
if|if
condition|(
name|linecntptr
operator|!=
operator|(
name|long
operator|*
operator|)
name|NULL
condition|)
operator|*
name|linecntptr
operator|=
literal|0
expr_stmt|;
name|bufptr
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
name|file
operator|=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|proc
operator|=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|last
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|c
operator|=
name|offset
expr_stmt|;
name|iline
operator|=
literal|0
expr_stmt|;
name|totcount
operator|=
literal|0
expr_stmt|;
comment|/* FIXME?  Now that MIPS embedded-PIC is gone, it may be safe to      remove this code.  */
comment|/* For some reason the address of the first procedure is ignored      when reading line numbers.  This doesn't matter if the address of      the first procedure is 0, but when gcc is generating MIPS      embedded PIC code, it will put strings in the .text section      before the first procedure.  We cope by inserting a dummy line if      the address of the first procedure is not 0.  Hopefully this      won't screw things up too badly.       Don't do this for ECOFF assembly source line numbers.  They work      without this extra attention.  */
if|if
condition|(
name|debug_type
operator|!=
name|DEBUG_ECOFF
operator|&&
name|first_proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
operator|&&
name|local_first_lineno
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|(
name|S_GET_VALUE
argument_list|(
name|first_proc_ptr
operator|->
name|sym
operator|->
name|as_sym
argument_list|)
operator|+
name|bfd_get_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|first_proc_ptr
operator|->
name|sym
operator|->
name|as_sym
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|first
operator|.
name|file
operator|=
name|local_first_lineno
operator|->
name|file
expr_stmt|;
name|first
operator|.
name|proc
operator|=
name|local_first_lineno
operator|->
name|proc
expr_stmt|;
name|first
operator|.
name|frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|first
operator|.
name|paddr
operator|=
literal|0
expr_stmt|;
name|first
operator|.
name|lineno
operator|=
literal|0
expr_stmt|;
name|first
operator|.
name|next
operator|=
name|local_first_lineno
expr_stmt|;
name|local_first_lineno
operator|=
operator|&
name|first
expr_stmt|;
block|}
for|for
control|(
name|l
operator|=
name|local_first_lineno
init|;
name|l
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|long
name|count
decl_stmt|;
name|long
name|delta
decl_stmt|;
comment|/* Get the offset to the memory address of the next line number          (in words).  Do this first, so that we can skip ahead to the          next useful line number entry.  */
if|if
condition|(
name|l
operator|->
name|next
operator|==
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* We want a count of zero, but it will be decremented 	     before it is used.  */
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|next
operator|->
name|frag
operator|->
name|fr_address
operator|+
name|l
operator|->
name|next
operator|->
name|paddr
operator|>
name|l
operator|->
name|frag
operator|->
name|fr_address
operator|+
name|l
operator|->
name|paddr
condition|)
block|{
name|count
operator|=
operator|(
operator|(
name|l
operator|->
name|next
operator|->
name|frag
operator|->
name|fr_address
operator|+
name|l
operator|->
name|next
operator|->
name|paddr
operator|-
operator|(
name|l
operator|->
name|frag
operator|->
name|fr_address
operator|+
name|l
operator|->
name|paddr
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't change last, so we still get the right delta.  */
continue|continue;
block|}
if|if
condition|(
name|l
operator|->
name|file
operator|!=
name|file
operator|||
name|l
operator|->
name|proc
operator|!=
name|proc
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|proc
operator|!=
name|proc
operator|&&
name|proc
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
name|proc
operator|->
name|pdr
operator|.
name|lnHigh
operator|=
name|last
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|file
operator|!=
name|file
operator|&&
name|file
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|file
operator|->
name|fdr
operator|.
name|cbLine
operator|=
name|c
operator|-
name|file
operator|->
name|fdr
operator|.
name|cbLineOffset
expr_stmt|;
name|file
operator|->
name|fdr
operator|.
name|cline
operator|=
name|totcount
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|linecntptr
operator|!=
operator|(
name|long
operator|*
operator|)
name|NULL
condition|)
operator|*
name|linecntptr
operator|+=
name|totcount
operator|+
name|count
expr_stmt|;
name|totcount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|file
operator|!=
name|file
condition|)
block|{
name|efdr_t
modifier|*
name|last_file
init|=
name|file
decl_stmt|;
name|file
operator|=
name|l
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|file
operator|->
name|fdr
operator|.
name|ilineBase
operator|=
name|last_file
operator|->
name|fdr
operator|.
name|ilineBase
operator|+
name|last_file
operator|->
name|fdr
operator|.
name|cline
expr_stmt|;
else|else
name|file
operator|->
name|fdr
operator|.
name|ilineBase
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|fdr
operator|.
name|cbLineOffset
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|proc
operator|!=
name|proc
condition|)
block|{
name|proc
operator|=
name|l
operator|->
name|proc
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|proc
operator|->
name|pdr
operator|.
name|lnLow
operator|=
name|l
operator|->
name|lineno
expr_stmt|;
name|proc
operator|->
name|pdr
operator|.
name|cbLineOffset
operator|=
name|c
operator|-
name|file
operator|->
name|fdr
operator|.
name|cbLineOffset
expr_stmt|;
name|proc
operator|->
name|pdr
operator|.
name|iline
operator|=
name|totcount
expr_stmt|;
block|}
block|}
name|last
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|totcount
operator|+=
name|count
expr_stmt|;
comment|/* Get the offset to this line number.  */
if|if
condition|(
name|last
operator|==
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|)
name|delta
operator|=
literal|0
expr_stmt|;
else|else
name|delta
operator|=
name|l
operator|->
name|lineno
operator|-
name|last
operator|->
name|lineno
expr_stmt|;
comment|/* Put in the offset to this line number.  */
while|while
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
name|int
name|setcount
decl_stmt|;
comment|/* 1 is added to each count read.  */
operator|--
name|count
expr_stmt|;
comment|/* We can only adjust the word count by up to 15 words at a 	     time.  */
if|if
condition|(
name|count
operator|<=
literal|0x0f
condition|)
block|{
name|setcount
operator|=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|setcount
operator|=
literal|0x0f
expr_stmt|;
name|count
operator|-=
literal|0x0f
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|>=
operator|-
literal|7
operator|&&
name|delta
operator|<=
literal|7
condition|)
block|{
if|if
condition|(
name|bufptr
operator|>=
operator|*
name|bufend
condition|)
name|bufptr
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|bufptr
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bufptr
operator|++
operator|=
name|setcount
operator|+
operator|(
name|delta
operator|<<
literal|4
operator|)
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
else|else
block|{
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|*
name|bufend
operator|-
name|bufptr
operator|<
literal|3
condition|)
name|bufptr
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|bufptr
argument_list|,
operator|(
name|long
operator|)
literal|3
argument_list|)
expr_stmt|;
operator|*
name|bufptr
operator|++
operator|=
name|setcount
operator|+
operator|(
literal|8
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
literal|0x8000
condition|)
block|{
name|set
operator|=
operator|-
literal|0x8000
expr_stmt|;
name|delta
operator|+=
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|>
literal|0x7fff
condition|)
block|{
name|set
operator|=
literal|0x7fff
expr_stmt|;
name|delta
operator|-=
literal|0x7fff
expr_stmt|;
block|}
else|else
block|{
name|set
operator|=
name|delta
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|bufptr
operator|++
operator|=
name|set
operator|>>
literal|8
expr_stmt|;
operator|*
name|bufptr
operator|++
operator|=
name|set
operator|&
literal|0xffff
expr_stmt|;
name|c
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|/* Finish adjusting the count.  */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bufptr
operator|>=
operator|*
name|bufend
condition|)
name|bufptr
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|bufptr
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 is added to each count read.  */
operator|--
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0x0f
condition|)
block|{
operator|*
name|bufptr
operator|++
operator|=
literal|0x0f
expr_stmt|;
name|count
operator|-=
literal|0x0f
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bufptr
operator|++
operator|=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
operator|++
name|iline
expr_stmt|;
name|last
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
name|proc
operator|->
name|pdr
operator|.
name|lnHigh
operator|=
name|last
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|file
operator|->
name|fdr
operator|.
name|cbLine
operator|=
name|c
operator|-
name|file
operator|->
name|fdr
operator|.
name|cbLineOffset
expr_stmt|;
name|file
operator|->
name|fdr
operator|.
name|cline
operator|=
name|totcount
expr_stmt|;
block|}
if|if
condition|(
name|linecntptr
operator|!=
operator|(
name|long
operator|*
operator|)
name|NULL
condition|)
operator|*
name|linecntptr
operator|+=
name|totcount
expr_stmt|;
name|c
operator|=
name|ecoff_padding_adjust
argument_list|(
name|backend
argument_list|,
name|buf
argument_list|,
name|bufend
argument_list|,
name|c
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Build and swap out the symbols.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_symbols
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|backend
operator|->
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
operator|*
specifier|const
name|swap_sym_out
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
specifier|const
name|SYMR
operator|*
argument_list|,
name|PTR
argument_list|)
operator|=
name|backend
operator|->
name|swap_sym_out
expr_stmt|;
name|char
modifier|*
name|sym_out
decl_stmt|;
name|long
name|isym
decl_stmt|;
name|vlinks_t
modifier|*
name|file_link
decl_stmt|;
name|sym_out
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
name|isym
operator|=
literal|0
expr_stmt|;
comment|/* The symbols are stored by file.  */
for|for
control|(
name|file_link
operator|=
name|file_desc
operator|.
name|first
init|;
name|file_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|file_link
operator|=
name|file_link
operator|->
name|next
control|)
block|{
name|int
name|ifilesym
decl_stmt|;
name|int
name|fil_cnt
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|fil_end
decl_stmt|;
if|if
condition|(
name|file_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_per_page
expr_stmt|;
name|fil_ptr
operator|=
name|file_link
operator|->
name|datum
operator|->
name|file
expr_stmt|;
name|fil_end
operator|=
name|fil_ptr
operator|+
name|fil_cnt
expr_stmt|;
for|for
control|(
init|;
name|fil_ptr
operator|<
name|fil_end
condition|;
name|fil_ptr
operator|++
control|)
block|{
name|vlinks_t
modifier|*
name|sym_link
decl_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|isymBase
operator|=
name|isym
expr_stmt|;
name|ifilesym
operator|=
name|isym
expr_stmt|;
for|for
control|(
name|sym_link
operator|=
name|fil_ptr
operator|->
name|symbols
operator|.
name|first
init|;
name|sym_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|sym_link
operator|=
name|sym_link
operator|->
name|next
control|)
block|{
name|int
name|sym_cnt
decl_stmt|;
name|localsym_t
modifier|*
name|sym_ptr
decl_stmt|;
name|localsym_t
modifier|*
name|sym_end
decl_stmt|;
if|if
condition|(
name|sym_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|sym_cnt
operator|=
name|fil_ptr
operator|->
name|symbols
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|sym_cnt
operator|=
name|fil_ptr
operator|->
name|symbols
operator|.
name|objects_per_page
expr_stmt|;
name|sym_ptr
operator|=
name|sym_link
operator|->
name|datum
operator|->
name|sym
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr
operator|+
name|sym_cnt
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|int
name|local
decl_stmt|;
name|symbolS
modifier|*
name|as_sym
decl_stmt|;
name|forward_t
modifier|*
name|f
decl_stmt|;
name|know
argument_list|(
name|sym_ptr
operator|->
name|file_ptr
operator|==
name|fil_ptr
argument_list|)
expr_stmt|;
comment|/* If there is no associated gas symbol, then this 		     is a pure debugging symbol.  We have already 		     added the name (if any) to fil_ptr->strings. 		     Otherwise we must decide whether this is an 		     external or a local symbol (actually, it may be 		     both if the local provides additional debugging 		     information for the external).  */
name|local
operator|=
literal|1
expr_stmt|;
name|as_sym
operator|=
name|sym_ptr
operator|->
name|as_sym
expr_stmt|;
if|if
condition|(
name|as_sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|symint_t
name|indx
decl_stmt|;
comment|/* The value of a block start symbol is the 		         offset from the start of the procedure.  For 		         other symbols we just use the gas value (but 		         we must offset it by the vma of the section, 		         just as BFD does, because BFD will not see 		         this value).  */
if|if
condition|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|==
operator|(
name|int
operator|)
name|st_Block
operator|&&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|==
operator|(
name|int
operator|)
name|sc_Text
condition|)
block|{
name|symbolS
modifier|*
name|begin_sym
decl_stmt|;
name|know
argument_list|(
name|sym_ptr
operator|->
name|proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|begin_sym
operator|=
name|sym_ptr
operator|->
name|proc_ptr
operator|->
name|sym
operator|->
name|as_sym
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|as_sym
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|begin_sym
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin/.bend in different segments"
argument_list|)
argument_list|)
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|begin_sym
argument_list|)
expr_stmt|;
block|}
else|else
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|+
name|bfd_get_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|as_sym
argument_list|)
argument_list|)
operator|+
name|sym_ptr
operator|->
name|addend
operator|)
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|weakext
operator|=
name|S_IS_WEAK
argument_list|(
name|as_sym
argument_list|)
expr_stmt|;
comment|/* Set st_Proc to st_StaticProc for local 			 functions.  */
if|if
condition|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|==
name|st_Proc
operator|&&
name|S_IS_DEFINED
argument_list|(
name|as_sym
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|as_sym
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|as_sym
argument_list|)
condition|)
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|=
name|st_StaticProc
expr_stmt|;
comment|/* Get the type and storage class based on where 		         the symbol actually wound up.  Traditionally, 		         N_LBRAC and N_RBRAC are *not* relocated.  */
name|indx
operator|=
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|==
name|st_Nil
operator|&&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|==
name|sc_Nil
operator|&&
operator|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|)
operator|||
operator|(
operator|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|indx
argument_list|)
operator|!=
name|N_LBRAC
operator|)
operator|&&
operator|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|indx
argument_list|)
operator|!=
name|N_RBRAC
operator|)
operator|)
operator|)
condition|)
block|{
name|segT
name|seg
decl_stmt|;
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
name|st_t
name|st
decl_stmt|;
name|sc_t
name|sc
decl_stmt|;
name|seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|as_sym
argument_list|)
expr_stmt|;
name|segname
operator|=
name|segment_name
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|)
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|as_sym
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|as_sym
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|as_sym
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|as_sym
argument_list|)
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
name|st
operator|=
name|st_Proc
expr_stmt|;
else|else
name|st
operator|=
name|st_Global
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg
operator|==
name|text_section
condition|)
name|st
operator|=
name|st_Label
expr_stmt|;
else|else
name|st
operator|=
name|st_Static
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|as_sym
argument_list|)
condition|)
block|{
name|valueT
name|s
decl_stmt|;
name|s
operator|=
name|symbol_get_obj
argument_list|(
name|as_sym
argument_list|)
operator|->
name|ecoff_extern_size
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
name|s
operator|>
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
condition|)
name|sc
operator|=
name|sc_Undefined
expr_stmt|;
else|else
block|{
name|sc
operator|=
name|sc_SUndefined
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|S_SET_SIZE
name|S_SET_SIZE
argument_list|(
name|as_sym
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|as_sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|<=
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
operator|)
condition|)
name|sc
operator|=
name|sc_SCommon
expr_stmt|;
else|else
name|sc
operator|=
name|sc_Common
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg
operator|==
name|text_section
condition|)
name|sc
operator|=
name|sc_Text
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
name|data_section
condition|)
name|sc
operator|=
name|sc_Data
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|=
name|sc_RData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|=
name|sc_SData
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
name|bss_section
condition|)
name|sc
operator|=
name|sc_Bss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|=
name|sc_SBss
expr_stmt|;
elseif|else
if|if
condition|(
name|seg
operator|==
operator|&
name|bfd_abs_section
condition|)
name|sc
operator|=
name|sc_Abs
expr_stmt|;
else|else
block|{
comment|/* This must be a user named section. 			         This is not possible in ECOFF, but it 			         is in ELF.  */
name|sc
operator|=
name|sc_Data
expr_stmt|;
block|}
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|=
operator|(
name|int
operator|)
name|st
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|=
operator|(
name|int
operator|)
name|sc
expr_stmt|;
block|}
comment|/* This is just an external symbol if it is 		         outside a procedure and it has a type. 		         FIXME: g++ will generate symbols which have 		         different names in the debugging information 		         than the actual symbol.  Should we handle 		         them here?  */
if|if
condition|(
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|as_sym
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|as_sym
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|as_sym
argument_list|)
operator|)
operator|&&
name|sym_ptr
operator|->
name|proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
operator|&&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|!=
operator|(
name|int
operator|)
name|st_Nil
operator|&&
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|)
condition|)
name|local
operator|=
literal|0
expr_stmt|;
comment|/* This is just an external symbol if it is a 		         common symbol.  */
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|as_sym
argument_list|)
condition|)
name|local
operator|=
literal|0
expr_stmt|;
comment|/* If an st_end symbol has an associated gas 		         symbol, then it is a local label created for 		         a .bend or .end directive.  Stabs line 		         numbers will have \001 in the names.  */
if|if
condition|(
name|local
operator|&&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|!=
name|st_End
operator|&&
name|strchr
argument_list|(
name|sym_ptr
operator|->
name|name
argument_list|,
literal|'\001'
argument_list|)
operator|==
literal|0
condition|)
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|iss
operator|=
name|add_string
argument_list|(
operator|&
name|fil_ptr
operator|->
name|strings
argument_list|,
name|fil_ptr
operator|->
name|str_hash
argument_list|,
name|sym_ptr
operator|->
name|name
argument_list|,
operator|(
name|shash_t
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We now know the index of this symbol; fill in 		     locations that have been waiting for that 		     information.  */
if|if
condition|(
name|sym_ptr
operator|->
name|begin_ptr
operator|!=
operator|(
name|localsym_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|localsym_t
modifier|*
name|begin_ptr
decl_stmt|;
name|st_t
name|begin_type
decl_stmt|;
name|know
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|begin_ptr
operator|=
name|sym_ptr
operator|->
name|begin_ptr
expr_stmt|;
name|know
argument_list|(
name|begin_ptr
operator|->
name|sym_index
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|begin_ptr
operator|->
name|sym_index
expr_stmt|;
if|if
condition|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|!=
operator|(
name|int
operator|)
name|sc_Info
condition|)
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|iss
operator|=
name|begin_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|begin_type
operator|=
name|begin_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
expr_stmt|;
if|if
condition|(
name|begin_type
operator|==
name|st_File
operator|||
name|begin_type
operator|==
name|st_Block
condition|)
block|{
name|begin_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|isym
operator|-
name|ifilesym
operator|+
literal|1
expr_stmt|;
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|begin_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|,
operator|(
operator|*
name|buf
operator|+
name|offset
operator|+
operator|(
name|begin_ptr
operator|->
name|sym_index
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|begin_ptr
operator|->
name|index_ptr
operator|!=
operator|(
name|aux_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|begin_ptr
operator|->
name|index_ptr
operator|->
name|data
operator|.
name|isym
operator|=
name|isym
operator|-
name|ifilesym
operator|+
literal|1
expr_stmt|;
block|}
comment|/* The value of the symbol marking the end of a 		         procedure is the size of the procedure.  The 		         value of the symbol marking the end of a 		         block is the offset from the start of the 		         procedure to the block.  */
if|if
condition|(
name|begin_type
operator|==
name|st_Proc
operator|||
name|begin_type
operator|==
name|st_StaticProc
condition|)
block|{
name|know
argument_list|(
name|as_sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|begin_ptr
operator|->
name|as_sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|as_sym
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|begin_ptr
operator|->
name|as_sym
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin/.bend in different segments"
argument_list|)
argument_list|)
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|begin_ptr
operator|->
name|as_sym
argument_list|)
operator|)
expr_stmt|;
comment|/* If the size is odd, this is probably a 			     mips16 function; force it to be even.  */
if|if
condition|(
operator|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|S_SET_SIZE
name|S_SET_SIZE
argument_list|(
name|begin_ptr
operator|->
name|as_sym
argument_list|,
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|begin_type
operator|==
name|st_Block
operator|&&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|!=
operator|(
name|int
operator|)
name|sc_Info
condition|)
block|{
name|symbolS
modifier|*
name|begin_sym
decl_stmt|;
name|know
argument_list|(
name|as_sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|sym_ptr
operator|->
name|proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|begin_sym
operator|=
name|sym_ptr
operator|->
name|proc_ptr
operator|->
name|sym
operator|->
name|as_sym
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|as_sym
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|begin_sym
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin/.bend in different segments"
argument_list|)
argument_list|)
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|as_sym
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|begin_sym
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|sym_ptr
operator|->
name|forward_ref
init|;
name|f
operator|!=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|know
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|f
operator|->
name|ifd_ptr
operator|->
name|data
operator|.
name|isym
operator|=
name|fil_ptr
operator|->
name|file_index
expr_stmt|;
name|f
operator|->
name|index_ptr
operator|->
name|data
operator|.
name|rndx
operator|.
name|index
operator|=
name|isym
operator|-
name|ifilesym
expr_stmt|;
block|}
if|if
condition|(
name|local
condition|)
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
operator|*
name|bufend
operator|-
name|sym_out
argument_list|)
operator|<
name|external_sym_size
condition|)
name|sym_out
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|sym_out
argument_list|,
name|external_sym_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
argument_list|,
name|sym_out
argument_list|)
expr_stmt|;
name|sym_out
operator|+=
name|external_sym_size
expr_stmt|;
name|sym_ptr
operator|->
name|sym_index
operator|=
name|isym
expr_stmt|;
if|if
condition|(
name|sym_ptr
operator|->
name|proc_ptr
operator|!=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
operator|&&
name|sym_ptr
operator|->
name|proc_ptr
operator|->
name|sym
operator|==
name|sym_ptr
condition|)
name|sym_ptr
operator|->
name|proc_ptr
operator|->
name|pdr
operator|.
name|isym
operator|=
name|isym
operator|-
name|ifilesym
expr_stmt|;
operator|++
name|isym
expr_stmt|;
block|}
comment|/* Record the local symbol index and file number in 		     case this is an external symbol.  Note that this 		     destroys the asym.index field.  */
if|if
condition|(
name|as_sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|symbol_get_obj
argument_list|(
name|as_sym
argument_list|)
operator|->
name|ecoff_symbol
operator|==
name|sym_ptr
condition|)
block|{
if|if
condition|(
operator|(
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|==
name|st_Proc
operator|||
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|==
name|st_StaticProc
operator|)
operator|&&
name|local
condition|)
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|isym
operator|-
name|ifilesym
operator|-
literal|1
expr_stmt|;
name|sym_ptr
operator|->
name|ecoff_sym
operator|.
name|ifd
operator|=
name|fil_ptr
operator|->
name|file_index
expr_stmt|;
comment|/* Don't try to merge an FDR which has an 		         external symbol attached to it.  */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|as_sym
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|as_sym
argument_list|)
condition|)
name|fil_ptr
operator|->
name|fdr
operator|.
name|fMerge
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|fil_ptr
operator|->
name|fdr
operator|.
name|csym
operator|=
name|isym
operator|-
name|fil_ptr
operator|->
name|fdr
operator|.
name|isymBase
expr_stmt|;
block|}
block|}
return|return
name|offset
operator|+
name|isym
operator|*
name|external_sym_size
return|;
block|}
end_function

begin_comment
comment|/* Swap out the procedure information.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_procs
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
specifier|const
name|bfd_size_type
name|external_pdr_size
init|=
name|backend
operator|->
name|external_pdr_size
decl_stmt|;
name|void
argument_list|(
operator|*
specifier|const
name|swap_pdr_out
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
specifier|const
name|PDR
operator|*
argument_list|,
name|PTR
argument_list|)
operator|=
name|backend
operator|->
name|swap_pdr_out
expr_stmt|;
name|char
modifier|*
name|pdr_out
decl_stmt|;
name|long
name|iproc
decl_stmt|;
name|vlinks_t
modifier|*
name|file_link
decl_stmt|;
name|pdr_out
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
name|iproc
operator|=
literal|0
expr_stmt|;
comment|/* The procedures are stored by file.  */
for|for
control|(
name|file_link
operator|=
name|file_desc
operator|.
name|first
init|;
name|file_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|file_link
operator|=
name|file_link
operator|->
name|next
control|)
block|{
name|int
name|fil_cnt
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|fil_end
decl_stmt|;
if|if
condition|(
name|file_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_per_page
expr_stmt|;
name|fil_ptr
operator|=
name|file_link
operator|->
name|datum
operator|->
name|file
expr_stmt|;
name|fil_end
operator|=
name|fil_ptr
operator|+
name|fil_cnt
expr_stmt|;
for|for
control|(
init|;
name|fil_ptr
operator|<
name|fil_end
condition|;
name|fil_ptr
operator|++
control|)
block|{
name|vlinks_t
modifier|*
name|proc_link
decl_stmt|;
name|int
name|first
decl_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|ipdFirst
operator|=
name|iproc
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|proc_link
operator|=
name|fil_ptr
operator|->
name|procs
operator|.
name|first
init|;
name|proc_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|proc_link
operator|=
name|proc_link
operator|->
name|next
control|)
block|{
name|int
name|prc_cnt
decl_stmt|;
name|proc_t
modifier|*
name|proc_ptr
decl_stmt|;
name|proc_t
modifier|*
name|proc_end
decl_stmt|;
if|if
condition|(
name|proc_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|prc_cnt
operator|=
name|fil_ptr
operator|->
name|procs
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|prc_cnt
operator|=
name|fil_ptr
operator|->
name|procs
operator|.
name|objects_per_page
expr_stmt|;
name|proc_ptr
operator|=
name|proc_link
operator|->
name|datum
operator|->
name|proc
expr_stmt|;
name|proc_end
operator|=
name|proc_ptr
operator|+
name|prc_cnt
expr_stmt|;
for|for
control|(
init|;
name|proc_ptr
operator|<
name|proc_end
condition|;
name|proc_ptr
operator|++
control|)
block|{
name|symbolS
modifier|*
name|adr_sym
decl_stmt|;
name|unsigned
name|long
name|adr
decl_stmt|;
name|adr_sym
operator|=
name|proc_ptr
operator|->
name|sym
operator|->
name|as_sym
expr_stmt|;
name|adr
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|adr_sym
argument_list|)
operator|+
name|bfd_get_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|adr_sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
comment|/* This code used to force the adr of the very 		         first fdr to be 0.  However, the native tools 		         don't do that, and I can't remember why it 		         used to work that way, so I took it out.  */
name|fil_ptr
operator|->
name|fdr
operator|.
name|adr
operator|=
name|adr
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|proc_ptr
operator|->
name|pdr
operator|.
name|adr
operator|=
name|adr
operator|-
name|fil_ptr
operator|->
name|fdr
operator|.
name|adr
expr_stmt|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
operator|*
name|bufend
operator|-
name|pdr_out
argument_list|)
operator|<
name|external_pdr_size
condition|)
name|pdr_out
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|pdr_out
argument_list|,
name|external_pdr_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_pdr_out
call|)
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|proc_ptr
operator|->
name|pdr
argument_list|,
name|pdr_out
argument_list|)
expr_stmt|;
name|pdr_out
operator|+=
name|external_pdr_size
expr_stmt|;
operator|++
name|iproc
expr_stmt|;
block|}
block|}
name|fil_ptr
operator|->
name|fdr
operator|.
name|cpd
operator|=
name|iproc
operator|-
name|fil_ptr
operator|->
name|fdr
operator|.
name|ipdFirst
expr_stmt|;
block|}
block|}
return|return
name|offset
operator|+
name|iproc
operator|*
name|external_pdr_size
return|;
block|}
end_function

begin_comment
comment|/* Swap out the aux information.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_aux
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
name|int
name|bigendian
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|aux_out
decl_stmt|;
name|long
name|iaux
decl_stmt|;
name|vlinks_t
modifier|*
name|file_link
decl_stmt|;
name|bigendian
operator|=
name|bfd_big_endian
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|aux_out
operator|=
operator|(
expr|union
name|aux_ext
operator|*
operator|)
operator|(
operator|*
name|buf
operator|+
name|offset
operator|)
expr_stmt|;
name|iaux
operator|=
literal|0
expr_stmt|;
comment|/* The aux entries are stored by file.  */
for|for
control|(
name|file_link
operator|=
name|file_desc
operator|.
name|first
init|;
name|file_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|file_link
operator|=
name|file_link
operator|->
name|next
control|)
block|{
name|int
name|fil_cnt
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|fil_end
decl_stmt|;
if|if
condition|(
name|file_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_per_page
expr_stmt|;
name|fil_ptr
operator|=
name|file_link
operator|->
name|datum
operator|->
name|file
expr_stmt|;
name|fil_end
operator|=
name|fil_ptr
operator|+
name|fil_cnt
expr_stmt|;
for|for
control|(
init|;
name|fil_ptr
operator|<
name|fil_end
condition|;
name|fil_ptr
operator|++
control|)
block|{
name|vlinks_t
modifier|*
name|aux_link
decl_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|fBigendian
operator|=
name|bigendian
expr_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|iauxBase
operator|=
name|iaux
expr_stmt|;
for|for
control|(
name|aux_link
operator|=
name|fil_ptr
operator|->
name|aux_syms
operator|.
name|first
init|;
name|aux_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|aux_link
operator|=
name|aux_link
operator|->
name|next
control|)
block|{
name|int
name|aux_cnt
decl_stmt|;
name|aux_t
modifier|*
name|aux_ptr
decl_stmt|;
name|aux_t
modifier|*
name|aux_end
decl_stmt|;
if|if
condition|(
name|aux_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|aux_cnt
operator|=
name|fil_ptr
operator|->
name|aux_syms
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|aux_cnt
operator|=
name|fil_ptr
operator|->
name|aux_syms
operator|.
name|objects_per_page
expr_stmt|;
name|aux_ptr
operator|=
name|aux_link
operator|->
name|datum
operator|->
name|aux
expr_stmt|;
name|aux_end
operator|=
name|aux_ptr
operator|+
name|aux_cnt
expr_stmt|;
for|for
control|(
init|;
name|aux_ptr
operator|<
name|aux_end
condition|;
name|aux_ptr
operator|++
control|)
block|{
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
name|bufend
operator|-
operator|(
name|char
operator|*
operator|)
name|aux_out
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
condition|)
name|aux_out
operator|=
operator|(
operator|(
expr|union
name|aux_ext
operator|*
operator|)
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aux_out
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|aux_ptr
operator|->
name|type
condition|)
block|{
case|case
name|aux_tir
case|:
call|(
modifier|*
name|backend
operator|->
name|swap_tir_out
call|)
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
operator|->
name|data
operator|.
name|ti
argument_list|,
operator|&
name|aux_out
operator|->
name|a_ti
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_rndx
case|:
call|(
modifier|*
name|backend
operator|->
name|swap_rndx_out
call|)
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
operator|->
name|data
operator|.
name|rndx
argument_list|,
operator|&
name|aux_out
operator|->
name|a_rndx
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_dnLow
case|:
name|AUX_PUT_DNLOW
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|dnLow
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_dnHigh
case|:
name|AUX_PUT_DNHIGH
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|dnHigh
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_isym
case|:
name|AUX_PUT_ISYM
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|isym
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_iss
case|:
name|AUX_PUT_ISS
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|iss
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_width
case|:
name|AUX_PUT_WIDTH
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|width
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|aux_count
case|:
name|AUX_PUT_COUNT
argument_list|(
name|bigendian
argument_list|,
name|aux_ptr
operator|->
name|data
operator|.
name|count
argument_list|,
name|aux_out
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|aux_out
expr_stmt|;
operator|++
name|iaux
expr_stmt|;
block|}
block|}
name|fil_ptr
operator|->
name|fdr
operator|.
name|caux
operator|=
name|iaux
operator|-
name|fil_ptr
operator|->
name|fdr
operator|.
name|iauxBase
expr_stmt|;
block|}
block|}
return|return
name|ecoff_padding_adjust
argument_list|(
name|backend
argument_list|,
name|buf
argument_list|,
name|bufend
argument_list|,
name|offset
operator|+
name|iaux
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy out the strings from a varray_t.  This returns the number of    bytes copied, rather than the new offset.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_strings
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|varray_t
modifier|*
name|vp
parameter_list|)
block|{
name|unsigned
name|long
name|istr
decl_stmt|;
name|char
modifier|*
name|str_out
decl_stmt|;
name|vlinks_t
modifier|*
name|str_link
decl_stmt|;
name|str_out
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
name|istr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|str_link
operator|=
name|vp
operator|->
name|first
init|;
name|str_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|str_link
operator|=
name|str_link
operator|->
name|next
control|)
block|{
name|unsigned
name|long
name|str_cnt
decl_stmt|;
if|if
condition|(
name|str_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|str_cnt
operator|=
name|vp
operator|->
name|objects_last_page
expr_stmt|;
else|else
name|str_cnt
operator|=
name|vp
operator|->
name|objects_per_page
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
name|bufend
operator|-
name|str_out
argument_list|)
operator|<
name|str_cnt
condition|)
name|str_out
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|str_out
argument_list|,
name|str_cnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str_out
argument_list|,
name|str_link
operator|->
name|datum
operator|->
name|byte
argument_list|,
name|str_cnt
argument_list|)
expr_stmt|;
name|str_out
operator|+=
name|str_cnt
expr_stmt|;
name|istr
operator|+=
name|str_cnt
expr_stmt|;
block|}
return|return
name|istr
return|;
block|}
end_function

begin_comment
comment|/* Dump out the local strings.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_ss
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
name|long
name|iss
decl_stmt|;
name|vlinks_t
modifier|*
name|file_link
decl_stmt|;
name|iss
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|file_link
operator|=
name|file_desc
operator|.
name|first
init|;
name|file_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|file_link
operator|=
name|file_link
operator|->
name|next
control|)
block|{
name|int
name|fil_cnt
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|fil_end
decl_stmt|;
if|if
condition|(
name|file_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_per_page
expr_stmt|;
name|fil_ptr
operator|=
name|file_link
operator|->
name|datum
operator|->
name|file
expr_stmt|;
name|fil_end
operator|=
name|fil_ptr
operator|+
name|fil_cnt
expr_stmt|;
for|for
control|(
init|;
name|fil_ptr
operator|<
name|fil_end
condition|;
name|fil_ptr
operator|++
control|)
block|{
name|long
name|ss_cnt
decl_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|issBase
operator|=
name|iss
expr_stmt|;
name|ss_cnt
operator|=
name|ecoff_build_strings
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|offset
operator|+
name|iss
argument_list|,
operator|&
name|fil_ptr
operator|->
name|strings
argument_list|)
expr_stmt|;
name|fil_ptr
operator|->
name|fdr
operator|.
name|cbSs
operator|=
name|ss_cnt
expr_stmt|;
name|iss
operator|+=
name|ss_cnt
expr_stmt|;
block|}
block|}
return|return
name|ecoff_padding_adjust
argument_list|(
name|backend
argument_list|,
name|buf
argument_list|,
name|bufend
argument_list|,
name|offset
operator|+
name|iss
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Swap out the file descriptors.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ecoff_build_fdr
parameter_list|(
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|bufend
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
specifier|const
name|bfd_size_type
name|external_fdr_size
init|=
name|backend
operator|->
name|external_fdr_size
decl_stmt|;
name|void
argument_list|(
operator|*
specifier|const
name|swap_fdr_out
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
specifier|const
name|FDR
operator|*
argument_list|,
name|PTR
argument_list|)
operator|=
name|backend
operator|->
name|swap_fdr_out
expr_stmt|;
name|long
name|ifile
decl_stmt|;
name|char
modifier|*
name|fdr_out
decl_stmt|;
name|vlinks_t
modifier|*
name|file_link
decl_stmt|;
name|ifile
operator|=
literal|0
expr_stmt|;
name|fdr_out
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|file_link
operator|=
name|file_desc
operator|.
name|first
init|;
name|file_link
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|;
name|file_link
operator|=
name|file_link
operator|->
name|next
control|)
block|{
name|int
name|fil_cnt
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|fil_end
decl_stmt|;
if|if
condition|(
name|file_link
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
name|NULL
condition|)
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_last_page
expr_stmt|;
else|else
name|fil_cnt
operator|=
name|file_desc
operator|.
name|objects_per_page
expr_stmt|;
name|fil_ptr
operator|=
name|file_link
operator|->
name|datum
operator|->
name|file
expr_stmt|;
name|fil_end
operator|=
name|fil_ptr
operator|+
name|fil_cnt
expr_stmt|;
for|for
control|(
init|;
name|fil_ptr
operator|<
name|fil_end
condition|;
name|fil_ptr
operator|++
control|)
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
operator|*
name|bufend
operator|-
name|fdr_out
argument_list|)
operator|<
name|external_fdr_size
condition|)
name|fdr_out
operator|=
name|ecoff_add_bytes
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|fdr_out
argument_list|,
name|external_fdr_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_fdr_out
call|)
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|fil_ptr
operator|->
name|fdr
argument_list|,
name|fdr_out
argument_list|)
expr_stmt|;
name|fdr_out
operator|+=
name|external_fdr_size
expr_stmt|;
operator|++
name|ifile
expr_stmt|;
block|}
block|}
return|return
name|offset
operator|+
name|ifile
operator|*
name|external_fdr_size
return|;
block|}
end_function

begin_comment
comment|/* Set up the external symbols.  These are supposed to be handled by    the backend.  This routine just gets the right information and    calls a backend function to deal with it.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_setup_ext
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|symbolS
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If this is a local symbol, then force the fields to zero.  */
if|if
condition|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|struct
name|localsym
modifier|*
name|lsym
decl_stmt|;
name|lsym
operator|=
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
expr_stmt|;
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|st
operator|=
operator|(
name|int
operator|)
name|st_Nil
expr_stmt|;
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|sc
operator|=
operator|(
name|int
operator|)
name|sc_Nil
expr_stmt|;
name|lsym
operator|->
name|ecoff_sym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
name|obj_ecoff_set_ext
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
operator|->
name|ecoff_sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the ECOFF debugging information.  */
end_comment

begin_function
name|unsigned
name|long
name|ecoff_build_debug
parameter_list|(
name|HDRR
modifier|*
name|hdr
parameter_list|,
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|backend
parameter_list|)
block|{
specifier|const
name|bfd_size_type
name|external_pdr_size
init|=
name|backend
operator|->
name|external_pdr_size
decl_stmt|;
name|tag_t
modifier|*
name|ptag
decl_stmt|;
name|tag_t
modifier|*
name|ptag_next
decl_stmt|;
name|efdr_t
modifier|*
name|fil_ptr
decl_stmt|;
name|int
name|end_warning
decl_stmt|;
name|efdr_t
modifier|*
name|hold_file_ptr
decl_stmt|;
name|proc_t
modifier|*
name|hold_proc_ptr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* Make sure we have a file.  */
if|if
condition|(
name|first_file
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|)
name|add_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Handle any top level tags.  */
for|for
control|(
name|ptag
operator|=
name|top_tag_head
operator|->
name|first_tag
init|;
name|ptag
operator|!=
operator|(
name|tag_t
operator|*
operator|)
name|NULL
condition|;
name|ptag
operator|=
name|ptag_next
control|)
block|{
if|if
condition|(
name|ptag
operator|->
name|forward_ref
operator|!=
operator|(
name|forward_t
operator|*
operator|)
name|NULL
condition|)
name|add_unknown_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
name|ptag_next
operator|=
name|ptag
operator|->
name|same_block
expr_stmt|;
name|ptag
operator|->
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|ptag
operator|->
name|same_name
expr_stmt|;
name|free_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
block|}
name|free_thead
argument_list|(
name|top_tag_head
argument_list|)
expr_stmt|;
comment|/* Look through the symbols.  Add debugging information for each      symbol that has not already received it.  */
name|hold_file_ptr
operator|=
name|cur_file_ptr
expr_stmt|;
name|hold_proc_ptr
operator|=
name|cur_proc_ptr
expr_stmt|;
name|cur_proc_ptr
operator|=
operator|(
name|proc_t
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_symbol
operator|!=
name|NULL
operator|||
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_file
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
operator|||
operator|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|cur_file_ptr
operator|=
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_file
expr_stmt|;
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_Nil
argument_list|,
name|sc_Nil
argument_list|,
name|sym
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|indexNil
argument_list|)
expr_stmt|;
block|}
name|cur_proc_ptr
operator|=
name|hold_proc_ptr
expr_stmt|;
name|cur_file_ptr
operator|=
name|hold_file_ptr
expr_stmt|;
comment|/* Output an ending symbol for all the files.  We have to do this      here for the last file, so we may as well do it for all of the      files.  */
name|end_warning
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fil_ptr
operator|=
name|first_file
init|;
name|fil_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
condition|;
name|fil_ptr
operator|=
name|fil_ptr
operator|->
name|next_file
control|)
block|{
name|cur_file_ptr
operator|=
name|fil_ptr
expr_stmt|;
while|while
condition|(
name|cur_file_ptr
operator|->
name|cur_scope
operator|!=
operator|(
name|scope_t
operator|*
operator|)
name|NULL
operator|&&
name|cur_file_ptr
operator|->
name|cur_scope
operator|->
name|prev
operator|!=
operator|(
name|scope_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|cur_file_ptr
operator|->
name|cur_scope
operator|=
name|cur_file_ptr
operator|->
name|cur_scope
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|end_warning
operator|&&
operator|!
name|cur_file_ptr
operator|->
name|fake
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end or .bend at end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|end_warning
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_file_ptr
operator|->
name|cur_scope
operator|!=
operator|(
name|scope_t
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|add_ecoff_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Build the symbolic information.  */
name|offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* Build the line number information.  */
name|hdr
operator|->
name|cbLineOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|ecoff_build_lineno
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|offset
argument_list|,
operator|&
name|hdr
operator|->
name|ilineMax
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|cbLine
operator|=
name|offset
operator|-
name|hdr
operator|->
name|cbLineOffset
expr_stmt|;
comment|/* We don't use dense numbers at all.  */
name|hdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|cbDnOffset
operator|=
literal|0
expr_stmt|;
comment|/* We can't build the PDR table until we have built the symbols,      because a PDR contains a symbol index.  However, we set aside      space at this point.  */
name|hdr
operator|->
name|ipdMax
operator|=
name|proc_cnt
expr_stmt|;
name|hdr
operator|->
name|cbPdOffset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|bufend
operator|-
operator|(
name|buf
operator|+
name|offset
operator|)
argument_list|)
operator|<
name|proc_cnt
operator|*
name|external_pdr_size
condition|)
operator|(
name|void
operator|)
name|ecoff_add_bytes
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|proc_cnt
operator|*
name|external_pdr_size
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|proc_cnt
operator|*
name|external_pdr_size
expr_stmt|;
comment|/* Build the local symbols.  */
name|hdr
operator|->
name|cbSymOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|ecoff_build_symbols
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|isymMax
operator|=
operator|(
name|offset
operator|-
name|hdr
operator|->
name|cbSymOffset
operator|)
operator|/
name|backend
operator|->
name|external_sym_size
expr_stmt|;
comment|/* Building the symbols initializes the symbol index in the PDR's.      Now we can swap out the PDR's.  */
operator|(
name|void
operator|)
name|ecoff_build_procs
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|hdr
operator|->
name|cbPdOffset
argument_list|)
expr_stmt|;
comment|/* We don't use optimization symbols.  */
name|hdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|cbOptOffset
operator|=
literal|0
expr_stmt|;
comment|/* Swap out the auxiliary type information.  */
name|hdr
operator|->
name|cbAuxOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|ecoff_build_aux
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|iauxMax
operator|=
operator|(
name|offset
operator|-
name|hdr
operator|->
name|cbAuxOffset
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
expr_stmt|;
comment|/* Copy out the local strings.  */
name|hdr
operator|->
name|cbSsOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|ecoff_build_ss
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|issMax
operator|=
name|offset
operator|-
name|hdr
operator|->
name|cbSsOffset
expr_stmt|;
comment|/* We don't use relative file descriptors.  */
name|hdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|cbRfdOffset
operator|=
literal|0
expr_stmt|;
comment|/* Swap out the file descriptors.  */
name|hdr
operator|->
name|cbFdOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|ecoff_build_fdr
argument_list|(
name|backend
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ifdMax
operator|=
operator|(
name|offset
operator|-
name|hdr
operator|->
name|cbFdOffset
operator|)
operator|/
name|backend
operator|->
name|external_fdr_size
expr_stmt|;
comment|/* Set up the external symbols, which are handled by the BFD back      end.  */
name|hdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|cbSsExtOffset
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|cbExtOffset
operator|=
literal|0
expr_stmt|;
name|ecoff_setup_ext
argument_list|()
expr_stmt|;
name|know
argument_list|(
operator|(
name|offset
operator|&
operator|(
name|backend
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This value should be determined from the .verstamp directive,      with reasonable defaults in config files.  */
ifdef|#
directive|ifdef
name|TC_ALPHA
name|hdr
operator|->
name|vstamp
operator|=
literal|0x030b
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|vstamp
operator|=
literal|0x020b
expr_stmt|;
endif|#
directive|endif
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a cluster of pages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_function
specifier|static
name|page_type
modifier|*
name|allocate_cluster
parameter_list|(
name|unsigned
name|long
name|npages
parameter_list|)
block|{
specifier|register
name|page_type
modifier|*
name|value
init|=
operator|(
name|page_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|npages
operator|*
name|PAGE_USIZE
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ECOFF_DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\talloc\tnpages = %d, value = 0x%.8x\n"
argument_list|,
name|npages
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|npages
operator|*
name|PAGE_USIZE
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|page_type
modifier|*
name|cluster_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pages_left
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_CHECK */
end_comment

begin_comment
comment|/* Allocate one page (which is initialized to 0).  */
end_comment

begin_function
specifier|static
name|page_type
modifier|*
name|allocate_page
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MALLOC_CHECK
if|if
condition|(
name|pages_left
operator|==
literal|0
condition|)
block|{
name|pages_left
operator|=
name|MAX_CLUSTER_PAGES
expr_stmt|;
name|cluster_ptr
operator|=
name|allocate_cluster
argument_list|(
name|pages_left
argument_list|)
expr_stmt|;
block|}
name|pages_left
operator|--
expr_stmt|;
return|return
name|cluster_ptr
operator|++
return|;
else|#
directive|else
comment|/* MALLOC_CHECK */
name|page_type
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
name|PAGE_USIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|PAGE_USIZE
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
endif|#
directive|endif
comment|/* MALLOC_CHECK */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate scoping information.  */
end_comment

begin_function
specifier|static
name|scope_t
modifier|*
name|allocate_scope
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|scope_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|scope_t
name|initial_scope
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|scope_t
operator|*
operator|)
name|NULL
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|scope
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|scope_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_scope
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
specifier|static
name|void
name|free_scope
parameter_list|(
name|scope_t
modifier|*
name|ptr
parameter_list|)
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate links for pages in a virtual array.  */
end_comment

begin_function
specifier|static
name|vlinks_t
modifier|*
name|allocate_vlinks
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|vlinks_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|vlinks_t
name|initial_vlinks
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|vlinks
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|vlinks_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_vlinks
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate string hash buckets.  */
end_comment

begin_function
specifier|static
name|shash_t
modifier|*
name|allocate_shash
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|shash_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|shash_t
name|initial_shash
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|shash
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|shash_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_shash
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate type hash buckets.  */
end_comment

begin_function
specifier|static
name|thash_t
modifier|*
name|allocate_thash
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|thash_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|thash_t
name|initial_thash
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|thash
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|thash_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_thash
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate structure, union, or enum tag information.  */
end_comment

begin_function
specifier|static
name|tag_t
modifier|*
name|allocate_tag
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|tag_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|tag_t
name|initial_tag
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|tag_t
operator|*
operator|)
name|NULL
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|tag
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|tag_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_tag
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
specifier|static
name|void
name|free_tag
parameter_list|(
name|tag_t
modifier|*
name|ptr
parameter_list|)
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR_T
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate forward reference to a yet unknown tag.  */
end_comment

begin_function
specifier|static
name|forward_t
modifier|*
name|allocate_forward
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|forward_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|forward_t
name|initial_forward
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|forward
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|forward_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_forward
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate head of type hash list.  */
end_comment

begin_function
specifier|static
name|thead_t
modifier|*
name|allocate_thead
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|thead_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|thead_t
name|initial_thead
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|thead_t
operator|*
operator|)
name|NULL
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|thead
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|thead_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_thead
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
specifier|static
name|void
name|free_thead
parameter_list|(
name|thead_t
modifier|*
name|ptr
parameter_list|)
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
operator|(
name|thead_t
operator|*
operator|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR_T
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|lineno_list_t
modifier|*
name|allocate_lineno_list
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|lineno_list_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|lineno_list_t
name|initial_lineno_list
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
specifier|register
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|unallocated
decl_stmt|;
specifier|register
name|page_type
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|lineno_list_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|lineno
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lineno_list_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_lineno
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_lineno_list
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|ecoff_set_gp_prolog_size
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
if|if
condition|(
name|cur_proc_ptr
operator|==
literal|0
condition|)
return|return;
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|gp_prologue
operator|=
name|sz
expr_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|gp_prologue
operator|!=
name|sz
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"GP prologue size exceeds field size, using 0 instead"
argument_list|)
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|gp_prologue
operator|=
literal|0
expr_stmt|;
block|}
name|cur_proc_ptr
operator|->
name|pdr
operator|.
name|gp_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ecoff_no_current_file
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ecoff_generate_asm_lineno
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|lineno_list_t
modifier|*
name|list
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|filename
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_stabs_filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|strcmp
argument_list|(
name|current_stabs_filename
argument_list|,
name|filename
argument_list|)
condition|)
name|add_file
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|allocate_lineno_list
argument_list|()
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|->
name|file
operator|=
name|cur_file_ptr
expr_stmt|;
name|list
operator|->
name|proc
operator|=
name|cur_proc_ptr
expr_stmt|;
name|list
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|list
operator|->
name|paddr
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|list
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
comment|/* We don't want to merge files which have line numbers.  */
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|fMerge
operator|=
literal|0
expr_stmt|;
comment|/* A .loc directive will sometimes appear before a .ent directive,      which means that cur_proc_ptr will be NULL here.  Arrange to      patch this up.  */
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|proc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|lineno_list_t
modifier|*
modifier|*
name|pl
decl_stmt|;
name|pl
operator|=
operator|&
name|noproc_lineno
expr_stmt|;
while|while
condition|(
operator|*
name|pl
operator|!=
operator|(
name|lineno_list_t
operator|*
operator|)
name|NULL
condition|)
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pl
operator|=
name|list
expr_stmt|;
block|}
else|else
block|{
name|last_lineno
operator|=
name|list
expr_stmt|;
operator|*
name|last_lineno_ptr
operator|=
name|list
expr_stmt|;
name|last_lineno_ptr
operator|=
operator|&
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|ecoff_generate_asm_lineno
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECOFF_DEBUGGING */
end_comment

end_unit

