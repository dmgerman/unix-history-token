begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* read.c - read a source file -    Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* If your chars aren't 8 bits, you will change this a bit (eg. to 0xFF).    But then, GNU isn't spozed to run on your machine anyway.    (RMS is so shortsighted sometimes.)  */
end_comment

begin_define
define|#
directive|define
name|MASK_CHAR
value|((int)(unsigned char) -1)
end_define

begin_comment
comment|/* This is the largest known floating point format (for now). It will    grow when we do 4361 style flonums.  */
end_comment

begin_define
define|#
directive|define
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
value|(16)
end_define

begin_comment
comment|/* Routines that read assembler source text to build spaghetti in memory.    Another group of these functions is in the expr.c module.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"listing.h"
end_include

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TC_START_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TC_START_LABEL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x == ':')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set by the object-format or the target.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_IMPLICIT_LCOMM_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TC_IMPLICIT_LCOMM_ALIGNMENT
parameter_list|(
name|SIZE
parameter_list|,
name|P2VAR
parameter_list|)
define|\
value|do								\     {								\       if ((SIZE)>= 8)						\ 	(P2VAR) = 3;						\       else if ((SIZE)>= 4)					\ 	(P2VAR) = 2;						\       else if ((SIZE)>= 2)					\ 	(P2VAR) = 1;						\       else							\ 	(P2VAR) = 0;						\     }								\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->next char of source file to parse.  */
end_comment

begin_if
if|#
directive|if
name|BITS_PER_CHAR
operator|!=
literal|8
end_if

begin_comment
comment|/*  The following table is indexed by[(char)] and will break if     a char does not have exactly 256 states (hopefully 0:255!)!  */
end_comment

begin_decl_stmt
name|die
name|horribly
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_AT
end_ifndef

begin_define
define|#
directive|define
name|LEX_AT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_BR
end_ifndef

begin_comment
comment|/* The RS/6000 assembler uses {,},[,] as parts of symbol names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_BR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_PCT
end_ifndef

begin_comment
comment|/* The Delta 68k assembler permits % inside label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_PCT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_QM
end_ifndef

begin_comment
comment|/* The PowerPC Windows NT assemblers permits ? inside label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_QM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_HASH
end_ifndef

begin_comment
comment|/* The IA-64 assembler uses # as a suffix designating a symbol.  We include    it in the symbol and strip it out in tc_canonicalize_symbol_name.  */
end_comment

begin_define
define|#
directive|define
name|LEX_HASH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_DOLLAR
end_ifndef

begin_define
define|#
directive|define
name|LEX_DOLLAR
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LEX_TILDE
end_ifndef

begin_comment
comment|/* The Delta 68k assembler permits ~ at start of label names.  */
end_comment

begin_define
define|#
directive|define
name|LEX_TILDE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used by is_... macros. our ctype[].  */
end_comment

begin_decl_stmt
name|char
name|lex_type
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LEX_HASH
block|,
name|LEX_DOLLAR
block|,
name|LEX_PCT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* _!"#$%&'()*+,-./ */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LEX_QM
block|,
comment|/* 0123456789:;<=>? */
name|LEX_AT
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
name|LEX_BR
block|,
literal|0
block|,
name|LEX_BR
block|,
literal|0
block|,
literal|3
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* `abcdefghijklmno */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
name|LEX_BR
block|,
literal|0
block|,
name|LEX_BR
block|,
name|LEX_TILDE
block|,
literal|0
block|,
comment|/* pqrstuvwxyz{|}~.  */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In: a character.    Out: 1 if this character ends a line.  */
end_comment

begin_decl_stmt
name|char
name|is_end_of_line
index|[
literal|256
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|CR_EOL
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* @abcdefghijklmno */
else|#
directive|else
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* @abcdefghijklmno */
endif|#
directive|endif
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* _!"#$%&'()*+,-./ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0123456789:;<=>? */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* */
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TC_CASE_SENSITIVE
end_ifndef

begin_decl_stmt
name|char
name|original_case_string
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions private to this file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st char of each buffer of lines is here.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->1 + last char in buffer.  */
end_comment

begin_comment
comment|/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1    in the tc-<CPU>.h file.  See the "Porting GAS" section of the    internals manual.  */
end_comment

begin_decl_stmt
name|int
name|target_big_endian
init|=
name|TARGET_BYTES_BIG_ENDIAN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for handling include file directory table.  */
end_comment

begin_comment
comment|/* Table of pointers to directories to search for .include's.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|include_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many are in the table.  */
end_comment

begin_decl_stmt
name|int
name|include_dir_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of longest in table.  */
end_comment

begin_decl_stmt
name|int
name|include_dir_maxlen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|struct
name|broken_word
modifier|*
name|broken_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The current offset into the absolute section.  We don't try to    build frags in the absolute section, since no data can be stored    there.  We just keep track of the current offset.  */
end_comment

begin_decl_stmt
name|addressT
name|abs_section_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this line had an MRI style label, it is stored in this variable.    This is used by some of the MRI pseudo-ops.  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|line_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This global variable is used to support MRI common sections.  We    translate such sections into a common symbol.  This variable is    non-NULL when we are in an MRI common section.  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|mri_common_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In MRI mode, after a dc.b pseudo-op with an odd number of bytes, we    need to align to an even byte boundary unless the next pseudo-op is    dc.b, ds.b, or dcb.b.  This variable is set to 1 if an alignment    may be needed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mri_pending_align
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_LISTING
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This variable is set to be non-zero if the next string we see might    be the name of the source file in DWARF debugging information.  See    the comment in emit_expr for the format we look for.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dwarf_file_string
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|do_s_func
parameter_list|(
name|int
name|end_p
parameter_list|,
specifier|const
name|char
modifier|*
name|default_prefix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_align
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_align
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_altmacro
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bad_end
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hex_float
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
name|expressionS
modifier|*
name|expP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pobegin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_line_sb
parameter_list|(
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_file_debug
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_find_end_of_line
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|read_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|pobegin
argument_list|()
expr_stmt|;
name|obj_read_begin_hook
argument_list|()
expr_stmt|;
comment|/* Something close -- but not too close -- to a multiple of 1024.      The debugging malloc I'm using has 24 bytes of overhead.  */
name|obstack_begin
argument_list|(
operator|&
name|notes
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|cond_obstack
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
comment|/* Use machine dependent syntax.  */
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Use more.  FIXME-SOMEDAY.  */
if|if
condition|(
name|flag_mri
condition|)
name|lex_type
index|[
literal|'?'
index|]
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|TC_ADDRESS_BYTES
end_ifndef

begin_define
define|#
directive|define
name|TC_ADDRESS_BYTES
value|address_bytes
end_define

begin_function
specifier|static
specifier|inline
name|int
name|address_bytes
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Choose smallest of 1, 2, 4, 8 bytes that is large enough to      contain an address.  */
name|int
name|n
init|=
operator|(
name|stdoutput
operator|->
name|arch_info
operator|->
name|bits_per_address
operator|-
literal|1
operator|)
operator|/
literal|8
decl_stmt|;
name|n
operator||=
name|n
operator|>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>
literal|2
expr_stmt|;
name|n
operator|+=
literal|1
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set up pseudo-op tables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|po_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|potable
index|[]
init|=
block|{
block|{
literal|"abort"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
block|{
literal|"altmacro"
block|,
name|s_altmacro
block|,
literal|1
block|}
block|,
block|{
literal|"ascii"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"balign"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"balignw"
block|,
name|s_align_bytes
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"balignl"
block|,
name|s_align_bytes
block|,
operator|-
literal|4
block|}
block|,
comment|/* block  */
block|{
literal|"byte"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"comm"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
block|{
literal|"common"
block|,
name|s_mri_common
block|,
literal|0
block|}
block|,
block|{
literal|"common.s"
block|,
name|s_mri_common
block|,
literal|1
block|}
block|,
block|{
literal|"data"
block|,
name|s_data
block|,
literal|0
block|}
block|,
block|{
literal|"dc"
block|,
name|cons
block|,
literal|2
block|}
block|,
ifdef|#
directive|ifdef
name|TC_ADDRESS_BYTES
block|{
literal|"dc.a"
block|,
name|cons
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"dc.b"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"dc.d"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"dc.l"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"dc.s"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dc.w"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"dc.x"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"dcb"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dcb.b"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"dcb.d"
block|,
name|s_float_space
block|,
literal|'d'
block|}
block|,
block|{
literal|"dcb.l"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"dcb.s"
block|,
name|s_float_space
block|,
literal|'f'
block|}
block|,
block|{
literal|"dcb.w"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dcb.x"
block|,
name|s_float_space
block|,
literal|'x'
block|}
block|,
block|{
literal|"ds"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"ds.b"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"ds.d"
block|,
name|s_space
block|,
literal|8
block|}
block|,
block|{
literal|"ds.l"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"ds.p"
block|,
name|s_space
block|,
literal|12
block|}
block|,
block|{
literal|"ds.s"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"ds.w"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"ds.x"
block|,
name|s_space
block|,
literal|12
block|}
block|,
block|{
literal|"debug"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|S_SET_DESC
block|{
literal|"desc"
block|,
name|s_desc
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* dim  */
block|{
literal|"double"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
comment|/* dsect  */
block|{
literal|"eject"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
comment|/* Formfeed listing.  */
block|{
literal|"else"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"elsec"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"elseif"
block|,
name|s_elseif
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"end"
block|,
name|s_end
block|,
literal|0
block|}
block|,
block|{
literal|"endc"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
block|{
literal|"endfunc"
block|,
name|s_func
block|,
literal|1
block|}
block|,
block|{
literal|"endif"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
block|{
literal|"endm"
block|,
name|s_bad_end
block|,
literal|0
block|}
block|,
block|{
literal|"endr"
block|,
name|s_bad_end
block|,
literal|1
block|}
block|,
comment|/* endef  */
block|{
literal|"equ"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"equiv"
block|,
name|s_set
block|,
literal|1
block|}
block|,
block|{
literal|"eqv"
block|,
name|s_set
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"err"
block|,
name|s_err
block|,
literal|0
block|}
block|,
block|{
literal|"error"
block|,
name|s_errwarn
block|,
literal|1
block|}
block|,
block|{
literal|"exitm"
block|,
name|s_mexit
block|,
literal|0
block|}
block|,
comment|/* extend  */
block|{
literal|"extern"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* We treat all undef as ext.  */
block|{
literal|"appfile"
block|,
name|s_app_file
block|,
literal|1
block|}
block|,
block|{
literal|"appline"
block|,
name|s_app_line
block|,
literal|0
block|}
block|,
block|{
literal|"fail"
block|,
name|s_fail
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_app_file
block|,
literal|0
block|}
block|,
block|{
literal|"fill"
block|,
name|s_fill
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"format"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"func"
block|,
name|s_func
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"globl"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"if"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"ifb"
block|,
name|s_ifb
block|,
literal|1
block|}
block|,
block|{
literal|"ifc"
block|,
name|s_ifc
block|,
literal|0
block|}
block|,
block|{
literal|"ifdef"
block|,
name|s_ifdef
block|,
literal|0
block|}
block|,
block|{
literal|"ifeq"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_eq
block|}
block|,
block|{
literal|"ifeqs"
block|,
name|s_ifeqs
block|,
literal|0
block|}
block|,
block|{
literal|"ifge"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ge
block|}
block|,
block|{
literal|"ifgt"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_gt
block|}
block|,
block|{
literal|"ifle"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_le
block|}
block|,
block|{
literal|"iflt"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_lt
block|}
block|,
block|{
literal|"ifnb"
block|,
name|s_ifb
block|,
literal|0
block|}
block|,
block|{
literal|"ifnc"
block|,
name|s_ifc
block|,
literal|1
block|}
block|,
block|{
literal|"ifndef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"ifne"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"ifnes"
block|,
name|s_ifeqs
block|,
literal|1
block|}
block|,
block|{
literal|"ifnotdef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"incbin"
block|,
name|s_incbin
block|,
literal|0
block|}
block|,
block|{
literal|"include"
block|,
name|s_include
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"irp"
block|,
name|s_irp
block|,
literal|0
block|}
block|,
block|{
literal|"irep"
block|,
name|s_irp
block|,
literal|0
block|}
block|,
block|{
literal|"irpc"
block|,
name|s_irp
block|,
literal|1
block|}
block|,
block|{
literal|"irepc"
block|,
name|s_irp
block|,
literal|1
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm
block|,
literal|0
block|}
block|,
block|{
literal|"lflags"
block|,
name|listing_flags
block|,
literal|0
block|}
block|,
comment|/* Listing flags.  */
block|{
literal|"linkonce"
block|,
name|s_linkonce
block|,
literal|0
block|}
block|,
block|{
literal|"list"
block|,
name|listing_list
block|,
literal|1
block|}
block|,
comment|/* Turn listing on.  */
block|{
literal|"llen"
block|,
name|listing_psize
block|,
literal|1
block|}
block|,
block|{
literal|"long"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lsym"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
block|{
literal|"macro"
block|,
name|s_macro
block|,
literal|0
block|}
block|,
block|{
literal|"mexit"
block|,
name|s_mexit
block|,
literal|0
block|}
block|,
block|{
literal|"mri"
block|,
name|s_mri
block|,
literal|0
block|}
block|,
block|{
literal|".mri"
block|,
name|s_mri
block|,
literal|0
block|}
block|,
comment|/* Special case so .mri works in MRI mode.  */
block|{
literal|"name"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"noaltmacro"
block|,
name|s_altmacro
block|,
literal|0
block|}
block|,
block|{
literal|"noformat"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"nolist"
block|,
name|listing_list
block|,
literal|0
block|}
block|,
comment|/* Turn listing off.  */
block|{
literal|"nopage"
block|,
name|listing_nopage
block|,
literal|0
block|}
block|,
block|{
literal|"octa"
block|,
name|cons
block|,
literal|16
block|}
block|,
block|{
literal|"offset"
block|,
name|s_struct
block|,
literal|0
block|}
block|,
block|{
literal|"org"
block|,
name|s_org
block|,
literal|0
block|}
block|,
block|{
literal|"p2align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
block|{
literal|"p2alignw"
block|,
name|s_align_ptwo
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"p2alignl"
block|,
name|s_align_ptwo
block|,
operator|-
literal|4
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"plen"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"print"
block|,
name|s_print
block|,
literal|0
block|}
block|,
block|{
literal|"psize"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
comment|/* Set paper size.  */
block|{
literal|"purgem"
block|,
name|s_purgem
block|,
literal|0
block|}
block|,
block|{
literal|"quad"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"rep"
block|,
name|s_rept
block|,
literal|0
block|}
block|,
block|{
literal|"rept"
block|,
name|s_rept
block|,
literal|0
block|}
block|,
block|{
literal|"rva"
block|,
name|s_rva
block|,
literal|4
block|}
block|,
block|{
literal|"sbttl"
block|,
name|listing_title
block|,
literal|1
block|}
block|,
comment|/* Subtitle of listing.  */
comment|/* scl  */
comment|/* sect  */
block|{
literal|"set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
comment|/* size  */
block|{
literal|"space"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"sleb128"
block|,
name|s_leb128
block|,
literal|1
block|}
block|,
block|{
literal|"spc"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"stabd"
block|,
name|s_stab
block|,
literal|'d'
block|}
block|,
block|{
literal|"stabn"
block|,
name|s_stab
block|,
literal|'n'
block|}
block|,
block|{
literal|"stabs"
block|,
name|s_stab
block|,
literal|'s'
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"struct"
block|,
name|s_struct
block|,
literal|0
block|}
block|,
comment|/* tag  */
block|{
literal|"text"
block|,
name|s_text
block|,
literal|0
block|}
block|,
comment|/* This is for gcc to use.  It's only just been added (2/94), so gcc      won't be able to use it for a while -- probably a year or more.      But once this has been released, check with gcc maintainers      before deleting it or even changing the spelling.  */
block|{
literal|"this_GCC_requires_the_GNU_assembler"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* If we're folding case -- done for some targets, not necessarily      all -- the above string in an input file will be converted to      this one.  Match it either way...  */
block|{
literal|"this_gcc_requires_the_gnu_assembler"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"title"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
comment|/* Listing title.  */
block|{
literal|"ttl"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
comment|/* type  */
block|{
literal|"uleb128"
block|,
name|s_leb128
block|,
literal|0
block|}
block|,
comment|/* use  */
comment|/* val  */
block|{
literal|"xcom"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
block|{
literal|"xdef"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"xref"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"xstabs"
block|,
name|s_xstab
block|,
literal|'s'
block|}
block|,
block|{
literal|"warning"
block|,
name|s_errwarn
block|,
literal|0
block|}
block|,
block|{
literal|"weakref"
block|,
name|s_weakref
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"zero"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
comment|/* End sentinel.  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|offsetT
name|get_absolute_expr
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|expression_and_evaluate
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad or irreducible absolute expression"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|exp
operator|->
name|X_add_number
return|;
block|}
end_function

begin_function
name|offsetT
name|get_absolute_expression
parameter_list|(
name|void
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
return|return
name|get_absolute_expr
argument_list|(
operator|&
name|exp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|pop_override_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pop_table_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pop_insert
parameter_list|(
specifier|const
name|pseudo_typeS
modifier|*
name|table
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errtxt
decl_stmt|;
specifier|const
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
for|for
control|(
name|pop
operator|=
name|table
init|;
name|pop
operator|->
name|poc_name
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtxt
operator|&&
operator|(
operator|!
name|pop_override_ok
operator|||
name|strcmp
argument_list|(
name|errtxt
argument_list|,
literal|"exists"
argument_list|)
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"error constructing %s pseudo-op table: %s"
argument_list|)
argument_list|,
name|pop_table_name
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|md_pop_insert
end_ifndef

begin_define
define|#
directive|define
name|md_pop_insert
parameter_list|()
value|pop_insert(md_pseudo_table)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|obj_pop_insert
end_ifndef

begin_define
define|#
directive|define
name|obj_pop_insert
parameter_list|()
value|pop_insert(obj_pseudo_table)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|cfi_pop_insert
end_ifndef

begin_define
define|#
directive|define
name|cfi_pop_insert
parameter_list|()
value|pop_insert(cfi_pseudo_table)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|pobegin
parameter_list|(
name|void
parameter_list|)
block|{
name|po_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Do the target-specific pseudo ops.  */
name|pop_table_name
operator|=
literal|"md"
expr_stmt|;
name|md_pop_insert
argument_list|()
expr_stmt|;
comment|/* Now object specific.  Skip any that were in the target table.  */
name|pop_table_name
operator|=
literal|"obj"
expr_stmt|;
name|pop_override_ok
operator|=
literal|1
expr_stmt|;
name|obj_pop_insert
argument_list|()
expr_stmt|;
comment|/* Now portable ones.  Skip any that we've seen already.  */
name|pop_table_name
operator|=
literal|"standard"
expr_stmt|;
name|pop_insert
argument_list|(
name|potable
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_USE_CFIPOP
name|pop_table_name
operator|=
literal|"cfi"
expr_stmt|;
name|pop_override_ok
operator|=
literal|1
expr_stmt|;
name|cfi_pop_insert
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|HANDLE_CONDITIONAL_ASSEMBLY
parameter_list|()
define|\
value|if (ignore_input ())							\     {									\       char *eol = find_end_of_line (input_line_pointer, flag_m68k_mri);	\       input_line_pointer = (input_line_pointer<= buffer_limit		\&& eol>= buffer_limit)			\ 			   ? buffer_limit				\ 			   : eol + 1;					\       continue;								\     }
end_define

begin_comment
comment|/* This function is used when scrubbing the characters between #APP    and #NO_APP.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scrub_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scrub_string_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|scrub_from_string
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|int
name|copy
decl_stmt|;
name|copy
operator|=
name|scrub_string_end
operator|-
name|scrub_string
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|buflen
condition|)
name|copy
operator|=
name|buflen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|scrub_string
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|scrub_string
operator|+=
name|copy
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Helper function of read_a_source_file, which tries to expand a macro.  */
end_comment

begin_function
specifier|static
name|int
name|try_macro
parameter_list|(
name|char
name|term
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|sb
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|macro_entry
modifier|*
name|macro
decl_stmt|;
if|if
condition|(
name|check_macro
argument_list|(
name|line
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|macro
argument_list|)
condition|)
block|{
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|++
operator|=
name|term
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|out
argument_list|,
name|input_line_pointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_macro_info
name|md_macro_info
argument_list|(
name|macro
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We read the file, putting things into a web that represents what we    have been reading.  */
end_comment

begin_function
name|void
name|read_a_source_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* String of symbol, '\0' appended.  */
specifier|register
name|int
name|temp
decl_stmt|;
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
ifdef|#
directive|ifdef
name|WARN_COMMENTS
name|found_comment
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|input_scrub_new_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_newline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|register_dependency
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Generate debugging information before we've read anything in to denote      this file as the "main" source file and not a subordinate one      (e.g. N_SO vs N_SOL in stabs).  */
name|generate_file_debug
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We have another line to parse.  */
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* In order to avoid listing macro expansion lines with labels 	 multiple times, keep track of which line was last issued.  */
specifier|static
name|char
modifier|*
name|last_eol
decl_stmt|;
name|last_eol
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|buffer_limit
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Must have a sentinel.  */
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
condition|)
block|{
comment|/* We have more of this buffer to parse.  */
comment|/* We now have input_line_pointer->1st char of next line. 	     If input_line_pointer [-1] == '\n' then we just 	     scanned another line: so bump line counters.  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|md_start_line_hook
name|md_start_line_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|LABELS_WITHOUT_COLONS
operator|||
name|flag_m68k_mri
condition|)
block|{
comment|/* Text at the start of a line must be a label, we 		     run down and stick a colon in.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|line_start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|mri_line_macro
decl_stmt|;
name|LISTING_NEWLINE
argument_list|()
expr_stmt|;
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* In MRI mode, the EQU and MACRO pseudoops must 			 be handled specially.  */
name|mri_line_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|rest
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|':'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|' '
operator|||
operator|*
name|rest
operator|==
literal|'\t'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"EQU"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rest
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
name|rest
operator|+
literal|3
expr_stmt|;
name|equals
argument_list|(
name|line_start
argument_list|,
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"MACRO"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|rest
index|[
literal|5
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|5
index|]
operator|==
literal|'\t'
operator|||
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|rest
index|[
literal|5
index|]
index|]
operator|)
condition|)
name|mri_line_macro
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In MRI mode, we need to handle the MACRO 			 pseudo-op specially: we don't want to put the 			 symbol in the symbol table.  */
if|if
condition|(
operator|!
name|mri_line_macro
ifdef|#
directive|ifdef
name|TC_START_LABEL_WITHOUT_COLON
operator|&&
name|TC_START_LABEL_WITHOUT_COLON
argument_list|(
name|c
argument_list|,
name|input_line_pointer
argument_list|)
endif|#
directive|endif
condition|)
name|line_label
operator|=
name|colon
argument_list|(
name|line_start
argument_list|)
expr_stmt|;
else|else
name|line_label
operator|=
name|symbol_create
argument_list|(
name|line_start
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* We are at the beginning of a line, or similar place. 	     We expect a well-formed assembler statement. 	     A "symbol-name:" is a statement.  	     Depending on what compiler is used, the order of these tests 	     may vary to catch most common case 1st. 	     Each test is independent of all other tests at the (top) level. 	     PLEASE make a compiler that doesn't use this assembler. 	     It is crufty to waste a compiler's time encoding things for this 	     assembler, which then wastes more time decoding it. 	     (And communicating via (linear) files is silly! 	     If you must pass stuff, please pass a tree!)  */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|)
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|0
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
name|know
argument_list|(
name|c
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* No further leading whitespace.  */
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* If listing is on, and we are expanding a macro, then give 	     the listing code the contents of the expanded line.  */
if|if
condition|(
name|listing
condition|)
block|{
if|if
condition|(
operator|(
name|listing
operator|&
name|LISTING_MACEXP
operator|)
operator|&&
name|macro_nest
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Find the end of the current expanded macro line.  */
name|s
operator|=
name|find_end_of_line
argument_list|(
name|input_line_pointer
operator|-
literal|1
argument_list|,
name|flag_m68k_mri
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|last_eol
condition|)
block|{
name|last_eol
operator|=
name|s
expr_stmt|;
comment|/* Copy it for safe keeping.  Also give an indication of 			 how much macro nesting is involved at this point.  */
name|len
operator|=
name|s
operator|-
operator|(
name|input_line_pointer
operator|-
literal|1
operator|)
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
name|macro_nest
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|copy
argument_list|,
literal|'>'
argument_list|,
name|macro_nest
argument_list|)
expr_stmt|;
name|copy
index|[
name|macro_nest
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|copy
operator|+
name|macro_nest
operator|+
literal|1
argument_list|,
name|input_line_pointer
operator|-
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|macro_nest
operator|+
literal|1
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Install the line with the listing facility.  */
name|listing_newline
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|listing_newline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* C is the 1st significant character. 	     Input_line_pointer points after that character.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Want user-defined label or pseudo/opcode.  */
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|s
operator|=
operator|--
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* name's delimiter.  */
comment|/* C is character after symbol. 		 That character's place in the input line is now '\0'. 		 S points to the beginning of the symbol. 		   [In case of pseudo-op, s->'.'.] 		 Input_line_pointer->'\0' where c was.  */
if|if
condition|(
name|TC_START_LABEL
argument_list|(
name|c
argument_list|,
name|input_line_pointer
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|char
modifier|*
name|rest
init|=
name|input_line_pointer
operator|+
literal|1
decl_stmt|;
comment|/* In MRI mode, \tsym: set 0 is permitted.  */
if|if
condition|(
operator|*
name|rest
operator|==
literal|':'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|' '
operator|||
operator|*
name|rest
operator|==
literal|'\t'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"EQU"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"SET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rest
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
name|rest
operator|+
literal|3
expr_stmt|;
name|equals
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|line_label
operator|=
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* User-defined label.  */
comment|/* Put ':' back for error messages' sake.  */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_check_label
name|tc_check_label
argument_list|(
name|line_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Input_line_pointer->after ':'.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'='
operator|&&
operator|(
name|c
operator|==
literal|'='
operator|||
operator|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'='
operator|)
operator|)
condition|)
block|{
name|equals
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'='
operator|||
operator|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'='
operator|)
operator|)
ifdef|#
directive|ifdef
name|TC_EQUAL_IN_INSN
operator|&&
operator|!
name|TC_EQUAL_IN_INSN
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|equals
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Expect pseudo-op or machine instruction.  */
name|pop
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|TC_CASE_SENSITIVE
block|{
name|char
modifier|*
name|s2
init|=
name|s
decl_stmt|;
name|strncpy
argument_list|(
name|original_case_string
argument_list|,
name|s2
argument_list|,
sizeof|sizeof
argument_list|(
name|original_case_string
argument_list|)
argument_list|)
expr_stmt|;
name|original_case_string
index|[
sizeof|sizeof
argument_list|(
name|original_case_string
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s2
condition|)
block|{
operator|*
name|s2
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|NO_PSEUDO_DOT
operator|||
name|flag_m68k_mri
condition|)
block|{
comment|/* The MRI assembler uses pseudo-ops without 			 a period.  */
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop
operator|!=
name|NULL
operator|&&
name|pop
operator|->
name|poc_handler
operator|==
name|NULL
condition|)
name|pop
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pop
operator|!=
name|NULL
operator|||
operator|(
operator|!
name|flag_m68k_mri
operator|&&
operator|*
name|s
operator|==
literal|'.'
operator|)
condition|)
block|{
comment|/* PSEUDO - OP.  			 WARNING: c has next char, which may be end-of-line. 			 We lookup the pseudo-op table with s+1 because we 			 already know that the pseudo-op begins with a '.'.  */
if|if
condition|(
name|pop
operator|==
name|NULL
condition|)
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop
operator|&&
operator|!
name|pop
operator|->
name|poc_handler
condition|)
name|pop
operator|=
name|NULL
expr_stmt|;
comment|/* In MRI mode, we may need to insert an 			 automatic alignment directive.  What a hack 			 this is.  */
if|if
condition|(
name|mri_pending_align
operator|&&
operator|(
name|pop
operator|==
name|NULL
operator|||
operator|!
operator|(
operator|(
name|pop
operator|->
name|poc_handler
operator|==
name|cons
operator|&&
name|pop
operator|->
name|poc_val
operator|==
literal|1
operator|)
operator|||
operator|(
name|pop
operator|->
name|poc_handler
operator|==
name|s_space
operator|&&
name|pop
operator|->
name|poc_val
operator|==
literal|1
operator|)
ifdef|#
directive|ifdef
name|tc_conditional_pseudoop
operator|||
name|tc_conditional_pseudoop
argument_list|(
name|pop
argument_list|)
endif|#
directive|endif
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_if
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifdef
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifc
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ifeqs
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_else
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_endif
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_globl
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_ignore
operator|)
operator|)
condition|)
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mri_pending_align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print the error msg now, while we still can.  */
if|if
condition|(
name|pop
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|end
init|=
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|--
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|macro_defined
operator|||
operator|!
name|try_macro
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown pseudo-op: `%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Put it back for error messages etc.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* The following skip of whitespace is compulsory. 			 A well shaped space is sometimes all that separates 			 keyword from operands.  */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Input_line is restored. 			 Input_line_pointer->1st non-blank char 			 after pseudo-operation.  */
call|(
modifier|*
name|pop
operator|->
name|poc_handler
call|)
argument_list|(
name|pop
operator|->
name|poc_val
argument_list|)
expr_stmt|;
comment|/* If that was .end, just get out now.  */
if|if
condition|(
name|pop
operator|->
name|poc_handler
operator|==
name|s_end
condition|)
goto|goto
name|quit
goto|;
block|}
else|else
block|{
comment|/* WARNING: c has char, which may be end-of-line.  */
comment|/* Also: input_line_pointer->`\0` where c was.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|_find_end_of_line
argument_list|(
name|input_line_pointer
argument_list|,
name|flag_m68k_mri
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|generate_lineno_debug
argument_list|()
expr_stmt|;
if|if
condition|(
name|macro_defined
operator|&&
name|try_macro
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|mri_pending_align
condition|)
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mri_pending_align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|md_assemble
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assemble 1 instruction.  */
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* We resume loop AFTER the end-of-line from 			 this instruction.  */
block|}
block|}
continue|continue;
block|}
comment|/* Empty statement?  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|LOCAL_LABELS_DOLLAR
operator|||
name|LOCAL_LABELS_FB
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* local label  ("4:")  */
name|char
modifier|*
name|backup
init|=
name|input_line_pointer
decl_stmt|;
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|temp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* Read the whole number.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|temp
operator|=
operator|(
name|temp
operator|*
literal|10
operator|)
operator|+
operator|*
name|input_line_pointer
operator|-
literal|'0'
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"label \"%d$\" redefined"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|define_dollar_label
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|dollar_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCAL_LABELS_FB
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|==
literal|':'
condition|)
block|{
name|fb_label_instance_inc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|fb_label_name
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|input_line_pointer
operator|=
name|backup
expr_stmt|;
block|}
comment|/* local label  ("4:") */
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|line_comment_chars
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* Its a comment.  Better say APP or NO_APP.  */
name|sb
name|sbuf
decl_stmt|;
name|char
modifier|*
name|ends
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|char
modifier|*
name|new_tmp
decl_stmt|;
name|unsigned
name|int
name|new_length
decl_stmt|;
name|char
modifier|*
name|tmp_buf
init|=
literal|0
decl_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"APP\n"
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* We ignore it */
name|s
operator|+=
literal|4
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ends
condition|)
block|{
name|unsigned
name|int
name|tmp_len
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
comment|/* The end of the #APP wasn't in this buffer.  We 		     keep reading in buffers until we find the #NO_APP 		     that goes with this #APP  There is one.  The specs 		     guarantee it...  */
name|tmp_len
operator|=
name|buffer_limit
operator|-
name|s
expr_stmt|;
name|tmp_buf
operator|=
name|xmalloc
argument_list|(
name|tmp_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
argument_list|,
name|s
argument_list|,
name|tmp_len
argument_list|)
expr_stmt|;
do|do
block|{
name|new_tmp
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_tmp
condition|)
break|break;
else|else
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
name|input_line_pointer
operator|=
name|buffer
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ends
condition|)
name|num
operator|=
name|ends
operator|-
name|buffer
expr_stmt|;
else|else
name|num
operator|=
name|buffer_limit
operator|-
name|buffer
expr_stmt|;
name|tmp_buf
operator|=
name|xrealloc
argument_list|(
name|tmp_buf
argument_list|,
name|tmp_len
operator|+
name|num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
operator|+
name|tmp_len
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|tmp_len
operator|+=
name|num
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ends
condition|)
do|;
name|input_line_pointer
operator|=
name|ends
condition|?
name|ends
operator|+
literal|8
else|:
name|NULL
expr_stmt|;
name|s
operator|=
name|tmp_buf
expr_stmt|;
name|ends
operator|=
name|s
operator|+
name|tmp_len
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|ends
operator|+
literal|8
expr_stmt|;
block|}
name|scrub_string
operator|=
name|s
expr_stmt|;
name|scrub_string_end
operator|=
name|ends
expr_stmt|;
name|new_length
operator|=
name|ends
operator|-
name|s
expr_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_length
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|space
decl_stmt|;
name|int
name|size
decl_stmt|;
name|space
operator|=
operator|(
name|new_buf
operator|+
name|new_length
operator|)
operator|-
name|new_tmp
expr_stmt|;
name|size
operator|=
name|do_scrub_chars
argument_list|(
name|scrub_from_string
argument_list|,
name|new_tmp
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|space
condition|)
block|{
name|new_tmp
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new_buf
operator|=
name|xrealloc
argument_list|(
name|new_buf
argument_list|,
name|new_length
operator|+
literal|100
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
operator|+
name|new_length
expr_stmt|;
name|new_length
operator|+=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|tmp_buf
condition|)
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
comment|/* We've "scrubbed" input to the preferred format.  In the 		 process we may have consumed the whole of the remaining 		 file (and included files).  We handle this formatted 		 input similar to that of macro expansion, letting 		 actual macro expansion (possibly nested) and other 		 input expansion work.  Beware that in messages, line 		 numbers and possibly file names will be incorrect.  */
name|sb_add_string
argument_list|(
operator|&
name|sbuf
argument_list|,
name|new_buf
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|sbuf
argument_list|,
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_unrecognized_line
if|if
condition|(
name|tc_unrecognized_line
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Report unknown char as ignored.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|md_after_pass_hook
name|md_after_pass_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|quit
label|:
ifdef|#
directive|ifdef
name|md_cleanup
name|md_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Close the input file.  */
name|input_scrub_close
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WARN_COMMENTS
block|{
if|if
condition|(
name|warn_comment
operator|&&
name|found_comment
condition|)
name|as_warn_where
argument_list|(
name|found_comment_file
argument_list|,
name|found_comment
argument_list|,
literal|"first comment found here"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Convert O_constant expression EXP into the equivalent O_big representation.    Take the sign of the number from X_unsigned rather than X_add_number.  */
end_comment

begin_function
specifier|static
name|void
name|convert_to_bignum
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|valueT
name|value
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|value
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
operator|/
name|CHARS_PER_LITTLENUM
condition|;
name|i
operator|++
control|)
block|{
name|generic_bignum
index|[
name|i
index|]
operator|=
name|value
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|value
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
comment|/* Add a sequence of sign bits if the top bit of X_add_number is not      the sign of the original value.  */
if|if
condition|(
operator|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0
operator|)
operator|!=
operator|!
name|exp
operator|->
name|X_unsigned
condition|)
name|generic_bignum
index|[
name|i
operator|++
index|]
operator|=
name|exp
operator|->
name|X_unsigned
condition|?
literal|0
else|:
name|LITTLENUM_MASK
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_big
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For most MRI pseudo-ops, the line actually ends at the first    nonquoted space.  This function looks for that point, stuffs a null    in, and sets *STOPCP to the character that used to be there, and    returns the location.     Until I hear otherwise, I am going to assume that this is only true    for the m68k MRI assembler.  */
end_comment

begin_function
name|char
modifier|*
name|mri_comment_field
parameter_list|(
name|char
modifier|*
name|stopcp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|int
name|inquote
init|=
literal|0
decl_stmt|;
name|know
argument_list|(
name|flag_m68k_mri
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|(
operator|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|)
operator|||
name|inquote
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
condition|;
name|s
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
operator|*
name|stopcp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Skip to the end of an MRI comment field.  */
end_comment

begin_function
name|void
name|mri_comment_end
parameter_list|(
name|char
modifier|*
name|stop
parameter_list|,
name|int
name|stopc
parameter_list|)
block|{
name|know
argument_list|(
name|flag_mri
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|stop
expr_stmt|;
operator|*
name|stop
operator|=
name|stopc
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_abort
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|".abort detected.  Abandoning ship."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Guts of .align directive.  N is the power of two to which to align.    FILL may be NULL, or it may point to the bytes of the fill pattern.    LEN is the length of whatever FILL points to, if anything.  MAX is    the maximum number of characters to skip when doing the alignment,    or 0 if there is no maximum.  */
end_comment

begin_function
specifier|static
name|void
name|do_align
parameter_list|(
name|int
name|n
parameter_list|,
name|char
modifier|*
name|fill
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|fill
operator|!=
name|NULL
condition|)
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|fill
operator|++
operator|!=
literal|'\0'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring fill value in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fill
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_do_align
name|md_do_align
argument_list|(
name|n
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|,
name|just_record_alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Only make a frag if we HAVE to...  */
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|fill
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|frag_align_code
argument_list|(
name|n
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|frag_align
argument_list|(
name|n
argument_list|,
operator|*
name|fill
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|md_do_align
name|just_record_alignment
label|:
name|ATTRIBUTE_UNUSED_LABEL
endif|#
directive|endif
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|n
operator|-
name|OCTETS_PER_BYTE_POWER
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op.  A positive ARG is a default alignment    (in bytes).  A negative ARG is the negative of the length of the    fill pattern.  BYTES_P is non-zero if the alignment value should be    interpreted as the byte boundary, rather than the power of 2.  */
end_comment

begin_define
define|#
directive|define
name|ALIGN_LIMIT
value|(stdoutput->arch_info->bits_per_address - 1)
end_define

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|bytes_p
parameter_list|)
block|{
name|unsigned
name|int
name|align_limit
init|=
name|ALIGN_LIMIT
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|offsetT
name|fill
init|=
literal|0
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|fill_p
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
name|align
operator|=
literal|0
expr_stmt|;
else|else
name|align
operator|=
name|arg
expr_stmt|;
comment|/* Default value from pseudo-op table.  */
block|}
else|else
block|{
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bytes_p
condition|)
block|{
comment|/* Convert to a power of 2.  */
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|align
operator|>
name|align_limit
condition|)
block|{
name|align
operator|=
name|align_limit
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment too large: %u assumed"
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|fill_p
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|fill_p
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|fill_p
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|max
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|max
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fill_p
condition|)
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expected fill pattern missing"
argument_list|)
argument_list|)
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fill_len
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
literal|0
condition|)
name|fill_len
operator|=
literal|1
expr_stmt|;
else|else
name|fill_len
operator|=
operator|-
name|arg
expr_stmt|;
if|if
condition|(
name|fill_len
operator|<=
literal|1
condition|)
block|{
name|char
name|fill_char
decl_stmt|;
name|fill_char
operator|=
name|fill
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
operator|&
name|fill_char
argument_list|,
name|fill_len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|ab
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|fill_len
operator|>
sizeof|sizeof
name|ab
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ab
argument_list|,
name|fill
argument_list|,
name|fill_len
argument_list|)
expr_stmt|;
name|do_align
argument_list|(
name|align
argument_list|,
name|ab
argument_list|,
name|fill_len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op on machines where ".align 4" means    align to a 4 byte boundary.  */
end_comment

begin_function
name|void
name|s_align_bytes
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|s_align
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op on machines where ".align 4" means align    to a 2**4 boundary.  */
end_comment

begin_function
name|void
name|s_align_ptwo
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|s_align
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch in and out of alternate macro mode.  */
end_comment

begin_function
name|void
name|s_altmacro
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|macro_set_alternate
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|s_comm_internal
parameter_list|(
name|int
name|param
parameter_list|,
name|symbolS
modifier|*
function_decl|(
modifier|*
name|comm_parse_extra
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|addressT
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|temp
decl_stmt|,
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|p
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Accept an optional comma after the name.  The comma used to be      required, but Irix 5 cc does not generate it for .lcomm.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expr
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|size
operator|=
name|temp
expr_stmt|;
name|size
operator|&=
operator|(
operator|(
name|offsetT
operator|)
literal|2
operator|<<
operator|(
name|stdoutput
operator|->
name|arch_info
operator|->
name|bits_per_address
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing size expression"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|!=
name|size
operator|||
operator|!
name|exp
operator|.
name|X_unsigned
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"size (%ld) out of range, ignored"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|symbol_equated_p
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_VOLATILE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|=
name|NULL
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* This could be avoided when the symbol wasn't used so far, but 	 the comment in struc-symbol.h says this flag isn't reliable.  */
if|if
condition|(
literal|1
operator|||
operator|!
name|symbol_used_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|symbolP
operator|=
name|symbol_clone
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_CLEAR_VOLATILE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|temp
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|!=
name|temp
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"size of \"%s\" is already %ld; not changing to %ld"
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|comm_parse_extra
operator|!=
name|NULL
condition|)
name|symbolP
operator|=
call|(
modifier|*
name|comm_parse_extra
call|)
argument_list|(
name|param
argument_list|,
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
block|{
specifier|extern
name|int
name|flag_one
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
operator|!
name|flag_one
condition|)
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|out
label|:
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_function
name|void
name|s_comm
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|s_comm_internal
argument_list|(
name|ignore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MRI COMMON pseudo-op.  We handle this by creating a common    symbol with the appropriate name.  We make s_space do the right    thing by increasing the size.  */
end_comment

begin_function
name|void
name|s_mri_common
parameter_list|(
name|int
name|small
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|alc
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
operator|!
name|flag_mri
condition|)
block|{
name|s_comm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
else|else
block|{
do|do
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
do|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|alc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
operator|+
operator|(
name|input_line_pointer
operator|-
name|name
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|alc
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
block|}
block|}
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return;
block|}
name|S_SET_EXTERNAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|sym
expr_stmt|;
ifdef|#
directive|ifdef
name|S_SET_ALIGN
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
name|S_SET_ALIGN
argument_list|(
name|sym
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|line_label
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: We just ignore the small argument, which distinguishes      COMMON and COMMON.S.  I don't know what we can do about it.  */
comment|/* Ignore the type and hptype.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_data
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segT
name|section
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
name|section
operator|=
name|text_section
expr_stmt|;
name|temp
operator|+=
literal|1000
expr_stmt|;
block|}
else|else
name|section
operator|=
name|data_section
expr_stmt|;
name|subseg_set
argument_list|(
name|section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|const_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .appfile pseudo-op.  This is automatically generated by    do_scrub_chars when a preprocessor # line comment is seen with a    file name.  This default definition may be overridden by the object    or CPU specific pseudo-ops.  This function is also the default    definition for .file; the APPFILE argument is 1 for .appfile, 0 for    .file.  */
end_comment

begin_function
name|void
name|s_app_file_string
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|appfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|register_dependency
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obj_app_file
name|obj_app_file
argument_list|(
name|file
argument_list|,
name|appfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|s_app_file
parameter_list|(
name|int
name|appfile
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Some assemblers tolerate immediately following '"'.  */
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this is a fake .appfile, a fake newline was inserted into 	 the buffer.  Passing -2 to new_logical_line tells it to 	 account for it.  */
name|int
name|may_omit
init|=
operator|(
operator|!
name|new_logical_line
argument_list|(
name|s
argument_list|,
name|appfile
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
argument_list|)
operator|&&
name|appfile
operator|)
decl_stmt|;
comment|/* In MRI mode, the preprocessor may have inserted an extraneous 	 backquote.  */
if|if
condition|(
name|flag_m68k_mri
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'\''
operator|&&
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|1
index|]
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|may_omit
condition|)
name|s_app_file_string
argument_list|(
name|s
argument_list|,
name|appfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the .appline pseudo-op.  This is automatically generated by    do_scrub_chars when a preprocessor # line comment is seen.  This    default definition may be overridden by the object or CPU specific    pseudo-ops.  */
end_comment

begin_function
name|void
name|s_app_line
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
comment|/* The given number is that of the next line.  */
name|l
operator|=
name|get_absolute_expression
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|<
operator|-
literal|1
condition|)
comment|/* Some of the back ends can't deal with non-positive line numbers.        Besides, it's silly.  GCC however will generate a line number of        zero when it is pre-processing builtins for assembler-with-cpp files:            # 0 "<built-in>"         We do not want to barf on this, especially since such files are used        in the GCC and GDB testsuites.  So we check for negative line numbers        rather than non-positive line numbers.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"line numbers must be positive; line number %d rejected"
argument_list|)
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .end pseudo-op.  Actually, the real work is done in    read_a_source_file.  */
end_comment

begin_function
name|void
name|s_end
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|flag_mri
condition|)
block|{
comment|/* The MRI assembler permits the start symbol to follow .end, 	 but we don't support that.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'*'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'!'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"start address not supported"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the .err pseudo-op.  */
end_comment

begin_function
name|void
name|s_err
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".err encountered"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .error and .warning pseudo-ops.  */
end_comment

begin_function
name|void
name|s_errwarn
parameter_list|(
name|int
name|err
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* The purpose for the conditional assignment is not to      internationalize the directive itself, but that we need a      self-contained message, one that can be passed like the      demand_copy_C_string return value, and with no assumption on the      location of the name of the directive within the message.  */
name|char
modifier|*
name|msg
init|=
operator|(
name|err
condition|?
name|_
argument_list|(
literal|".error directive invoked in source file"
argument_list|)
else|:
name|_
argument_list|(
literal|".warning directive invoked in source file"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s argument must be a string"
argument_list|)
argument_list|,
name|err
condition|?
literal|".error"
else|:
literal|".warning"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|msg
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
name|err
condition|)
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI fail pseudo-op.  */
end_comment

begin_function
name|void
name|s_fail
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|offsetT
name|temp
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|500
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".fail %ld encountered"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".fail %ld encountered"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_fill
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|rep_exp
decl_stmt|;
name|long
name|size
init|=
literal|1
decl_stmt|;
specifier|register
name|long
name|fill
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|get_known_segmented_expression
argument_list|(
operator|&
name|rep_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* This is to be compatible with BSD 4.2 AS, not for any rational reason.  */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_8
value|(8)
if|if
condition|(
name|size
operator|>
name|BSD_FILL_SIZE_CROCK_8
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".fill size clamped to %d"
argument_list|)
argument_list|,
name|BSD_FILL_SIZE_CROCK_8
argument_list|)
expr_stmt|;
name|size
operator|=
name|BSD_FILL_SIZE_CROCK_8
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"size negative; .fill ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep_exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|rep_exp
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|rep_exp
operator|.
name|X_add_number
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"repeat< 0; .fill ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|rep_exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|rep_exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't have a constant repeat count, so we can't use 	     rs_fill.  We can get the same results out of rs_space, 	     but its argument is in bytes, so we must multiply the 	     repeat count by size.  */
name|symbolS
modifier|*
name|rep_sym
decl_stmt|;
name|rep_sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|rep_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|1
condition|)
block|{
name|expressionS
name|size_exp
decl_stmt|;
name|size_exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|size_exp
operator|.
name|X_add_number
operator|=
name|size
expr_stmt|;
name|rep_exp
operator|.
name|X_op
operator|=
name|O_multiply
expr_stmt|;
name|rep_exp
operator|.
name|X_add_symbol
operator|=
name|rep_sym
expr_stmt|;
name|rep_exp
operator|.
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|size_exp
argument_list|)
expr_stmt|;
name|rep_exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|rep_sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|rep_exp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_space
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|rep_sym
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
comment|/* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX 	 flavoured AS.  The following bizarre behaviour is to be 	 compatible with above.  I guess they tried to take up to 8 	 bytes from a 4-byte expression and they forgot to sign 	 extend.  */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_4
value|(4)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|fill
argument_list|,
operator|(
name|size
operator|>
name|BSD_FILL_SIZE_CROCK_4
condition|?
name|BSD_FILL_SIZE_CROCK_4
else|:
operator|(
name|int
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes) 	 but emits no error message because it seems a legal thing to do. 	 It is a degenerate case of .fill but could be emitted by a 	 compiler.  */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_globl
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI IRP and IRPC pseudo-ops.  */
end_comment

begin_function
name|void
name|s_irp
parameter_list|(
name|int
name|irpc
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|sb
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|sb
name|out
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|eol
operator|=
name|find_end_of_line
argument_list|(
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
operator|&
name|s
argument_list|,
name|input_line_pointer
argument_list|,
name|eol
operator|-
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|eol
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|err
operator|=
name|expand_irp
argument_list|(
name|irpc
argument_list|,
literal|0
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|out
argument_list|,
name|get_line_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|out
argument_list|,
name|input_line_pointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .linkonce pseudo-op.  This tells the assembler to mark    the section to only be linked once.  However, this is not supported    by most object file formats.  This takes an optional argument,    which is what to do about duplicates.  */
end_comment

begin_function
name|void
name|s_linkonce
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|linkonce_type
name|type
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|type
operator|=
name|LINKONCE_DISCARD
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"discard"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_DISCARD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"one_only"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_ONE_ONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"same_size"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_SAME_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
literal|"same_contents"
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|LINKONCE_SAME_CONTENTS
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognized .linkonce type `%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|obj_handle_link_once
name|obj_handle_link_once
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! defined (obj_handle_link_once) */
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".linkonce is not supported for this object file format"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|LINKONCE_DISCARD
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
case|case
name|LINKONCE_ONE_ONLY
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_ONE_ONLY
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_SIZE
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_CONTENTS
case|:
name|flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bfd_set_section_flags: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! defined (obj_handle_link_once) */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bss_alloc
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|addressT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|char
modifier|*
name|pfrag
decl_stmt|;
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
name|segT
name|bss_seg
init|=
name|bss_section
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TC_MIPS
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_ALPHA
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* For MIPS and Alpha ECOFF or ELF, small objects are put in .sbss.  */
if|if
condition|(
name|size
operator|<=
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
condition|)
block|{
name|bss_seg
operator|=
name|subseg_new
argument_list|(
literal|".sbss"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|bss_seg
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|bss_seg
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \".sbss\": %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|subseg_set
argument_list|(
name|bss_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
name|record_alignment
argument_list|(
name|bss_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Detach from old frag.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_seg
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|symbolP
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|S_SET_SIZE
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* The symbol may already have been created with a preceding      ".globl" directive -- be careful not to step on storage class      in that case.  Otherwise, set it to static.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|offsetT
name|parse_align
parameter_list|(
name|int
name|align_bytes
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|addressT
name|align
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|no_align
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected alignment after size"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|align
operator|=
name|get_absolute_expr
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
goto|goto
name|no_align
goto|;
if|if
condition|(
operator|!
name|exp
operator|.
name|X_unsigned
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment negative; 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|align_bytes
operator|&&
name|align
operator|!=
literal|0
condition|)
block|{
comment|/* convert to a power of 2 alignment */
name|unsigned
name|int
name|alignp2
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|align
operator|>>=
literal|1
operator|,
operator|++
name|alignp2
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|align
operator|=
name|alignp2
expr_stmt|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Called from s_comm_internal after symbol name and size have been    parsed.  NEEDS_ALIGN is 0 if it was an ".lcomm" (2 args only),    1 if this was a ".bss" directive which has a 3rd argument    (alignment as a power of 2), or 2 if this was a ".bss" directive    with alignment in bytes.  */
end_comment

begin_function
name|symbolS
modifier|*
name|s_lcomm_internal
parameter_list|(
name|int
name|needs_align
parameter_list|,
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|addressT
name|size
parameter_list|)
block|{
name|addressT
name|align
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|needs_align
condition|)
block|{
name|align
operator|=
name|parse_align
argument_list|(
name|needs_align
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
operator|(
name|addressT
operator|)
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
else|else
comment|/* Assume some objects may require alignment on some systems.  */
name|TC_IMPLICIT_LCOMM_ALIGNMENT
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|bss_alloc
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_function
name|void
name|s_lcomm
parameter_list|(
name|int
name|needs_align
parameter_list|)
block|{
name|s_comm_internal
argument_list|(
name|needs_align
argument_list|,
name|s_lcomm_internal
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lcomm_bytes
parameter_list|(
name|int
name|needs_align
parameter_list|)
block|{
name|s_comm_internal
argument_list|(
name|needs_align
operator|*
literal|2
argument_list|,
name|s_lcomm_internal
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lsym
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* We permit ANY defined expression: BSD4.2 demands constants.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|p
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|expression_and_evaluate
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad expression"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
comment|/* The name might be an undefined .global symbol; be sure to 	 keep the "external" bit.  */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
operator|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|?
name|absolute_section
else|:
name|reg_section
operator|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line into an sb.  Returns the character that ended the line    or zero if there are no more lines.  */
end_comment

begin_function
specifier|static
name|int
name|get_line_sb
parameter_list|(
name|sb
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|eol
decl_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|>=
name|buffer_limit
condition|)
block|{
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_limit
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|eol
operator|=
name|find_end_of_line
argument_list|(
name|input_line_pointer
argument_list|,
name|flag_m68k_mri
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
name|line
argument_list|,
name|input_line_pointer
argument_list|,
name|eol
operator|-
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|eol
expr_stmt|;
comment|/* Don't skip multiple end-of-line characters, because that breaks support      for the IA-64 stop bit (;;) which looks like two consecutive end-of-line      characters but isn't.  Instead just skip one end of line character and      return the character skipped so that the caller can re-insert it if      necessary.   */
return|return
operator|*
name|input_line_pointer
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Define a macro.  This is an interface to macro.c.  */
end_comment

begin_function
name|void
name|s_macro
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|sb
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|eol
operator|=
name|find_end_of_line
argument_list|(
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
operator|&
name|s
argument_list|,
name|input_line_pointer
argument_list|,
name|eol
operator|-
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|eol
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|sb
name|label
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|label
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|define_macro
argument_list|(
literal|0
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|label
argument_list|,
name|get_line_sb
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|define_macro
argument_list|(
literal|0
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|,
name|get_line_sb
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|NO_PSEUDO_DOT
operator|||
name|flag_m68k_mri
operator|)
operator|&&
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|!
name|flag_m68k_mri
operator|&&
operator|*
name|name
operator|==
literal|'.'
operator|&&
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|name
operator|+
literal|1
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"attempt to redefine pseudo-op `%s' ignored"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .mexit pseudo-op, which immediately exits a macro    expansion.  */
end_comment

begin_function
name|void
name|s_mexit
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|cond_exit_macro
argument_list|(
name|macro_nest
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch in and out of MRI mode.  */
end_comment

begin_function
name|void
name|s_mri
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|on
decl_stmt|,
name|old_flag
decl_stmt|;
name|on
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|old_flag
operator|=
name|flag_mri
expr_stmt|;
if|if
condition|(
name|on
operator|!=
literal|0
condition|)
block|{
name|flag_mri
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|flag_m68k_mri
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|macro_mri_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flag_mri
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|flag_m68k_mri
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|macro_mri_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Operator precedence changes in m68k MRI mode, so we need to      update the operator rankings.  */
name|expr_set_precedence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MRI_MODE_CHANGE
if|if
condition|(
name|on
operator|!=
name|old_flag
condition|)
name|MRI_MODE_CHANGE
argument_list|(
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle changing the location counter.  */
end_comment

begin_function
specifier|static
name|void
name|do_org
parameter_list|(
name|segT
name|segment
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|fill
parameter_list|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|absolute_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid segment \"%s\""
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|fill
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring fill value in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"only constant offsets supported in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|abs_section_offset
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|exp
operator|->
name|X_add_symbol
decl_stmt|;
name|offsetT
name|off
init|=
name|exp
operator|->
name|X_add_number
operator|*
name|OCTETS_PER_BYTE
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|fill
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|s_org
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* The m68k MRI assembler has a different meaning for .org.  It      means to create an absolute section at a given address.  We can't      support that--use a linker script instead.  */
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MRI style ORG pseudo-op not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Don't believe the documentation of BSD 4.2 AS.  There is no such      thing as a sub-segment-relative origin.  Any absolute origin is      given a warning, then assumed to be segment-relative.  Any      segmented origin expression ("foo+42") had better be in the right      segment or the .org is ignored.       BSD 4.2 AS warns if you try to .org backwards. We cannot because      we never know sub-segment sizes when we are reading code.  BSD      will crash trying to emit negative numbers of filler bytes in      certain .orgs. We don't crash, but see as-write for that code.       Don't make frag if need_pass_2==1.  */
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|do_org
argument_list|(
name|segment
argument_list|,
operator|&
name|exp
argument_list|,
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle parsing for the MRI SECT/SECTION pseudo-op.  This should be    called by the obj-format routine which handles section changing    when in MRI mode.  It will create a new section, and return it.  It    will set *TYPE to the section type: one of 'C' (code), 'D' (data),    'M' (mixed), or 'R' (romable).  The flags will be set in the section.  */
end_comment

begin_function
name|void
name|s_mri_sect
parameter_list|(
name|char
modifier|*
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
else|else
block|{
do|do
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
do|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
block|}
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|int
name|align
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|TOUPPER
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'D'
operator|||
name|c
operator|==
literal|'M'
operator|||
name|c
operator|==
literal|'R'
condition|)
operator|*
name|type
operator|=
name|c
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized section type"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'C'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
literal|'D'
operator|||
operator|*
name|type
operator|==
literal|'M'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
literal|'R'
condition|)
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_READONLY
operator||
name|SEC_ROM
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|SEC_NO_FLAGS
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Ignore the HP type.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ! TC_M68K */
ifdef|#
directive|ifdef
name|TC_I960
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|sectype
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|sectype
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sectype
operator|==
literal|'\0'
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|sectype
argument_list|,
literal|"romdata"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|type
operator|=
literal|'R'
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognized section type `%s'"
argument_list|)
argument_list|,
name|sectype
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|char
modifier|*
name|seccmd
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|seccmd
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|seccmd
argument_list|,
literal|"absolute"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"absolute sections are not supported"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|seccmd
argument_list|,
literal|"align"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|align
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognized section command `%s'"
argument_list|)
argument_list|,
name|seccmd
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ! TC_I960 */
comment|/* The MRI assembler seems to use different forms of .sect for      different targets.  */
name|as_bad
argument_list|(
literal|"MRI mode not supported for this target"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! TC_I960 */
endif|#
directive|endif
comment|/* ! TC_M68K */
block|}
end_function

begin_comment
comment|/* Handle the .print pseudo-op.  */
end_comment

begin_function
name|void
name|s_print
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .purgem pseudo-op.  */
end_comment

begin_function
name|void
name|s_purgem
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|delete_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .endm/.endr pseudo-ops.  */
end_comment

begin_function
specifier|static
name|void
name|s_bad_end
parameter_list|(
name|int
name|endr
parameter_list|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end%c encountered without preceeding %s"
argument_list|)
argument_list|,
name|endr
condition|?
literal|'r'
else|:
literal|'m'
argument_list|,
name|endr
condition|?
literal|".rept, .irp, or .irpc"
else|:
literal|".macro"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .rept pseudo-op.  */
end_comment

begin_function
name|void
name|s_rept
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|do_repeat
argument_list|(
name|count
argument_list|,
literal|"REPT"
argument_list|,
literal|"ENDR"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function provides a generic repeat block implementation.   It allows    different directives to be used as the start/end keys.  */
end_comment

begin_function
name|void
name|do_repeat
parameter_list|(
name|int
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|sb
name|one
decl_stmt|;
name|sb
name|many
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|one
argument_list|,
name|get_line_sb
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s without %s"
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
name|sb_new
argument_list|(
operator|&
name|many
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|sb_add_sb
argument_list|(
operator|&
name|many
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|many
argument_list|,
name|input_line_pointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|many
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip to end of current repeat loop; EXTRA indicates how many additional    input buffers to skip.  Assumes that conditionals preceding the loop end    are properly nested.     This function makes it easier to implement a premature "break" out of the    loop.  The EXTRA arg accounts for other buffers we might have inserted,    such as line substitutions.  */
end_comment

begin_function
name|void
name|end_repeat
parameter_list|(
name|int
name|extra
parameter_list|)
block|{
name|cond_exit_macro
argument_list|(
name|macro_nest
argument_list|)
expr_stmt|;
while|while
condition|(
name|extra
operator|--
operator|>=
literal|0
condition|)
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_symbol
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble.  */
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|do_org
argument_list|(
name|segment
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* When doing symbol listings, play games with dummy fragments living 	 outside the normal fragment chain to record the file and line info 	 for this symbol.  */
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
specifier|extern
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
name|fragS
modifier|*
name|dummy_frag
init|=
operator|(
name|fragS
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
decl_stmt|;
name|dummy_frag
operator|->
name|line
operator|=
name|listing_tail
expr_stmt|;
name|dummy_frag
operator|->
name|fr_symbol
operator|=
name|symbolP
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|dummy_frag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified.  */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|symbol_equated_p
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Permit register names to be redefined.  */
if|if
condition|(
operator|(
name|mode
operator|!=
literal|0
operator|||
operator|!
name|S_IS_VOLATILE
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_clone
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the symbol is volatile, copy the symbol and replace the 	 original with the copy, so that previous uses of the symbol will 	 retain the value of the symbol at the point of use.  */
elseif|else
if|if
condition|(
name|S_IS_VOLATILE
argument_list|(
name|symbolP
argument_list|)
comment|/* This could be avoided when the symbol wasn't used so far, but 	     the comment in struc-symbol.h says this flag isn't reliable.  */
operator|&&
operator|(
literal|1
operator|||
name|symbol_used_p
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
name|symbolP
operator|=
name|symbol_clone
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|S_SET_VOLATILE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
name|S_SET_FORWARD_REF
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .equ, .equiv, .eqv, and .set directives.  If EQUIV is 1,    then this is .equiv, and it is an error if the symbol is already    defined.  If EQUIV is -1, the symbol additionally is a forward    reference.  */
end_comment

begin_function
name|void
name|s_set
parameter_list|(
name|int
name|equiv
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
modifier|*
name|end_name
decl_stmt|;
comment|/* Especial apologies for the random logic:      this just grew, and could be parsed much more simply!      Dean in haste.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|end_name
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|assign_symbol
argument_list|(
name|name
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_space
parameter_list|(
name|int
name|mult
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|expressionS
name|val
decl_stmt|;
name|char
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|int
name|bytes
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
comment|/* In m68k MRI mode, we need to align to a word boundary, unless      this is ds.b.  */
if|if
condition|(
name|flag_m68k_mri
operator|&&
name|mult
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|abs_section_offset
operator|+=
name|abs_section_offset
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|abs_section_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|valueT
name|val
decl_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|expressionS
modifier|*
name|symexp
decl_stmt|;
name|symexp
operator|=
name|symbol_get_value_expression
argument_list|(
name|line_label
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symexp
operator|->
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symexp
operator|->
name|X_add_symbol
operator|==
name|mri_common_symbol
argument_list|)
expr_stmt|;
name|symexp
operator|->
name|X_add_number
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|do_align
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bytes
operator|=
name|mult
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|val
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|val
operator|.
name|X_add_number
operator|<
operator|-
literal|0x80
operator|||
name|val
operator|.
name|X_add_number
operator|>
literal|0xff
operator|||
operator|(
name|mult
operator|!=
literal|0
operator|&&
name|mult
operator|!=
literal|1
operator|&&
name|val
operator|.
name|X_add_number
operator|!=
literal|0
operator|)
condition|)
block|{
name|resolve_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported variable size or fill value"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|offsetT
name|i
decl_stmt|;
if|if
condition|(
name|mult
operator|==
literal|0
condition|)
name|mult
operator|=
literal|1
expr_stmt|;
name|bytes
operator|=
name|mult
operator|*
name|exp
operator|.
name|X_add_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|.
name|X_add_number
condition|;
name|i
operator|++
control|)
name|emit_expr
argument_list|(
operator|&
name|val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
operator|||
name|mri_common_symbol
operator|!=
name|NULL
condition|)
name|resolve_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|long
name|repeat
decl_stmt|;
name|repeat
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|mult
condition|)
name|repeat
operator|*=
name|mult
expr_stmt|;
name|bytes
operator|=
name|repeat
expr_stmt|;
if|if
condition|(
name|repeat
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flag_mri
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".space repeat count is zero, ignored"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".space repeat count is negative, ignored"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* If we are in the absolute section, just bump the offset.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|abs_section_offset
operator|+=
name|repeat
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* If we are secretly in an MRI common section, then 	     creating space just increases the size of the common 	     symbol.  */
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|,
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
operator|+
name|repeat
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"space allocation too complex in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"space allocation too complex in common section"
argument_list|)
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|p
operator|=
name|frag_var
argument_list|(
name|rs_space
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
name|val
operator|.
name|X_add_number
expr_stmt|;
block|}
name|getout
label|:
comment|/* In MRI mode, after an odd number of bytes, we must align to an      even word boundary, unless the next instruction is a dc.b, ds.b      or dcb.b.  */
if|if
condition|(
name|flag_mri
operator|&&
operator|(
name|bytes
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|mri_pending_align
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like s_space, but the value is a floating point number with    the given precision.  This is for the MRI dcb.s pseudo-op and    friends.  */
end_comment

begin_function
name|void
name|s_float_space
parameter_list|(
name|int
name|float_type
parameter_list|)
block|{
name|offsetT
name|count
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing value"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present.  Don't even check if the    * letter is legal.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|ISALPHA
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Accept :xxxx, where the x's are hex digits, for a floating point      with the exact digits specified.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|flen
operator|=
name|hex_float
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|<
literal|0
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|flen
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|flen
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|flen
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad floating literal: %s"
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|flen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flen
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .struct pseudo-op, as found in MIPS assemblers.  */
end_comment

begin_function
name|void
name|s_struct
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|abs_section_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|absolute_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_text
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|const_flag
operator|&=
operator|~
name|IN_DEFAULT_SECTION
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* .weakref x, y sets x as an alias to y that, as long as y is not    referenced directly, will cause y to become a weak symbol.  */
end_comment

begin_function
name|void
name|s_weakref
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
modifier|*
name|end_name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
name|symbolP2
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|end_name
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|symbol_equated_p
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_VOLATILE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* This could be avoided when the symbol wasn't used so far, but 	 the comment in struc-symbol.h says this flag isn't reliable.  */
if|if
condition|(
literal|1
operator|||
operator|!
name|symbol_used_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|symbolP
operator|=
name|symbol_clone
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|S_CLEAR_VOLATILE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|end_name
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|symbolP2
operator|=
name|symbol_find_noref
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP2
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP2
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_WEAKREFD
argument_list|(
name|symbolP2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|symp
init|=
name|symbolP2
decl_stmt|;
while|while
condition|(
name|S_IS_WEAKREFR
argument_list|(
name|symp
argument_list|)
operator|&&
name|symp
operator|!=
name|symbolP
condition|)
block|{
name|expressionS
modifier|*
name|expP
init|=
name|symbol_get_value_expression
argument_list|(
name|symp
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|expP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|expP
operator|->
name|X_add_number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|symp
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
block|}
if|if
condition|(
name|symp
operator|==
name|symbolP
condition|)
block|{
name|char
modifier|*
name|loop
decl_stmt|;
name|loop
operator|=
name|concat
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|" => "
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP2
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|symp
operator|=
name|symbolP2
expr_stmt|;
while|while
condition|(
name|symp
operator|!=
name|symbolP
condition|)
block|{
name|char
modifier|*
name|old_loop
init|=
name|loop
decl_stmt|;
name|symp
operator|=
name|symbol_get_value_expression
argument_list|(
name|symp
argument_list|)
operator|->
name|X_add_symbol
expr_stmt|;
name|loop
operator|=
name|concat
argument_list|(
name|loop
argument_list|,
literal|" => "
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_loop
argument_list|)
expr_stmt|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: would close weakref loop: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Short-circuiting instead of just checking here might speed 	 things up a tiny little bit, but loop error messages would 	 miss intermediate links.  */
comment|/* symbolP2 = symp; */
block|}
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|memset
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|symbolP2
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_WEAKREFR
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify that we are at the end of a line.  If not, issue an error and    skip to EOL.  */
end_comment

begin_function
name|void
name|demand_empty_rest_of_line
parameter_list|(
name|void
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line, first unrecognized character is `%c'"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line, first unrecognized character valued 0x%x"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Return pointing just after end-of-line.  */
name|know
argument_list|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Silently advance to the end of line.  Use this after already having    issued an error about something bad.  */
end_comment

begin_function
name|void
name|ignore_rest_of_line
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Return pointing just after end-of-line.  */
name|know
argument_list|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets frag for given symbol to zero_address_frag, except when the    symbol frag is already set to a dummy listing frag.  */
end_comment

begin_function
specifier|static
name|void
name|set_zero_frag
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_type
operator|!=
name|rs_dummy
condition|)
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In:	Pointer to a symbol. 	Input_line_pointer->expression.     Out:	Input_line_pointer->just after any whitespace after expression. 	Tried to set symbol to value of expression. 	Will change symbols type, value, and frag;  */
end_comment

begin_function
name|void
name|pseudo_set
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* NULL pointer is logic error.  */
if|if
condition|(
operator|!
name|S_IS_FORWARD_REF
argument_list|(
name|symbolP
argument_list|)
condition|)
operator|(
name|void
operator|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|deferred_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal expression"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing expression"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bignum invalid"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"floating point number invalid"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_subtract
operator|&&
operator|!
name|S_IS_FORWARD_REF
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
operator|&&
operator|(
name|symbol_get_frag
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|symbol_get_frag
argument_list|(
name|exp
operator|.
name|X_op_symbol
argument_list|)
operator|)
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_op_symbol
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol_section_p
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"attempt to set value of section symbol"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
case|case
name|O_big
case|:
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|set_zero_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_register
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|set_zero_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
name|seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
comment|/* For x=undef+const, create an expression symbol. 	 For x=x+const, just update x except when x is an undefined symbol 	 For x=defined+const, evaluate x.  */
if|if
condition|(
name|symbolP
operator|==
name|exp
operator|.
name|X_add_symbol
operator|&&
operator|(
name|seg
operator|!=
name|undefined_section
operator|||
operator|!
name|symbol_constant_p
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
operator|*
name|symbol_X_add_number
argument_list|(
name|symbolP
argument_list|)
operator|+=
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_FORWARD_REF
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|seg
operator|!=
name|undefined_section
condition|)
block|{
name|symbolS
modifier|*
name|s
init|=
name|exp
operator|.
name|X_add_symbol
decl_stmt|;
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|s
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' can't be equated to common symbol '%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|exp
operator|.
name|X_add_number
operator|+
name|S_GET_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|symbol_get_frag
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symbolP
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|set_zero_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* The value is some complex expression.  */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|set_zero_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*			cons()     CONStruct more frag of .bytes, or .words etc.    Should need_pass_2 be 1 then emit no frag(s).    This understands EXPRESSIONS.     Bug (?)     This has a split personality. We use expression() to read the    value. We can detect if the value won't fit in a byte or word.    But we can't detect if expression() discarded significant digits    in the case of a long. Not worth the crocks required to fix it.  */
end_comment

begin_comment
comment|/* Select a parser for cons expressions.  */
end_comment

begin_comment
comment|/* Some targets need to parse the expression in various fancy ways.    You can define TC_PARSE_CONS_EXPRESSION to do whatever you like    (for example, the HPPA does this).  Otherwise, you can define    BITFIELD_CONS_EXPRESSIONS to permit bitfields to be specified, or    REPEAT_CONS_EXPRESSIONS to permit repeat counts.  If none of these    are defined, which is the normal case, then only simple expressions    are permitted.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TC_M68K
end_ifdef

begin_function_decl
specifier|static
name|void
name|parse_mri_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|unsigned
name|int
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_PARSE_CONS_EXPRESSION
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BITFIELD_CONS_EXPRESSIONS
end_ifdef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|parse_bitfield_cons (EXP, NBYTES)
end_define

begin_function_decl
specifier|static
name|void
name|parse_bitfield_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|unsigned
name|int
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
end_ifdef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|parse_repeat_cons (EXP, NBYTES)
end_define

begin_function_decl
specifier|static
name|void
name|parse_repeat_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|unsigned
name|int
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we haven't gotten one yet, just call expression.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_PARSE_CONS_EXPRESSION
end_ifndef

begin_define
define|#
directive|define
name|TC_PARSE_CONS_EXPRESSION
parameter_list|(
name|EXP
parameter_list|,
name|NBYTES
parameter_list|)
value|expression (EXP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|do_parse_cons_expression
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|nbytes
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|TC_PARSE_CONS_EXPRESSION
argument_list|(
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker to do .byte etc statements.    Clobbers input_line_pointer and checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|cons_worker
parameter_list|(
specifier|register
name|int
name|nbytes
parameter_list|,
comment|/* 1=.byte, 2=.word, 4=.long.  */
name|int
name|rva
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|TC_ADDRESS_BYTES
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|nbytes
operator|=
name|TC_ADDRESS_BYTES
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|TC_M68K
if|if
condition|(
name|flag_m68k_mri
condition|)
name|parse_mri_cons
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|TC_PARSE_CONS_EXPRESSION
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rva
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|exp
operator|.
name|X_op
operator|=
name|O_symbol_rva
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"rva without symbol"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* In MRI mode, after an odd number of bytes, we must align to an      even word boundary, unless the next instruction is a dc.b, ds.b      or dcb.b.  */
if|if
condition|(
name|flag_mri
operator|&&
name|nbytes
operator|==
literal|1
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|mri_pending_align
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cons
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|cons_worker
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_rva
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|cons_worker
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the contents of expression EXP into the object file using    NBYTES bytes.  If need_pass_2 is 1, this does nothing.  */
end_comment

begin_function
name|void
name|emit_expr
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|unsigned
name|int
name|nbytes
parameter_list|)
block|{
name|operatorT
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|valueT
name|extra_digit
init|=
literal|0
decl_stmt|;
comment|/* Don't do anything if we are going to make another pass.  */
if|if
condition|(
name|need_pass_2
condition|)
return|return;
name|dot_value
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* When gcc emits DWARF 1 debugging pseudo-ops, a line number will      appear as a four byte positive constant in the .line section,      followed by a 2 byte 0xffff.  Look for that case here.  */
block|{
specifier|static
name|int
name|dwarf_line
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".line"
argument_list|)
operator|!=
literal|0
condition|)
name|dwarf_line
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_line
operator|>=
literal|0
operator|&&
name|nbytes
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
operator|->
name|X_add_number
operator|==
operator|-
literal|1
operator|||
name|exp
operator|->
name|X_add_number
operator|==
literal|0xffff
operator|)
condition|)
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|dwarf_line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|4
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|>=
literal|0
condition|)
name|dwarf_line
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
else|else
name|dwarf_line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* When gcc emits DWARF 1 debugging pseudo-ops, a file name will      appear as a 2 byte TAG_compile_unit (0x11) followed by a 2 byte      AT_sibling (0x12) followed by a four byte address of the sibling      followed by a 2 byte AT_name (0x38) followed by the name of the      file.  We look for that case here.  */
block|{
specifier|static
name|int
name|dwarf_file
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".debug"
argument_list|)
operator|!=
literal|0
condition|)
name|dwarf_file
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_file
operator|==
literal|0
operator|&&
name|nbytes
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0x11
condition|)
name|dwarf_file
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_file
operator|==
literal|1
operator|&&
name|nbytes
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0x12
condition|)
name|dwarf_file
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_file
operator|==
literal|2
operator|&&
name|nbytes
operator|==
literal|4
condition|)
name|dwarf_file
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_file
operator|==
literal|3
operator|&&
name|nbytes
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0x38
condition|)
name|dwarf_file
operator|=
literal|4
expr_stmt|;
else|else
name|dwarf_file
operator|=
literal|0
expr_stmt|;
comment|/* The variable dwarf_file_string tells stringer that the string        may be the name of the source file.  */
if|if
condition|(
name|dwarf_file
operator|==
literal|4
condition|)
name|dwarf_file_string
operator|=
literal|1
expr_stmt|;
else|else
name|dwarf_file_string
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|check_eh_frame
argument_list|(
name|exp
argument_list|,
operator|&
name|nbytes
argument_list|)
condition|)
return|return;
name|op
operator|=
name|exp
operator|->
name|X_op
expr_stmt|;
comment|/* Allow `.word 0' in the absolute section.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|O_constant
operator|||
name|exp
operator|->
name|X_add_number
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to store value in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
name|abs_section_offset
operator|+=
name|nbytes
expr_stmt|;
return|return;
block|}
comment|/* Handle a negative bignum.  */
if|if
condition|(
name|op
operator|==
name|O_uminus
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0
operator|&&
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|->
name|X_op
operator|==
name|O_big
operator|&&
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|carry
decl_stmt|;
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
comment|/* Negate the bignum: one's complement each digit and add 1.  */
name|carry
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|->
name|X_add_number
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|next
decl_stmt|;
name|next
operator|=
operator|(
operator|(
operator|(
operator|~
operator|(
name|generic_bignum
index|[
name|i
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|)
operator|&
name|LITTLENUM_MASK
operator|)
operator|+
name|carry
operator|)
expr_stmt|;
name|generic_bignum
index|[
name|i
index|]
operator|=
name|next
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|next
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
comment|/* We can ignore any carry out, because it will be handled by 	 extra_digit if it is needed.  */
name|extra_digit
operator|=
operator|(
name|valueT
operator|)
operator|-
literal|1
expr_stmt|;
name|op
operator|=
name|O_big
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|O_absent
operator|||
name|op
operator|==
name|O_illegal
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"zero assumed for missing expression"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"floating point number invalid"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_register
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register value used as expression"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* If we have the difference of two symbols in a word, save it on      the broken_words list.  See the code in write.c.  */
if|if
condition|(
name|op
operator|==
name|O_subtract
operator|&&
name|nbytes
operator|==
literal|2
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|broken_word
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|next_broken_word
operator|=
name|broken_words
expr_stmt|;
name|broken_words
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|x
operator|->
name|subseg
operator|=
name|now_subseg
expr_stmt|;
name|x
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|x
operator|->
name|word_goes_here
operator|=
name|p
expr_stmt|;
name|x
operator|->
name|dispfrag
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|x
operator|->
name|sub
operator|=
name|exp
operator|->
name|X_op_symbol
expr_stmt|;
name|x
operator|->
name|addnum
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|x
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|use_jump
operator|=
literal|0
expr_stmt|;
name|new_broken_words
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If we have an integer, but the number of bytes is too large to      pass to md_number_to_chars, handle it as a bignum.  */
if|if
condition|(
name|op
operator|==
name|O_constant
operator|&&
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|extra_digit
operator|=
name|exp
operator|->
name|X_unsigned
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|convert_to_bignum
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|op
operator|=
name|O_big
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|O_constant
condition|)
block|{
specifier|register
name|valueT
name|get
decl_stmt|;
specifier|register
name|valueT
name|use
decl_stmt|;
specifier|register
name|valueT
name|mask
decl_stmt|;
name|valueT
name|hibit
decl_stmt|;
specifier|register
name|valueT
name|unmask
decl_stmt|;
comment|/* JF<< of>= number of bits in the object is undefined.  In 	 particular SPARC (Sun 4) has problems.  */
if|if
condition|(
name|nbytes
operator|>=
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
name|hibit
operator|=
literal|0
expr_stmt|;
else|else
name|hibit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|nbytes
operator|*
name|BITS_PER_CHAR
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't store these bits.  */
name|mask
operator|=
operator|~
operator|(
name|valueT
operator|)
literal|0
operator|<<
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
expr_stmt|;
name|hibit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|nbytes
operator|*
name|BITS_PER_CHAR
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|unmask
operator|=
operator|~
name|mask
expr_stmt|;
comment|/* Do store these bits.  */
ifdef|#
directive|ifdef
name|NEVER
literal|"Do this mod if you want every overflow check to assume SIGNED 2's complement data."
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|unmask
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Includes sign bit now.  */
endif|#
directive|endif
name|get
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|use
operator|=
name|get
operator|&
name|unmask
expr_stmt|;
if|if
condition|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|||
operator|(
name|get
operator|&
name|hibit
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Leading bits contain both 0s& 1s.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"value 0x%lx truncated to 0x%lx"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|get
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|use
argument_list|)
expr_stmt|;
block|}
comment|/* Put bytes in right order.  */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|use
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
condition|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|nums
decl_stmt|;
name|know
argument_list|(
name|nbytes
operator|%
name|CHARS_PER_LITTLENUM
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|exp
operator|->
name|X_add_number
operator|*
name|CHARS_PER_LITTLENUM
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
name|size
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"bignum truncated to %d bytes"
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|size
operator|=
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|nbytes
operator|>
name|size
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|extra_digit
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
name|nums
operator|=
name|generic_bignum
operator|+
name|size
operator|/
name|CHARS_PER_LITTLENUM
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|CHARS_PER_LITTLENUM
condition|)
block|{
operator|--
name|nums
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|nums
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|size
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
block|}
else|else
block|{
name|nums
operator|=
name|generic_bignum
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|CHARS_PER_LITTLENUM
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
operator|*
name|nums
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
operator|++
name|nums
expr_stmt|;
name|size
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
while|while
condition|(
name|nbytes
operator|>=
name|CHARS_PER_LITTLENUM
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|extra_digit
argument_list|,
name|CHARS_PER_LITTLENUM
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|p
operator|+=
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Now we need to generate a fixS to record the symbol value.  */
ifdef|#
directive|ifdef
name|TC_CONS_FIX_NEW
name|TC_CONS_FIX_NEW
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|r
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BITFIELD_CONS_EXPRESSIONS
end_ifdef

begin_comment
comment|/* i960 assemblers, (eg, asm960), allow bitfields after ".byte" as    w:x,y:z, where w and y are bitwidths and x and y are values.  They    then pack them all together. We do a little better in that we allow    them in words, longs, etc. and we'll pack them in target byte order    for you.     The rules are: pack least significant bit first, if a field doesn't    entirely fit, put it in the next unit.  Overflowing the bitfield is    explicitly *not* even a warning.  The bitwidth should be considered    a "mask".     To use this function the tc-XXX.h file should define    BITFIELD_CONS_EXPRESSIONS.  */
end_comment

begin_function
specifier|static
name|void
name|parse_bitfield_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|unsigned
name|int
name|bits_available
init|=
name|BITS_PER_CHAR
operator|*
name|nbytes
decl_stmt|;
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
comment|/* Bitfields.  */
name|long
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|width
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
break|break;
block|}
comment|/* Next piece is not a bitfield.  */
comment|/* In the general case, we can't allow 	     full expressions with symbol 	     differences and such.  The relocation 	     entries for symbols not defined in this 	     assembly would require arbitrary field 	     widths, positions, and masks which most 	     of our current object formats don't 	     support.  	     In the specific case where a symbol 	     *is* defined in this assembly, we 	     *could* build fixups and track it, but 	     this could lead to confusion for the 	     backends.  I'm lazy. I'll take any 	     SEG_ABSOLUTE. I think that means that 	     you can use a previous .set or 	     .equ type symbol.  xoxorich.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"using a bit field width of zero"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
comment|/* Implied zero width bitfield.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field width \"%s\" too complex for a bitfield"
argument_list|)
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Too complex.  */
if|if
condition|(
operator|(
name|width
operator|=
name|exp
operator|->
name|X_add_number
operator|)
operator|>
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"field width %lu too big to fit in %d bytes: truncated to %d bits"
argument_list|)
argument_list|,
name|width
argument_list|,
name|nbytes
argument_list|,
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|BITS_PER_CHAR
operator|*
name|nbytes
expr_stmt|;
block|}
comment|/* Too big.  */
if|if
condition|(
name|width
operator|>
name|bits_available
condition|)
block|{
comment|/* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|value
expr_stmt|;
break|break;
block|}
comment|/* Won't fit.  */
comment|/* Skip ':'.  */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|char
name|cache
init|=
operator|*
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field value \"%s\" too complex for a bitfield"
argument_list|)
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|cache
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Too complex.  */
name|value
operator||=
operator|(
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
name|width
operator|)
operator|&
name|exp
operator|->
name|X_add_number
operator|)
operator|<<
operator|(
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
operator|-
name|bits_available
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits_available
operator|-=
name|width
operator|)
operator|==
literal|0
operator|||
name|is_it_end_of_statement
argument_list|()
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
break|break;
block|}
comment|/* All the bitfields we're gonna get.  */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|exp
operator|->
name|X_add_number
operator|=
name|value
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITFIELD_CONS_EXPRESSIONS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle an MRI style string expression.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TC_M68K
end_ifdef

begin_function
specifier|static
name|void
name|parse_mri_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\''
operator|&&
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'\''
operator|||
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|'A'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'E'
operator|)
operator|)
condition|)
name|TC_PARSE_CONS_EXPRESSION
argument_list|(
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|scan
decl_stmt|;
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* An MRI style string.  Cut into as many bytes as will fit into 	 a nbyte chunk, left justify if necessary, and separate with 	 commas so we can try again later.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'A'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'E'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"EBCDIC constants are not supported"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
name|scan
operator|=
literal|0
init|;
name|scan
operator|<
name|nbytes
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Left justify.  */
while|while
condition|(
name|scan
operator|<
name|nbytes
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
comment|/* Create correct expression.  */
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
name|result
expr_stmt|;
comment|/* Fake it so that we can read the next char too.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|||
operator|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'\''
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
name|input_line_pointer
operator|-=
literal|2
expr_stmt|;
name|input_line_pointer
index|[
literal|0
index|]
operator|=
literal|','
expr_stmt|;
name|input_line_pointer
index|[
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TC_M68K */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
end_ifdef

begin_comment
comment|/* Parse a repeat expression for cons.  This is used by the MIPS    assembler.  The format is NUMBER:COUNT; NUMBER appears in the    object file COUNT times.     To use this for a target, define REPEAT_CONS_EXPRESSIONS.  */
end_comment

begin_function
specifier|static
name|void
name|parse_repeat_cons
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|count
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
comment|/* No repeat count.  */
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|count
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unresolvable or nonpositive repeat count; using 1"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The cons function is going to output this expression once.  So we      output it count - 1 times.  */
for|for
control|(
name|i
operator|=
name|count
operator|.
name|X_add_number
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|emit_expr
argument_list|(
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REPEAT_CONS_EXPRESSIONS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Parse a floating point number represented as a hex constant.  This    permits users to specify the exact bits they want in the floating    point number.  */
end_comment

begin_function
specifier|static
name|int
name|hex_float
parameter_list|(
name|int
name|float_type
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|)
block|{
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|float_type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|length
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|length
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown floating type type '%c'"
argument_list|)
argument_list|,
name|float_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* It would be nice if we could go through expression to parse the      hex constant, but if we get a bignum it's a pain to sort it into      the buffer correctly.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
block|{
name|int
name|d
decl_stmt|;
comment|/* The MRI assembler accepts arbitrary underscores strewn about 	 through the hex constant, so we ignore them as well.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|>=
name|length
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"floating point constant too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|d
operator|=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|<<
literal|4
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'_'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|hex_p
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|d
operator|+=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
name|bytes
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
else|else
name|bytes
index|[
name|length
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|d
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|memset
argument_list|(
name|bytes
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/*			float_cons()     CONStruct some more frag chars of .floats .ffloats etc.    Makes 0 or more new frags.    If need_pass_2 == 1, no frags are emitted.    This understands only floating literals, not expressions. Sorry.     A floating constant is defined by atof_generic(), except it is preceded    by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its    reading, I decided to be incompatible. This always tries to give you    rounded bits to the precision of the pseudo-op. Former AS did premature    truncation, restored noisy bits instead of trailing 0s AND gave you    a choice of 2 flavours of noise according to which of 2 floating-point    scanners you directed AS to use.     In:	input_line_pointer->whitespace before, or '0' of flonum.  */
end_comment

begin_function
name|void
name|float_cons
parameter_list|(
comment|/* Clobbers input_line-pointer, checks end-of-line.  */
specifier|register
name|int
name|float_type
comment|/* 'f':.ffloat ... 'F':.float ...  */
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Number of chars in an object.  */
specifier|register
name|char
modifier|*
name|err
decl_stmt|;
comment|/* Error from scanning floating literal.  */
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* input_line_pointer->1st char of a flonum (we hope!).  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present. Don't even check if the 	 letter is legal. Someone may invent a "z" format and this routine 	 has no use for such information. Lusers beware: you get 	 diagnostics if your input is ill-conditioned.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|ISALPHA
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Accept :xxxx, where the x's are hex digits, for a floating 	 point with the exact digits specified.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|length
operator|=
name|hex_float
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad floating literal: %s"
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REPEAT_CONS_EXPRESSIONS
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
name|expressionS
name|count_exp
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|count_exp
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unresolvable or nonpositive repeat count; using 1"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|count_exp
operator|.
name|X_add_number
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Put terminator back into stream.  */
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size of a LEB128 value.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sizeof_sleb128
parameter_list|(
name|offsetT
name|value
parameter_list|)
block|{
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
comment|/* Sadly, we cannot rely on typical arithmetic right shift behaviour. 	 Fortunately, we can structure things so that the extra work reduces 	 to a noop on systems that do things "properly".  */
name|value
operator|=
operator|(
name|value
operator|>>
literal|7
operator|)
operator||
operator|~
operator|(
operator|-
operator|(
name|offsetT
operator|)
literal|1
operator|>>
literal|7
operator|)
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sizeof_uleb128
parameter_list|(
name|valueT
name|value
parameter_list|)
block|{
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|int
name|sizeof_leb128
parameter_list|(
name|valueT
name|value
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
if|if
condition|(
name|sign
condition|)
return|return
name|sizeof_sleb128
argument_list|(
operator|(
name|offsetT
operator|)
name|value
argument_list|)
return|;
else|else
return|return
name|sizeof_uleb128
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output a LEB128 value.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|output_sleb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|offsetT
name|value
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|orig
init|=
name|p
decl_stmt|;
specifier|register
name|int
name|more
decl_stmt|;
do|do
block|{
name|unsigned
name|byte
init|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
decl_stmt|;
comment|/* Sadly, we cannot rely on typical arithmetic right shift behaviour. 	 Fortunately, we can structure things so that the extra work reduces 	 to a noop on systems that do things "properly".  */
name|value
operator|=
operator|(
name|value
operator|>>
literal|7
operator|)
operator||
operator|~
operator|(
operator|-
operator|(
name|offsetT
operator|)
literal|1
operator|>>
literal|7
operator|)
expr_stmt|;
name|more
operator|=
operator|!
operator|(
operator|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|byte
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
return|return
name|p
operator|-
name|orig
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|output_uleb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|valueT
name|value
parameter_list|)
block|{
name|char
modifier|*
name|orig
init|=
name|p
decl_stmt|;
do|do
block|{
name|unsigned
name|byte
init|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
comment|/* More bytes to follow.  */
name|byte
operator||=
literal|0x80
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|byte
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
return|return
name|p
operator|-
name|orig
return|;
block|}
end_function

begin_function
name|int
name|output_leb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|valueT
name|value
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
if|if
condition|(
name|sign
condition|)
return|return
name|output_sleb128
argument_list|(
name|p
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|)
return|;
else|else
return|return
name|output_uleb128
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do the same for bignums.  We combine sizeof with output here in that    we don't output for NULL values of P.  It isn't really as critical as    for "normal" values that this be streamlined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|output_big_sleb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|bignum
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|orig
init|=
name|p
decl_stmt|;
name|valueT
name|val
init|=
literal|0
decl_stmt|;
name|int
name|loaded
init|=
literal|0
decl_stmt|;
name|unsigned
name|byte
decl_stmt|;
comment|/* Strip leading sign extensions off the bignum.  */
while|while
condition|(
name|size
operator|>
literal|1
operator|&&
name|bignum
index|[
name|size
operator|-
literal|1
index|]
operator|==
name|LITTLENUM_MASK
operator|&&
name|bignum
index|[
name|size
operator|-
literal|2
index|]
operator|>
name|LITTLENUM_MASK
operator|/
literal|2
condition|)
name|size
operator|--
expr_stmt|;
do|do
block|{
comment|/* OR in the next part of the littlenum.  */
name|val
operator||=
operator|(
operator|*
name|bignum
operator|<<
name|loaded
operator|)
expr_stmt|;
name|loaded
operator|+=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
name|size
operator|--
expr_stmt|;
name|bignum
operator|++
expr_stmt|;
comment|/* Add bytes until there are less than 7 bits left in VAL 	 or until every non-sign bit has been written.  */
do|do
block|{
name|byte
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
name|loaded
operator|-=
literal|7
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|||
name|val
operator|!=
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|loaded
operator|)
operator|-
literal|1
operator|)
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|orig
condition|)
operator|*
name|p
operator|=
name|byte
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|&&
name|loaded
operator|>=
literal|7
condition|)
do|;
block|}
do|while
condition|(
name|size
operator|>
literal|0
condition|)
do|;
comment|/* Mop up any left-over bits (of which there will be less than 7).  */
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Sign-extend VAL.  */
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|loaded
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
literal|0
operator|<<
name|loaded
expr_stmt|;
if|if
condition|(
name|orig
condition|)
operator|*
name|p
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
operator|-
name|orig
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|output_big_uleb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|bignum
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|orig
init|=
name|p
decl_stmt|;
name|valueT
name|val
init|=
literal|0
decl_stmt|;
name|int
name|loaded
init|=
literal|0
decl_stmt|;
name|unsigned
name|byte
decl_stmt|;
comment|/* Strip leading zeros off the bignum.  */
comment|/* XXX: Is this needed?  */
while|while
condition|(
name|size
operator|>
literal|0
operator|&&
name|bignum
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
do|do
block|{
if|if
condition|(
name|loaded
operator|<
literal|7
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
name|val
operator||=
operator|(
operator|*
name|bignum
operator|<<
name|loaded
operator|)
expr_stmt|;
name|loaded
operator|+=
literal|8
operator|*
name|CHARS_PER_LITTLENUM
expr_stmt|;
name|size
operator|--
expr_stmt|;
name|bignum
operator|++
expr_stmt|;
block|}
name|byte
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
name|loaded
operator|-=
literal|7
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|||
name|val
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|orig
condition|)
operator|*
name|p
operator|=
name|byte
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
return|return
name|p
operator|-
name|orig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|output_big_leb128
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|bignum
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
if|if
condition|(
name|sign
condition|)
return|return
name|output_big_sleb128
argument_list|(
name|p
argument_list|,
name|bignum
argument_list|,
name|size
argument_list|)
return|;
else|else
return|return
name|output_big_uleb128
argument_list|(
name|p
argument_list|,
name|bignum
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the appropriate fragments for a given expression to emit a    leb128 value.  */
end_comment

begin_function
specifier|static
name|void
name|emit_leb128_expr
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|operatorT
name|op
init|=
name|exp
operator|->
name|X_op
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|O_absent
operator|||
name|op
operator|==
name|O_illegal
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"zero assumed for missing expression"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"floating point number invalid"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_register
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register value used as expression"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_constant
operator|&&
name|sign
operator|&&
operator|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0
operator|)
operator|!=
operator|!
name|exp
operator|->
name|X_unsigned
condition|)
block|{
comment|/* We're outputting a signed leb128 and the sign of X_add_number 	 doesn't reflect the sign of the original value.  Convert EXP 	 to a correctly-extended bignum instead.  */
name|convert_to_bignum
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|op
operator|=
name|O_big
expr_stmt|;
block|}
comment|/* Let check_eh_frame know that data is being emitted.  nbytes == -1 is      a signal that this is leb128 data.  It shouldn't optimize this away.  */
name|nbytes
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|check_eh_frame
argument_list|(
name|exp
argument_list|,
operator|&
name|nbytes
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Let the backend know that subsequent data may be byte aligned.  */
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|==
name|O_constant
condition|)
block|{
comment|/* If we've got a constant, emit the thing directly right now.  */
name|valueT
name|value
init|=
name|exp
operator|->
name|X_add_number
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|output_leb128
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_big
condition|)
block|{
comment|/* O_big is a different sort of constant.  */
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|output_big_leb128
argument_list|(
name|NULL
argument_list|,
name|generic_bignum
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|output_big_leb128
argument_list|(
name|p
argument_list|,
name|generic_bignum
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we have to create a variable sized fragment and 	 resolve things later.  */
name|frag_var
argument_list|(
name|rs_leb128
argument_list|,
name|sizeof_uleb128
argument_list|(
operator|~
operator|(
name|valueT
operator|)
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sign
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the .sleb128 and .uleb128 pseudos.  */
end_comment

begin_function
name|void
name|s_leb128
parameter_list|(
name|int
name|sign
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|emit_leb128_expr
argument_list|(
operator|&
name|exp
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We read 0 or more ',' separated, double-quoted strings.    Caller should have checked need_pass_2 is FALSE because we don't    check it.  */
end_comment

begin_function
name|void
name|stringer
parameter_list|(
comment|/* Worker to do .ascii etc statements.  */
comment|/* Checks end-of-line.  */
specifier|register
name|int
name|append_zero
comment|/* 0: don't append '\0', else 1.  */
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* The following awkward logic is to parse ZERO or more strings,      comma separated. Recall a string expression includes spaces      before the opening '\"' and spaces after the closing '\"'.      We fake a leading ',' if there is (supposed to be)      a 1st, expression. We keep demanding expressions for each ','.  */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop.  */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Compensate for end of loop.  */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop.  */
block|}
comment|/* If we have been switched into the abs_section then we      will not have an obstack onto which we can hang strings.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"strings must be placed into a section"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
comment|/*->1st char of string.  */
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* In ELF, when gcc is emitting DWARF 1 debugging output, it 	     will emit .string with a filename in the .debug section 	     after a sequence of constants.  See the comment in 	     emit_expr for the sequence.  emit_expr will set 	     dwarf_file_string to non-zero if this string might be a 	     source file name.  */
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|".debug"
argument_list|)
operator|!=
literal|0
condition|)
name|dwarf_file_string
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf_file_string
condition|)
block|{
name|c
operator|=
name|input_line_pointer
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|listing_source_file
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
literal|'<'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|c
operator|=
name|get_single_number
argument_list|()
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'>'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected<nn>"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stringer() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* FIXME-SOMEDAY: I had trouble here on characters with the     high bits set.  We'll probably also have trouble with     multibyte chars, wide chars, etc.  Also be careful about     returning values bigger than 1 byte.  xoxorich.  */
end_comment

begin_function
name|unsigned
name|int
name|next_char_of_string
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|&
name|CHAR_MASK
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
name|NOT_A_CHAR
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_STRING_ESCAPES
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\013'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* As itself.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|long
name|number
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|number
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|&&
name|i
operator|<
literal|3
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
block|}
operator|--
name|input_line_pointer
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|long
name|number
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|/* To be compatible with BSD 4.2 as: give the luser a linefeed!!  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|ONLY_STANDARD_ESCAPES
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad escaped character in string"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
comment|/* ONLY_STANDARD_ESCAPES */
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* ! defined (NO_STRING_ESCAPES) */
default|default:
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|segT
name|get_segmented_expression
parameter_list|(
specifier|register
name|expressionS
modifier|*
name|expP
parameter_list|)
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
name|retval
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expP
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|expP
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|expP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected address expression"
argument_list|)
argument_list|)
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|absolute_section
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
specifier|register
name|expressionS
modifier|*
name|expP
parameter_list|)
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|get_segmented_expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|undefined_section
condition|)
block|{
comment|/* There is no easy way to extract the undefined symbol from the 	 expression.  */
if|if
condition|(
name|expP
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|expr_section
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"symbol \"%s\" undefined; zero assumed"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"some symbol undefined; zero assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|absolute_section
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|know
argument_list|(
name|retval
operator|==
name|absolute_section
operator|||
name|SEG_NORMAL
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|char
comment|/* Return terminator.  */
name|get_absolute_expression_and_terminator
parameter_list|(
name|long
modifier|*
name|val_pointer
comment|/* Return value of expression.  */
parameter_list|)
block|{
comment|/* FIXME: val_pointer should probably be offsetT *.  */
operator|*
name|val_pointer
operator|=
operator|(
name|long
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
return|return
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like demand_copy_string, but return NULL if the string contains any '\0's.    Give a warning if that happens.  */
end_comment

begin_function
name|char
modifier|*
name|demand_copy_C_string
parameter_list|(
name|int
modifier|*
name|len_pointer
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
name|len_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
operator|*
name|len_pointer
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|len_pointer
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"this string may not contain \'\\0\'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Demand string, but return a safe (=private) copy of the string.    Return NULL if we can't read a string here.  */
end_comment

begin_function
name|char
modifier|*
name|demand_copy_string
parameter_list|(
name|int
modifier|*
name|lenP
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip opening quote.  */
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* JF this next line is so demand_copy_C_string will return a 	 null terminated string.  */
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing string"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|lenP
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In:	Input_line_pointer->next character.     Do:	Skip input_line_pointer over all whitespace.     Out:	1 if input_line_pointer->end-of-line.  */
end_comment

begin_function
name|int
name|is_it_end_of_statement
parameter_list|(
name|void
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
return|return
operator|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|equals
parameter_list|(
name|char
modifier|*
name|sym_name
parameter_list|,
name|int
name|reassign
parameter_list|)
block|{
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'='
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|reassign
operator|<
literal|0
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'='
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|assign_symbol
argument_list|(
name|sym_name
argument_list|,
name|reassign
operator|>=
literal|0
condition|?
operator|!
name|reassign
else|:
name|reassign
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .incbin -- include a file verbatim at the current location.  */
end_comment

begin_function
name|void
name|s_incbin
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|FILE
modifier|*
name|binfile
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|binfrag
decl_stmt|;
name|long
name|skip
init|=
literal|0
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
name|long
name|bytes
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|filename
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Look for optional skip and count.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|skip
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".incbin count zero, ignoring `%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Try opening absolute path first, then try include dirs.  */
name|binfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfile
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|len
operator|+
name|include_dir_maxlen
operator|+
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_dir_count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|include_dirs
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|binfile
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfile
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|binfile
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"file not found: %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfile
condition|)
block|{
name|long
name|file_len
decl_stmt|;
name|register_dependency
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Compute the length of the file.  */
if|if
condition|(
name|fseek
argument_list|(
name|binfile
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"seek to end of .incbin file failed `%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|file_len
operator|=
name|ftell
argument_list|(
name|binfile
argument_list|)
expr_stmt|;
comment|/* If a count was not specified use the remainder of the file.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
name|file_len
operator|-
name|skip
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
operator|||
name|count
operator|<
literal|0
operator|||
name|file_len
operator|<
literal|0
operator|||
name|skip
operator|+
name|count
operator|>
name|file_len
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"skip (%ld) or count (%ld) invalid for file size (%ld)"
argument_list|)
argument_list|,
name|skip
argument_list|,
name|count
argument_list|,
name|file_len
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fseek
argument_list|(
name|binfile
argument_list|,
name|skip
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"could not skip to %ld in file `%s'"
argument_list|)
argument_list|,
name|skip
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Allocate frag space and store file contents in it.  */
name|binfrag
operator|=
name|frag_more
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|fread
argument_list|(
name|binfrag
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|binfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|count
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"truncated file `%s', %ld of %ld bytes read"
argument_list|)
argument_list|,
name|path
argument_list|,
name|bytes
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|binfile
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|binfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .include -- include a file at this point.  */
end_comment

begin_function
name|void
name|s_include
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|try
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|flag_m68k_mri
condition|)
block|{
name|filename
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* demand_copy_string has already printed an error and 	     called ignore_rest_of_line.  */
return|return;
block|}
block|}
else|else
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|' '
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\t'
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|filename
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|+
name|include_dir_maxlen
operator|+
literal|5
comment|/* slop */
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_dir_count
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|include_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|try
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
name|FOPEN_RT
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|try
argument_list|)
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|filename
expr_stmt|;
name|gotit
label|:
comment|/* malloc Storage leak when file is found on path.  FIXME-SOMEDAY.  */
name|register_dependency
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|input_scrub_insert_file
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_include_dir
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|include_dir_count
operator|==
literal|0
condition|)
block|{
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
name|include_dirs
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
comment|/* Current dir.  */
name|include_dir_count
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|include_dir_count
operator|++
expr_stmt|;
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|include_dirs
argument_list|,
name|include_dir_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|include_dirs
index|[
name|include_dir_count
operator|-
literal|1
index|]
operator|=
name|path
expr_stmt|;
comment|/* New one.  */
name|i
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|include_dir_maxlen
condition|)
name|include_dir_maxlen
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugging information to denote the source file.  */
end_comment

begin_function
specifier|static
name|void
name|generate_file_debug
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output line number debugging information for the current source line.  */
end_comment

begin_function
name|void
name|generate_lineno_debug
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|debug_type
condition|)
block|{
case|case
name|DEBUG_UNSPECIFIED
case|:
case|case
name|DEBUG_NONE
case|:
case|case
name|DEBUG_DWARF
case|:
break|break;
case|case
name|DEBUG_STABS
case|:
name|stabs_generate_asm_lineno
argument_list|()
expr_stmt|;
break|break;
case|case
name|DEBUG_ECOFF
case|:
name|ecoff_generate_asm_lineno
argument_list|()
expr_stmt|;
break|break;
case|case
name|DEBUG_DWARF2
case|:
comment|/* ??? We could here indicate to dwarf2dbg.c that something 	 has changed.  However, since there is additional backend 	 support that is required (calling dwarf2_emit_insn), we 	 let dwarf2dbg.c call as_where on its own.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output debugging information to mark a function entry point or end point.    END_P is zero for .func, and non-zero for .endfunc.  */
end_comment

begin_function
name|void
name|s_func
parameter_list|(
name|int
name|end_p
parameter_list|)
block|{
name|do_s_func
argument_list|(
name|end_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of s_func so targets can choose a different default prefix.    If DEFAULT_PREFIX is NULL, use the target's "leading char".  */
end_comment

begin_function
specifier|static
name|void
name|do_s_func
parameter_list|(
name|int
name|end_p
parameter_list|,
specifier|const
name|char
modifier|*
name|default_prefix
parameter_list|)
block|{
comment|/* Record the current function so that we can issue an error message for      misplaced .func,.endfunc, and also so that .endfunc needs no      arguments.  */
specifier|static
name|char
modifier|*
name|current_name
decl_stmt|;
specifier|static
name|char
modifier|*
name|current_label
decl_stmt|;
if|if
condition|(
name|end_p
condition|)
block|{
if|if
condition|(
name|current_name
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing .func"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_endfunc
argument_list|(
name|current_name
argument_list|,
name|current_label
argument_list|)
expr_stmt|;
name|current_name
operator|=
name|current_label
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* ! end_p */
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|label
decl_stmt|;
name|char
name|delim1
decl_stmt|,
name|delim2
decl_stmt|;
if|if
condition|(
name|current_name
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".endfunc missing for previous .func"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim1
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|delim1
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|default_prefix
condition|)
name|asprintf
argument_list|(
operator|&
name|label
argument_list|,
literal|"%s%s"
argument_list|,
name|default_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|leading_char
init|=
name|bfd_get_symbol_leading_char
argument_list|(
name|stdoutput
argument_list|)
decl_stmt|;
comment|/* Missing entry point, use function's name with the leading 		 char prepended.  */
if|if
condition|(
name|leading_char
condition|)
name|asprintf
argument_list|(
operator|&
name|label
argument_list|,
literal|"%c%s"
argument_list|,
name|leading_char
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|label
operator|=
name|name
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|label
operator|=
name|input_line_pointer
expr_stmt|;
name|delim2
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|delim2
expr_stmt|;
block|}
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_func
argument_list|(
name|name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|current_name
operator|=
name|name
expr_stmt|;
name|current_label
operator|=
name|label
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|s_ignore
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"pseudo-op table"
argument_list|,
name|po_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inserts the given line into the input stream.     This call avoids macro/conditionals nesting checking, since the contents of    the line are assumed to replace the contents of a line already scanned.     An appropriate use of this function would be substitution of input lines when    called by md_start_line_hook().  The given line is assumed to already be    properly scrubbed.  */
end_comment

begin_function
name|void
name|input_scrub_insert_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|sb
name|newline
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|newline
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|newline
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|input_scrub_include_sb
argument_list|(
operator|&
name|newline
argument_list|,
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|newline
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a file into the input stream; the path must resolve to an actual    file; no include path searching or dependency registering is performed.  */
end_comment

begin_function
name|void
name|input_scrub_insert_file
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|input_scrub_include_file
argument_list|(
name|path
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the end of a line, considering quotation and escaping of quotes.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TC_SINGLE_QUOTE_STRINGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SINGLE_QUOTE_STRINGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|TC_SINGLE_QUOTE_STRINGS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|_find_end_of_line
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|mri_string
parameter_list|,
name|int
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|inquote
init|=
literal|'\0'
decl_stmt|;
name|int
name|inescape
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|||
operator|(
name|inquote
operator|&&
operator|!
name|ISCNTRL
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|||
operator|(
name|inquote
operator|==
literal|'\''
operator|&&
name|flag_mri
operator|)
ifdef|#
directive|ifdef
name|TC_EOL_IN_INSN
operator|||
operator|(
name|insn
operator|&&
name|TC_EOL_IN_INSN
argument_list|(
name|s
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|mri_string
operator|&&
operator|*
name|s
operator|==
literal|'\''
condition|)
name|inquote
operator|^=
operator|*
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|inescape
condition|)
name|inescape
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|inescape
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inquote
condition|?
operator|*
name|s
operator|==
literal|'"'
ifdef|#
directive|ifdef
name|TC_SINGLE_QUOTE_STRINGS
operator|||
operator|(
name|TC_SINGLE_QUOTE_STRINGS
operator|&&
operator|*
name|s
operator|==
literal|'\''
operator|)
endif|#
directive|endif
else|:
operator|*
name|s
operator|==
name|inquote
condition|)
name|inquote
operator|^=
operator|*
name|s
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|inquote
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing closing `%c'"
argument_list|)
argument_list|,
name|inquote
argument_list|)
expr_stmt|;
if|if
condition|(
name|inescape
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"stray `\\'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|find_end_of_line
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|mri_string
parameter_list|)
block|{
return|return
name|_find_end_of_line
argument_list|(
name|s
argument_list|,
name|mri_string
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

