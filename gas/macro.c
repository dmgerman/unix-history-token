begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* macro.c - macro support for gas    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006 Free Software Foundation, Inc.     Written by Steve and Judy Chamberlain of Cygnus Support,       sac@cygnus.com     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_comment
comment|/* The routines in this file handle macro definition and expansion.    They are called by gas.  */
end_comment

begin_comment
comment|/* Internal functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|get_token
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getstring
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_any_string
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|formal_entry
modifier|*
name|new_formal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|del_formal
parameter_list|(
name|formal_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_formals
parameter_list|(
name|macro_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_apost_token
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sub_actual
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|struct
name|hash_control
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand_body
parameter_list|(
name|sb
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|formal_entry
modifier|*
parameter_list|,
name|struct
name|hash_control
modifier|*
parameter_list|,
specifier|const
name|macro_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand
parameter_list|(
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|macro_entry
modifier|*
parameter_list|,
name|sb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_macro
parameter_list|(
name|macro_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISWHITE
parameter_list|(
name|x
parameter_list|)
value|((x) == ' ' || (x) == '\t')
end_define

begin_define
define|#
directive|define
name|ISSEP
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == ' ' || (x) == '\t' || (x) == ',' || (x) == '"' || (x) == ';' \   || (x) == ')' || (x) == '(' \   || ((macro_alternate || macro_mri)&& ((x) == '<' || (x) == '>')))
end_define

begin_define
define|#
directive|define
name|ISBASE
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == 'b' || (x) == 'B' \    || (x) == 'q' || (x) == 'Q' \    || (x) == 'h' || (x) == 'H' \    || (x) == 'd' || (x) == 'D')
end_define

begin_comment
comment|/* The macro hash table.  */
end_comment

begin_decl_stmt
name|struct
name|hash_control
modifier|*
name|macro_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether any macros have been defined.  */
end_comment

begin_decl_stmt
name|int
name|macro_defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are in alternate syntax mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_alternate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are in MRI mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_mri
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we should strip '@' characters.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_strip_at
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to use to parse an expression.  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|macro_expr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of macro expansions that have been done.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize macro processing.  */
end_comment

begin_function
name|void
name|macro_init
parameter_list|(
name|int
name|alternate
parameter_list|,
name|int
name|mri
parameter_list|,
name|int
name|strip_at
parameter_list|,
name|int
function_decl|(
modifier|*
name|expr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sb
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|)
block|{
name|macro_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|macro_defined
operator|=
literal|0
expr_stmt|;
name|macro_alternate
operator|=
name|alternate
expr_stmt|;
name|macro_mri
operator|=
name|mri
expr_stmt|;
name|macro_strip_at
operator|=
name|strip_at
expr_stmt|;
name|macro_expr
operator|=
name|expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch in and out of alternate mode on the fly.  */
end_comment

begin_function
name|void
name|macro_set_alternate
parameter_list|(
name|int
name|alternate
parameter_list|)
block|{
name|macro_alternate
operator|=
name|alternate
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch in and out of MRI mode on the fly.  */
end_comment

begin_function
name|void
name|macro_mri_mode
parameter_list|(
name|int
name|mri
parameter_list|)
block|{
name|macro_mri
operator|=
name|mri
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read input lines till we get to a TO string.    Increase nesting depth if we get a FROM string.    Put the results into sb at PTR.    FROM may be NULL (or will be ignored) if TO is "ENDR".    Add a new input line to an sb using GET_LINE.    Return 1 on success, 0 on unexpected EOF.  */
end_comment

begin_function
name|int
name|buffer_and_nest
parameter_list|(
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
name|sb
modifier|*
name|ptr
parameter_list|,
name|int
function_decl|(
modifier|*
name|get_line
function_decl|)
parameter_list|(
name|sb
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|from_len
decl_stmt|;
name|int
name|to_len
init|=
name|strlen
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|line_start
init|=
name|ptr
operator|->
name|len
decl_stmt|;
name|int
name|more
init|=
name|get_line
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|to_len
operator|==
literal|4
operator|&&
name|strcasecmp
argument_list|(
name|to
argument_list|,
literal|"ENDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|from
operator|=
name|NULL
expr_stmt|;
name|from_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|from_len
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
name|more
condition|)
block|{
comment|/* Try to find the first pseudo op on the line.  */
name|int
name|i
init|=
name|line_start
decl_stmt|;
comment|/* With normal syntax we can suck what we want till we get 	 to the dot.  With the alternate, labels have to start in 	 the first column, since we can't tell what's a label and 	 what's a pseudoop.  */
if|if
condition|(
operator|!
name|LABELS_WITHOUT_COLONS
condition|)
block|{
comment|/* Skip leading whitespace.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ISWHITE
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Skip over a label, if any.  */
if|if
condition|(
name|i
operator|>=
name|ptr
operator|->
name|len
operator|||
operator|!
name|is_name_beginner
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|is_part_of_name
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|is_name_ender
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|LABELS_WITHOUT_COLONS
condition|)
break|break;
comment|/* Skip whitespace.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ISWHITE
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Check for the colon.  */
if|if
condition|(
name|i
operator|>=
name|ptr
operator|->
name|len
operator|||
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
block|{
name|i
operator|=
name|line_start
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|line_start
operator|=
name|i
expr_stmt|;
block|}
comment|/* Skip trailing whitespace.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ISWHITE
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'.'
operator|||
name|NO_PSEUDO_DOT
operator|||
name|macro_mri
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|flag_m68k_mri
operator|&&
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"IRPC"
argument_list|,
name|from_len
operator|=
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"IRP"
argument_list|,
name|from_len
operator|=
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"IREPC"
argument_list|,
name|from_len
operator|=
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"IREP"
argument_list|,
name|from_len
operator|=
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"REPT"
argument_list|,
name|from_len
operator|=
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
literal|"REP"
argument_list|,
name|from_len
operator|=
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|from_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|from
operator|!=
name|NULL
condition|?
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
name|from
argument_list|,
name|from_len
argument_list|)
operator|==
literal|0
else|:
name|from_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ptr
operator|->
name|len
operator|==
operator|(
name|i
operator|+
name|from_len
operator|)
operator|||
operator|!
operator|(
name|is_part_of_name
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|from_len
index|]
argument_list|)
operator|||
name|is_name_ender
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|from_len
index|]
argument_list|)
operator|)
operator|)
condition|)
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
name|to
argument_list|,
name|to_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|len
operator|==
operator|(
name|i
operator|+
name|to_len
operator|)
operator|||
operator|!
operator|(
name|is_part_of_name
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|to_len
index|]
argument_list|)
operator|||
name|is_name_ender
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|to_len
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
comment|/* Reset the string to not include the ending rune.  */
name|ptr
operator|->
name|len
operator|=
name|line_start
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Add the original end-of-line char to the end and keep running.  */
name|sb_add_char
argument_list|(
name|ptr
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|line_start
operator|=
name|ptr
operator|->
name|len
expr_stmt|;
name|more
operator|=
name|get_line
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* Return 1 on success, 0 on unexpected EOF.  */
return|return
name|depth
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Pick up a token.  */
end_comment

begin_function
specifier|static
name|int
name|get_token
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|is_name_beginner
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|is_part_of_name
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|is_name_ender
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ignore trailing&.  */
if|if
condition|(
name|macro_alternate
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'&'
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Pick up a string.  */
end_comment

begin_function
specifier|static
name|int
name|getstring
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|acc
parameter_list|)
block|{
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|&&
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|)
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|&&
name|macro_alternate
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|nest
init|=
literal|0
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'>'
operator|||
name|nest
operator|)
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'>'
condition|)
name|nest
operator|--
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
name|nest
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|escaped
operator|^=
literal|1
expr_stmt|;
else|else
name|escaped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escaped
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|tchar
condition|)
block|{
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|tchar
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|tchar
condition|)
block|{
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
break|break;
block|}
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Fetch string from the input stream,    rules:     'Bxyx<whitespace>  	-> return 'Bxyza     %<expr>		-> return string of decimal value of<expr>     "string"		-> return string     (string)		-> return (string-including-whitespaces)     xyx<whitespace>     -> return xyz.  */
end_comment

begin_function
specifier|static
name|int
name|get_any_string
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|out
parameter_list|)
block|{
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|len
operator|>
name|idx
operator|+
literal|2
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'\''
operator|&&
name|ISBASE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'%'
operator|&&
name|macro_alternate
condition|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* Turns the next expression into a string.  */
comment|/* xgettext: no-c-format */
name|idx
operator|=
call|(
modifier|*
name|macro_expr
call|)
argument_list|(
name|_
argument_list|(
literal|"% operator needs absolute expression"
argument_list|)
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|&&
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|)
operator|||
operator|(
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|macro_alternate
operator|&&
operator|!
name|macro_strip_at
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'<'
condition|)
block|{
comment|/* Keep the quotes.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|br_buf
init|=
name|xmalloc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|in_br
init|=
name|br_buf
decl_stmt|;
operator|*
name|in_br
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
operator|*
name|in_br
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|' '
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'\t'
operator|)
operator|)
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|','
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'<'
operator|||
operator|(
operator|!
name|macro_alternate
operator|&&
operator|!
name|macro_mri
operator|)
operator|)
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
switch|switch
condition|(
name|tchar
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|in
operator|->
name|len
condition|)
return|return
name|idx
return|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'['
case|:
if|if
condition|(
name|in_br
operator|>
name|br_buf
condition|)
operator|--
name|in_br
expr_stmt|;
else|else
block|{
name|br_buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|in_br
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|br_buf
operator|+
literal|1
argument_list|,
name|in_br
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_br
argument_list|)
expr_stmt|;
name|in_br
operator|=
name|br_buf
expr_stmt|;
block|}
operator|*
name|in_br
operator|=
name|tchar
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|*
name|in_br
operator|==
literal|'('
condition|)
operator|++
name|in_br
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
operator|*
name|in_br
operator|==
literal|'['
condition|)
operator|++
name|in_br
expr_stmt|;
break|break;
block|}
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|tchar
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|free
argument_list|(
name|br_buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new formal.  */
end_comment

begin_function
specifier|static
name|formal_entry
modifier|*
name|new_formal
parameter_list|(
name|void
parameter_list|)
block|{
name|formal_entry
modifier|*
name|formal
decl_stmt|;
name|formal
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|actual
argument_list|)
expr_stmt|;
name|formal
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|formal
operator|->
name|type
operator|=
name|FORMAL_OPTIONAL
expr_stmt|;
return|return
name|formal
return|;
block|}
end_function

begin_comment
comment|/* Free a formal.  */
end_comment

begin_function
specifier|static
name|void
name|del_formal
parameter_list|(
name|formal_entry
modifier|*
name|formal
parameter_list|)
block|{
name|sb_kill
argument_list|(
operator|&
name|formal
operator|->
name|actual
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|formal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pick up the formal parameters of a macro definition.  */
end_comment

begin_function
specifier|static
name|int
name|do_formals
parameter_list|(
name|macro_entry
modifier|*
name|macro
parameter_list|,
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|)
block|{
name|formal_entry
modifier|*
modifier|*
name|p
init|=
operator|&
name|macro
operator|->
name|formals
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|formal_entry
modifier|*
name|formal
init|=
name|new_formal
argument_list|()
decl_stmt|;
name|int
name|cidx
decl_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|->
name|name
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|macro
operator|->
name|formal_count
condition|)
operator|--
name|idx
expr_stmt|;
break|break;
block|}
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* This is a formal.  */
name|name
operator|=
name|sb_terminate
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro_mri
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|':'
operator|&&
operator|(
operator|!
name|is_name_beginner
argument_list|(
literal|':'
argument_list|)
operator|||
name|idx
operator|+
literal|1
operator|>=
name|in
operator|->
name|len
operator|||
operator|!
name|is_part_of_name
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Got a qualifier.  */
name|sb
name|qual
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|qual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
argument_list|,
name|in
argument_list|,
operator|&
name|qual
argument_list|)
expr_stmt|;
name|sb_terminate
argument_list|(
operator|&
name|qual
argument_list|)
expr_stmt|;
if|if
condition|(
name|qual
operator|.
name|len
operator|==
literal|0
condition|)
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"Missing parameter qualifier for `%s' in macro `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qual
operator|.
name|ptr
argument_list|,
literal|"req"
argument_list|)
operator|==
literal|0
condition|)
name|formal
operator|->
name|type
operator|=
name|FORMAL_REQUIRED
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qual
operator|.
name|ptr
argument_list|,
literal|"vararg"
argument_list|)
operator|==
literal|0
condition|)
name|formal
operator|->
name|type
operator|=
name|FORMAL_VARARG
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"`%s' is not a valid parameter qualifier for `%s' in macro `%s'"
argument_list|)
argument_list|,
name|qual
operator|.
name|ptr
argument_list|,
name|name
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|qual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* Got a default.  */
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|->
name|type
operator|==
name|FORMAL_REQUIRED
condition|)
block|{
name|sb_reset
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"Pointless default value for required parameter `%s' in macro `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add to macro's hash table.  */
if|if
condition|(
operator|!
name|hash_find
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|name
argument_list|)
condition|)
name|hash_jam
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|name
argument_list|,
name|formal
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"A parameter named `%s' already exists for macro `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|formal
operator|->
name|index
operator|=
name|macro
operator|->
name|formal_count
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|formal
expr_stmt|;
name|p
operator|=
operator|&
name|formal
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|formal
operator|->
name|type
operator|==
name|FORMAL_VARARG
condition|)
break|break;
name|cidx
operator|=
name|idx
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
name|cidx
operator|&&
name|idx
operator|>=
name|in
operator|->
name|len
condition|)
block|{
name|idx
operator|=
name|cidx
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|macro_mri
condition|)
block|{
name|formal_entry
modifier|*
name|formal
init|=
name|new_formal
argument_list|()
decl_stmt|;
comment|/* Add a special NARG formal, which macro_expand will set to the          number of arguments.  */
comment|/* The same MRI assemblers which treat '@' characters also use          the name $NARG.  At least until we find an exception.  */
if|if
condition|(
name|macro_strip_at
condition|)
name|name
operator|=
literal|"$NARG"
expr_stmt|;
else|else
name|name
operator|=
literal|"NARG"
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Add to macro's hash table.  */
if|if
condition|(
name|hash_find
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|name
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"Reserved word `%s' used as parameter in macro `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|hash_jam
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|name
argument_list|,
name|formal
argument_list|)
expr_stmt|;
name|formal
operator|->
name|index
operator|=
name|NARG_INDEX
expr_stmt|;
operator|*
name|p
operator|=
name|formal
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Define a new macro.  Returns NULL on success, otherwise returns an    error message.  If NAMEP is not NULL, *NAMEP is set to the name of    the macro which was defined.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|define_macro
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|label
parameter_list|,
name|int
function_decl|(
modifier|*
name|get_line
function_decl|)
parameter_list|(
name|sb
modifier|*
parameter_list|)
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|)
block|{
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|sb
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|macro
operator|=
operator|(
name|macro_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|macro_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|macro
operator|->
name|sub
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|macro
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|macro
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|macro
operator|->
name|formal_count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formals
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formal_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
literal|"MACRO"
argument_list|,
literal|"ENDM"
argument_list|,
operator|&
name|macro
operator|->
name|sub
argument_list|,
name|get_line
argument_list|)
condition|)
name|error
operator|=
name|_
argument_list|(
literal|"unexpected end of file in macro `%s' definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
operator|&&
name|label
operator|->
name|len
operator|!=
literal|0
condition|)
block|{
name|sb_add_sb
argument_list|(
operator|&
name|name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|macro
operator|->
name|name
operator|=
name|sb_terminate
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* It's the label: MACRO (formals,...)  sort  */
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|')'
condition|)
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|_
argument_list|(
literal|"missing `)' after formals in macro definition `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's the label: MACRO formals,...  sort  */
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|cidx
decl_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|macro
operator|->
name|name
operator|=
name|sb_terminate
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|len
operator|==
literal|0
condition|)
name|error
operator|=
name|_
argument_list|(
literal|"Missing macro name"
argument_list|)
expr_stmt|;
name|cidx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|cidx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|cidx
operator|||
name|idx
operator|<
name|in
operator|->
name|len
condition|)
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|cidx
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
condition|)
name|error
operator|=
name|_
argument_list|(
literal|"Bad parameter list for macro `%s'"
argument_list|)
expr_stmt|;
comment|/* And stick it in the macro hash table.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|name
operator|.
name|len
condition|;
name|idx
operator|++
control|)
name|name
operator|.
name|ptr
index|[
name|idx
index|]
operator|=
name|TOLOWER
argument_list|(
name|name
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_find
argument_list|(
name|macro_hash
argument_list|,
name|macro
operator|->
name|name
argument_list|)
condition|)
name|error
operator|=
name|_
argument_list|(
literal|"Macro `%s' was already defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|hash_jam
argument_list|(
name|macro_hash
argument_list|,
name|macro
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|namep
operator|!=
name|NULL
condition|)
operator|*
name|namep
operator|=
name|macro
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|macro_defined
operator|=
literal|1
expr_stmt|;
else|else
name|free_macro
argument_list|(
name|macro
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Scan a token, and then skip KIND.  */
end_comment

begin_function
specifier|static
name|int
name|get_apost_token
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|name
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|kind
operator|&&
operator|(
operator|!
name|macro_mri
operator|||
name|macro_strip_at
operator|)
operator|&&
operator|(
operator|!
name|macro_strip_at
operator|||
name|kind
operator|==
literal|'@'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Substitute the actual value for a formal parameter.  */
end_comment

begin_function
specifier|static
name|int
name|sub_actual
parameter_list|(
name|int
name|start
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|t
parameter_list|,
name|struct
name|hash_control
modifier|*
name|formal_hash
parameter_list|,
name|int
name|kind
parameter_list|,
name|sb
modifier|*
name|out
parameter_list|,
name|int
name|copyifnotthere
parameter_list|)
block|{
name|int
name|src
decl_stmt|;
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|src
operator|=
name|get_apost_token
argument_list|(
name|start
argument_list|,
name|in
argument_list|,
name|t
argument_list|,
name|kind
argument_list|)
expr_stmt|;
comment|/* See if it's in the macro's hash table, unless this is      macro_strip_at and kind is '@' and the token did not end in '@'.  */
if|if
condition|(
name|macro_strip_at
operator|&&
name|kind
operator|==
literal|'@'
operator|&&
operator|(
name|src
operator|==
name|start
operator|||
name|in
operator|->
name|ptr
index|[
name|src
operator|-
literal|1
index|]
operator|!=
literal|'@'
operator|)
condition|)
name|ptr
operator|=
name|NULL
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
condition|)
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|ptr
operator|->
name|def
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
literal|'&'
condition|)
block|{
comment|/* Doing this permits people to use& in macro bodies.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copyifnotthere
condition|)
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* Expand the body of a macro.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand_body
parameter_list|(
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|out
parameter_list|,
name|formal_entry
modifier|*
name|formals
parameter_list|,
name|struct
name|hash_control
modifier|*
name|formal_hash
parameter_list|,
specifier|const
name|macro_entry
modifier|*
name|macro
parameter_list|)
block|{
name|sb
name|t
decl_stmt|;
name|int
name|src
init|=
literal|0
decl_stmt|,
name|inquote
init|=
literal|0
decl_stmt|,
name|macro_line
init|=
literal|0
decl_stmt|;
name|formal_entry
modifier|*
name|loclist
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'&'
condition|)
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_mri
condition|)
block|{
if|if
condition|(
name|src
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|1
index|]
operator|==
literal|'&'
condition|)
name|src
operator|=
name|sub_actual
argument_list|(
name|src
operator|+
literal|2
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'\''
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: Why do we do this?  */
comment|/* At least in alternate mode this seems correct; without this 	         one can't append a literal to a parameter.  */
name|src
operator|=
name|sub_actual
argument_list|(
name|src
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'&'
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'\\'
condition|)
block|{
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* Sub in till the next ')' literally.  */
name|src
operator|++
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|')'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
condition|)
name|src
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|macro
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"missing `)'"
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
operator|+
name|macro_line
argument_list|,
name|_
argument_list|(
literal|"missing `)'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* Sub in the macro invocation number.  */
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|src
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|macro_number
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* This is a preprocessor variable name, we don't do them 		 here.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macro_mri
operator|&&
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|ISALNUM
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
block|{
name|int
name|ind
decl_stmt|;
name|formal_entry
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
operator|++
name|src
expr_stmt|;
for|for
control|(
name|f
operator|=
name|formals
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|index
operator|==
name|ind
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|actual
operator|.
name|len
operator|!=
literal|0
condition|)
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
else|else
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|f
operator|->
name|def
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|sub_actual
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'\''
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|&&
name|is_name_beginner
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|inquote
operator|||
operator|!
name|macro_strip_at
operator|||
operator|(
name|src
operator|>
literal|0
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|-
literal|1
index|]
operator|==
literal|'@'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|macro
operator|||
name|src
operator|+
literal|5
operator|>=
name|in
operator|->
name|len
operator|||
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|src
argument_list|,
literal|"LOCAL"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISWHITE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|5
index|]
argument_list|)
condition|)
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|sub_actual
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
operator|(
name|macro_strip_at
operator|&&
name|inquote
operator|)
condition|?
literal|'@'
else|:
literal|'\''
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|sb_skip_white
argument_list|(
name|src
operator|+
literal|5
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|'\n'
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|formal_entry
modifier|*
name|f
init|=
name|new_formal
argument_list|()
decl_stmt|;
name|src
operator|=
name|get_token
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|sb_terminate
argument_list|(
operator|&
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_find
argument_list|(
name|formal_hash
argument_list|,
name|name
argument_list|)
condition|)
block|{
specifier|static
name|int
name|loccnt
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|f
operator|->
name|index
operator|=
name|LOCAL_INDEX
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|loclist
expr_stmt|;
name|loclist
operator|=
name|f
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|IS_ELF
condition|?
literal|".LL%04x"
else|:
literal|"LL%04x"
argument_list|,
operator|++
name|loccnt
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_jam
argument_list|(
name|formal_hash
argument_list|,
name|name
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
break|break;
block|}
else|else
block|{
name|as_bad_where
argument_list|(
name|macro
operator|->
name|file
argument_list|,
name|macro
operator|->
name|line
operator|+
name|macro_line
argument_list|,
name|_
argument_list|(
literal|"`%s' was already used as parameter (or another local) name"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|del_formal
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|sb_skip_comma
argument_list|(
name|src
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'"'
operator|||
operator|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
operator|&&
name|macro_strip_at
condition|)
block|{
operator|++
name|src
expr_stmt|;
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'='
operator|&&
name|src
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|get_token
argument_list|(
name|src
operator|+
literal|2
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: We should really return a warning string here,                  but we can't, because the == might be in the MRI                  comment field, and, since the nature of the MRI                  comment field depends upon the exact instruction                  being used, we don't have enough information here to                  figure out whether it is or not.  Instead, we leave                  the == in place, which should cause a syntax error if                  it is not in a comment.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
condition|)
block|{
name|sb_add_string
argument_list|(
name|out
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|macro_line
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|loclist
operator|!=
name|NULL
condition|)
block|{
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|loclist
operator|->
name|next
expr_stmt|;
comment|/* Setting the value to NULL effectively deletes the entry.  We          avoid calling hash_delete because it doesn't reclaim memory.  */
name|hash_jam
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|loclist
operator|->
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|del_formal
argument_list|(
name|loclist
argument_list|)
expr_stmt|;
name|loclist
operator|=
name|f
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Assign values to the formal parameters of a macro, and expand the    body.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|macro_entry
modifier|*
name|m
parameter_list|,
name|sb
modifier|*
name|out
parameter_list|)
block|{
name|sb
name|t
decl_stmt|;
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|int
name|is_keyword
init|=
literal|0
decl_stmt|;
name|int
name|narg
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Reset any old value the actuals may have.  */
for|for
control|(
name|f
operator|=
name|m
operator|->
name|formals
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
name|sb_reset
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
name|f
operator|=
name|m
operator|->
name|formals
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|index
operator|<
literal|0
condition|)
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|macro_mri
condition|)
block|{
comment|/* The macro may be called with an optional qualifier, which may          be referred to in the macro body as \0.  */
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* The Microtec assembler ignores this if followed by a white space. 	     (Macro invocation with empty extension) */
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|' '
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'\t'
condition|)
block|{
name|formal_entry
modifier|*
name|n
init|=
name|new_formal
argument_list|()
decl_stmt|;
name|n
operator|->
name|index
operator|=
name|QUAL_INDEX
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|m
operator|->
name|formals
expr_stmt|;
name|m
operator|->
name|formals
operator|=
name|n
expr_stmt|;
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|n
operator|->
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Peel off the actuals and store them away in the hash tables' actuals.  */
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|int
name|scan
decl_stmt|;
comment|/* Look and see if it's a positional or keyword arg.  */
name|scan
operator|=
name|idx
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|scan
index|]
argument_list|)
operator|&&
operator|!
operator|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|==
literal|'\''
operator|)
operator|&&
operator|(
operator|!
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|!=
literal|'='
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|==
literal|'='
condition|)
block|{
name|is_keyword
operator|=
literal|1
expr_stmt|;
comment|/* It's OK to go from positional to keyword.  */
comment|/* This is a keyword arg, fetch the formal name and 	     then the actual stuff.  */
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'='
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"confusion in formal parameters"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Lookup the formal in the macro's list.  */
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|m
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Parameter named `%s' does not exist for macro `%s'"
argument_list|)
argument_list|,
name|t
operator|.
name|ptr
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Insert this value into the right place.  */
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Value for parameter `%s' of macro `%s' was already specified"
argument_list|)
argument_list|,
name|ptr
operator|->
name|name
operator|.
name|ptr
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
operator|>
literal|0
condition|)
operator|++
name|narg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_keyword
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"can't mix positional and keyword arguments"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|formal_entry
modifier|*
modifier|*
name|pf
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|macro_mri
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"too many positional arguments"
argument_list|)
expr_stmt|;
break|break;
block|}
name|f
operator|=
name|new_formal
argument_list|()
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|pf
operator|=
operator|&
name|m
operator|->
name|formals
init|;
operator|*
name|pf
operator|!=
name|NULL
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pf
operator|)
operator|->
name|index
operator|>=
name|c
condition|)
name|c
operator|=
operator|(
operator|*
name|pf
operator|)
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
name|c
operator|=
literal|0
expr_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|index
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|type
operator|!=
name|FORMAL_VARARG
condition|)
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
else|else
block|{
name|sb_add_buffer
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|,
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
name|in
operator|->
name|len
operator|-
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|=
name|in
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|actual
operator|.
name|len
operator|>
literal|0
condition|)
operator|++
name|narg
expr_stmt|;
do|do
block|{
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|index
operator|<
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|macro_mri
condition|)
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
operator|++
name|idx
expr_stmt|;
if|if
condition|(
name|ISWHITE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|m
operator|->
name|formals
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|FORMAL_REQUIRED
operator|&&
name|ptr
operator|->
name|actual
operator|.
name|len
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing value for required parameter `%s' of macro `%s'"
argument_list|)
argument_list|,
name|ptr
operator|->
name|name
operator|.
name|ptr
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|macro_mri
condition|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|t
argument_list|,
name|macro_strip_at
condition|?
literal|"$NARG"
else|:
literal|"NARG"
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|m
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|ptr
operator|->
name|actual
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|m
operator|->
name|sub
argument_list|,
name|out
argument_list|,
name|m
operator|->
name|formals
argument_list|,
name|m
operator|->
name|formal_hash
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Discard any unnamed formal arguments.  */
if|if
condition|(
name|macro_mri
condition|)
block|{
name|formal_entry
modifier|*
modifier|*
name|pf
decl_stmt|;
name|pf
operator|=
operator|&
name|m
operator|->
name|formals
expr_stmt|;
while|while
condition|(
operator|*
name|pf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pf
operator|)
operator|->
name|name
operator|.
name|len
operator|!=
literal|0
condition|)
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
expr_stmt|;
else|else
block|{
name|f
operator|=
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
expr_stmt|;
name|del_formal
argument_list|(
operator|*
name|pf
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
block|}
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|macro_number
operator|++
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Check for a macro.  If one is found, put the expansion into    *EXPAND.  Return 1 if a macro is found, 0 otherwise.  */
end_comment

begin_function
name|int
name|check_macro
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|sb
modifier|*
name|expand
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|,
name|macro_entry
modifier|*
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|cs
decl_stmt|;
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|sb
name|line_sb
decl_stmt|;
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|line
argument_list|)
operator|&&
operator|(
operator|!
name|macro_mri
operator|||
operator|*
name|line
operator|!=
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|is_name_ender
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|line
argument_list|,
name|s
operator|-
name|line
argument_list|)
expr_stmt|;
name|copy
index|[
name|s
operator|-
name|line
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|copy
init|;
operator|*
name|cs
operator|!=
literal|'\0'
condition|;
name|cs
operator|++
control|)
operator|*
name|cs
operator|=
name|TOLOWER
argument_list|(
operator|*
name|cs
argument_list|)
expr_stmt|;
name|macro
operator|=
operator|(
name|macro_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|macro_hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Wrap the line up in an sb.  */
name|sb_new
argument_list|(
operator|&
name|line_sb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
condition|)
name|sb_add_char
argument_list|(
operator|&
name|line_sb
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
name|expand
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|macro_expand
argument_list|(
literal|0
argument_list|,
operator|&
name|line_sb
argument_list|,
name|macro
argument_list|,
name|expand
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|line_sb
argument_list|)
expr_stmt|;
comment|/* Export the macro information if requested.  */
if|if
condition|(
name|info
condition|)
operator|*
name|info
operator|=
name|macro
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Free the memory allocated to a macro.  */
end_comment

begin_function
specifier|static
name|void
name|free_macro
parameter_list|(
name|macro_entry
modifier|*
name|macro
parameter_list|)
block|{
name|formal_entry
modifier|*
name|formal
decl_stmt|;
for|for
control|(
name|formal
operator|=
name|macro
operator|->
name|formals
init|;
name|formal
condition|;
control|)
block|{
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|formal
expr_stmt|;
name|formal
operator|=
name|formal
operator|->
name|next
expr_stmt|;
name|del_formal
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|hash_die
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|macro
operator|->
name|sub
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|macro
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a macro.  */
end_comment

begin_function
name|void
name|delete_macro
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|copy
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Since hash_delete doesn't free memory, just clear out the entry.  */
if|if
condition|(
operator|(
name|macro
operator|=
name|hash_find
argument_list|(
name|macro_hash
argument_list|,
name|copy
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|hash_jam
argument_list|(
name|macro_hash
argument_list|,
name|copy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_macro
argument_list|(
name|macro
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Attempt to purge non-existant macro `%s'"
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a    combined macro definition and execution.  This returns NULL on    success, or an error message otherwise.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|expand_irp
parameter_list|(
name|int
name|irpc
parameter_list|,
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|in
parameter_list|,
name|sb
modifier|*
name|out
parameter_list|,
name|int
function_decl|(
modifier|*
name|get_line
function_decl|)
parameter_list|(
name|sb
modifier|*
parameter_list|)
parameter_list|)
block|{
name|sb
name|sub
decl_stmt|;
name|formal_entry
name|f
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
name|NULL
argument_list|,
literal|"ENDR"
argument_list|,
operator|&
name|sub
argument_list|,
name|get_line
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"unexpected end of file in irp or irpc"
argument_list|)
return|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|name
operator|.
name|len
operator|==
literal|0
condition|)
return|return
name|_
argument_list|(
literal|"missing model parameter"
argument_list|)
return|;
name|h
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|err
operator|=
name|hash_jam
argument_list|(
name|h
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|f
operator|.
name|name
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
name|f
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|f
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|.
name|type
operator|=
name|FORMAL_OPTIONAL
expr_stmt|;
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
condition|)
block|{
comment|/* Expand once with a null string.  */
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|sub
argument_list|,
name|out
argument_list|,
operator|&
name|f
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|in_quotes
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|irpc
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|in_quotes
operator|=
name|TRUE
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|irpc
condition|)
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|nxt
decl_stmt|;
if|if
condition|(
name|irpc
condition|)
name|in_quotes
operator|=
operator|!
name|in_quotes
expr_stmt|;
name|nxt
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|>=
name|in
operator|->
name|len
condition|)
block|{
name|idx
operator|=
name|nxt
expr_stmt|;
break|break;
block|}
block|}
name|sb_reset
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|sub
argument_list|,
name|out
argument_list|,
operator|&
name|f
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|irpc
condition|)
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|in_quotes
condition|)
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
name|hash_die
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|f
operator|.
name|def
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

