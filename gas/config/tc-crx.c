begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-crx.c -- Assembler code for the CRX CPU core.    Copyright 2004 Free Software Foundation, Inc.     Contributed by Tomer Levi, NSC, Israel.    Originally written for GAS 2.12 by Tomer Levi, NSC, Israel.    Updates, BFDizing, GNUifying and ELF support by Tomer Levi.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"opcode/crx.h"
end_include

begin_include
include|#
directive|include
file|"elf/crx.h"
end_include

begin_comment
comment|/* Word is considered here as a 16-bit unsigned short int.  */
end_comment

begin_define
define|#
directive|define
name|WORD_SHIFT
value|16
end_define

begin_comment
comment|/* Register is 4-bit size.  */
end_comment

begin_define
define|#
directive|define
name|REG_SIZE
value|4
end_define

begin_comment
comment|/* Maximum size of a single instruction (in words).  */
end_comment

begin_define
define|#
directive|define
name|INSN_MAX_SIZE
value|3
end_define

begin_comment
comment|/* Maximum bits which may be set in a `mask16' operand.  */
end_comment

begin_define
define|#
directive|define
name|MAX_REGS_IN_MASK16
value|8
end_define

begin_comment
comment|/* Utility macros for string comparison.  */
end_comment

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp (a, b) == 0)
end_define

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(strncmp (a, b, c) == 0)
end_define

begin_comment
comment|/* Assign a number NUM, shifted by SHIFT bytes, into a location    pointed by index BYTE of array 'output_opcode'.  */
end_comment

begin_define
define|#
directive|define
name|CRX_PRINT
parameter_list|(
name|BYTE
parameter_list|,
name|NUM
parameter_list|,
name|SHIFT
parameter_list|)
value|output_opcode[BYTE] |= (NUM<< SHIFT)
end_define

begin_comment
comment|/* Operand errors.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OP_LEGAL
init|=
literal|0
block|,
comment|/* Legal operand.  */
name|OP_OUT_OF_RANGE
block|,
comment|/* Operand not within permitted range.  */
name|OP_NOT_EVEN
block|,
comment|/* Operand is Odd number, should be even.  */
name|OP_ILLEGAL_DISPU4
block|,
comment|/* Operand is not within DISPU4 range.  */
name|OP_ILLEGAL_CST4
block|,
comment|/* Operand is not within CST4 range.  */
name|OP_NOT_UPPER_64KB
comment|/* Operand is not within the upper 64KB  			   (0xFFFF0000-0xFFFFFFFF).  */
block|}
name|op_err
typedef|;
end_typedef

begin_comment
comment|/* Opcode mnemonics hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|crx_inst_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRX registers hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRX coprocessor registers hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|copreg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current instruction we're assembling.  */
end_comment

begin_decl_stmt
specifier|const
name|inst
modifier|*
name|instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables.  */
end_comment

begin_comment
comment|/* Array to hold an instruction encoding.  */
end_comment

begin_decl_stmt
name|long
name|output_opcode
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a relocatable symbol.  */
end_comment

begin_decl_stmt
name|int
name|relocatable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A copy of the original instruction (used in error messages).  */
end_comment

begin_decl_stmt
name|char
name|ins_parse
index|[
name|MAX_INST_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current processed argument number.  */
end_comment

begin_decl_stmt
name|int
name|cur_arg_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic assembler global variables which must be defined by all targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds machine specific line separator characters.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant as in 0f12.456  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"f'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target-specific multicharacter options, not const-declared at usage.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table describes all the machine specific pseudo-ops    the assembler has to support.  The fields are:    *** Pseudo-op name without dot.    *** Function to call to execute this pseudo-op.    *** Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* In CRX machine, align is in bytes (not a ptwo boundary).  */
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRX relaxation table.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* bCC  */
block|{
literal|0xfa
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/*  8 */
block|{
literal|0xfffe
block|,
operator|-
literal|0x10000
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* 16 */
block|{
literal|0xfffffffe
block|,
operator|-
literal|0xfffffffe
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* 32 */
comment|/* bal  */
block|{
literal|0xfffe
block|,
operator|-
literal|0x10000
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* 16 */
block|{
literal|0xfffffffe
block|,
operator|-
literal|0xfffffffe
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* 32 */
comment|/* cmpbr/bcop  */
block|{
literal|0xfe
block|,
operator|-
literal|0x100
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/*  8 */
block|{
literal|0xfffffe
block|,
operator|-
literal|0x1000000
block|,
literal|6
block|,
literal|0
block|}
comment|/* 24 */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|reset_vars
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg
name|get_register
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|copreg
name|get_copregister
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|argtype
name|get_optype
parameter_list|(
name|operand_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_opbits
parameter_list|(
name|operand_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_opflags
parameter_list|(
name|operand_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gettrap
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_LoadStor
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_cinv_parameters
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|getconstant
parameter_list|(
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|op_err
name|check_range
parameter_list|(
name|long
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getreg_image
parameter_list|(
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operands
parameter_list|(
name|ins
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_insn
parameter_list|(
name|ins
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_operand
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_constant
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|argument
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|exponent2scale
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mask_reg
parameter_list|(
name|int
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_label_constant
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_operand
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|preprocess_reglist
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assemble_insn
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_insn
parameter_list|(
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_if_needed
parameter_list|(
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adjust_if_needed
parameter_list|(
name|ins
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the bit size for a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|get_opbits
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|crx_optab
index|[
name|op
index|]
operator|.
name|bit_size
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the argument type of a given operand.  */
end_comment

begin_function
specifier|static
name|argtype
name|get_optype
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|crx_optab
index|[
name|op
index|]
operator|.
name|arg_type
return|;
else|else
return|return
name|nullargs
return|;
block|}
end_function

begin_comment
comment|/* Return the flags of a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|get_opflags
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|crx_optab
index|[
name|op
index|]
operator|.
name|flags
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the core processor register 'reg_name'.  */
end_comment

begin_function
specifier|static
name|reg
name|get_register
parameter_list|(
name|char
modifier|*
name|reg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
return|return
name|reg
operator|->
name|value
operator|.
name|reg_val
return|;
else|else
return|return
name|nullregister
return|;
block|}
end_function

begin_comment
comment|/* Get the coprocessor register 'copreg_name'.  */
end_comment

begin_function
specifier|static
name|copreg
name|get_copregister
parameter_list|(
name|char
modifier|*
name|copreg_name
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|copreg
decl_stmt|;
name|copreg
operator|=
operator|(
specifier|const
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|copreg_hash
argument_list|,
name|copreg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|copreg
operator|!=
name|NULL
condition|)
return|return
name|copreg
operator|->
name|value
operator|.
name|copreg_val
return|;
else|else
return|return
name|nullcopregister
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|val
parameter_list|)
block|{
comment|/* Round .text section to a multiple of 2.  */
if|if
condition|(
name|seg
operator|==
name|text_section
condition|)
return|return
operator|(
name|val
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific (remove '*').  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
name|c
init|=
operator|*
name|input_line_pointer
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Reset global variables before parsing a new instruction.  */
end_comment

begin_function
specifier|static
name|void
name|reset_vars
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|cur_arg_num
operator|=
name|relocatable
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|output_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|output_opcode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save a copy of the original OP (used in error messages).  */
name|strncpy
argument_list|(
name|ins_parse
argument_list|,
name|op
argument_list|,
sizeof|sizeof
name|ins_parse
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ins_parse
index|[
sizeof|sizeof
name|ins_parse
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This macro decides whether a particular reloc is an entry in a    switch table.  It is used when relaxing, because the linker needs    to know about all such entries so that it can adjust them if    necessary.  */
end_comment

begin_define
define|#
directive|define
name|SWITCH_TABLE
parameter_list|(
name|fix
parameter_list|)
define|\
value|(   (fix)->fx_addsy != NULL				  \&& (fix)->fx_subsy != NULL				  \&& S_GET_SEGMENT ((fix)->fx_addsy) ==		  \       S_GET_SEGMENT ((fix)->fx_subsy)			  \&& S_GET_SEGMENT (fix->fx_addsy) != undefined_section  \&& (   (fix)->fx_r_type == BFD_RELOC_CRX_NUM8	  \        || (fix)->fx_r_type == BFD_RELOC_CRX_NUM16	  \        || (fix)->fx_r_type == BFD_RELOC_CRX_NUM32))
end_define

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|crx_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
if|if
condition|(
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
operator|||
name|SWITCH_TABLE
argument_list|(
name|fix
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate a relocation entry for a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SWITCH_TABLE
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* Keep the current difference in the addend.  */
name|reloc
operator|->
name|addend
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|+
name|fixP
operator|->
name|fx_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CRX_NUM8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CRX_SWITCH8
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRX_NUM16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CRX_SWITCH16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRX_NUM32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_CRX_SWITCH32
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We only resolve difference expressions in the same section.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't resolve `%s' {%s section} - `%s' {%s section}"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|"0"
argument_list|,
name|segment_name
argument_list|(
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|absolute_section
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: reloc %d (`%s') not supported by object file format"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Prepare machine-dependent frags for relaxation.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|)
block|{
comment|/* If symbol is undefined or located in a different section,      select the largest supported relocation.  */
name|relax_substateT
name|subtype
decl_stmt|;
name|relax_substateT
name|rlx_state
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
for|for
control|(
name|subtype
operator|=
literal|0
init|;
name|subtype
operator|<
name|ARRAY_SIZE
argument_list|(
name|rlx_state
argument_list|)
condition|;
name|subtype
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
name|rlx_state
index|[
name|subtype
index|]
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|rlx_state
index|[
name|subtype
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|>=
name|ARRAY_SIZE
argument_list|(
name|md_relax_table
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|md_relax_table
index|[
name|fragp
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* 'opcode' points to the start of the instruction, whether      we need to change the instruction's fixed encoding.  */
name|char
modifier|*
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
literal|0
case|:
name|reloc
operator|=
name|BFD_RELOC_CRX_REL8
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|opcode
operator|=
literal|0x7e
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_CRX_REL16
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|opcode
operator|=
literal|0x7f
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_CRX_REL32
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|reloc
operator|=
name|BFD_RELOC_CRX_REL16
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
operator|++
name|opcode
operator|=
literal|0x31
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_CRX_REL32
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|reloc
operator|=
name|BFD_RELOC_CRX_REL8_CMP
expr_stmt|;
break|break;
case|case
literal|6
case|:
operator|*
operator|++
name|opcode
operator|=
literal|0x31
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_CRX_REL24
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process machine-dependent command line options.  Called once for    each option on the command line that the machine-independent part of    GAS does not understand.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Machine-dependent usage-output.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixS (fixup of an instruction or data that we didn't have    enough info to complete immediately) to the data in a frag.    Since linkrelax is nonzero and TC_LINKRELAX_FIXUP is defined to disable    relaxation of debug sections, this function is called only when    fixuping relocations of debug sections.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|valueT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CRX_NUM8
case|:
name|bfd_put_8
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRX_NUM16
case|:
name|bfd_put_16
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRX_NUM32
case|:
name|bfd_put_32
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We shouldn't ever get here because linkrelax is nonzero.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|1
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hashret
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Set up a hash table for the instructions.  */
if|if
condition|(
operator|(
name|crx_inst_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|crx_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|mnemonic
init|=
name|crx_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
decl_stmt|;
name|hashret
operator|=
name|hash_insert
argument_list|(
name|crx_inst_hash
argument_list|,
name|mnemonic
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|crx_instruction
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
operator|!=
name|NULL
operator|&&
operator|*
name|hashret
operator|!=
literal|'\0'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|crx_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
operator|*
name|hashret
operator|==
literal|0
condition|?
name|_
argument_list|(
literal|"(unknown reason)"
argument_list|)
else|:
name|hashret
argument_list|)
expr_stmt|;
comment|/* Insert unique names into hash table.  The CRX instruction set 	 has many identical opcode names that have different opcodes based 	 on the operands.  This hash table then provides a quick index to 	 the first opcode with a particular name in the opcode table.  */
do|do
block|{
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|crx_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|crx_instruction
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
name|mnemonic
argument_list|)
condition|)
do|;
block|}
comment|/* Initialize reg_hash hash table.  */
if|if
condition|(
operator|(
name|reg_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|crx_regtab
init|;
name|regtab
operator|<
operator|(
name|crx_regtab
operator|+
name|NUMREGS
operator|)
condition|;
name|regtab
operator|++
control|)
block|{
name|hashret
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|regtab
operator|->
name|name
argument_list|,
name|hashret
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize copreg_hash hash table.  */
if|if
condition|(
operator|(
name|copreg_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|reg_entry
modifier|*
name|copregtab
decl_stmt|;
for|for
control|(
name|copregtab
operator|=
name|crx_copregtab
init|;
name|copregtab
operator|<
operator|(
name|crx_copregtab
operator|+
name|NUMCOPREGS
operator|)
condition|;
name|copregtab
operator|++
control|)
block|{
name|hashret
operator|=
name|hash_insert
argument_list|(
name|copreg_hash
argument_list|,
name|copregtab
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|copregtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|copregtab
operator|->
name|name
argument_list|,
name|hashret
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Set linkrelax here to avoid fixups in most sections.  */
name|linkrelax
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process constants (immediate/absolute)     and labels (jump targets/Memory locations).  */
end_comment

begin_function
specifier|static
name|void
name|process_label_constant
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|ins
modifier|*
name|crx_ins
parameter_list|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|argument
modifier|*
name|cur_arg
init|=
operator|&
name|crx_ins
operator|->
name|arg
index|[
name|cur_arg_num
index|]
decl_stmt|;
comment|/* Current argument.  */
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|crx_ins
operator|->
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|crx_ins
operator|->
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_big
case|:
case|case
name|O_absent
case|:
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|crx_ins
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|crx_ins
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|crx_ins
operator|->
name|exp
operator|.
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|crx_ins
operator|->
name|exp
operator|.
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|cur_arg
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|cur_arg
operator|->
name|constant
operator|=
name|crx_ins
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
case|case
name|O_subtract
case|:
case|case
name|O_add
case|:
name|cur_arg
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|relocatable
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cur_arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_cr
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REGREL12
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|STOR_IMM_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REGREL28
expr_stmt|;
else|else
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REGREL32
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REGREL22
expr_stmt|;
break|break;
case|case
name|arg_c
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|DCR_BRANCH_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REL16
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REL8
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|STOR_IMM_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_ABS32
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_NEQ_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REL4
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|CMPBR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|COP_BRANCH_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_REL8_CMP
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|ARITH_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_IMM32
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|ARITH_BYTE_INS
argument_list|)
condition|)
name|crx_ins
operator|->
name|rtype
operator|=
name|BFD_RELOC_CRX_IMM16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
name|cur_arg
operator|->
name|X_op
operator|=
name|crx_ins
operator|->
name|exp
operator|.
name|X_op
expr_stmt|;
break|break;
block|}
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Get the values of the scale to be encoded -    used for the scaled index mode of addressing.  */
end_comment

begin_function
specifier|static
name|int
name|exponent2scale
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|int
name|exponent
decl_stmt|;
comment|/* If 'val' is 0, the following 'for' will be an endless loop.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|exponent
operator|=
literal|0
init|;
operator|(
name|val
operator|!=
literal|1
operator|)
condition|;
name|val
operator|>>=
literal|1
operator|,
name|exponent
operator|++
control|)
empty_stmt|;
return|return
name|exponent
return|;
block|}
end_function

begin_comment
comment|/* Parsing different types of operands    -> constants		    Immediate/Absolute/Relative numbers    -> Labels		    Relocatable symbols    -> (rbase)		    Register base    -> disp(rbase)	    Register relative    -> disp(rbase)+	    Post-increment mode    -> disp(rbase,ridx,scl)  Register index mode  */
end_comment

begin_function
specifier|static
name|void
name|set_operand
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|,
name|ins
modifier|*
name|crx_ins
parameter_list|)
block|{
name|char
modifier|*
name|operandS
decl_stmt|;
comment|/* Pointer to start of sub-opearand.  */
name|char
modifier|*
name|operandE
decl_stmt|;
comment|/* Pointer to end of sub-opearand.  */
name|expressionS
name|scale
decl_stmt|;
name|int
name|scale_val
decl_stmt|;
name|char
modifier|*
name|input_save
decl_stmt|,
name|c
decl_stmt|;
name|argument
modifier|*
name|cur_arg
init|=
operator|&
name|crx_ins
operator|->
name|arg
index|[
name|cur_arg_num
index|]
decl_stmt|;
comment|/* Current argument.  */
comment|/* Initialize pointers.  */
name|operandS
operator|=
name|operandE
operator|=
name|operand
expr_stmt|;
switch|switch
condition|(
name|cur_arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_sc
case|:
comment|/* Case *+0x18.  */
case|case
name|arg_ic
case|:
comment|/* Case $0x18.  */
name|operandS
operator|++
expr_stmt|;
case|case
name|arg_c
case|:
comment|/* Case 0x18.  */
comment|/* Set constant.  */
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|crx_ins
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_arg
operator|->
name|type
operator|!=
name|arg_ic
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_c
expr_stmt|;
break|break;
case|case
name|arg_icr
case|:
comment|/* Case $0x18(r1).  */
name|operandS
operator|++
expr_stmt|;
case|case
name|arg_cr
case|:
comment|/* Case 0x18(r1).   */
comment|/* Set displacement constant.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|'('
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|crx_ins
argument_list|)
expr_stmt|;
name|operandS
operator|=
name|operandE
expr_stmt|;
case|case
name|arg_rbase
case|:
comment|/* Case (r1).  */
name|operandS
operator|++
expr_stmt|;
comment|/* Set register base.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|')'
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|r
operator|=
name|get_register
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_arg
operator|->
name|type
operator|!=
name|arg_rbase
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_cr
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
comment|/* Set displacement constant.  */
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|'('
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
name|process_label_constant
argument_list|(
name|operandS
argument_list|,
name|crx_ins
argument_list|)
expr_stmt|;
name|operandS
operator|=
operator|++
name|operandE
expr_stmt|;
comment|/* Set register base.  */
while|while
condition|(
operator|(
operator|*
name|operandE
operator|!=
literal|','
operator|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|operandE
argument_list|)
operator|)
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|r
operator|=
name|get_register
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
comment|/* Skip leading white space.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|operandE
argument_list|)
condition|)
name|operandE
operator|++
expr_stmt|;
name|operandS
operator|=
name|operandE
expr_stmt|;
comment|/* Set register index.  */
while|while
condition|(
operator|(
operator|*
name|operandE
operator|!=
literal|')'
operator|)
operator|&&
operator|(
operator|*
name|operandE
operator|!=
literal|','
operator|)
condition|)
name|operandE
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|operandE
expr_stmt|;
operator|*
name|operandE
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cur_arg
operator|->
name|i_r
operator|=
name|get_register
argument_list|(
name|operandS
argument_list|)
operator|)
operator|==
name|nullregister
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in Instruction `%s'"
argument_list|)
argument_list|,
name|operandS
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
comment|/* Skip leading white space.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|operandE
argument_list|)
condition|)
name|operandE
operator|++
expr_stmt|;
name|operandS
operator|=
name|operandE
expr_stmt|;
comment|/* Set the scale.  */
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|cur_arg
operator|->
name|scale
operator|=
literal|0
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|*
name|operandE
operator|!=
literal|')'
condition|)
name|operandE
operator|++
expr_stmt|;
operator|*
name|operandE
operator|=
literal|'\0'
expr_stmt|;
comment|/* Preprocess the scale string.  */
name|input_save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|operandS
expr_stmt|;
name|expression
argument_list|(
operator|&
name|scale
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|input_save
expr_stmt|;
name|scale_val
operator|=
name|scale
operator|.
name|X_add_number
expr_stmt|;
comment|/* Check if the scale value is legal.  */
if|if
condition|(
name|scale_val
operator|!=
literal|1
operator|&&
name|scale_val
operator|!=
literal|2
operator|&&
name|scale_val
operator|!=
literal|4
operator|&&
name|scale_val
operator|!=
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal Scale - `%d'"
argument_list|)
argument_list|,
name|scale_val
argument_list|)
expr_stmt|;
name|cur_arg
operator|->
name|scale
operator|=
name|exponent2scale
argument_list|(
name|scale_val
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a single operand.    operand - Current operand to parse.    crx_ins - Current assembled instruction.  */
end_comment

begin_function
specifier|static
name|void
name|parse_operand
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|,
name|ins
modifier|*
name|crx_ins
parameter_list|)
block|{
name|int
name|ret_val
decl_stmt|;
name|argument
modifier|*
name|cur_arg
init|=
operator|&
name|crx_ins
operator|->
name|arg
index|[
name|cur_arg_num
index|]
decl_stmt|;
comment|/* Current argument.  */
comment|/* Initialize the type to NULL before parsing.  */
name|cur_arg
operator|->
name|type
operator|=
name|nullargs
expr_stmt|;
comment|/* Check whether this is a general processor register.  */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|get_register
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullregister
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_r
expr_stmt|;
name|cur_arg
operator|->
name|r
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Check whether this is a core [special] coprocessor register.  */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|get_copregister
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|nullcopregister
condition|)
block|{
name|cur_arg
operator|->
name|type
operator|=
name|arg_copr
expr_stmt|;
if|if
condition|(
name|ret_val
operator|>=
name|cs0
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_copsr
expr_stmt|;
name|cur_arg
operator|->
name|cr
operator|=
name|ret_val
expr_stmt|;
name|cur_arg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
return|return;
block|}
comment|/* Deal with special characters.  */
switch|switch
condition|(
name|operand
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'$'
case|:
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_icr
expr_stmt|;
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_ic
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
case|case
literal|'*'
case|:
name|cur_arg
operator|->
name|type
operator|=
name|arg_sc
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
case|case
literal|'('
case|:
name|cur_arg
operator|->
name|type
operator|=
name|arg_rbase
expr_stmt|;
goto|goto
name|set_params
goto|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|operand
argument_list|,
literal|','
argument_list|)
operator|>
name|strchr
argument_list|(
name|operand
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
name|cur_arg
operator|->
name|type
operator|=
name|arg_idxr
expr_stmt|;
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_cr
expr_stmt|;
block|}
else|else
name|cur_arg
operator|->
name|type
operator|=
name|arg_c
expr_stmt|;
goto|goto
name|set_params
goto|;
comment|/* Parse an operand according to its type.  */
name|set_params
label|:
name|cur_arg
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|set_operand
argument_list|(
name|operand
argument_list|,
name|crx_ins
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the various operands. Each operand is then analyzed to fillup     the fields in the crx_ins data structure.  */
end_comment

begin_function
specifier|static
name|void
name|parse_operands
parameter_list|(
name|ins
modifier|*
name|crx_ins
parameter_list|,
name|char
modifier|*
name|operands
parameter_list|)
block|{
name|char
modifier|*
name|operandS
decl_stmt|;
comment|/* Operands string.  */
name|char
modifier|*
name|operandH
decl_stmt|,
modifier|*
name|operandT
decl_stmt|;
comment|/* Single operand head/tail pointers.  */
name|int
name|allocated
init|=
literal|0
decl_stmt|;
comment|/* Indicates a new operands string was allocated.  */
name|char
modifier|*
name|operand
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Separating the operands.  */
name|int
name|op_num
init|=
literal|0
decl_stmt|;
comment|/* Current operand number we are parsing.  */
name|int
name|bracket_flag
init|=
literal|0
decl_stmt|;
comment|/* Indicates a bracket '(' was found.  */
name|int
name|sq_bracket_flag
init|=
literal|0
decl_stmt|;
comment|/* Indicates a square bracket '[' was found.  */
comment|/* Preprocess the list of registers, if necessary.  */
name|operandS
operator|=
name|operandH
operator|=
name|operandT
operator|=
operator|(
name|INST_HAS_REG_LIST
operator|)
condition|?
name|preprocess_reglist
argument_list|(
name|operands
argument_list|,
operator|&
name|allocated
argument_list|)
else|:
name|operands
expr_stmt|;
while|while
condition|(
operator|*
name|operandT
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|operandT
operator|==
literal|','
operator|&&
name|bracket_flag
operator|!=
literal|1
operator|&&
name|sq_bracket_flag
operator|!=
literal|1
condition|)
block|{
operator|*
name|operandT
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|operand
index|[
name|op_num
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|operandH
argument_list|)
expr_stmt|;
name|operandH
operator|=
name|operandT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|operandT
operator|==
literal|' '
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands (whitespace): `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|operandT
operator|==
literal|'('
condition|)
name|bracket_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|operandT
operator|==
literal|'['
condition|)
name|sq_bracket_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|operandT
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|bracket_flag
condition|)
name|bracket_flag
operator|=
literal|0
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|operandT
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|sq_bracket_flag
condition|)
name|sq_bracket_flag
operator|=
literal|0
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bracket_flag
operator|==
literal|1
operator|&&
operator|*
name|operandT
operator|==
literal|')'
condition|)
name|bracket_flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sq_bracket_flag
operator|==
literal|1
operator|&&
operator|*
name|operandT
operator|==
literal|']'
condition|)
name|sq_bracket_flag
operator|=
literal|0
expr_stmt|;
name|operandT
operator|++
expr_stmt|;
block|}
comment|/* Adding the last operand.  */
name|operand
index|[
name|op_num
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|operandH
argument_list|)
expr_stmt|;
name|crx_ins
operator|->
name|nargs
operator|=
name|op_num
expr_stmt|;
comment|/* Verifying correct syntax of operands (all brackets should be closed).  */
if|if
condition|(
name|bracket_flag
operator|||
name|sq_bracket_flag
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
comment|/* Now we parse each operand separately.  */
for|for
control|(
name|op_num
operator|=
literal|0
init|;
name|op_num
operator|<
name|crx_ins
operator|->
name|nargs
condition|;
name|op_num
operator|++
control|)
block|{
name|cur_arg_num
operator|=
name|op_num
expr_stmt|;
name|parse_operand
argument_list|(
name|operand
index|[
name|op_num
index|]
argument_list|,
name|crx_ins
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|operand
index|[
name|op_num
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocated
condition|)
name|free
argument_list|(
name|operandS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the trap index in dispatch table, given its name.    This routine is used by assembling the 'excp' instruction.  */
end_comment

begin_function
specifier|static
name|int
name|gettrap
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|trap_entry
modifier|*
name|trap
decl_stmt|;
for|for
control|(
name|trap
operator|=
name|crx_traps
init|;
name|trap
operator|<
operator|(
name|crx_traps
operator|+
name|NUMTRAPS
operator|)
condition|;
name|trap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|trap
operator|->
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|trap
operator|->
name|entry
return|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown exception: `%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Post-Increment instructions, as well as Store-Immediate instructions, are a     sub-group within load/stor instruction groups.     Therefore, when parsing a Post-Increment/Store-Immediate insn, we have to     advance the instruction pointer to the start of that sub-group (that is, up     to the first instruction of that type).    Otherwise, the insn will be mistakenly identified as of type LD_STOR_INS.  */
end_comment

begin_function
specifier|static
name|void
name|handle_LoadStor
parameter_list|(
name|char
modifier|*
name|operands
parameter_list|)
block|{
comment|/* Post-Increment instructions precede Store-Immediate instructions in       CRX instruction table, hence they are handled before.       This synchronization should be kept.  */
comment|/* Assuming Post-Increment insn has the following format :      'MNEMONIC DISP(REG)+, REG' (e.g. 'loadw 12(r5)+, r6').      LD_STOR_INS_INC are the only store insns containing a plus sign (+).  */
if|if
condition|(
name|strstr
argument_list|(
name|operands
argument_list|,
literal|")+"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
condition|)
name|instruction
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Assuming Store-Immediate insn has the following format :      'MNEMONIC $DISP, ...' (e.g. 'storb $1, 12(r5)').      STOR_IMM_INS are the only store insns containing a dollar sign ($).  */
if|if
condition|(
name|strstr
argument_list|(
name|operands
argument_list|,
literal|"$"
argument_list|)
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|!
name|IS_INSN_TYPE
argument_list|(
name|STOR_IMM_INS
argument_list|)
condition|)
name|instruction
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level module where instruction parsing starts.    crx_ins - data structure holds some information.    operands - holds the operands part of the whole instruction.  */
end_comment

begin_function
specifier|static
name|void
name|parse_insn
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|,
name|char
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Handle instructions with no operands.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|no_op_insn
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|no_op_insn
index|[
name|i
index|]
argument_list|,
name|instruction
operator|->
name|mnemonic
argument_list|)
condition|)
block|{
name|insn
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle 'excp'/'cinv' instructions.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"excp"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"cinv"
argument_list|)
condition|)
block|{
name|insn
operator|->
name|nargs
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|arg_ic
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|=
name|IS_INSN_MNEMONIC
argument_list|(
literal|"excp"
argument_list|)
condition|?
name|gettrap
argument_list|(
name|operands
argument_list|)
else|:
name|get_cinv_parameters
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
return|return;
block|}
comment|/* Handle load/stor unique instructions before parsing.  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
condition|)
name|handle_LoadStor
argument_list|(
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
operator|!=
name|NULL
condition|)
name|parse_operands
argument_list|(
name|insn
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cinv instruction requires special handling.  */
end_comment

begin_function
specifier|static
name|int
name|get_cinv_parameters
parameter_list|(
name|char
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|operand
decl_stmt|;
name|int
name|d_used
init|=
literal|0
decl_stmt|,
name|i_used
init|=
literal|0
decl_stmt|,
name|u_used
init|=
literal|0
decl_stmt|,
name|b_used
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'d'
condition|)
name|d_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'i'
condition|)
name|i_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
name|u_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
condition|)
name|b_used
operator|=
literal|1
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal `cinv' parameter: `%c'"
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|b_used
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
operator|(
name|d_used
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|i_used
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|u_used
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the opcode image of a given register.    If the register is illegal for the current instruction,    issue an error.  */
end_comment

begin_function
specifier|static
name|int
name|getreg_image
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|is_procreg
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means argument should be processor reg.  */
if|if
condition|(
operator|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"mtpr"
argument_list|)
operator|)
operator|&&
operator|(
name|cur_arg_num
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"mfpr"
argument_list|)
operator|)
operator|&&
operator|(
name|cur_arg_num
operator|==
literal|0
operator|)
operator|)
condition|)
name|is_procreg
operator|=
literal|1
expr_stmt|;
comment|/* Check whether the register is in registers table.  */
if|if
condition|(
name|r
operator|<
name|MAX_REG
condition|)
name|reg
operator|=
operator|&
name|crx_regtab
index|[
name|r
index|]
expr_stmt|;
comment|/* Check whether the register is in coprocessor registers table.  */
elseif|else
if|if
condition|(
name|r
operator|<
name|MAX_COPREG
condition|)
name|reg
operator|=
operator|&
name|crx_copregtab
index|[
name|r
operator|-
name|MAX_REG
index|]
expr_stmt|;
comment|/* Register not found.  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown register: `%d'"
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg_name
operator|=
name|reg
operator|->
name|name
expr_stmt|;
comment|/* Issue a error message when register is illegal.  */
define|#
directive|define
name|IMAGE_ERR
define|\
value|as_bad (_("Illegal register (`%s') in Instruction: `%s'"), \ 	    reg_name, ins_parse);			     \   break;
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|CRX_U_REGTYPE
case|:
if|if
condition|(
name|is_procreg
operator|||
operator|(
name|instruction
operator|->
name|flags
operator|&
name|USER_REG
operator|)
condition|)
return|return
name|reg
operator|->
name|image
return|;
else|else
name|IMAGE_ERR
expr_stmt|;
case|case
name|CRX_CFG_REGTYPE
case|:
if|if
condition|(
name|is_procreg
condition|)
return|return
name|reg
operator|->
name|image
return|;
else|else
name|IMAGE_ERR
expr_stmt|;
case|case
name|CRX_R_REGTYPE
case|:
if|if
condition|(
operator|!
name|is_procreg
condition|)
return|return
name|reg
operator|->
name|image
return|;
else|else
name|IMAGE_ERR
expr_stmt|;
case|case
name|CRX_C_REGTYPE
case|:
case|case
name|CRX_CS_REGTYPE
case|:
return|return
name|reg
operator|->
name|image
return|;
break|break;
default|default:
name|IMAGE_ERR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routine used to represent integer X using NBITS bits.  */
end_comment

begin_function
specifier|static
name|long
name|getconstant
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
comment|/* The following expression avoids overflow if      'nbits' is the number of bits in 'bfd_vma'.  */
return|return
operator|(
name|x
operator|&
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a constant value to 'output_opcode':    ARG holds the operand's type and value.    SHIFT represents the location of the operand to be print into.    NBITS determines the size (in bits) of the constant.  */
end_comment

begin_function
specifier|static
name|void
name|print_constant
parameter_list|(
name|int
name|nbits
parameter_list|,
name|int
name|shift
parameter_list|,
name|argument
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|long
name|constant
init|=
name|getconstant
argument_list|(
name|arg
operator|->
name|constant
argument_list|,
name|nbits
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nbits
condition|)
block|{
case|case
literal|32
case|:
case|case
literal|28
case|:
case|case
literal|24
case|:
case|case
literal|22
case|:
comment|/* mask the upper part of the constant, that is, the bits 	 going to the lowest byte of output_opcode[0]. 	 The upper part of output_opcode[1] is always filled, 	 therefore it is always masked with 0xFFFF.  */
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|16
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Divide the constant between two consecutive words : 		 0	   1	     2	       3 	    +---------+---------+---------+---------+ 	    |	      | X X X X | X X X X |	    | 	    +---------+---------+---------+---------+ 	      output_opcode[0]    output_opcode[1]     */
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
operator|(
name|constant
operator|>>
name|WORD_SHIFT
operator|)
operator|&
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CRX_PRINT
argument_list|(
literal|1
argument_list|,
operator|(
name|constant
operator|&
literal|0xFFFF
operator|)
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
case|case
literal|12
case|:
comment|/* Special case - in arg_cr, the SHIFT represents the location 	 of the REGISTER, not the constant, which is itself not shifted.  */
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|arg_cr
condition|)
block|{
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* When instruction size is 3 and 'shift' is 16, a 16-bit constant is  	 always filling the upper part of output_opcode[1]. If we mistakenly  	 write it to output_opcode[0], the constant prefix (that is, 'match') 	 will be overridden. 		 0	   1	     2	       3 	    +---------+---------+---------+---------+ 	    | 'match' |         | X X X X |	    | 	    +---------+---------+---------+---------+ 	      output_opcode[0]    output_opcode[1]     */
if|if
condition|(
operator|(
name|instruction
operator|->
name|size
operator|>
literal|2
operator|)
operator|&&
operator|(
name|shift
operator|==
name|WORD_SHIFT
operator|)
condition|)
name|CRX_PRINT
argument_list|(
literal|1
argument_list|,
name|constant
argument_list|,
name|WORD_SHIFT
argument_list|)
expr_stmt|;
else|else
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|constant
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print an operand to 'output_opcode', which later on will be    printed to the object file:    ARG holds the operand's type, size and value.    SHIFT represents the printing location of operand.    NBITS determines the size (in bits) of a constant operand.  */
end_comment

begin_function
specifier|static
name|void
name|print_operand
parameter_list|(
name|int
name|nbits
parameter_list|,
name|int
name|shift
parameter_list|,
name|argument
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|arg
operator|->
name|type
condition|)
block|{
case|case
name|arg_r
case|:
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_copr
case|:
if|if
condition|(
name|arg
operator|->
name|cr
operator|<
name|c0
operator|||
name|arg
operator|->
name|cr
operator|>
name|c15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal Co-processor register in Instruction `%s' "
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|cr
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_copsr
case|:
if|if
condition|(
name|arg
operator|->
name|cr
operator|<
name|cs0
operator|||
name|arg
operator|->
name|cr
operator|>
name|cs15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal Co-processor special register in Instruction `%s' "
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|cr
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
comment|/*    16      12	      8    6         0 	    +--------------------------------+ 	    | r_base | r_idx  | scl|  disp   | 	    +--------------------------------+	  */
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|i_r
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|arg
operator|->
name|scale
argument_list|,
literal|6
argument_list|)
expr_stmt|;
case|case
name|arg_ic
case|:
case|case
name|arg_c
case|:
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
comment|/* case base_cst4.  */
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|DISPU4MAP
condition|)
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
operator|+
name|REG_SIZE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
comment|/* rbase_disps<NN> and other such cases.  */
name|print_constant
argument_list|(
name|nbits
argument_list|,
name|shift
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Add the register argument to the output_opcode.  */
name|CRX_PRINT
argument_list|(
literal|0
argument_list|,
name|getreg_image
argument_list|(
name|arg
operator|->
name|r
argument_list|)
argument_list|,
name|shift
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the number of operands for the current assembled instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|&&
name|i
operator|<
name|MAX_OPERANDS
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Verify that the number NUM can be represented in BITS bits (that is,     within its permitted range), based on the instruction's FLAGS.      If UPDATE is nonzero, update the value of NUM if necessary.    Return OP_LEGAL upon success, actual error type upon failure.  */
end_comment

begin_function
specifier|static
name|op_err
name|check_range
parameter_list|(
name|long
modifier|*
name|num
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|unsigned
name|flags
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|retval
init|=
name|OP_LEGAL
decl_stmt|;
name|int
name|bin
decl_stmt|;
name|long
name|upper_64kb
init|=
literal|0xFFFF0000
decl_stmt|;
name|long
name|value
init|=
operator|*
name|num
decl_stmt|;
comment|/* For hosts witah longs bigger than 32-bits make sure that the top       bits of a 32-bit negative value read in by the parser are set,      so that the correct comparisons are made.  */
if|if
condition|(
name|value
operator|&
literal|0x80000000
condition|)
name|value
operator||=
operator|(
operator|-
literal|1L
operator|<<
literal|31
operator|)
expr_stmt|;
comment|/* Verify operand value is even.  */
if|if
condition|(
name|flags
operator|&
name|OP_EVEN
condition|)
block|{
if|if
condition|(
name|value
operator|%
literal|2
condition|)
return|return
name|OP_NOT_EVEN
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_UPPER_64KB
condition|)
block|{
comment|/* Check if value is to be mapped to upper 64 KB memory area.  */
if|if
condition|(
operator|(
name|value
operator|&
name|upper_64kb
operator|)
operator|==
name|upper_64kb
condition|)
block|{
name|value
operator|-=
name|upper_64kb
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
else|else
return|return
name|OP_NOT_UPPER_64KB
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_SHIFT
condition|)
block|{
name|value
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_SHIFT_DEC
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_ESC
condition|)
block|{
comment|/* 0x7e and 0x7f are reserved escape sequences of dispe9.  */
if|if
condition|(
name|value
operator|==
literal|0x7e
operator|||
name|value
operator|==
literal|0x7f
condition|)
return|return
name|OP_OUT_OF_RANGE
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OP_DISPU4
condition|)
block|{
name|int
name|is_dispu4
init|=
literal|0
decl_stmt|;
name|int
name|mul
init|=
operator|(
name|instruction
operator|->
name|flags
operator|&
name|DISPUB4
operator|)
condition|?
literal|1
else|:
operator|(
name|instruction
operator|->
name|flags
operator|&
name|DISPUW4
operator|)
condition|?
literal|2
else|:
operator|(
name|instruction
operator|->
name|flags
operator|&
name|DISPUD4
operator|)
condition|?
literal|4
else|:
literal|0
decl_stmt|;
for|for
control|(
name|bin
operator|=
literal|0
init|;
name|bin
operator|<
name|cst4_maps
condition|;
name|bin
operator|++
control|)
block|{
if|if
condition|(
name|value
operator|==
operator|(
name|mul
operator|*
name|bin
operator|)
condition|)
block|{
name|is_dispu4
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|bin
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|is_dispu4
condition|)
name|retval
operator|=
name|OP_ILLEGAL_DISPU4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_CST4
condition|)
block|{
name|int
name|is_cst4
init|=
literal|0
decl_stmt|;
for|for
control|(
name|bin
operator|=
literal|0
init|;
name|bin
operator|<
name|cst4_maps
condition|;
name|bin
operator|++
control|)
block|{
if|if
condition|(
name|value
operator|==
name|cst4_map
index|[
name|bin
index|]
condition|)
block|{
name|is_cst4
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|update
condition|)
operator|*
name|num
operator|=
name|bin
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|is_cst4
condition|)
name|retval
operator|=
name|OP_ILLEGAL_CST4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_SIGNED
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|>
name|max
operator|)
operator|||
operator|(
name|value
operator|<
name|min
operator|)
condition|)
name|retval
operator|=
name|OP_OUT_OF_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OP_UNSIGNED
condition|)
block|{
name|max
operator|=
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|<
operator|(
name|unsigned
name|long
operator|)
name|min
operator|)
condition|)
name|retval
operator|=
name|OP_OUT_OF_RANGE
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction:    INSN is already parsed (that is, all operand values and types are set).    For instruction to be assembled, we need to find an appropriate template in     the instruction table, meeting the following conditions:     1: Has the same number of operands.     2: Has the same operand types.     3: Each operand size is sufficient to represent the instruction's values.    Returns 1 upon success, 0 upon failure.  */
end_comment

begin_function
specifier|static
name|int
name|assemble_insn
parameter_list|(
name|char
modifier|*
name|mnemonic
parameter_list|,
name|ins
modifier|*
name|insn
parameter_list|)
block|{
comment|/* Type of each operand in the current template.  */
name|argtype
name|cur_type
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Size (in bits) of each operand in the current template.  */
name|unsigned
name|int
name|cur_size
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Flags of each operand in the current template.  */
name|unsigned
name|int
name|cur_flags
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Instruction type to match.  */
name|unsigned
name|int
name|ins_type
decl_stmt|;
comment|/* Boolean flag to mark whether a match was found.  */
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Nonzero if an instruction with same number of operands was found.  */
name|int
name|found_same_number_of_operands
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if an instruction with same argument types was found.  */
name|int
name|found_same_argument_types
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if a constant was found within the required range.  */
name|int
name|found_const_within_range
init|=
literal|0
decl_stmt|;
comment|/* Argument number of an operand with invalid type.  */
name|int
name|invalid_optype
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Argument number of an operand with invalid constant value.  */
name|int
name|invalid_const
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Operand error (used for issuing various constant error messages).  */
name|op_err
name|op_error
decl_stmt|,
name|const_err
init|=
name|OP_LEGAL
decl_stmt|;
comment|/* Retrieve data (based on FUNC) for each operand of a given instruction.  */
define|#
directive|define
name|GET_CURRENT_DATA
parameter_list|(
name|FUNC
parameter_list|,
name|ARRAY
parameter_list|)
define|\
value|for (i = 0; i< insn->nargs; i++)				  \     ARRAY[i] = FUNC (instruction->operands[i].op_type)
define|#
directive|define
name|GET_CURRENT_TYPE
value|GET_CURRENT_DATA(get_optype, cur_type)
define|#
directive|define
name|GET_CURRENT_SIZE
value|GET_CURRENT_DATA(get_opbits, cur_size)
define|#
directive|define
name|GET_CURRENT_FLAGS
value|GET_CURRENT_DATA(get_opflags, cur_flags)
comment|/* Instruction has no operands -> only copy the constant opcode.   */
if|if
condition|(
name|insn
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|output_opcode
index|[
literal|0
index|]
operator|=
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* In some case, same mnemonic can appear with different instruction types.      For example, 'storb' is supported with 3 different types :      LD_STOR_INS, LD_STOR_INS_INC, STOR_IMM_INS.      We assume that when reaching this point, the instruction type was       pre-determined. We need to make sure that the type stays the same      during a search for matching instruction.  */
name|ins_type
operator|=
name|CRX_INS_TYPE
argument_list|(
name|instruction
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
comment|/* Check that match is still not found.  */
name|match
operator|!=
literal|1
comment|/* Check we didn't get to end of table.  */
operator|&&
name|instruction
operator|->
name|mnemonic
operator|!=
name|NULL
comment|/* Check that the actual mnemonic is still available.  */
operator|&&
name|IS_INSN_MNEMONIC
argument_list|(
name|mnemonic
argument_list|)
comment|/* Check that the instruction type wasn't changed.  */
operator|&&
name|IS_INSN_TYPE
argument_list|(
name|ins_type
argument_list|)
condition|)
block|{
comment|/* Check whether number of arguments is legal.  */
if|if
condition|(
name|get_number_of_operands
argument_list|()
operator|!=
name|insn
operator|->
name|nargs
condition|)
goto|goto
name|next_insn
goto|;
name|found_same_number_of_operands
operator|=
literal|1
expr_stmt|;
comment|/* Initialize arrays with data of each operand in current template.  */
name|GET_CURRENT_TYPE
expr_stmt|;
name|GET_CURRENT_SIZE
expr_stmt|;
name|GET_CURRENT_FLAGS
expr_stmt|;
comment|/* Check for type compatibility.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_type
index|[
name|i
index|]
operator|!=
name|insn
operator|->
name|arg
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|invalid_optype
operator|==
operator|-
literal|1
condition|)
name|invalid_optype
operator|=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|next_insn
goto|;
block|}
block|}
name|found_same_argument_types
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Reverse the operand indices for certain opcodes: 	     Index 0	  -->> 1 	     Index 1	  -->> 0	 	     Other index  -->> stays the same.  */
name|int
name|j
init|=
name|instruction
operator|->
name|flags
operator|&
name|REVERSE_MATCH
condition|?
name|i
operator|==
literal|0
condition|?
literal|1
else|:
name|i
operator|==
literal|1
condition|?
literal|0
else|:
name|i
else|:
name|i
decl_stmt|;
comment|/* Only check range - don't update the constant's value, since the  	     current instruction may not be the last we try to match.   	     The constant's value will be updated later, right before printing  	     it to the object file.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|op_error
operator|=
name|check_range
argument_list|(
operator|&
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|constant
argument_list|,
name|cur_size
index|[
name|j
index|]
argument_list|,
name|cur_flags
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|invalid_const
operator|==
operator|-
literal|1
condition|)
block|{
name|invalid_const
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|const_err
operator|=
name|op_error
expr_stmt|;
block|}
goto|goto
name|next_insn
goto|;
block|}
comment|/* For symbols, we make sure the relocation size (which was already  	     determined) is sufficient.  */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|X_op
operator|==
name|O_symbol
operator|)
operator|&&
operator|(
operator|(
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
operator|)
operator|->
name|bitsize
operator|>
name|cur_size
index|[
name|j
index|]
operator|)
condition|)
goto|goto
name|next_insn
goto|;
block|}
name|found_const_within_range
operator|=
literal|1
expr_stmt|;
comment|/* If we got till here -> Full match is found.  */
name|match
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Try again with next instruction.  */
name|next_insn
label|:
name|instruction
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
comment|/* We haven't found a match - instruction can't be assembled.  */
if|if
condition|(
operator|!
name|found_same_number_of_operands
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Incorrect number of operands"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|found_same_argument_types
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal type of operand (arg %d)"
argument_list|)
argument_list|,
name|invalid_optype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|found_const_within_range
condition|)
block|{
switch|switch
condition|(
name|const_err
condition|)
block|{
case|case
name|OP_OUT_OF_RANGE
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of range (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_EVEN
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand has odd displacement (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ILLEGAL_DISPU4
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid DISPU4 operand value (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ILLEGAL_CST4
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid CST4 operand value (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_UPPER_64KB
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand value is not within upper 64 KB (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operand (arg %d)"
argument_list|)
argument_list|,
name|invalid_const
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
else|else
comment|/* Full match - print the encoding to output file.  */
block|{
comment|/* Make further checkings (such that couldn't be made earlier). 	 Warn the user if necessary.  */
name|warn_if_needed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check whether we need to adjust the instruction pointer.  */
if|if
condition|(
name|adjust_if_needed
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* If instruction pointer was adjusted, we need to update  	   the size of the current template operands.  */
name|GET_CURRENT_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|instruction
operator|->
name|flags
operator|&
name|REVERSE_MATCH
condition|?
name|i
operator|==
literal|0
condition|?
literal|1
else|:
name|i
operator|==
literal|1
condition|?
literal|0
else|:
name|i
else|:
name|i
decl_stmt|;
comment|/* This time, update constant value before printing it.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|check_range
argument_list|(
operator|&
name|insn
operator|->
name|arg
index|[
name|j
index|]
operator|.
name|constant
argument_list|,
name|cur_size
index|[
name|j
index|]
argument_list|,
name|cur_flags
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|!=
name|OP_LEGAL
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal operand (arg %d)"
argument_list|)
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* First, copy the instruction's opcode.  */
name|output_opcode
index|[
literal|0
index|]
operator|=
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|cur_arg_num
operator|=
name|i
expr_stmt|;
name|print_operand
argument_list|(
name|cur_size
index|[
name|i
index|]
argument_list|,
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|shift
argument_list|,
operator|&
name|insn
operator|->
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Bunch of error checkings.    The checks are made after a matching instruction was found.  */
end_comment

begin_function
name|void
name|warn_if_needed
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|)
block|{
comment|/* If the post-increment address mode is used and the load/store       source register is the same as rbase, the result of the       instruction is undefined.  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
condition|)
block|{
comment|/* Enough to verify that one of the arguments is a simple reg.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|arg_r
operator|)
operator|||
operator|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|arg_r
operator|)
condition|)
if|if
condition|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
operator|==
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Same src/dest register is used (`r%d'), result is undefined"
argument_list|)
argument_list|,
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Some instruction assume the stack pointer as rptr operand.      Issue an error when the register to be loaded is also SP.  */
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|NO_SP
condition|)
block|{
if|if
condition|(
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
operator|==
name|getreg_image
argument_list|(
name|sp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' has undefined result"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
block|}
comment|/* If the rptr register is specified as one of the registers to be loaded,       the final contents of rptr are undefined. Thus, we issue an error.  */
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|NO_RPTR
condition|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
operator|)
operator|&
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Same src/dest register is used (`r%d'), result is undefined"
argument_list|)
argument_list|,
name|getreg_image
argument_list|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In some cases, we need to adjust the instruction pointer although a     match was already found. Here, we gather all these cases.    Returns 1 if instruction pointer was adjusted, otherwise 0.  */
end_comment

begin_function
name|int
name|adjust_if_needed
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|ret_value
init|=
literal|0
decl_stmt|;
comment|/* Special check for 'addub $0, r0' instruction -      The opcode '0000 0000 0000 0000' is not allowed.  */
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"addub"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|instruction
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|op_type
operator|==
name|cst4
operator|)
operator|&&
name|instruction
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|op_type
operator|==
name|regr
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|constant
operator|==
literal|0
operator|&&
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|r
operator|==
name|r0
condition|)
block|{
name|instruction
operator|++
expr_stmt|;
name|ret_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Optimization: Omit a zero displacement in bit operations,       saving 2-byte encoding space (e.g., 'cbitw $8, 0(r1)').  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|instruction
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|op_type
operator|==
name|rbase_disps12
operator|)
operator|&&
operator|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|insn
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|constant
operator|==
literal|0
operator|)
condition|)
block|{
name|instruction
operator|--
expr_stmt|;
name|ret_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ret_value
return|;
block|}
end_function

begin_comment
comment|/* Set the appropriate bit for register 'r' in 'mask'.    This indicates that this register is loaded or stored by    the instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mask_reg
parameter_list|(
name|int
name|r
parameter_list|,
name|unsigned
name|short
name|int
modifier|*
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|reg
operator|)
name|r
operator|>
operator|(
name|reg
operator|)
name|sp
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Register in Register List"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|mask
operator||=
operator|(
literal|1
operator|<<
name|r
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Preprocess register list - create a 16-bit mask with one bit for each    of the 16 general purpose registers. If a bit is set, it indicates    that this register is loaded or stored by the instruction.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|preprocess_reglist
parameter_list|(
name|char
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|allocated
parameter_list|)
block|{
name|char
name|reg_name
index|[
name|MAX_REGNAME_LEN
index|]
decl_stmt|;
comment|/* Current parsed register name.  */
name|char
modifier|*
name|regP
decl_stmt|;
comment|/* Pointer to 'reg_name' string.  */
name|int
name|reg_counter
init|=
literal|0
decl_stmt|;
comment|/* Count number of parsed registers.  */
name|unsigned
name|short
name|int
name|mask
init|=
literal|0
decl_stmt|;
comment|/* Mask for 16 general purpose registers.  */
name|char
modifier|*
name|new_param
decl_stmt|;
comment|/* New created operands string.  */
name|char
modifier|*
name|paramP
init|=
name|param
decl_stmt|;
comment|/* Pointer to original opearands string.  */
name|char
name|maskstring
index|[
literal|10
index|]
decl_stmt|;
comment|/* Array to print the mask as a string.  */
name|int
name|hi_found
init|=
literal|0
decl_stmt|,
name|lo_found
init|=
literal|0
decl_stmt|;
comment|/* Boolean flags for hi/lo registers.  */
name|reg
name|r
decl_stmt|;
name|copreg
name|cr
decl_stmt|;
comment|/* If 'param' is already in form of a number, no need to preprocess.  */
if|if
condition|(
name|strchr
argument_list|(
name|paramP
argument_list|,
literal|'{'
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|param
return|;
comment|/* Verifying correct syntax of operand.  */
if|if
condition|(
name|strchr
argument_list|(
name|paramP
argument_list|,
literal|'}'
argument_list|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing matching brackets : `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|paramP
operator|++
operator|!=
literal|'{'
condition|)
empty_stmt|;
name|new_param
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|MAX_INST_LEN
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|allocated
operator|=
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|new_param
argument_list|,
name|param
argument_list|,
name|paramP
operator|-
name|param
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|paramP
operator|!=
literal|'}'
condition|)
block|{
name|regP
operator|=
name|paramP
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reg_name
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_name
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|paramP
argument_list|)
condition|)
name|paramP
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|reg_name
argument_list|,
name|regP
argument_list|,
name|paramP
operator|-
name|regP
argument_list|)
expr_stmt|;
comment|/* Coprocessor register c<N>.  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|COP_REG_INS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cr
operator|=
name|get_copregister
argument_list|(
name|reg_name
argument_list|)
operator|)
operator|==
name|nullcopregister
operator|)
operator|||
operator|(
name|crx_copregtab
index|[
name|cr
operator|-
name|MAX_REG
index|]
operator|.
name|type
operator|!=
name|CRX_C_REGTYPE
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in cop-register list"
argument_list|)
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
name|mask_reg
argument_list|(
name|getreg_image
argument_list|(
name|cr
operator|-
name|c0
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* Coprocessor Special register cs<N>.  */
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|COPS_REG_INS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cr
operator|=
name|get_copregister
argument_list|(
name|reg_name
argument_list|)
operator|)
operator|==
name|nullcopregister
operator|)
operator|||
operator|(
name|crx_copregtab
index|[
name|cr
operator|-
name|MAX_REG
index|]
operator|.
name|type
operator|!=
name|CRX_CS_REGTYPE
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in cop-special-register list"
argument_list|)
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
name|mask_reg
argument_list|(
name|getreg_image
argument_list|(
name|cr
operator|-
name|cs0
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* User register u<N>.  */
elseif|else
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|USER_REG
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|reg_name
argument_list|,
literal|"uhi"
argument_list|)
condition|)
block|{
name|hi_found
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_inst
goto|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|reg_name
argument_list|,
literal|"ulo"
argument_list|)
condition|)
block|{
name|lo_found
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_inst
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|r
operator|=
name|get_register
argument_list|(
name|reg_name
argument_list|)
operator|)
operator|==
name|nullregister
operator|)
operator|||
operator|(
name|crx_regtab
index|[
name|r
index|]
operator|.
name|type
operator|!=
name|CRX_U_REGTYPE
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in user register list"
argument_list|)
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
name|mask_reg
argument_list|(
name|getreg_image
argument_list|(
name|r
operator|-
name|u0
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* General purpose register r<N>.  */
else|else
block|{
if|if
condition|(
name|streq
argument_list|(
name|reg_name
argument_list|,
literal|"hi"
argument_list|)
condition|)
block|{
name|hi_found
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_inst
goto|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|reg_name
argument_list|,
literal|"lo"
argument_list|)
condition|)
block|{
name|lo_found
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_inst
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|r
operator|=
name|get_register
argument_list|(
name|reg_name
argument_list|)
operator|)
operator|==
name|nullregister
operator|)
operator|||
operator|(
name|crx_regtab
index|[
name|r
index|]
operator|.
name|type
operator|!=
name|CRX_R_REGTYPE
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal register `%s' in register list"
argument_list|)
argument_list|,
name|reg_name
argument_list|)
expr_stmt|;
name|mask_reg
argument_list|(
name|getreg_image
argument_list|(
name|r
operator|-
name|r0
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|reg_counter
operator|>
name|MAX_REGS_IN_MASK16
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Maximum %d bits may be set in `mask16' operand"
argument_list|)
argument_list|,
name|MAX_REGS_IN_MASK16
argument_list|)
expr_stmt|;
name|next_inst
label|:
while|while
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|paramP
argument_list|)
operator|&&
operator|*
name|paramP
operator|!=
literal|'}'
condition|)
name|paramP
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|paramP
operator|!=
literal|'\0'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"rest of line ignored; first ignored character is `%c'"
argument_list|)
argument_list|,
operator|*
name|paramP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hi_found
operator|+
name|lo_found
condition|)
block|{
case|case
literal|0
case|:
comment|/* At least one register should be specified.  */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal `mask16' operand, operation is undefined - `%s'"
argument_list|)
argument_list|,
name|ins_parse
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* HI can't be specified without LO (and vise-versa).  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"HI/LO registers should be specified together"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* HI/LO registers mustn't be masked with additional registers.  */
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"HI/LO registers should be specified without additional registers"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
name|sprintf
argument_list|(
name|maskstring
argument_list|,
literal|"$0x%x"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_param
argument_list|,
name|maskstring
argument_list|)
expr_stmt|;
return|return
name|new_param
return|;
block|}
end_function

begin_comment
comment|/* Print the instruction.    Handle also cases where the instruction is relaxable/relocatable.  */
end_comment

begin_function
name|void
name|print_insn
parameter_list|(
name|ins
modifier|*
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|insn_size
decl_stmt|;
name|char
modifier|*
name|this_frag
decl_stmt|;
name|unsigned
name|short
name|words
index|[
literal|4
index|]
decl_stmt|;
name|int
name|addr_mod
decl_stmt|;
comment|/* Arrange the insn encodings in a WORD size array.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|words
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|output_opcode
index|[
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|words
index|[
name|j
operator|++
index|]
operator|=
name|output_opcode
index|[
name|i
index|]
operator|&
literal|0xFFFF
expr_stmt|;
block|}
comment|/* Handle relaxtion.  */
if|if
condition|(
operator|(
name|instruction
operator|->
name|flags
operator|&
name|RELAXABLE
operator|)
operator|&&
name|relocatable
condition|)
block|{
name|int
name|relax_subtype
decl_stmt|;
comment|/* Write the maximal instruction size supported.  */
name|insn_size
operator|=
name|INSN_MAX_SIZE
expr_stmt|;
comment|/* bCC  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
condition|)
name|relax_subtype
operator|=
literal|0
expr_stmt|;
comment|/* bal  */
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|DCR_BRANCH_INS
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
condition|)
name|relax_subtype
operator|=
literal|3
expr_stmt|;
comment|/* cmpbr/bcop  */
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|CMPBR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|COP_BRANCH_INS
argument_list|)
condition|)
name|relax_subtype
operator|=
literal|5
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|this_frag
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|insn_size
operator|*
literal|2
argument_list|,
literal|4
argument_list|,
name|relax_subtype
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn_size
operator|=
name|instruction
operator|->
name|size
expr_stmt|;
name|this_frag
operator|=
name|frag_more
argument_list|(
name|insn_size
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Handle relocation.  */
if|if
condition|(
operator|(
name|relocatable
operator|)
operator|&&
operator|(
name|insn
operator|->
name|rtype
operator|!=
name|BFD_RELOC_NONE
operator|)
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|int
name|size
decl_stmt|;
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|this_frag
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|insn
operator|->
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|insn
operator|->
name|rtype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Verify a 2-byte code alignment.  */
name|addr_mod
operator|=
name|frag_now_fix
argument_list|()
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|frag_now
operator|->
name|has_code
operator|&&
name|frag_now
operator|->
name|insn_addr
operator|!=
name|addr_mod
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction address is not a multiple of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|insn_addr
operator|=
name|addr_mod
expr_stmt|;
name|frag_now
operator|->
name|has_code
operator|=
literal|1
expr_stmt|;
comment|/* Write the instruction encoding to frag.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_size
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|this_frag
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this_frag
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  OP points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
name|ins
name|crx_ins
decl_stmt|;
name|char
modifier|*
name|param
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Reset global variables for a new instruction.  */
name|reset_vars
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Strip the mnemonic.  */
for|for
control|(
name|param
operator|=
name|op
init|;
operator|*
name|param
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|;
name|param
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|param
expr_stmt|;
operator|*
name|param
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the instruction.  */
name|instruction
operator|=
operator|(
specifier|const
name|inst
operator|*
operator|)
name|hash_find
argument_list|(
name|crx_inst_hash
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tie dwarf2 debug info to the address at the start of the insn.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse the instruction's operands.  */
name|parse_insn
argument_list|(
operator|&
name|crx_ins
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Assemble the instruction - return upon failure.  */
if|if
condition|(
name|assemble_insn
argument_list|(
name|op
argument_list|,
operator|&
name|crx_ins
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Print the instruction.  */
name|print_insn
argument_list|(
operator|&
name|crx_ins
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

