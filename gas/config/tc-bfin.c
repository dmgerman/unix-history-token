begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-bfin.c -- Assembler for the ADI Blackfin.    Copyright 2005, 2006    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"bfin-defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/bfin.h"
end_include

begin_function_decl
specifier|extern
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|yy_buffer_state
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|yy_buffer_state
modifier|*
name|YY_BUFFER_STATE
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|YY_BUFFER_STATE
name|yy_scan_string
parameter_list|(
specifier|const
name|char
modifier|*
name|yy_str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|yy_delete_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|parse_state
name|parse
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|bfin_s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|md_chars_to_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables. */
end_comment

begin_decl_stmt
name|struct
name|bfin_insn
modifier|*
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_insn_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|mempool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|errorf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to set in the elf header */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|0
end_define

begin_decl_stmt
specifier|static
name|flagword
name|bfin_flags
init|=
name|DEFAULT_FLAGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bfin_pic_flag
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Registers list.  */
end_comment

begin_struct
struct|struct
name|bfin_reg_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfin_reg_entry
name|bfin_reg_info
index|[]
init|=
block|{
block|{
literal|"R0.L"
block|,
name|REG_RL0
block|}
block|,
block|{
literal|"R1.L"
block|,
name|REG_RL1
block|}
block|,
block|{
literal|"R2.L"
block|,
name|REG_RL2
block|}
block|,
block|{
literal|"R3.L"
block|,
name|REG_RL3
block|}
block|,
block|{
literal|"R4.L"
block|,
name|REG_RL4
block|}
block|,
block|{
literal|"R5.L"
block|,
name|REG_RL5
block|}
block|,
block|{
literal|"R6.L"
block|,
name|REG_RL6
block|}
block|,
block|{
literal|"R7.L"
block|,
name|REG_RL7
block|}
block|,
block|{
literal|"R0.H"
block|,
name|REG_RH0
block|}
block|,
block|{
literal|"R1.H"
block|,
name|REG_RH1
block|}
block|,
block|{
literal|"R2.H"
block|,
name|REG_RH2
block|}
block|,
block|{
literal|"R3.H"
block|,
name|REG_RH3
block|}
block|,
block|{
literal|"R4.H"
block|,
name|REG_RH4
block|}
block|,
block|{
literal|"R5.H"
block|,
name|REG_RH5
block|}
block|,
block|{
literal|"R6.H"
block|,
name|REG_RH6
block|}
block|,
block|{
literal|"R7.H"
block|,
name|REG_RH7
block|}
block|,
block|{
literal|"R0"
block|,
name|REG_R0
block|}
block|,
block|{
literal|"R1"
block|,
name|REG_R1
block|}
block|,
block|{
literal|"R2"
block|,
name|REG_R2
block|}
block|,
block|{
literal|"R3"
block|,
name|REG_R3
block|}
block|,
block|{
literal|"R4"
block|,
name|REG_R4
block|}
block|,
block|{
literal|"R5"
block|,
name|REG_R5
block|}
block|,
block|{
literal|"R6"
block|,
name|REG_R6
block|}
block|,
block|{
literal|"R7"
block|,
name|REG_R7
block|}
block|,
block|{
literal|"P0"
block|,
name|REG_P0
block|}
block|,
block|{
literal|"P0.H"
block|,
name|REG_P0
block|}
block|,
block|{
literal|"P0.L"
block|,
name|REG_P0
block|}
block|,
block|{
literal|"P1"
block|,
name|REG_P1
block|}
block|,
block|{
literal|"P1.H"
block|,
name|REG_P1
block|}
block|,
block|{
literal|"P1.L"
block|,
name|REG_P1
block|}
block|,
block|{
literal|"P2"
block|,
name|REG_P2
block|}
block|,
block|{
literal|"P2.H"
block|,
name|REG_P2
block|}
block|,
block|{
literal|"P2.L"
block|,
name|REG_P2
block|}
block|,
block|{
literal|"P3"
block|,
name|REG_P3
block|}
block|,
block|{
literal|"P3.H"
block|,
name|REG_P3
block|}
block|,
block|{
literal|"P3.L"
block|,
name|REG_P3
block|}
block|,
block|{
literal|"P4"
block|,
name|REG_P4
block|}
block|,
block|{
literal|"P4.H"
block|,
name|REG_P4
block|}
block|,
block|{
literal|"P4.L"
block|,
name|REG_P4
block|}
block|,
block|{
literal|"P5"
block|,
name|REG_P5
block|}
block|,
block|{
literal|"P5.H"
block|,
name|REG_P5
block|}
block|,
block|{
literal|"P5.L"
block|,
name|REG_P5
block|}
block|,
block|{
literal|"SP"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"SP.L"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"SP.H"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"FP"
block|,
name|REG_FP
block|}
block|,
block|{
literal|"FP.L"
block|,
name|REG_FP
block|}
block|,
block|{
literal|"FP.H"
block|,
name|REG_FP
block|}
block|,
block|{
literal|"A0x"
block|,
name|REG_A0x
block|}
block|,
block|{
literal|"A1x"
block|,
name|REG_A1x
block|}
block|,
block|{
literal|"A0w"
block|,
name|REG_A0w
block|}
block|,
block|{
literal|"A1w"
block|,
name|REG_A1w
block|}
block|,
block|{
literal|"A0.x"
block|,
name|REG_A0x
block|}
block|,
block|{
literal|"A1.x"
block|,
name|REG_A1x
block|}
block|,
block|{
literal|"A0.w"
block|,
name|REG_A0w
block|}
block|,
block|{
literal|"A1.w"
block|,
name|REG_A1w
block|}
block|,
block|{
literal|"A0"
block|,
name|REG_A0
block|}
block|,
block|{
literal|"A0.L"
block|,
name|REG_A0
block|}
block|,
block|{
literal|"A0.H"
block|,
name|REG_A0
block|}
block|,
block|{
literal|"A1"
block|,
name|REG_A1
block|}
block|,
block|{
literal|"A1.L"
block|,
name|REG_A1
block|}
block|,
block|{
literal|"A1.H"
block|,
name|REG_A1
block|}
block|,
block|{
literal|"I0"
block|,
name|REG_I0
block|}
block|,
block|{
literal|"I0.L"
block|,
name|REG_I0
block|}
block|,
block|{
literal|"I0.H"
block|,
name|REG_I0
block|}
block|,
block|{
literal|"I1"
block|,
name|REG_I1
block|}
block|,
block|{
literal|"I1.L"
block|,
name|REG_I1
block|}
block|,
block|{
literal|"I1.H"
block|,
name|REG_I1
block|}
block|,
block|{
literal|"I2"
block|,
name|REG_I2
block|}
block|,
block|{
literal|"I2.L"
block|,
name|REG_I2
block|}
block|,
block|{
literal|"I2.H"
block|,
name|REG_I2
block|}
block|,
block|{
literal|"I3"
block|,
name|REG_I3
block|}
block|,
block|{
literal|"I3.L"
block|,
name|REG_I3
block|}
block|,
block|{
literal|"I3.H"
block|,
name|REG_I3
block|}
block|,
block|{
literal|"M0"
block|,
name|REG_M0
block|}
block|,
block|{
literal|"M0.H"
block|,
name|REG_M0
block|}
block|,
block|{
literal|"M0.L"
block|,
name|REG_M0
block|}
block|,
block|{
literal|"M1"
block|,
name|REG_M1
block|}
block|,
block|{
literal|"M1.H"
block|,
name|REG_M1
block|}
block|,
block|{
literal|"M1.L"
block|,
name|REG_M1
block|}
block|,
block|{
literal|"M2"
block|,
name|REG_M2
block|}
block|,
block|{
literal|"M2.H"
block|,
name|REG_M2
block|}
block|,
block|{
literal|"M2.L"
block|,
name|REG_M2
block|}
block|,
block|{
literal|"M3"
block|,
name|REG_M3
block|}
block|,
block|{
literal|"M3.H"
block|,
name|REG_M3
block|}
block|,
block|{
literal|"M3.L"
block|,
name|REG_M3
block|}
block|,
block|{
literal|"B0"
block|,
name|REG_B0
block|}
block|,
block|{
literal|"B0.H"
block|,
name|REG_B0
block|}
block|,
block|{
literal|"B0.L"
block|,
name|REG_B0
block|}
block|,
block|{
literal|"B1"
block|,
name|REG_B1
block|}
block|,
block|{
literal|"B1.H"
block|,
name|REG_B1
block|}
block|,
block|{
literal|"B1.L"
block|,
name|REG_B1
block|}
block|,
block|{
literal|"B2"
block|,
name|REG_B2
block|}
block|,
block|{
literal|"B2.H"
block|,
name|REG_B2
block|}
block|,
block|{
literal|"B2.L"
block|,
name|REG_B2
block|}
block|,
block|{
literal|"B3"
block|,
name|REG_B3
block|}
block|,
block|{
literal|"B3.H"
block|,
name|REG_B3
block|}
block|,
block|{
literal|"B3.L"
block|,
name|REG_B3
block|}
block|,
block|{
literal|"L0"
block|,
name|REG_L0
block|}
block|,
block|{
literal|"L0.H"
block|,
name|REG_L0
block|}
block|,
block|{
literal|"L0.L"
block|,
name|REG_L0
block|}
block|,
block|{
literal|"L1"
block|,
name|REG_L1
block|}
block|,
block|{
literal|"L1.H"
block|,
name|REG_L1
block|}
block|,
block|{
literal|"L1.L"
block|,
name|REG_L1
block|}
block|,
block|{
literal|"L2"
block|,
name|REG_L2
block|}
block|,
block|{
literal|"L2.H"
block|,
name|REG_L2
block|}
block|,
block|{
literal|"L2.L"
block|,
name|REG_L2
block|}
block|,
block|{
literal|"L3"
block|,
name|REG_L3
block|}
block|,
block|{
literal|"L3.H"
block|,
name|REG_L3
block|}
block|,
block|{
literal|"L3.L"
block|,
name|REG_L3
block|}
block|,
block|{
literal|"AZ"
block|,
name|S_AZ
block|}
block|,
block|{
literal|"AN"
block|,
name|S_AN
block|}
block|,
block|{
literal|"AC0"
block|,
name|S_AC0
block|}
block|,
block|{
literal|"AC1"
block|,
name|S_AC1
block|}
block|,
block|{
literal|"AV0"
block|,
name|S_AV0
block|}
block|,
block|{
literal|"AV0S"
block|,
name|S_AV0S
block|}
block|,
block|{
literal|"AV1"
block|,
name|S_AV1
block|}
block|,
block|{
literal|"AV1S"
block|,
name|S_AV1S
block|}
block|,
block|{
literal|"AQ"
block|,
name|S_AQ
block|}
block|,
block|{
literal|"V"
block|,
name|S_V
block|}
block|,
block|{
literal|"VS"
block|,
name|S_VS
block|}
block|,
block|{
literal|"sftreset"
block|,
name|REG_sftreset
block|}
block|,
block|{
literal|"omode"
block|,
name|REG_omode
block|}
block|,
block|{
literal|"excause"
block|,
name|REG_excause
block|}
block|,
block|{
literal|"emucause"
block|,
name|REG_emucause
block|}
block|,
block|{
literal|"idle_req"
block|,
name|REG_idle_req
block|}
block|,
block|{
literal|"hwerrcause"
block|,
name|REG_hwerrcause
block|}
block|,
block|{
literal|"CC"
block|,
name|REG_CC
block|}
block|,
block|{
literal|"LC0"
block|,
name|REG_LC0
block|}
block|,
block|{
literal|"LC1"
block|,
name|REG_LC1
block|}
block|,
block|{
literal|"ASTAT"
block|,
name|REG_ASTAT
block|}
block|,
block|{
literal|"RETS"
block|,
name|REG_RETS
block|}
block|,
block|{
literal|"LT0"
block|,
name|REG_LT0
block|}
block|,
block|{
literal|"LB0"
block|,
name|REG_LB0
block|}
block|,
block|{
literal|"LT1"
block|,
name|REG_LT1
block|}
block|,
block|{
literal|"LB1"
block|,
name|REG_LB1
block|}
block|,
block|{
literal|"CYCLES"
block|,
name|REG_CYCLES
block|}
block|,
block|{
literal|"CYCLES2"
block|,
name|REG_CYCLES2
block|}
block|,
block|{
literal|"USP"
block|,
name|REG_USP
block|}
block|,
block|{
literal|"SEQSTAT"
block|,
name|REG_SEQSTAT
block|}
block|,
block|{
literal|"SYSCFG"
block|,
name|REG_SYSCFG
block|}
block|,
block|{
literal|"RETI"
block|,
name|REG_RETI
block|}
block|,
block|{
literal|"RETX"
block|,
name|REG_RETX
block|}
block|,
block|{
literal|"RETN"
block|,
name|REG_RETN
block|}
block|,
block|{
literal|"RETE"
block|,
name|REG_RETE
block|}
block|,
block|{
literal|"EMUDAT"
block|,
name|REG_EMUDAT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Blackfin specific function to handle FD-PIC pointer initializations.  */
end_comment

begin_function
specifier|static
name|void
name|bfin_pic_ptr
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|bfd_reloc_code_real_type
name|reloc_type
init|=
name|BFD_RELOC_BFIN_FUNCDESC
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"funcdesc("
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|9
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|')'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing ')'"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"missing funcdesc in picptr"
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream. */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfin_s_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"byte2"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"byte4"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"picptr"
block|,
name|bfin_pic_ptr
block|,
literal|4
block|}
block|,
block|{
literal|"code"
block|,
name|obj_elf_section
block|,
literal|0
block|}
block|,
block|{
literal|"db"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"dd"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"dw"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"p"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"pdata"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"var"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|bfin_s_bss
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that are used to denote comments and line separators. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to separate the mantissa from the    exponent in floating point numbers. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that mean this number is a floating point constant.    As in 0f12.456 or  0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define bfin-specific command-line options (there are none). */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_FDPIC
value|(OPTION_MD_BASE)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mfdpic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FDPIC
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|OPTION_FDPIC
case|:
name|bfin_flags
operator||=
name|EF_BFIN_FDPIC
expr_stmt|;
name|bfin_pic_flag
operator|=
literal|"-mfdpic"
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" BFIN specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform machine-specific initializations.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* Set the ELF flags if desired. */
if|if
condition|(
name|bfin_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|bfin_flags
argument_list|)
expr_stmt|;
comment|/* Set the default machine type. */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_bfin
argument_list|,
literal|0
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Could not set architecture and machine."
argument_list|)
expr_stmt|;
comment|/* Ensure that lines can begin with '(', for multiple      register stack pops. */
name|lex_type
index|[
literal|'('
index|]
operator|=
name|LEX_BEGIN_NAME
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errorf
operator|=
name|stderr
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|mempool
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|int
name|debug_codeselection
decl_stmt|;
name|debug_codeselection
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|last_insn_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform the main parsing, and assembly of the input here.  Also,    call the required routines for alignment and fixups here.    This is called for every line that contains real assembly code.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|toP
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|current_inputline
decl_stmt|;
name|int
name|size
decl_stmt|,
name|insn_size
decl_stmt|;
name|struct
name|bfin_insn
modifier|*
name|tmp_insn
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|static
name|size_t
name|buffer_len
init|=
literal|0
decl_stmt|;
name|parse_state
name|state
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|2
operator|>
name|buffer_len
condition|)
block|{
if|if
condition|(
name|buffer_len
operator|>
literal|0
condition|)
name|free
argument_list|(
name|current_inputline
argument_list|)
expr_stmt|;
name|buffer_len
operator|=
name|len
operator|+
literal|40
expr_stmt|;
name|current_inputline
operator|=
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|current_inputline
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|current_inputline
index|[
name|len
index|]
operator|=
literal|';'
expr_stmt|;
name|current_inputline
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
name|parse
argument_list|(
name|current_inputline
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NO_INSN_GENERATED
condition|)
return|return;
for|for
control|(
name|insn_size
operator|=
literal|0
operator|,
name|tmp_insn
operator|=
name|insn
init|;
name|tmp_insn
condition|;
name|tmp_insn
operator|=
name|tmp_insn
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|tmp_insn
operator|->
name|reloc
operator|||
operator|!
name|tmp_insn
operator|->
name|exp
operator|->
name|symbol
condition|)
name|insn_size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|insn_size
condition|)
name|toP
operator|=
name|frag_more
argument_list|(
name|insn_size
argument_list|)
expr_stmt|;
name|last_insn_size
operator|=
name|insn_size
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"INS:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|reloc
operator|&&
name|insn
operator|->
name|exp
operator|->
name|symbol
condition|)
block|{
name|char
modifier|*
name|prev_toP
init|=
name|toP
operator|-
literal|2
decl_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_BFIN_24_PCREL_JUMP_L
case|:
case|case
name|BFD_RELOC_24_PCREL
case|:
case|case
name|BFD_RELOC_BFIN_16_LOW
case|:
case|case
name|BFD_RELOC_BFIN_16_HIGH
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Following if condition checks for the arithmetic relocations. 	     If the case then it doesn't required to generate the code. 	     It has been assumed that, their ID will be contiguous.  */
if|if
condition|(
operator|(
name|BFD_ARELOC_BFIN_PUSH
operator|<=
name|insn
operator|->
name|reloc
operator|&&
name|BFD_ARELOC_BFIN_COMP
operator|>=
name|insn
operator|->
name|reloc
operator|)
operator|||
name|insn
operator|->
name|reloc
operator|==
name|BFD_RELOC_BFIN_16_IMM
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|->
name|reloc
operator|==
name|BFD_ARELOC_BFIN_CONST
operator|||
name|insn
operator|->
name|reloc
operator|==
name|BFD_ARELOC_BFIN_PUSH
condition|)
name|size
operator|=
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
operator|(
name|prev_toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
name|size
argument_list|,
name|insn
operator|->
name|exp
operator|->
name|symbol
argument_list|,
name|insn
operator|->
name|exp
operator|->
name|value
argument_list|,
name|insn
operator|->
name|pcrel
argument_list|,
name|insn
operator|->
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|insn
operator|->
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|" reloc :"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x%02x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|insn
operator|->
name|value
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|insn
operator|->
name|value
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|insn
operator|->
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|insn_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Parse one line of instructions, and generate opcode for it.    To parse the line, YACC and LEX are used, because the instruction set    syntax doesn't confirm to the AT&T assembly syntax.    To call a YACC& LEX generated parser, we must provide the input via    a FILE stream, otherwise stdin is used by default.  Below the input    to the function will be put into a temporary file, then the generated    parser uses the temporary file for parsing.  */
end_comment

begin_function
specifier|static
name|parse_state
name|parse
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|parse_state
name|state
decl_stmt|;
name|YY_BUFFER_STATE
name|buffstate
decl_stmt|;
name|buffstate
operator|=
name|yy_scan_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* our lex requires setting the start state to keyword      every line as the first word may be a keyword.      Fixes a bug where we could not have keywords as labels.  */
name|set_start_state
argument_list|()
expr_stmt|;
comment|/* Call yyparse here.  */
name|state
operator|=
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SEMANTIC_ERROR
condition|)
block|{
name|as_bad
argument_list|(
literal|"Parse failed."
argument_list|)
expr_stmt|;
name|insn
operator|=
literal|0
expr_stmt|;
block|}
name|yy_delete_buffer
argument_list|(
name|buffstate
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/* We need to handle various expressions properly.    Such as, [SP--] = 34, concerned by md_assemble().  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'['
condition|)
block|{
name|as_tsktsk
argument_list|(
literal|"We found a '['!"
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle undefined symbols. */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|symbolS
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert from target byte order to host byte order.  */
end_comment

begin_function
specifier|static
name|int
name|md_chars_to_number
parameter_list|(
name|char
modifier|*
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
init|;
name|n
operator|--
condition|;
control|)
block|{
name|retval
operator|<<=
literal|8
expr_stmt|;
name|retval
operator||=
name|val
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valueP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|long
name|value
init|=
operator|*
name|valueP
decl_stmt|;
name|long
name|newval
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_BFIN_GOT
case|:
case|case
name|BFD_RELOC_BFIN_GOT17M4
case|:
case|case
name|BFD_RELOC_BFIN_FUNCDESC_GOT17M4
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|where
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|newval
operator||=
literal|0x0
operator|&
literal|0x7f
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|newval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_10_PCREL
case|:
if|if
condition|(
operator|!
name|value
condition|)
break|break;
if|if
condition|(
name|value
operator|<
operator|-
literal|1024
operator|||
name|value
operator|>
literal|1022
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far BFD_RELOC_BFIN_10"
argument_list|)
expr_stmt|;
comment|/* 11 bit offset even numbered, so we remove right bit.  */
name|value
operator|=
name|value
operator|>>
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|where
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|&
literal|0x03ff
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|newval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_12_PCREL_JUMP
case|:
case|case
name|BFD_RELOC_BFIN_12_PCREL_JUMP_S
case|:
case|case
name|BFD_RELOC_12_PCREL
case|:
if|if
condition|(
operator|!
name|value
condition|)
break|break;
if|if
condition|(
name|value
operator|<
operator|-
literal|4096
operator|||
name|value
operator|>
literal|4094
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far BFD_RELOC_BFIN_12"
argument_list|)
expr_stmt|;
comment|/* 13 bit offset even numbered, so we remove right bit.  */
name|value
operator|=
name|value
operator|>>
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|where
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|newval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_16_LOW
case|:
case|case
name|BFD_RELOC_BFIN_16_HIGH
case|:
name|fixP
operator|->
name|fx_done
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_24_PCREL_JUMP_L
case|:
case|case
name|BFD_RELOC_BFIN_24_PCREL_CALL_X
case|:
case|case
name|BFD_RELOC_24_PCREL
case|:
if|if
condition|(
operator|!
name|value
condition|)
break|break;
if|if
condition|(
name|value
operator|<
operator|-
literal|16777216
operator|||
name|value
operator|>
literal|16777214
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far BFD_RELOC_BFIN_24"
argument_list|)
expr_stmt|;
comment|/* 25 bit offset even numbered, so we remove right bit.  */
name|value
operator|=
name|value
operator|>>
literal|1
expr_stmt|;
name|value
operator|++
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
operator|-
literal|2
argument_list|,
name|value
operator|>>
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
operator|+
literal|1
argument_list|,
name|value
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_5_PCREL
case|:
comment|/* LSETUP (a, b) : "a" */
if|if
condition|(
operator|!
name|value
condition|)
break|break;
if|if
condition|(
name|value
operator|<
literal|4
operator|||
name|value
operator|>
literal|30
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far BFD_RELOC_BFIN_5"
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|value
operator|&
literal|0xf
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|newval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_11_PCREL
case|:
comment|/* LSETUP (a, b) : "b" */
if|if
condition|(
operator|!
name|value
condition|)
break|break;
name|value
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|4
operator|||
name|value
operator|>
literal|2046
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"pcrel too far BFD_RELOC_BFIN_11_PCREL"
argument_list|)
expr_stmt|;
comment|/* 11 bit unsigned even, so we remove right bit.  */
name|value
operator|=
name|value
operator|>>
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|where
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|&
literal|0x03ff
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|newval
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|0x80
operator|||
name|value
operator|>=
literal|0x7f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"rel too far BFD_RELOC_8"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_16_IMM
case|:
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|0x8000
operator|||
name|value
operator|>=
literal|0x7fff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"rel too far BFD_RELOC_8"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_PLTPC
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_FUNCDESC
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|BFD_ARELOC_BFIN_PUSH
operator|>
name|fixP
operator|->
name|fx_r_type
operator|)
operator|||
operator|(
name|BFD_ARELOC_BFIN_COMP
operator|<
name|fixP
operator|->
name|fx_r_type
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Relocation %d not handled in gas."
literal|" Contact support.\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|fixP
operator|->
name|fx_done
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|boundary
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|boundary
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|boundary
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point    constant of type type, and store the appropriate bytes in    *litP.  The number of LITTLENUMS emitted is stored in *sizeP.    An error message is returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the littleendianness of the processor.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
comment|/* xgettext:c-format.  */
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/*  The location from which a PC relative jump should be calculated,     given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section).          Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Return true if the fix can be handled by GAS, false if it must    be passed through to the linker.  */
end_comment

begin_function
name|bfd_boolean
name|bfin_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* Adjust_reloc_syms doesn't know about the GOT.  */
case|case
name|BFD_RELOC_BFIN_GOT
case|:
case|case
name|BFD_RELOC_BFIN_GOT17M4
case|:
case|case
name|BFD_RELOC_BFIN_FUNCDESC_GOT17M4
case|:
case|case
name|BFD_RELOC_BFIN_PLTPC
case|:
comment|/* We need the symbol name for the VTABLE entries.  */
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the LOOP_BEGIN and LOOP_END statements.    Parse the Loop_Begin/Loop_End and create a label.  */
end_comment

begin_function
name|void
name|bfin_start_line_hook
parameter_list|()
block|{
name|bfd_boolean
name|maybe_begin
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|maybe_end
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|label_name
decl_stmt|;
name|symbolS
modifier|*
name|line_label
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|cr_num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'\n'
condition|)
name|cr_num
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
comment|/* Look for Loop_Begin or Loop_End statements.  */
if|if
condition|(
operator|*
name|c
operator|!=
literal|'L'
operator|&&
operator|*
name|c
operator|!=
literal|'l'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'O'
operator|&&
operator|*
name|c
operator|!=
literal|'o'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'O'
operator|&&
operator|*
name|c
operator|!=
literal|'o'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'P'
operator|&&
operator|*
name|c
operator|!=
literal|'p'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'_'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'E'
operator|||
operator|*
name|c
operator|==
literal|'e'
condition|)
name|maybe_end
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'B'
operator|||
operator|*
name|c
operator|==
literal|'b'
condition|)
name|maybe_begin
operator|=
name|TRUE
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|maybe_end
condition|)
block|{
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'N'
operator|&&
operator|*
name|c
operator|!=
literal|'n'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'D'
operator|&&
operator|*
name|c
operator|!=
literal|'d'
condition|)
return|return;
block|}
if|if
condition|(
name|maybe_begin
condition|)
block|{
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'E'
operator|&&
operator|*
name|c
operator|!=
literal|'e'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'G'
operator|&&
operator|*
name|c
operator|!=
literal|'g'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'I'
operator|&&
operator|*
name|c
operator|!=
literal|'i'
condition|)
return|return;
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'N'
operator|&&
operator|*
name|c
operator|!=
literal|'n'
condition|)
return|return;
block|}
name|c
operator|++
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
name|c1
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|ISALPHA
argument_list|(
operator|*
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
operator|*
name|c
argument_list|)
operator|||
operator|*
name|c
operator|==
literal|'_'
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
while|while
condition|(
name|cr_num
operator|--
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|maybe_end
condition|)
block|{
name|label_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|c
operator|-
name|c1
operator|)
operator|+
name|strlen
argument_list|(
literal|"__END"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|label_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strncat
argument_list|(
name|label_name
argument_list|,
name|c1
argument_list|,
name|c
operator|-
name|c1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|label_name
argument_list|,
literal|"__END"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* maybe_begin.  */
block|{
name|label_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|c
operator|-
name|c1
operator|)
operator|+
name|strlen
argument_list|(
literal|"__BEGIN"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|label_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strncat
argument_list|(
name|label_name
argument_list|,
name|c1
argument_list|,
name|c
operator|-
name|c1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|label_name
argument_list|,
literal|"__BEGIN"
argument_list|)
expr_stmt|;
block|}
name|line_label
operator|=
name|colon
argument_list|(
name|label_name
argument_list|)
expr_stmt|;
comment|/* Loop_End follows the last instruction in the loop.      Adjust label address.  */
if|if
condition|(
name|maybe_end
condition|)
name|line_label
operator|->
name|sy_value
operator|.
name|X_add_number
operator|-=
name|last_insn_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special extra functions that help bfin-parse.y perform its job.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
name|struct
name|obstack
name|mempool
decl_stmt|;
end_decl_stmt

begin_function
name|INSTR_T
name|conscode
parameter_list|(
name|INSTR_T
name|head
parameter_list|,
name|INSTR_T
name|tail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|head
condition|)
return|return
name|tail
return|;
name|head
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_function
name|INSTR_T
name|conctcode
parameter_list|(
name|INSTR_T
name|head
parameter_list|,
name|INSTR_T
name|tail
parameter_list|)
block|{
name|INSTR_T
name|temp
init|=
operator|(
name|head
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
name|tail
return|;
while|while
condition|(
name|temp
operator|->
name|next
condition|)
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_function
name|INSTR_T
name|note_reloc
parameter_list|(
name|INSTR_T
name|code
parameter_list|,
name|Expr_Node
modifier|*
name|symbol
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|pcrel
parameter_list|)
block|{
comment|/* Assert that the symbol is not an operator.  */
name|assert
argument_list|(
name|symbol
operator|->
name|type
operator|==
name|Expr_Node_Reloc
argument_list|)
expr_stmt|;
return|return
name|note_reloc1
argument_list|(
name|code
argument_list|,
name|symbol
operator|->
name|value
operator|.
name|s_value
argument_list|,
name|reloc
argument_list|,
name|pcrel
argument_list|)
return|;
block|}
end_function

begin_function
name|INSTR_T
name|note_reloc1
parameter_list|(
name|INSTR_T
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|pcrel
parameter_list|)
block|{
name|code
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|code
operator|->
name|exp
operator|=
name|mkexpr
argument_list|(
literal|0
argument_list|,
name|symbol_find_or_make
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|->
name|pcrel
operator|=
name|pcrel
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
name|INSTR_T
name|note_reloc2
parameter_list|(
name|INSTR_T
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|,
name|int
name|reloc
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|pcrel
parameter_list|)
block|{
name|code
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|code
operator|->
name|exp
operator|=
name|mkexpr
argument_list|(
name|value
argument_list|,
name|symbol_find_or_make
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|->
name|pcrel
operator|=
name|pcrel
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
name|INSTR_T
name|gencode
parameter_list|(
name|unsigned
name|long
name|x
parameter_list|)
block|{
name|INSTR_T
name|cell
init|=
operator|(
name|INSTR_T
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|mempool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfin_insn
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|cell
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfin_insn
argument_list|)
argument_list|)
expr_stmt|;
name|cell
operator|->
name|value
operator|=
operator|(
name|x
operator|)
expr_stmt|;
return|return
name|cell
return|;
block|}
end_function

begin_decl_stmt
name|int
name|reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ninsns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count_insns
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|allocate
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|mempool
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function
name|Expr_Node
modifier|*
name|Expr_Node_Create
parameter_list|(
name|Expr_Node_Type
name|type
parameter_list|,
name|Expr_Node_Value
name|value
parameter_list|,
name|Expr_Node
modifier|*
name|Left_Child
parameter_list|,
name|Expr_Node
modifier|*
name|Right_Child
parameter_list|)
block|{
name|Expr_Node
modifier|*
name|node
init|=
operator|(
name|Expr_Node
operator|*
operator|)
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|Expr_Node
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|node
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|node
operator|->
name|Left_Child
operator|=
name|Left_Child
expr_stmt|;
name|node
operator|->
name|Right_Child
operator|=
name|Right_Child
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|con
init|=
literal|".__constant"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|op
init|=
literal|".__operator"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|INSTR_T
name|Expr_Node_Gen_Reloc_R
parameter_list|(
name|Expr_Node
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|INSTR_T
name|Expr_Node_Gen_Reloc
parameter_list|(
name|Expr_Node
modifier|*
name|head
parameter_list|,
name|int
name|parent_reloc
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|INSTR_T
name|Expr_Node_Gen_Reloc
parameter_list|(
name|Expr_Node
modifier|*
name|head
parameter_list|,
name|int
name|parent_reloc
parameter_list|)
block|{
comment|/* Top level reloction expression generator VDSP style.    If the relocation is just by itself, generate one item    else generate this convoluted expression.  */
name|INSTR_T
name|note
init|=
name|NULL_CODE
decl_stmt|;
name|INSTR_T
name|note1
init|=
name|NULL_CODE
decl_stmt|;
name|int
name|pcrel
init|=
literal|1
decl_stmt|;
comment|/* Is the parent reloc pcrelative? 		  This calculation here and HOWTO should match.  */
if|if
condition|(
name|parent_reloc
condition|)
block|{
comment|/*  If it's 32 bit quantity then 16bit code needs to be added.  */
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|type
operator|==
name|Expr_Node_Constant
condition|)
block|{
comment|/* If note1 is not null code, we have to generate a right              aligned value for the constant. Otherwise the reloc is              a part of the basic command and the yacc file              generates this.  */
name|value
operator|=
name|head
operator|->
name|value
operator|.
name|i_value
expr_stmt|;
block|}
switch|switch
condition|(
name|parent_reloc
condition|)
block|{
comment|/*  Some relocations will need to allocate extra words.  */
case|case
name|BFD_RELOC_BFIN_16_IMM
case|:
case|case
name|BFD_RELOC_BFIN_16_LOW
case|:
case|case
name|BFD_RELOC_BFIN_16_HIGH
case|:
name|note1
operator|=
name|conscode
argument_list|(
name|gencode
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_BFIN_PLTPC
case|:
name|note1
operator|=
name|conscode
argument_list|(
name|gencode
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_BFIN_GOT
case|:
case|case
name|BFD_RELOC_BFIN_GOT17M4
case|:
case|case
name|BFD_RELOC_BFIN_FUNCDESC_GOT17M4
case|:
name|note1
operator|=
name|conscode
argument_list|(
name|gencode
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24_PCREL
case|:
case|case
name|BFD_RELOC_BFIN_24_PCREL_JUMP_L
case|:
case|case
name|BFD_RELOC_BFIN_24_PCREL_CALL_X
case|:
comment|/* These offsets are even numbered pcrel.  */
name|note1
operator|=
name|conscode
argument_list|(
name|gencode
argument_list|(
name|value
operator|>>
literal|1
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|note1
operator|=
name|NULL_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|head
operator|->
name|type
operator|==
name|Expr_Node_Constant
condition|)
name|note
operator|=
name|note1
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|->
name|type
operator|==
name|Expr_Node_Reloc
condition|)
block|{
name|note
operator|=
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|head
operator|->
name|value
operator|.
name|s_value
argument_list|,
name|parent_reloc
argument_list|,
name|pcrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|note1
operator|!=
name|NULL_CODE
condition|)
name|note
operator|=
name|conscode
argument_list|(
name|note1
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|head
operator|->
name|type
operator|==
name|Expr_Node_Binop
operator|&&
operator|(
name|head
operator|->
name|value
operator|.
name|op_value
operator|==
name|Expr_Op_Type_Add
operator|||
name|head
operator|->
name|value
operator|.
name|op_value
operator|==
name|Expr_Op_Type_Sub
operator|)
operator|&&
name|head
operator|->
name|Left_Child
operator|->
name|type
operator|==
name|Expr_Node_Reloc
operator|&&
name|head
operator|->
name|Right_Child
operator|->
name|type
operator|==
name|Expr_Node_Constant
condition|)
block|{
name|int
name|val
init|=
name|head
operator|->
name|Right_Child
operator|->
name|value
operator|.
name|i_value
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|value
operator|.
name|op_value
operator|==
name|Expr_Op_Type_Sub
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
name|note
operator|=
name|conscode
argument_list|(
name|note_reloc2
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|head
operator|->
name|Left_Child
operator|->
name|value
operator|.
name|s_value
argument_list|,
name|parent_reloc
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|note1
operator|!=
name|NULL_CODE
condition|)
name|note
operator|=
name|conscode
argument_list|(
name|note1
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Call the recursive function.  */
name|note
operator|=
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|parent_reloc
argument_list|,
name|pcrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|note1
operator|!=
name|NULL_CODE
condition|)
name|note
operator|=
name|conscode
argument_list|(
name|note1
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|conctcode
argument_list|(
name|Expr_Node_Gen_Reloc_R
argument_list|(
name|head
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
return|return
name|note
return|;
block|}
end_function

begin_function
specifier|static
name|INSTR_T
name|Expr_Node_Gen_Reloc_R
parameter_list|(
name|Expr_Node
modifier|*
name|head
parameter_list|)
block|{
name|INSTR_T
name|note
init|=
literal|0
decl_stmt|;
name|INSTR_T
name|note1
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|head
operator|->
name|type
condition|)
block|{
case|case
name|Expr_Node_Constant
case|:
name|note
operator|=
name|conscode
argument_list|(
name|note_reloc2
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|con
argument_list|,
name|BFD_ARELOC_BFIN_CONST
argument_list|,
name|head
operator|->
name|value
operator|.
name|i_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Node_Reloc
case|:
name|note
operator|=
name|conscode
argument_list|(
name|note_reloc
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|head
argument_list|,
name|BFD_ARELOC_BFIN_PUSH
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Node_Binop
case|:
name|note1
operator|=
name|conctcode
argument_list|(
name|Expr_Node_Gen_Reloc_R
argument_list|(
name|head
operator|->
name|Left_Child
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc_R
argument_list|(
name|head
operator|->
name|Right_Child
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|value
operator|.
name|op_value
condition|)
block|{
case|case
name|Expr_Op_Type_Add
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_ADD
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Sub
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_SUB
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Mult
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_MULT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Div
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_DIV
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Mod
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_MOD
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Lshift
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_LSHIFT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_Rshift
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_RSHIFT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_BAND
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_AND
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_BOR
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_OR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_BXOR
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_XOR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_LAND
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_LAND
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_LOR
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_LOR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:Unkonwn operator found for arithmetic"
literal|" relocation"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Expr_Node_Unop
case|:
name|note1
operator|=
name|conscode
argument_list|(
name|Expr_Node_Gen_Reloc_R
argument_list|(
name|head
operator|->
name|Left_Child
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|value
operator|.
name|op_value
condition|)
block|{
case|case
name|Expr_Op_Type_NEG
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_NEG
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expr_Op_Type_COMP
case|:
name|note
operator|=
name|conctcode
argument_list|(
name|note1
argument_list|,
name|conscode
argument_list|(
name|note_reloc1
argument_list|(
name|gencode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|op
argument_list|,
name|BFD_ARELOC_BFIN_COMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_CODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:Unkonwn operator found for arithmetic"
literal|" relocation"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:Unknown node expression found during "
literal|"arithmetic relocation generation"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Blackfin opcode generation.  */
end_comment

begin_comment
comment|/* These functions are called by the generated parser    (from bfin-parse.y), the register type classification    happens in bfin-lex.l.  */
end_comment

begin_include
include|#
directive|include
file|"bfin-aux.h"
end_include

begin_include
include|#
directive|include
file|"opcode/bfin.h"
end_include

begin_define
define|#
directive|define
name|INIT
parameter_list|(
name|t
parameter_list|)
value|t c_code = init_##t
end_define

begin_define
define|#
directive|define
name|ASSIGN
parameter_list|(
name|x
parameter_list|)
value|c_code.opcode |= ((x& c_code.mask_##x)<<c_code.bits_##x)
end_define

begin_define
define|#
directive|define
name|ASSIGN_R
parameter_list|(
name|x
parameter_list|)
value|c_code.opcode |= (((x ? (x->regno& CODE_MASK) : 0)& c_code.mask_##x)<<c_code.bits_##x)
end_define

begin_define
define|#
directive|define
name|HI
parameter_list|(
name|x
parameter_list|)
value|((x>> 16)& 0xffff)
end_define

begin_define
define|#
directive|define
name|LO
parameter_list|(
name|x
parameter_list|)
value|((x      )& 0xffff)
end_define

begin_define
define|#
directive|define
name|GROUP
parameter_list|(
name|x
parameter_list|)
value|((x->regno& CLASS_MASK)>> 4)
end_define

begin_define
define|#
directive|define
name|GEN_OPCODE32
parameter_list|()
define|\
value|conscode (gencode (HI (c_code.opcode)), \ 	conscode (gencode (LO (c_code.opcode)), NULL_CODE))
end_define

begin_define
define|#
directive|define
name|GEN_OPCODE16
parameter_list|()
define|\
value|conscode (gencode (c_code.opcode), NULL_CODE)
end_define

begin_comment
comment|/*  32 BIT INSTRUCTIONS.  */
end_comment

begin_comment
comment|/* DSP32 instruction generation.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_dsp32mac
parameter_list|(
name|int
name|op1
parameter_list|,
name|int
name|MM
parameter_list|,
name|int
name|mmod
parameter_list|,
name|int
name|w1
parameter_list|,
name|int
name|P
parameter_list|,
name|int
name|h01
parameter_list|,
name|int
name|h11
parameter_list|,
name|int
name|h00
parameter_list|,
name|int
name|h10
parameter_list|,
name|int
name|op0
parameter_list|,
name|REG_T
name|dst
parameter_list|,
name|REG_T
name|src0
parameter_list|,
name|REG_T
name|src1
parameter_list|,
name|int
name|w0
parameter_list|)
block|{
name|INIT
argument_list|(
name|DSP32Mac
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|MM
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|mmod
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|w0
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|w1
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h01
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h11
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h00
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h10
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|P
argument_list|)
expr_stmt|;
comment|/* If we have full reg assignments, mask out LSB to encode   single or simultaneous even/odd register moves.  */
if|if
condition|(
name|P
condition|)
block|{
name|dst
operator|->
name|regno
operator|&=
literal|0x06
expr_stmt|;
block|}
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dsp32mult
parameter_list|(
name|int
name|op1
parameter_list|,
name|int
name|MM
parameter_list|,
name|int
name|mmod
parameter_list|,
name|int
name|w1
parameter_list|,
name|int
name|P
parameter_list|,
name|int
name|h01
parameter_list|,
name|int
name|h11
parameter_list|,
name|int
name|h00
parameter_list|,
name|int
name|h10
parameter_list|,
name|int
name|op0
parameter_list|,
name|REG_T
name|dst
parameter_list|,
name|REG_T
name|src0
parameter_list|,
name|REG_T
name|src1
parameter_list|,
name|int
name|w0
parameter_list|)
block|{
name|INIT
argument_list|(
name|DSP32Mult
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|MM
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|mmod
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|w0
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|w1
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h01
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h11
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h00
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|h10
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
condition|)
block|{
name|dst
operator|->
name|regno
operator|&=
literal|0x06
expr_stmt|;
block|}
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dsp32alu
parameter_list|(
name|int
name|HL
parameter_list|,
name|int
name|aopcde
parameter_list|,
name|int
name|aop
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|x
parameter_list|,
name|REG_T
name|dst0
parameter_list|,
name|REG_T
name|dst1
parameter_list|,
name|REG_T
name|src0
parameter_list|,
name|REG_T
name|src1
parameter_list|)
block|{
name|INIT
argument_list|(
name|DSP32Alu
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|HL
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|aopcde
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|aop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst1
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dsp32shift
parameter_list|(
name|int
name|sopcde
parameter_list|,
name|REG_T
name|dst0
parameter_list|,
name|REG_T
name|src0
parameter_list|,
name|REG_T
name|src1
parameter_list|,
name|int
name|sop
parameter_list|,
name|int
name|HLs
parameter_list|)
block|{
name|INIT
argument_list|(
name|DSP32Shift
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sopcde
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|HLs
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dsp32shiftimm
parameter_list|(
name|int
name|sopcde
parameter_list|,
name|REG_T
name|dst0
parameter_list|,
name|int
name|immag
parameter_list|,
name|REG_T
name|src1
parameter_list|,
name|int
name|sop
parameter_list|,
name|int
name|HLs
parameter_list|)
block|{
name|INIT
argument_list|(
name|DSP32ShiftImm
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sopcde
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|HLs
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst0
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|immag
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* LOOP SETUP.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_loopsetup
parameter_list|(
name|Expr_Node
modifier|*
name|psoffset
parameter_list|,
name|REG_T
name|c
parameter_list|,
name|int
name|rop
parameter_list|,
name|Expr_Node
modifier|*
name|peoffset
parameter_list|,
name|REG_T
name|reg
parameter_list|)
block|{
name|int
name|soffset
decl_stmt|,
name|eoffset
decl_stmt|;
name|INIT
argument_list|(
name|LoopSetup
argument_list|)
expr_stmt|;
name|soffset
operator|=
operator|(
name|EXPR_VALUE
argument_list|(
name|psoffset
argument_list|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|soffset
argument_list|)
expr_stmt|;
name|eoffset
operator|=
operator|(
name|EXPR_VALUE
argument_list|(
name|peoffset
argument_list|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|eoffset
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|rop
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|conctcode
argument_list|(
name|Expr_Node_Gen_Reloc
argument_list|(
name|psoffset
argument_list|,
name|BFD_RELOC_BFIN_5_PCREL
argument_list|)
argument_list|,
name|conctcode
argument_list|(
name|gencode
argument_list|(
name|LO
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|peoffset
argument_list|,
name|BFD_RELOC_BFIN_11_PCREL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Call, Link.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_calla
parameter_list|(
name|Expr_Node
modifier|*
name|addr
parameter_list|,
name|int
name|S
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|high_val
decl_stmt|;
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|INIT
argument_list|(
name|CALLa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|S
condition|)
block|{
case|case
literal|0
case|:
name|reloc
operator|=
name|BFD_RELOC_BFIN_24_PCREL_JUMP_L
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reloc
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reloc
operator|=
name|BFD_RELOC_BFIN_PLTPC
expr_stmt|;
break|break;
default|default :
break|break;
block|}
name|ASSIGN
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|val
operator|=
name|EXPR_VALUE
argument_list|(
name|addr
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|high_val
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
operator||
operator|(
name|high_val
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|addr
argument_list|,
name|reloc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_linkage
parameter_list|(
name|int
name|R
parameter_list|,
name|int
name|framesize
parameter_list|)
block|{
name|INIT
argument_list|(
name|Linkage
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|framesize
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Load and Store.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_ldimmhalf
parameter_list|(
name|REG_T
name|reg
parameter_list|,
name|int
name|H
parameter_list|,
name|int
name|S
parameter_list|,
name|int
name|Z
parameter_list|,
name|Expr_Node
modifier|*
name|phword
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|int
name|grp
decl_stmt|,
name|hword
decl_stmt|;
name|unsigned
name|val
init|=
name|EXPR_VALUE
argument_list|(
name|phword
argument_list|)
decl_stmt|;
name|INIT
argument_list|(
name|LDIMMhalf
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|H
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|Z
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|grp
operator|=
operator|(
name|GROUP
argument_list|(
name|reg
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
literal|2
condition|)
block|{
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|phword
argument_list|,
name|BFD_RELOC_BFIN_16_IMM
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reloc
operator|==
literal|1
condition|)
block|{
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|phword
argument_list|,
name|IS_H
argument_list|(
operator|*
name|reg
argument_list|)
condition|?
name|BFD_RELOC_BFIN_16_HIGH
else|:
name|BFD_RELOC_BFIN_16_LOW
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|hword
operator|=
name|val
expr_stmt|;
name|ASSIGN
argument_list|(
name|hword
argument_list|)
expr_stmt|;
block|}
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ldstidxi
parameter_list|(
name|REG_T
name|ptr
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|int
name|W
parameter_list|,
name|int
name|sz
parameter_list|,
name|int
name|Z
parameter_list|,
name|Expr_Node
modifier|*
name|poffset
parameter_list|)
block|{
name|INIT
argument_list|(
name|LDSTidxI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_PREG
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
operator|(
operator|!
name|IS_DREG
argument_list|(
operator|*
name|reg
argument_list|)
operator|&&
operator|!
name|Z
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: possible mixup of Preg/Dreg\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSIGN_R
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|Z
argument_list|)
expr_stmt|;
if|if
condition|(
name|poffset
operator|->
name|type
operator|!=
name|Expr_Node_Constant
condition|)
block|{
comment|/* a GOT relocation such as R0 = [P5 + symbol@GOT] */
comment|/* distinguish between R0 = [P5 + symbol@GOT] and 	 P5 = [P5 + _current_shared_library_p5_offset_]       */
if|if
condition|(
name|poffset
operator|->
name|type
operator|==
name|Expr_Node_Reloc
operator|&&
operator|!
name|strcmp
argument_list|(
name|poffset
operator|->
name|value
operator|.
name|s_value
argument_list|,
literal|"_current_shared_library_p5_offset_"
argument_list|)
condition|)
block|{
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|poffset
argument_list|,
name|BFD_RELOC_16
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|poffset
operator|->
name|type
operator|!=
name|Expr_Node_GOT_Reloc
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|HI
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|poffset
operator|->
name|Left_Child
argument_list|,
name|poffset
operator|->
name|value
operator|.
name|i_value
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|value
decl_stmt|,
name|offset
decl_stmt|;
switch|switch
condition|(
name|sz
condition|)
block|{
comment|// load/store access size
case|case
literal|0
case|:
comment|// 32 bit
name|value
operator|=
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// 16 bit
name|value
operator|=
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// 8 bit
name|value
operator|=
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|offset
operator|=
operator|(
name|value
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ldst
parameter_list|(
name|REG_T
name|ptr
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|int
name|aop
parameter_list|,
name|int
name|sz
parameter_list|,
name|int
name|Z
parameter_list|,
name|int
name|W
parameter_list|)
block|{
name|INIT
argument_list|(
name|LDST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_PREG
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
operator|(
operator|!
name|IS_DREG
argument_list|(
operator|*
name|reg
argument_list|)
operator|&&
operator|!
name|Z
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: possible mixup of Preg/Dreg\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSIGN_R
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|aop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|Z
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ldstii
parameter_list|(
name|REG_T
name|ptr
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|Expr_Node
modifier|*
name|poffset
parameter_list|,
name|int
name|W
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|INIT
argument_list|(
name|LDSTii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_PREG
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: possible mixup of Preg/Dreg\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|value
operator|=
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|3
case|:
name|value
operator|=
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|2
expr_stmt|;
break|break;
block|}
name|ASSIGN_R
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|value
expr_stmt|;
name|ASSIGN
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ldstiifp
parameter_list|(
name|REG_T
name|sreg
parameter_list|,
name|Expr_Node
modifier|*
name|poffset
parameter_list|,
name|int
name|W
parameter_list|)
block|{
comment|/* Set bit 4 if it's a Preg.  */
name|int
name|reg
init|=
operator|(
name|sreg
operator|->
name|regno
operator|&
name|CODE_MASK
operator|)
operator||
operator|(
name|IS_PREG
argument_list|(
operator|*
name|sreg
argument_list|)
condition|?
literal|0x8
else|:
literal|0x0
operator|)
decl_stmt|;
name|int
name|offset
init|=
operator|(
operator|(
operator|~
operator|(
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|2
operator|)
operator|)
operator|&
literal|0x1f
operator|)
operator|+
literal|1
decl_stmt|;
name|INIT
argument_list|(
name|LDSTiiFP
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ldstpmod
parameter_list|(
name|REG_T
name|ptr
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|int
name|aop
parameter_list|,
name|int
name|W
parameter_list|,
name|REG_T
name|idx
parameter_list|)
block|{
name|INIT
argument_list|(
name|LDSTpmod
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|aop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dspldst
parameter_list|(
name|REG_T
name|i
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|int
name|aop
parameter_list|,
name|int
name|W
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|INIT
argument_list|(
name|DspLDST
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|aop
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_logi2op
parameter_list|(
name|int
name|opc
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|dst
parameter_list|)
block|{
name|INIT
argument_list|(
name|LOGI2op
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|opc
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_brcc
parameter_list|(
name|int
name|T
parameter_list|,
name|int
name|B
parameter_list|,
name|Expr_Node
modifier|*
name|poffset
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|INIT
argument_list|(
name|BRCC
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|T
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|poffset
argument_list|,
name|BFD_RELOC_BFIN_10_PCREL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ujump
parameter_list|(
name|Expr_Node
modifier|*
name|poffset
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|INIT
argument_list|(
name|UJump
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|EXPR_VALUE
argument_list|(
name|poffset
argument_list|)
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|conscode
argument_list|(
name|gencode
argument_list|(
name|c_code
operator|.
name|opcode
argument_list|)
argument_list|,
name|Expr_Node_Gen_Reloc
argument_list|(
name|poffset
argument_list|,
name|BFD_RELOC_BFIN_12_PCREL_JUMP_S
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_alu2op
parameter_list|(
name|REG_T
name|dst
parameter_list|,
name|REG_T
name|src
parameter_list|,
name|int
name|opc
parameter_list|)
block|{
name|INIT
argument_list|(
name|ALU2op
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|opc
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_compi2opd
parameter_list|(
name|REG_T
name|dst
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|INIT
argument_list|(
name|COMPI2opD
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_compi2opp
parameter_list|(
name|REG_T
name|dst
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|INIT
argument_list|(
name|COMPI2opP
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dagmodik
parameter_list|(
name|REG_T
name|i
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|INIT
argument_list|(
name|DagMODik
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_dagmodim
parameter_list|(
name|REG_T
name|i
parameter_list|,
name|REG_T
name|m
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|br
parameter_list|)
block|{
name|INIT
argument_list|(
name|DagMODim
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|br
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ptr2op
parameter_list|(
name|REG_T
name|dst
parameter_list|,
name|REG_T
name|src
parameter_list|,
name|int
name|opc
parameter_list|)
block|{
name|INIT
argument_list|(
name|PTR2op
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|opc
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_comp3op
parameter_list|(
name|REG_T
name|src0
parameter_list|,
name|REG_T
name|src1
parameter_list|,
name|REG_T
name|dst
parameter_list|,
name|int
name|opc
parameter_list|)
block|{
name|INIT
argument_list|(
name|COMP3op
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|opc
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ccflag
parameter_list|(
name|REG_T
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|opc
parameter_list|,
name|int
name|I
parameter_list|,
name|int
name|G
parameter_list|)
block|{
name|INIT
argument_list|(
name|CCflag
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|opc
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|G
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_ccmv
parameter_list|(
name|REG_T
name|src
parameter_list|,
name|REG_T
name|dst
parameter_list|,
name|int
name|T
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|d
decl_stmt|;
name|INIT
argument_list|(
name|CCmv
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|GROUP
argument_list|(
name|src
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|GROUP
argument_list|(
name|dst
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|T
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_cc2stat
parameter_list|(
name|int
name|cbit
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|D
parameter_list|)
block|{
name|INIT
argument_list|(
name|CC2stat
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|cbit
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|D
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_regmv
parameter_list|(
name|REG_T
name|src
parameter_list|,
name|REG_T
name|dst
parameter_list|)
block|{
name|int
name|gs
decl_stmt|,
name|gd
decl_stmt|;
name|INIT
argument_list|(
name|RegMv
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|gs
operator|=
operator|(
name|GROUP
argument_list|(
name|src
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|gs
argument_list|)
expr_stmt|;
name|gd
operator|=
operator|(
name|GROUP
argument_list|(
name|dst
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|gd
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_cc2dreg
parameter_list|(
name|int
name|op
parameter_list|,
name|REG_T
name|reg
parameter_list|)
block|{
name|INIT
argument_list|(
name|CC2dreg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_progctrl
parameter_list|(
name|int
name|prgfunc
parameter_list|,
name|int
name|poprnd
parameter_list|)
block|{
name|INIT
argument_list|(
name|ProgCtrl
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|prgfunc
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|poprnd
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_cactrl
parameter_list|(
name|REG_T
name|reg
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|INIT
argument_list|(
name|CaCTRL
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_pushpopmultiple
parameter_list|(
name|int
name|dr
parameter_list|,
name|int
name|pr
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|p
parameter_list|,
name|int
name|W
parameter_list|)
block|{
name|INIT
argument_list|(
name|PushPopMultiple
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_pushpopreg
parameter_list|(
name|REG_T
name|reg
parameter_list|,
name|int
name|W
parameter_list|)
block|{
name|int
name|grp
decl_stmt|;
name|INIT
argument_list|(
name|PushPopReg
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|grp
operator|=
operator|(
name|GROUP
argument_list|(
name|reg
argument_list|)
operator|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|W
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Pseudo Debugging Support.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_pseudodbg
parameter_list|(
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|grp
parameter_list|)
block|{
name|INIT
argument_list|(
name|PseudoDbg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|grp
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE16
argument_list|()
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_pseudodbg_assert
parameter_list|(
name|int
name|dbgop
parameter_list|,
name|REG_T
name|regtest
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|INIT
argument_list|(
name|PseudoDbg_Assert
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|dbgop
argument_list|)
expr_stmt|;
name|ASSIGN_R
argument_list|(
name|regtest
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|expected
argument_list|)
expr_stmt|;
return|return
name|GEN_OPCODE32
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Multiple instruction generation.  */
end_comment

begin_function
name|INSTR_T
name|bfin_gen_multi_instr
parameter_list|(
name|INSTR_T
name|dsp32
parameter_list|,
name|INSTR_T
name|dsp16_grp1
parameter_list|,
name|INSTR_T
name|dsp16_grp2
parameter_list|)
block|{
name|INSTR_T
name|walk
decl_stmt|;
comment|/* If it's a 0, convert into MNOP. */
if|if
condition|(
name|dsp32
condition|)
block|{
name|walk
operator|=
name|dsp32
operator|->
name|next
expr_stmt|;
name|SET_MULTI_INSTRUCTION_BIT
argument_list|(
name|dsp32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsp32
operator|=
name|gencode
argument_list|(
literal|0xc803
argument_list|)
expr_stmt|;
name|walk
operator|=
name|gencode
argument_list|(
literal|0x1800
argument_list|)
expr_stmt|;
name|dsp32
operator|->
name|next
operator|=
name|walk
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dsp16_grp1
condition|)
block|{
name|dsp16_grp1
operator|=
name|gencode
argument_list|(
literal|0x0000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dsp16_grp2
condition|)
block|{
name|dsp16_grp2
operator|=
name|gencode
argument_list|(
literal|0x0000
argument_list|)
expr_stmt|;
block|}
name|walk
operator|->
name|next
operator|=
name|dsp16_grp1
expr_stmt|;
name|dsp16_grp1
operator|->
name|next
operator|=
name|dsp16_grp2
expr_stmt|;
name|dsp16_grp2
operator|->
name|next
operator|=
name|NULL_CODE
expr_stmt|;
return|return
name|dsp32
return|;
block|}
end_function

begin_function
name|INSTR_T
name|bfin_gen_loop
parameter_list|(
name|Expr_Node
modifier|*
name|expr
parameter_list|,
name|REG_T
name|reg
parameter_list|,
name|int
name|rop
parameter_list|,
name|REG_T
name|preg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|loopsym
decl_stmt|;
name|char
modifier|*
name|lbeginsym
decl_stmt|,
modifier|*
name|lendsym
decl_stmt|;
name|Expr_Node_Value
name|lbeginval
decl_stmt|,
name|lendval
decl_stmt|;
name|Expr_Node
modifier|*
name|lbegin
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
name|loopsym
operator|=
name|expr
operator|->
name|value
operator|.
name|s_value
expr_stmt|;
name|lbeginsym
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|loopsym
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"__BEGIN"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lendsym
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|loopsym
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"__END"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lbeginsym
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lendsym
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|lbeginsym
argument_list|,
name|loopsym
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|lbeginsym
argument_list|,
literal|"__BEGIN"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|lendsym
argument_list|,
name|loopsym
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|lendsym
argument_list|,
literal|"__END"
argument_list|)
expr_stmt|;
name|lbeginval
operator|.
name|s_value
operator|=
name|lbeginsym
expr_stmt|;
name|lendval
operator|.
name|s_value
operator|=
name|lendsym
expr_stmt|;
name|lbegin
operator|=
name|Expr_Node_Create
argument_list|(
name|Expr_Node_Reloc
argument_list|,
name|lbeginval
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lend
operator|=
name|Expr_Node_Create
argument_list|(
name|Expr_Node_Reloc
argument_list|,
name|lendval
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|bfin_gen_loopsetup
argument_list|(
name|lbegin
argument_list|,
name|reg
argument_list|,
name|rop
argument_list|,
name|lend
argument_list|,
name|preg
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfin_eol_in_insn
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* Allow a new-line to appear in the middle of a multi-issue instruction.  */
name|char
modifier|*
name|temp
init|=
name|line
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|!=
literal|'\n'
condition|)
return|return
name|FALSE
return|;
comment|/* A semi-colon followed by a newline is always the end of a line.  */
if|if
condition|(
name|line
index|[
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|line
index|[
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
return|return
name|TRUE
return|;
comment|/* If the || is on the next line, there might be leading whitespace.  */
name|temp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|==
literal|' '
operator|||
operator|*
name|temp
operator|==
literal|'\t'
condition|)
name|temp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|temp
operator|==
literal|'|'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfin_start_label
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|ptr
operator|--
expr_stmt|;
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
name|ptr
operator|--
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'('
operator|||
operator|*
name|ptr
operator|==
literal|'['
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|bfin_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_BFIN_16_LOW
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_BFIN_16_HIGH
condition|)
return|return
name|TRUE
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
return|;
block|}
end_function

end_unit

