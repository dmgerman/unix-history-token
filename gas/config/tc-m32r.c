begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-m32r.c -- Assembler for the Renesas M32R.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/m32r-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/m32r-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32r.h"
end_include

begin_comment
comment|/* Linked list of symbols that are debugging symbols to be defined as the    beginning of the current instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sym_link
block|{
name|struct
name|sym_link
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
block|}
name|sym_linkS
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|sym_linkS
modifier|*
name|debug_sym_link
init|=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
name|sym_linkS
modifier|*
name|debug_sym_link
decl_stmt|;
block|}
name|m32r_insn
typedef|;
end_typedef

begin_comment
comment|/* prev_insn.insn is non-null if last insn was a 16 bit insn on a 32 bit    boundary (i.e. was the first of two 16 bit insns).  */
end_comment

begin_decl_stmt
specifier|static
name|m32r_insn
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we've seen a relaxable insn since the last 32 bit    alignment request.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|seen_relaxable_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we are generating PIC code.  */
end_comment

begin_decl_stmt
name|int
name|pic_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if -relax specified, in which case sufficient relocs are output    for the linker to do relaxing.    We do simple forms of relaxing internally, but they are always done.    This flag does not apply to them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m32r_relax
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not supported yet.  */
end_comment

begin_comment
comment|/* If non-NULL, pointer to cpu description file to read.    This allows runtime additions to the assembler.  */
end_comment

begin_endif
unit|static const char *m32r_cpu_desc;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero if warn when a high/shigh reloc has no matching low reloc.    Each high/shigh reloc must be paired with it's low cousin in order to    properly calculate the addend in a relocatable link (since there is a    potential carry from the low to the high/shigh).    This option is off by default though for user-written assembler code it    might make sense to make the default be on (i.e. have gcc pass a flag    to turn it off).  This warning must not be on for GCC created code as    optimization may delete the low but not the high/shigh (at least we    shouldn't assume or require it to).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_unmatched_high
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if -m32rx has been specified, in which case support for      the extended M32RX instruction set should be enabled.    2 if -m32r2 has been specified, in which case support for      the extended M32R2 instruction set should be enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_m32rx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to M32R.  */
end_comment

begin_comment
comment|/* Non-zero if -m32rx -hidden has been specified, in which case support for    the special M32RX instruction set should be enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_special
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if -bitinst has been specified, in which case support    for extended M32R bit-field instruction set should be enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_special_m32r
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if -float has been specified, in which case support for    extended M32R floating point instruction set should be enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_special_float
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the programmer should be warned when an explicit parallel    instruction might have constraint violations.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_explicit_parallel_conflicts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the programmer should not receive any messages about    parallel instruction with potential or real constraint violations.    The ability to suppress these messages is intended only for hardware    vendors testing the chip.  It superceedes    warn_explicit_parallel_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_parallel_conflicts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if insns can be made parallel.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_parallel
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if optimizations should be performed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|optimize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* m32r er_flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m32r_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for .scomm symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|sbss_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
name|scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocations against symbols are done in two    parts, with a HI relocation and a LO relocation.  Each relocation    has only 16 bits of space to store an addend.  This means that in    order for the linker to handle carries correctly, it must be able    to locate both the HI and the LO relocation.  This means that the    relocations must appear in order in the relocation table.     In order to implement this, we keep track of each unmatched HI    relocation.  We then sort them so that they immediately precede the    corresponding LO relocation.  */
end_comment

begin_struct
struct|struct
name|m32r_hi_fixup
block|{
comment|/* Next HI fixup.  */
name|struct
name|m32r_hi_fixup
modifier|*
name|next
decl_stmt|;
comment|/* This fixup.  */
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* The section this fixup is in.  */
name|segT
name|seg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of unmatched HI relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m32r_hi_fixup
modifier|*
name|m32r_hi_fixup_list
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
struct|struct
block|{
name|enum
name|bfd_architecture
name|bfd_mach
decl_stmt|;
name|int
name|mach_flags
decl_stmt|;
block|}
name|mach_table
index|[]
init|=
block|{
block|{
name|bfd_mach_m32r
block|,
operator|(
literal|1
operator|<<
name|MACH_M32R
operator|)
block|}
block|,
block|{
name|bfd_mach_m32rx
block|,
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
block|}
block|,
block|{
name|bfd_mach_m32r2
block|,
operator|(
literal|1
operator|<<
name|MACH_M32R2
operator|)
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|allow_m32rx
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|allow_m32rx
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|enable_m32rx
operator|=
name|on
expr_stmt|;
if|if
condition|(
name|stdoutput
operator|!=
name|NULL
condition|)
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|mach_table
index|[
name|on
index|]
operator|.
name|bfd_mach
argument_list|)
expr_stmt|;
if|if
condition|(
name|gas_cgen_cpu_desc
operator|!=
name|NULL
condition|)
name|gas_cgen_cpu_desc
operator|->
name|machs
operator|=
name|mach_table
index|[
name|on
index|]
operator|.
name|mach_flags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|M32R_SHORTOPTS
value|"O::K:"
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|M32R_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_M32R
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_M32RX
value|(OPTION_M32R + 1)
define|#
directive|define
name|OPTION_M32R2
value|(OPTION_M32RX + 1)
define|#
directive|define
name|OPTION_BIG
value|(OPTION_M32R2 + 1)
define|#
directive|define
name|OPTION_LITTLE
value|(OPTION_BIG + 1)
define|#
directive|define
name|OPTION_PARALLEL
value|(OPTION_LITTLE + 1)
define|#
directive|define
name|OPTION_NO_PARALLEL
value|(OPTION_PARALLEL + 1)
define|#
directive|define
name|OPTION_WARN_PARALLEL
value|(OPTION_NO_PARALLEL + 1)
define|#
directive|define
name|OPTION_NO_WARN_PARALLEL
value|(OPTION_WARN_PARALLEL + 1)
define|#
directive|define
name|OPTION_IGNORE_PARALLEL
value|(OPTION_NO_WARN_PARALLEL + 1)
define|#
directive|define
name|OPTION_NO_IGNORE_PARALLEL
value|(OPTION_IGNORE_PARALLEL + 1)
define|#
directive|define
name|OPTION_SPECIAL
value|(OPTION_NO_IGNORE_PARALLEL + 1)
define|#
directive|define
name|OPTION_SPECIAL_M32R
value|(OPTION_SPECIAL + 1)
define|#
directive|define
name|OPTION_SPECIAL_FLOAT
value|(OPTION_SPECIAL_M32R + 1)
define|#
directive|define
name|OPTION_WARN_UNMATCHED
value|(OPTION_SPECIAL_FLOAT + 1)
define|#
directive|define
name|OPTION_NO_WARN_UNMATCHED
value|(OPTION_WARN_UNMATCHED + 1)
block|{
literal|"m32r"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M32R
block|}
block|,
block|{
literal|"m32rx"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M32RX
block|}
block|,
block|{
literal|"m32r2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M32R2
block|}
block|,
block|{
literal|"big"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG
block|}
block|,
block|{
literal|"little"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE
block|}
block|,
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG
block|}
block|,
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE
block|}
block|,
block|{
literal|"parallel"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PARALLEL
block|}
block|,
block|{
literal|"no-parallel"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_PARALLEL
block|}
block|,
block|{
literal|"warn-explicit-parallel-conflicts"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_PARALLEL
block|}
block|,
block|{
literal|"Wp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_PARALLEL
block|}
block|,
block|{
literal|"no-warn-explicit-parallel-conflicts"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_PARALLEL
block|}
block|,
block|{
literal|"Wnp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_PARALLEL
block|}
block|,
block|{
literal|"ignore-parallel-conflicts"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE_PARALLEL
block|}
block|,
block|{
literal|"Ip"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE_PARALLEL
block|}
block|,
block|{
literal|"no-ignore-parallel-conflicts"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_IGNORE_PARALLEL
block|}
block|,
block|{
literal|"nIp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_IGNORE_PARALLEL
block|}
block|,
block|{
literal|"hidden"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SPECIAL
block|}
block|,
block|{
literal|"bitinst"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SPECIAL_M32R
block|}
block|,
block|{
literal|"float"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SPECIAL_FLOAT
block|}
block|,
comment|/* Sigh.  I guess all warnings must now have both variants.  */
block|{
literal|"warn-unmatched-high"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_UNMATCHED
block|}
block|,
block|{
literal|"Wuh"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_UNMATCHED
block|}
block|,
block|{
literal|"no-warn-unmatched-high"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_UNMATCHED
block|}
block|,
block|{
literal|"Wnuh"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_UNMATCHED
block|}
block|,
if|#
directive|if
literal|0
comment|/* Not supported yet.  */
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_NO_WARN_UNMATCHED + 1)
define|#
directive|define
name|OPTION_CPU_DESC
value|(OPTION_RELAX + 1)
block|{"relax", no_argument, NULL, OPTION_RELAX},   {"cpu-desc", required_argument, NULL, OPTION_CPU_DESC},
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|little
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parallel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|little
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|target_big_endian
operator|=
operator|!
name|on
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use parallel execution.  */
end_comment

begin_function
specifier|static
name|int
name|parallel
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable_m32rx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|use_parallel
operator|==
literal|1
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'O'
case|:
name|optimize
operator|=
literal|1
expr_stmt|;
name|use_parallel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_M32R
case|:
name|allow_m32rx
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_M32RX
case|:
name|allow_m32rx
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_M32R2
case|:
name|allow_m32rx
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|enable_special
operator|=
literal|1
expr_stmt|;
name|enable_special_m32r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_BIG
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LITTLE
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_PARALLEL
case|:
name|use_parallel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PARALLEL
case|:
name|use_parallel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_PARALLEL
case|:
name|warn_explicit_parallel_conflicts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WARN_PARALLEL
case|:
name|warn_explicit_parallel_conflicts
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_IGNORE_PARALLEL
case|:
name|ignore_parallel_conflicts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_IGNORE_PARALLEL
case|:
name|ignore_parallel_conflicts
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SPECIAL
case|:
if|if
condition|(
name|enable_m32rx
condition|)
name|enable_special
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Pretend that we do not recognise this option.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognised option: -hidden"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|OPTION_SPECIAL_M32R
case|:
name|enable_special_m32r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_SPECIAL_FLOAT
case|:
name|enable_special_float
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_UNMATCHED
case|:
name|warn_unmatched_high
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WARN_UNMATCHED
case|:
name|warn_unmatched_high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"PIC"
argument_list|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option following -K"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pic_code
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* Not supported yet.  */
block|case OPTION_RELAX:       m32r_relax = 1;       break;     case OPTION_CPU_DESC:       m32r_cpu_desc = arg;       break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" M32R specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -m32r                   disable support for the m32rx instruction set\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -m32rx                  support the extended m32rx instruction set\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -m32r2                  support the extended m32r2 instruction set\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -EL,-little             produce little endian code and data\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -EB,-big                produce big endian code and data\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -parallel               try to combine instructions in parallel\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-parallel            disable -parallel\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -O                      try to optimize code.  Implies -parallel\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -warn-explicit-parallel-conflicts     warn when parallel instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\                                          might violate contraints\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-warn-explicit-parallel-conflicts  do not warn when parallel\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\                                          instructions might violate contraints\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Wp                     synonym for -warn-explicit-parallel-conflicts\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Wnp                    synonym for -no-warn-explicit-parallel-conflicts\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -ignore-parallel-conflicts            do not check parallel instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\                                          fo contraint violations\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-ignore-parallel-conflicts         check parallel instructions for\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\                                          contraint violations\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Ip                     synonym for -ignore-parallel-conflicts\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -nIp                    synonym for -no-ignore-parallel-conflicts\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -warn-unmatched-high    warn when an (s)high reloc has no matching low reloc\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-warn-unmatched-high do not warn about missing low relocs\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Wuh                    synonym for -warn-unmatched-high\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Wnuh                   synonym for -no-warn-unmatched-high\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -KPIC                   generate PIC\n"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stream, _("\   -relax                 create linker relaxable code\n"));   fprintf (stream, _("\   -cpu-desc              provide runtime cpu description file\n"));
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|fill_insn
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|m32r_scomm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_sym
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_debug_syms
name|PARAMS
argument_list|(
operator|(
name|sym_linkS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by md_assemble for use by m32r_fill_insn.  */
end_comment

begin_decl_stmt
specifier|static
name|subsegT
name|prev_subseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|prev_seg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"fillinsn"
block|,
name|fill_insn
block|,
literal|0
block|}
block|,
block|{
literal|"scomm"
block|,
name|m32r_scomm
block|,
literal|0
block|}
block|,
block|{
literal|"debugsym"
block|,
name|debug_sym
block|,
literal|0
block|}
block|,
block|{
literal|"m32r"
block|,
name|allow_m32rx
block|,
literal|0
block|}
block|,
block|{
literal|"m32rx"
block|,
name|allow_m32rx
block|,
literal|1
block|}
block|,
block|{
literal|"m32r2"
block|,
name|allow_m32rx
block|,
literal|2
block|}
block|,
block|{
literal|"little"
block|,
name|little
block|,
literal|1
block|}
block|,
block|{
literal|"big"
block|,
name|little
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: Should be machine generated.  */
end_comment

begin_define
define|#
directive|define
name|NOP_INSN
value|0x7000
end_define

begin_define
define|#
directive|define
name|PAR_NOP_INSN
value|0xf000
end_define

begin_comment
comment|/* Can only be used in 2nd slot.  */
end_comment

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|m32r_handle_align
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|nop_pattern
index|[]
init|=
block|{
literal|0xf0
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|multi_nop_pattern
index|[]
init|=
block|{
literal|0x70
block|,
literal|0x00
block|,
literal|0xf0
block|,
literal|0x00
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|fix
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|fix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|1
condition|)
block|{
name|fix
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|&
literal|2
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|nop_pattern
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|fix
operator|+=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|multi_nop_pattern
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the last instruction was the first of 2 16 bit insns,    output a nop to move the PC to a 32 bit boundary.     This is done via an alignment specification since branch relaxing    may make it unnecessary.     Internally, we need to output one of these each time a 32 bit insn is    seen after an insn that is relaxable.  */
end_comment

begin_function
specifier|static
name|void
name|fill_insn
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|frag_align_code
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev_insn
operator|.
name|insn
operator|=
name|NULL
expr_stmt|;
name|seen_relaxable_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the symbol so that when we output the insn, we can create    a symbol that is at the start of the instruction.  This is used    to emit the label for the start of a breakpoint without causing    the assembler to emit a NOP if the previous instruction was a    16 bit instruction.  */
end_comment

begin_function
specifier|static
name|void
name|debug_sym
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|sym_linkS
modifier|*
name|link
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
comment|/* xgettext:c-format */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|link
operator|=
operator|(
name|sym_linkS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_linkS
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|symbol
operator|=
name|symbolP
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|debug_sym_link
expr_stmt|;
name|debug_sym_link
operator|=
name|link
expr_stmt|;
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Second pass to expanding the debug symbols, go through linked    list of symbols and reassign the address.  */
end_comment

begin_function
specifier|static
name|void
name|expand_debug_syms
parameter_list|(
name|syms
parameter_list|,
name|align
parameter_list|)
name|sym_linkS
modifier|*
name|syms
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|char
modifier|*
name|save_input_line
init|=
name|input_line_pointer
decl_stmt|;
name|sym_linkS
modifier|*
name|next_syms
decl_stmt|;
if|if
condition|(
operator|!
name|syms
condition|)
return|return;
operator|(
name|void
operator|)
name|frag_align_code
argument_list|(
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|syms
operator|!=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
condition|;
name|syms
operator|=
name|next_syms
control|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|syms
operator|->
name|symbol
decl_stmt|;
name|next_syms
operator|=
name|syms
operator|->
name|next
expr_stmt|;
name|input_line_pointer
operator|=
literal|".\n"
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|syms
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_input_line
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m32r_flush_pending_output
parameter_list|()
block|{
if|if
condition|(
name|debug_sym_link
condition|)
block|{
name|expand_debug_syms
argument_list|(
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug_sym_link
operator|=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Cover function to fill_insn called after a label and at end of assembly.    The result is always 1: we're called in a conditional to see if the    current line is a label.  */
end_comment

begin_function
name|int
name|m32r_fill_insn
parameter_list|(
name|done
parameter_list|)
name|int
name|done
decl_stmt|;
block|{
if|if
condition|(
name|prev_seg
operator|!=
name|NULL
condition|)
block|{
name|segT
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|subseg_set
argument_list|(
name|prev_seg
argument_list|,
name|prev_subseg
argument_list|)
expr_stmt|;
name|fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|&&
name|debug_sym_link
condition|)
block|{
name|expand_debug_syms
argument_list|(
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug_sym_link
operator|=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The default target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|m32r_target_format
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TE_LINUX
if|if
condition|(
name|target_big_endian
condition|)
return|return
literal|"elf32-m32r-linux"
return|;
else|else
return|return
literal|"elf32-m32rle-linux"
return|;
else|#
directive|else
if|if
condition|(
name|target_big_endian
condition|)
return|return
literal|"elf32-m32r"
return|;
else|else
return|return
literal|"elf32-m32rle"
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|flagword
name|applicable
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|m32r_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
operator|(
name|target_big_endian
condition|?
name|CGEN_ENDIAN_BIG
else|:
name|CGEN_ENDIAN_LITTLE
operator|)
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|m32r_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* The operand instance table is used during optimization to determine      which insns can be executed in parallel.  It is also used to give      warnings regarding operand interference in parallel insns.  */
name|m32r_cgen_init_opinst_table
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not supported yet.  */
comment|/* If a runtime cpu description file was provided, parse it.  */
block|if (m32r_cpu_desc != NULL)     {       const char *errmsg;        errmsg = cgen_read_cpu_file (gas_cgen_cpu_desc, m32r_cpu_desc);       if (errmsg != NULL) 	as_bad ("%s: %s", m32r_cpu_desc, errmsg);     }
endif|#
directive|endif
comment|/* Save the current subseg so we can restore it [it's the default one and      we don't want the initial section to be .sbss].  */
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* The sbss section is for local .scomm symbols.  */
name|sbss_section
operator|=
name|subseg_new
argument_list|(
literal|".sbss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is copied from perform_an_assembly_pass.  */
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sbss_section
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* What does this do? [see perform_an_assembly_pass]  */
block|seg_info (bss_section)->bss = 1;
endif|#
directive|endif
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
comment|/* We must construct a fake section similar to bfd_com_section      but with the name .scommon.  */
name|scom_section
operator|=
name|bfd_com_section
expr_stmt|;
name|scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|scom_section
operator|.
name|output_section
operator|=
operator|&
name|scom_section
expr_stmt|;
name|scom_section
operator|.
name|symbol
operator|=
operator|&
name|scom_symbol
expr_stmt|;
name|scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|scom_section
operator|.
name|symbol
expr_stmt|;
name|scom_symbol
operator|=
operator|*
name|bfd_com_section
operator|.
name|symbol
expr_stmt|;
name|scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|scom_symbol
operator|.
name|section
operator|=
operator|&
name|scom_section
expr_stmt|;
name|allow_m32rx
argument_list|(
name|enable_m32rx
argument_list|)
expr_stmt|;
name|gas_cgen_initialize_saved_fixups_array
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OPERAND_IS_COND_BIT
parameter_list|(
name|operand
parameter_list|,
name|indices
parameter_list|,
name|index
parameter_list|)
define|\
value|((operand)->hw_type == HW_H_COND			\    || ((operand)->hw_type == HW_H_PSW)			\    || ((operand)->hw_type == HW_H_CR			\&& (indices [index] == 0 || indices [index] == 1)))
end_define

begin_comment
comment|/* Returns true if an output of instruction 'a' is referenced by an operand    of instruction 'b'.  If 'check_outputs' is true then b's outputs are    checked, otherwise its inputs are examined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_writes_to_seconds_operands
name|PARAMS
argument_list|(
operator|(
name|m32r_insn
operator|*
operator|,
name|m32r_insn
operator|*
operator|,
specifier|const
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|first_writes_to_seconds_operands
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|check_outputs
parameter_list|)
name|m32r_insn
modifier|*
name|a
decl_stmt|;
name|m32r_insn
modifier|*
name|b
decl_stmt|;
specifier|const
name|int
name|check_outputs
decl_stmt|;
block|{
specifier|const
name|CGEN_OPINST
modifier|*
name|a_operands
init|=
name|CGEN_INSN_OPERANDS
argument_list|(
name|a
operator|->
name|insn
argument_list|)
decl_stmt|;
specifier|const
name|CGEN_OPINST
modifier|*
name|b_ops
init|=
name|CGEN_INSN_OPERANDS
argument_list|(
name|b
operator|->
name|insn
argument_list|)
decl_stmt|;
name|int
name|a_index
decl_stmt|;
if|if
condition|(
name|ignore_parallel_conflicts
condition|)
return|return
literal|0
return|;
comment|/* If at least one of the instructions takes no operands, then there is      nothing to check.  There really are instructions without operands,      eg 'nop'.  */
if|if
condition|(
name|a_operands
operator|==
name|NULL
operator|||
name|b_ops
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Scan the operand list of 'a' looking for an output operand.  */
for|for
control|(
name|a_index
operator|=
literal|0
init|;
name|a_operands
operator|->
name|type
operator|!=
name|CGEN_OPINST_END
condition|;
name|a_index
operator|++
operator|,
name|a_operands
operator|++
control|)
block|{
if|if
condition|(
name|a_operands
operator|->
name|type
operator|==
name|CGEN_OPINST_OUTPUT
condition|)
block|{
name|int
name|b_index
decl_stmt|;
specifier|const
name|CGEN_OPINST
modifier|*
name|b_operands
init|=
name|b_ops
decl_stmt|;
comment|/* Special Case: 	     The Condition bit 'C' is a shadow of the CBR register (control 	     register 1) and also a shadow of bit 31 of the program status 	     word (control register 0).  For now this is handled here, rather 	     than by cgen....  */
if|if
condition|(
name|OPERAND_IS_COND_BIT
argument_list|(
name|a_operands
argument_list|,
name|a
operator|->
name|indices
argument_list|,
name|a_index
argument_list|)
condition|)
block|{
comment|/* Scan operand list of 'b' looking for another reference to the 		 condition bit, which goes in the right direction.  */
for|for
control|(
name|b_index
operator|=
literal|0
init|;
name|b_operands
operator|->
name|type
operator|!=
name|CGEN_OPINST_END
condition|;
name|b_index
operator|++
operator|,
name|b_operands
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|b_operands
operator|->
name|type
operator|==
operator|(
name|check_outputs
condition|?
name|CGEN_OPINST_OUTPUT
else|:
name|CGEN_OPINST_INPUT
operator|)
operator|)
operator|&&
name|OPERAND_IS_COND_BIT
argument_list|(
name|b_operands
argument_list|,
name|b
operator|->
name|indices
argument_list|,
name|b_index
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* Scan operand list of 'b' looking for an operand that 		 references the same hardware element, and which goes in the 		 right direction.  */
for|for
control|(
name|b_index
operator|=
literal|0
init|;
name|b_operands
operator|->
name|type
operator|!=
name|CGEN_OPINST_END
condition|;
name|b_index
operator|++
operator|,
name|b_operands
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|b_operands
operator|->
name|type
operator|==
operator|(
name|check_outputs
condition|?
name|CGEN_OPINST_OUTPUT
else|:
name|CGEN_OPINST_INPUT
operator|)
operator|)
operator|&&
operator|(
name|b_operands
operator|->
name|hw_type
operator|==
name|a_operands
operator|->
name|hw_type
operator|)
operator|&&
operator|(
name|a
operator|->
name|indices
index|[
name|a_index
index|]
operator|==
name|b
operator|->
name|indices
index|[
name|b_index
index|]
operator|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the insn can (potentially) alter the program counter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|writes_to_pc
name|PARAMS
argument_list|(
operator|(
name|m32r_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|writes_to_pc
parameter_list|(
name|a
parameter_list|)
name|m32r_insn
modifier|*
name|a
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Once PC operands are working....  */
block|const CGEN_OPINST *a_operands == CGEN_INSN_OPERANDS (gas_cgen_cpu_desc, 						       a->insn);    if (a_operands == NULL)     return 0;    while (a_operands->type != CGEN_OPINST_END)     {       if (a_operands->operand != NULL&& CGEN_OPERAND_INDEX (gas_cgen_cpu_desc, 				 a_operands->operand) == M32R_OPERAND_PC) 	return 1;        a_operands++;     }
else|#
directive|else
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|a
operator|->
name|insn
argument_list|,
name|CGEN_INSN_UNCOND_CTI
argument_list|)
operator|||
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|a
operator|->
name|insn
argument_list|,
name|CGEN_INSN_COND_CTI
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return NULL if the two 16 bit insns can be executed in parallel.    Otherwise return a pointer to an error message explaining why not.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|can_make_parallel
name|PARAMS
argument_list|(
operator|(
name|m32r_insn
operator|*
operator|,
name|m32r_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|can_make_parallel
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|m32r_insn
modifier|*
name|a
decl_stmt|;
name|m32r_insn
modifier|*
name|b
decl_stmt|;
block|{
name|PIPE_ATTR
name|a_pipe
decl_stmt|;
name|PIPE_ATTR
name|b_pipe
decl_stmt|;
comment|/* Make sure the instructions are the right length.  */
if|if
condition|(
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|a
operator|->
name|fields
argument_list|)
operator|!=
literal|16
operator|||
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|b
operator|->
name|fields
argument_list|)
operator|!=
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|first_writes_to_seconds_operands
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"instructions write to the same destination register."
argument_list|)
return|;
name|a_pipe
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|a
operator|->
name|insn
argument_list|,
name|CGEN_INSN_PIPE
argument_list|)
expr_stmt|;
name|b_pipe
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|b
operator|->
name|insn
argument_list|,
name|CGEN_INSN_PIPE
argument_list|)
expr_stmt|;
comment|/* Make sure that the instructions use the correct execution pipelines.  */
if|if
condition|(
name|a_pipe
operator|==
name|PIPE_NONE
operator|||
name|b_pipe
operator|==
name|PIPE_NONE
condition|)
return|return
name|_
argument_list|(
literal|"Instructions do not use parallel execution pipelines."
argument_list|)
return|;
comment|/* Leave this test for last, since it is the only test that can      go away if the instructions are swapped, and we want to make      sure that any other errors are detected before this happens.  */
if|if
condition|(
name|a_pipe
operator|==
name|PIPE_S
operator|||
name|b_pipe
operator|==
name|PIPE_O
operator|||
operator|(
name|b_pipe
operator|==
name|PIPE_O_OS
operator|&&
operator|(
name|enable_m32rx
operator|!=
literal|2
operator|)
operator|)
condition|)
return|return
name|_
argument_list|(
literal|"Instructions share the same execution pipeline"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Force the top bit of the second 16-bit insn to be set.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|make_parallel
name|PARAMS
argument_list|(
operator|(
name|CGEN_INSN_BYTES_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|make_parallel
parameter_list|(
name|buffer
parameter_list|)
name|CGEN_INSN_BYTES_PTR
name|buffer
decl_stmt|;
block|{
if|#
directive|if
name|CGEN_INT_INSN_P
operator|*
name|buffer
operator||=
literal|0x8000
expr_stmt|;
else|#
directive|else
name|buffer
index|[
name|CGEN_CPU_ENDIAN
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
operator|==
name|CGEN_ENDIAN_BIG
condition|?
literal|0
else|:
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Same as make_parallel except buffer contains the bytes in target order.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|target_make_parallel
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|target_make_parallel
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|buffer
index|[
name|CGEN_CPU_ENDIAN
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
operator|==
name|CGEN_ENDIAN_BIG
condition|?
literal|0
else|:
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble two instructions with an explicit parallel operation (||) or    sequential operation (->).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|assemble_two_insns
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|assemble_two_insns
parameter_list|(
name|str
parameter_list|,
name|str2
parameter_list|,
name|parallel_p
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|parallel_p
decl_stmt|;
block|{
name|char
modifier|*
name|str3
decl_stmt|;
name|m32r_insn
name|first
decl_stmt|;
name|m32r_insn
name|second
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|char
name|save_str2
init|=
operator|*
name|str2
decl_stmt|;
comment|/* Separate the two instructions.  */
operator|*
name|str2
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the two insns begin on a 32 bit boundary.      This is also done for the serial case (foo -> bar), relaxing doesn't      affect insns written like this.      Note that we must always do this as we can't assume anything about      whether we're currently on a 32 bit boundary or not.  Relaxing may      change this.  */
name|fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|first
operator|.
name|debug_sym_link
operator|=
name|debug_sym_link
expr_stmt|;
name|debug_sym_link
operator|=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Parse the first instruction.  */
if|if
condition|(
operator|!
operator|(
name|first
operator|.
name|insn
operator|=
name|m32r_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|first
operator|.
name|fields
argument_list|,
name|first
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check it.  */
if|if
condition|(
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|first
operator|.
name|fields
argument_list|)
operator|!=
literal|16
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"not a 16 bit instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|E_M32R2_ARCH
elseif|else
if|if
condition|(
operator|(
name|enable_m32rx
operator|==
literal|1
operator|)
comment|/* FIXME: Need standard macro to perform this test.  */
operator|&&
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32R2
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32R2 only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|enable_special_m32r
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
operator|)
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|enable_m32rx
comment|/* FIXME: Need standard macro to perform this test.  */
operator|&&
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|==
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32RX only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check to see if this is an allowable parallel insn.  */
if|if
condition|(
name|parallel_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_PIPE
argument_list|)
operator|==
name|PIPE_NONE
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' cannot be executed in parallel."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Restore the original assembly text, just in case it is needed.  */
operator|*
name|str2
operator|=
name|save_str2
expr_stmt|;
comment|/* Save the original string pointer.  */
name|str3
operator|=
name|str
expr_stmt|;
comment|/* Advanced past the parsed string.  */
name|str
operator|=
name|str2
operator|+
literal|2
expr_stmt|;
comment|/* Remember the entire string in case it is needed for error      messages.  */
name|str2
operator|=
name|str3
expr_stmt|;
comment|/* Convert the opcode to lower case.  */
block|{
name|char
modifier|*
name|s2
init|=
name|str
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s2
operator|++
argument_list|)
condition|)
continue|continue;
operator|--
name|s2
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
block|{
operator|*
name|s2
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
comment|/* Preserve any fixups that have been generated and reset the list      to empty.  */
name|gas_cgen_save_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the indices of the operands of the instruction.  */
comment|/* FIXME: CGEN_FIELDS is already recorded, but relying on that fact      doesn't seem right.  Perhaps allow passing fields like we do insn.  */
comment|/* FIXME: ALIAS insns do not have operands, so we use this function      to find the equivalent insn and overwrite the value stored in our      structure.  We still need the original insn, however, since this      may have certain attributes that are not present in the unaliased      version (eg relaxability).  When aliases behave differently this      may have to change.  */
name|first
operator|.
name|orig_insn
operator|=
name|first
operator|.
name|insn
expr_stmt|;
block|{
name|CGEN_FIELDS
name|tmp_fields
decl_stmt|;
name|first
operator|.
name|insn
operator|=
name|cgen_lookup_get_insn_operands
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|NULL
argument_list|,
name|INSN_VALUE
argument_list|(
name|first
operator|.
name|buffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|first
operator|.
name|indices
argument_list|,
operator|&
name|tmp_fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|.
name|insn
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: lookup/get operands failed"
argument_list|)
argument_list|)
expr_stmt|;
name|second
operator|.
name|debug_sym_link
operator|=
name|NULL
expr_stmt|;
comment|/* Parse the second instruction.  */
if|if
condition|(
operator|!
operator|(
name|second
operator|.
name|insn
operator|=
name|m32r_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|second
operator|.
name|fields
argument_list|,
name|second
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check it.  */
if|if
condition|(
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|second
operator|.
name|fields
argument_list|)
operator|!=
literal|16
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"not a 16 bit instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|E_M32R2_ARCH
elseif|else
if|if
condition|(
operator|(
name|enable_m32rx
operator|==
literal|1
operator|)
comment|/* FIXME: Need standard macro to perform this test.  */
operator|&&
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32R2
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32R2 only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|enable_special_m32r
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
operator|)
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|enable_m32rx
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|==
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32RX only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check to see if this is an allowable parallel insn.  */
if|if
condition|(
name|parallel_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_PIPE
argument_list|)
operator|==
name|PIPE_NONE
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' cannot be executed in parallel."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parallel_p
operator|&&
operator|!
name|enable_m32rx
condition|)
block|{
if|if
condition|(
name|CGEN_INSN_NUM
argument_list|(
name|first
operator|.
name|insn
argument_list|)
operator|!=
name|M32R_INSN_NOP
operator|&&
name|CGEN_INSN_NUM
argument_list|(
name|second
operator|.
name|insn
argument_list|)
operator|!=
name|M32R_INSN_NOP
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s': only the NOP instruction can be issued in parallel on the m32r"
argument_list|)
argument_list|,
name|str2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Get the indices of the operands of the instruction.  */
name|second
operator|.
name|orig_insn
operator|=
name|second
operator|.
name|insn
expr_stmt|;
block|{
name|CGEN_FIELDS
name|tmp_fields
decl_stmt|;
name|second
operator|.
name|insn
operator|=
name|cgen_lookup_get_insn_operands
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|NULL
argument_list|,
name|INSN_VALUE
argument_list|(
name|second
operator|.
name|buffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|second
operator|.
name|indices
argument_list|,
operator|&
name|tmp_fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|second
operator|.
name|insn
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: lookup/get operands failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We assume that if the first instruction writes to a register that is      read by the second instruction it is because the programmer intended      this to happen, (after all they have explicitly requested that these      two instructions be executed in parallel).  Although if the global      variable warn_explicit_parallel_conflicts is true then we do generate      a warning message.  Similarly we assume that parallel branch and jump      instructions are deliberate and should not produce errors.  */
if|if
condition|(
name|parallel_p
operator|&&
name|warn_explicit_parallel_conflicts
condition|)
block|{
if|if
condition|(
name|first_writes_to_seconds_operands
argument_list|(
operator|&
name|first
argument_list|,
operator|&
name|second
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* xgettext:c-format  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?"
argument_list|)
argument_list|,
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_writes_to_seconds_operands
argument_list|(
operator|&
name|second
argument_list|,
operator|&
name|first
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* xgettext:c-format  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?"
argument_list|)
argument_list|,
name|str2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parallel_p
operator|||
operator|(
name|errmsg
operator|=
operator|(
name|char
operator|*
operator|)
name|can_make_parallel
argument_list|(
operator|&
name|first
argument_list|,
operator|&
name|second
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Get the fixups for the first instruction.  */
name|gas_cgen_swap_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Write it out.  */
name|expand_debug_syms
argument_list|(
name|first
operator|.
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|first
operator|.
name|orig_insn
argument_list|,
name|first
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|first
operator|.
name|fields
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Force the top bit of the second insn to be set.  */
if|if
condition|(
name|parallel_p
condition|)
name|make_parallel
argument_list|(
name|second
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* Get its fixups.  */
name|gas_cgen_restore_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Write it out.  */
name|expand_debug_syms
argument_list|(
name|second
operator|.
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|second
operator|.
name|orig_insn
argument_list|,
name|second
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|second
operator|.
name|fields
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Try swapping the instructions to see if they work that way.  */
elseif|else
if|if
condition|(
name|can_make_parallel
argument_list|(
operator|&
name|second
argument_list|,
operator|&
name|first
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Write out the second instruction first.  */
name|expand_debug_syms
argument_list|(
name|second
operator|.
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|second
operator|.
name|orig_insn
argument_list|,
name|second
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|second
operator|.
name|fields
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Force the top bit of the first instruction to be set.  */
name|make_parallel
argument_list|(
name|first
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* Get the fixups for the first instruction.  */
name|gas_cgen_restore_fixups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Write out the first instruction.  */
name|expand_debug_syms
argument_list|(
name|first
operator|.
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|first
operator|.
name|orig_insn
argument_list|,
name|first
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|first
operator|.
name|fields
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"'%s': %s"
argument_list|,
name|str2
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
operator|||
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_HIDDEN_INST
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
operator|||
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_BIT_INST
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|first
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_FLOAT
argument_list|)
operator|||
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|second
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_FLOAT
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_FLOAT_INST
expr_stmt|;
comment|/* Set these so m32r_fill_insn can use them.  */
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|m32r_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|char
modifier|*
name|str2
init|=
name|NULL
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
comment|/* Look for a parallel instruction separator.  */
if|if
condition|(
operator|(
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"||"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|assemble_two_insns
argument_list|(
name|str
argument_list|,
name|str2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m32r_flags
operator||=
name|E_M32R_HAS_PARALLEL
expr_stmt|;
return|return;
block|}
comment|/* Also look for a sequential instruction separator.  */
if|if
condition|(
operator|(
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"->"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|assemble_two_insns
argument_list|(
name|str
argument_list|,
name|str2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|debug_sym_link
operator|=
name|debug_sym_link
expr_stmt|;
name|debug_sym_link
operator|=
operator|(
name|sym_linkS
operator|*
operator|)
literal|0
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|m32r_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|E_M32R2_ARCH
if|if
condition|(
operator|(
name|enable_m32rx
operator|==
literal|1
operator|)
comment|/* FIXME: Need standard macro to perform this test.  */
operator|&&
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32R2
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32R2 only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|enable_special_m32r
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|enable_special
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|enable_m32rx
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_MACH
argument_list|)
operator|==
operator|(
literal|1
operator|<<
name|MACH_M32RX
operator|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction '%s' is for the M32RX only"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_HIDDEN_INST
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_M32R
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_BIT_INST
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SPECIAL_FLOAT
argument_list|)
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_FLOAT_INST
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
operator|==
literal|32
condition|)
block|{
comment|/* 32 bit insns must live on 32 bit boundaries.  */
if|if
condition|(
name|prev_insn
operator|.
name|insn
operator|||
name|seen_relaxable_p
condition|)
block|{
comment|/* ??? If calling fill_insn too many times turns us into a memory 	     pig, can we call a fn to assemble a nop instead of 	     !seen_relaxable_p?  */
name|fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|expand_debug_syms
argument_list|(
name|insn
operator|.
name|debug_sym_link
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|on_32bit_boundary_p
decl_stmt|;
name|int
name|swap
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
operator|!=
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|.
name|orig_insn
operator|=
name|insn
operator|.
name|insn
expr_stmt|;
comment|/* If the previous insn was relaxable, then it may be expanded 	 to fill the current 16 bit slot.  Emit a NOP here to occupy 	 this slot, so that we can start at optimizing at a 32 bit 	 boundary.  */
if|if
condition|(
name|prev_insn
operator|.
name|insn
operator|&&
name|seen_relaxable_p
operator|&&
name|optimize
condition|)
name|fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_m32rx
condition|)
block|{
comment|/* Get the indices of the operands of the instruction. 	     FIXME: See assemble_parallel for notes on orig_insn.  */
block|{
name|CGEN_FIELDS
name|tmp_fields
decl_stmt|;
name|insn
operator|.
name|insn
operator|=
name|cgen_lookup_get_insn_operands
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|NULL
argument_list|,
name|INSN_VALUE
argument_list|(
name|insn
operator|.
name|buffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
name|insn
operator|.
name|indices
argument_list|,
operator|&
name|tmp_fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|.
name|insn
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: lookup/get operands failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute whether we're on a 32 bit boundary or not. 	 prev_insn.insn is NULL when we're on a 32 bit boundary.  */
name|on_32bit_boundary_p
operator|=
name|prev_insn
operator|.
name|insn
operator|==
name|NULL
expr_stmt|;
comment|/* Look to see if this instruction can be combined with the 	 previous instruction to make one, parallel, 32 bit instruction. 	 If the previous instruction (potentially) changed the flow of 	 program control, then it cannot be combined with the current 	 instruction.  If the current instruction is relaxable, then it 	 might be replaced with a longer version, so we cannot combine it. 	 Also if the output of the previous instruction is used as an 	 input to the current instruction then it cannot be combined. 	 Otherwise call can_make_parallel() with both orderings of the 	 instructions to see if they can be combined.  */
if|if
condition|(
operator|!
name|on_32bit_boundary_p
operator|&&
name|parallel
argument_list|()
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|orig_insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|writes_to_pc
argument_list|(
operator|&
name|prev_insn
argument_list|)
operator|&&
operator|!
name|first_writes_to_seconds_operands
argument_list|(
operator|&
name|prev_insn
argument_list|,
operator|&
name|insn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|can_make_parallel
argument_list|(
operator|&
name|prev_insn
argument_list|,
operator|&
name|insn
argument_list|)
operator|==
name|NULL
condition|)
name|make_parallel
argument_list|(
name|insn
operator|.
name|buffer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|can_make_parallel
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|prev_insn
argument_list|)
operator|==
name|NULL
condition|)
name|swap
operator|=
name|TRUE
expr_stmt|;
block|}
name|expand_debug_syms
argument_list|(
name|insn
operator|.
name|debug_sym_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|finished_insnS
name|fi
decl_stmt|;
comment|/* Ensure each pair of 16 bit insns is in the same frag.  */
name|frag_grow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|orig_insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
comment|/* relax_p  */
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
name|insn
operator|.
name|addr
operator|=
name|fi
operator|.
name|addr
expr_stmt|;
name|insn
operator|.
name|frag
operator|=
name|fi
operator|.
name|frag
expr_stmt|;
name|insn
operator|.
name|num_fixups
operator|=
name|fi
operator|.
name|num_fixups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fi
operator|.
name|num_fixups
condition|;
operator|++
name|i
control|)
name|insn
operator|.
name|fixups
index|[
name|i
index|]
operator|=
name|fi
operator|.
name|fixups
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|swap
condition|)
block|{
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
define|#
directive|define
name|SWAP_BYTES
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|tmp = a; a = b; b = tmp
comment|/* Swap the two insns */
name|SWAP_BYTES
argument_list|(
name|prev_insn
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|insn
operator|.
name|addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SWAP_BYTES
argument_list|(
name|prev_insn
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|insn
operator|.
name|addr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|target_make_parallel
argument_list|(
name|insn
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Swap any relaxable frags recorded for the two insns.  */
comment|/* FIXME: Clarify.  relaxation precludes parallel insns */
if|if
condition|(
name|prev_insn
operator|.
name|frag
operator|->
name|fr_opcode
operator|==
name|prev_insn
operator|.
name|addr
condition|)
name|prev_insn
operator|.
name|frag
operator|->
name|fr_opcode
operator|=
name|insn
operator|.
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|frag
operator|->
name|fr_opcode
operator|==
name|insn
operator|.
name|addr
condition|)
name|insn
operator|.
name|frag
operator|->
name|fr_opcode
operator|=
name|prev_insn
operator|.
name|addr
expr_stmt|;
comment|/* Update the addresses in any fixups. 	     Note that we don't have to handle the case where each insn is in 	     a different frag as we ensure they're in the same frag above.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prev_insn
operator|.
name|num_fixups
condition|;
operator|++
name|i
control|)
name|prev_insn
operator|.
name|fixups
index|[
name|i
index|]
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|.
name|num_fixups
condition|;
operator|++
name|i
control|)
name|insn
operator|.
name|fixups
index|[
name|i
index|]
operator|->
name|fx_where
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* Keep track of whether we've seen a pair of 16 bit insns. 	 prev_insn.insn is NULL when we're on a 32 bit boundary.  */
if|if
condition|(
name|on_32bit_boundary_p
condition|)
name|prev_insn
operator|=
name|insn
expr_stmt|;
else|else
name|prev_insn
operator|.
name|insn
operator|=
name|NULL
expr_stmt|;
comment|/* If the insn needs the following one to be on a 32 bit boundary 	 (e.g. subroutine calls), fill this insn's slot.  */
if|if
condition|(
name|on_32bit_boundary_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|orig_insn
argument_list|,
name|CGEN_INSN_FILL_SLOT
argument_list|)
operator|!=
literal|0
condition|)
name|fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a relaxable insn (can be replaced with a larger version) 	 mark the fact so that we can emit an alignment directive for a 	 following 32 bit insn if we see one.   */
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|orig_insn
argument_list|,
name|CGEN_INSN_RELAXABLE
argument_list|)
operator|!=
literal|0
condition|)
name|seen_relaxable_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set these so m32r_fill_insn can use them.  */
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The syntax in the manual says constants begin with '#'.    We just ignore it.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* .scomm pseudo-op handler.     This is a new pseudo-op to handle putting objects in .scommon.    By doing this the linker won't need to do any work,    and more importantly it removes the implicit -G arg necessary to    correctly link the object file.  */
end_comment

begin_function
specifier|static
name|void
name|m32r_scomm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|int
name|align2
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip ','.  */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".SCOMMon length (%ld.)<0! Ignored."
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* The third argument to .scomm is the alignment.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|8
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring bad alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Convert to a power of 2 alignment.  */
if|if
condition|(
name|align
condition|)
block|{
for|for
control|(
name|align2
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|align2
control|)
continue|continue;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Common alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align2
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|size
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Length of .scomm \"%s\" is already %ld. Not changed to %ld."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
init|=
name|now_seg
decl_stmt|;
name|int
name|old_subsec
init|=
name|now_subseg
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|record_alignment
argument_list|(
name|sbss_section
argument_list|,
name|align2
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|sbss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align2
condition|)
name|frag_align
argument_list|(
name|align2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|sbss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|sbss_section
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|align2
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
operator|&
name|scom_section
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_comment
comment|/* FIXME: Build table by hand, get it working, then machine generate.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:    1) most positive reach of this state,    2) most negative reach of this state,    3) how many bytes this mode will add to the size of the current frag    4) which index into the table to try if we can't fit into this one.  */
comment|/* The first entry must be unused because an `rlx_more' value of zero ends      each list.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* The displacement used by GAS is from the end of the 2 byte insn,      so we subtract 2 from the following.  */
comment|/* 16 bit insn, 8 bit disp -> 10 bit range.      This doesn't handle a branch in the right slot at the border:      the "& -4" isn't taken into account.  It's not important enough to      complicate things over it, so we subtract an extra 2 (or + 2 in -ve      case).  */
block|{
literal|511
operator|-
literal|2
operator|-
literal|2
block|,
operator|-
literal|512
operator|-
literal|2
operator|+
literal|2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* 32 bit insn, 24 bit disp -> 26 bit range.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* Same thing, but with leading nop for alignment.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|m32r_relax_frag
parameter_list|(
name|segment
parameter_list|,
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
comment|/* Address of branch insn.  */
name|long
name|address
init|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
literal|2
decl_stmt|;
name|long
name|growth
init|=
literal|0
decl_stmt|;
comment|/* Keep 32 bit insns aligned on 32 bit boundaries.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
literal|3
expr_stmt|;
name|growth
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
literal|2
expr_stmt|;
name|growth
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|growth
operator|=
name|relax_frag
argument_list|(
name|segment
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
comment|/* Long jump on odd halfword boundary?  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
operator|&&
operator|(
name|address
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
literal|3
expr_stmt|;
name|growth
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts    with a 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
comment|/* The only thing we have to handle here are symbols outside of the      current segment.  They may be undefined or in a different segment in      which case linker scripts may place them anywhere.      However, we can't finish the fragment here and emit the reloc as insn      alignment requirements may move the insn about.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|int old_fr_fix = fragP->fr_fix;
endif|#
directive|endif
comment|/* The symbol is undefined in this segment. 	 Change the relaxation subtype to the max allowable and leave 	 all further handling to md_convert_frag.  */
name|fragP
operator|->
name|fr_subtype
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Can't use this, but leave in for illustration.  */
comment|/* Change 16 bit insn to 32 bit insn.  */
block|fragP->fr_opcode[0] |= 0x80;
comment|/* Increase known (fixed) size of fragment.  */
block|fragP->fr_fix += 2;
comment|/* Create a relocation for it.  */
block|fix_new (fragP, old_fr_fix, 4, 	       fragP->fr_symbol, 	       fragP->fr_offset, 1
comment|/* pcrel  */
block|,
comment|/* FIXME: Can't use a real BFD reloc here. 		  gas_cgen_md_apply_fix3 can't handle it.  */
block|BFD_RELOC_M32R_26_PCREL);
comment|/* Mark this fragment as finished.  */
block|frag_wane (fragP);       return fragP->fr_fix - old_fr_fix;
else|#
directive|else
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update the recorded insn. 	   Fortunately we don't have to look very far. 	   FIXME: Change this to record in the instruction the next higher 	   relaxable insn to use.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|insn
operator|=
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|insn
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
argument_list|)
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXED
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
return|return
literal|2
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* *FRAGP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|char
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|displacement
decl_stmt|;
name|int
name|target_address
decl_stmt|;
name|int
name|opcode_address
decl_stmt|;
name|int
name|extension
decl_stmt|;
name|int
name|addend
decl_stmt|;
name|opcode
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address opcode resides at in file space.  */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
literal|1
case|:
name|extension
operator|=
literal|0
expr_stmt|;
name|displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|opcode
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
name|displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|opcode
index|[
literal|2
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator||
literal|0x80
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|opcode
argument_list|,
name|PAR_NOP_INSN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opcode_address
operator|+=
literal|2
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
name|displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|sec
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
comment|/* Symbol must be resolved by linker.  */
if|if
condition|(
name|fragP
operator|->
name|fr_offset
operator|&
literal|3
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Addend to unresolved symbol not on word boundary."
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_M32R_OLD_RELOC
name|addend
operator|=
name|fragP
operator|->
name|fr_offset
operator|>>
literal|2
expr_stmt|;
comment|/* Old M32R used USE_REL. */
else|#
directive|else
name|addend
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Address we want to reach in file space.  */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|addend
operator|=
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|&
operator|-
literal|4
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
comment|/* Create a relocation for symbols that must be resolved by the linker.      Otherwise output the completed insn.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|sec
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|fragP
operator|->
name|fr_subtype
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gas_cgen_record_fixup
argument_list|(
name|fragP
argument_list|,
comment|/* Offset of branch insn in frag.  */
name|fragP
operator|->
name|fr_fix
operator|+
name|extension
operator|-
literal|4
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|,
literal|4
comment|/* Length.  */
argument_list|,
comment|/* FIXME: quick hack.  */
if|#
directive|if
literal|0
argument_list|cgen_operand_lookup_by_num (gas_cgen_cpu_desc, 							 fragP->fr_cgen.opindex),
else|#
directive|else
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|M32R_OPERAND_DISP24
argument_list|)
argument_list|,
endif|#
directive|endif
name|fragP
operator|->
name|fr_cgen
operator|.
name|opinfo
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|n
parameter_list|)
value|((n) == 1 ? 1 : 3)
name|md_number_to_chars
argument_list|(
name|displacement
argument_list|,
operator|(
name|valueT
operator|)
name|addend
argument_list|,
name|SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section). 	 Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
operator|&
operator|-
literal|4L
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|fixP
parameter_list|)
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|M32R_OPERAND_DISP8
case|:
return|return
name|BFD_RELOC_M32R_10_PCREL
return|;
case|case
name|M32R_OPERAND_DISP16
case|:
return|return
name|BFD_RELOC_M32R_18_PCREL
return|;
case|case
name|M32R_OPERAND_DISP24
case|:
return|return
name|BFD_RELOC_M32R_26_PCREL
return|;
case|case
name|M32R_OPERAND_UIMM24
case|:
return|return
name|BFD_RELOC_M32R_24
return|;
case|case
name|M32R_OPERAND_HI16
case|:
case|case
name|M32R_OPERAND_SLO16
case|:
case|case
name|M32R_OPERAND_ULO16
case|:
comment|/* If low/high/shigh/sda was used, it is recorded in `opinfo'.  */
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
literal|0
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
break|break;
default|default:
comment|/* Avoid -Wall warning.  */
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Record a HI16 reloc for later matching with its LO16 cousin.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|m32r_record_hi16
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|fixS
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|m32r_record_hi16
parameter_list|(
name|reloc_type
parameter_list|,
name|fixP
parameter_list|,
name|seg
parameter_list|)
name|int
name|reloc_type
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|m32r_hi_fixup
modifier|*
name|hi_fixup
decl_stmt|;
name|assert
argument_list|(
name|reloc_type
operator|==
name|BFD_RELOC_M32R_HI16_SLO
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_M32R_HI16_ULO
argument_list|)
expr_stmt|;
name|hi_fixup
operator|=
operator|(
operator|(
expr|struct
name|m32r_hi_fixup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|m32r_hi_fixup
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|hi_fixup
operator|->
name|fixp
operator|=
name|fixP
expr_stmt|;
name|hi_fixup
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|hi_fixup
operator|->
name|next
operator|=
name|m32r_hi_fixup_list
expr_stmt|;
name|m32r_hi_fixup_list
operator|=
name|hi_fixup
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called while parsing an instruction to create a fixup.    We need to check for HI16 relocs and queue them up for later sorting.  */
end_comment

begin_function
name|fixS
modifier|*
name|m32r_cgen_record_fixup_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
init|=
name|gas_cgen_record_fixup_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|opinfo
argument_list|,
name|exp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|M32R_OPERAND_HI16
case|:
comment|/* If low/high/shigh/sda was used, it is recorded in `opinfo'.  */
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|==
name|BFD_RELOC_M32R_HI16_SLO
operator|||
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|==
name|BFD_RELOC_M32R_HI16_ULO
condition|)
name|m32r_record_hi16
argument_list|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
argument_list|,
name|fixP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Avoid -Wall warning */
break|break;
block|}
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Return BFD reloc type from opinfo field in a fixS.    It's tricky using fx_r_type in m32r_frob_file because the values    are BFD_RELOC_UNUSED + operand number.  */
end_comment

begin_define
define|#
directive|define
name|FX_OPINFO_R_TYPE
parameter_list|(
name|f
parameter_list|)
value|((f)->fx_cgen.opinfo)
end_define

begin_comment
comment|/* Sort any unmatched HI16 relocs so that they immediately precede    the corresponding LO16 reloc.  This is called before md_apply_fix3 and    tc_gen_reloc.  */
end_comment

begin_function
name|void
name|m32r_frob_file
parameter_list|()
block|{
name|struct
name|m32r_hi_fixup
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|m32r_hi_fixup_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|assert
argument_list|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_M32R_HI16_SLO
operator|||
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_M32R_HI16_ULO
argument_list|)
expr_stmt|;
comment|/* Check quickly whether the next fixup happens to be a matching low.  */
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
argument_list|)
operator|==
name|BFD_RELOC_M32R_LO16
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_addsy
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_offset
condition|)
continue|continue;
comment|/* Look through the fixups for this segment for a matching `low'.          When we find one, move the high/shigh just in front of it.  We do          this in two passes.  In the first pass, we try to find a          unique `low'.  In the second pass, we permit multiple high's          relocs for a single `low'.  */
name|seginfo
operator|=
name|seg_info
argument_list|(
name|l
operator|->
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|fixS
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fx_next
control|)
block|{
comment|/* Check whether this is a `low' fixup which matches l->fixp.  */
if|if
condition|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|f
argument_list|)
operator|==
name|BFD_RELOC_M32R_LO16
operator|&&
name|f
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|&&
name|f
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|&&
operator|(
name|pass
operator|==
literal|1
operator|||
name|prev
operator|==
name|NULL
operator|||
operator|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BFD_RELOC_M32R_HI16_SLO
operator|&&
name|FX_OPINFO_R_TYPE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BFD_RELOC_M32R_HI16_ULO
operator|)
operator|||
name|prev
operator|->
name|fx_addsy
operator|!=
name|f
operator|->
name|fx_addsy
operator|||
name|prev
operator|->
name|fx_offset
operator|!=
name|f
operator|->
name|fx_offset
operator|)
condition|)
block|{
name|fixS
modifier|*
modifier|*
name|pf
decl_stmt|;
comment|/* Move l->fixp before f.  */
for|for
control|(
name|pf
operator|=
operator|&
name|seginfo
operator|->
name|fix_root
init|;
operator|*
name|pf
operator|!=
name|l
operator|->
name|fixp
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|fx_next
control|)
name|assert
argument_list|(
operator|*
name|pf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|l
operator|->
name|fixp
operator|->
name|fx_next
expr_stmt|;
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|seginfo
operator|->
name|fix_root
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
else|else
name|prev
operator|->
name|fx_next
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|pass
operator|==
literal|1
operator|&&
name|warn_unmatched_high
condition|)
name|as_warn_where
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_file
argument_list|,
name|l
operator|->
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unmatched high/shigh reloc"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|m32r_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
if|if
condition|(
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|m32r_relax
condition|)
return|return
literal|0
return|;
return|return
name|fix
operator|->
name|fx_pcrel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes          here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|m32r_elf_section_change_hook
parameter_list|()
block|{
comment|/* If we have reached the end of a section and we have just emitted a      16 bit insn, then emit a nop to make sure that the section ends on      a 32 bit boundary.  */
if|if
condition|(
name|prev_insn
operator|.
name|insn
operator|||
name|seen_relaxable_p
condition|)
operator|(
name|void
operator|)
name|m32r_fill_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if can adjust the reloc to be relative to its section    (such as .data) instead of relative to some symbol.  */
end_comment

begin_function
name|bfd_boolean
name|m32r_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|NULL
decl_stmt|;
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Prevent all adjustments to global symbols.  */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pic_code
operator|&&
operator|(
name|reloc_type
operator|==
name|BFD_RELOC_M32R_24
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_M32R_26_PCREL
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_M32R_HI16_SLO
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_M32R_HI16_ULO
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_M32R_LO16
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|m32r_elf_final_processing
parameter_list|()
block|{
if|if
condition|(
name|use_parallel
condition|)
name|m32r_flags
operator||=
name|E_M32R_HAS_PARALLEL
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|m32r_flags
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|GOT_NAME
value|"_GLOBAL_OFFSET_TABLE_"
end_define

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format. */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|pic_code
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_M32R_26_PCREL
case|:
name|code
operator|=
name|BFD_RELOC_M32R_26_PLTREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M32R_24
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_M32R_GOTPC24
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_M32R_GOT24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M32R_HI16_ULO
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_M32R_GOTPC_HI_ULO
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_M32R_GOT16_HI_ULO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M32R_HI16_SLO
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_M32R_GOTPC_HI_SLO
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_M32R_GOT16_HI_SLO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M32R_LO16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_M32R_GOTPC_LO
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_M32R_GOT16_LO
expr_stmt|;
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|" => %s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|" => %s\n"
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Use fx_offset for these cases */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pic_code
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|section
operator|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
comment|/* already used fx_offset in the opcode field itseld. */
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

