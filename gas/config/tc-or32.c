begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Assembly backend for the OpenRISC 1000.    Copyright (C) 2002 Free Software Foundation, Inc.    Contributed by Damjan Lampret<lampret@opencores.org>.    Modified bu Johan Rydberg,<johan.rydberg@netinsight.se>.    Based upon a29k port.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* tc-a29k.c used as a template.  */
end_comment

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"opcode/or32.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_include
include|#
directive|include
file|"elf/or32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|'%'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make it easier to clone this machine desc into another one.  */
end_comment

begin_define
define|#
directive|define
name|machine_opcode
value|or32_opcode
end_define

begin_define
define|#
directive|define
name|machine_opcodes
value|or32_opcodes
end_define

begin_define
define|#
directive|define
name|machine_ip
value|or32_ip
end_define

begin_define
define|#
directive|define
name|machine_it
value|or32_it
end_define

begin_comment
comment|/* Handle of the OPCODE hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|machine_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlistp
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|reloc_offset
decl_stmt|;
comment|/* Offset of reloc within insn.  */
name|int
name|reloc
decl_stmt|;
block|}
name|the_insn
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|machine_ip
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|4
block|}
block|,
block|{
literal|"space"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"cputype"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"reg"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
comment|/* Register equate, same as equ.  */
block|{
literal|"sect"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Creation of coff sections.  */
block|{
literal|"proc"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Start of a function.  */
block|{
literal|"endproc"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Function end.  */
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_HEADERS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|RELSZ
end_ifdef

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
name|RELSZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coff headers.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Something else headers.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not bfdized.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.    If the pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.  */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We needed an unused char for line separation to work around the    lack of macros, using sed and such.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.    As in 0f12.456    or    0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "l.jalr r9" precalculated opcode.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|jalr_r9_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_invalid_opcode
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|machine_opcode
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|,
name|signed
name|long
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set bits in machine opcode according to insn->encoding    description and passed operand.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|insn
parameter_list|,
name|opcode
parameter_list|,
name|param_val
parameter_list|,
name|param_ch
parameter_list|)
specifier|const
name|struct
name|machine_opcode
modifier|*
name|insn
decl_stmt|;
name|unsigned
name|long
modifier|*
name|opcode
decl_stmt|;
name|signed
name|long
name|param_val
decl_stmt|;
name|char
name|param_ch
decl_stmt|;
block|{
name|int
name|opc_pos
init|=
literal|0
decl_stmt|;
name|int
name|param_pos
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|enc
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    encode:  opcode=%.8lx  param_val=%.8lx abs=%.8lx param_ch=%c\n"
argument_list|,
operator|*
name|opcode
argument_list|,
name|param_val
argument_list|,
name|abs
argument_list|(
name|param_val
argument_list|)
argument_list|,
name|param_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|enc
operator|=
name|insn
operator|->
name|encoding
init|;
operator|*
name|enc
operator|!=
literal|'\0'
condition|;
name|enc
operator|++
control|)
if|if
condition|(
operator|*
name|enc
operator|==
name|param_ch
condition|)
block|{
if|if
condition|(
name|enc
operator|-
literal|2
operator|>=
name|insn
operator|->
name|encoding
operator|&&
operator|(
operator|*
operator|(
name|enc
operator|-
literal|2
operator|)
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|enc
operator|-
literal|1
operator|)
operator|==
literal|'x'
operator|)
condition|)
continue|continue;
else|else
name|param_pos
operator|++
expr_stmt|;
block|}
name|opc_pos
operator|=
literal|32
expr_stmt|;
for|for
control|(
name|enc
operator|=
name|insn
operator|->
name|encoding
init|;
operator|*
name|enc
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|enc
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|enc
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|)
condition|)
block|{
name|int
name|tmp
init|=
name|strtol
argument_list|(
name|enc
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|opc_pos
operator|-=
literal|4
expr_stmt|;
operator|*
name|opcode
operator||=
name|tmp
operator|<<
name|opc_pos
expr_stmt|;
name|enc
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|enc
operator|==
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|enc
operator|==
literal|'-'
operator|)
condition|)
block|{
name|opc_pos
operator|--
expr_stmt|;
name|enc
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|enc
operator|==
literal|'1'
condition|)
block|{
name|opc_pos
operator|--
expr_stmt|;
operator|*
name|opcode
operator||=
literal|1
operator|<<
name|opc_pos
expr_stmt|;
name|enc
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|enc
operator|==
name|param_ch
condition|)
block|{
name|opc_pos
operator|--
expr_stmt|;
name|param_pos
operator|--
expr_stmt|;
operator|*
name|opcode
operator||=
operator|(
operator|(
name|param_val
operator|>>
name|param_pos
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|opc_pos
expr_stmt|;
name|enc
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
name|enc
argument_list|)
condition|)
block|{
name|opc_pos
operator|--
expr_stmt|;
name|enc
operator|++
expr_stmt|;
block|}
else|else
name|enc
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    opcode=%.8lx\n"
argument_list|,
operator|*
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc., that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|int
name|skipnext
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Hash up all the opcodes for fast use later.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|or32_num_opcodes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|skipnext
condition|)
block|{
name|skipnext
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|machine_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't hash `%s': %s\n"
argument_list|,
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
name|encode
argument_list|(
operator|&
name|machine_opcodes
index|[
name|insn_index
argument_list|(
literal|"l.jalr"
argument_list|)
index|]
argument_list|,
operator|&
name|jalr_r9_opcode
argument_list|,
literal|9
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non zero if instruction is to be used.  */
end_comment

begin_function
specifier|static
name|int
name|check_invalid_opcode
parameter_list|(
name|opcode
parameter_list|)
name|unsigned
name|long
name|opcode
decl_stmt|;
block|{
return|return
name|opcode
operator|==
name|jalr_r9_opcode
return|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction.  Its label has already been handled    by the generic front end.  We just parse opcode and operands, and    produce the bytes of data and relocation.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|toP
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"NEW INSTRUCTION\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|machine_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Put out the opcode.  */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Put out the symbol-dependent stuff.  */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
else|#
directive|else
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|NO_RELOC
condition|)
endif|#
directive|endif
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|the_insn
operator|.
name|reloc_offset
operator|)
argument_list|,
literal|4
argument_list|,
comment|/* size */
operator|&
name|the_insn
operator|.
name|exp
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is true of the we have issued a "lo(" or "hi"(.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|waiting_for_shift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mask_or_shift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|parse_operand
parameter_list|(
name|s
parameter_list|,
name|operandp
parameter_list|,
name|opt
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|operandp
decl_stmt|;
name|int
name|opt
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  PROCESS NEW OPERAND(%s) == %c (%d)\n"
argument_list|,
name|s
argument_list|,
name|opt
condition|?
name|opt
else|:
literal|'!'
argument_list|,
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|input_line_pointer
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"HI("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|waiting_for_shift
operator|=
literal|1
expr_stmt|;
name|mask_or_shift
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"LO("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask_or_shift
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|mask_or_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'('
operator|)
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'r'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'r'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|operandp
operator|->
name|X_add_number
operator|=
name|strtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|operandp
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|s
operator|!=
literal|','
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\0'
operator|)
condition|;
control|)
name|s
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|s
return|;
block|}
name|expression
argument_list|(
name|operandp
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
if|if
condition|(
operator|!
name|opt
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|operandp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|operandp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
block|}
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  %s=parse_operand(%s): operandp->X_op = %u\n"
argument_list|,
name|new
argument_list|,
name|s
argument_list|,
name|operandp
operator|->
name|X_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|new
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|char
modifier|*
name|parse_operand
parameter_list|(
name|s
parameter_list|,
name|operandp
parameter_list|,
name|opt
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|operandp
decl_stmt|;
name|int
name|opt
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  PROCESS NEW OPERAND(%s) == %c (%d)\n"
argument_list|,
name|s
argument_list|,
name|opt
condition|?
name|opt
else|:
literal|'!'
argument_list|,
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|input_line_pointer
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"HI("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|waiting_for_shift
operator|=
literal|1
expr_stmt|;
name|mask_or_shift
operator|=
name|RELOC_CONSTH
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"LO("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask_or_shift
operator|=
name|RELOC_CONST
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|mask_or_shift
operator|=
literal|0
expr_stmt|;
name|expression
argument_list|(
name|operandp
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
if|if
condition|(
operator|!
name|opt
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|operandp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|operandp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
block|}
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
if|if
condition|(
operator|(
name|operandp
operator|->
name|X_op
operator|==
name|O_symbol
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'_'
operator|)
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"symbol: '%s'\n"
argument_list|,
name|save
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|save
operator|=
name|s
init|;
name|s
operator|<
name|new
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
name|REGISTER_PREFIX
operator|)
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'r'
operator|)
condition|)
comment|/* Register prefix.  */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'r'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|operandp
operator|->
name|X_add_number
operator|=
name|strtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|operandp
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
block|}
name|s
operator|=
name|save
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  %s=parse_operand(%s): operandp->X_op = %u\n"
argument_list|,
name|new
argument_list|,
name|s
argument_list|,
name|operandp
operator|->
name|X_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|new
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Instruction parsing.  Takes a string containing the opcode.    Operands are at input_line_pointer.  Output is in the_insn.    Warnings or errors are generated.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|void
name|machine_ip
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|struct
name|machine_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|expressionS
name|the_operand
decl_stmt|;
name|expressionS
modifier|*
name|operand
init|=
operator|&
name|the_operand
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|reloc
init|=
name|BFD_RELOC_NONE
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"machine_ip(%s)\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
name|ISALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'.'
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
comment|/* FIXME-SOMEDAY more whitespace.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode1: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|machine_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode2 `%s'."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
name|opcode
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the      operands match.       If an operand matches, we modify the_insn or opcode appropriately,      and do a "continue".  If an operand fails to match, we "break".  */
if|if
condition|(
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Prime the pump.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  args = %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* End of args.  */
comment|/* We have have 0 args, do the bazoooka!  */
if|if
condition|(
name|args
operator|==
name|insn
operator|->
name|args
condition|)
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* We are truly done.  */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
if|if
condition|(
name|check_invalid_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction not allowed: %s"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many operands: %s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Must match a comma.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* Parse next operand.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|args
index|[
literal|1
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    ',' case: operand->X_add_number = %d, *args = %s, *s = %s\n"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
name|args
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
comment|/* Must match a (.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|args
index|[
literal|1
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
comment|/* Must match a ).  */
continue|continue;
case|case
literal|'r'
case|:
comment|/* A general register.  */
name|args
operator|++
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|X_op
operator|!=
name|O_register
condition|)
break|break;
comment|/* Only registers.  */
name|know
argument_list|(
name|operand
operator|->
name|X_add_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operand
operator|->
name|X_op_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|operand
operator|->
name|X_add_number
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|regno
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    r: operand->X_op = %d\n"
argument_list|,
name|operand
operator|->
name|X_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
default|default:
comment|/* if (! ISALPHA (*args))                break;  */
comment|/* Only immediate values.  */
if|if
condition|(
name|mask_or_shift
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"mask_or_shift = %d\n"
argument_list|,
name|mask_or_shift
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|mask_or_shift
expr_stmt|;
block|}
name|mask_or_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"LO("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"HI("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_consth\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|operand
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|#
directive|if
literal|0
block|operand->X_add_number = 0;
comment|/* ??? if enabled load/store offsets 					    are zero.  */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    default case: operand->X_add_number = %d, *args = %s, *s = %s\n"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
name|args
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
block|{
name|bfd_vma
name|v
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x3ffffff
expr_stmt|;
name|v
operator|=
name|abs
argument_list|(
name|operand
operator|->
name|X_add_number
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"call/jmp target out of range (1)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_HI16
condition|)
name|operand
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
comment|/*             the_insn.reloc = BFD_RELOC_NONE; */
continue|continue;
block|}
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
comment|/* the_insn.reloc = insn->reloc;  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    reloc sym=%d\n"
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    BFD_RELOC_NONE=%d\n"
argument_list|,
name|BFD_RELOC_NONE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
comment|/*  the_insn.reloc_offset = 1;  */
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
comment|/* Assume PC-relative jump.  */
comment|/* FIXME-SOON, Do we figure out whether abs later, after              know sym val?  */
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_LO16
operator|||
name|reloc
operator|==
name|BFD_RELOC_HI16
condition|)
name|the_insn
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Types or values of args don't match.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|machine_ip
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|struct
name|machine_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|expressionS
name|the_operand
decl_stmt|;
name|expressionS
modifier|*
name|operand
init|=
operator|&
name|the_operand
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|reloc
init|=
name|NO_RELOC
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"machine_ip(%s)\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
name|ISALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'.'
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
comment|/* FIXME-SOMEDAY more whitespace.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode1: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|machine_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode2 `%s'."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
name|opcode
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the      operands match.       If an operand matches, we modify the_insn or opcode appropriately,      and do a "continue".  If an operand fails to match, we "break".  */
if|if
condition|(
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* Prime the pump.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'I'
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"l.nop"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  args = %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* End of args.  */
comment|/* We have have 0 args, do the bazoooka!  */
if|if
condition|(
name|args
operator|==
name|insn
operator|->
name|args
condition|)
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* We are truly done.  */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
if|if
condition|(
name|check_invalid_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction not allowed: %s"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many operands: %s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Must match a comma.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* Parse next operand.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|args
index|[
literal|1
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    ',' case: operand->X_add_number = %d, *args = %s, *s = %s\n"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
name|args
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
comment|/* Must match a (.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|args
index|[
literal|1
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
comment|/* Must match a ).  */
continue|continue;
case|case
literal|'r'
case|:
comment|/* A general register.  */
name|args
operator|++
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|X_op
operator|!=
name|O_register
condition|)
break|break;
comment|/* Only registers.  */
name|know
argument_list|(
name|operand
operator|->
name|X_add_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operand
operator|->
name|X_op_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|operand
operator|->
name|X_add_number
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|regno
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    r: operand->X_op = %d\n"
argument_list|,
name|operand
operator|->
name|X_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
default|default:
comment|/* if (! ISALPHA (*args))                break;  */
comment|/* Only immediate values.  */
if|if
condition|(
name|mask_or_shift
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"mask_or_shift = %d\n"
argument_list|,
name|mask_or_shift
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|mask_or_shift
expr_stmt|;
block|}
name|mask_or_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"LO("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|RELOC_CONST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"HI("
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_consth\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|=
name|RELOC_CONSTH
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|operand
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|#
directive|if
literal|0
block|operand->X_add_number = 0;
comment|/* ??? if enabled load/store offsets 					    are zero.  */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    default case: operand->X_add_number = %d, *args = %s, *s = %s\n"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
name|args
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|reloc
operator|==
name|NO_RELOC
condition|)
block|{
name|unsigned
name|long
name|v
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x3ffffff
expr_stmt|;
name|v
operator|=
name|abs
argument_list|(
name|operand
operator|->
name|X_add_number
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"call/jmp target out of range (1)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reloc
operator|==
name|RELOC_CONSTH
condition|)
name|operand
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
comment|/* the_insn.reloc = NO_RELOC; */
continue|continue;
block|}
if|if
condition|(
name|reloc
operator|==
name|NO_RELOC
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_JUMPTARG
expr_stmt|;
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"    reloc sym=%d\n"
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    NO_RELOC=%d\n"
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
comment|/*  the_insn.reloc_offset = 1;  */
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
comment|/* Assume PC-relative jump.  */
comment|/* FIXME-SOON, Do we figure out whether abs later, after              know sym val?  */
if|if
condition|(
name|reloc
operator|==
name|RELOC_CONST
operator|||
name|reloc
operator|==
name|RELOC_CONSTH
condition|)
name|the_insn
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
name|encode
argument_list|(
name|insn
argument_list|,
operator|&
name|opcode
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Types or values of args don't match.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is identical to the md_atof in m68k.c.  I think this is right,    but I'm not sure.     Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP .  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write out big-endian.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|val
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|long
name|t_val
decl_stmt|;
name|t_val
operator|=
operator|(
name|long
operator|)
operator|*
name|val
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"md_apply_fix val:%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fixP
operator|->
name|fx_addnumber
operator|=
name|t_val
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
name|know
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_NONE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
comment|/* XXXXXXXX pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const: val=%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
name|t_val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|t_val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|t_val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|t_val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
comment|/* XXXX0000 pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const: val=%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
name|t_val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|t_val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
comment|/* XX000000 pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const: val=%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
name|t_val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
comment|/* 0000XXXX pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const: val=%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|2
index|]
operator|=
name|t_val
operator|>>
literal|8
expr_stmt|;
comment|/* Holds bits 0000XXXX.  */
name|buf
index|[
literal|3
index|]
operator|=
name|t_val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
comment|/* 0000XXXX pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_consth: val=%x\n"
argument_list|,
name|t_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|2
index|]
operator|=
name|t_val
operator|>>
literal|24
expr_stmt|;
comment|/* Holds bits XXXX0000.  */
name|buf
index|[
literal|3
index|]
operator|=
name|t_val
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
comment|/* 0000XXXX pattern in a word.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* The linker tries to support both AMD and old GNU style              R_IREL relocs.  That means that if the addend is exactly              the negative of the address within the section, the              linker will not handle it correctly.  */
if|#
directive|if
literal|0
block|if (fixP->fx_pcrel&& t_val != 0&& t_val == - (fixP->fx_frag->fr_address + fixP->fx_where))             as_bad_where               (fixP->fx_file, fixP->fx_line,                _("the linker will not handle this relocation correctly (1)"));
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|long
name|v
init|=
name|t_val
operator|>>
literal|28
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|v
operator|!=
operator|-
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"call/jmp target out of range (2)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This case was supposed to be handled in machine_ip.  */
name|abort
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|t_val
operator|>>
literal|26
operator|)
operator|&
literal|0x03
expr_stmt|;
comment|/* Holds bits 0FFFFFFC of address.  */
name|buf
index|[
literal|1
index|]
operator|=
name|t_val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|t_val
operator|>>
literal|10
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|t_val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relocation type: 0x%02x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"md_apply_fix val:%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
name|know
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* This is a hack.  There should be a better way to handle this.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_WDISP30
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
name|val
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_8
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP30
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_HI22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
break|break;
case|case
name|RELOC_LO10
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x03
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_BASE13
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP22
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RELOC_BASE22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_JUMPTARG
case|:
comment|/* 0000XXXX pattern in a word.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* The linker tries to support both AMD and old GNU style              R_IREL relocs.  That means that if the addend is exactly              the negative of the address within the section, the              linker will not handle it correctly.  */
if|#
directive|if
literal|0
block|if (fixP->fx_pcrel&& val != 0&& val == - (fixP->fx_frag->fr_address + fixP->fx_where))             as_bad_where               (fixP->fx_file, fixP->fx_line,                _("the linker will not handle this relocation correctly (1)"));
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|long
name|v
init|=
name|val
operator|>>
literal|28
decl_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|v
operator|!=
operator|-
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"call/jmp target out of range (2)"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* This case was supposed to be handled in machine_ip.  */
name|abort
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x03
expr_stmt|;
comment|/* Holds bits 0FFFFFFC of address.  */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|RELOC_CONST
case|:
comment|/* 0000XXXX pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_const: val=%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* Holds bits 0000XXXX.  */
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_CONSTH
case|:
comment|/* 0000XXXX pattern in a word.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"reloc_consth: val=%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
comment|/* Holds bits XXXX0000.  */
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NO_RELOC
case|:
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relocation type: 0x%02x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"tc_coff_fix2rtype\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
return|return
operator|(
name|R_WORD
operator|)
return|;
case|case
name|RELOC_8
case|:
return|return
operator|(
name|R_BYTE
operator|)
return|;
case|case
name|RELOC_CONST
case|:
return|return
operator|(
name|R_ILOHALF
operator|)
return|;
case|case
name|RELOC_CONSTH
case|:
return|return
operator|(
name|R_IHIHALF
operator|)
return|;
case|case
name|RELOC_JUMPTARG
case|:
return|return
operator|(
name|R_IREL
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"need %d\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/* Should never be called for or32.  */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"or32_create_short_jmp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for or32.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"or32_convert_frag\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"or32_convert_frag\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Should never be called for or32.  */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"or32_create_long_jump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for or32.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"or32_estimate_size_before_relax\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to target format.     On sparc/29k: first 4 bytes are normal unsigned long address, next three    bytes are index, most sig. byte first.  Byte 7 is broken up with    bit 7 as external, bits 6& 5 unused, and the lower    five bits as relocation type.  Next 4 bytes are long addend.  */
end_comment

begin_comment
comment|/* Thanx and a tip of the hat to Michael Bloom, mb@ttidca.tti.com.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|long
name|r_symbolnum
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"tc_aout_fix_to_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_NONE
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
literal|0
operator|&
literal|0x60
operator|)
operator||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|&
literal|0x1F
operator|)
expr_stmt|;
comment|/* Also easy.  */
name|md_number_to_chars
argument_list|(
operator|&
name|where
index|[
literal|8
index|]
argument_list|,
name|fixP
operator|->
name|fx_addnumber
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called when a line is unrecognized.  This is used to handle    definitions of or32 style local labels.  */
end_comment

begin_function
name|int
name|or32_unrecognized_line
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|lab
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'$'
operator|||
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|lab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
block|{
name|lab
operator|=
name|lab
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
comment|/* Not a label definition.  */
return|return
literal|0
return|;
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"label \"$%d\" redefined"
argument_list|)
argument_list|,
name|lab
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|define_dollar_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_comment
comment|/* Record a fixup for a cons expression.  */
end_comment

begin_comment
comment|/*   void or32_cons_fix_new (frag, where, nbytes, exp)      fragS *frag;      int where;      int nbytes;      expressionS *exp; {   fix_new_exp (frag, where, nbytes, exp, 0, 		   nbytes == 5 ? RELOC_32                    : nbytes == 2 ? RELOC_16 		   : RELOC_8); } void tc_aout_pre_write_hook () { #if DEBUG   printf ("In tc_aout_pre_write_hook()\n"); #endif } */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default the values of symbols known that should be "predefined".  We    don't bother to predefine them unless you actually use one, since there    are a lot of them.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
name|long
name|regnum
decl_stmt|;
name|char
name|testbuf
index|[
literal|5
operator|+
comment|/*SLOP*/
literal|5
index|]
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"md_undefined_symbol(%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Register name.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'R'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'a'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'b'
condition|)
block|{
comment|/* Parse the number, make sure it has no extra zeroes or          trailing chars.  */
name|regnum
operator|=
name|atol
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>
literal|31
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"register out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|testbuf
argument_list|,
literal|"%ld"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|testbuf
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* gr007 or lr7foo or whatever.  */
comment|/* We have a wiener!  Define and return a new symbol for it.  */
return|return
operator|(
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_REGISTER
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"  md_operand(input_line_pointer = %s)\n"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
name|REGISTER_PREFIX
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
comment|/* We have a numeric register expression.  No biggy.  */
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Skip %r */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_constant
operator|||
name|expressionP
operator|->
name|X_add_number
operator|>
literal|255
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid expression after %%%%\n"
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* We are taking the 'address' of a register...this one is not          in the manual, but it *is* in traps/fpsymbol.h!  What they          seem to want is the register number, as an absolute number.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip& */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register in& expression"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|long
name|lab
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* This is a local label.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|lab
operator|=
operator|(
name|long
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|fieldnum
decl_stmt|,
name|fieldlimit
decl_stmt|;
name|LITTLENUM_TYPE
name|floatbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* $float(), $doubleN(), or $extendN() convert floating values          to integers.  */
name|s
operator|=
name|input_line_pointer
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|fieldnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"double"
argument_list|,
sizeof|sizeof
expr|"double"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"double"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'d'
expr_stmt|;
name|fieldlimit
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"float"
argument_list|,
sizeof|sizeof
expr|"float"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"float"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'f'
expr_stmt|;
name|fieldlimit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"extend"
argument_list|,
sizeof|sizeof
expr|"extend"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"extend"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'x'
expr_stmt|;
name|fieldlimit
operator|=
literal|4
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|fieldnum
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|fieldnum
operator|>=
name|fieldlimit
condition|)
return|return;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
return|return;
operator|++
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|s
operator|=
name|atof_ieee
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|floatbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|s
operator|=
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|')'
condition|)
return|return;
operator|++
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|floatbuf
index|[
name|fieldnum
operator|*
literal|2
index|]
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|+
name|floatbuf
index|[
name|fieldnum
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine.  */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the 29000, they're relative to the address of the instruction,    which we have set up as the address of the fixup too.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc for a fixup.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/*  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where + fixp->fx_addnumber;*/
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

