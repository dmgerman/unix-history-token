begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-msp430.c -- Assembler code for the Texas Instruments MSP430    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007   Free Software Foundation, Inc.   Contributed by Dmitry Diky<diwil@mail.ru>    This file is part of GAS, the GNU Assembler.    GAS is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2, or (at your option)   any later version.    GAS is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.    You should have received a copy of the GNU General Public License   along with GAS; see the file COPYING.  If not, write to   the Free Software Foundation, 51 Franklin Street - Fifth Floor,   Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|PUSH_1X_WORKAROUND
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/msp430.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_comment
comment|/*    We will disable polymorphs by default because it is dangerous.    The potential problem here is the following: assume we got the    following code:  	jump .l1 	nop 	jump  subroutine	; external symbol       .l1: 	nop 	ret        In case of assembly time relaxation we'll get: 	0: jmp .l1<.text +0x08> (reloc deleted) 	2: nop 	4: br subroutine     .l1: 	8: nop 	10: ret     If the 'subroutine' wiys thin +-1024 bytes range then linker    will produce 	0: jmp .text +0x08 	2: nop 	4: jmp subroutine 	.l1: 	6: nop 	8: ret	; 'jmp .text +0x08' will land here. WRONG!!!      The workaround is the following:    1. Declare global var enable_polymorphs which set to 1 via option -mP.    2. Declare global var enable_relax	which set to 1 via option -mQ.     If polymorphs are enabled, and relax isn't, treat all jumps as long jumps,    do not delete any relocs and leave them for linker.        If relax is enabled, relax at assembly time and kill relocs as necessary.  */
end_comment

begin_decl_stmt
name|int
name|msp430_enable_relax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msp430_enable_polys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GCC uses the some condition codes which we'll    implement as new polymorph instructions.       COND	EXPL	   SHORT JUMP	LONG JUMP    ===============================================    eq	==	   jeq 		jne +4; br lab    ne	!=	   jne 		jeq +4; br lab     ltn honours no-overflow flag    ltn<	   jn 		jn +2;  jmp +4; br lab     lt<	   jl 		jge +4;	br lab     ltu<	   jlo 		lhs +4; br lab    le<= see below    leu<= see below     gt>  see below    gtu>  see below    ge>=	   jge 		jl +4; br lab    geu>=	   jhs 		jlo +4; br lab    ===============================================     Therefore, new opcodes are (BranchEQ -> beq; and so on...)    beq,bne,blt,bltn,bltu,bge,bgeu    'u' means unsigned compares        Also, we add 'jump' instruction:    jump	UNCOND	-> jmp		br lab     They will have fmt == 4, and insn_opnumb == number of instruction.  */
end_comment

begin_struct
struct|struct
name|rcodes_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Corresponding insn_opnumb.  */
name|int
name|sop
decl_stmt|;
comment|/* Opcode if jump length is short.  */
name|long
name|lpos
decl_stmt|;
comment|/* Label position.  */
name|long
name|lop0
decl_stmt|;
comment|/* Opcode 1 _word_ (16 bits).  */
name|long
name|lop1
decl_stmt|;
comment|/* Opcode second word.  */
name|long
name|lop2
decl_stmt|;
comment|/* Opcode third word.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSP430_RLC
parameter_list|(
name|n
parameter_list|,
name|i
parameter_list|,
name|sop
parameter_list|,
name|o1
parameter_list|)
define|\
value|{#n, i, sop, 2, (o1 + 2), 0x4010, 0}
end_define

begin_decl_stmt
specifier|static
name|struct
name|rcodes_s
name|msp430_rcodes
index|[]
init|=
block|{
name|MSP430_RLC
argument_list|(
name|beq
argument_list|,
literal|0
argument_list|,
literal|0x2400
argument_list|,
literal|0x2000
argument_list|)
block|,
name|MSP430_RLC
argument_list|(
name|bne
argument_list|,
literal|1
argument_list|,
literal|0x2000
argument_list|,
literal|0x2400
argument_list|)
block|,
name|MSP430_RLC
argument_list|(
name|blt
argument_list|,
literal|2
argument_list|,
literal|0x3800
argument_list|,
literal|0x3400
argument_list|)
block|,
name|MSP430_RLC
argument_list|(
name|bltu
argument_list|,
literal|3
argument_list|,
literal|0x2800
argument_list|,
literal|0x2c00
argument_list|)
block|,
name|MSP430_RLC
argument_list|(
name|bge
argument_list|,
literal|4
argument_list|,
literal|0x3400
argument_list|,
literal|0x3800
argument_list|)
block|,
name|MSP430_RLC
argument_list|(
name|bgeu
argument_list|,
literal|5
argument_list|,
literal|0x2c00
argument_list|,
literal|0x2800
argument_list|)
block|,
block|{
literal|"bltn"
block|,
literal|6
block|,
literal|0x3000
block|,
literal|3
block|,
literal|0x3000
operator|+
literal|1
block|,
literal|0x3c00
operator|+
literal|2
block|,
literal|0x4010
block|}
block|,
block|{
literal|"jump"
block|,
literal|7
block|,
literal|0x3c00
block|,
literal|1
block|,
literal|0x4010
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|MSP430_RLC
end_undef

begin_comment
comment|/* More difficult than above and they have format 5.        COND	EXPL	SHORT			LONG    =================================================================    gt>	jeq +2; jge label	jeq +6; jl  +4; br label    gtu>	jeq +2; jhs label	jeq +6; jlo +4; br label    leu<=	jeq label; jlo label	jeq +2; jhs +4; br label    le<=	jeq label; jl  label	jeq +2; jge +4; br label    =================================================================  */
end_comment

begin_struct
struct|struct
name|hcodes_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Corresponding insn_opnumb.  */
name|int
name|tlab
decl_stmt|;
comment|/* Number of labels in short mode.  */
name|int
name|op0
decl_stmt|;
comment|/* Opcode for first word of short jump.  */
name|int
name|op1
decl_stmt|;
comment|/* Opcode for second word of short jump.  */
name|int
name|lop0
decl_stmt|;
comment|/* Opcodes for long jump mode.  */
name|int
name|lop1
decl_stmt|;
name|int
name|lop2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|hcodes_s
name|msp430_hcodes
index|[]
init|=
block|{
block|{
literal|"bgt"
block|,
literal|0
block|,
literal|1
block|,
literal|0x2401
block|,
literal|0x3400
block|,
literal|0x2403
block|,
literal|0x3802
block|,
literal|0x4010
block|}
block|,
block|{
literal|"bgtu"
block|,
literal|1
block|,
literal|1
block|,
literal|0x2401
block|,
literal|0x2c00
block|,
literal|0x2403
block|,
literal|0x2802
block|,
literal|0x4010
block|}
block|,
block|{
literal|"bleu"
block|,
literal|2
block|,
literal|2
block|,
literal|0x2400
block|,
literal|0x2800
block|,
literal|0x2401
block|,
literal|0x2c02
block|,
literal|0x4010
block|}
block|,
block|{
literal|"ble"
block|,
literal|3
block|,
literal|2
block|,
literal|0x2400
block|,
literal|0x3800
block|,
literal|0x2401
block|,
literal|0x3402
block|,
literal|0x4010
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"{"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle  long expressions.  */
end_comment

begin_decl_stmt
specifier|extern
name|LITTLENUM_TYPE
name|generic_bignum
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|msp430_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relaxations.  */
end_comment

begin_define
define|#
directive|define
name|STATE_UNCOND_BRANCH
value|1
end_define

begin_comment
comment|/* jump */
end_comment

begin_define
define|#
directive|define
name|STATE_NOOV_BRANCH
value|3
end_define

begin_comment
comment|/* bltn */
end_comment

begin_define
define|#
directive|define
name|STATE_SIMPLE_BRANCH
value|2
end_define

begin_comment
comment|/* bne, beq, etc... */
end_comment

begin_define
define|#
directive|define
name|STATE_EMUL_BRANCH
value|4
end_define

begin_define
define|#
directive|define
name|CNRL
value|2
end_define

begin_define
define|#
directive|define
name|CUBL
value|4
end_define

begin_define
define|#
directive|define
name|CNOL
value|8
end_define

begin_define
define|#
directive|define
name|CSBL
value|6
end_define

begin_define
define|#
directive|define
name|CEBL
value|4
end_define

begin_comment
comment|/* Length.  */
end_comment

begin_define
define|#
directive|define
name|STATE_BITS10
value|1
end_define

begin_comment
comment|/* wild guess. short jump */
end_comment

begin_define
define|#
directive|define
name|STATE_WORD
value|2
end_define

begin_comment
comment|/* 2 bytes pc rel. addr. more */
end_comment

begin_define
define|#
directive|define
name|STATE_UNDEF
value|3
end_define

begin_comment
comment|/* cannot handle this yet. convert to word mode */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_define
define|#
directive|define
name|RELAX_STATE
parameter_list|(
name|s
parameter_list|)
value|((s)& 3)
end_define

begin_define
define|#
directive|define
name|RELAX_LEN
parameter_list|(
name|s
parameter_list|)
value|((s)>> 2)
end_define

begin_define
define|#
directive|define
name|RELAX_NEXT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX (a, b + 1)
end_define

begin_decl_stmt
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* Unused.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unconditional jump.  */
block|{
literal|1
block|,
literal|1
block|,
literal|8
block|,
literal|5
block|}
block|,
block|{
literal|1024
block|,
operator|-
literal|1024
block|,
name|CNRL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_UNCOND_BRANCH
argument_list|,
argument|STATE_BITS10
argument_list|)
block|}
block|,
comment|/* state 10 bits displ */
block|{
literal|0
block|,
literal|0
block|,
name|CUBL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_UNCOND_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
comment|/* state word */
block|{
literal|1
block|,
literal|1
block|,
name|CUBL
block|,
literal|0
block|}
block|,
comment|/* state undef */
comment|/* Simple branches.  */
block|{
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|9
block|}
block|,
block|{
literal|1024
block|,
operator|-
literal|1024
block|,
name|CNRL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_SIMPLE_BRANCH
argument_list|,
argument|STATE_BITS10
argument_list|)
block|}
block|,
comment|/* state 10 bits displ */
block|{
literal|0
block|,
literal|0
block|,
name|CSBL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_SIMPLE_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
comment|/* state word */
block|{
literal|1
block|,
literal|1
block|,
name|CSBL
block|,
literal|0
block|}
block|,
comment|/* blt no overflow branch.  */
block|{
literal|1
block|,
literal|1
block|,
literal|8
block|,
literal|13
block|}
block|,
block|{
literal|1024
block|,
operator|-
literal|1024
block|,
name|CNRL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_NOOV_BRANCH
argument_list|,
argument|STATE_BITS10
argument_list|)
block|}
block|,
comment|/* state 10 bits displ */
block|{
literal|0
block|,
literal|0
block|,
name|CNOL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_NOOV_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
comment|/* state word */
block|{
literal|1
block|,
literal|1
block|,
name|CNOL
block|,
literal|0
block|}
block|,
comment|/* Emulated branches.  */
block|{
literal|1
block|,
literal|1
block|,
literal|8
block|,
literal|17
block|}
block|,
block|{
literal|1020
block|,
operator|-
literal|1020
block|,
name|CEBL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_EMUL_BRANCH
argument_list|,
argument|STATE_BITS10
argument_list|)
block|}
block|,
comment|/* state 10 bits displ */
block|{
literal|0
block|,
literal|0
block|,
name|CNOL
block|,
name|RELAX_NEXT
argument_list|(
argument|STATE_EMUL_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
comment|/* state word */
block|{
literal|1
block|,
literal|1
block|,
name|CNOL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_OP_LEN
value|256
end_define

begin_struct
struct|struct
name|mcu_type_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|isa
decl_stmt|;
name|int
name|mach
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSP430_ISA_11
value|11
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_110
value|110
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_12
value|12
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_13
value|13
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_14
value|14
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_15
value|15
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_16
value|16
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_21
value|21
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_31
value|31
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_32
value|32
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_33
value|33
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_41
value|41
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_42
value|42
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_43
value|43
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_44
value|44
end_define

begin_define
define|#
directive|define
name|CHECK_RELOC_MSP430
value|((imm_op || byte_op)?BFD_RELOC_MSP430_16_BYTE:BFD_RELOC_MSP430_16)
end_define

begin_define
define|#
directive|define
name|CHECK_RELOC_MSP430_PCREL
value|((imm_op || byte_op)?BFD_RELOC_MSP430_16_PCREL_BYTE:BFD_RELOC_MSP430_16_PCREL)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|mcu_types
index|[]
init|=
block|{
block|{
literal|"msp1"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp2"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x110"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp430x112"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp430x1101"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1111"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1121"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1122"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1132"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x122"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x123"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x1222"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x1232"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x133"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x135"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x1331"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x1351"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x147"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x148"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x149"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x155"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x156"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x157"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x167"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x168"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x169"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x1610"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x1611"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x1612"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x2101"
block|,
name|MSP430_ISA_21
block|,
name|bfd_mach_msp21
block|}
block|,
block|{
literal|"msp430x2111"
block|,
name|MSP430_ISA_21
block|,
name|bfd_mach_msp21
block|}
block|,
block|{
literal|"msp430x2121"
block|,
name|MSP430_ISA_21
block|,
name|bfd_mach_msp21
block|}
block|,
block|{
literal|"msp430x2131"
block|,
name|MSP430_ISA_21
block|,
name|bfd_mach_msp21
block|}
block|,
block|{
literal|"msp430x311"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x312"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x313"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x314"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x315"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x323"
block|,
name|MSP430_ISA_32
block|,
name|bfd_mach_msp32
block|}
block|,
block|{
literal|"msp430x325"
block|,
name|MSP430_ISA_32
block|,
name|bfd_mach_msp32
block|}
block|,
block|{
literal|"msp430x336"
block|,
name|MSP430_ISA_33
block|,
name|bfd_mach_msp33
block|}
block|,
block|{
literal|"msp430x337"
block|,
name|MSP430_ISA_33
block|,
name|bfd_mach_msp33
block|}
block|,
block|{
literal|"msp430x412"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430x413"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430x415"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430x417"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430xE423"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xE425"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xE427"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW423"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW425"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW427"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xG437"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430xG438"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430xG439"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x435"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x436"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x437"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x447"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
literal|"msp430x448"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
literal|"msp430x449"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|default_mcu
init|=
block|{
literal|"msp430x11"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
modifier|*
name|msp430_mcu
init|=
operator|&
name|default_mcu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Profiling capability:    It is a performance hit to use gcc's profiling approach for this tiny target.    Even more -- jtag hardware facility does not perform any profiling functions.    However we've got gdb's built-in simulator where we can do anything.    Therefore my suggestion is:     We define new section ".profiler" which holds all profiling information.    We define new pseudo operation .profiler which will instruct assembler to    add new profile entry to the object file. Profile should take place at the    present address.     Pseudo-op format:        .profiler flags,function_to_profile [, cycle_corrector, extra]     where 'flags' is a combination of the following chars: 	    s - function Start 	    x - function eXit 	    i - function is in Init section 	    f - function is in Fini section 	    l - Library call 	    c - libC standard call 	    d - stack value Demand (saved at run-time in simulator) 	    I - Interrupt service routine 	    P - Prologue start 	    p - Prologue end 	    E - Epilogue start 	    e - Epilogue end 	    j - long Jump/ sjlj unwind 	    a - an Arbitrary code fragment 	    t - exTra parameter saved (constant value like frame size) 	  '""' optional: "sil" == sil        function_to_profile - function's address       cycle_corrector     - a value which should be added to the cycle 			      counter, zero if omitted       extra - some extra parameter, zero if omitted.        For example:       ------------------------------ 	.global fxx 	.type fxx,@function       fxx:       .LFrameOffset_fxx=0x08       .profiler "scdP", fxx	; function entry. 				; we also demand stack value to be displayed 	push r11 	push r10 	push r9 	push r8       .profiler "cdp",fxx,0, .LFrameOffset_fxx	; check stack value at this point 						; (this is a prologue end) 						; note, that spare var filled with the farme size 	mov r15,r8 	....       .profiler cdE,fxx		; check stack 	pop r8 	pop r9 	pop r10 	pop r11       .profiler xcde,fxx,3	; exit adds 3 to the cycle counter       ret			; cause 'ret' insn takes 3 cycles       -------------------------------        This profiling approach does not produce any overhead and       absolutely harmless.       So, even profiled code can be uploaded to the MCU.  */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_ENTRY
value|1
end_define

begin_comment
comment|/* s */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_EXIT
value|2
end_define

begin_comment
comment|/* x */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_INITSECT
value|4
end_define

begin_comment
comment|/* i */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_FINISECT
value|8
end_define

begin_comment
comment|/* f */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_LIBCALL
value|0x10
end_define

begin_comment
comment|/* l */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_STDCALL
value|0x20
end_define

begin_comment
comment|/* c */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_STACKDMD
value|0x40
end_define

begin_comment
comment|/* d */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_ISR
value|0x80
end_define

begin_comment
comment|/* I */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_PROLSTART
value|0x100
end_define

begin_comment
comment|/* P */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_PROLEND
value|0x200
end_define

begin_comment
comment|/* p */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_EPISTART
value|0x400
end_define

begin_comment
comment|/* E */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_EPIEND
value|0x800
end_define

begin_comment
comment|/* e */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_JUMP
value|0x1000
end_define

begin_comment
comment|/* j */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_FRAGMENT
value|0x2000
end_define

begin_comment
comment|/* a */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_EXTRA
value|0x4000
end_define

begin_comment
comment|/* t */
end_comment

begin_define
define|#
directive|define
name|MSP430_PROFILER_FLAG_notyet
value|0x8000
end_define

begin_comment
comment|/* ? */
end_comment

begin_function
specifier|static
name|int
name|pow2value
parameter_list|(
name|int
name|y
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|x
condition|;
name|x
operator|=
name|x
operator|>>
literal|1
control|)
if|if
condition|(
name|x
operator|&
literal|1
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse ordinary expression.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|input_line_pointer
return|;
block|}
end_function

begin_comment
comment|/* Delete spaces from s: X ( r 1  2)  => X(r12).  */
end_comment

begin_function
specifier|static
name|void
name|del_spaces
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|s
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|m
argument_list|)
operator|&&
operator|*
name|m
condition|)
name|m
operator|++
expr_stmt|;
name|memmove
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|skip_space
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Extract one word from FROM and copy it to TO. Delimiters are ",;\n"  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_operand
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
name|from
operator|=
name|skip_space
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|<
name|limit
operator|&&
operator|*
name|from
condition|)
block|{
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
operator|*
name|from
operator|==
literal|','
operator|||
operator|*
name|from
operator|==
literal|';'
operator|||
operator|*
name|from
operator|==
literal|'\n'
condition|)
break|break;
name|from
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
literal|0
expr_stmt|;
name|del_spaces
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msp430_profiler
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|flags
init|=
name|f
decl_stmt|;
name|int
name|p_flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|halt
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|int
name|left
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|int
name|subseg
decl_stmt|;
name|char
modifier|*
name|end
init|=
literal|0
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|expressionS
name|exp1
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|end
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
condition|)
name|end
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|ops
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|left
operator|=
literal|3
operator|-
name|ops
expr_stmt|;
if|if
condition|(
name|ops
operator|<
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".profiler pseudo requires at least two operands."
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|end
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|=
name|extract_operand
argument_list|(
name|input_line_pointer
argument_list|,
name|flags
argument_list|,
literal|32
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|flags
condition|)
block|{
switch|switch
condition|(
operator|*
name|flags
condition|)
block|{
case|case
literal|'"'
case|:
break|break;
case|case
literal|'a'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_FRAGMENT
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_JUMP
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_PROLSTART
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_PROLEND
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_EPISTART
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_EPIEND
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_ENTRY
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_EXIT
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_INITSECT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_FINISECT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_LIBCALL
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_STDCALL
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_STACKDMD
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_ISR
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|p_flags
operator||=
name|MSP430_PROFILER_FLAG_EXTRA
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown profiling flag - ignored."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_flags
operator|&&
operator|(
operator|!
name|pow2value
argument_list|(
name|p_flags
operator|&
operator|(
name|MSP430_PROFILER_FLAG_ENTRY
operator||
name|MSP430_PROFILER_FLAG_EXIT
operator|)
argument_list|)
operator|||
operator|!
name|pow2value
argument_list|(
name|p_flags
operator|&
operator|(
name|MSP430_PROFILER_FLAG_PROLSTART
operator||
name|MSP430_PROFILER_FLAG_PROLEND
operator||
name|MSP430_PROFILER_FLAG_EPISTART
operator||
name|MSP430_PROFILER_FLAG_EPIEND
operator|)
argument_list|)
operator|||
operator|!
name|pow2value
argument_list|(
name|p_flags
operator|&
operator|(
name|MSP430_PROFILER_FLAG_INITSECT
operator||
name|MSP430_PROFILER_FLAG_FINISECT
operator|)
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ambigious flags combination - '.profiler' directive ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|end
expr_stmt|;
return|return;
block|}
comment|/* Generate temp symbol which denotes current location.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
comment|/* Paranoja ?  */
block|{
name|exp1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp1
operator|.
name|X_add_number
operator|=
name|abs_section_offset
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"profiling in absolute section? Hm..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp1
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp1
operator|.
name|X_add_symbol
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|exp1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate a symbol which holds flags value.  */
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|p_flags
expr_stmt|;
comment|/* Save current section.  */
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Now go to .profiler section.  */
name|obj_elf_change_section
argument_list|(
literal|".profiler"
argument_list|,
name|SHT_PROGBITS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save flags.  */
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Save label value.  */
name|emit_expr
argument_list|(
operator|&
name|exp1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|ops
operator|--
condition|)
block|{
comment|/* Now get profiling info.  */
name|halt
operator|=
name|extract_operand
argument_list|(
name|input_line_pointer
argument_list|,
name|str
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* Process like ".word xxx" directive.  */
name|parse_exp
argument_list|(
name|str
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|halt
expr_stmt|;
block|}
comment|/* Fill the rest with zeros.  */
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Return to current section.  */
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|extract_word
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
name|from
operator|=
name|skip_space
argument_list|(
name|from
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
literal|0
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|from
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
name|is_part_of_name
argument_list|(
operator|*
name|op_end
argument_list|)
condition|;
control|)
block|{
name|to
index|[
name|size
operator|++
index|]
operator|=
operator|*
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
block|}
name|to
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|op_end
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OPTION_MMCU
value|'m'
end_define

begin_define
define|#
directive|define
name|OPTION_RELAX
value|'Q'
end_define

begin_define
define|#
directive|define
name|OPTION_POLYMORPHS
value|'P'
end_define

begin_function
specifier|static
name|void
name|msp430_set_arch
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|32
argument_list|)
decl_stmt|;
comment|/* 32 for good measure.  */
name|input_line_pointer
operator|=
name|extract_word
argument_list|(
name|input_line_pointer
argument_list|,
name|str
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|md_parse_option
argument_list|(
name|OPTION_MMCU
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|msp430_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_mcu_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Known MCU names:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\t %s\n"
argument_list|)
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_MMCU
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|show_mcu_list
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown MCU: %s\n"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msp430_mcu
operator|==
operator|&
name|default_mcu
operator|||
name|msp430_mcu
operator|->
name|mach
operator|==
name|mcu_types
index|[
name|i
index|]
operator|.
name|mach
condition|)
name|msp430_mcu
operator|=
operator|&
name|mcu_types
index|[
name|i
index|]
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"redefinition of mcu type %s' to %s'"
argument_list|)
argument_list|,
name|msp430_mcu
operator|->
name|name
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
break|break;
case|case
name|OPTION_RELAX
case|:
name|msp430_enable_relax
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
break|break;
case|case
name|OPTION_POLYMORPHS
case|:
name|msp430_enable_polys
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"arch"
block|,
name|msp430_set_arch
block|,
literal|0
block|}
block|,
block|{
literal|"profiler"
block|,
name|msp430_profiler
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mmcu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MMCU
block|}
block|,
block|{
literal|"mP"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_POLYMORPHS
block|}
block|,
block|{
literal|"mQ"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"MSP430 options:\n"
literal|"  -mmcu=[msp430-name] select microcontroller type\n"
literal|"                  msp430x110  msp430x112\n"
literal|"                  msp430x1101 msp430x1111\n"
literal|"                  msp430x1121 msp430x1122 msp430x1132\n"
literal|"                  msp430x122  msp430x123\n"
literal|"                  msp430x1222 msp430x1232\n"
literal|"                  msp430x133  msp430x135\n"
literal|"                  msp430x1331 msp430x1351\n"
literal|"                  msp430x147  msp430x148  msp430x149\n"
literal|"                  msp430x155  msp430x156  msp430x157\n"
literal|"                  msp430x167  msp430x168  msp430x169\n"
literal|"                  msp430x1610 msp430x1611 msp430x1612\n"
literal|"                  msp430x311  msp430x312  msp430x313  msp430x314  msp430x315\n"
literal|"                  msp430x323  msp430x325\n"
literal|"                  msp430x336  msp430x337\n"
literal|"                  msp430x412  msp430x413  msp430x415  msp430x417\n"
literal|"                  msp430xE423 msp430xE425 msp430E427\n"
literal|"                  msp430xW423 msp430xW425 msp430W427\n"
literal|"                  msp430xG437 msp430xG438 msp430G439\n"
literal|"                  msp430x435  msp430x436  msp430x437\n"
literal|"                  msp430x447  msp430x448  msp430x449\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mQ - enable relaxation at assembly time. DANGEROUS!\n"
literal|"  -mP - enable polymorph instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|show_mcu_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|extract_cmd
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|from
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|from
argument_list|)
operator|&&
operator|*
name|from
operator|!=
literal|'.'
operator|&&
name|limit
operator|>
name|size
condition|)
block|{
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
operator|*
name|from
expr_stmt|;
name|from
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loop outputs the LITTLENUMs in REVERSE order.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
decl_stmt|;
name|msp430_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|msp430_opcodes
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|msp430_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|msp430_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_reg
parameter_list|(
name|char
modifier|*
name|t
parameter_list|)
block|{
comment|/* If this is a reg numb, str 't' must be a number from 0 - 15.  */
if|if
condition|(
name|strlen
argument_list|(
name|t
argument_list|)
operator|>
literal|2
operator|&&
operator|*
operator|(
name|t
operator|+
literal|2
operator|)
operator|!=
literal|'+'
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|<
literal|'0'
operator|||
operator|*
name|t
operator|>
literal|'9'
operator|)
operator|&&
operator|*
name|t
operator|!=
literal|'+'
condition|)
break|break;
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msp430_srcoperand
parameter_list|(
name|struct
name|msp430_operand_s
modifier|*
name|op
parameter_list|,
name|char
modifier|*
name|l
parameter_list|,
name|int
name|bin
parameter_list|,
name|int
modifier|*
name|imm_op
parameter_list|)
block|{
name|char
modifier|*
name|__tl
init|=
name|l
decl_stmt|;
comment|/* Check if an immediate #VALUE.  The hash sign should be only at the beginning!  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'#'
condition|)
block|{
name|char
modifier|*
name|h
init|=
name|l
decl_stmt|;
name|int
name|vshift
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* Check if there is: 	 llo(x) - least significant 16 bits, x&= 0xffff 	 lhi(x) - x = (x>> 16)& 0xffff, 	 hlo(x) - x = (x>> 32)& 0xffff, 	 hhi(x) - x = (x>> 48)& 0xffff 	 The value _MUST_ be constant expression: #hlo(1231231231).  */
operator|*
name|imm_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#llo("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#lhi("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hlo("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|2
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hhi("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|3
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#lo("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hi("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|2
expr_stmt|;
block|}
name|op
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* Reg PC.  */
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Immediate  will follow an instruction.  */
name|__tl
operator|=
name|h
operator|+
literal|1
operator|+
name|rval
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|vshift
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|&
literal|0xffff
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vshift
operator|==
literal|1
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vshift
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Nothing left.  */
name|x
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|>
literal|65535
operator|||
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value %d out of range. Use #lo() or #hi()"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now check constants.  */
comment|/* Substitute register mode with a constant generator if applicable.  */
name|x
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
comment|/* Extend sign.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|2
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_1X_WORKAROUND
if|if
condition|(
name|bin
operator|==
literal|0x1200
condition|)
block|{
comment|/* Remove warning as confusing. 		     as_warn(_("Hardware push bug workaround")); */
block|}
else|else
endif|#
directive|endif
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_1X_WORKAROUND
if|if
condition|(
name|bin
operator|==
literal|0x1200
condition|)
block|{
comment|/* Remove warning as confusing. 		     as_warn(_("Hardware push bug workaround")); */
block|}
else|else
endif|#
directive|endif
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
name|short
name|x
decl_stmt|;
if|if
condition|(
name|vshift
operator|!=
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0xffff
operator|&
name|generic_bignum
index|[
name|vshift
index|]
expr_stmt|;
name|x
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s. use #llo() #lhi() #hlo() #hhi() "
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|2
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|4
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
comment|/* Redudant (yet) check.  */
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Registers cannot be used within immediate expression [%s]"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check if absolute&VALUE (assume that we can construct something like ((a&b)<<7 + 25).  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'&'
condition|)
block|{
name|char
modifier|*
name|h
init|=
name|l
decl_stmt|;
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
comment|/* reg 2 in absolute addr mode.  */
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
comment|/* mode As == 01 bin.  */
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Immediate value followed by instruction.  */
name|__tl
operator|=
name|h
operator|+
literal|1
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|65535
operator|||
name|x
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value out of range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
empty_stmt|;
else|else
block|{
comment|/* Redudant (yet) check.  */
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Registers cannot be used within absolute expression [%s]"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Check if indirect register mode @Rn / postincrement @Rn+.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'@'
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|m
init|=
name|strchr
argument_list|(
name|l
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|l
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'r'
operator|&&
operator|*
name|t
operator|!=
literal|'R'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
comment|/* Points to the reg value.  */
if|if
condition|(
name|check_reg
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad register name r%s"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
name|m
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
condition|)
operator|*
name|m
operator|=
literal|0
expr_stmt|;
comment|/* strip '+' */
name|op
operator|->
name|reg
operator|=
name|atoi
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|<
literal|0
operator|||
name|op
operator|->
name|reg
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MSP430 does not have %d registers"
argument_list|)
argument_list|,
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Check if register indexed X(Rn).  */
do|do
block|{
name|char
modifier|*
name|h
init|=
name|strrchr
argument_list|(
name|l
argument_list|,
literal|'('
argument_list|)
decl_stmt|;
name|char
modifier|*
name|m
init|=
name|strrchr
argument_list|(
name|l
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
operator|*
name|imm_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
break|break;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"')' required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
name|h
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Extract a register.  */
name|t
operator|++
expr_stmt|;
comment|/* Advance pointer.  */
if|if
condition|(
operator|*
name|t
operator|!=
literal|'r'
operator|&&
operator|*
name|t
operator|!=
literal|'R'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s. Did you mean X(Rn) or #[hl][hl][oi](CONST) ?"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|>
literal|9
operator|||
name|op
operator|->
name|reg
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator (r%s substituded as a register name"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|')'
condition|)
block|{
name|op
operator|->
name|reg
operator|=
name|op
operator|->
name|reg
operator|*
literal|10
expr_stmt|;
name|op
operator|->
name|reg
operator|+=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|op
operator|->
name|reg
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"r2 should not be used in indexed addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Extract constant.  */
name|__tl
operator|=
name|l
expr_stmt|;
operator|*
name|h
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|65535
operator|||
name|x
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value out of range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
empty_stmt|;
else|else
block|{
comment|/* Redudant (yet) check.  */
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Registers cannot be used as a prefix of indexed expression [%s]"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Register mode 'mov r1,r2'.  */
do|do
block|{
name|char
modifier|*
name|t
init|=
name|l
decl_stmt|;
comment|/* Operand should be a register.  */
if|if
condition|(
operator|*
name|t
operator|==
literal|'r'
operator|||
operator|*
name|t
operator|==
literal|'R'
condition|)
block|{
name|int
name|x
init|=
name|atoi
argument_list|(
name|t
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_reg
argument_list|(
name|t
operator|+
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|15
condition|)
break|break;
comment|/* Symbolic mode.  */
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|reg
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Symbolic mode 'mov a, b' == 'mov x(pc), y(pc)'.  */
do|do
block|{
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|op
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* PC relative... be careful.  */
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
name|__tl
operator|=
name|l
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Unreachable.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode for operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msp430_dstoperand
parameter_list|(
name|struct
name|msp430_operand_s
modifier|*
name|op
parameter_list|,
name|char
modifier|*
name|l
parameter_list|,
name|int
name|bin
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|;
name|int
name|ret
init|=
name|msp430_srcoperand
argument_list|(
name|op
argument_list|,
name|l
argument_list|,
name|bin
argument_list|,
operator|&
name|dummy
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|op
operator|->
name|am
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|__tl
init|=
literal|"0"
decl_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal bug. Try to use 0(r%d) instead of @r%d"
argument_list|)
argument_list|,
name|op
operator|->
name|reg
argument_list|,
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|op
operator|->
name|am
operator|>
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"this addressing mode is not applicable for destination operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse instruction operands.    Return binary opcode.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|msp430_operands
parameter_list|(
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|bin
init|=
name|opcode
operator|->
name|bin_opcode
decl_stmt|;
comment|/* Opcode mask.  */
name|int
name|__is
init|=
literal|0
decl_stmt|;
name|char
name|l1
index|[
name|MAX_OP_LEN
index|]
decl_stmt|,
name|l2
index|[
name|MAX_OP_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|struct
name|msp430_operand_s
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|static
name|short
name|ZEROS
init|=
literal|0
decl_stmt|;
name|int
name|byte_op
decl_stmt|,
name|imm_op
decl_stmt|;
comment|/* Opcode is the one from opcodes table      line contains something like      [.w] @r2+, 5(R1)      or      .b @r2+, 5(R1).  */
comment|/* Check if byte or word operation.  */
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|TOLOWER
argument_list|(
operator|*
operator|(
name|line
operator|+
literal|1
operator|)
argument_list|)
operator|==
literal|'b'
condition|)
block|{
name|bin
operator||=
name|BYTE_OPERATION
expr_stmt|;
name|byte_op
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|byte_op
operator|=
literal|0
expr_stmt|;
comment|/* skip .[bwBW].  */
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|line
argument_list|)
operator|&&
operator|*
name|line
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|insn_opnumb
operator|&&
operator|(
operator|!
operator|*
name|line
operator|||
operator|*
name|line
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction %s requires %d operand(s)"
argument_list|)
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|insn_opnumb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|l1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|op1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|op2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|imm_op
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|fmt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Emulated.  */
switch|switch
condition|(
name|opcode
operator|->
name|insn_opnumb
condition|)
block|{
case|case
literal|0
case|:
comment|/* Set/clear bits instructions.  */
name|__is
operator|=
literal|2
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
name|__is
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|__is
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Something which works with destination operand.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_dstoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
name|bin
operator||=
operator|(
name|op1
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
comment|/* Shift instruction.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|l2
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|l2
index|[
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
name|res
operator|+=
name|msp430_dstoperand
argument_list|(
operator|&
name|op2
argument_list|,
name|l2
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* An error occurred.  All warnings were done before.  */
name|bin
operator||=
operator|(
name|op2
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator||
operator|(
name|op2
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
operator|+
name|op2
operator|.
name|ol
expr_stmt|;
comment|/* insn size in words.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
comment|/* Advance 'where' as we do not know _where_.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op2
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
operator|+
operator|(
operator|(
name|__is
operator|==
literal|3
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|reg
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|3
case|:
comment|/* Branch instruction => mov dst, r0.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
name|byte_op
operator|=
literal|0
expr_stmt|;
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bin
operator||=
operator|(
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Format 1, double operand.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l2
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
name|res
operator|+=
name|msp430_dstoperand
argument_list|(
operator|&
name|op2
argument_list|,
name|l2
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* Error occurred.  All warnings were done before.  */
name|bin
operator||=
operator|(
name|op2
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator||
operator|(
name|op2
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
operator|+
name|op2
operator|.
name|ol
expr_stmt|;
comment|/* insn size in words.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
comment|/* Advance where as we do not know _where_.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op2
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
operator|+
operator|(
operator|(
name|__is
operator|==
literal|3
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|reg
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Single-operand mostly instr.  */
if|if
condition|(
name|opcode
operator|->
name|insn_opnumb
operator|==
literal|0
condition|)
block|{
comment|/* reti instruction.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* Error in operand.  */
name|bin
operator||=
name|op1
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Conditional jumps instructions.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* l1 is a label.  */
if|if
condition|(
name|l1
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|l1
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
literal|'$'
condition|)
name|m
operator|++
expr_stmt|;
name|parse_exp
argument_list|(
name|m
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Instr size is 1 word.  */
comment|/* In order to handle something like:  	     and #0x8000, r5 	     tst r5 	     jz   4     ;       skip next 4 bytes 	     inv r5 	     inc r5 	     nop        ;       will jump here if r5 positive or zero  	     jCOND      -n      ;assumes jump n bytes backward:  	     mov r5,r6 	     jmp -2  	     is equal to: 	     lab: 	     mov r5,r6 	     jmp lab  	     jCOND      $n      ; jump from PC in either direction.  */
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Even number required. Rounded to %d"
argument_list|)
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|l1
operator|==
literal|'$'
operator|&&
name|x
operator|>
literal|0
operator|)
operator|||
name|x
operator|<
literal|0
condition|)
name|x
operator|-=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|512
operator|||
name|x
operator|<
operator|-
literal|511
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong displacement  %d"
argument_list|)
argument_list|,
name|x
operator|<<
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|bin
operator||=
name|x
operator|&
literal|0x3ff
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|l1
operator|!=
literal|'$'
condition|)
block|{
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_MSP430_10_PCREL
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|l1
operator|==
literal|'$'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label sans '$'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label or value in range -511:512"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dwarf2_emit_insn
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|4
case|:
comment|/* Extended jumps.  */
if|if
condition|(
operator|!
name|msp430_enable_polys
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"polymorphs are not enabled. Use -mP option to enable."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|l1
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* Ignore absolute addressing. make it PC relative anyway.  */
if|if
condition|(
operator|*
name|m
operator|==
literal|'#'
operator|||
operator|*
name|m
operator|==
literal|'$'
condition|)
name|m
operator|++
expr_stmt|;
name|parse_exp
argument_list|(
name|m
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
comment|/* Relaxation required.  */
name|struct
name|rcodes_s
name|rc
init|=
name|msp430_rcodes
index|[
name|opcode
operator|->
name|insn_opnumb
index|]
decl_stmt|;
comment|/* The parameter to dwarf2_emit_insn is actually the offset to the start 		 of the insn from the fix piece of instruction that was emitted. 		 Since next fragments may have variable size we tie debug info 	         to the beginning of the instruction. */
name|frag
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|rc
operator|.
name|sop
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|frag
operator|=
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|rc
operator|.
name|lpos
argument_list|,
name|STATE_BITS10
argument_list|)
argument_list|,
comment|/* Wild guess.  */
name|exp
operator|.
name|X_add_symbol
argument_list|,
literal|0
argument_list|,
comment|/* Offset is zero if jump dist less than 1K.  */
operator|(
name|char
operator|*
operator|)
name|frag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Emulated extended branches.  */
if|if
condition|(
operator|!
name|msp430_enable_polys
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"polymorphs are not enabled. Use -mP option to enable."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|l1
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* Ignore absolute addressing. make it PC relative anyway.  */
if|if
condition|(
operator|*
name|m
operator|==
literal|'#'
operator|||
operator|*
name|m
operator|==
literal|'$'
condition|)
name|m
operator|++
expr_stmt|;
name|parse_exp
argument_list|(
name|m
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
comment|/* Relaxation required.  */
name|struct
name|hcodes_s
name|hc
init|=
name|msp430_hcodes
index|[
name|opcode
operator|->
name|insn_opnumb
index|]
decl_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|hc
operator|.
name|op0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|hc
operator|.
name|op1
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
name|frag
operator|=
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_EMUL_BRANCH
argument_list|,
name|STATE_BITS10
argument_list|)
argument_list|,
comment|/* Wild guess.  */
name|exp
operator|.
name|X_add_symbol
argument_list|,
literal|0
argument_list|,
comment|/* Offset is zero if jump dist less than 1K.  */
operator|(
name|char
operator|*
operator|)
name|frag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ilegal instruction or not implmented opcode."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|line
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
decl_stmt|;
name|char
name|cmd
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Skip leading spaces.  */
name|str
operator|=
name|extract_cmd
argument_list|(
name|str
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|i
index|]
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|char
name|a
init|=
name|TOLOWER
argument_list|(
name|cmd
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|cmd
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmd
index|[
literal|0
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
operator|(
expr|struct
name|msp430_opcode_s
operator|*
operator|)
name|hash_find
argument_list|(
name|msp430_hash
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode `%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|char
modifier|*
name|__t
init|=
name|input_line_pointer
decl_stmt|;
name|msp430_operands
argument_list|(
name|opcode
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|__t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GAS will call this function for each section at the end of the assembly,    to permit the CPU backend to adjust the alignment of a section.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If you define this macro, it should return the offset between the    address of a PC relative fixup and the position from which the PC    relative adjustment should be made.  On many processors, the base    of a PC relative instruction is the next instruction, so this    macro would return the length of an instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Replaces standard TC_FORCE_RELOCATION_LOCAL.    Now it handles the situation when relocations    have to be passed to linker. */
end_comment

begin_function
name|int
name|msp430_force_relocation_local
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|msp430_enable_polys
operator|&&
operator|!
name|msp430_enable_relax
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|||
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GAS will call this for each fixup.  It should store the correct    value in the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|valueT
modifier|*
name|valuep
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|long
name|value
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|segT
name|s
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
operator|(
name|s
operator|==
name|seg
operator|||
name|s
operator|==
name|absolute_section
operator|)
condition|)
block|{
comment|/* FIXME: We can appear here only in case if we perform a pc 	     relative jump to the label which is i) global, ii) locally 	     defined or this is a jump to an absolute symbol. 	     If this is an absolute symbol -- everything is OK. 	     If this is a global label, we've got a symbol value defined 	     twice:                1. S_GET_VALUE (fixp->fx_addsy) will contain a symbol offset 	          from this section start                2. *valuep will contain the real offset from jump insn to the 	          label 	     So, the result of S_GET_VALUE (fixp->fx_addsy) + (* valuep); 	     will be incorrect. Therefore remove s_get_value.  */
name|value
operator|=
comment|/* S_GET_VALUE (fixp->fx_addsy) + */
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fixp
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
comment|/* if polymorphs are enabled and relax disabled.       do not kill any relocs and pass them to linker. */
if|if
condition|(
name|msp430_enable_polys
operator|&&
operator|!
name|msp430_enable_relax
condition|)
block|{
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_addsy
operator|||
operator|(
name|fixp
operator|->
name|fx_addsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|absolute_section
operator|)
condition|)
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* it is ok to kill 'abs' reloc */
else|else
name|fixp
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_MSP430_10_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Jumps are in words.  */
name|value
operator|>>=
literal|1
expr_stmt|;
operator|--
name|value
expr_stmt|;
comment|/* Correct PC.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|512
operator|||
name|value
operator|>
literal|511
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0x3ff
expr_stmt|;
comment|/* get rid of extended sign */
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator||
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_RL_PCREL
case|:
case|case
name|BFD_RELOC_MSP430_16_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Nothing to be corrected here.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|65536
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffff
expr_stmt|;
comment|/* Get rid of extended sign.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_16_PCREL_BYTE
case|:
comment|/* Nothing to be corrected here.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|65536
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffff
expr_stmt|;
comment|/* Get rid of extended sign.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_16
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_MSP430_16_BYTE
case|:
name|value
operator|&=
literal|0xffff
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"line %d: unknown relocation type: 0x%x"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fixp
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GAS will call this to generate a reloc, passing the resulting reloc    to `bfd_install_relocation'.  This currently works poorly, as    `bfd_install_relocation' often does the wrong thing, and instances of    `tc_gen_reloc' have been written to work around the problems, which    in turns makes it difficult to fix `bfd_install_relocation'.  */
end_comment

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
comment|/* This is a jump -> pcrel mode. Nothing to do much here.          Return value == 2.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|RELAX_LEN
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|STATE_BITS10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
comment|/* Its got a segment, but its not ours.   Even if fr_symbol is in 	 an absolute segment, we dont know a displacement until we link 	 object files. So it will always be long. This also applies to 	 labels in a subsegment of current. Liker may relax it to short 	 jump later. Return value == 8.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|RELAX_LEN
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|STATE_WORD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We know the abs value. may be it is a jump to fixed address.          Impossible in our case, cause all constants already handeled. */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|RELAX_LEN
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|STATE_UNDEF
argument_list|)
expr_stmt|;
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
literal|0
decl_stmt|;
name|int
name|rela
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rcodes_s
modifier|*
name|cc
init|=
name|NULL
decl_stmt|;
name|struct
name|hcodes_s
modifier|*
name|hc
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_UNCOND_BRANCH
argument_list|,
name|STATE_BITS10
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_SIMPLE_BRANCH
argument_list|,
name|STATE_BITS10
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_NOOV_BRANCH
argument_list|,
name|STATE_BITS10
argument_list|)
case|:
comment|/* We do not have to convert anything here.          Just apply a fix.  */
name|rela
operator|=
name|BFD_RELOC_MSP430_10_PCREL
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_UNCOND_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_UNCOND_BRANCH
argument_list|,
name|STATE_UNDEF
argument_list|)
case|:
comment|/* Convert uncond branch jmp lab -> br lab.  */
name|cc
operator|=
operator|&
name|msp430_rcodes
index|[
literal|7
index|]
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|rela
operator|=
name|BFD_RELOC_MSP430_RL_PCREL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_SIMPLE_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_SIMPLE_BRANCH
argument_list|,
name|STATE_UNDEF
argument_list|)
case|:
block|{
comment|/* Other simple branches.  */
name|int
name|insn
init|=
name|bfd_getl16
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|)
decl_stmt|;
name|insn
operator|&=
literal|0xffff
expr_stmt|;
comment|/* Find actual instruction.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
operator|&&
operator|!
name|cc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|msp430_rcodes
index|[
name|i
index|]
operator|.
name|sop
operator|==
name|insn
condition|)
name|cc
operator|=
operator|&
name|msp430_rcodes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cc
operator|||
operator|!
name|cc
operator|->
name|name
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: insn %04lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|)
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop1
argument_list|,
name|where
operator|+
literal|2
argument_list|)
expr_stmt|;
name|rela
operator|=
name|BFD_RELOC_MSP430_RL_PCREL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_NOOV_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_NOOV_BRANCH
argument_list|,
name|STATE_UNDEF
argument_list|)
case|:
name|cc
operator|=
operator|&
name|msp430_rcodes
index|[
literal|6
index|]
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop1
argument_list|,
name|where
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
name|cc
operator|->
name|lop2
argument_list|,
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
name|rela
operator|=
name|BFD_RELOC_MSP430_RL_PCREL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_EMUL_BRANCH
argument_list|,
name|STATE_BITS10
argument_list|)
case|:
block|{
name|int
name|insn
init|=
name|bfd_getl16
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|+
literal|2
argument_list|)
decl_stmt|;
name|insn
operator|&=
literal|0xffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|!
name|hc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|msp430_hcodes
index|[
name|i
index|]
operator|.
name|op1
operator|==
name|insn
condition|)
name|hc
operator|=
operator|&
name|msp430_hcodes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hc
operator|||
operator|!
name|hc
operator|->
name|name
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: ext. insn %04lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|)
expr_stmt|;
name|rela
operator|=
name|BFD_RELOC_MSP430_10_PCREL
expr_stmt|;
comment|/* Apply a fix for a first label if necessary. 	   another fix will be applied to the next word of insn anyway.  */
if|if
condition|(
name|hc
operator|->
name|tlab
operator|==
literal|2
condition|)
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
name|TRUE
argument_list|,
name|rela
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_EMUL_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_EMUL_BRANCH
argument_list|,
name|STATE_UNDEF
argument_list|)
case|:
block|{
name|int
name|insn
init|=
name|bfd_getl16
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|+
literal|2
argument_list|)
decl_stmt|;
name|insn
operator|&=
literal|0xffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|!
name|hc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|msp430_hcodes
index|[
name|i
index|]
operator|.
name|op1
operator|==
name|insn
condition|)
name|hc
operator|=
operator|&
name|msp430_hcodes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hc
operator|||
operator|!
name|hc
operator|->
name|name
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: ext. insn %04lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|)
expr_stmt|;
name|rela
operator|=
name|BFD_RELOC_MSP430_RL_PCREL
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|bfd_putl16
argument_list|(
name|hc
operator|->
name|lop0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
name|hc
operator|->
name|lop1
argument_list|,
name|where
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
name|hc
operator|->
name|lop2
argument_list|,
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s:  %lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now apply fix.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
name|TRUE
argument_list|,
name|rela
argument_list|)
expr_stmt|;
comment|/* Just fixed 2 bytes.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relax fragment. Mostly stolen from hc11 and mcore    which arches I think I know.  */
end_comment

begin_function
name|long
name|msp430_relax_frag
parameter_list|(
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|growth
decl_stmt|;
name|offsetT
name|aim
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
name|relax_substateT
name|next_state
decl_stmt|;
name|relax_substateT
name|this_state
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|table
init|=
name|md_relax_table
decl_stmt|;
comment|/* Nothing to be done if the frag has already max size.  */
if|if
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_UNDEF
operator|||
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_WORD
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_BITS10
condition|)
block|{
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
if|if
condition|(
name|symbol_resolved_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: resolved symbol"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* We know the offset. calculate a distance.  */
name|aim
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msp430_enable_relax
condition|)
block|{
comment|/* Relaxation is not enabled. So, make all jump as long ones          by setting 'aim' to quite high value. */
name|aim
operator|=
literal|0x7fff
expr_stmt|;
block|}
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
expr_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
operator|||
operator|!
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look forwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
operator|||
operator|!
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
expr_stmt|;
if|if
condition|(
name|growth
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

end_unit

