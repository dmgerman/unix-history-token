begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-msp430.c -- Assembler code for the Texas Instruments MSP430    Copyright (C) 2002, 2003 Free Software Foundation, Inc.   Contributed by Dmitry Diky<diwil@mail.ru>    This file is part of GAS, the GNU Assembler.    GAS is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2, or (at your option)   any later version.    GAS is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.    You should have received a copy of the GNU General Public License   along with GAS; see the file COPYING.  If not, write to   the Free Software Foundation, 59 Temple Place - Suite 330,   Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|PUSH_1X_WORKAROUND
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/msp430.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle  long expressions.  */
end_comment

begin_decl_stmt
specifier|extern
name|LITTLENUM_TYPE
name|generic_bignum
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|msp430_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|msp430_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|msp430_opcode_s
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msp430_srcoperand
name|PARAMS
argument_list|(
operator|(
expr|struct
name|msp430_operand_s
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msp430_dstoperand
name|PARAMS
argument_list|(
operator|(
expr|struct
name|msp430_operand_s
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_exp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|char
modifier|*
name|skip_space
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|msp430_set_arch
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_mcu_list
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|del_spaces
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_OP_LEN
value|256
end_define

begin_struct
struct|struct
name|mcu_type_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|isa
decl_stmt|;
name|int
name|mach
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSP430_ISA_11
value|11
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_110
value|110
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_12
value|12
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_13
value|13
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_14
value|14
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_15
value|15
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_16
value|16
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_31
value|31
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_32
value|32
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_33
value|33
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_41
value|41
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_42
value|42
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_43
value|43
end_define

begin_define
define|#
directive|define
name|MSP430_ISA_44
value|44
end_define

begin_define
define|#
directive|define
name|CHECK_RELOC_MSP430
value|((imm_op || byte_op)?BFD_RELOC_MSP430_16_BYTE:BFD_RELOC_MSP430_16)
end_define

begin_define
define|#
directive|define
name|CHECK_RELOC_MSP430_PCREL
value|((imm_op || byte_op)?BFD_RELOC_MSP430_16_PCREL_BYTE:BFD_RELOC_MSP430_16_PCREL)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|mcu_types
index|[]
init|=
block|{
block|{
literal|"msp1"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp2"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x110"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp430x112"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
block|,
block|{
literal|"msp430x1101"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1111"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1121"
block|,
name|MSP430_ISA_110
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1122"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x1132"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp110
block|}
block|,
block|{
literal|"msp430x122"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x123"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x1222"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x1232"
block|,
name|MSP430_ISA_12
block|,
name|bfd_mach_msp12
block|}
block|,
block|{
literal|"msp430x133"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x135"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x1331"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x1351"
block|,
name|MSP430_ISA_13
block|,
name|bfd_mach_msp13
block|}
block|,
block|{
literal|"msp430x147"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x148"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x149"
block|,
name|MSP430_ISA_14
block|,
name|bfd_mach_msp14
block|}
block|,
block|{
literal|"msp430x155"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x156"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x157"
block|,
name|MSP430_ISA_15
block|,
name|bfd_mach_msp15
block|}
block|,
block|{
literal|"msp430x167"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x168"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x169"
block|,
name|MSP430_ISA_16
block|,
name|bfd_mach_msp16
block|}
block|,
block|{
literal|"msp430x311"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x312"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x313"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x314"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x315"
block|,
name|MSP430_ISA_31
block|,
name|bfd_mach_msp31
block|}
block|,
block|{
literal|"msp430x323"
block|,
name|MSP430_ISA_32
block|,
name|bfd_mach_msp32
block|}
block|,
block|{
literal|"msp430x325"
block|,
name|MSP430_ISA_32
block|,
name|bfd_mach_msp32
block|}
block|,
block|{
literal|"msp430x336"
block|,
name|MSP430_ISA_33
block|,
name|bfd_mach_msp33
block|}
block|,
block|{
literal|"msp430x337"
block|,
name|MSP430_ISA_33
block|,
name|bfd_mach_msp33
block|}
block|,
block|{
literal|"msp430x412"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430x413"
block|,
name|MSP430_ISA_41
block|,
name|bfd_mach_msp41
block|}
block|,
block|{
literal|"msp430xE423"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xE425"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xE427"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW423"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW425"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430xW427"
block|,
name|MSP430_ISA_42
block|,
name|bfd_mach_msp42
block|}
block|,
block|{
literal|"msp430x435"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x436"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x437"
block|,
name|MSP430_ISA_43
block|,
name|bfd_mach_msp43
block|}
block|,
block|{
literal|"msp430x447"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
literal|"msp430x448"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
literal|"msp430x449"
block|,
name|MSP430_ISA_44
block|,
name|bfd_mach_msp44
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|default_mcu
init|=
block|{
literal|"msp430x11"
block|,
name|MSP430_ISA_11
block|,
name|bfd_mach_msp11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
modifier|*
name|msp430_mcu
init|=
operator|&
name|default_mcu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"arch"
block|,
name|msp430_set_arch
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_MMCU
value|'m'
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mmcu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MMCU
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|show_mcu_list
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Known MCU names:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\t %s\n"
argument_list|)
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"MSP430 options:\n"
literal|"  -mmcu=[msp430-name] select microcontroller type\n"
literal|"                  msp430x110  msp430x112\n"
literal|"                  msp430x1101 msp430x1111\n"
literal|"                  msp430x1121 msp430x1122 msp430x1132\n"
literal|"                  msp430x122  msp430x123\n"
literal|"                  msp430x1222 msp430x1232\n"
literal|"                  msp430x133  msp430x135\n"
literal|"                  msp430x1331 msp430x1351\n"
literal|"                  msp430x147  msp430x148  msp430x149\n"
literal|"                  msp430x155  msp430x156  msp430x157\n"
literal|"                  msp430x167  msp430x168  msp430x169\n"
literal|"                  msp430x311  msp430x312  msp430x313  msp430x314  msp430x315\n"
literal|"                  msp430x323  msp430x325\n"
literal|"                  msp430x336  msp430x337\n"
literal|"                  msp430x412  msp430x413\n"
literal|"                  msp430xE423 msp430xE425 msp430E427\n"
literal|"                  msp430xW423 msp430xW425 msp430W427\n"
literal|"                  msp430x435  msp430x436  msp430x437\n"
literal|"                  msp430x447  msp430x448  msp430x449\n"
argument_list|)
argument_list|)
expr_stmt|;
name|show_mcu_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|extract_word
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
name|from
operator|=
name|skip_space
argument_list|(
name|from
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
literal|0
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|from
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
name|is_part_of_name
argument_list|(
operator|*
name|op_end
argument_list|)
condition|;
control|)
block|{
name|to
index|[
name|size
operator|++
index|]
operator|=
operator|*
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
block|}
name|to
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|op_end
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msp430_set_arch
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|32
argument_list|)
decl_stmt|;
comment|/* 32 for good measure.  */
name|input_line_pointer
operator|=
name|extract_word
argument_list|(
name|input_line_pointer
argument_list|,
name|str
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|md_parse_option
argument_list|(
name|OPTION_MMCU
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|msp430_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_MMCU
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|show_mcu_list
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown MCU: %s\n"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msp430_mcu
operator|==
operator|&
name|default_mcu
operator|||
name|msp430_mcu
operator|->
name|mach
operator|==
name|mcu_types
index|[
name|i
index|]
operator|.
name|mach
condition|)
name|msp430_mcu
operator|=
operator|&
name|mcu_types
index|[
name|i
index|]
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"redefinition of mcu type %s' to %s'"
argument_list|)
argument_list|,
name|msp430_mcu
operator|->
name|name
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|skip_space
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Delete spaces from s: X ( r 1  2)  => X(r12).  */
end_comment

begin_function
specifier|static
name|void
name|del_spaces
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|s
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|m
argument_list|)
operator|&&
operator|*
name|m
condition|)
name|m
operator|++
expr_stmt|;
name|memmove
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extract one word from FROM and copy it to TO. Delimeters are ",;\n"  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_operand
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
name|from
operator|=
name|skip_space
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|<
name|limit
operator|&&
operator|*
name|from
condition|)
block|{
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
operator|*
name|from
operator|==
literal|','
operator|||
operator|*
name|from
operator|==
literal|';'
operator|||
operator|*
name|from
operator|==
literal|'\n'
condition|)
break|break;
name|from
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
literal|0
expr_stmt|;
name|del_spaces
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|extract_cmd
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|from
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|from
argument_list|)
operator|&&
operator|*
name|from
operator|!=
literal|'.'
operator|&&
name|limit
operator|>
name|size
condition|)
block|{
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
operator|*
name|from
expr_stmt|;
name|from
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|to
operator|+
name|size
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loop outputs the LITTLENUMs in REVERSE order.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
decl_stmt|;
name|msp430_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|msp430_opcodes
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|msp430_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|msp430_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
decl_stmt|;
name|char
name|cmd
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Skip leading spaces.  */
name|str
operator|=
name|extract_cmd
argument_list|(
name|str
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|i
index|]
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|char
name|a
init|=
name|TOLOWER
argument_list|(
name|cmd
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|cmd
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmd
index|[
literal|0
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
operator|(
expr|struct
name|msp430_opcode_s
operator|*
operator|)
name|hash_find
argument_list|(
name|msp430_hash
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode `%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|char
modifier|*
name|__t
init|=
name|input_line_pointer
decl_stmt|;
name|msp430_operands
argument_list|(
name|opcode
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|__t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse instruction operands.    Return binary opcode.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|msp430_operands
parameter_list|(
name|opcode
parameter_list|,
name|line
parameter_list|)
name|struct
name|msp430_opcode_s
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|bin
init|=
name|opcode
operator|->
name|bin_opcode
decl_stmt|;
comment|/* opcode mask.  */
name|int
name|__is
decl_stmt|;
name|char
name|l1
index|[
name|MAX_OP_LEN
index|]
decl_stmt|,
name|l2
index|[
name|MAX_OP_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|struct
name|msp430_operand_s
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|static
name|short
name|ZEROS
init|=
literal|0
decl_stmt|;
name|int
name|byte_op
decl_stmt|,
name|imm_op
decl_stmt|;
comment|/* opcode is the one from opcodes table      line contains something like      [.w] @r2+, 5(R1)      or      .b @r2+, 5(R1).  */
comment|/* Check if byte or word operation.  */
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|TOLOWER
argument_list|(
operator|*
operator|(
name|line
operator|+
literal|1
operator|)
argument_list|)
operator|==
literal|'b'
condition|)
block|{
name|bin
operator||=
name|BYTE_OPERATION
expr_stmt|;
name|byte_op
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|byte_op
operator|=
literal|0
expr_stmt|;
comment|/* skip .[bwBW].  */
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|line
argument_list|)
operator|&&
operator|*
name|line
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|insn_opnumb
operator|&&
operator|(
operator|!
operator|*
name|line
operator|||
operator|*
name|line
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction %s requires %d operand(s)"
argument_list|)
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|insn_opnumb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|l1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|op1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|op2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|imm_op
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|fmt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Emulated.  */
switch|switch
condition|(
name|opcode
operator|->
name|insn_opnumb
condition|)
block|{
case|case
literal|0
case|:
comment|/* Set/clear bits instructions.  */
name|__is
operator|=
literal|2
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
name|__is
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Something which works with destination operand.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_dstoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
name|bin
operator||=
operator|(
name|op1
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
comment|/* Shift instruction.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|l2
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|l2
index|[
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
name|res
operator|+=
name|msp430_dstoperand
argument_list|(
operator|&
name|op2
argument_list|,
name|l2
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* An error occurred.  All warnings were done before.  */
name|bin
operator||=
operator|(
name|op2
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator||
operator|(
name|op2
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
operator|+
name|op2
operator|.
name|ol
expr_stmt|;
comment|/* insn size in words.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
comment|/* Advance 'where' as we do not know _where_.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op2
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
operator|+
operator|(
operator|(
name|__is
operator|==
literal|3
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|reg
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|3
case|:
comment|/* Branch instruction => mov dst, r0.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
name|byte_op
operator|=
literal|0
expr_stmt|;
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bin
operator||=
operator|(
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Format 1, double operand.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l2
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
name|res
operator|+=
name|msp430_dstoperand
argument_list|(
operator|&
name|op2
argument_list|,
name|l2
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* Error occurred.  All warnings were done before.  */
name|bin
operator||=
operator|(
name|op2
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
operator||
operator|(
name|op2
operator|.
name|am
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
operator|+
name|op2
operator|.
name|ol
expr_stmt|;
comment|/* insn size in words.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
comment|/* Advance where as we do not know _where_.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op2
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|imm_op
operator|=
literal|0
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
operator|+
operator|(
operator|(
name|__is
operator|==
literal|3
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|reg
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op2
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Single-operand mostly instr.  */
if|if
condition|(
name|opcode
operator|->
name|insn_opnumb
operator|==
literal|0
condition|)
block|{
comment|/* reti instruction.  */
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|msp430_srcoperand
argument_list|(
operator|&
name|op1
argument_list|,
name|l1
argument_list|,
name|opcode
operator|->
name|bin_opcode
argument_list|,
operator|&
name|imm_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
comment|/* Error in operand.  */
name|bin
operator||=
name|op1
operator|.
name|reg
operator||
operator|(
name|op1
operator|.
name|am
operator|<<
literal|4
operator|)
expr_stmt|;
name|__is
operator|=
literal|1
operator|+
name|op1
operator|.
name|ol
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|__is
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|mode
operator|==
name|OP_EXP
condition|)
block|{
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|ZEROS
argument_list|,
name|frag
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reg
operator|||
operator|(
name|op1
operator|.
name|reg
operator|==
literal|0
operator|&&
name|op1
operator|.
name|am
operator|==
literal|3
operator|)
condition|)
comment|/* Not PC relative.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|FALSE
argument_list|,
name|CHECK_RELOC_MSP430
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
operator|(
name|op1
operator|.
name|exp
operator|)
argument_list|,
name|TRUE
argument_list|,
name|CHECK_RELOC_MSP430_PCREL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Conditional jumps instructions.  */
name|line
operator|=
name|extract_operand
argument_list|(
name|line
argument_list|,
name|l1
argument_list|,
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* l1 is a label.  */
if|if
condition|(
name|l1
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|l1
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
literal|'$'
condition|)
name|m
operator|++
expr_stmt|;
name|parse_exp
argument_list|(
name|m
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|frag
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Instr size is 1 word.  */
comment|/* In order to handle something like:  	     and #0x8000, r5 	     tst r5 	     jz   4     ;       skip next 4 bytes 	     inv r5 	     inc r5 	     nop        ;       will jump here if r5 positive or zero  	     jCOND      -n      ;assumes jump n bytes backward:  	     mov r5,r6 	     jmp -2  	     is equal to: 	     lab: 	     mov r5,r6 	     jmp lab  	     jCOND      $n      ; jump from PC in either direction.  */
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Even number required. Rounded to %d"
argument_list|)
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|l1
operator|==
literal|'$'
operator|&&
name|x
operator|>
literal|0
operator|)
operator|||
name|x
operator|<
literal|0
condition|)
name|x
operator|-=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|512
operator|||
name|x
operator|<
operator|-
literal|511
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong displacement  %d"
argument_list|)
argument_list|,
name|x
operator|<<
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|bin
operator||=
name|x
operator|&
literal|0x3ff
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|l1
operator|!=
literal|'$'
condition|)
block|{
name|where
operator|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_MSP430_10_PCREL
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|l1
operator|==
literal|'$'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label sans '$'"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label or value in range -511:512"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction requires label"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ilegal instruction or not implmented opcode."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|line
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msp430_dstoperand
parameter_list|(
name|op
parameter_list|,
name|l
parameter_list|,
name|bin
parameter_list|)
name|struct
name|msp430_operand_s
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|;
name|int
name|bin
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
name|int
name|ret
init|=
name|msp430_srcoperand
argument_list|(
name|op
argument_list|,
name|l
argument_list|,
name|bin
argument_list|,
operator|&
name|dummy
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|op
operator|->
name|am
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|__tl
init|=
literal|"0"
decl_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal bug. Try to use 0(r%d) instead of @r%d"
argument_list|)
argument_list|,
name|op
operator|->
name|reg
argument_list|,
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|op
operator|->
name|am
operator|>
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"this addressing mode is not applicable for destination operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_reg
parameter_list|(
name|t
parameter_list|)
name|char
modifier|*
name|t
decl_stmt|;
block|{
comment|/* If this is a reg numb, str 't' must be a number from 0 - 15.  */
if|if
condition|(
name|strlen
argument_list|(
name|t
argument_list|)
operator|>
literal|2
operator|&&
operator|*
operator|(
name|t
operator|+
literal|2
operator|)
operator|!=
literal|'+'
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|<
literal|'0'
operator|||
operator|*
name|t
operator|>
literal|'9'
operator|)
operator|&&
operator|*
name|t
operator|!=
literal|'+'
condition|)
break|break;
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msp430_srcoperand
parameter_list|(
name|op
parameter_list|,
name|l
parameter_list|,
name|bin
parameter_list|,
name|imm_op
parameter_list|)
name|struct
name|msp430_operand_s
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|;
name|int
name|bin
decl_stmt|;
name|int
modifier|*
name|imm_op
decl_stmt|;
block|{
name|char
modifier|*
name|__tl
init|=
name|l
decl_stmt|;
comment|/* Check if an immediate #VALUE.  The hash sign should be only at the beginning!  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'#'
condition|)
block|{
name|char
modifier|*
name|h
init|=
name|l
decl_stmt|;
name|int
name|vshift
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* Check if there is: 	 llo(x) - least significant 16 bits, x&= 0xffff 	 lhi(x) - x = (x>> 16)& 0xffff, 	 hlo(x) - x = (x>> 32)& 0xffff, 	 hhi(x) - x = (x>> 48)& 0xffff 	 The value _MUST_ be constant expression: #hlo(1231231231).  */
operator|*
name|imm_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#llo("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#lhi("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hlo("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|2
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hhi("
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|3
expr_stmt|;
name|rval
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#lo("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|h
argument_list|,
literal|"#hi("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vshift
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|2
expr_stmt|;
block|}
name|op
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* Reg PC.  */
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Immediate  will follow an instruction.  */
name|__tl
operator|=
name|h
operator|+
literal|1
operator|+
name|rval
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|vshift
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|&
literal|0xffff
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vshift
operator|==
literal|1
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vshift
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Nothing left.  */
name|x
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|>
literal|65535
operator|||
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value %ld out of range. Use #lo() or #hi()"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now check constants.  */
comment|/* Substitute register mode with a constant generator if applicable.  */
name|x
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
comment|/* Extend sign.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|2
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_1X_WORKAROUND
if|if
condition|(
name|bin
operator|==
literal|0x1200
condition|)
block|{
comment|/* Remove warning as confusing. 		     as_warn(_("Hardware push bug workaround")); */
block|}
else|else
endif|#
directive|endif
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_1X_WORKAROUND
if|if
condition|(
name|bin
operator|==
literal|0x1200
condition|)
block|{
comment|/* Remove warning as confusing. 		     as_warn(_("Hardware push bug workaround")); */
block|}
else|else
endif|#
directive|endif
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
name|short
name|x
decl_stmt|;
if|if
condition|(
name|vshift
operator|!=
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0xffff
operator|&
name|generic_bignum
index|[
name|vshift
index|]
expr_stmt|;
name|x
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s. use #llo() #lhi() #hlo() #hhi() "
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|2
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|4
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
block|{
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|3
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Check if absolute&VALUE (assume that we can construct something like ((a&b)<<7 + 25).  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'&'
condition|)
block|{
name|char
modifier|*
name|h
init|=
name|l
decl_stmt|;
name|op
operator|->
name|reg
operator|=
literal|2
expr_stmt|;
comment|/* reg 2 in absolute addr mode.  */
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
comment|/* mode As == 01 bin.  */
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Immediate value followed by instruction.  */
name|__tl
operator|=
name|h
operator|+
literal|1
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|65535
operator|||
name|x
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value out of range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{ 	}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Check if indirect register mode @Rn / postincrement @Rn+.  */
if|if
condition|(
operator|*
name|l
operator|==
literal|'@'
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|m
init|=
name|strchr
argument_list|(
name|l
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|l
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'r'
operator|&&
operator|*
name|t
operator|!=
literal|'R'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
comment|/* Points to the reg value.  */
if|if
condition|(
name|check_reg
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad register name r%s"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
name|m
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
condition|)
operator|*
name|m
operator|=
literal|0
expr_stmt|;
comment|/* strip '+' */
name|op
operator|->
name|reg
operator|=
name|atoi
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|<
literal|0
operator|||
name|op
operator|->
name|reg
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MSP430 does not have %d registers"
argument_list|)
argument_list|,
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Check if register indexed X(Rn).  */
do|do
block|{
name|char
modifier|*
name|h
init|=
name|strrchr
argument_list|(
name|l
argument_list|,
literal|'('
argument_list|)
decl_stmt|;
name|char
modifier|*
name|m
init|=
name|strrchr
argument_list|(
name|l
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
operator|*
name|imm_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
break|break;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"')' required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
name|h
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
comment|/* Extract a register.  */
name|t
operator|++
expr_stmt|;
comment|/* Advance pointer.  */
if|if
condition|(
operator|*
name|t
operator|!=
literal|'r'
operator|&&
operator|*
name|t
operator|!=
literal|'R'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s. Did you mean X(Rn) or #[hl][hl][oi](CONST) ?"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
name|op
operator|->
name|reg
operator|=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|>
literal|9
operator|||
name|op
operator|->
name|reg
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator (r%s substituded as a register name"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|')'
condition|)
block|{
name|op
operator|->
name|reg
operator|=
name|op
operator|->
name|reg
operator|*
literal|10
expr_stmt|;
name|op
operator|->
name|reg
operator|+=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|op
operator|->
name|reg
operator|==
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"r2 should not be used in indexed addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operator %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Extract constant.  */
name|__tl
operator|=
name|l
expr_stmt|;
operator|*
name|h
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|65535
operator|||
name|x
operator|<
operator|-
literal|32768
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value out of range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{ 	}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown expression in operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Register mode 'mov r1,r2'.  */
do|do
block|{
name|char
modifier|*
name|t
init|=
name|l
decl_stmt|;
comment|/* Operand should be a register.  */
if|if
condition|(
operator|*
name|t
operator|==
literal|'r'
operator|||
operator|*
name|t
operator|==
literal|'R'
condition|)
block|{
name|int
name|x
init|=
name|atoi
argument_list|(
name|t
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_reg
argument_list|(
name|t
operator|+
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|15
condition|)
break|break;
comment|/* Symbolic mode.  */
name|op
operator|->
name|mode
operator|=
name|OP_REG
expr_stmt|;
name|op
operator|->
name|am
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|reg
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Symbolic mode 'mov a, b' == 'mov x(pc), y(pc)'.  */
do|do
block|{
name|char
modifier|*
name|t
init|=
name|l
decl_stmt|;
name|__tl
operator|=
name|l
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
comment|/* alpha/number    underline     dot for labels.  */
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|&&
operator|*
name|t
operator|!=
literal|'_'
operator|&&
operator|*
name|t
operator|!=
literal|'.'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
name|op
operator|->
name|mode
operator|=
name|OP_EXP
expr_stmt|;
name|op
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* PC relative... be careful.  */
name|op
operator|->
name|am
operator|=
literal|1
expr_stmt|;
name|op
operator|->
name|ol
operator|=
literal|1
expr_stmt|;
name|__tl
operator|=
name|l
expr_stmt|;
name|parse_exp
argument_list|(
name|__tl
argument_list|,
operator|&
operator|(
name|op
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Unreachable.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown addressing mode for operand %s"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* GAS will call this function for each section at the end of the assembly,    to permit the CPU backend to adjust the alignment of a section.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If you define this macro, it should return the offset between the    address of a PC relative fixup and the position from which the PC    relative adjustment should be made.  On many processors, the base    of a PC relative instruction is the next instruction, so this    macro would return the length of an instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixp
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* GAS will call this for each fixup.  It should store the correct    value in the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixp
parameter_list|,
name|valuep
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|valueT
modifier|*
name|valuep
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|long
name|value
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|segT
name|s
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
operator|(
name|s
operator|==
name|seg
operator|||
name|s
operator|==
name|absolute_section
operator|)
condition|)
block|{
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|+
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
default|default:
name|fixp
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_10_PCREL
case|:
break|break;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_MSP430_10_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Jumps are in words.  */
name|value
operator|>>=
literal|1
expr_stmt|;
operator|--
name|value
expr_stmt|;
comment|/* Correct PC.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|512
operator|||
name|value
operator|>
literal|511
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0x3ff
expr_stmt|;
comment|/* get rid of extended sign */
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator||
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_16_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Nothing to be corrected here.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|65536
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffff
expr_stmt|;
comment|/* Get rid of extended sign.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_16_PCREL_BYTE
case|:
comment|/* Nothing to be corrected here.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|65536
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffff
expr_stmt|;
comment|/* Get rid of extended sign.  */
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MSP430_16
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_MSP430_16_BYTE
case|:
name|value
operator|&=
literal|0xffff
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"line %d: unknown relocation type: 0x%x"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fixp
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A `BFD_ASSEMBLER' GAS will call this to generate a reloc.  GAS    will pass the resulting reloc to `bfd_install_relocation'.  This    currently works poorly, as `bfd_install_relocation' often does the    wrong thing, and instances of `tc_gen_reloc' have been written to    work around the problems, which in turns makes it difficult to fix    `bfd_install_relocation'.  */
end_comment

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Parse ordinary expression.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|s
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|op
decl_stmt|;
block|{
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|input_line_pointer
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

