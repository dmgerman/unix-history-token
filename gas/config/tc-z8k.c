begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-z8k.c -- Assemble code for the Zilog Z800n    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003,    2005, 2006 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Written By Steve Chamberlain<sac@cygnus.com>.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"opcodes/z8k-opc.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|coff_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|segmented_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is non-zero if target was set from the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|z8k_target_from_cmdline
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s_segm
parameter_list|(
name|int
name|segm
parameter_list|)
block|{
if|if
condition|(
name|segm
condition|)
block|{
name|segmented_mode
operator|=
literal|1
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|bfd_mach_z8001
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segmented_mode
operator|=
literal|0
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|bfd_mach_z8002
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|even
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
operator|-
literal|'a'
operator|+
literal|10
return|;
return|return
name|c
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sval
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
name|int
name|c
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|(
name|tohex
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|tohex
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function    */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data.b"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"data.w"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data.l"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"form"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"program"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"z8001"
block|,
name|s_segm
block|,
literal|1
block|}
block|,
block|{
literal|"z8002"
block|,
name|s_segm
block|,
literal|0
block|}
block|,
block|{
literal|"segm"
block|,
name|s_segm
block|,
literal|1
block|}
block|,
block|{
literal|"unsegm"
block|,
name|s_segm
block|,
literal|0
block|}
block|,
block|{
literal|"unseg"
block|,
name|s_segm
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
name|s_app_file
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"wval"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"lval"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"bval"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"sval"
block|,
name|sval
block|,
literal|0
block|}
block|,
block|{
literal|"rsect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|even
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.    As in 0f12.456    or    0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|z8k_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
comment|/* Only enter unique codes into the table.  */
if|if
condition|(
name|idx
operator|!=
name|opcode
operator|->
name|idx
condition|)
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|idx
operator|=
name|opcode
operator|->
name|idx
expr_stmt|;
block|}
comment|/* Default to z8002.  */
if|if
condition|(
operator|!
name|z8k_target_from_cmdline
condition|)
name|s_segm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Insert the pseudo ops, too.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|md_pseudo_table
index|[
name|idx
index|]
operator|.
name|poc_name
condition|;
name|idx
operator|++
control|)
block|{
name|opcode_entry_type
modifier|*
name|fake_opcode
decl_stmt|;
name|fake_opcode
operator|=
operator|(
name|opcode_entry_type
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opcode_entry_type
argument_list|)
argument_list|)
expr_stmt|;
name|fake_opcode
operator|->
name|name
operator|=
name|md_pseudo_table
index|[
name|idx
index|]
operator|.
name|poc_name
expr_stmt|;
name|fake_opcode
operator|->
name|func
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|md_pseudo_table
operator|+
name|idx
operator|)
expr_stmt|;
name|fake_opcode
operator|->
name|opcode
operator|=
literal|250
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|fake_opcode
operator|->
name|name
argument_list|,
name|fake_opcode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|z8k_op
block|{
comment|/* CLASS_REG_xxx.  */
name|int
name|regsize
decl_stmt|;
comment|/* 0 .. 15.  */
name|unsigned
name|int
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Any other register associated with the mode.  */
name|unsigned
name|int
name|x_reg
decl_stmt|;
comment|/* Any expression.  */
name|expressionS
name|exp
decl_stmt|;
block|}
name|op_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|expressionS
modifier|*
name|da_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
modifier|*
name|imm_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|the_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|the_ctrl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|the_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|the_interrupt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine register number.  src points to the ascii number    (after "rl", "rh", "r", "rr", or "rq").  If a character    outside the set of {0,',',')','('} follows the number,    return NULL to indicate that it's not a valid register    number.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|whatreg
parameter_list|(
name|unsigned
name|int
modifier|*
name|reg
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
name|unsigned
name|int
name|new_reg
decl_stmt|;
comment|/* src[0] is already known to be a digit.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|new_reg
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|new_reg
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|src
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|src
index|[
literal|0
index|]
operator|!=
literal|','
operator|&&
name|src
index|[
literal|0
index|]
operator|!=
literal|'('
operator|&&
name|src
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
return|return
name|NULL
return|;
operator|*
name|reg
operator|=
name|new_reg
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* Parse operands     rh0-rh7, rl0-rl7    r0-r15    rr0-rr14    rq0--rq12    WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp    r0l,r0h,..r7l,r7h    @WREG    @WREG+    @-WREG    #const */
end_comment

begin_comment
comment|/* Try to parse a reg name.  Return a pointer to the first character    in SRC after the reg name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_reg
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
modifier|*
name|reg
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|char
name|regno
decl_stmt|;
comment|/* Check for stack pointer "sp" alias.  */
if|if
condition|(
operator|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|src
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|src
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|src
index|[
literal|2
index|]
operator|==
literal|','
operator|)
condition|)
block|{
if|if
condition|(
name|segmented_mode
condition|)
block|{
operator|*
name|mode
operator|=
name|CLASS_REG_LONG
expr_stmt|;
operator|*
name|reg
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mode
operator|=
name|CLASS_REG_WORD
expr_stmt|;
operator|*
name|reg
operator|=
literal|15
expr_stmt|;
block|}
return|return
name|src
operator|+
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|src
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'r'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|NULL
return|;
comment|/* Assume no register name but a label starting with 'rr'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_LONG
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Not a valid register name.  */
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|14
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rr%d out of range"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|&
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rr%d does not exist"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'h'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'H'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|NULL
return|;
comment|/* Assume no register name but a label starting with 'rh'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_BYTE
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Not a valid register name.  */
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rh%d out of range"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|NULL
return|;
comment|/* Assume no register name but a label starting with 'rl'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_BYTE
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Not a valid register name.  */
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rl%d out of range"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
operator|*
name|reg
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'q'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'Q'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|NULL
return|;
comment|/* Assume no register name but a label starting with 'rq'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_QUAD
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Not a valid register name.  */
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|12
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rq%d out of range"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|&
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register rq%d does not exist"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|1
index|]
operator|>
literal|'9'
condition|)
return|return
name|NULL
return|;
comment|/* Assume no register name but a label starting with 'r'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_WORD
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Not a valid register name.  */
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register r%d out of range"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* The many forms of operand:<rb><r><rr><rq>    @r    #exp    exp    exp(r)    r(#exp)    r(r)    */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|checkfor
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|char
name|what
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|what
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected %c"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Make sure the mode supplied is the size of a word.  */
end_comment

begin_function
specifier|static
name|void
name|regword
parameter_list|(
name|int
name|mode
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|CLASS_REG_WORD
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
name|mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register is wrong size for a word %s"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure the mode supplied is the size of an address.  */
end_comment

begin_function
specifier|static
name|void
name|regaddr
parameter_list|(
name|int
name|mode
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|segmented_mode
condition|?
name|CLASS_REG_LONG
else|:
name|CLASS_REG_WORD
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
name|mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register is wrong size for address %s"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|ctrl_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ctrl_names
name|ctrl_table
index|[]
init|=
block|{
block|{
literal|0x1
block|,
literal|"flags"
block|}
block|,
comment|/* ldctlb only.  */
block|{
literal|0x2
block|,
literal|"fcw"
block|}
block|,
comment|/* ldctl only.  Applies to all remaining control registers.  */
block|{
literal|0x3
block|,
literal|"refresh"
block|}
block|,
block|{
literal|0x4
block|,
literal|"psapseg"
block|}
block|,
block|{
literal|0x5
block|,
literal|"psapoff"
block|}
block|,
block|{
literal|0x5
block|,
literal|"psap"
block|}
block|,
block|{
literal|0x6
block|,
literal|"nspseg"
block|}
block|,
block|{
literal|0x7
block|,
literal|"nspoff"
block|}
block|,
block|{
literal|0x7
block|,
literal|"nsp"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_ctrl_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_CTRL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|the_ctrl
operator|=
name|ctrl_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|&&
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|!=
literal|','
condition|)
break|break;
operator|*
name|ptr
operator|=
name|src
operator|+
name|l
expr_stmt|;
comment|/* Valid control name found: "consume" it.  */
return|return;
block|}
block|}
name|the_ctrl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|flag_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|flag_names
name|flag_table
index|[]
init|=
block|{
block|{
literal|0x1
block|,
literal|"P"
block|}
block|,
block|{
literal|0x1
block|,
literal|"V"
block|}
block|,
block|{
literal|0x2
block|,
literal|"S"
block|}
block|,
block|{
literal|0x4
block|,
literal|"Z"
block|}
block|,
block|{
literal|0x8
block|,
literal|"C"
block|}
block|,
block|{
literal|0x0
block|,
literal|"+"
block|}
block|,
block|{
literal|0x0
block|,
literal|","
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_flags_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_FLAGS
expr_stmt|;
name|the_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|9
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|src
index|[
name|j
index|]
condition|)
goto|goto
name|done
goto|;
name|c
operator|=
name|TOUPPER
argument_list|(
name|src
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flag_table
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|c
condition|)
block|{
name|the_flags
operator|=
name|the_flags
operator||
name|flag_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
goto|goto
name|match
goto|;
block|}
block|}
goto|goto
name|done
goto|;
name|match
label|:
empty_stmt|;
block|}
name|done
label|:
operator|*
name|ptr
operator|=
name|src
operator|+
name|j
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|interrupt_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|interrupt_names
name|intr_table
index|[]
init|=
block|{
block|{
literal|0x1
block|,
literal|"nvi"
block|}
block|,
block|{
literal|0x2
block|,
literal|"vi"
block|}
block|,
block|{
literal|0x3
block|,
literal|"both"
block|}
block|,
block|{
literal|0x3
block|,
literal|"all"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_interrupt_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_IMM
expr_stmt|;
name|the_interrupt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|intr_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|intr_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|intr_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|the_interrupt
operator||=
name|intr_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|&&
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|!=
literal|','
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
operator|+
name|l
expr_stmt|;
name|invalid
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown interrupt %s"
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|ptr
index|]
condition|)
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
comment|/* Consume rest of line.  */
return|return;
block|}
name|src
operator|+=
name|l
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|src
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|','
condition|)
name|src
operator|++
expr_stmt|;
else|else
block|{
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
block|}
comment|/* No interrupt type specified, opcode won't do anything.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"opcode has no effect"
argument_list|)
argument_list|)
expr_stmt|;
name|the_interrupt
operator|=
literal|0x0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|cc_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cc_names
name|table
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"f"
block|}
block|,
block|{
literal|0x1
block|,
literal|"lt"
block|}
block|,
block|{
literal|0x2
block|,
literal|"le"
block|}
block|,
block|{
literal|0x3
block|,
literal|"ule"
block|}
block|,
block|{
literal|0x4
block|,
literal|"ov/pe"
block|}
block|,
block|{
literal|0x4
block|,
literal|"ov"
block|}
block|,
block|{
literal|0x4
block|,
literal|"pe/ov"
block|}
block|,
block|{
literal|0x4
block|,
literal|"pe"
block|}
block|,
block|{
literal|0x5
block|,
literal|"mi"
block|}
block|,
block|{
literal|0x6
block|,
literal|"eq"
block|}
block|,
block|{
literal|0x6
block|,
literal|"z"
block|}
block|,
block|{
literal|0x7
block|,
literal|"c/ult"
block|}
block|,
block|{
literal|0x7
block|,
literal|"c"
block|}
block|,
block|{
literal|0x7
block|,
literal|"ult/c"
block|}
block|,
block|{
literal|0x7
block|,
literal|"ult"
block|}
block|,
block|{
literal|0x8
block|,
literal|"t"
block|}
block|,
block|{
literal|0x9
block|,
literal|"ge"
block|}
block|,
block|{
literal|0xa
block|,
literal|"gt"
block|}
block|,
block|{
literal|0xb
block|,
literal|"ugt"
block|}
block|,
block|{
literal|0xc
block|,
literal|"nov/po"
block|}
block|,
block|{
literal|0xc
block|,
literal|"nov"
block|}
block|,
block|{
literal|0xc
block|,
literal|"po/nov"
block|}
block|,
block|{
literal|0xc
block|,
literal|"po"
block|}
block|,
block|{
literal|0xd
block|,
literal|"pl"
block|}
block|,
block|{
literal|0xe
block|,
literal|"ne"
block|}
block|,
block|{
literal|0xe
block|,
literal|"nz"
block|}
block|,
block|{
literal|0xf
block|,
literal|"nc/uge"
block|}
block|,
block|{
literal|0xf
block|,
literal|"nc"
block|}
block|,
block|{
literal|0xf
block|,
literal|"uge/nc"
block|}
block|,
block|{
literal|0xf
block|,
literal|"uge"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_cc_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_CC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|the_cc
operator|=
name|table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|&&
operator|*
operator|(
name|src
operator|+
name|l
operator|)
operator|!=
literal|','
condition|)
break|break;
operator|*
name|ptr
operator|=
name|src
operator|+
name|l
expr_stmt|;
comment|/* Valid cc found: "consume" it.  */
return|return;
block|}
block|}
name|the_cc
operator|=
literal|0x8
expr_stmt|;
comment|/* Not recognizing the cc defaults to t.  (Assuming no cc present.)  */
block|}
end_function

begin_function
specifier|static
name|void
name|get_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|mode
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
block|{
name|mode
operator|->
name|mode
operator|=
name|CLASS_IMM
expr_stmt|;
name|imm_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
name|src
operator|=
name|parse_exp
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
block|{
name|mode
operator|->
name|mode
operator|=
name|CLASS_IR
expr_stmt|;
name|src
operator|=
name|parse_reg
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
name|mode
operator|->
name|regsize
argument_list|,
operator|&
name|mode
operator|->
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|regn
decl_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
operator|->
name|mode
argument_list|,
operator|&
name|regn
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|int
name|nw
decl_stmt|;
name|unsigned
name|int
name|nr
decl_stmt|;
name|src
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|nw
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
comment|/* Got Ra(Rb).  */
name|src
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing ) in ra(rb)"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src
operator|++
expr_stmt|;
name|regaddr
argument_list|(
name|mode
operator|->
name|mode
argument_list|,
literal|"ra(rb) ra"
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_BX
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
name|nr
expr_stmt|;
name|reg
index|[
name|ARG_RX
index|]
operator|=
name|nr
expr_stmt|;
block|}
else|else
block|{
comment|/* Got Ra(disp).  */
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
name|src
operator|++
expr_stmt|;
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|checkfor
argument_list|(
name|src
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_BA
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|imm_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No initial reg.  */
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|mode
operator|)
argument_list|,
operator|&
name|regn
argument_list|)
expr_stmt|;
name|regword
argument_list|(
name|mode
operator|->
name|mode
argument_list|,
literal|"addr(Ra) ra"
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_X
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|da_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
name|src
operator|=
name|checkfor
argument_list|(
name|end
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just an address.  */
name|mode
operator|->
name|mode
operator|=
name|CLASS_DA
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|da_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
specifier|const
name|opcode_entry_type
modifier|*
name|opcode
parameter_list|,
name|char
modifier|*
name|op_end
parameter_list|,
name|op_type
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
name|op_end
decl_stmt|;
name|char
modifier|*
name|savptr
decl_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|noperands
condition|)
block|{
case|case
literal|0
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CC
condition|)
block|{
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid condition code '%s'"
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Consume rest of line.  */
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_FLAGS
condition|)
block|{
name|get_flags_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid flag '%s'"
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
index|]
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Consume rest of line.  */
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
operator|(
name|CLASS_IMM
operator|+
operator|(
name|ARG_IMM2
operator|)
operator|)
condition|)
name|get_interrupt_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|savptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CC
condition|)
block|{
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|','
operator|&&
name|strchr
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
condition|)
block|{
name|savptr
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid condition code '%s'"
argument_list|)
argument_list|,
name|savptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CTRL
condition|)
block|{
name|get_ctrl_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ctrl
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|savptr
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_ctrl_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ctrl
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|ptr
return|;
block|}
block|}
else|else
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Passed a pointer to a list of opcodes which use different    addressing modes.  Return the opcode which matches the opcodes    provided.  */
end_comment

begin_function
specifier|static
name|opcode_entry_type
modifier|*
name|get_specific
parameter_list|(
name|opcode_entry_type
modifier|*
name|opcode
parameter_list|,
name|op_type
modifier|*
name|operands
parameter_list|)
block|{
name|opcode_entry_type
modifier|*
name|this_try
init|=
name|opcode
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|noperands
init|=
name|opcode
operator|->
name|noperands
decl_stmt|;
name|int
name|this_index
init|=
name|opcode
operator|->
name|idx
decl_stmt|;
while|while
condition|(
name|this_index
operator|==
name|opcode
operator|->
name|idx
operator|&&
operator|!
name|found
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|this_try
operator|=
name|opcode
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|mode
init|=
name|operands
index|[
name|i
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|CLASS_MASK
operator|)
operator|==
name|CLASS_IR
operator|)
operator|&&
operator|(
operator|(
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|CLASS_MASK
operator|)
operator|==
name|CLASS_IRO
operator|)
condition|)
block|{
name|mode
operator|=
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|=
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|&
operator|~
name|CLASS_MASK
operator|)
operator||
name|CLASS_IRO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|CLASS_MASK
operator|)
operator|!=
operator|(
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|CLASS_MASK
operator|)
condition|)
block|{
comment|/* It could be a pc rel operand, if this is a da mode 		 and we like disps, then insert it.  */
if|if
condition|(
name|mode
operator|==
name|CLASS_DA
operator|&&
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|==
name|CLASS_DISP
condition|)
block|{
comment|/* This is the case.  */
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|CLASS_DISP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CLASS_BA
operator|&&
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
condition|)
block|{
comment|/* Can't think of a way to turn what we've been 		     given into something that's OK.  */
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|CLASS_PR
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|CLASS_REG_LONG
operator|&&
name|segmented_mode
condition|)
block|{
comment|/* OK.  */
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CLASS_REG_WORD
operator|&&
operator|!
name|segmented_mode
condition|)
block|{
comment|/* OK.  */
block|}
else|else
goto|goto
name|fail
goto|;
block|}
else|else
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mode
operator|&
name|CLASS_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|CLASS_IRO
case|:
if|if
condition|(
name|operands
index|[
name|i
index|]
operator|.
name|regsize
operator|!=
name|CLASS_REG_WORD
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid indirect register size"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
index|[
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|ARG_MASK
index|]
operator|=
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|CLASS_IR
case|:
if|if
condition|(
operator|(
name|segmented_mode
operator|&&
name|operands
index|[
name|i
index|]
operator|.
name|regsize
operator|!=
name|CLASS_REG_LONG
operator|)
operator|||
operator|(
operator|!
name|segmented_mode
operator|&&
name|operands
index|[
name|i
index|]
operator|.
name|regsize
operator|!=
name|CLASS_REG_WORD
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid indirect register size"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
index|[
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|ARG_MASK
index|]
operator|=
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|CLASS_X
case|:
case|case
name|CLASS_BA
case|:
case|case
name|CLASS_BX
case|:
case|case
name|CLASS_DISP
case|:
case|case
name|CLASS_REG
case|:
case|case
name|CLASS_REG_WORD
case|:
case|case
name|CLASS_REG_BYTE
case|:
case|case
name|CLASS_REG_QUAD
case|:
case|case
name|CLASS_REG_LONG
case|:
case|case
name|CLASS_REGN0
case|:
name|reg
index|[
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|ARG_MASK
index|]
operator|=
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|CLASS_CTRL
case|:
if|if
condition|(
name|this_try
operator|->
name|opcode
operator|==
name|OPC_ldctlb
operator|&&
name|the_ctrl
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid control register name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|found
operator|=
literal|1
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
name|this_try
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|newfix
parameter_list|(
name|int
name|ptr
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|operand
parameter_list|)
block|{
name|int
name|is_pcrel
init|=
literal|0
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Size is in nibbles.  */
if|if
condition|(
name|operand
operator|->
name|X_add_symbol
operator|||
name|operand
operator|->
name|X_op_symbol
operator|||
name|operand
operator|->
name|X_add_number
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_Z8K_CALLR
case|:
case|case
name|BFD_RELOC_Z8K_DISP7
case|:
name|is_pcrel
operator|=
literal|1
expr_stmt|;
block|}
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|ptr
argument_list|,
name|size
operator|/
literal|2
argument_list|,
name|operand
argument_list|,
name|is_pcrel
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pcrel
condition|)
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|apply_fix
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|type
parameter_list|,
name|expressionS
modifier|*
name|operand
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|long
name|n
init|=
name|operand
operator|->
name|X_add_number
decl_stmt|;
comment|/* size is in nibbles.  */
name|newfix
argument_list|(
operator|(
name|ptr
operator|-
name|buffer
operator|)
operator|/
literal|2
argument_list|,
name|type
argument_list|,
name|size
operator|+
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
comment|/* 8 nibbles == 32 bits.  */
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|28
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|24
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|20
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
case|case
literal|4
case|:
comment|/* 4 nibbles == 16 bits.  */
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|12
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|8
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|4
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Now we know what sort of opcodes it is.  Let's build the bytes.  */
end_comment

begin_function
specifier|static
name|void
name|build_bytes
parameter_list|(
name|opcode_entry_type
modifier|*
name|this_try
parameter_list|,
name|struct
name|z8k_op
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|output_ptr
init|=
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|nibble
decl_stmt|;
name|unsigned
name|int
modifier|*
name|class_ptr
decl_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag_room
argument_list|()
operator|<
literal|8
condition|)
name|frag_grow
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Make room for maximum instruction size.  */
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|class_ptr
operator|=
name|this_try
operator|->
name|byte_info
expr_stmt|;
for|for
control|(
name|nibble
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|class_ptr
operator|++
operator|)
condition|;
name|nibble
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|&
name|CLASS_MASK
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CLASS_ADDRESS
case|:
comment|/* Direct address, we don't cope with the SS mode right now.  */
if|if
condition|(
name|segmented_mode
condition|)
block|{
comment|/* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_32
argument_list|,
name|da_operand
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_16
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_DISP8
case|:
comment|/* pc rel 8 bit  */
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_0DISP7
case|:
comment|/* pc rel 7 bit  */
operator|*
name|output_ptr
operator|=
literal|0
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_Z8K_DISP7
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_1DISP7
case|:
comment|/* pc rel 7 bit  */
operator|*
name|output_ptr
operator|=
literal|0x80
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_Z8K_DISP7
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|output_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|0x8
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_BIT_1OR2
case|:
operator|*
name|output_ptr
operator|=
name|c
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|imm_operand
condition|)
block|{
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|==
literal|2
condition|)
operator|*
name|output_ptr
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate must be 1 or 2"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate 1 or 2 expected"
argument_list|)
argument_list|)
expr_stmt|;
name|output_ptr
operator|++
expr_stmt|;
break|break;
case|case
name|CLASS_CC
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_cc
expr_stmt|;
break|break;
case|case
name|CLASS_0CCC
case|:
if|if
condition|(
name|the_ctrl
operator|<
literal|2
operator|||
name|the_ctrl
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid control register name"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output_ptr
operator|++
operator|=
name|the_ctrl
expr_stmt|;
break|break;
case|case
name|CLASS_1CCC
case|:
if|if
condition|(
name|the_ctrl
operator|<
literal|2
operator|||
name|the_ctrl
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid control register name"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output_ptr
operator|++
operator|=
name|the_ctrl
operator||
literal|0x8
expr_stmt|;
break|break;
case|case
name|CLASS_00II
case|:
operator|*
name|output_ptr
operator|++
operator|=
operator|(
operator|~
name|the_interrupt
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
name|CLASS_01II
case|:
operator|*
name|output_ptr
operator|++
operator|=
operator|(
operator|~
name|the_interrupt
operator|&
literal|0x3
operator|)
operator||
literal|0x4
expr_stmt|;
break|break;
case|case
name|CLASS_FLAGS
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_flags
expr_stmt|;
break|break;
case|case
name|CLASS_IGNORE
case|:
case|case
name|CLASS_BIT
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|c
operator|&
literal|0xf
expr_stmt|;
break|break;
case|case
name|CLASS_REGN0
case|:
if|if
condition|(
name|reg
index|[
name|c
operator|&
literal|0xf
index|]
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't use R0 here"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CLASS_REG
case|:
case|case
name|CLASS_REG_BYTE
case|:
case|case
name|CLASS_REG_WORD
case|:
case|case
name|CLASS_REG_LONG
case|:
case|case
name|CLASS_REG_QUAD
case|:
comment|/* Insert bit mattern of right reg.  */
operator|*
name|output_ptr
operator|++
operator|=
name|reg
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
break|break;
case|case
name|CLASS_DISP
case|:
switch|switch
condition|(
name|c
operator|&
name|ARG_MASK
condition|)
block|{
case|case
name|ARG_DISP12
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_Z8K_CALLR
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_DISP16
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_16
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_IMM
case|:
block|{
switch|switch
condition|(
name|c
operator|&
name|ARG_MASK
condition|)
block|{
case|case
name|ARG_NIM4
case|:
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|>
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_operand
operator|->
name|X_add_number
operator|=
operator|-
name|imm_operand
operator|->
name|X_add_number
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_Z8K_IMM4L
argument_list|,
name|imm_operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/*case ARG_IMMNMINUS1: not used.  */
case|case
name|ARG_IMM4M1
case|:
name|imm_operand
operator|->
name|X_add_number
operator|--
expr_stmt|;
comment|/* Drop through.  */
case|case
name|ARG_IMM4
case|:
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|>
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_Z8K_IMM4L
argument_list|,
name|imm_operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NIM8
case|:
name|imm_operand
operator|->
name|X_add_number
operator|=
operator|-
name|imm_operand
operator|->
name|X_add_number
expr_stmt|;
comment|/* Drop through.  */
case|case
name|ARG_IMM8
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_8
argument_list|,
name|imm_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMM16
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_16
argument_list|,
name|imm_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMM32
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|BFD_RELOC_32
argument_list|,
name|imm_operand
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Copy from the nibble buffer into the frag.  */
block|{
name|int
name|length
init|=
operator|(
name|output_ptr
operator|-
name|buffer
operator|)
operator|/
literal|2
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|fragp
init|=
name|frag_more
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|src
operator|<
name|output_ptr
condition|)
block|{
operator|*
name|fragp
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
name|src
index|[
literal|1
index|]
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|fragp
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|struct
name|z8k_op
name|operand
index|[
literal|4
index|]
decl_stmt|;
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|str
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|op_end
index|]
condition|;
name|op_end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|op_end
operator|==
name|op_start
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|op_end
expr_stmt|;
operator|*
name|op_end
operator|=
literal|0
expr_stmt|;
comment|/* Zero-terminate op code string for hash_find() call.  */
name|opcode
operator|=
operator|(
name|opcode_entry_type
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|op_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|op_end
operator|=
name|c
expr_stmt|;
comment|/* Restore original string.  */
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|==
literal|250
condition|)
block|{
name|pseudo_typeS
modifier|*
name|p
decl_stmt|;
name|char
name|oc
decl_stmt|;
name|char
modifier|*
name|old
init|=
name|input_line_pointer
decl_stmt|;
comment|/* Was really a pseudo op.  */
name|input_line_pointer
operator|=
name|op_end
expr_stmt|;
name|oc
operator|=
operator|*
name|old
expr_stmt|;
operator|*
name|old
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|p
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
operator|(
name|opcode
operator|->
name|func
operator|)
expr_stmt|;
call|(
name|p
operator|->
name|poc_handler
call|)
argument_list|(
name|p
operator|->
name|poc_val
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|old
expr_stmt|;
operator|*
name|old
operator|=
name|oc
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|new_input_line_pointer
decl_stmt|;
name|new_input_line_pointer
operator|=
name|get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_input_line_pointer
condition|)
block|{
name|input_line_pointer
operator|=
name|new_input_line_pointer
expr_stmt|;
name|opcode
operator|=
name|get_specific
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_input_line_pointer
operator|==
name|NULL
operator|||
name|opcode
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands.  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't find opcode to match operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_bytes
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Various routines to kill one day.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"z:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE)
block|{
literal|"linkrelax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'z'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"8001"
argument_list|)
condition|)
name|s_segm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"8002"
argument_list|)
condition|)
name|s_segm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architecture -z%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|z8k_target_from_cmdline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_RELAX
case|:
name|linkrelax
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\  Z8K options:\n\   -z8001                  generate segmented code\n\   -z8002                  generate unsegmented code\n\   -linkrelax              create linker relaxable code\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to md_convert_frag\n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a machine dependent reloc from a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
operator|->
name|howto
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent %s relocation in object file"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
name|valueT
name|mask
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify or eliminate a fixup. To indicate that a fixup    has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,    we will have to generate a reloc entry.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_Z8K_IMM4L
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|val
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot branch to odd address"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
operator|||
name|val
operator|<
operator|-
literal|128
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relative jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|val
operator|-
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|fixP
operator|->
name|fx_size
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|32767
operator|||
name|val
operator|<
operator|-
literal|32768
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relative address out of range"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_Z8K_CALLR
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot branch to odd address"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|4096
operator|||
name|val
operator|<
operator|-
literal|4095
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relative call out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|-
name|val
operator|/
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_Z8K_DISP7
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot branch to odd address"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
operator|||
name|val
operator|<
operator|-
literal|127
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relative jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|-
name|val
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"md_apply_fix: unknown r_type 0x%x\n"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to md_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|valueT
name|use
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* On the Z8000, a PC-relative offset is relative to the address of the    instruction plus its size.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_function
name|void
name|tc_coff_symbol_emit_hook
parameter_list|(
name|symbolS
modifier|*
name|s
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

end_unit

