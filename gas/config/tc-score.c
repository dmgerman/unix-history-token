begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-score.c -- Assembler for Score    Copyright 2006 Free Software Foundation, Inc.    Contributed by:    Mei Ligang (ligang@sunnorth.com.cn)    Pei-Lin Tsai (pltsai@sunplus.com)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/score-inst.h"
end_include

begin_include
include|#
directive|include
file|"opcode/score-datadep.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/score.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GP
value|28
end_define

begin_define
define|#
directive|define
name|PIC_CALL_REG
value|29
end_define

begin_define
define|#
directive|define
name|MAX_LITERAL_POOL_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|FAIL
value|0x80000000
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|INSN_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|INSN16_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|RELAX_INST_NUM
value|3
end_define

begin_comment
comment|/* For score5u : div/mul will pop warning message, mmu/alw/asw will pop error message.  */
end_comment

begin_define
define|#
directive|define
name|BAD_ARGS
value|_("bad arguments to instruction")
end_define

begin_define
define|#
directive|define
name|BAD_PC
value|_("r15 not allowed here")
end_define

begin_define
define|#
directive|define
name|BAD_COND
value|_("instruction is not conditional")
end_define

begin_define
define|#
directive|define
name|ERR_NO_ACCUM
value|_("acc0 expected")
end_define

begin_define
define|#
directive|define
name|ERR_FOR_SCORE5U_MUL_DIV
value|_("div / mul are reserved instructions")
end_define

begin_define
define|#
directive|define
name|ERR_FOR_SCORE5U_MMU
value|_("This architecture doesn't support mmu")
end_define

begin_define
define|#
directive|define
name|ERR_FOR_SCORE5U_ATOMIC
value|_("This architecture doesn't support atomic instruction")
end_define

begin_define
define|#
directive|define
name|LONG_LABEL_LEN
value|_("the label length is longer than 1024");
end_define

begin_define
define|#
directive|define
name|BAD_SKIP_COMMA
value|BAD_ARGS
end_define

begin_define
define|#
directive|define
name|BAD_GARBAGE
value|_("garbage following instruction");
end_define

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|(
name|str
parameter_list|)
value|while (*(str) == ' ') ++(str)
end_define

begin_comment
comment|/* The name of the readonly data section.  */
end_comment

begin_define
define|#
directive|define
name|RDATA_SECTION_NAME
value|(OUTPUT_FLAVOR == bfd_target_aout_flavour \ 			    ? ".data" \ 			    : OUTPUT_FLAVOR == bfd_target_ecoff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \ 			    ? ".rodata" \ 			    : (abort (), ""))
end_define

begin_define
define|#
directive|define
name|RELAX_ENCODE
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|type
parameter_list|,
name|reloc1
parameter_list|,
name|reloc2
parameter_list|,
name|opt
parameter_list|)
define|\
value|((relax_substateT) \    (((old)<< 23) \     | ((new)<< 16) \     | ((type)<< 9) \     | ((reloc1)<< 5) \     | ((reloc2)<< 1) \     | ((opt) ? 1 : 0)))
end_define

begin_define
define|#
directive|define
name|RELAX_OLD
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 23)& 0x7f)
end_define

begin_define
define|#
directive|define
name|RELAX_NEW
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 16)& 0x7f)
end_define

begin_define
define|#
directive|define
name|RELAX_TYPE
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 9)& 0x7f)
end_define

begin_define
define|#
directive|define
name|RELAX_RELOC1
parameter_list|(
name|i
parameter_list|)
value|((valueT) ((i)>> 5)& 0xf)
end_define

begin_define
define|#
directive|define
name|RELAX_RELOC2
parameter_list|(
name|i
parameter_list|)
value|((valueT) ((i)>> 1)& 0xf)
end_define

begin_define
define|#
directive|define
name|RELAX_OPT
parameter_list|(
name|i
parameter_list|)
value|((i)& 1)
end_define

begin_define
define|#
directive|define
name|RELAX_OPT_CLEAR
parameter_list|(
name|i
parameter_list|)
value|((i)& ~1)
end_define

begin_define
define|#
directive|define
name|SET_INSN_ERROR
parameter_list|(
name|s
parameter_list|)
value|(inst.error = (s))
end_define

begin_define
define|#
directive|define
name|INSN_IS_PCE_P
parameter_list|(
name|s
parameter_list|)
value|(strstr (str, "||") != NULL)
end_define

begin_define
define|#
directive|define
name|GET_INSN_CLASS
parameter_list|(
name|type
parameter_list|)
value|(get_insn_class_from_type (type))
end_define

begin_define
define|#
directive|define
name|GET_INSN_SIZE
parameter_list|(
name|type
parameter_list|)
value|((GET_INSN_CLASS (type) == INSN_CLASS_16) \                              ? INSN16_SIZE : INSN_SIZE)
end_define

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point numbers.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to contain constructed error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|err_msg
index|[
literal|255
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fragS
modifier|*
name|score_fragp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fix_data_dependency
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_fix_data_dependency
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|score7
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|university_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_my_get_expression
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_GLOBAL_POINTER_OPT
value|1
end_define

begin_define
define|#
directive|define
name|SCORE_BI_ENDIAN
end_define

begin_comment
comment|/* Default, pop warning message when using r1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nor1
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default will do instruction relax, -O0 will set g_opt = 0.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the small data section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|segT
name|pdr_seg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|score_pic_level
name|score_pic
init|=
name|NO_PIC
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_NAME_LEN
value|16
end_define

begin_struct
struct|struct
name|score_it
block|{
name|char
name|name
index|[
name|INSN_NAME_LEN
index|]
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|unsigned
name|long
name|relax_inst
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|relax_size
decl_stmt|;
name|enum
name|score_insn_type
name|type
decl_stmt|;
name|char
name|str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|int
name|bwarn
decl_stmt|;
name|char
name|reg
index|[
name|INSN_NAME_LEN
index|]
decl_stmt|;
struct|struct
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
block|}
name|reloc
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|score_it
name|inst
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|proc
block|{
name|symbolS
modifier|*
name|isym
decl_stmt|;
name|unsigned
name|long
name|reg_mask
decl_stmt|;
name|unsigned
name|long
name|reg_offset
decl_stmt|;
name|unsigned
name|long
name|fpreg_mask
decl_stmt|;
name|unsigned
name|long
name|leaf
decl_stmt|;
name|unsigned
name|long
name|frame_offset
decl_stmt|;
name|unsigned
name|long
name|frame_reg
decl_stmt|;
name|unsigned
name|long
name|pc_reg
decl_stmt|;
block|}
name|procS
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|procS
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|procS
modifier|*
name|cur_proc_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numprocs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCORE7_PIPELINE
value|7
end_define

begin_define
define|#
directive|define
name|SCORE5_PIPELINE
value|5
end_define

begin_decl_stmt
specifier|static
name|int
name|vector_size
init|=
name|SCORE7_PIPELINE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|score_it
name|dependency_vector
index|[
name|SCORE7_PIPELINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relax will need some padding for alignment.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_PAD_BYTE
value|3
end_define

begin_comment
comment|/* Number of littlenums required to hold an extended precision number.  For md_atof.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FLOAT_VALS
value|8
end_define

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_decl_stmt
name|LITTLENUM_TYPE
name|fp_values
index|[
name|NUM_FLOAT_VALS
index|]
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for a hash table entry for a register.  */
end_comment

begin_struct
struct|struct
name|reg_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|score_rn_table
index|[]
init|=
block|{
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|}
block|,
block|{
literal|"r27"
block|,
literal|27
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|}
block|,
block|{
literal|"r29"
block|,
literal|29
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|score_srn_table
index|[]
init|=
block|{
block|{
literal|"sr0"
block|,
literal|0
block|}
block|,
block|{
literal|"sr1"
block|,
literal|1
block|}
block|,
block|{
literal|"sr2"
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|score_crn_table
index|[]
init|=
block|{
block|{
literal|"cr0"
block|,
literal|0
block|}
block|,
block|{
literal|"cr1"
block|,
literal|1
block|}
block|,
block|{
literal|"cr2"
block|,
literal|2
block|}
block|,
block|{
literal|"cr3"
block|,
literal|3
block|}
block|,
block|{
literal|"cr4"
block|,
literal|4
block|}
block|,
block|{
literal|"cr5"
block|,
literal|5
block|}
block|,
block|{
literal|"cr6"
block|,
literal|6
block|}
block|,
block|{
literal|"cr7"
block|,
literal|7
block|}
block|,
block|{
literal|"cr8"
block|,
literal|8
block|}
block|,
block|{
literal|"cr9"
block|,
literal|9
block|}
block|,
block|{
literal|"cr10"
block|,
literal|10
block|}
block|,
block|{
literal|"cr11"
block|,
literal|11
block|}
block|,
block|{
literal|"cr12"
block|,
literal|12
block|}
block|,
block|{
literal|"cr13"
block|,
literal|13
block|}
block|,
block|{
literal|"cr14"
block|,
literal|14
block|}
block|,
block|{
literal|"cr15"
block|,
literal|15
block|}
block|,
block|{
literal|"cr16"
block|,
literal|16
block|}
block|,
block|{
literal|"cr17"
block|,
literal|17
block|}
block|,
block|{
literal|"cr18"
block|,
literal|18
block|}
block|,
block|{
literal|"cr19"
block|,
literal|19
block|}
block|,
block|{
literal|"cr20"
block|,
literal|20
block|}
block|,
block|{
literal|"cr21"
block|,
literal|21
block|}
block|,
block|{
literal|"cr22"
block|,
literal|22
block|}
block|,
block|{
literal|"cr23"
block|,
literal|23
block|}
block|,
block|{
literal|"cr24"
block|,
literal|24
block|}
block|,
block|{
literal|"cr25"
block|,
literal|25
block|}
block|,
block|{
literal|"cr26"
block|,
literal|26
block|}
block|,
block|{
literal|"cr27"
block|,
literal|27
block|}
block|,
block|{
literal|"cr28"
block|,
literal|28
block|}
block|,
block|{
literal|"cr29"
block|,
literal|29
block|}
block|,
block|{
literal|"cr30"
block|,
literal|30
block|}
block|,
block|{
literal|"cr31"
block|,
literal|31
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_map
block|{
specifier|const
name|struct
name|reg_entry
modifier|*
name|names
decl_stmt|;
name|int
name|max_regno
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|htab
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|reg_map
name|all_reg_maps
index|[]
init|=
block|{
block|{
name|score_rn_table
block|,
literal|31
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"S+core register expected"
argument_list|)
block|}
block|,
block|{
name|score_srn_table
block|,
literal|2
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"S+core special-register expected"
argument_list|)
block|}
block|,
block|{
name|score_crn_table
block|,
literal|31
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"S+core co-processor register expected"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|score_ops_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|dependency_insn_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enumeration matching entries in table above.  */
end_comment

begin_enum
enum|enum
name|score_reg_type
block|{
name|REG_TYPE_SCORE
init|=
literal|0
block|,
define|#
directive|define
name|REG_TYPE_FIRST
value|REG_TYPE_SCORE
name|REG_TYPE_SCORE_SR
init|=
literal|1
block|,
name|REG_TYPE_SCORE_CR
init|=
literal|2
block|,
name|REG_TYPE_MAX
init|=
literal|3
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|literalS
block|{
name|struct
name|expressionS
name|exp
decl_stmt|;
name|struct
name|score_it
modifier|*
name|inst
decl_stmt|;
block|}
name|literalT
typedef|;
end_typedef

begin_decl_stmt
name|literalT
name|literals
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|do_ldst_insn
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_crdcrscrsimm5
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_ldst_unalign
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_ldst_atomic
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_ldst_cop
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_li_rdi32
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_la_rdi32
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_rdi32hi
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_rdi32lo
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_mul_rdrsrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_macro_ldst_label
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_branch
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_jump
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_empty
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdrsrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdsi16
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdrssi14
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_sub_rdsi16
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_sub_rdrssi14
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdrsi5
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdrsi14
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdi16
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_xrsi5
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdxrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rsrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdcrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdsrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_i15
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_xi5x
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_ceinst
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_cache
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_rdrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_rs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_xrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_mv_rdrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_hrdrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_rdhrs
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_rdi4
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_rdi5
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_xi5
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_ldst_insn
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_ldst_imm_insn
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_push_pop
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_branch
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do16_jump
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_rdi16_pic
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_addi_s_pic
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_addi_u_pic
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_lw_pic
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_opcode
name|score_ldst_insns
index|[]
init|=
block|{
block|{
literal|"lw"
block|,
literal|0x20000000
block|,
literal|0x3e000000
block|,
literal|0x2008
block|,
name|Rd_rvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lw"
block|,
literal|0x06000000
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lw"
block|,
literal|0x0e000000
block|,
literal|0x3e000007
block|,
literal|0x200a
block|,
name|Rd_rvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lh"
block|,
literal|0x22000000
block|,
literal|0x3e000000
block|,
literal|0x2009
block|,
name|Rd_rvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lh"
block|,
literal|0x06000001
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lh"
block|,
literal|0x0e000001
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lhu"
block|,
literal|0x24000000
block|,
literal|0x3e000000
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lhu"
block|,
literal|0x06000002
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lhu"
block|,
literal|0x0e000002
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lb"
block|,
literal|0x26000000
block|,
literal|0x3e000000
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lb"
block|,
literal|0x06000003
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lb"
block|,
literal|0x0e000003
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sw"
block|,
literal|0x28000000
block|,
literal|0x3e000000
block|,
literal|0x200c
block|,
name|Rd_lvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sw"
block|,
literal|0x06000004
block|,
literal|0x3e000007
block|,
literal|0x200e
block|,
name|Rd_lvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sw"
block|,
literal|0x0e000004
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sh"
block|,
literal|0x2a000000
block|,
literal|0x3e000000
block|,
literal|0x200d
block|,
name|Rd_lvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sh"
block|,
literal|0x06000005
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sh"
block|,
literal|0x0e000005
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lbu"
block|,
literal|0x2c000000
block|,
literal|0x3e000000
block|,
literal|0x200b
block|,
name|Rd_rvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lbu"
block|,
literal|0x06000006
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"lbu"
block|,
literal|0x0e000006
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sb"
block|,
literal|0x2e000000
block|,
literal|0x3e000000
block|,
literal|0x200f
block|,
name|Rd_lvalueRs_SI15
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sb"
block|,
literal|0x06000007
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_preSI12
block|,
name|do_ldst_insn
block|}
block|,
block|{
literal|"sb"
block|,
literal|0x0e000007
block|,
literal|0x3e000007
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_postSI12
block|,
name|do_ldst_insn
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_opcode
name|score_insns
index|[]
init|=
block|{
block|{
literal|"abs"
block|,
literal|0x3800000a
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"abs.s"
block|,
literal|0x3800004b
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"add"
block|,
literal|0x00000010
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"add.c"
block|,
literal|0x00000011
block|,
literal|0x3e0003ff
block|,
literal|0x2000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"add.s"
block|,
literal|0x38000048
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"addc"
block|,
literal|0x00000012
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"addc.c"
block|,
literal|0x00000013
block|,
literal|0x3e0003ff
block|,
literal|0x0009
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"addi"
block|,
literal|0x02000000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_rdsi16
block|}
block|,
block|{
literal|"addi.c"
block|,
literal|0x02000001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_rdsi16
block|}
block|,
block|{
literal|"addis"
block|,
literal|0x0a000000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"addis.c"
block|,
literal|0x0a000001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"addri"
block|,
literal|0x10000000
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_SI14
block|,
name|do_rdrssi14
block|}
block|,
block|{
literal|"addri.c"
block|,
literal|0x10000001
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_SI14
block|,
name|do_rdrssi14
block|}
block|,
block|{
literal|"addc!"
block|,
literal|0x0009
block|,
literal|0x700f
block|,
literal|0x00000013
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"add!"
block|,
literal|0x2000
block|,
literal|0x700f
block|,
literal|0x00000011
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"addei!"
block|,
literal|0x6000
block|,
literal|0x7087
block|,
literal|0x02000001
block|,
name|Rd_I4
block|,
name|do16_rdi4
block|}
block|,
block|{
literal|"subi"
block|,
literal|0x02000000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_sub_rdsi16
block|}
block|,
block|{
literal|"subi.c"
block|,
literal|0x02000001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_sub_rdsi16
block|}
block|,
block|{
literal|"subri"
block|,
literal|0x10000000
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_SI14
block|,
name|do_sub_rdrssi14
block|}
block|,
block|{
literal|"subri.c"
block|,
literal|0x10000001
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_SI14
block|,
name|do_sub_rdrssi14
block|}
block|,
block|{
literal|"and"
block|,
literal|0x00000020
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"and.c"
block|,
literal|0x00000021
block|,
literal|0x3e0003ff
block|,
literal|0x2004
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"andi"
block|,
literal|0x02080000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"andi.c"
block|,
literal|0x02080001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"andis"
block|,
literal|0x0a080000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"andis.c"
block|,
literal|0x0a080001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"andri"
block|,
literal|0x18000000
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_I14
block|,
name|do_rdrsi14
block|}
block|,
block|{
literal|"andri.c"
block|,
literal|0x18000001
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_I14
block|,
name|do_rdrsi14
block|}
block|,
block|{
literal|"and!"
block|,
literal|0x2004
block|,
literal|0x700f
block|,
literal|0x00000021
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"bcs"
block|,
literal|0x08000000
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bcc"
block|,
literal|0x08000400
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bcnz"
block|,
literal|0x08003800
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bcsl"
block|,
literal|0x08000001
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bccl"
block|,
literal|0x08000401
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bcnzl"
block|,
literal|0x08003801
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bcs!"
block|,
literal|0x4000
block|,
literal|0x7f00
block|,
literal|0x08000000
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bcc!"
block|,
literal|0x4100
block|,
literal|0x7f00
block|,
literal|0x08000400
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bcnz!"
block|,
literal|0x4e00
block|,
literal|0x7f00
block|,
literal|0x08003800
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"beq"
block|,
literal|0x08001000
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"beql"
block|,
literal|0x08001001
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"beq!"
block|,
literal|0x4400
block|,
literal|0x7f00
block|,
literal|0x08001000
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bgtu"
block|,
literal|0x08000800
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bgt"
block|,
literal|0x08001800
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bge"
block|,
literal|0x08002000
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bgtul"
block|,
literal|0x08000801
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bgtl"
block|,
literal|0x08001801
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bgel"
block|,
literal|0x08002001
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bgtu!"
block|,
literal|0x4200
block|,
literal|0x7f00
block|,
literal|0x08000800
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bgt!"
block|,
literal|0x4600
block|,
literal|0x7f00
block|,
literal|0x08001800
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bge!"
block|,
literal|0x4800
block|,
literal|0x7f00
block|,
literal|0x08002000
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bitclr.c"
block|,
literal|0x00000029
block|,
literal|0x3e0003ff
block|,
literal|0x6004
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"bitrev"
block|,
literal|0x3800000c
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"bitset.c"
block|,
literal|0x0000002b
block|,
literal|0x3e0003ff
block|,
literal|0x6005
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"bittst.c"
block|,
literal|0x0000002d
block|,
literal|0x3e0003ff
block|,
literal|0x6006
block|,
name|x_Rs_I5
block|,
name|do_xrsi5
block|}
block|,
block|{
literal|"bittgl.c"
block|,
literal|0x0000002f
block|,
literal|0x3e0003ff
block|,
literal|0x6007
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"bitclr!"
block|,
literal|0x6004
block|,
literal|0x7007
block|,
literal|0x00000029
block|,
name|Rd_I5
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"bitset!"
block|,
literal|0x6005
block|,
literal|0x7007
block|,
literal|0x0000002b
block|,
name|Rd_I5
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"bittst!"
block|,
literal|0x6006
block|,
literal|0x7007
block|,
literal|0x0000002d
block|,
name|Rd_I5
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"bittgl!"
block|,
literal|0x6007
block|,
literal|0x7007
block|,
literal|0x0000002f
block|,
name|Rd_I5
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"bleu"
block|,
literal|0x08000c00
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"ble"
block|,
literal|0x08001c00
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"blt"
block|,
literal|0x08002400
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bleul"
block|,
literal|0x08000c01
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"blel"
block|,
literal|0x08001c01
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bltl"
block|,
literal|0x08002401
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bl"
block|,
literal|0x08003c01
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bleu!"
block|,
literal|0x4300
block|,
literal|0x7f00
block|,
literal|0x08000c00
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"ble!"
block|,
literal|0x4700
block|,
literal|0x7f00
block|,
literal|0x08001c00
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"blt!"
block|,
literal|0x4900
block|,
literal|0x7f00
block|,
literal|0x08002400
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bmi"
block|,
literal|0x08002800
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bmil"
block|,
literal|0x08002801
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bmi!"
block|,
literal|0x00004a00
block|,
literal|0x00007f00
block|,
literal|0x08002800
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bne"
block|,
literal|0x08001400
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bnel"
block|,
literal|0x08001401
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bne!"
block|,
literal|0x4500
block|,
literal|0x7f00
block|,
literal|0x08001400
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bpl"
block|,
literal|0x08002c00
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bpll"
block|,
literal|0x08002c01
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bpl!"
block|,
literal|0x4b00
block|,
literal|0x7f00
block|,
literal|0x08002c00
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"brcs"
block|,
literal|0x00000008
block|,
literal|0x3e007fff
block|,
literal|0x0004
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brcc"
block|,
literal|0x00000408
block|,
literal|0x3e007fff
block|,
literal|0x0104
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brgtu"
block|,
literal|0x00000808
block|,
literal|0x3e007fff
block|,
literal|0x0204
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brleu"
block|,
literal|0x00000c08
block|,
literal|0x3e007fff
block|,
literal|0x0304
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"breq"
block|,
literal|0x00001008
block|,
literal|0x3e007fff
block|,
literal|0x0404
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brne"
block|,
literal|0x00001408
block|,
literal|0x3e007fff
block|,
literal|0x0504
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brgt"
block|,
literal|0x00001808
block|,
literal|0x3e007fff
block|,
literal|0x0604
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brle"
block|,
literal|0x00001c08
block|,
literal|0x3e007fff
block|,
literal|0x0704
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brge"
block|,
literal|0x00002008
block|,
literal|0x3e007fff
block|,
literal|0x0804
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brlt"
block|,
literal|0x00002408
block|,
literal|0x3e007fff
block|,
literal|0x0904
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brmi"
block|,
literal|0x00002808
block|,
literal|0x3e007fff
block|,
literal|0x0a04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brpl"
block|,
literal|0x00002c08
block|,
literal|0x3e007fff
block|,
literal|0x0b04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brvs"
block|,
literal|0x00003008
block|,
literal|0x3e007fff
block|,
literal|0x0c04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brvc"
block|,
literal|0x00003408
block|,
literal|0x3e007fff
block|,
literal|0x0d04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brcnz"
block|,
literal|0x00003808
block|,
literal|0x3e007fff
block|,
literal|0x0e04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"br"
block|,
literal|0x00003c08
block|,
literal|0x3e007fff
block|,
literal|0x0f04
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brcsl"
block|,
literal|0x00000009
block|,
literal|0x3e007fff
block|,
literal|0x000c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brccl"
block|,
literal|0x00000409
block|,
literal|0x3e007fff
block|,
literal|0x010c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brgtul"
block|,
literal|0x00000809
block|,
literal|0x3e007fff
block|,
literal|0x020c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brleul"
block|,
literal|0x00000c09
block|,
literal|0x3e007fff
block|,
literal|0x030c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"breql"
block|,
literal|0x00001009
block|,
literal|0x3e007fff
block|,
literal|0x040c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brnel"
block|,
literal|0x00001409
block|,
literal|0x3e007fff
block|,
literal|0x050c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brgtl"
block|,
literal|0x00001809
block|,
literal|0x3e007fff
block|,
literal|0x060c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brlel"
block|,
literal|0x00001c09
block|,
literal|0x3e007fff
block|,
literal|0x070c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brgel"
block|,
literal|0x00002009
block|,
literal|0x3e007fff
block|,
literal|0x080c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brltl"
block|,
literal|0x00002409
block|,
literal|0x3e007fff
block|,
literal|0x090c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brmil"
block|,
literal|0x00002809
block|,
literal|0x3e007fff
block|,
literal|0x0a0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brpll"
block|,
literal|0x00002c09
block|,
literal|0x3e007fff
block|,
literal|0x0b0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brvsl"
block|,
literal|0x00003009
block|,
literal|0x3e007fff
block|,
literal|0x0c0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brvcl"
block|,
literal|0x00003409
block|,
literal|0x3e007fff
block|,
literal|0x0d0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brcnzl"
block|,
literal|0x00003809
block|,
literal|0x3e007fff
block|,
literal|0x0e0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brl"
block|,
literal|0x00003c09
block|,
literal|0x3e007fff
block|,
literal|0x0f0c
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"brcs!"
block|,
literal|0x0004
block|,
literal|0x7f0f
block|,
literal|0x00000008
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brcc!"
block|,
literal|0x0104
block|,
literal|0x7f0f
block|,
literal|0x00000408
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brgtu!"
block|,
literal|0x0204
block|,
literal|0x7f0f
block|,
literal|0x00000808
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brleu!"
block|,
literal|0x0304
block|,
literal|0x7f0f
block|,
literal|0x00000c08
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"breq!"
block|,
literal|0x0404
block|,
literal|0x7f0f
block|,
literal|0x00001008
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brne!"
block|,
literal|0x0504
block|,
literal|0x7f0f
block|,
literal|0x00001408
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brgt!"
block|,
literal|0x0604
block|,
literal|0x7f0f
block|,
literal|0x00001808
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brle!"
block|,
literal|0x0704
block|,
literal|0x7f0f
block|,
literal|0x00001c08
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brge!"
block|,
literal|0x0804
block|,
literal|0x7f0f
block|,
literal|0x00002008
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brlt!"
block|,
literal|0x0904
block|,
literal|0x7f0f
block|,
literal|0x00002408
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brmi!"
block|,
literal|0x0a04
block|,
literal|0x7f0f
block|,
literal|0x00002808
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brpl!"
block|,
literal|0x0b04
block|,
literal|0x7f0f
block|,
literal|0x00002c08
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brvs!"
block|,
literal|0x0c04
block|,
literal|0x7f0f
block|,
literal|0x00003008
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brvc!"
block|,
literal|0x0d04
block|,
literal|0x7f0f
block|,
literal|0x00003408
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brcnz!"
block|,
literal|0x0e04
block|,
literal|0x7f0f
block|,
literal|0x00003808
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"br!"
block|,
literal|0x0f04
block|,
literal|0x7f0f
block|,
literal|0x00003c08
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brcsl!"
block|,
literal|0x000c
block|,
literal|0x7f0f
block|,
literal|0x00000009
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brccl!"
block|,
literal|0x010c
block|,
literal|0x7f0f
block|,
literal|0x00000409
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brgtul!"
block|,
literal|0x020c
block|,
literal|0x7f0f
block|,
literal|0x00000809
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brleul!"
block|,
literal|0x030c
block|,
literal|0x7f0f
block|,
literal|0x00000c09
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"breql!"
block|,
literal|0x040c
block|,
literal|0x7f0f
block|,
literal|0x00001009
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brnel!"
block|,
literal|0x050c
block|,
literal|0x7f0f
block|,
literal|0x00001409
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brgtl!"
block|,
literal|0x060c
block|,
literal|0x7f0f
block|,
literal|0x00001809
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brlel!"
block|,
literal|0x070c
block|,
literal|0x7f0f
block|,
literal|0x00001c09
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brgel!"
block|,
literal|0x080c
block|,
literal|0x7f0f
block|,
literal|0x00002009
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brltl!"
block|,
literal|0x090c
block|,
literal|0x7f0f
block|,
literal|0x00002409
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brmil!"
block|,
literal|0x0a0c
block|,
literal|0x7f0f
block|,
literal|0x00002809
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brpll!"
block|,
literal|0x0b0c
block|,
literal|0x7f0f
block|,
literal|0x00002c09
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brvsl!"
block|,
literal|0x0c0c
block|,
literal|0x7f0f
block|,
literal|0x00003009
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brvcl!"
block|,
literal|0x0d0c
block|,
literal|0x7f0f
block|,
literal|0x00003409
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brcnzl!"
block|,
literal|0x0e0c
block|,
literal|0x7f0f
block|,
literal|0x00003809
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"brl!"
block|,
literal|0x0f0c
block|,
literal|0x7f0f
block|,
literal|0x00003c09
block|,
name|x_Rs
block|,
name|do16_xrs
block|}
block|,
block|{
literal|"bvs"
block|,
literal|0x08003000
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bvc"
block|,
literal|0x08003400
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bvsl"
block|,
literal|0x08003001
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bvcl"
block|,
literal|0x08003401
block|,
literal|0x3e007c01
block|,
literal|0x8000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"bvs!"
block|,
literal|0x4c00
block|,
literal|0x7f00
block|,
literal|0x08003000
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"bvc!"
block|,
literal|0x4d00
block|,
literal|0x7f00
block|,
literal|0x08003400
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"b!"
block|,
literal|0x4f00
block|,
literal|0x7f00
block|,
literal|0x08003c00
block|,
name|PC_DISP8div2
block|,
name|do16_branch
block|}
block|,
block|{
literal|"b"
block|,
literal|0x08003c00
block|,
literal|0x3e007c01
block|,
literal|0x4000
block|,
name|PC_DISP19div2
block|,
name|do_branch
block|}
block|,
block|{
literal|"cache"
block|,
literal|0x30000000
block|,
literal|0x3ff00000
block|,
literal|0x8000
block|,
name|OP5_rvalueRs_SI15
block|,
name|do_cache
block|}
block|,
block|{
literal|"ceinst"
block|,
literal|0x38000000
block|,
literal|0x3e000000
block|,
literal|0x8000
block|,
name|I5_Rs_Rs_I5_OP5
block|,
name|do_ceinst
block|}
block|,
block|{
literal|"clz"
block|,
literal|0x3800000d
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"cmpteq.c"
block|,
literal|0x00000019
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"cmptmi.c"
block|,
literal|0x00100019
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"cmp.c"
block|,
literal|0x00300019
block|,
literal|0x3ff003ff
block|,
literal|0x2003
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"cmpzteq.c"
block|,
literal|0x0000001b
block|,
literal|0x3ff07fff
block|,
literal|0x8000
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"cmpztmi.c"
block|,
literal|0x0010001b
block|,
literal|0x3ff07fff
block|,
literal|0x8000
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"cmpz.c"
block|,
literal|0x0030001b
block|,
literal|0x3ff07fff
block|,
literal|0x8000
block|,
name|x_Rs_x
block|,
name|do_rs
block|}
block|,
block|{
literal|"cmpi.c"
block|,
literal|0x02040001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_SI16
block|,
name|do_rdsi16
block|}
block|,
block|{
literal|"cmp!"
block|,
literal|0x2003
block|,
literal|0x700f
block|,
literal|0x00300019
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"cop1"
block|,
literal|0x0c00000c
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs_imm
block|,
name|do_crdcrscrsimm5
block|}
block|,
block|{
literal|"cop2"
block|,
literal|0x0c000014
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs_imm
block|,
name|do_crdcrscrsimm5
block|}
block|,
block|{
literal|"cop3"
block|,
literal|0x0c00001c
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs_imm
block|,
name|do_crdcrscrsimm5
block|}
block|,
block|{
literal|"drte"
block|,
literal|0x0c0000a4
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"extsb"
block|,
literal|0x00000058
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extsb.c"
block|,
literal|0x00000059
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extsh"
block|,
literal|0x0000005a
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extsh.c"
block|,
literal|0x0000005b
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extzb"
block|,
literal|0x0000005c
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extzb.c"
block|,
literal|0x0000005d
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extzh"
block|,
literal|0x0000005e
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"extzh.c"
block|,
literal|0x0000005f
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"jl"
block|,
literal|0x04000001
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|PC_DISP24div2
block|,
name|do_jump
block|}
block|,
block|{
literal|"jl!"
block|,
literal|0x3001
block|,
literal|0x7001
block|,
literal|0x04000001
block|,
name|PC_DISP11div2
block|,
name|do16_jump
block|}
block|,
block|{
literal|"j!"
block|,
literal|0x3000
block|,
literal|0x7001
block|,
literal|0x04000000
block|,
name|PC_DISP11div2
block|,
name|do16_jump
block|}
block|,
block|{
literal|"j"
block|,
literal|0x04000000
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|PC_DISP24div2
block|,
name|do_jump
block|}
block|,
block|{
literal|"lbu!"
block|,
literal|0x200b
block|,
literal|0x0000700f
block|,
literal|0x2c000000
block|,
name|Rd_rvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"lbup!"
block|,
literal|0x7003
block|,
literal|0x7007
block|,
literal|0x2c000000
block|,
name|Rd_rvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"alw"
block|,
literal|0x0000000c
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_rvalue32Rs
block|,
name|do_ldst_atomic
block|}
block|,
block|{
literal|"lcb"
block|,
literal|0x00000060
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|x_rvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"lcw"
block|,
literal|0x00000062
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"lce"
block|,
literal|0x00000066
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"ldc1"
block|,
literal|0x0c00000a
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"ldc2"
block|,
literal|0x0c000012
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"ldc3"
block|,
literal|0x0c00001a
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_rvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"lh!"
block|,
literal|0x2009
block|,
literal|0x700f
block|,
literal|0x22000000
block|,
name|Rd_rvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"lhp!"
block|,
literal|0x7001
block|,
literal|0x7007
block|,
literal|0x22000000
block|,
name|Rd_rvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"ldi"
block|,
literal|0x020c0000
block|,
literal|0x3e0e0000
block|,
literal|0x5000
block|,
name|Rd_SI16
block|,
name|do_rdsi16
block|}
block|,
block|{
literal|"ldis"
block|,
literal|0x0a0c0000
block|,
literal|0x3e0e0000
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"ldiu!"
block|,
literal|0x5000
block|,
literal|0x7000
block|,
literal|0x020c0000
block|,
name|Rd_I8
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"lw!"
block|,
literal|0x2008
block|,
literal|0x700f
block|,
literal|0x20000000
block|,
name|Rd_rvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"lwp!"
block|,
literal|0x7000
block|,
literal|0x7007
block|,
literal|0x20000000
block|,
name|Rd_rvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"mfcel"
block|,
literal|0x00000448
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_x_x
block|,
name|do_rd
block|}
block|,
block|{
literal|"mfcel!"
block|,
literal|0x1001
block|,
literal|0x7f0f
block|,
literal|0x00000448
block|,
name|x_Rs
block|,
name|do16_rs
block|}
block|,
block|{
literal|"mad"
block|,
literal|0x38000000
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mad.f!"
block|,
literal|0x1004
block|,
literal|0x700f
block|,
literal|0x38000080
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"madh"
block|,
literal|0x38000203
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"madh.fs"
block|,
literal|0x380002c3
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"madh.fs!"
block|,
literal|0x100b
block|,
literal|0x700f
block|,
literal|0x380002c3
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"madl"
block|,
literal|0x38000002
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"madl.fs"
block|,
literal|0x380000c2
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"madl.fs!"
block|,
literal|0x100a
block|,
literal|0x700f
block|,
literal|0x380000c2
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"madu"
block|,
literal|0x38000020
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"madu!"
block|,
literal|0x1005
block|,
literal|0x700f
block|,
literal|0x38000020
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mad.f"
block|,
literal|0x38000080
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"max"
block|,
literal|0x38000007
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"mazh"
block|,
literal|0x38000303
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mazh.f"
block|,
literal|0x38000383
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mazh.f!"
block|,
literal|0x1009
block|,
literal|0x700f
block|,
literal|0x3800038c
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mazl"
block|,
literal|0x38000102
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mazl.f"
block|,
literal|0x38000182
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mazl.f!"
block|,
literal|0x1008
block|,
literal|0x700f
block|,
literal|0x38000182
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mfceh"
block|,
literal|0x00000848
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_x_x
block|,
name|do_rd
block|}
block|,
block|{
literal|"mfceh!"
block|,
literal|0x1101
block|,
literal|0x7f0f
block|,
literal|0x00000848
block|,
name|x_Rs
block|,
name|do16_rs
block|}
block|,
block|{
literal|"mfcehl"
block|,
literal|0x00000c48
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mfsr"
block|,
literal|0x00000050
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_x_I5
block|,
name|do_rdsrs
block|}
block|,
block|{
literal|"mfcr"
block|,
literal|0x0c000001
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfc1"
block|,
literal|0x0c000009
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfc2"
block|,
literal|0x0c000011
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfc3"
block|,
literal|0x0c000019
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfcc1"
block|,
literal|0x0c00000f
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfcc2"
block|,
literal|0x0c000017
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mfcc3"
block|,
literal|0x0c00001f
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mhfl!"
block|,
literal|0x0002
block|,
literal|0x700f
block|,
literal|0x00003c56
block|,
name|Rd_LowRs
block|,
name|do16_hrdrs
block|}
block|,
block|{
literal|"min"
block|,
literal|0x38000006
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"mlfh!"
block|,
literal|0x0001
block|,
literal|0x700f
block|,
literal|0x00003c56
block|,
name|Rd_HighRs
block|,
name|do16_rdhrs
block|}
block|,
block|{
literal|"msb"
block|,
literal|0x38000001
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msb.f!"
block|,
literal|0x1006
block|,
literal|0x700f
block|,
literal|0x38000081
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"msbh"
block|,
literal|0x38000205
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msbh.fs"
block|,
literal|0x380002c5
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msbh.fs!"
block|,
literal|0x100f
block|,
literal|0x700f
block|,
literal|0x380002c5
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"msbl"
block|,
literal|0x38000004
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msbl.fs"
block|,
literal|0x380000c4
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msbl.fs!"
block|,
literal|0x100e
block|,
literal|0x700f
block|,
literal|0x380000c4
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"msbu"
block|,
literal|0x38000021
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"msbu!"
block|,
literal|0x1007
block|,
literal|0x700f
block|,
literal|0x38000021
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"msb.f"
block|,
literal|0x38000081
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mszh"
block|,
literal|0x38000305
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mszh.f"
block|,
literal|0x38000385
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mszh.f!"
block|,
literal|0x100d
block|,
literal|0x700f
block|,
literal|0x38000385
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mszl"
block|,
literal|0x38000104
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mszl.f"
block|,
literal|0x38000184
block|,
literal|0x3ff003ff
block|,
literal|0x8000
block|,
name|x_Rs_Rs
block|,
name|do_rsrs
block|}
block|,
block|{
literal|"mszl.f!"
block|,
literal|0x100c
block|,
literal|0x700f
block|,
literal|0x38000184
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mtcel!"
block|,
literal|0x1000
block|,
literal|0x7f0f
block|,
literal|0x0000044a
block|,
name|x_Rs
block|,
name|do16_rs
block|}
block|,
block|{
literal|"mtcel"
block|,
literal|0x0000044a
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_x_x
block|,
name|do_rd
block|}
block|,
block|{
literal|"mtceh"
block|,
literal|0x0000084a
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_x_x
block|,
name|do_rd
block|}
block|,
block|{
literal|"mtceh!"
block|,
literal|0x1100
block|,
literal|0x7f0f
block|,
literal|0x0000084a
block|,
name|x_Rs
block|,
name|do16_rs
block|}
block|,
block|{
literal|"mtcehl"
block|,
literal|0x00000c4a
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mtsr"
block|,
literal|0x00000052
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|x_Rs_I5
block|,
name|do_rdsrs
block|}
block|,
block|{
literal|"mtcr"
block|,
literal|0x0c000000
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtc1"
block|,
literal|0x0c000008
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtc2"
block|,
literal|0x0c000010
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtc3"
block|,
literal|0x0c000018
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtcc1"
block|,
literal|0x0c00000e
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtcc2"
block|,
literal|0x0c000016
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mtcc3"
block|,
literal|0x0c00001e
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdcrs
block|}
block|,
block|{
literal|"mul.f!"
block|,
literal|0x1002
block|,
literal|0x700f
block|,
literal|0x00000041
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mulu!"
block|,
literal|0x1003
block|,
literal|0x700f
block|,
literal|0x00000042
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"mvcs"
block|,
literal|0x00000056
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvcc"
block|,
literal|0x00000456
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvgtu"
block|,
literal|0x00000856
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvleu"
block|,
literal|0x00000c56
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mveq"
block|,
literal|0x00001056
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvne"
block|,
literal|0x00001456
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvgt"
block|,
literal|0x00001856
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvle"
block|,
literal|0x00001c56
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvge"
block|,
literal|0x00002056
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvlt"
block|,
literal|0x00002456
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvmi"
block|,
literal|0x00002856
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvpl"
block|,
literal|0x00002c56
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvvs"
block|,
literal|0x00003056
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mvvc"
block|,
literal|0x00003456
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mv"
block|,
literal|0x00003c56
block|,
literal|0x3e007fff
block|,
literal|0x0003
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"mv!"
block|,
literal|0x0003
block|,
literal|0x700f
block|,
literal|0x00003c56
block|,
name|Rd_Rs
block|,
name|do16_mv_rdrs
block|}
block|,
block|{
literal|"neg"
block|,
literal|0x0000001e
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_x_Rs
block|,
name|do_rdxrs
block|}
block|,
block|{
literal|"neg.c"
block|,
literal|0x0000001f
block|,
literal|0x3e0003ff
block|,
literal|0x2002
block|,
name|Rd_x_Rs
block|,
name|do_rdxrs
block|}
block|,
block|{
literal|"neg!"
block|,
literal|0x2002
block|,
literal|0x700f
block|,
literal|0x0000001f
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"nop"
block|,
literal|0x00000000
block|,
literal|0x3e0003ff
block|,
literal|0x0000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"not"
block|,
literal|0x00000024
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"not.c"
block|,
literal|0x00000025
block|,
literal|0x3e0003ff
block|,
literal|0x2006
block|,
name|Rd_Rs_x
block|,
name|do_rdrs
block|}
block|,
block|{
literal|"nop!"
block|,
literal|0x0000
block|,
literal|0x700f
block|,
literal|0x00000000
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"not!"
block|,
literal|0x2006
block|,
literal|0x700f
block|,
literal|0x00000025
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"or"
block|,
literal|0x00000022
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"or.c"
block|,
literal|0x00000023
block|,
literal|0x3e0003ff
block|,
literal|0x2005
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"ori"
block|,
literal|0x020a0000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"ori.c"
block|,
literal|0x020a0001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"oris"
block|,
literal|0x0a0a0000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"oris.c"
block|,
literal|0x0a0a0001
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Rd_I16
block|,
name|do_rdi16
block|}
block|,
block|{
literal|"orri"
block|,
literal|0x1a000000
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_I14
block|,
name|do_rdrsi14
block|}
block|,
block|{
literal|"orri.c"
block|,
literal|0x1a000001
block|,
literal|0x3e000001
block|,
literal|0x8000
block|,
name|Rd_Rs_I14
block|,
name|do_rdrsi14
block|}
block|,
block|{
literal|"or!"
block|,
literal|0x2005
block|,
literal|0x700f
block|,
literal|0x00000023
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"pflush"
block|,
literal|0x0000000a
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"pop!"
block|,
literal|0x200a
block|,
literal|0x700f
block|,
literal|0x0e000000
block|,
name|Rd_rvalueRs
block|,
name|do16_push_pop
block|}
block|,
block|{
literal|"push!"
block|,
literal|0x200e
block|,
literal|0x700f
block|,
literal|0x06000004
block|,
name|Rd_lvalueRs
block|,
name|do16_push_pop
block|}
block|,
block|{
literal|"ror"
block|,
literal|0x00000038
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"ror.c"
block|,
literal|0x00000039
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"rorc.c"
block|,
literal|0x0000003b
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"rol"
block|,
literal|0x0000003c
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"rol.c"
block|,
literal|0x0000003d
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"rolc.c"
block|,
literal|0x0000003f
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"rori"
block|,
literal|0x00000078
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"rori.c"
block|,
literal|0x00000079
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"roric.c"
block|,
literal|0x0000007b
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"roli"
block|,
literal|0x0000007c
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"roli.c"
block|,
literal|0x0000007d
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"rolic.c"
block|,
literal|0x0000007f
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"rte"
block|,
literal|0x0c000084
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"sb!"
block|,
literal|0x200f
block|,
literal|0x700f
block|,
literal|0x2e000000
block|,
name|Rd_lvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"sbp!"
block|,
literal|0x7007
block|,
literal|0x7007
block|,
literal|0x2e000000
block|,
name|Rd_lvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"asw"
block|,
literal|0x0000000e
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_lvalue32Rs
block|,
name|do_ldst_atomic
block|}
block|,
block|{
literal|"scb"
block|,
literal|0x00000068
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"scw"
block|,
literal|0x0000006a
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"sce"
block|,
literal|0x0000006e
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|x_lvalueRs_post4
block|,
name|do_ldst_unalign
block|}
block|,
block|{
literal|"sdbbp"
block|,
literal|0x00000006
block|,
literal|0x3e0003ff
block|,
literal|0x6002
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"sdbbp!"
block|,
literal|0x6002
block|,
literal|0x7007
block|,
literal|0x00000006
block|,
name|Rd_I5
block|,
name|do16_xi5
block|}
block|,
block|{
literal|"sh!"
block|,
literal|0x200d
block|,
literal|0x700f
block|,
literal|0x2a000000
block|,
name|Rd_lvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"shp!"
block|,
literal|0x7005
block|,
literal|0x7007
block|,
literal|0x2a000000
block|,
name|Rd_lvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"sleep"
block|,
literal|0x0c0000c4
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"sll"
block|,
literal|0x00000030
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sll.c"
block|,
literal|0x00000031
block|,
literal|0x3e0003ff
block|,
literal|0x0008
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sll.s"
block|,
literal|0x3800004e
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"slli"
block|,
literal|0x00000070
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"slli.c"
block|,
literal|0x00000071
block|,
literal|0x3e0003ff
block|,
literal|0x6001
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"sll!"
block|,
literal|0x0008
block|,
literal|0x700f
block|,
literal|0x00000031
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"slli!"
block|,
literal|0x6001
block|,
literal|0x7007
block|,
literal|0x00000071
block|,
name|Rd_I5
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"srl"
block|,
literal|0x00000034
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"srl.c"
block|,
literal|0x00000035
block|,
literal|0x3e0003ff
block|,
literal|0x000a
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sra"
block|,
literal|0x00000036
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sra.c"
block|,
literal|0x00000037
block|,
literal|0x3e0003ff
block|,
literal|0x000b
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"srli"
block|,
literal|0x00000074
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"srli.c"
block|,
literal|0x00000075
block|,
literal|0x3e0003ff
block|,
literal|0x6003
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"srai"
block|,
literal|0x00000076
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"srai.c"
block|,
literal|0x00000077
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_I5
block|,
name|do_rdrsi5
block|}
block|,
block|{
literal|"srl!"
block|,
literal|0x000a
block|,
literal|0x700f
block|,
literal|0x00000035
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"sra!"
block|,
literal|0x000b
block|,
literal|0x700f
block|,
literal|0x00000037
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"srli!"
block|,
literal|0x6003
block|,
literal|0x7007
block|,
literal|0x00000075
block|,
name|Rd_Rs
block|,
name|do16_rdi5
block|}
block|,
block|{
literal|"stc1"
block|,
literal|0x0c00000b
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"stc2"
block|,
literal|0x0c000013
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"stc3"
block|,
literal|0x0c00001b
block|,
literal|0x3e00001f
block|,
literal|0x8000
block|,
name|Rd_lvalueRs_SI10
block|,
name|do_ldst_cop
block|}
block|,
block|{
literal|"sub"
block|,
literal|0x00000014
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sub.c"
block|,
literal|0x00000015
block|,
literal|0x3e0003ff
block|,
literal|0x2001
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sub.s"
block|,
literal|0x38000049
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"subc"
block|,
literal|0x00000016
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"subc.c"
block|,
literal|0x00000017
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"sub!"
block|,
literal|0x2001
block|,
literal|0x700f
block|,
literal|0x00000015
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
block|{
literal|"subei!"
block|,
literal|0x6080
block|,
literal|0x7087
block|,
literal|0x02000001
block|,
name|Rd_I4
block|,
name|do16_rdi4
block|}
block|,
block|{
literal|"sw!"
block|,
literal|0x200c
block|,
literal|0x700f
block|,
literal|0x28000000
block|,
name|Rd_lvalueRs
block|,
name|do16_ldst_insn
block|}
block|,
block|{
literal|"swp!"
block|,
literal|0x7004
block|,
literal|0x7007
block|,
literal|0x28000000
block|,
name|Rd_lvalueBP_I5
block|,
name|do16_ldst_imm_insn
block|}
block|,
block|{
literal|"syscall"
block|,
literal|0x00000002
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|I15
block|,
name|do_i15
block|}
block|,
block|{
literal|"tcs"
block|,
literal|0x00000054
block|,
literal|0x3e007fff
block|,
literal|0x0005
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tcc"
block|,
literal|0x00000454
block|,
literal|0x3e007fff
block|,
literal|0x0105
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tcnz"
block|,
literal|0x00003854
block|,
literal|0x3e007fff
block|,
literal|0x0e05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tcs!"
block|,
literal|0x0005
block|,
literal|0x7f0f
block|,
literal|0x00000054
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tcc!"
block|,
literal|0x0105
block|,
literal|0x7f0f
block|,
literal|0x00000454
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tcnz!"
block|,
literal|0x0e05
block|,
literal|0x7f0f
block|,
literal|0x00003854
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"teq"
block|,
literal|0x00001054
block|,
literal|0x3e007fff
block|,
literal|0x0405
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"teq!"
block|,
literal|0x0405
block|,
literal|0x7f0f
block|,
literal|0x00001054
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tgtu"
block|,
literal|0x00000854
block|,
literal|0x3e007fff
block|,
literal|0x0205
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tgt"
block|,
literal|0x00001854
block|,
literal|0x3e007fff
block|,
literal|0x0605
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tge"
block|,
literal|0x00002054
block|,
literal|0x3e007fff
block|,
literal|0x0805
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tgtu!"
block|,
literal|0x0205
block|,
literal|0x7f0f
block|,
literal|0x00000854
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tgt!"
block|,
literal|0x0605
block|,
literal|0x7f0f
block|,
literal|0x00001854
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tge!"
block|,
literal|0x0805
block|,
literal|0x7f0f
block|,
literal|0x00002054
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tleu"
block|,
literal|0x00000c54
block|,
literal|0x3e007fff
block|,
literal|0x0305
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tle"
block|,
literal|0x00001c54
block|,
literal|0x3e007fff
block|,
literal|0x0705
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tlt"
block|,
literal|0x00002454
block|,
literal|0x3e007fff
block|,
literal|0x0905
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"stlb"
block|,
literal|0x0c000004
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"mftlb"
block|,
literal|0x0c000024
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"mtptlb"
block|,
literal|0x0c000044
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"mtrtlb"
block|,
literal|0x0c000064
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tleu!"
block|,
literal|0x0305
block|,
literal|0x7f0f
block|,
literal|0x00000c54
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tle!"
block|,
literal|0x0705
block|,
literal|0x7f0f
block|,
literal|0x00001c54
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tlt!"
block|,
literal|0x0905
block|,
literal|0x7f0f
block|,
literal|0x00002454
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tmi"
block|,
literal|0x00002854
block|,
literal|0x3e007fff
block|,
literal|0x0a05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tmi!"
block|,
literal|0x0a05
block|,
literal|0x7f0f
block|,
literal|0x00002854
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tne"
block|,
literal|0x00001454
block|,
literal|0x3e007fff
block|,
literal|0x0505
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tne!"
block|,
literal|0x0505
block|,
literal|0x7f0f
block|,
literal|0x00001454
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tpl"
block|,
literal|0x00002c54
block|,
literal|0x3e007fff
block|,
literal|0x0b05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tpl!"
block|,
literal|0x0b05
block|,
literal|0x7f0f
block|,
literal|0x00002c54
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"trapcs"
block|,
literal|0x00000004
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapcc"
block|,
literal|0x00000404
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapgtu"
block|,
literal|0x00000804
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapleu"
block|,
literal|0x00000c04
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapeq"
block|,
literal|0x00001004
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapne"
block|,
literal|0x00001404
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapgt"
block|,
literal|0x00001804
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"traple"
block|,
literal|0x00001c04
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapge"
block|,
literal|0x00002004
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"traplt"
block|,
literal|0x00002404
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapmi"
block|,
literal|0x00002804
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trappl"
block|,
literal|0x00002c04
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapvs"
block|,
literal|0x00003004
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trapvc"
block|,
literal|0x00003404
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"trap"
block|,
literal|0x00003c04
block|,
literal|0x3e007fff
block|,
literal|0x8000
block|,
name|x_I5_x
block|,
name|do_xi5x
block|}
block|,
block|{
literal|"tset"
block|,
literal|0x00003c54
block|,
literal|0x3e007fff
block|,
literal|0x0f05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tset!"
block|,
literal|0x0f05
block|,
literal|0x00007f0f
block|,
literal|0x00003c54
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tvs"
block|,
literal|0x00003054
block|,
literal|0x3e007fff
block|,
literal|0x0c05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tvc"
block|,
literal|0x00003454
block|,
literal|0x3e007fff
block|,
literal|0x0d05
block|,
name|NO_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tvs!"
block|,
literal|0x0c05
block|,
literal|0x7f0f
block|,
literal|0x00003054
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"tvc!"
block|,
literal|0x0d05
block|,
literal|0x7f0f
block|,
literal|0x00003454
block|,
name|NO16_OPD
block|,
name|do_empty
block|}
block|,
block|{
literal|"xor"
block|,
literal|0x00000026
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"xor.c"
block|,
literal|0x00000027
block|,
literal|0x3e0003ff
block|,
literal|0x2007
block|,
name|Rd_Rs_Rs
block|,
name|do_rdrsrs
block|}
block|,
block|{
literal|"xor!"
block|,
literal|0x2007
block|,
literal|0x700f
block|,
literal|0x00000027
block|,
name|Rd_Rs
block|,
name|do16_rdrs
block|}
block|,
comment|/* Macro instruction.  */
block|{
literal|"li"
block|,
literal|0x020c0000
block|,
literal|0x3e0e0000
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_li_rdi32
block|}
block|,
comment|/* la reg, imm32        -->(1)  ldi  reg, simm16                              (2)  ldis reg, %HI(imm32)                                           ori  reg, %LO(imm32)                  la reg, symbol       -->(1)  lis  reg, %HI(imm32)                                   ori  reg, %LO(imm32)  */
block|{
literal|"la"
block|,
literal|0x020c0000
block|,
literal|0x3e0e0000
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_la_rdi32
block|}
block|,
block|{
literal|"div"
block|,
literal|0x00000044
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"divu"
block|,
literal|0x00000046
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"rem"
block|,
literal|0x00000044
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"remu"
block|,
literal|0x00000046
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"mul"
block|,
literal|0x00000040
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"mulu"
block|,
literal|0x00000042
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"maz"
block|,
literal|0x00000040
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"mazu"
block|,
literal|0x00000042
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"mul.f"
block|,
literal|0x00000041
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"maz.f"
block|,
literal|0x00000041
block|,
literal|0x3e0003ff
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_mul_rdrsrs
block|}
block|,
block|{
literal|"lb"
block|,
name|INSN_LB
block|,
literal|0x00000000
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"lbu"
block|,
name|INSN_LBU
block|,
literal|0x00000000
block|,
literal|0x200b
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"lh"
block|,
name|INSN_LH
block|,
literal|0x00000000
block|,
literal|0x2009
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"lhu"
block|,
name|INSN_LHU
block|,
literal|0x00000000
block|,
literal|0x8000
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"lw"
block|,
name|INSN_LW
block|,
literal|0x00000000
block|,
literal|0x2008
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"sb"
block|,
name|INSN_SB
block|,
literal|0x00000000
block|,
literal|0x200f
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"sh"
block|,
name|INSN_SH
block|,
literal|0x00000000
block|,
literal|0x200d
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
block|{
literal|"sw"
block|,
name|INSN_SW
block|,
literal|0x00000000
block|,
literal|0x200c
block|,
name|Insn_Type_SYN
block|,
name|do_macro_ldst_label
block|}
block|,
comment|/* Assembler use internal.  */
block|{
literal|"ld_i32hi"
block|,
literal|0x0a0c0000
block|,
literal|0x3e0e0000
block|,
literal|0x8000
block|,
name|Insn_internal
block|,
name|do_macro_rdi32hi
block|}
block|,
block|{
literal|"ld_i32lo"
block|,
literal|0x020a0000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Insn_internal
block|,
name|do_macro_rdi32lo
block|}
block|,
block|{
literal|"ldis_pic"
block|,
literal|0x0a0c0000
block|,
literal|0x3e0e0000
block|,
literal|0x5000
block|,
name|Insn_internal
block|,
name|do_rdi16_pic
block|}
block|,
block|{
literal|"addi_s_pic"
block|,
literal|0x02000000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Insn_internal
block|,
name|do_addi_s_pic
block|}
block|,
block|{
literal|"addi_u_pic"
block|,
literal|0x02000000
block|,
literal|0x3e0e0001
block|,
literal|0x8000
block|,
name|Insn_internal
block|,
name|do_addi_u_pic
block|}
block|,
block|{
literal|"lw_pic"
block|,
literal|0x20000000
block|,
literal|0x3e000000
block|,
literal|0x8000
block|,
name|Insn_internal
block|,
name|do_lw_pic
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free entry in the pool.  */
end_comment

begin_decl_stmt
name|int
name|next_literal_pool_place
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next literal pool number.  */
end_comment

begin_decl_stmt
name|int
name|lit_pool_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|current_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|end_of_line
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|retval
init|=
name|SUCCESS
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|retval
operator|=
operator|(
name|int
operator|)
name|FAIL
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_GARBAGE
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|score_reg_parse
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|struct
name|hash_control
modifier|*
name|htab
parameter_list|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|p
operator|=
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|htab
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|reg
operator|->
name|number
return|;
block|}
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* If shift<= 0, only return reg.  */
end_comment

begin_function
specifier|static
name|int
name|reg_required_here
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|shift
parameter_list|,
name|enum
name|score_reg_type
name|reg_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|reg
init|=
operator|(
name|int
operator|)
name|FAIL
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|score_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|reg_type
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
name|reg_type
operator|==
name|REG_TYPE_SCORE
condition|)
block|{
if|if
condition|(
operator|(
name|reg
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nor1
operator|==
literal|1
operator|)
operator|&&
operator|(
name|inst
operator|.
name|bwarn
operator|==
literal|0
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Using temp register(r1)"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|bwarn
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|reg_type
operator|==
name|REG_TYPE_SCORE_CR
condition|)
name|strcpy
argument_list|(
name|inst
operator|.
name|reg
argument_list|,
name|score_crn_table
index|[
name|reg
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_type
operator|==
name|REG_TYPE_SCORE_SR
condition|)
name|strcpy
argument_list|(
name|inst
operator|.
name|reg
argument_list|,
name|score_srn_table
index|[
name|reg
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|inst
operator|.
name|reg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|shift
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|str
operator|=
name|start
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"register expected, not '%.100s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_past_comma
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
operator|&&
name|comma
operator|++
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_SKIP_COMMA
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|comma
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_SKIP_COMMA
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|comma
condition|?
name|SUCCESS
else|:
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rdrsrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|==
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|walk_no_bignums
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|)
block|{
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op
operator|==
name|O_big
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
condition|)
return|return
operator|(
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_get_expression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
name|in_my_get_expression
operator|=
literal|1
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|in_my_get_expression
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_illegal
condition|)
block|{
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"illegal expression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
comment|/* Get rid of any bignums now, so that we don't generate an error for which      we can't establish a line number later on.  Big numbers are never valid      in instructions, which is where this routine is always called.  */
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_big
operator|||
operator|(
name|ep
operator|->
name|X_add_symbol
operator|&&
operator|(
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|ep
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|ep
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|PC_DISP19div2
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|PC_DISP8div2
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|PC_DISP24div2
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|PC_DISP11div2
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Insn_Type_SYN
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Rd_rvalueRs_SI15
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Rd_lvalueRs_SI15
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Insn_internal
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Check if an immediate is valid.  If so, convert it to the right format.  */
end_comment

begin_function
specifier|static
name|int
name|validate_immediate
parameter_list|(
name|int
name|val
parameter_list|,
name|unsigned
name|int
name|data_type
parameter_list|,
name|int
name|hex_p
parameter_list|)
block|{
switch|switch
condition|(
name|data_type
condition|)
block|{
case|case
name|_VALUE_HI16
case|:
block|{
name|int
name|val_hi
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
decl_stmt|;
if|if
condition|(
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
operator|<=
name|val_hi
operator|&&
name|val_hi
operator|<=
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
condition|)
return|return
name|val_hi
return|;
block|}
break|break;
case|case
name|_VALUE_LO16
case|:
block|{
name|int
name|val_lo
init|=
operator|(
name|val
operator|&
literal|0xffff
operator|)
decl_stmt|;
if|if
condition|(
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
operator|<=
name|val_lo
operator|&&
name|val_lo
operator|<=
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
condition|)
return|return
name|val_lo
return|;
block|}
break|break;
case|case
name|_VALUE
case|:
return|return
name|val
return|;
break|break;
case|case
name|_SIMM14
case|:
if|if
condition|(
name|hex_p
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|>=
operator|-
literal|0x2000
operator|&&
name|val
operator|<=
literal|0x3fff
operator|)
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|>=
operator|-
literal|8192
operator|&&
name|val
operator|<=
literal|8191
operator|)
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
return|return
name|val
return|;
break|break;
case|case
name|_SIMM16_NEG
case|:
if|if
condition|(
name|hex_p
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|>=
operator|-
literal|0x7fff
operator|&&
name|val
operator|<=
literal|0xffff
operator|&&
name|val
operator|!=
literal|0x8000
operator|)
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|val
operator|>=
operator|-
literal|32767
operator|&&
name|val
operator|<=
literal|32768
operator|)
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
name|val
operator|=
operator|-
name|val
expr_stmt|;
return|return
name|val
return|;
break|break;
default|default:
if|if
condition|(
name|data_type
operator|==
name|_SIMM14_NEG
operator|||
name|data_type
operator|==
name|_IMM16_NEG
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
operator|<=
name|val
operator|&&
name|val
operator|<=
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
condition|)
return|return
name|val
return|;
break|break;
block|}
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|data_op2
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|shift
parameter_list|,
name|enum
name|score_data_type
name|data_type
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|char
name|data_exp
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|dataptr
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|dataptr
operator|=
operator|*
name|str
expr_stmt|;
comment|/* Set hex_p to zero.  */
name|int
name|hex_p
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|dataptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|dataptr
operator|!=
literal|'|'
operator|)
operator|&&
operator|(
name|cnt
operator|<=
name|MAX_LITERAL_POOL_SIZE
operator|)
condition|)
comment|/* 0x7c = ='|' */
block|{
name|data_exp
index|[
name|cnt
index|]
operator|=
operator|*
name|dataptr
expr_stmt|;
name|dataptr
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|data_exp
index|[
name|cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data_exp
expr_stmt|;
if|if
condition|(
operator|*
name|dataptr
operator|==
literal|'|'
condition|)
comment|/* process PCE */
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|pp
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
name|end_of_line
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
comment|/* to ouptut_inst to printf out the error */
operator|*
name|str
operator|=
name|dataptr
expr_stmt|;
block|}
else|else
comment|/* process  16 bit */
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
name|dataptr
operator|=
operator|(
name|char
operator|*
operator|)
name|data_exp
expr_stmt|;
for|for
control|(
init|;
operator|*
name|dataptr
operator|!=
literal|'\0'
condition|;
name|dataptr
operator|++
control|)
block|{
operator|*
name|dataptr
operator|=
name|TOLOWER
argument_list|(
operator|*
name|dataptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dataptr
operator|==
literal|'!'
operator|||
operator|*
name|dataptr
operator|==
literal|' '
condition|)
break|break;
block|}
name|dataptr
operator|=
operator|(
name|char
operator|*
operator|)
name|data_exp
expr_stmt|;
if|if
condition|(
operator|(
name|dataptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|strstr
argument_list|(
name|dataptr
argument_list|,
literal|"0x"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|strstr
argument_list|(
name|dataptr
argument_list|,
literal|"0X"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|hex_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|data_type
operator|!=
name|_SIMM16_LA
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_HI16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_LO16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM15
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM14
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM4
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM8
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_1
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_2
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM14
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM14_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM16_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM10_RSHIFT_2
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_GP_IMM15
operator|)
condition|)
block|{
name|data_type
operator|+=
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|==
literal|0
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Insn_Type_SYN
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Rd_rvalueRs_SI15
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Rd_lvalueRs_SI15
operator|)
operator|&&
operator|(
name|inst
operator|.
name|type
operator|!=
name|Insn_internal
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|*
name|dataptr
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|dataptr
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|dataptr
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|2
operator|)
operator|!=
literal|'0'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|dataptr
operator|==
literal|'+'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|1
operator|)
operator|!=
literal|'0'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|dataptr
operator|==
literal|'-'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|1
operator|)
operator|!=
literal|'0'
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|)
operator|&&
operator|(
operator|(
name|data_type
operator|==
name|_SIMM16
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_SIMM16_NEG
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM16_NEG
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_SIMM14
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_SIMM14_NEG
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM5
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM14
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM20
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM16
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM15
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM4
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
switch|switch
condition|(
name|data_type
condition|)
block|{
case|case
name|_SIMM16_LA
case|:
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
case|case
name|_VALUE_HI16
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_HI16_S
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_VALUE_LO16
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_GP_IMM15
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_GPREL15
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_SIMM16_pic
case|:
case|case
name|_IMM16_LO16_pic
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_GOT_LO16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data_type
operator|==
name|_IMM16_pic
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_DUMMY_HI16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_type
operator|==
name|_SIMM16_LA
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_unsigned
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|_SIMM16_LA_POS
argument_list|,
name|hex_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
comment|/* for advance to check if this is ldis */
if|if
condition|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
literal|0x8000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|<<
literal|1
operator|)
operator|&
literal|0x1fffe
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|data_type
argument_list|,
name|hex_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
operator|(
name|data_type
operator|!=
name|_SIMM14_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM16_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM16_NEG
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
argument_list|,
operator|-
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|,
operator|-
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|inst
operator|.
name|error
operator|=
name|err_msg
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM5_RANGE_8_31
operator|)
condition|)
block|{
name|value
operator|&=
operator|(
literal|1
operator|<<
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
operator|<<
name|shift
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0x30000000
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|2
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|3
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|4
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|8
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|9
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0xa
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0xb
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0xc
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0xd
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0xe
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x10
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x11
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x18
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x1A
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x1B
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x1d
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x1e
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
operator|)
operator|!=
literal|0x1f
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant: bit expression not defined"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Handle addi/addi.c/addis.c/cmpi.c/addis.c/ldi.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdsi16
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM16
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* ldi.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x20c0000
operator|)
operator|==
literal|0x20c0000
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x1fe00
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle subi/subi.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_sub_rdsi16
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM16_NEG
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle addri/addri.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdrssi14
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
comment|/* -(2^13)~((2^13)-1) */
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM14
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle subri.c/subri.  */
end_comment

begin_function
specifier|static
name|void
name|do_sub_rdrssi14
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
comment|/* -(2^13)~((2^13)-1) */
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM14_NEG
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle bitclr.c/bitset.c/bittgl.c/slli.c/srai.c/srli.c/roli.c/rori.c/rolic.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdrsi5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
comment|/* 0~((2^14)-1) */
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1f
operator|)
operator|==
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x1f
operator|)
operator|)
operator|&&
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle andri/orri/andri.c/orri.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdrsi14
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
comment|/* 0 ~ ((2^14)-1)  */
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_IMM14
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle bittst.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_xrsi5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle addis/andi/ori/andis/oris/ldis.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdi16
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_IMM16
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/*   if (((inst.instruction& 0xa0dfffe) != 0xa0c0000) || ((((inst.instruction>> 20)& 0x1f)& 0x10) == 0x10))     inst.relax_inst = 0x8000;   else     inst.relax_size = 2;   */
block|}
end_function

begin_function
specifier|static
name|void
name|do_macro_rdi32hi
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Do not handle end_of_line().  */
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_VALUE_HI16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_macro_rdi32lo
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Do not handle end_of_line().  */
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_VALUE_LO16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle ldis_pic.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdi16_pic
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_IMM16_pic
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle addi_s_pic to generate R_SCORE_GOT_LO16 .  */
end_comment

begin_function
specifier|static
name|void
name|do_addi_s_pic
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM16_pic
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle addi_u_pic to generate R_SCORE_GOT_LO16 .  */
end_comment

begin_function
specifier|static
name|void
name|do_addi_u_pic
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_IMM16_LO16_pic
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle mfceh/mfcel/mtceh/mtchl.  */
end_comment

begin_function
specifier|static
name|void
name|do_rd
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_i15
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|_IMM15
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_xi5x
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_rdrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7f
operator|)
operator|==
literal|0x56
operator|)
condition|)
comment|/* adjust mv -> mv! / mlfh! / mhfl! */
block|{
comment|/* mlfh */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|!=
literal|0x0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x00000001
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* mhfl */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|!=
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x00000002
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle mfcr/mtcr.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdcrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE_CR
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle mfsr/mtsr.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdsrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* mfsr */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xff
operator|)
operator|==
literal|0x50
condition|)
block|{
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE_SR
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE_SR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle neg.  */
end_comment

begin_function
specifier|static
name|void
name|do_rdxrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle cmp.c/cmp<cond>.  */
end_comment

begin_function
specifier|static
name|void
name|do_rsrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1f
operator|)
operator|==
literal|3
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ceinst
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|strbak
decl_stmt|;
name|strbak
operator|=
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
name|str
operator|=
name|strbak
expr_stmt|;
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|,
name|_IMM25
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|reglow_required_here
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|score_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_SCORE
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
operator|(
name|reg
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nor1
operator|==
literal|1
operator|)
operator|&&
operator|(
name|inst
operator|.
name|bwarn
operator|==
literal|0
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Using temp register(r1)"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|bwarn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|shift
expr_stmt|;
return|return
name|reg
return|;
block|}
block|}
comment|/* Restore the start point, we may have got a reg of the wrong class.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"low register(r0-r15)expected, not '%.100s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Handle addc!/add!/and!/cmp!/neg!/not!/or!/sll!/srl!/sra!/xor!/sub!.  */
end_comment

begin_function
specifier|static
name|void
name|do16_rdrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x700f
operator|)
operator|==
literal|0x2003
condition|)
comment|/* cmp!  */
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x700f
operator|)
operator|==
literal|0x2006
condition|)
comment|/* not!  */
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
block|}
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do16_rs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|rd
init|=
literal|0
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
name|rd
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle br!/brl!.  */
end_comment

begin_function
specifier|static
name|void
name|do16_xrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|reghigh_required_here
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|score_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_SCORE
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
literal|15
operator|<
name|reg
operator|&&
name|reg
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
operator|(
name|reg
operator|&
literal|0xf
operator|)
operator|<<
name|shift
expr_stmt|;
return|return
name|reg
return|;
block|}
block|}
operator|*
name|str
operator|=
name|start
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"high register(r16-r31)expected, not '%.100s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Handle mhfl!.  */
end_comment

begin_function
specifier|static
name|void
name|do16_hrdrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reghigh_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator||
literal|0x10
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
literal|0xf
operator|<<
literal|10
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle mlfh!.  */
end_comment

begin_function
specifier|static
name|void
name|do16_rdhrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|reghigh_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
operator|&&
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator||
literal|0x10
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
literal|0xf
operator|<<
literal|10
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We need to be able to fix up arbitrary expressions in some statements.    This is so that we can handle symbols that are an arbitrary distance from    the pc.  The most common cases are of the form ((+/-sym -/+ . - 8)& mask),    which returns part of an address in a form which will be valid for    a data instruction.  We do this by pushing the expression into a symbol    in the expr_section, and creating a fix for that.  */
end_comment

begin_function
specifier|static
name|fixS
modifier|*
name|fix_new_score
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|short
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|pc_rel
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_fix
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|new_fix
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_dependency_vector
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vector_size
condition|;
name|i
operator|++
control|)
name|memset
argument_list|(
operator|&
name|dependency_vector
index|[
name|i
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_type_for_dependency
name|dependency_type_from_insn
parameter_list|(
name|char
modifier|*
name|insn_name
parameter_list|)
block|{
name|char
name|name
index|[
name|INSN_NAME_LEN
index|]
decl_stmt|;
specifier|const
name|struct
name|insn_to_dependency
modifier|*
name|tmp
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
specifier|const
expr|struct
name|insn_to_dependency
operator|*
operator|)
name|hash_find
argument_list|(
name|dependency_insn_hsh
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
operator|->
name|type
return|;
return|return
name|D_all_insn
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_dependency
parameter_list|(
name|char
modifier|*
name|pre_insn
parameter_list|,
name|char
modifier|*
name|pre_reg
parameter_list|,
name|char
modifier|*
name|cur_insn
parameter_list|,
name|char
modifier|*
name|cur_reg
parameter_list|,
name|int
modifier|*
name|warn_or_error
parameter_list|)
block|{
name|int
name|bubbles
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|insn_type_for_dependency
name|pre_insn_type
decl_stmt|;
name|enum
name|insn_type_for_dependency
name|cur_insn_type
decl_stmt|;
name|pre_insn_type
operator|=
name|dependency_type_from_insn
argument_list|(
name|pre_insn
argument_list|)
expr_stmt|;
name|cur_insn_type
operator|=
name|dependency_type_from_insn
argument_list|(
name|cur_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|data_dependency_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|data_dependency_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pre_insn_type
operator|==
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|pre_insn_type
operator|)
operator|&&
operator|(
name|D_all_insn
operator|==
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|cur_insn_type
operator|||
name|cur_insn_type
operator|==
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|cur_insn_type
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|pre_reg
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|pre_reg
argument_list|,
name|pre_reg
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|cur_reg
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|cur_reg
argument_list|,
name|cur_reg
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|bubbles
operator|=
operator|(
name|score7
operator|)
condition|?
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|bubblenum_7
else|:
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|bubblenum_5
expr_stmt|;
operator|*
name|warn_or_error
operator|=
name|data_dependency_table
index|[
name|i
index|]
operator|.
name|warn_or_error
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bubbles
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_one_frag
parameter_list|(
name|struct
name|score_it
name|one_inst
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|relaxable_p
init|=
name|g_opt
decl_stmt|;
name|int
name|relax_size
init|=
literal|0
decl_stmt|;
comment|/* Start a new frag if frag_now is not empty.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frag_grow
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|one_inst
operator|.
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|one_inst
operator|.
name|instruction
argument_list|,
name|one_inst
operator|.
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|one_inst
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|relaxable_p
operator|&=
operator|(
name|one_inst
operator|.
name|relax_size
operator|!=
literal|0
operator|)
expr_stmt|;
name|relax_size
operator|=
name|relaxable_p
condition|?
name|one_inst
operator|.
name|relax_size
else|:
literal|0
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|relax_size
operator|+
name|RELAX_PAD_BYTE
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|one_inst
operator|.
name|size
argument_list|,
name|one_inst
operator|.
name|relax_size
argument_list|,
name|one_inst
operator|.
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|relaxable_p
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|relaxable_p
condition|)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|one_inst
operator|.
name|relax_inst
argument_list|,
name|relax_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_dependency
parameter_list|(
name|struct
name|score_it
modifier|*
name|theinst
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|warn_or_error
init|=
literal|0
decl_stmt|;
comment|/* warn - 0; error - 1  */
name|int
name|bubbles
init|=
literal|0
decl_stmt|;
name|int
name|remainder_bubbles
init|=
literal|0
decl_stmt|;
name|char
name|cur_insn
index|[
name|INSN_NAME_LEN
index|]
decl_stmt|;
name|char
name|pre_insn
index|[
name|INSN_NAME_LEN
index|]
decl_stmt|;
name|struct
name|score_it
name|nop_inst
decl_stmt|;
name|struct
name|score_it
name|pflush_inst
decl_stmt|;
name|nop_inst
operator|.
name|instruction
operator|=
literal|0x0000
expr_stmt|;
name|nop_inst
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|nop_inst
operator|.
name|relax_inst
operator|=
literal|0x80008000
expr_stmt|;
name|nop_inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
name|nop_inst
operator|.
name|type
operator|=
name|NO16_OPD
expr_stmt|;
name|pflush_inst
operator|.
name|instruction
operator|=
literal|0x8000800a
expr_stmt|;
name|pflush_inst
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|pflush_inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
name|pflush_inst
operator|.
name|relax_size
operator|=
literal|0
expr_stmt|;
name|pflush_inst
operator|.
name|type
operator|=
name|NO_OPD
expr_stmt|;
comment|/* pflush will clear all data dependency.  */
if|if
condition|(
name|strcmp
argument_list|(
name|theinst
operator|->
name|name
argument_list|,
literal|"pflush"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|init_dependency_vector
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Push current instruction to dependency_vector[0].  */
for|for
control|(
name|i
operator|=
name|vector_size
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|memcpy
argument_list|(
operator|&
name|dependency_vector
index|[
name|i
index|]
argument_list|,
operator|&
name|dependency_vector
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dependency_vector
index|[
literal|0
index|]
argument_list|,
name|theinst
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There is no dependency between nop and any instruction.  */
if|if
condition|(
name|strcmp
argument_list|(
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"nop!"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* "pce" is defined in insn_to_dependency_table.  */
define|#
directive|define
name|PCE_NAME
value|"pce"
if|if
condition|(
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|Insn_Type_PCE
condition|)
name|strcpy
argument_list|(
name|cur_insn
argument_list|,
name|PCE_NAME
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|cur_insn
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vector_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* The element of dependency_vector is NULL.  */
if|if
condition|(
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|dependency_vector
index|[
name|i
index|]
operator|.
name|type
operator|==
name|Insn_Type_PCE
condition|)
name|strcpy
argument_list|(
name|pre_insn
argument_list|,
name|PCE_NAME
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pre_insn
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|bubbles
operator|=
name|check_dependency
argument_list|(
name|pre_insn
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|cur_insn
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
operator|&
name|warn_or_error
argument_list|)
expr_stmt|;
name|remainder_bubbles
operator|=
name|bubbles
operator|-
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|remainder_bubbles
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fix_data_dependency
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|remainder_bubbles
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|warn_fix_data_dependency
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Fix data dependency: %s %s -- %s %s  (insert %d nop!/%d)"
argument_list|)
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|remainder_bubbles
argument_list|,
name|bubbles
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|vector_size
operator|-
literal|1
operator|)
init|;
operator|(
name|j
operator|-
name|remainder_bubbles
operator|)
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|memcpy
argument_list|(
operator|&
name|dependency_vector
index|[
name|j
index|]
argument_list|,
operator|&
name|dependency_vector
index|[
name|j
operator|-
name|remainder_bubbles
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|remainder_bubbles
condition|;
name|j
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|dependency_vector
index|[
name|j
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert nop!.  */
name|build_one_frag
argument_list|(
name|nop_inst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|warn_fix_data_dependency
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Fix data dependency: %s %s -- %s %s  (insert 1 pflush/%d)"
argument_list|)
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|bubbles
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|vector_size
condition|;
name|j
operator|++
control|)
name|memset
argument_list|(
operator|&
name|dependency_vector
index|[
name|j
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|dependency_vector
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert pflush.  */
name|build_one_frag
argument_list|(
name|pflush_inst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|warn_or_error
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"data dependency: %s %s -- %s %s  (%d/%d bubble)"
argument_list|)
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|remainder_bubbles
argument_list|,
name|bubbles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"data dependency: %s %s -- %s %s  (%d/%d bubble)"
argument_list|)
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|dependency_vector
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|remainder_bubbles
argument_list|,
name|bubbles
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_class
name|get_insn_class_from_type
parameter_list|(
name|enum
name|score_insn_type
name|type
parameter_list|)
block|{
name|enum
name|insn_class
name|retval
init|=
operator|(
name|int
operator|)
name|FAIL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Rd_I4
case|:
case|case
name|Rd_I5
case|:
case|case
name|Rd_rvalueBP_I5
case|:
case|case
name|Rd_lvalueBP_I5
case|:
case|case
name|Rd_I8
case|:
case|case
name|PC_DISP8div2
case|:
case|case
name|PC_DISP11div2
case|:
case|case
name|Rd_Rs
case|:
case|case
name|Rd_HighRs
case|:
case|case
name|Rd_lvalueRs
case|:
case|case
name|Rd_rvalueRs
case|:
case|case
name|x_Rs
case|:
case|case
name|Rd_LowRs
case|:
case|case
name|NO16_OPD
case|:
name|retval
operator|=
name|INSN_CLASS_16
expr_stmt|;
break|break;
case|case
name|Rd_Rs_I5
case|:
case|case
name|x_Rs_I5
case|:
case|case
name|x_I5_x
case|:
case|case
name|Rd_Rs_I14
case|:
case|case
name|I15
case|:
case|case
name|Rd_I16
case|:
case|case
name|Rd_SI16
case|:
case|case
name|Rd_rvalueRs_SI10
case|:
case|case
name|Rd_lvalueRs_SI10
case|:
case|case
name|Rd_rvalueRs_preSI12
case|:
case|case
name|Rd_rvalueRs_postSI12
case|:
case|case
name|Rd_lvalueRs_preSI12
case|:
case|case
name|Rd_lvalueRs_postSI12
case|:
case|case
name|Rd_Rs_SI14
case|:
case|case
name|Rd_rvalueRs_SI15
case|:
case|case
name|Rd_lvalueRs_SI15
case|:
case|case
name|PC_DISP19div2
case|:
case|case
name|PC_DISP24div2
case|:
case|case
name|Rd_Rs_Rs
case|:
case|case
name|x_Rs_x
case|:
case|case
name|x_Rs_Rs
case|:
case|case
name|Rd_Rs_x
case|:
case|case
name|Rd_x_Rs
case|:
case|case
name|Rd_x_x
case|:
case|case
name|OP5_rvalueRs_SI15
case|:
case|case
name|I5_Rs_Rs_I5_OP5
case|:
case|case
name|x_rvalueRs_post4
case|:
case|case
name|Rd_rvalueRs_post4
case|:
case|case
name|Rd_x_I5
case|:
case|case
name|Rd_lvalueRs_post4
case|:
case|case
name|x_lvalueRs_post4
case|:
case|case
name|Rd_Rs_Rs_imm
case|:
case|case
name|NO_OPD
case|:
case|case
name|Rd_lvalue32Rs
case|:
case|case
name|Rd_rvalue32Rs
case|:
case|case
name|Insn_GP
case|:
case|case
name|Insn_PIC
case|:
case|case
name|Insn_internal
case|:
name|retval
operator|=
name|INSN_CLASS_32
expr_stmt|;
break|break;
case|case
name|Insn_Type_PCE
case|:
name|retval
operator|=
name|INSN_CLASS_PCE
expr_stmt|;
break|break;
case|case
name|Insn_Type_SYN
case|:
name|retval
operator|=
name|INSN_CLASS_SYN
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|adjust_paritybit
parameter_list|(
name|unsigned
name|long
name|m_code
parameter_list|,
name|enum
name|insn_class
name|class
parameter_list|)
block|{
name|unsigned
name|long
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|m_code_high
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|m_code_low
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|pb_high
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|pb_low
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|INSN_CLASS_32
condition|)
block|{
name|pb_high
operator|=
literal|0x80000000
expr_stmt|;
name|pb_low
operator|=
literal|0x00008000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|INSN_CLASS_16
condition|)
block|{
name|pb_high
operator|=
literal|0
expr_stmt|;
name|pb_low
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|INSN_CLASS_PCE
condition|)
block|{
name|pb_high
operator|=
literal|0
expr_stmt|;
name|pb_low
operator|=
literal|0x00008000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|INSN_CLASS_SYN
condition|)
block|{
comment|/* FIXME.  at this time, INSN_CLASS_SYN must be 32 bit, but, instruction type should          be changed if macro instruction has been expanded.  */
name|pb_high
operator|=
literal|0x80000000
expr_stmt|;
name|pb_low
operator|=
literal|0x00008000
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|m_code_high
operator|=
name|m_code
operator|&
literal|0x3fff8000
expr_stmt|;
name|m_code_low
operator|=
name|m_code
operator|&
literal|0x00007fff
expr_stmt|;
name|result
operator|=
name|pb_high
operator||
operator|(
name|m_code_high
operator|<<
literal|1
operator|)
operator||
name|pb_low
operator||
name|m_code_low
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_insn_frag
parameter_list|(
name|struct
name|score_it
modifier|*
name|part_1
parameter_list|,
name|struct
name|score_it
modifier|*
name|part_2
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bfd_boolean
name|pce_p
init|=
name|FALSE
decl_stmt|;
name|int
name|relaxable_p
init|=
name|g_opt
decl_stmt|;
name|int
name|relax_size
init|=
literal|0
decl_stmt|;
name|struct
name|score_it
modifier|*
name|inst1
init|=
name|part_1
decl_stmt|;
name|struct
name|score_it
modifier|*
name|inst2
init|=
name|part_2
decl_stmt|;
name|struct
name|score_it
name|backup_inst1
decl_stmt|;
name|pce_p
operator|=
operator|(
name|inst2
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|backup_inst1
argument_list|,
name|inst1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust instruction opcode and to be relaxed instruction opcode.  */
if|if
condition|(
name|pce_p
condition|)
block|{
name|backup_inst1
operator|.
name|instruction
operator|=
operator|(
operator|(
name|backup_inst1
operator|.
name|instruction
operator|&
literal|0x7FFF
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|inst2
operator|->
name|instruction
operator|&
literal|0x7FFF
operator|)
expr_stmt|;
name|backup_inst1
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|backup_inst1
operator|.
name|instruction
argument_list|,
name|INSN_CLASS_PCE
argument_list|)
expr_stmt|;
name|backup_inst1
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
name|backup_inst1
operator|.
name|size
operator|=
name|INSN_SIZE
expr_stmt|;
name|backup_inst1
operator|.
name|relax_size
operator|=
literal|0
expr_stmt|;
name|backup_inst1
operator|.
name|type
operator|=
name|Insn_Type_PCE
expr_stmt|;
block|}
else|else
block|{
name|backup_inst1
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|backup_inst1
operator|.
name|instruction
argument_list|,
name|GET_INSN_CLASS
argument_list|(
name|backup_inst1
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backup_inst1
operator|.
name|relax_size
operator|!=
literal|0
condition|)
block|{
name|enum
name|insn_class
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|backup_inst1
operator|.
name|size
operator|==
name|INSN_SIZE
operator|)
condition|?
name|INSN_CLASS_16
else|:
name|INSN_CLASS_32
expr_stmt|;
name|backup_inst1
operator|.
name|relax_inst
operator|=
name|adjust_paritybit
argument_list|(
name|backup_inst1
operator|.
name|relax_inst
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Check data dependency.  */
name|handle_dependency
argument_list|(
operator|&
name|backup_inst1
argument_list|)
expr_stmt|;
comment|/* Start a new frag if frag_now is not empty and is not instruction frag, maybe it contains      data produced by .ascii etc.  Doing this is to make one instruction per frag.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Here, we must call frag_grow in order to keep the instruction frag type is      rs_machine_dependent.      For, frag_var may change frag_now->fr_type to rs_fill by calling frag_grow which      acturally will call frag_wane.      Calling frag_grow first will create a new frag_now which free size is 20 that is enough      for frag_var.  */
name|frag_grow
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|backup_inst1
operator|.
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|backup_inst1
operator|.
name|instruction
argument_list|,
name|backup_inst1
operator|.
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|backup_inst1
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Generate fixup structure.  */
if|if
condition|(
name|pce_p
condition|)
block|{
if|if
condition|(
name|inst1
operator|->
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst1
operator|->
name|size
argument_list|,
operator|&
name|inst1
operator|->
name|reloc
operator|.
name|exp
argument_list|,
name|inst1
operator|->
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst1
operator|->
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst2
operator|->
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
name|inst2
operator|->
name|size
argument_list|,
operator|&
name|inst2
operator|->
name|reloc
operator|.
name|exp
argument_list|,
name|inst2
operator|->
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst2
operator|->
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|backup_inst1
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|backup_inst1
operator|.
name|size
argument_list|,
operator|&
name|backup_inst1
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|backup_inst1
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|backup_inst1
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* relax_size may be 2, 4, 12 or 0, 0 indicates no relaxation.  */
name|relaxable_p
operator|&=
operator|(
name|backup_inst1
operator|.
name|relax_size
operator|!=
literal|0
operator|)
expr_stmt|;
name|relax_size
operator|=
name|relaxable_p
condition|?
name|backup_inst1
operator|.
name|relax_size
else|:
literal|0
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|relax_size
operator|+
name|RELAX_PAD_BYTE
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|backup_inst1
operator|.
name|size
argument_list|,
name|backup_inst1
operator|.
name|relax_size
argument_list|,
name|backup_inst1
operator|.
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|relaxable_p
argument_list|)
argument_list|,
name|backup_inst1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|relaxable_p
condition|)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|backup_inst1
operator|.
name|relax_inst
argument_list|,
name|relax_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inst1
argument_list|,
operator|&
name|backup_inst1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_16_32_inst
parameter_list|(
name|char
modifier|*
name|insnstr
parameter_list|,
name|bfd_boolean
name|gen_frag_p
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|operator
init|=
name|insnstr
decl_stmt|;
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* Parse operator and operands.  */
name|skip_whitespace
argument_list|(
name|operator
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|operator
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|asm_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|score_ops_hsh
argument_list|,
name|operator
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inst
operator|.
name|str
argument_list|,
literal|"%s"
argument_list|,
name|insnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|inst
operator|.
name|relax_inst
operator|=
name|opcode
operator|->
name|relax_value
expr_stmt|;
name|inst
operator|.
name|type
operator|=
name|opcode
operator|->
name|type
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|GET_INSN_SIZE
argument_list|(
name|inst
operator|.
name|type
argument_list|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|bwarn
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"%s"
argument_list|,
name|opcode
operator|->
name|template
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|inst
operator|.
name|reg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* It indicates current instruction is a macro instruction if inst.bwarn equals -1.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|bwarn
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|inst
operator|.
name|error
operator|)
operator|&&
operator|(
name|gen_frag_p
operator|)
condition|)
name|gen_insn_frag
argument_list|(
operator|&
name|inst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"unrecognized opcode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_insn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|bfd_boolean
name|gen_frag_p
parameter_list|)
block|{
name|int
name|retval
init|=
name|SUCCESS
decl_stmt|;
name|parse_16_32_inst
argument_list|(
name|str
argument_list|,
name|gen_frag_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
block|{
name|retval
operator|=
operator|(
name|int
operator|)
name|FAIL
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s -- `%s'"
argument_list|)
argument_list|,
name|inst
operator|.
name|error
argument_list|,
name|inst
operator|.
name|str
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Handle mv! reg_high, reg_low;           mv! reg_low, reg_high;           mv! reg_low, reg_low;  */
end_comment

begin_function
specifier|static
name|void
name|do16_mv_rdrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|int
name|reg_rs
decl_stmt|;
name|char
modifier|*
name|backupstr
init|=
name|NULL
decl_stmt|;
name|backupstr
operator|=
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
operator|(
name|reg_rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
comment|/* Case 1 : mv! or mlfh!.  */
if|if
condition|(
name|reg_rd
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|reg_rs
operator|<
literal|16
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
literal|0xf
operator|<<
literal|10
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"mlfh! %s"
argument_list|,
name|backupstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Case 2 : mhfl!.  */
else|else
block|{
if|if
condition|(
name|reg_rs
operator|>
literal|16
condition|)
block|{
name|SET_INSN_ERROR
argument_list|(
name|BAD_ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"mhfl! %s"
argument_list|,
name|backupstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do16_rdi4
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|3
argument_list|,
name|_IMM4
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
comment|/* for judge is addei or subei : bit 5 =0 : addei */
block|{
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0xf
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xf
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0xf
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
operator|-
operator|(
literal|1
operator|<<
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xf
operator|)
operator|)
operator|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do16_rdi5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|3
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle sdbbp.  */
end_comment

begin_function
specifier|static
name|void
name|do16_xi5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|3
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|15
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check that an immediate is word alignment or half word alignment.    If so, convert it to the right format.  */
end_comment

begin_function
specifier|static
name|int
name|validate_immediate_align
parameter_list|(
name|int
name|val
parameter_list|,
name|unsigned
name|int
name|data_type
parameter_list|)
block|{
if|if
condition|(
name|data_type
operator|==
name|_IMM5_RSHIFT_1
condition|)
block|{
if|if
condition|(
name|val
operator|%
literal|2
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address offset must be half word alignment"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|data_type
operator|==
name|_IMM5_RSHIFT_2
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM10_RSHIFT_2
operator|)
condition|)
block|{
if|if
condition|(
name|val
operator|%
literal|4
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address offset must be word alignment"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|exp_ldst_offset
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|shift
parameter_list|,
name|unsigned
name|int
name|data_type
parameter_list|)
block|{
name|char
modifier|*
name|dataptr
decl_stmt|;
name|dataptr
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dataptr
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM16_LA
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_HI16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_LO16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM15
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM14
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM4
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM8
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_1
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_2
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM14_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM10_RSHIFT_2
operator|)
condition|)
block|{
name|data_type
operator|+=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Need to check the immediate align.  */
name|int
name|value
init|=
name|validate_immediate_align
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|data_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|data_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
name|data_type
operator|<
literal|30
condition|)
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|bits
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|err_msg
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FAIL
return|;
block|}
if|if
condition|(
name|data_type
operator|==
name|_IMM5_RSHIFT_1
condition|)
block|{
name|value
operator|>>=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|data_type
operator|==
name|_IMM5_RSHIFT_2
operator|)
operator|||
operator|(
name|data_type
operator|==
name|_IMM10_RSHIFT_2
operator|)
condition|)
block|{
name|value
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|value
operator|&=
operator|(
literal|1
operator|<<
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
operator|<<
name|shift
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldst_insn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|conflict_reg
decl_stmt|;
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|strbak
decl_stmt|;
name|char
modifier|*
name|dataptr
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|ldst_idx
init|=
literal|0
decl_stmt|;
name|strbak
operator|=
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
comment|/* ld/sw rD, [rA, simm15]    ld/sw rD, [rA]+, simm12     ld/sw rD, [rA, simm12]+.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Conflicts can occur on stores as well as loads.  */
name|conflict_reg
operator|=
operator|(
name|conflict_reg
operator|==
name|reg
operator|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|temp
operator|=
name|str
operator|+
literal|1
expr_stmt|;
comment|/* The latter will process decimal/hex expression.  */
comment|/* ld/sw rD, [rA]+, simm12    ld/sw rD, [rA]+.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
comment|/* ld/sw rD, [rA]+, simm12.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|exp_ldst_offset
argument_list|(
operator|&
name|str
argument_list|,
literal|3
argument_list|,
name|_SIMM12
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
if|if
condition|(
name|conflict_reg
condition|)
block|{
name|unsigned
name|int
name|ldst_func
init|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
decl_stmt|;
if|if
condition|(
operator|(
name|ldst_func
operator|==
name|INSN_LH
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LHU
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LW
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LB
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LBU
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register same as write-back base"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
name|LDST_POST
index|]
operator|.
name|value
expr_stmt|;
comment|/* lw rD, [rA]+, 4 convert to pop rD, [rA].  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000007
operator|)
operator|==
literal|0x0e000000
condition|)
block|{
comment|/* rs =  r0-r7, offset = 4 */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x18
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xfff
operator|)
operator|==
literal|4
operator|)
condition|)
block|{
comment|/* Relax to pophi.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x0000200a
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
literal|1
operator|<<
literal|7
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
comment|/* Relax to pop.  */
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x0000200a
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0
operator|<<
literal|7
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* ld/sw rD, [rA]+ convert to ld/sw rD, [rA, 0]+.  */
else|else
block|{
name|SET_INSN_ERROR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
name|pre_inc
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|_SIMM12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|(
literal|1
operator|<<
name|score_df_range
index|[
name|_SIMM12
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
name|pre_inc
index|]
operator|.
name|value
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|<<
literal|3
expr_stmt|;
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
return|return;
block|}
block|}
comment|/* ld/sw rD, [rA] convert to ld/sw rD, [rA, simm15].  */
else|else
block|{
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
name|LDST_NOUPDATE
index|]
operator|.
name|value
expr_stmt|;
comment|/* lbu rd, [rs] -> lbu! rd, [rs]  */
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_LBU
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_LBU
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_LH
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_LH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_LW
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_LW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_SB
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_SB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_SH
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_SH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldst_idx
operator|==
name|INSN_SW
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
name|INSN16_SW
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
comment|/* lw/lh/lbu/sw/sh/sb, offset = 0, relax to 16 bit instruction.  */
if|if
condition|(
operator|(
name|ldst_idx
operator|==
name|INSN_LBU
operator|)
operator|||
operator|(
name|ldst_idx
operator|==
name|INSN_LH
operator|)
operator|||
operator|(
name|ldst_idx
operator|==
name|INSN_LW
operator|)
operator|||
operator|(
name|ldst_idx
operator|==
name|INSN_SB
operator|)
operator|||
operator|(
name|ldst_idx
operator|==
name|INSN_SH
operator|)
operator|||
operator|(
name|ldst_idx
operator|==
name|INSN_SW
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
literal|2
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
comment|/* ld/sw rD, [rA, simm15]    ld/sw rD, [rA, simm12]+.  */
else|else
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* ld/sw rD, [rA, simm12]+.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|conflict_reg
condition|)
block|{
name|unsigned
name|int
name|ldst_func
init|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
decl_stmt|;
if|if
condition|(
operator|(
name|ldst_func
operator|==
name|INSN_LH
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LHU
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LW
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LB
operator|)
operator|||
operator|(
name|ldst_func
operator|==
name|INSN_LBU
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register same as write-back base"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|value
decl_stmt|;
name|unsigned
name|int
name|data_type
decl_stmt|;
if|if
condition|(
name|pre_inc
operator|==
literal|1
condition|)
name|data_type
operator|=
name|_SIMM12
expr_stmt|;
else|else
name|data_type
operator|=
name|_SIMM15
expr_stmt|;
name|dataptr
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dataptr
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|dataptr
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM16_LA
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_HI16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_VALUE_LO16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM16
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM15
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM14
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM4
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM8
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_1
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM5_RSHIFT_2
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_SIMM14_NEG
operator|)
operator|&&
operator|(
name|data_type
operator|!=
name|_IMM10_RSHIFT_2
operator|)
condition|)
block|{
name|data_type
operator|+=
literal|24
expr_stmt|;
block|}
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|data_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
if|if
condition|(
name|data_type
operator|<
literal|30
condition|)
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|,
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|err_msg
argument_list|,
name|_
argument_list|(
literal|"invalid constant: %d bit expression not in range %d..%d"
argument_list|)
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|bits
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|range
index|[
literal|0
index|]
argument_list|,
name|score_df_range
index|[
name|data_type
operator|-
literal|24
index|]
operator|.
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|err_msg
expr_stmt|;
return|return;
block|}
name|value
operator|&=
operator|(
literal|1
operator|<<
name|score_df_range
index|[
name|data_type
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
name|pre_inc
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|pre_inc
operator|==
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|value
operator|<<
literal|3
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
comment|/* lw rD, [rA, simm15]  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x20000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, lw -> lw!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, lw -> lwp!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|128
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7000
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* sw rD, [rA, simm15]  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x28000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, sw -> sw!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, sw -> swp!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|128
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7004
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* sw rD, [rA, simm15]+    sw pre.  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000007
operator|)
operator|==
literal|0x06000004
condition|)
block|{
comment|/* rA is in [r0 - r7], and simm15 = -4.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x18
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0xfff
operator|)
operator|==
literal|0xffc
operator|)
condition|)
block|{
comment|/* sw -> pushhi!.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0x10
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x0000200e
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
literal|1
operator|<<
literal|7
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* sw -> push!.  */
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x0000200e
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0
operator|<<
literal|7
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* lh rD, [rA, simm15]  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x22000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, lh -> lh!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, lh -> lhp!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|64
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7001
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|>>
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* sh rD, [rA, simm15]  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x2a000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, sh -> sh!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, sh -> shp!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|64
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7005
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|>>
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* lbu rD, [rA, simm15]  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x2c000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, lbu -> lbu!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, lbu -> lbup!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|32
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7003
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
comment|/* sb rD, [rA, simm15]  */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e000000
operator|)
operator|==
literal|0x2e000000
condition|)
block|{
comment|/* Both rD and rA are in [r0 - r15].  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* simm15 = 0, sb -> sb!.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* rA = r2, sb -> sb!.  */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<
literal|32
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x7007
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7fff
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
comment|/* FIXME: may set error, for there is no ld/sw rD, [rA, label] */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle cache.  */
end_comment

begin_function
specifier|static
name|void
name|do_cache
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|int
name|cache_op
decl_stmt|;
name|cache_op
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0x1F
expr_stmt|;
name|sprintf
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"cache %d"
argument_list|,
name|cache_op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* cache op, [rA]  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|SET_INSN_ERROR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
block|}
comment|/* cache op, [rA, simm15]  */
else|else
block|{
if|if
condition|(
name|exp_ldst_offset
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|,
name|_SIMM15
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_crdcrscrsimm5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|strbak
decl_stmt|;
name|strbak
operator|=
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE_CR
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE_CR
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|10
argument_list|,
name|REG_TYPE_SCORE_CR
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|str
operator|=
name|strbak
expr_stmt|;
comment|/* cop1 cop_code20.  */
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
name|_IMM20
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
name|_IMM5
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle ldc/stc.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldst_cop
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE_CR
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|exp_ldst_offset
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
name|_IMM10_RSHIFT_2
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do16_ldst_insn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|15
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle lbup!/lhp!/ldiu!/lwp!/sbp!/shp!/swp!.  */
end_comment

begin_function
specifier|static
name|void
name|do16_ldst_imm_insn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|data_exp
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|reg_rd
decl_stmt|;
name|char
modifier|*
name|dataptr
init|=
name|NULL
decl_stmt|,
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|assign_data
init|=
operator|(
name|int
operator|)
name|FAIL
decl_stmt|;
name|unsigned
name|int
name|ldst_func
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_rd
operator|=
name|reglow_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|dataptr
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|dataptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|dataptr
operator|!=
literal|'|'
operator|)
operator|&&
operator|(
name|cnt
operator|<=
name|MAX_LITERAL_POOL_SIZE
operator|)
condition|)
block|{
name|data_exp
index|[
name|cnt
index|]
operator|=
operator|*
name|dataptr
expr_stmt|;
name|dataptr
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|data_exp
index|[
name|cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|=
operator|&
name|data_exp
index|[
literal|0
index|]
expr_stmt|;
name|str
operator|=
name|dataptr
expr_stmt|;
name|ldst_func
operator|=
name|inst
operator|.
name|instruction
operator|&
name|LDST16_RI_MASK
expr_stmt|;
if|if
condition|(
name|ldst_func
operator|==
name|N16_LIU
condition|)
name|assign_data
operator|=
name|exp_ldst_offset
argument_list|(
operator|&
name|pp
argument_list|,
literal|0
argument_list|,
name|_IMM8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ldst_func
operator|==
name|N16_LHP
operator|||
name|ldst_func
operator|==
name|N16_SHP
condition|)
name|assign_data
operator|=
name|exp_ldst_offset
argument_list|(
operator|&
name|pp
argument_list|,
literal|3
argument_list|,
name|_IMM5_RSHIFT_1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ldst_func
operator|==
name|N16_LWP
operator|||
name|ldst_func
operator|==
name|N16_SWP
condition|)
name|assign_data
operator|=
name|exp_ldst_offset
argument_list|(
operator|&
name|pp
argument_list|,
literal|3
argument_list|,
name|_IMM5_RSHIFT_2
argument_list|)
expr_stmt|;
else|else
name|assign_data
operator|=
name|exp_ldst_offset
argument_list|(
operator|&
name|pp
argument_list|,
literal|3
argument_list|,
name|_IMM5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|assign_data
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|pp
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
else|else
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7000
operator|)
operator|==
name|N16_LIU
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_LHP
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_SHP
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator||
literal|2
operator|<<
literal|15
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_LWP
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_SWP
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator||
literal|2
operator|<<
literal|15
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_LBUP
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x7007
operator|)
operator|==
name|N16_SBP
operator|)
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator||
literal|2
operator|<<
literal|15
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do16_push_pop
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|int
name|H_bit_mask
init|=
literal|0
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
return|return;
if|if
condition|(
name|reg_rd
operator|>=
literal|16
condition|)
name|H_bit_mask
operator|=
literal|1
expr_stmt|;
comment|/* reg_required_here will change bit 12 of opcode, so we must restore bit 12.  */
name|inst
operator|.
name|instruction
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|H_bit_mask
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
elseif|else
if|if
condition|(
name|reg
operator|>
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"base register nums are over 3 bit"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|str
operator|++
operator|!=
literal|']'
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* pop! */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf
operator|)
operator|==
literal|0xa
condition|)
block|{
if|if
condition|(
name|H_bit_mask
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator||
literal|0x10
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
literal|4
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
literal|4
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
comment|/* push! */
else|else
block|{
if|if
condition|(
name|H_bit_mask
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator||
literal|0x10
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
operator|(
operator|-
literal|4
operator|)
operator|&
literal|0xfff
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
operator|(
operator|-
literal|4
operator|)
operator|&
literal|0xfff
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle lcb/lcw/lce/scb/scw/sce.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldst_unalign
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|conflict_reg
decl_stmt|;
if|if
condition|(
name|university_version
operator|==
literal|1
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|ERR_FOR_SCORE5U_ATOMIC
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* lcb/scb [rA]+.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'+'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing +"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
comment|/* lcw/lce/scb/sce rD, [rA]+.  */
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
comment|/* Conflicts can occur on stores as well as loads.  */
name|conflict_reg
operator|=
operator|(
name|conflict_reg
operator|==
name|reg
operator|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|']'
condition|)
block|{
name|unsigned
name|int
name|ldst_func
init|=
name|inst
operator|.
name|instruction
operator|&
name|LDST_UNALIGN_MASK
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|ldst_func
operator|&
name|UA_LCE
operator|)
operator|||
operator|(
name|ldst_func
operator|&
name|UA_LCW
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing +"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle alw/asw.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldst_atomic
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|university_version
operator|==
literal|1
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|ERR_FOR_SCORE5U_ATOMIC
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|15
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|build_relax_frag
parameter_list|(
name|struct
name|score_it
name|fix_insts
index|[
name|RELAX_INST_NUM
index|]
parameter_list|,
name|int
name|fix_num
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|score_it
name|var_insts
index|[
name|RELAX_INST_NUM
index|]
parameter_list|,
name|int
name|var_num
parameter_list|,
name|symbolS
modifier|*
name|add_symbol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fixS
modifier|*
name|fixp
init|=
name|NULL
decl_stmt|;
name|fixS
modifier|*
name|cur_fixp
init|=
name|NULL
decl_stmt|;
name|long
name|where
decl_stmt|;
name|struct
name|score_it
name|inst_main
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inst_main
argument_list|,
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust instruction opcode and to be relaxed instruction opcode.  */
name|inst_main
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|inst_main
operator|.
name|instruction
argument_list|,
name|GET_INSN_CLASS
argument_list|(
name|inst_main
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|inst_main
operator|.
name|type
operator|=
name|Insn_PIC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var_num
condition|;
name|i
operator|++
control|)
block|{
name|inst_main
operator|.
name|relax_size
operator|+=
name|var_insts
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|var_insts
index|[
name|i
index|]
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|var_insts
index|[
name|i
index|]
operator|.
name|instruction
argument_list|,
name|GET_INSN_CLASS
argument_list|(
name|var_insts
index|[
name|i
index|]
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check data dependency.  */
name|handle_dependency
argument_list|(
operator|&
name|inst_main
argument_list|)
expr_stmt|;
comment|/* Start a new frag if frag_now is not empty.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frag_grow
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Write fr_fix part.  */
name|p
operator|=
name|frag_more
argument_list|(
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|inst_main
operator|.
name|instruction
argument_list|,
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_main
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fixp
operator|=
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst_main
operator|.
name|size
argument_list|,
operator|&
name|inst_main
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|inst_main
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst_main
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|fixp
operator|=
name|fixp
expr_stmt|;
name|cur_fixp
operator|=
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|fixp
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|where
operator|=
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|inst_main
operator|.
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|where
operator|+=
name|var_insts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|var_insts
index|[
name|i
index|]
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|fixp
operator|=
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|var_insts
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
name|var_insts
index|[
name|i
index|]
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|var_insts
index|[
name|i
index|]
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|var_insts
index|[
name|i
index|]
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
condition|)
block|{
if|if
condition|(
name|cur_fixp
condition|)
block|{
name|cur_fixp
operator|->
name|fx_next
operator|=
name|fixp
expr_stmt|;
name|cur_fixp
operator|=
name|cur_fixp
operator|->
name|fx_next
expr_stmt|;
block|}
else|else
block|{
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|fixp
operator|=
name|fixp
expr_stmt|;
name|cur_fixp
operator|=
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|fixp
expr_stmt|;
block|}
block|}
block|}
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|inst_main
operator|.
name|relax_size
operator|+
name|RELAX_PAD_BYTE
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|inst_main
operator|.
name|size
argument_list|,
name|inst_main
operator|.
name|relax_size
argument_list|,
name|inst_main
operator|.
name|type
argument_list|,
literal|0
argument_list|,
name|inst_main
operator|.
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|add_symbol
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write fr_var part.      no calling gen_insn_frag, no fixS will be generated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var_num
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|var_insts
index|[
name|i
index|]
operator|.
name|instruction
argument_list|,
name|var_insts
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|var_insts
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a relax frag for la instruction when generating PIC,    external symbol first and local symbol second.  */
end_comment

begin_function
specifier|static
name|void
name|build_la_pic
parameter_list|(
name|int
name|reg_rd
parameter_list|,
name|expressionS
name|exp
parameter_list|)
block|{
name|symbolS
modifier|*
name|add_symbol
init|=
name|exp
operator|.
name|X_add_symbol
decl_stmt|;
name|offsetT
name|add_number
init|=
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|struct
name|score_it
name|fix_insts
index|[
name|RELAX_INST_NUM
index|]
decl_stmt|;
name|struct
name|score_it
name|var_insts
index|[
name|RELAX_INST_NUM
index|]
decl_stmt|;
name|int
name|fix_num
init|=
literal|0
decl_stmt|;
name|int
name|var_num
init|=
literal|0
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|r1_bak
decl_stmt|;
name|r1_bak
operator|=
name|nor1
expr_stmt|;
name|nor1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add_number
operator|==
literal|0
condition|)
block|{
name|fix_num
operator|=
literal|1
expr_stmt|;
name|var_num
operator|=
literal|2
expr_stmt|;
comment|/* For an external symbol, only one insn is generated;           For a local symbol, two insns are generated.  */
comment|/* Fix part          For an external symbol: lw rD,<sym>($gp)                                  (BFD_RELOC_SCORE_GOT15 or BFD_RELOC_SCORE_CALL15)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"lw_pic r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|reg_rd
operator|==
name|PIC_CALL_REG
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_CALL15
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Var part 	 For a local symbol :          lw rD,<sym>($gp)    (BFD_RELOC_SCORE_GOT15) 	 addi rD,<sym>       (BFD_RELOC_GOT_LO16) */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_GOT15
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"addi_s_pic r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|1
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|build_relax_frag
argument_list|(
name|fix_insts
argument_list|,
name|fix_num
argument_list|,
name|var_insts
argument_list|,
name|var_num
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|add_number
operator|<=
literal|0x7fff
condition|)
block|{
comment|/* Insn 1: lw rD,<sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"lw_pic r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Insn 2  */
name|fix_num
operator|=
literal|1
expr_stmt|;
name|var_num
operator|=
literal|1
expr_stmt|;
comment|/* Fix part          For an external symbol: addi rD,<constant> */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"addi r%d, %d"
argument_list|,
name|reg_rd
argument_list|,
operator|(
name|int
operator|)
name|add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Var part  	 For a local symbol: addi rD,<sym>+<constant>    (BFD_RELOC_GOT_LO16)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"addi_s_pic r%d, %s + %d"
argument_list|,
name|reg_rd
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|build_relax_frag
argument_list|(
name|fix_insts
argument_list|,
name|fix_num
argument_list|,
name|var_insts
argument_list|,
name|var_num
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|hi
init|=
operator|(
name|add_number
operator|>>
literal|16
operator|)
operator|&
literal|0x0000FFFF
decl_stmt|;
name|int
name|lo
init|=
name|add_number
operator|&
literal|0x0000FFFF
decl_stmt|;
comment|/* Insn 1: lw rD,<sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"lw_pic r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Insn 2  */
name|fix_num
operator|=
literal|1
expr_stmt|;
name|var_num
operator|=
literal|1
expr_stmt|;
comment|/* Fix part 	 For an external symbol: ldis r1, HI%<constant>  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"ldis r1, %d"
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Var part 	 For a local symbol: ldis r1, HI%<constant>          but, if lo is outof 16 bit, make hi plus 1  */
if|if
condition|(
operator|(
name|lo
operator|<
operator|-
literal|0x8000
operator|)
operator|||
operator|(
name|lo
operator|>
literal|0x7fff
operator|)
condition|)
block|{
name|hi
operator|+=
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"ldis_pic r1, %d"
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|build_relax_frag
argument_list|(
name|fix_insts
argument_list|,
name|fix_num
argument_list|,
name|var_insts
argument_list|,
name|var_num
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
comment|/* Insn 3  */
name|fix_num
operator|=
literal|1
expr_stmt|;
name|var_num
operator|=
literal|1
expr_stmt|;
comment|/* Fix part 	 For an external symbol: ori r1, LO%<constant>  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"ori r1, %d"
argument_list|,
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Var part   	 For a local symbol: addi r1,<sym>+LO%<constant>    (BFD_RELOC_GOT_LO16)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"addi_u_pic r1, %s + %d"
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|,
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|build_relax_frag
argument_list|(
name|fix_insts
argument_list|,
name|fix_num
argument_list|,
name|var_insts
argument_list|,
name|var_num
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
comment|/* Insn 4: add rD, rD, r1  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"add r%d, r%d, r1"
argument_list|,
name|reg_rd
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|nor1
operator|=
name|r1_bak
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle la.  */
end_comment

begin_function
specifier|static
name|void
name|do_macro_la_rdi32
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|keep_data
init|=
name|str
decl_stmt|;
comment|/* la rd, simm16.  */
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM16_LA
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* la rd, imm32 or la rd, label.  */
else|else
block|{
name|SET_INSN_ERROR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|str
operator|=
name|keep_data
expr_stmt|;
if|if
condition|(
operator|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_VALUE_HI16
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|score_pic
operator|==
name|NO_PIC
operator|)
operator|||
operator|(
operator|!
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"ld_i32hi r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|keep_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"ld_i32lo r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|keep_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|assert
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|build_la_pic
argument_list|(
name|reg_rd
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle li.  */
end_comment

begin_function
specifier|static
name|void
name|do_macro_li_rdi32
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|keep_data
init|=
name|str
decl_stmt|;
comment|/* li rd, simm16.  */
if|if
condition|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_SIMM16_LA
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* li rd, imm32.  */
else|else
block|{
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|str
operator|=
name|keep_data
expr_stmt|;
if|if
condition|(
operator|(
name|data_op2
argument_list|(
operator|&
name|str
argument_list|,
literal|1
argument_list|,
name|_VALUE_HI16
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"li rd label isn't correct instruction form"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"ld_i32hi r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|keep_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
else|else
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"ld_i32lo r%d, %s"
argument_list|,
name|reg_rd
argument_list|,
name|keep_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle mul/mulu/div/divu/rem/remu.  */
end_comment

begin_function
specifier|static
name|void
name|do_macro_mul_rdrsrs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|int
name|reg_rs1
decl_stmt|;
name|int
name|reg_rs2
decl_stmt|;
name|char
modifier|*
name|backupstr
decl_stmt|;
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|university_version
operator|==
literal|1
condition|)
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|ERR_FOR_SCORE5U_MUL_DIV
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|append_str
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|backupstr
operator|=
name|append_str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|backupstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|backupstr
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
operator|(
name|reg_rs1
operator|=
name|reg_required_here
argument_list|(
operator|&
name|backupstr
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
comment|/* rem/remu rA, rB is error format.  */
if|if
condition|(
name|strcmp
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"rem"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"remu"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SET_INSN_ERROR
argument_list|(
name|BAD_ARGS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_INSN_ERROR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|do_rsrs
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|SET_INSN_ERROR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_rs2
operator|=
name|reg_required_here
argument_list|(
operator|&
name|backupstr
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|backupstr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|char
name|append_str1
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"rem"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"mul r%d, r%d"
argument_list|,
name|reg_rs1
argument_list|,
name|reg_rs2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str1
argument_list|,
literal|"mfceh  r%d"
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|inst
operator|.
name|name
argument_list|,
literal|"remu"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"mulu r%d, r%d"
argument_list|,
name|reg_rs1
argument_list|,
name|reg_rs2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str1
argument_list|,
literal|"mfceh  r%d"
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"%s r%d, r%d"
argument_list|,
name|inst
operator|.
name|name
argument_list|,
name|reg_rs1
argument_list|,
name|reg_rs2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str1
argument_list|,
literal|"mfcel  r%d"
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
block|}
comment|/* Output mul/mulu or div/divu or rem/remu.  */
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Output mfcel or mfceh.  */
if|if
condition|(
name|append_insn
argument_list|(
name|append_str1
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exp_macro_ldst_abs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|char
modifier|*
name|backupstr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|char
name|append_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
name|verifystr
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|struct
name|score_it
name|inst_backup
decl_stmt|;
name|int
name|r1_bak
init|=
literal|0
decl_stmt|;
name|r1_bak
operator|=
name|nor1
expr_stmt|;
name|nor1
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inst_backup
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|verifystr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|backupstr
operator|=
name|verifystr
expr_stmt|;
name|skip_whitespace
argument_list|(
name|backupstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|backupstr
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|tmp
operator|=
name|backupstr
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|backupstr
operator|=
name|tmp
expr_stmt|;
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|"li r1  %s"
argument_list|,
name|backupstr
argument_list|)
expr_stmt|;
name|append_insn
argument_list|(
name|append_str
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inst
argument_list|,
operator|&
name|inst_backup
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str
argument_list|,
literal|" r%d, [r1,0]"
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
name|do_ldst_insn
argument_list|(
name|append_str
argument_list|)
expr_stmt|;
name|nor1
operator|=
name|r1_bak
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nopic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|before_relaxing
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
operator|&&
name|g_switch_value
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
comment|/* Find out whether this symbol can be referenced off the $gp          register.  It can be if it is smaller than the -G size or if          it is in the .sdata or .sbss section.  Certain symbols can          not be referenced off the $gp, although it appears as though          they can.  */
name|symname
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"eprol"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"etext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"edata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_ftext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
name|GP_DISP_LABEL
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
literal|0
comment|/* We must defer this decision until after the whole file has been read,          since there might be a .extern after the first use of this symbol.  */
operator|||
operator|(
name|before_relaxing
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|<=
name|g_switch_value
operator|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|segname
operator|=
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sbss"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".sdata."
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".gnu.linkonce.s."
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
comment|/* We are not optimizing for the $gp register.  */
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Build a relax frag for lw/st instruction when generating PIC,    external symbol first and local symbol second.  */
end_comment

begin_function
specifier|static
name|void
name|build_lwst_pic
parameter_list|(
name|int
name|reg_rd
parameter_list|,
name|expressionS
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|insn_name
parameter_list|)
block|{
name|symbolS
modifier|*
name|add_symbol
init|=
name|exp
operator|.
name|X_add_symbol
decl_stmt|;
name|int
name|add_number
init|=
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|struct
name|score_it
name|fix_insts
index|[
name|RELAX_INST_NUM
index|]
decl_stmt|;
name|struct
name|score_it
name|var_insts
index|[
name|RELAX_INST_NUM
index|]
decl_stmt|;
name|int
name|fix_num
init|=
literal|0
decl_stmt|;
name|int
name|var_num
init|=
literal|0
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|int
name|r1_bak
decl_stmt|;
name|r1_bak
operator|=
name|nor1
expr_stmt|;
name|nor1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|add_number
operator|==
literal|0
operator|)
operator|||
operator|(
name|add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|add_number
operator|<=
literal|0x7fff
operator|)
condition|)
block|{
name|fix_num
operator|=
literal|1
expr_stmt|;
name|var_num
operator|=
literal|2
expr_stmt|;
comment|/* For an external symbol, two insns are generated;          For a local symbol, three insns are generated.  */
comment|/* Fix part          For an external symbol: lw rD,<sym>($gp)                                  (BFD_RELOC_SCORE_GOT15)  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"lw_pic r1, %s"
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|fix_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Var part 	 For a local symbol :          lw rD,<sym>($gp)    (BFD_RELOC_SCORE_GOT15) 	 addi rD,<sym>       (BFD_RELOC_GOT_LO16) */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_GOT15
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|0
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"addi_s_pic r1, %s"
argument_list|,
name|add_symbol
operator|->
name|bsym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|var_insts
index|[
literal|1
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|build_relax_frag
argument_list|(
name|fix_insts
argument_list|,
name|fix_num
argument_list|,
name|var_insts
argument_list|,
name|var_num
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
comment|/* Insn 2 or Insn 3: lw/st rD, [r1, constant]  */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s r%d, [r1, %d]"
argument_list|,
name|insn_name
argument_list|,
name|reg_rd
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|tmp
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nor1
operator|=
name|r1_bak
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_macro_ldst_label
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ldst_gp_p
init|=
literal|0
decl_stmt|;
name|int
name|reg_rd
decl_stmt|;
name|int
name|r1_bak
decl_stmt|;
name|char
modifier|*
name|backup_str
decl_stmt|;
name|char
modifier|*
name|label_str
decl_stmt|;
name|char
modifier|*
name|absolute_value
decl_stmt|;
name|char
name|append_str
index|[
literal|3
index|]
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
name|verifystr
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|struct
name|score_it
name|inst_backup
decl_stmt|;
name|struct
name|score_it
name|inst_expand
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|score_it
name|inst_main
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inst_backup
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|verifystr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|backup_str
operator|=
name|verifystr
expr_stmt|;
name|skip_whitespace
argument_list|(
name|backup_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|backup_str
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|backup_str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|label_str
operator|=
name|backup_str
expr_stmt|;
comment|/* Ld/st rD, [rA, imm]      ld/st rD, [rA]+, imm      ld/st rD, [rA, imm]+.  */
if|if
condition|(
operator|*
name|backup_str
operator|==
literal|'['
condition|)
block|{
name|inst
operator|.
name|type
operator|=
name|Rd_rvalueRs_preSI12
expr_stmt|;
name|do_ldst_insn
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ld/st rD, imm.  */
name|absolute_value
operator|=
name|backup_str
expr_stmt|;
name|inst
operator|.
name|type
operator|=
name|Rd_rvalueRs_SI15
expr_stmt|;
if|if
condition|(
operator|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|backup_str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|_VALUE
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|backup_str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|inst
argument_list|,
operator|&
name|inst_backup
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|exp_macro_ldst_abs
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Ld/st rD, label.  */
name|inst
operator|.
name|type
operator|=
name|Rd_rvalueRs_SI15
expr_stmt|;
name|backup_str
operator|=
name|absolute_value
expr_stmt|;
if|if
condition|(
operator|(
name|data_op2
argument_list|(
operator|&
name|backup_str
argument_list|,
literal|1
argument_list|,
name|_GP_IMM15
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|backup_str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|score_pic
operator|==
name|PIC
condition|)
block|{
name|int
name|ldst_idx
init|=
literal|0
decl_stmt|;
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|build_lwst_pic
argument_list|(
name|reg_rd
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
literal|0
index|]
operator|.
name|template
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<=
literal|0x3fff
operator|)
operator|&&
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x4000
operator|)
operator|&&
operator|(
operator|!
name|nopic_need_relax
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|int
name|ldst_idx
init|=
literal|0
decl_stmt|;
comment|/* Assign the real opcode.  */
name|ldst_idx
operator|=
name|inst
operator|.
name|instruction
operator|&
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|OPC_PSEUDOLDST_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|score_ldst_insns
index|[
name|ldst_idx
operator|*
literal|3
operator|+
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|reg_rd
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|GP
operator|<<
literal|15
expr_stmt|;
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|0
expr_stmt|;
name|ldst_gp_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Backup inst.  */
name|memcpy
argument_list|(
operator|&
name|inst_main
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
name|r1_bak
operator|=
name|nor1
expr_stmt|;
name|nor1
operator|=
literal|0
expr_stmt|;
comment|/* Determine which instructions should be output.  */
name|sprintf
argument_list|(
name|append_str
index|[
literal|0
index|]
argument_list|,
literal|"ld_i32hi r1, %s"
argument_list|,
name|label_str
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str
index|[
literal|1
index|]
argument_list|,
literal|"ld_i32lo r1, %s"
argument_list|,
name|label_str
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|append_str
index|[
literal|2
index|]
argument_list|,
literal|"%s r%d, [r1, 0]"
argument_list|,
name|inst_backup
operator|.
name|name
argument_list|,
name|reg_rd
argument_list|)
expr_stmt|;
comment|/* Generate three instructions.      la r1, label      ld/st rd, [r1, 0]  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|append_insn
argument_list|(
name|append_str
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|inst_expand
index|[
name|i
index|]
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_it
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldst_gp_p
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Adjust instruction opcode and to be relaxed instruction opcode.  */
name|inst_main
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|inst_main
operator|.
name|instruction
argument_list|,
name|GET_INSN_CLASS
argument_list|(
name|inst_main
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|inst_main
operator|.
name|relax_size
operator|=
name|inst_expand
index|[
literal|0
index|]
operator|.
name|size
operator|+
name|inst_expand
index|[
literal|1
index|]
operator|.
name|size
operator|+
name|inst_expand
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|inst_main
operator|.
name|type
operator|=
name|Insn_GP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|inst_expand
index|[
name|i
index|]
operator|.
name|instruction
operator|=
name|adjust_paritybit
argument_list|(
name|inst_expand
index|[
name|i
index|]
operator|.
name|instruction
argument_list|,
name|GET_INSN_CLASS
argument_list|(
name|inst_expand
index|[
name|i
index|]
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check data dependency.  */
name|handle_dependency
argument_list|(
operator|&
name|inst_main
argument_list|)
expr_stmt|;
comment|/* Start a new frag if frag_now is not empty.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frag_grow
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Write fr_fix part.  */
name|p
operator|=
name|frag_more
argument_list|(
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|inst_main
operator|.
name|instruction
argument_list|,
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_main
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|fix_new_score
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst_main
operator|.
name|size
argument_list|,
operator|&
name|inst_main
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|inst_main
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst_main
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|inst_main
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GP instruction can not do optimization, only can do relax between          1 instruction and 3 instructions.  */
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|inst_main
operator|.
name|relax_size
operator|+
name|RELAX_PAD_BYTE
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|inst_main
operator|.
name|size
argument_list|,
name|inst_main
operator|.
name|relax_size
argument_list|,
name|inst_main
operator|.
name|type
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|,
name|inst_main
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write fr_var part.          no calling gen_insn_frag, no fixS will be generated.  */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|inst_expand
index|[
literal|0
index|]
operator|.
name|instruction
argument_list|,
name|inst_expand
index|[
literal|0
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|inst_expand
index|[
literal|0
index|]
operator|.
name|size
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|inst_expand
index|[
literal|1
index|]
operator|.
name|instruction
argument_list|,
name|inst_expand
index|[
literal|1
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|inst_expand
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|inst_expand
index|[
literal|2
index|]
operator|.
name|instruction
argument_list|,
name|inst_expand
index|[
literal|2
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gen_insn_frag
argument_list|(
operator|&
name|inst_expand
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gen_insn_frag
argument_list|(
operator|&
name|inst_expand
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gen_insn_frag
argument_list|(
operator|&
name|inst_expand
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|nor1
operator|=
name|r1_bak
expr_stmt|;
comment|/* Set bwarn as -1, so macro instruction itself will not be generated frag.  */
name|inst
operator|.
name|bwarn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_lw_pic
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|reg_rd
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
operator|||
operator|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|GP
operator|<<
literal|15
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_GOT15
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_empty
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|str
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|university_version
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e0003ff
operator|)
operator|==
literal|0x0c000004
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e0003ff
operator|)
operator|==
literal|0x0c000024
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e0003ff
operator|)
operator|==
literal|0x0c000044
operator|)
operator|||
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x3e0003ff
operator|)
operator|==
literal|0x0c000064
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|ERR_FOR_SCORE5U_MMU
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|type
operator|==
name|NO_OPD
condition|)
block|{
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_jump
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lacking label  "
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0xff000000
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant: 25 bit expression not in range -2^24..2^24"
argument_list|)
expr_stmt|;
return|return;
block|}
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_JMP
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do16_jump
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lacking label  "
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xfffff800
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xfffff800
operator|)
operator|!=
literal|0xfffff800
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant: 12 bit expression not in range -2^11..2^11"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE16_JMP
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_branch
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|unsigned
name|long
name|abs_value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lacking label  "
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0xff000000
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant: 20 bit expression not in range -2^19..2^19"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
comment|/* Branch 32  offset field : 20 bit, 16 bit branch offset field : 8 bit.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x3fe
operator|)
operator||
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffc00
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* Compute 16 bit branch instruction.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|relax_inst
operator|!=
literal|0x8000
operator|)
operator|&&
operator|(
name|abs_value
operator|&
literal|0xfffffe00
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|10
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_inst
operator||=
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|inst
operator|.
name|relax_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|relax_inst
operator|=
literal|0x8000
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do16_branch
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|end_of_line
argument_list|(
name|str
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lacking label"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0xffffff00
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant: 9 bit expression not in range -2^8..2^8"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_SCORE16_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Iterate over the base tables to create the instruction patterns.  */
end_comment

begin_function
specifier|static
name|void
name|build_score_ops_hsh
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|obstack
name|insn_obstack
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|insn_obstack
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|score_insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|asm_opcode
modifier|*
name|insn
init|=
name|score_insns
operator|+
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|insn
operator|->
name|template
argument_list|)
decl_stmt|;
name|struct
name|asm_opcode
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
name|new
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|insn_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|insn_obstack
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|template
argument_list|,
name|insn
operator|->
name|template
argument_list|)
expr_stmt|;
name|new
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|new
operator|->
name|parms
operator|=
name|insn
operator|->
name|parms
expr_stmt|;
name|new
operator|->
name|value
operator|=
name|insn
operator|->
name|value
expr_stmt|;
name|new
operator|->
name|relax_value
operator|=
name|insn
operator|->
name|relax_value
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|insn
operator|->
name|type
expr_stmt|;
name|new
operator|->
name|bitmask
operator|=
name|insn
operator|->
name|bitmask
expr_stmt|;
name|hash_insert
argument_list|(
name|score_ops_hsh
argument_list|,
name|new
operator|->
name|template
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|build_dependency_insn_hsh
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|obstack
name|dependency_obstack
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|dependency_obstack
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|insn_to_dependency_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|insn_to_dependency_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|insn_to_dependency
modifier|*
name|tmp
init|=
name|insn_to_dependency_table
operator|+
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|tmp
operator|->
name|insn_name
argument_list|)
decl_stmt|;
name|struct
name|insn_to_dependency
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|dependency_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|insn_to_dependency
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|insn_name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|dependency_obstack
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|insn_name
argument_list|,
name|tmp
operator|->
name|insn_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|tmp
operator|->
name|type
expr_stmt|;
name|hash_insert
argument_list|(
name|dependency_insn_hsh
argument_list|,
name|new
operator|->
name|insn_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turn an integer of n bytes (in val) into a stream of bytes appropriate    for use in the a.out file, and stores them in the array pointed to by buf.    This knows about the endian-ness of the target machine and does    THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)    2 (short) and 4 (long)  Floating numbers are put out as a series of    LITTLENUMS (shorts, here at least).  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|valueT
name|md_chars_to_number
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|valueT
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
operator|*
name|where
operator|++
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
name|where
index|[
name|n
index|]
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.     Note that fp constants aren't represent in the normal way on the ARM.    In big endian mode, things are as expected.  However, in little endian    mode fp constants are big-endian word-wise, and little-endian byte-wise    within the words.  For example, (double) 1.1 in big endian mode is    the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is    the byte sequence 99 99 f1 3f 9a 99 99 99.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given symbol should be considered local for PIC.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|pic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|segtype
parameter_list|)
block|{
name|asection
modifier|*
name|symsec
decl_stmt|;
name|bfd_boolean
name|linkonce
decl_stmt|;
comment|/* Handle the case of a symbol equated to another symbol.  */
while|while
condition|(
name|symbol_equated_reloc_p
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* It's possible to get a loop here in a badly written 	 program.  */
name|n
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|sym
condition|)
break|break;
name|sym
operator|=
name|n
expr_stmt|;
block|}
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */
name|linkonce
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|symsec
operator|!=
name|segtype
operator|&&
operator|!
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|symsec
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
comment|/* The GNU toolchain uses an extension for ELF: a section 	  beginning with the magic string .gnu.linkonce is a linkonce 	  section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|symsec
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* This must duplicate the test in adjust_reloc_syms.  */
return|return
operator|(
name|symsec
operator|!=
operator|&
name|bfd_und_section
operator|&&
name|symsec
operator|!=
operator|&
name|bfd_abs_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|symsec
argument_list|)
operator|&&
operator|!
name|linkonce
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* A global or weak symbol is treated as external.  */
operator|&&
operator|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
operator|!
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|judge_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|int
name|change
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|score_pic
operator|==
name|NO_PIC
condition|)
name|change
operator|=
name|nopic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|change
operator|=
name|pic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|==
literal|1
condition|)
block|{
comment|/* Only at the first time determining whether GP instruction relax should be done,          return the difference between insntruction size and instruction relax size.  */
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
operator|==
name|NULL
condition|)
block|{
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_opcode
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|RELAX_RELOC1
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|-
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* In this function, we determine whether GP instruction should do relaxation,    for the label being against was known now.    Doing this here but not in md_relax_frag() can induce iteration times    in stage of doing relax.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|(
name|RELAX_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|Insn_GP
operator|)
operator|||
operator|(
name|RELAX_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|Insn_PIC
operator|)
condition|)
return|return
name|judge_size_before_relax
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|b32_relax_to_b16
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
name|int
name|grows
init|=
literal|0
decl_stmt|;
name|int
name|relaxable_p
init|=
literal|0
decl_stmt|;
name|int
name|old
decl_stmt|;
name|int
name|new
decl_stmt|;
name|int
name|frag_addr
init|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|insn_addr
decl_stmt|;
name|addressT
name|symbol_address
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|s
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|unsigned
name|long
name|abs_value
decl_stmt|;
comment|/* FIXME : here may be able to modify better .      I don't know how to get the fragp's section ,      so in relax stage , it may be wrong to calculate the symbol's offset when the frag's section      is different from the symbol's.  */
name|old
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|new
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|relaxable_p
operator|=
name|RELAX_OPT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|s
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
comment|/* b/bl immediate  */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|frag_addr
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|bsym
operator|!=
literal|0
condition|)
name|symbol_address
operator|=
operator|(
name|addressT
operator|)
name|s
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
name|value
operator|=
name|md_chars_to_number
argument_list|(
name|fragp
operator|->
name|fr_literal
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* b 32's offset : 20 bit, b 16's tolerate field : 0xff.  */
name|offset
operator|=
operator|(
operator|(
name|value
operator|&
literal|0x3ff0000
operator|)
operator|>>
literal|6
operator|)
operator||
operator|(
name|value
operator|&
literal|0x3fe
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x80000
operator|)
operator|==
literal|0x80000
condition|)
name|offset
operator||=
literal|0xfff00000
expr_stmt|;
name|abs_value
operator|=
name|offset
operator|+
name|symbol_address
operator|-
name|frag_addr
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|abs_value
operator|+
literal|1
expr_stmt|;
comment|/* Relax branch 32 to branch 16.  */
if|if
condition|(
name|relaxable_p
operator|&&
operator|(
name|s
operator|->
name|bsym
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|abs_value
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_IS_DEFINED
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
comment|/* do nothing.  */
block|}
else|else
block|{
comment|/* Branch 32 can not be relaxed to b 16, so clear OPT bit.  */
name|fragp
operator|->
name|fr_opcode
operator|=
name|NULL
expr_stmt|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_OPT_CLEAR
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
return|return
name|grows
return|;
block|}
end_function

begin_comment
comment|/* Main purpose is to determine whether one frag should do relax.    frag->fr_opcode indicates this point.  */
end_comment

begin_function
name|int
name|score_relax_frag
parameter_list|(
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|,
name|long
name|stretch
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|grows
init|=
literal|0
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
name|int
name|insn_relax_size
decl_stmt|;
name|int
name|do_relax_p
init|=
literal|0
decl_stmt|;
comment|/* Indicate doing relaxation for this frag.  */
name|int
name|relaxable_p
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|word_align_p
init|=
name|FALSE
decl_stmt|;
name|fragS
modifier|*
name|next_fragp
decl_stmt|;
comment|/* If the instruction address is odd, make it half word align first.  */
if|if
condition|(
operator|(
name|fragp
operator|->
name|fr_address
operator|)
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|insn_addr
operator|)
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|fragp
operator|->
name|insn_addr
operator|=
literal|1
expr_stmt|;
name|grows
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|word_align_p
operator|=
operator|(
operator|(
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|insn_addr
operator|)
operator|%
literal|4
operator|==
literal|0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* Get instruction size and relax size after the last relaxation.  */
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
block|{
name|insn_size
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|insn_relax_size
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn_size
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|insn_relax_size
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
comment|/* Handle specially for GP instruction.  for, judge_size_before_relax() has already determine      whether the GP instruction should do relax.  */
if|if
condition|(
operator|(
name|RELAX_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|Insn_GP
operator|)
operator|||
operator|(
name|RELAX_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|Insn_PIC
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|word_align_p
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|insn_addr
operator|<
literal|2
condition|)
block|{
name|fragp
operator|->
name|insn_addr
operator|+=
literal|2
expr_stmt|;
name|grows
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fragp
operator|->
name|insn_addr
operator|-=
literal|2
expr_stmt|;
name|grows
operator|-=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|+
name|fragp
operator|->
name|insn_addr
expr_stmt|;
else|else
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|+
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RELAX_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|PC_DISP19div2
condition|)
name|b32_relax_to_b16
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
name|relaxable_p
operator|=
name|RELAX_OPT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|next_fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
while|while
condition|(
operator|(
name|next_fragp
operator|)
operator|&&
operator|(
name|next_fragp
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
operator|)
condition|)
block|{
name|next_fragp
operator|=
name|next_fragp
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|next_fragp
condition|)
block|{
name|int
name|n_insn_size
decl_stmt|;
name|int
name|n_relaxable_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|next_fragp
operator|->
name|fr_opcode
condition|)
block|{
name|n_insn_size
operator|=
name|RELAX_NEW
argument_list|(
name|next_fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n_insn_size
operator|=
name|RELAX_OLD
argument_list|(
name|next_fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RELAX_TYPE
argument_list|(
name|next_fragp
operator|->
name|fr_subtype
argument_list|)
operator|==
name|PC_DISP19div2
condition|)
name|b32_relax_to_b16
argument_list|(
name|next_fragp
argument_list|)
expr_stmt|;
name|n_relaxable_p
operator|=
name|RELAX_OPT
argument_list|(
name|next_fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|word_align_p
condition|)
block|{
if|if
condition|(
name|insn_size
operator|==
literal|4
condition|)
block|{
comment|/* 32 -> 16.  */
if|if
condition|(
name|relaxable_p
operator|&&
operator|(
operator|(
name|n_insn_size
operator|==
literal|2
operator|)
operator|||
name|n_relaxable_p
operator|)
condition|)
block|{
name|grows
operator|-=
literal|2
expr_stmt|;
name|do_relax_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn_size
operator|==
literal|2
condition|)
block|{
comment|/* 16 -> 32.  */
if|if
condition|(
name|relaxable_p
operator|&&
operator|(
operator|(
operator|(
name|n_insn_size
operator|==
literal|4
operator|)
operator|&&
operator|!
name|n_relaxable_p
operator|)
operator|||
operator|(
name|n_insn_size
operator|>
literal|4
operator|)
operator|)
condition|)
block|{
name|grows
operator|+=
literal|2
expr_stmt|;
name|do_relax_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|insn_size
operator|==
literal|4
condition|)
block|{
comment|/* 32 -> 16.  */
if|if
condition|(
name|relaxable_p
condition|)
block|{
name|grows
operator|-=
literal|2
expr_stmt|;
name|do_relax_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Make the 32 bit insturction word align.  */
else|else
block|{
name|fragp
operator|->
name|insn_addr
operator|+=
literal|2
expr_stmt|;
name|grows
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn_size
operator|==
literal|2
condition|)
block|{
comment|/* Do nothing.  */
block|}
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Here, try best to do relax regardless fragp->fr_next->fr_type.  */
if|if
condition|(
name|word_align_p
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|insn_size
operator|%
literal|4
operator|==
literal|0
condition|)
block|{
comment|/* 32 -> 16.  */
if|if
condition|(
name|relaxable_p
condition|)
block|{
name|grows
operator|-=
literal|2
expr_stmt|;
name|do_relax_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fragp
operator|->
name|insn_addr
operator|+=
literal|2
expr_stmt|;
name|grows
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Do nothing.  */
block|}
block|}
comment|/* fragp->fr_opcode indicates whether this frag should be relaxed.  */
if|if
condition|(
name|do_relax_p
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
block|{
name|fragp
operator|->
name|fr_opcode
operator|=
name|NULL
expr_stmt|;
comment|/* Guarantee estimate stage is correct.  */
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
else|else
block|{
name|fragp
operator|->
name|fr_opcode
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|RELAX_RELOC1
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* Guarantee estimate stage is correct.  */
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
block|{
comment|/* Guarantee estimate stage is correct.  */
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Guarantee estimate stage is correct.  */
name|fragp
operator|->
name|fr_fix
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
block|}
block|}
return|return
name|grows
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
name|int
name|old
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
name|backup
index|[
literal|20
index|]
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|old
operator|=
name|RELAX_OLD
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|new
operator|=
name|RELAX_NEW
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* fragp->fr_opcode indicates whether this frag should be relaxed.  */
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
operator|==
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|backup
argument_list|,
name|fragp
operator|->
name|fr_literal
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|=
name|old
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|backup
argument_list|,
name|fragp
operator|->
name|fr_literal
operator|+
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|=
name|new
expr_stmt|;
block|}
name|fixp
operator|=
name|fragp
operator|->
name|tc_frag_data
operator|.
name|fixp
expr_stmt|;
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
operator|&&
name|fixp
operator|->
name|fx_where
operator|<
name|old
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_opcode
condition|)
name|fixp
operator|->
name|fx_where
operator|-=
name|old
operator|+
name|fragp
operator|->
name|insn_addr
expr_stmt|;
else|else
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
if|if
condition|(
name|fragp
operator|->
name|insn_addr
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|0x0
argument_list|,
name|fragp
operator|->
name|insn_addr
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|insn_addr
argument_list|,
name|backup
argument_list|,
name|fragp
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|insn_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implementation of md_frag_check.    Called after md_convert_frag().  */
end_comment

begin_function
name|void
name|score_frag_check
parameter_list|(
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|know
argument_list|(
name|fragp
operator|->
name|insn_addr
operator|<=
name|RELAX_PAD_BYTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|score_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Implementation of TC_VALIDATE_FIX.    Called before md_apply_fix() and after md_convert_frag().  */
end_comment

begin_function
name|void
name|score_validate_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|fixP
operator|->
name|fx_where
operator|+=
name|fixP
operator|->
name|fx_frag
operator|->
name|insn_addr
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|long
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
operator|)
operator|&&
operator|(
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|score_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixp
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SCORE_JMP
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SCORE_BRANCH
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SCORE16_JMP
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SCORE16_BRANCH
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|offsetT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|offsetT
name|abs_value
init|=
literal|0
decl_stmt|;
name|offsetT
name|newval
decl_stmt|;
name|offsetT
name|content
decl_stmt|;
name|unsigned
name|short
name|HI
decl_stmt|,
name|LO
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SCORE_DUMMY_HI16
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this symbol is in a different section then we need to leave it for      the linker to deal with.  Unfortunately, md_pcrel_from can't tell,      so we have to undo it's effects here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
block|}
comment|/* Remember value for emit_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_HI16_S
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* For la rd, imm32.  */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|HI
operator|=
operator|(
name|value
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* mul to 2, then take the hi 16 bit.  */
name|newval
operator||=
operator|(
name|HI
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|HI
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_LO16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
comment|/* For la rd, imm32.  */
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|LO
operator|=
operator|(
name|value
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|newval
operator||=
operator|(
name|LO
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* 16 bit: imm -> 14 bit in lo, 2 bit in hi.  */
name|newval
operator||=
operator|(
operator|(
name|LO
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SCORE_JMP
case|:
block|{
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
operator|~
literal|0x3ff7ffe
operator|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|1
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
name|value
operator|&
literal|0x7fff
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SCORE_BRANCH
case|:
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_opcode
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|content
operator|&
literal|0x80008000
operator|)
operator|!=
literal|0x80008000
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|value
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|" branch relocation truncate (0x%x) [-2^8 ~ 2^8]"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
name|content
operator|&=
literal|0xff00
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SCORE16_BRANCH
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|value
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0xfff80000
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|content
operator|&=
literal|0xfc00fc01
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
literal|0xfc00fc01
operator|)
operator||
operator|(
name|value
operator|&
literal|0x3fe
operator|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|6
operator|)
operator|&
literal|0x3ff0000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SCORE16_JMP
case|:
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
name|content
operator|&=
literal|0xf001
expr_stmt|;
name|value
operator|=
name|fixP
operator|->
name|fx_offset
operator|&
literal|0xfff
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
literal|0xfc01
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffe
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SCORE16_BRANCH
case|:
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_opcode
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|content
operator|&
literal|0x80008000
operator|)
operator|==
literal|0x80008000
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|value
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0xfff80000
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|" branch relocation truncate (0x%x) [-2^19 ~ 2^19]"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
literal|0xfc00fc01
operator|)
operator||
operator|(
name|value
operator|&
literal|0x3fe
operator|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|6
operator|)
operator|&
literal|0x3ff0000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SCORE_BRANCH
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* In differnt section.  */
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|value
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|" branch relocation truncate (0x%x)  [-2^8 ~ 2^8]"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
name|content
operator|=
operator|(
name|content
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|content
argument_list|,
name|INSN16_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SCORE_GPREL15
case|:
name|content
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_opcode
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|content
operator|&
literal|0xfc1c8000
operator|)
operator|!=
literal|0x94188000
operator|)
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SCORE_GOT15
case|:
case|case
name|BFD_RELOC_SCORE_DUMMY_HI16
case|:
case|case
name|BFD_RELOC_SCORE_GOT_LO16
case|:
case|case
name|BFD_RELOC_SCORE_CALL15
case|:
case|case
name|BFD_RELOC_GPREL32
case|:
break|break;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad relocation fixup type (%d)"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target format.  */
end_comment

begin_function
name|arelent
modifier|*
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
specifier|static
name|arelent
modifier|*
name|retval
index|[
name|MAX_RELOC_EXPANSION
operator|+
literal|1
index|]
decl_stmt|;
comment|/* MAX_RELOC_EXPANSION equals 2.  */
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
name|symbolS
modifier|*
name|s
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|reloc
operator|=
name|retval
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
comment|/* If this is a variant frag, we may need to adjust the existing      reloc and generate a new one.  */
if|if
condition|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_opcode
operator|!=
name|NULL
operator|&&
operator|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SCORE_GPREL15
operator|)
condition|)
block|{
comment|/* Update instruction imm bit.  */
name|offsetT
name|newval
decl_stmt|;
name|unsigned
name|short
name|off
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_frag
operator|->
name|insn_addr
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|off
operator|=
name|fixp
operator|->
name|fx_offset
operator|>>
literal|16
expr_stmt|;
name|newval
operator||=
operator|(
name|off
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|off
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|INSN_SIZE
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|off
operator|=
name|fixp
operator|->
name|fx_offset
operator|&
literal|0xffff
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|off
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
operator|(
name|off
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|retval
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|retval
index|[
literal|1
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|->
name|address
operator|=
operator|(
name|reloc
operator|->
name|address
operator|+
name|RELAX_RELOC2
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_subtype
argument_list|)
operator|)
expr_stmt|;
name|f
operator|=
name|fixp
operator|->
name|fx_frag
expr_stmt|;
name|s
operator|=
name|f
operator|->
name|fr_symbol
expr_stmt|;
name|e
operator|=
name|s
operator|->
name|sy_value
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|retval
index|[
literal|1
index|]
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_HI16_S
expr_stmt|;
block|}
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_HI16_S
case|:
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_SCORE_JMP
case|:
case|case
name|BFD_RELOC_SCORE_BRANCH
case|:
case|case
name|BFD_RELOC_SCORE16_JMP
case|:
case|case
name|BFD_RELOC_SCORE16_BRANCH
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_SCORE_GPREL15
case|:
case|case
name|BFD_RELOC_SCORE_GOT15
case|:
case|case
name|BFD_RELOC_SCORE_DUMMY_HI16
case|:
case|case
name|BFD_RELOC_SCORE_GOT_LO16
case|:
case|case
name|BFD_RELOC_SCORE_CALL15
case|:
case|case
name|BFD_RELOC_GPREL32
case|:
case|case
name|BFD_RELOC_NONE
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format1"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* HACK: Since arm ELF uses Rel instead of Rela, encode the      vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|score_elf_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fix_data_dependency
operator|==
literal|1
condition|)
block|{
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SCORE_FIXDEP
expr_stmt|;
block|}
if|if
condition|(
name|score_pic
operator|==
name|PIC
condition|)
block|{
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SCORE_PIC
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_pce_inst
parameter_list|(
name|char
modifier|*
name|insnstr
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|first
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
name|second
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|struct
name|score_it
name|pec_part_1
decl_stmt|;
comment|/* Get first part string of PCE.  */
name|p
operator|=
name|strstr
argument_list|(
name|insnstr
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|first
argument_list|,
literal|"%s"
argument_list|,
name|insnstr
argument_list|)
expr_stmt|;
comment|/* Get second part string of PCE.  */
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|sprintf
argument_list|(
name|second
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parse_16_32_inst
argument_list|(
name|first
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|pec_part_1
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|parse_16_32_inst
argument_list|(
name|second
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
name|pec_part_1
operator|.
name|size
operator|==
name|INSN_SIZE
operator|)
operator|&&
operator|(
name|inst
operator|.
name|size
operator|==
name|INSN_SIZE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pec_part_1
operator|.
name|size
operator|==
name|INSN_SIZE
operator|)
operator|&&
operator|(
name|inst
operator|.
name|size
operator|==
name|INSN16_SIZE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pec_part_1
operator|.
name|size
operator|==
name|INSN16_SIZE
operator|)
operator|&&
operator|(
name|inst
operator|.
name|size
operator|==
name|INSN_SIZE
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pce instruction error (16 bit || 16 bit)'"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inst
operator|.
name|str
argument_list|,
name|insnstr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|gen_insn_frag
argument_list|(
operator|&
name|pec_part_1
argument_list|,
operator|&
name|inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|<
name|MAX_LITERAL_POOL_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_IS_PCE_P
argument_list|(
name|str
argument_list|)
condition|)
name|parse_pce_inst
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|else
name|parse_16_32_inst
argument_list|(
name|str
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s -- `%s'"
argument_list|)
argument_list|,
name|inst
operator|.
name|error
argument_list|,
name|inst
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We handle all bad expressions here, so that we can report the faulty    instruction in the error message.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|expr
parameter_list|)
block|{
if|if
condition|(
name|in_my_get_expression
condition|)
block|{
name|expr
operator|->
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
operator|==
name|NULL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad expression"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"nO::g::G:"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCORE_BI_ENDIAN
end_ifdef

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|TARGET_BYTES_BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPTION_FIXDD
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_NWARN
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_SCORE5
value|(OPTION_MD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|OPTION_SCORE5U
value|(OPTION_MD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|OPTION_SCORE7
value|(OPTION_MD_BASE + 6)
end_define

begin_define
define|#
directive|define
name|OPTION_R1
value|(OPTION_MD_BASE + 7)
end_define

begin_define
define|#
directive|define
name|OPTION_O0
value|(OPTION_MD_BASE + 8)
end_define

begin_define
define|#
directive|define
name|OPTION_SCORE_VERSION
value|(OPTION_MD_BASE + 9)
end_define

begin_define
define|#
directive|define
name|OPTION_PIC
value|(OPTION_MD_BASE + 10)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
endif|#
directive|endif
block|{
literal|"FIXDD"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FIXDD
block|}
block|,
block|{
literal|"NWARN"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NWARN
block|}
block|,
block|{
literal|"SCORE5"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SCORE5
block|}
block|,
block|{
literal|"SCORE5U"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SCORE5U
block|}
block|,
block|{
literal|"SCORE7"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SCORE7
block|}
block|,
block|{
literal|"USE_R1"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_R1
block|}
block|,
block|{
literal|"O0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_O0
block|}
block|,
block|{
literal|"V"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SCORE_VERSION
block|}
block|,
block|{
literal|"KPIC"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OPTION_FIXDD
case|:
name|fix_data_dependency
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NWARN
case|:
name|warn_fix_data_dependency
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SCORE5
case|:
name|score7
operator|=
literal|0
expr_stmt|;
name|university_version
operator|=
literal|0
expr_stmt|;
name|vector_size
operator|=
name|SCORE5_PIPELINE
expr_stmt|;
break|break;
case|case
name|OPTION_SCORE5U
case|:
name|score7
operator|=
literal|0
expr_stmt|;
name|university_version
operator|=
literal|1
expr_stmt|;
name|vector_size
operator|=
name|SCORE5_PIPELINE
expr_stmt|;
break|break;
case|case
name|OPTION_SCORE7
case|:
name|score7
operator|=
literal|1
expr_stmt|;
name|university_version
operator|=
literal|0
expr_stmt|;
name|vector_size
operator|=
name|SCORE7_PIPELINE
expr_stmt|;
break|break;
case|case
name|OPTION_R1
case|:
name|nor1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|g_switch_value
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_O0
case|:
name|g_opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SCORE_VERSION
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Sunplus-v2-0-0-20060510\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_PIC
case|:
name|score_pic
operator|=
name|PIC
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
comment|/* Must set -G num as 0 to generate PIC code.  */
break|break;
default|default:
comment|/* as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");  */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|" Score-specific assembler options:\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTION_EB
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -EB\t\tassemble code for a big-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -EL\t\tassemble code for a little-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -FIXDD\t\tassemble code for fix data dependency\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -NWARN\t\tassemble code for no warning message for fix data dependency\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -SCORE5\t\tassemble code for target is SCORE5\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -SCORE5U\tassemble code for target is SCORE5U\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -SCORE7\t\tassemble code for target is SCORE7, this is default setting\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -USE_R1\t\tassemble code for no warning message when using temp register r1\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -KPIC\t\tassemble code for PIC\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -O0\t\tassembler will not perform any optimizations\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -G gpnum\tassemble code for setting gpsize and default is 8 byte\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\         -V \t\tSunplus release version \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pesudo handling functions.  */
end_comment

begin_comment
comment|/* If we change section we must dump the literal pool first.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_score_text
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|score_s_section
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
name|sec
parameter_list|)
block|{
name|segT
name|seg
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The ELF backend needs to know that we are changing sections, so      that .previous works correctly.  We could do something like check      for an obj_section_change_hook macro, but that might be confusing      as it would not be appropriate to use it in the section changing      functions in read.c, since obj-elf.c intercepts those.  FIXME:      This should be cleaner, somehow.  */
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
literal|'r'
case|:
name|seg
operator|=
name|subseg_new
argument_list|(
name|RDATA_SECTION_NAME
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".sdata"
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s_score_mask
parameter_list|(
name|int
name|reg_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|mask
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".mask outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|mask
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad .mask directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|off
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_mask
operator|=
name|mask
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_offset
operator|=
name|off
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected simple number"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISXDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator||=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|3
expr_stmt|;
name|val
operator||=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" *input_line_pointer == '%c' 0x%02x\n"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* The .aent and .ent directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_ent
parameter_list|(
name|int
name|aent
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|maybe_text
decl_stmt|;
name|symbolP
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
name|get_number
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|now_seg
operator|!=
name|data_section
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|maybe_text
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ent or .aent not in text section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
operator|&&
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
condition|)
block|{
name|cur_proc_ptr
operator|=
operator|&
name|cur_proc
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_mask
operator|=
literal|0xdeadbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_offset
operator|=
literal|0xdeadbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|fpreg_mask
operator|=
literal|0xdeafbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|leaf
operator|=
literal|0xdeafbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|frame_offset
operator|=
literal|0xdeafbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|frame_reg
operator|=
literal|0xdeafbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pc_reg
operator|=
literal|0xdeafbeaf
expr_stmt|;
name|cur_proc_ptr
operator|->
name|isym
operator|=
name|symbolP
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
operator|++
name|numprocs
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_func
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_score_frame
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|backupstr
decl_stmt|;
name|char
name|str
index|[
literal|30
index|]
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|backupstr
operator|=
name|input_line_pointer
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".frame outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|frame_reg
operator|=
name|reg_required_here
argument_list|(
operator|(
operator|&
name|backupstr
operator|)
argument_list|,
literal|0
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|backupstr
operator|!=
literal|','
condition|)
block|{
name|str
index|[
name|i
index|]
operator|=
operator|*
name|backupstr
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|backupstr
operator|++
expr_stmt|;
block|}
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|frame_offset
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pc_reg
operator|=
name|reg_required_here
argument_list|(
operator|(
operator|&
name|backupstr
operator|)
argument_list|,
literal|0
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|backupstr
operator|!=
literal|'\n'
condition|)
block|{
name|str
index|[
name|i
index|]
operator|=
operator|*
name|backupstr
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|backupstr
operator|++
expr_stmt|;
block|}
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|leaf
operator|=
name|val
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|skip_past_comma
argument_list|(
operator|&
name|backupstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
while|while
condition|(
name|input_line_pointer
operator|!=
name|backupstr
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .end directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_end
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|p
decl_stmt|;
name|int
name|maybe_text
decl_stmt|;
comment|/* Generate a .pdr section.  */
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|valueT
name|dot
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|fragp
decl_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|p
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|now_seg
operator|!=
name|data_section
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|maybe_text
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end not in text section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_proc_ptr
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .ent directive."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|cur_proc_ptr
operator|->
name|isym
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end symbol does not match .ent symbol."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_endfunc
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive missing or unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_proc_ptr
operator|->
name|reg_mask
operator|==
literal|0xdeadbeaf
operator|)
operator|||
operator|(
name|cur_proc_ptr
operator|->
name|reg_offset
operator|==
literal|0xdeadbeaf
operator|)
operator|||
operator|(
name|cur_proc_ptr
operator|->
name|leaf
operator|==
literal|0xdeafbeaf
operator|)
operator|||
operator|(
name|cur_proc_ptr
operator|->
name|frame_offset
operator|==
literal|0xdeafbeaf
operator|)
operator|||
operator|(
name|cur_proc_ptr
operator|->
name|frame_reg
operator|==
literal|0xdeafbeaf
operator|)
operator|||
operator|(
name|cur_proc_ptr
operator|->
name|pc_reg
operator|==
literal|0xdeafbeaf
operator|)
condition|)
empty_stmt|;
else|else
block|{
name|dot
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|pdr_seg
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|pdr_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the symbol.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|p
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|=
name|frag_more
argument_list|(
literal|7
operator|*
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|reg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|4
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|reg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|8
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|fpreg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|12
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|leaf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|16
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|frame_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|20
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|frame_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|24
argument_list|,
operator|(
name|valueT
operator|)
name|cur_proc_ptr
operator|->
name|pc_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
name|cur_proc_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .set pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_set
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|orig_ilp
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
operator|*
name|input_line_pointer
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nwarn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn_fix_data_dependency
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fixdd"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fix_data_dependency
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nofixdd"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fix_data_dependency
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"r1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nor1
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nor1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nor1
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"optimize"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_opt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"volatile"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_opt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|score_pic
operator|=
name|PIC
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|orig_ilp
expr_stmt|;
name|s_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the .cpload pseudo-op.  This is used when generating PIC code.  It sets the    $gp register for the function based on the function address, which is in the register    named in the argument. This uses a relocation against GP_DISP_LABEL, which is handled    specially by the linker.  The result is:    ldis gp, %hi(GP_DISP_LABEL)    ori  gp, %low(GP_DISP_LABEL)    add  gp, gp, .cpload argument    The .cpload argument is normally r29.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_cpload
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|char
name|insn_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
comment|/* If we are not generating PIC code, .cpload is ignored.  */
if|if
condition|(
name|score_pic
operator|==
name|NO_PIC
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"ld_i32hi r%d, %s"
argument_list|,
name|GP
argument_list|,
name|GP_DISP_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"ld_i32lo r%d, %s"
argument_list|,
name|GP
argument_list|,
name|GP_DISP_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"add r%d, r%d, r%d"
argument_list|,
name|GP
argument_list|,
name|GP
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
end_function

begin_comment
comment|/* Handle the .cprestore pseudo-op.  This stores $gp into a given    offset from $sp.  The offset is remembered, and after making a PIC    call $gp is restored from that location.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_cprestore
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|cprestore_offset
decl_stmt|;
name|char
name|insn_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
comment|/* If we are not generating PIC code, .cprestore is ignored.  */
if|if
condition|(
name|score_pic
operator|==
name|NO_PIC
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
name|cprestore_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|cprestore_offset
operator|<=
literal|0x3fff
condition|)
block|{
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"sw r%d, [r%d, %d]"
argument_list|,
name|GP
argument_list|,
name|reg
argument_list|,
name|cprestore_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|int
name|r1_bak
decl_stmt|;
name|r1_bak
operator|=
name|nor1
expr_stmt|;
name|nor1
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"li r1, %d"
argument_list|,
name|cprestore_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"add r1, r1, r%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"sw r%d, [r1]"
argument_list|,
name|GP
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
name|nor1
operator|=
name|r1_bak
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .gpword pseudo-op.  This is used when generating PIC    code.  It generates a 32 bit GP relative reloc.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_gpword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* When not generating PIC code, this is treated as .word.  */
if|if
condition|(
name|score_pic
operator|==
name|NO_PIC
condition|)
block|{
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of .gpword"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpadd pseudo-op.  This is used when dealing with switch    tables in PIC code.  */
end_comment

begin_function
specifier|static
name|void
name|s_score_cpadd
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|char
name|insn_str
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
comment|/* If we are not generating PIC code, .cpload is ignored.  */
if|if
condition|(
name|score_pic
operator|==
name|NO_PIC
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_SCORE
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
block|{
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Add $gp to the register named as an argument.  */
name|sprintf
argument_list|(
name|insn_str
argument_list|,
literal|"add r%d, r%d, r%d"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|GP
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_insn
argument_list|(
name|insn_str
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|(
name|int
operator|)
name|FAIL
condition|)
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TC_IMPLICIT_LCOMM_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TC_IMPLICIT_LCOMM_ALIGNMENT
parameter_list|(
name|SIZE
parameter_list|,
name|P2VAR
parameter_list|)
define|\
value|do								\     {                                                   	\     if ((SIZE)>= 8)                                      	\     (P2VAR) = 3;                                        	\     else if ((SIZE)>= 4)                                 	\     (P2VAR) = 2;                                        	\     else if ((SIZE)>= 2)                                 	\     (P2VAR) = 1;                                        	\     else                                                  	\     (P2VAR) = 0;                                        	\     }								\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|s_score_lcomm
parameter_list|(
name|int
name|bytes_p
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
specifier|const
name|int
name|max_alignment
init|=
literal|15
decl_stmt|;
name|int
name|align
init|=
literal|0
decl_stmt|;
name|segT
name|bss_seg
init|=
name|bss_section
decl_stmt|;
name|int
name|needs_align
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|p
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Accept an optional comma after the name.  The comma used to be      required, but Irix 5 cc does not generate it.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing size expression"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"BSS length (%d)< 0 ignored"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TC_SCORE
argument_list|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* For Score and Alpha ECOFF or ELF, small objects are put in .sbss.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|temp
operator|<=
name|bfd_get_gp_size
argument_list|(
name|stdoutput
argument_list|)
condition|)
block|{
name|bss_seg
operator|=
name|subseg_new
argument_list|(
literal|".sbss"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|bss_seg
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|bss_seg
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \".sbss\": %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing alignment"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|needs_align
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|needs_align
condition|)
block|{
name|TC_IMPLICIT_LCOMM_ALIGNMENT
argument_list|(
name|temp
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
if|if
condition|(
name|align
condition|)
name|record_alignment
argument_list|(
name|bss_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_align
condition|)
block|{
if|if
condition|(
name|bytes_p
condition|)
block|{
comment|/* Convert to a power of 2.  */
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|align
operator|!=
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|i
control|)
empty_stmt|;
name|align
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment too large; %d assumed"
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment negative; 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_alignment
argument_list|(
name|bss_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume some objects may require alignment on some systems.  */
if|#
directive|if
name|defined
argument_list|(
name|TC_ALPHA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
block|{
name|align
operator|=
name|ffs
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|%
operator|(
literal|1
operator|<<
name|align
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_BOUT
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_aout_flavour
operator|||
operator|(
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
else|#
directive|else
operator|(
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
operator|&&
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_seg
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|pfrag
decl_stmt|;
name|subseg_set
argument_list|(
name|bss_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detach from old frag.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_seg
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|temp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* The symbol may already have been created with a preceding          ".globl" directive -- be careful not to step on storage class          in that case.  Otherwise, set it to static.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_COFF */
ifdef|#
directive|ifdef
name|S_SET_SIZE
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_reg
parameter_list|(
specifier|const
name|struct
name|reg_entry
modifier|*
name|r
parameter_list|,
name|struct
name|hash_control
modifier|*
name|htab
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|r
operator|->
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|buf2
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|buf2
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hash_insert
argument_list|(
name|htab
argument_list|,
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|htab
argument_list|,
name|buf2
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_reg_hsh
parameter_list|(
name|struct
name|reg_map
modifier|*
name|map
parameter_list|)
block|{
specifier|const
name|struct
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|htab
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
name|map
operator|->
name|names
init|;
name|r
operator|->
name|name
operator|!=
name|NULL
condition|;
name|r
operator|++
control|)
block|{
name|insert_reg
argument_list|(
name|r
argument_list|,
name|map
operator|->
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
if|if
condition|(
operator|(
name|score_ops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|build_score_ops_hsh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dependency_insn_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|build_dependency_insn_hsh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|REG_TYPE_FIRST
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|REG_TYPE_MAX
condition|;
name|i
operator|++
control|)
name|build_reg_hsh
argument_list|(
name|all_reg_maps
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* Initialize dependency vector.  */
name|init_dependency_vector
argument_list|()
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
name|pdr_seg
operator|=
name|subseg_new
argument_list|(
literal|".pdr"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
condition|)
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|s_score_bss
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|s_score_text
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"extend"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"packed"
block|,
name|float_cons
block|,
literal|'p'
block|}
block|,
block|{
literal|"end"
block|,
name|s_score_end
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|s_score_ent
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|s_score_frame
block|,
literal|0
block|}
block|,
block|{
literal|"rdata"
block|,
name|s_change_sec
block|,
literal|'r'
block|}
block|,
block|{
literal|"sdata"
block|,
name|s_change_sec
block|,
literal|'s'
block|}
block|,
block|{
literal|"set"
block|,
name|s_score_set
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|s_score_mask
block|,
literal|'R'
block|}
block|,
block|{
literal|"dword"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_score_lcomm
block|,
literal|1
block|}
block|,
block|{
literal|"section"
block|,
name|score_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"cpload"
block|,
name|s_score_cpload
block|,
literal|0
block|}
block|,
block|{
literal|"cprestore"
block|,
name|s_score_cprestore
block|,
literal|0
block|}
block|,
block|{
literal|"gpword"
block|,
name|s_score_gpword
block|,
literal|0
block|}
block|,
block|{
literal|"cpadd"
block|,
name|s_score_cpadd
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

