begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-h8300.c -- Assemble code for the Renesas H8/300    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written By Steve Chamberlain<sac@cygnus.com>.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_define
define|#
directive|define
name|h8_opcodes
value|ops
end_define

begin_include
include|#
directive|include
file|"opcode/h8300.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/h8.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sbranch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300hmode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300smode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300hnmode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300snmode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300sxmode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300sxnmode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Hmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Smode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SXmode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PSIZE
value|(Hmode&& !Nmode ? L_32 : L_16)
end_define

begin_decl_stmt
specifier|static
name|int
name|bsize
init|=
name|L_8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default branch displacement.  */
end_comment

begin_struct
struct|struct
name|h8_instruction
block|{
name|int
name|length
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|const
name|struct
name|h8_opcode
modifier|*
name|opcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|h8_instruction
modifier|*
name|h8_instructions
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|h8300hmode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Hmode
operator|=
literal|1
expr_stmt|;
name|Smode
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300h
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|h8300smode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Smode
operator|=
literal|1
expr_stmt|;
name|Hmode
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300s
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|h8300hnmode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Hmode
operator|=
literal|1
expr_stmt|;
name|Smode
operator|=
literal|0
expr_stmt|;
name|Nmode
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300hn
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|h8300snmode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Smode
operator|=
literal|1
expr_stmt|;
name|Hmode
operator|=
literal|1
expr_stmt|;
name|Nmode
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300sn
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|h8300sxmode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Smode
operator|=
literal|1
expr_stmt|;
name|Hmode
operator|=
literal|1
expr_stmt|;
name|SXmode
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300sx
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|h8300sxnmode
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Smode
operator|=
literal|1
expr_stmt|;
name|Hmode
operator|=
literal|1
expr_stmt|;
name|SXmode
operator|=
literal|1
expr_stmt|;
name|Nmode
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300sxn
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sbranch
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|bsize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pint
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|cons
argument_list|(
name|Hmode
condition|?
literal|4
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"h8300h"
block|,
name|h8300hmode
block|,
literal|0
block|}
block|,
block|{
literal|"h8300hn"
block|,
name|h8300hnmode
block|,
literal|0
block|}
block|,
block|{
literal|"h8300s"
block|,
name|h8300smode
block|,
literal|0
block|}
block|,
block|{
literal|"h8300sn"
block|,
name|h8300snmode
block|,
literal|0
block|}
block|,
block|{
literal|"h8300sx"
block|,
name|h8300sxmode
block|,
literal|0
block|}
block|,
block|{
literal|"h8300sxn"
block|,
name|h8300sxnmode
block|,
literal|0
block|}
block|,
block|{
literal|"sbranch"
block|,
name|sbranch
block|,
name|L_8
block|}
block|,
block|{
literal|"lbranch"
block|,
name|sbranch
block|,
name|L_16
block|}
block|,
block|{
literal|"int"
block|,
name|pint
block|,
literal|0
block|}
block|,
block|{
literal|"data.b"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"data.w"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data.l"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"form"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"program"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    As in 0f12.456    or    0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics.  */
end_comment

begin_comment
comment|/* This function is called once, at assembler startup time.  This    should set up all the tables, etc. that the MD part of the assembler    needs.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|nopcodes
decl_stmt|;
name|struct
name|h8_opcode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|struct
name|h8_instruction
modifier|*
name|pi
decl_stmt|;
name|char
name|prev_buffer
index|[
literal|100
index|]
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|bfd_mach_h8300
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|prev_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nopcodes
operator|=
sizeof|sizeof
argument_list|(
name|h8_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|h8_opcode
argument_list|)
expr_stmt|;
name|h8_instructions
operator|=
operator|(
expr|struct
name|h8_instruction
operator|*
operator|)
name|xmalloc
argument_list|(
name|nopcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|h8_instruction
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|=
name|h8_instructions
expr_stmt|;
name|p1
operator|=
name|h8_opcodes
expr_stmt|;
comment|/* We do a minimum amount of sorting on the opcode table; this is to      make it easy to describe the mova instructions without unnecessary      code duplication.      Sorting only takes place inside blocks of instructions of the form      X/Y, so for example mova/b, mova/w and mova/l can be intermixed.  */
while|while
condition|(
name|p1
condition|)
block|{
name|struct
name|h8_opcode
modifier|*
name|first_skipped
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cmplen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|p1
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|name
operator|==
literal|0
condition|)
break|break;
comment|/* Strip off any . part when inserting the opcode and only enter 	 unique codes into the hash table.  */
name|dst
operator|=
name|buffer
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
name|src
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'/'
condition|)
name|cmplen
operator|=
name|src
operator|-
name|p1
operator|->
name|name
operator|+
literal|1
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|dst
operator|-
name|buffer
expr_stmt|;
if|if
condition|(
name|cmplen
operator|==
literal|0
condition|)
name|cmplen
operator|=
name|len
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pi
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prev_buffer
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
block|{
comment|/* A negative TIME is used to indicate that we've added this opcode 	     already.  */
if|if
condition|(
name|p
operator|->
name|time
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|buffer
argument_list|,
name|cmplen
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|p
operator|->
name|name
index|[
name|cmplen
index|]
operator|!=
literal|'\0'
operator|&&
name|p
operator|->
name|name
index|[
name|cmplen
index|]
operator|!=
literal|'.'
operator|&&
name|p
operator|->
name|name
index|[
name|cmplen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|first_skipped
operator|==
literal|0
condition|)
name|first_skipped
operator|=
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first_skipped
operator|==
literal|0
condition|)
name|first_skipped
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|size
operator|=
name|p
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'.'
condition|?
name|p
operator|->
name|name
index|[
name|len
operator|+
literal|1
index|]
else|:
literal|0
expr_stmt|;
name|pi
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
comment|/* Find the number of operands.  */
name|pi
operator|->
name|noperands
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pi
operator|->
name|noperands
operator|<
literal|3
operator|&&
name|p
operator|->
name|args
operator|.
name|nib
index|[
name|pi
operator|->
name|noperands
index|]
operator|!=
operator|(
name|op_type
operator|)
name|E
condition|)
name|pi
operator|->
name|noperands
operator|++
expr_stmt|;
comment|/* Find the length of the opcode in bytes.  */
name|pi
operator|->
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|data
operator|.
name|nib
index|[
name|pi
operator|->
name|length
operator|*
literal|2
index|]
operator|!=
operator|(
name|op_type
operator|)
name|E
condition|)
name|pi
operator|->
name|length
operator|++
expr_stmt|;
name|pi
operator|->
name|opcode
operator|=
name|p
expr_stmt|;
name|pi
operator|++
expr_stmt|;
block|}
name|p1
operator|=
name|first_skipped
expr_stmt|;
block|}
comment|/* Add entry for the NULL vector terminator.  */
name|pi
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|noperands
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|idx
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|opcode
operator|=
literal|0
expr_stmt|;
name|linkrelax
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|h8_op
block|{
name|op_type
name|mode
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|clever_message
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_operand_size
parameter_list|(
name|struct
name|h8_op
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_bytes
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_a_fix_imm
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_operand
parameter_list|(
name|struct
name|h8_op
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|h8_instruction
modifier|*
name|get_specific
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
name|unsigned
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_operand
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_reg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|op_type
modifier|*
parameter_list|,
name|unsigned
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_colonthing
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|h8_op
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constant_fits_width_p
parameter_list|(
name|struct
name|h8_op
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constant_fits_size_p
parameter_list|(
name|struct
name|h8_op
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   parse operands   WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp   r0l,r0h,..r7l,r7h   @WREG   @WREG+   @-WREG   #const   ccr */
end_comment

begin_comment
comment|/* Try to parse a reg name.  Return the number of chars consumed.  */
end_comment

begin_function
specifier|static
name|int
name|parse_reg
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|op_type
modifier|*
name|mode
parameter_list|,
name|unsigned
name|int
modifier|*
name|reg
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Cribbed from get_symbol_end.  */
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|src
argument_list|)
operator|||
operator|*
name|src
operator|==
literal|'\001'
condition|)
return|return
literal|0
return|;
name|end
operator|=
name|src
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|is_part_of_name
argument_list|(
operator|*
name|end
argument_list|)
operator|&&
operator|*
name|end
operator|!=
literal|'.'
operator|)
operator|||
operator|*
name|end
operator|==
literal|'\001'
condition|)
name|end
operator|++
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|src
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'p'
condition|)
block|{
operator|*
name|mode
operator|=
name|PSIZE
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
literal|7
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
operator|*
name|mode
operator|=
name|CCR
expr_stmt|;
operator|*
name|reg
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'e'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'x'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
operator|*
name|mode
operator|=
name|EXR
expr_stmt|;
operator|*
name|reg
operator|=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'v'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'b'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
operator|*
name|mode
operator|=
name|VBR
expr_stmt|;
operator|*
name|reg
operator|=
literal|6
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'b'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
operator|*
name|mode
operator|=
name|SBR
expr_stmt|;
operator|*
name|reg
operator|=
literal|7
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'f'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'p'
condition|)
block|{
operator|*
name|mode
operator|=
name|PSIZE
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
literal|6
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'e'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'7'
condition|)
block|{
operator|*
name|mode
operator|=
name|L_32
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
name|Hmode
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Reg not valid for H8/300"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'e'
operator|&&
name|src
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
operator|*
name|mode
operator|=
name|L_16
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|+
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|Hmode
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Reg not valid for H8/300"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'l'
condition|)
block|{
operator|*
name|mode
operator|=
name|L_8
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|+
literal|8
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'h'
condition|)
block|{
operator|*
name|mode
operator|=
name|L_8
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
operator|*
name|mode
operator|=
name|L_16
operator||
name|REG
operator||
name|direction
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an immediate or address-related constant and store it in OP.    If the user also specifies the operand's size, store that size    in OP->MODE, otherwise leave it for later code to decide.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|struct
name|h8_op
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|src
expr_stmt|;
name|expression
argument_list|(
operator|&
name|op
operator|->
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|skip_colonthing
argument_list|(
name|src
argument_list|,
operator|&
name|op
operator|->
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If SRC starts with an explicit operand size, skip it and store the size    in *MODE.  Leave *MODE unchanged otherwise.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_colonthing
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|':'
condition|)
block|{
name|src
operator|++
expr_stmt|;
operator|*
name|mode
operator|&=
operator|~
name|SIZE
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'8'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_8
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'2'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_2
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'3'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_3
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'4'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_4
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'5'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_5
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'2'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'4'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_24
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'3'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'2'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_32
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
operator|*
name|mode
operator||=
name|L_16
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand size requested"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|src
argument_list|)
condition|)
name|src
operator|++
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* The many forms of operand:     Rn			Register direct    @Rn			Register indirect    @(exp[:16], Rn)	Register indirect with displacement    @Rn+    @-Rn    @aa:8		absolute 8 bit    @aa:16		absolute 16 bit    @aa			absolute 16 bit     #xx[:size]		immediate data    @(exp:[8], pc)	pc rel    @@aa[:8]		memory indirect.  */
end_comment

begin_function
specifier|static
name|int
name|constant_fits_width_p
parameter_list|(
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|)
block|{
return|return
operator|(
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
operator|~
name|width
operator|)
operator|==
literal|0
operator|||
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator||
name|width
operator|)
operator|==
call|(
name|unsigned
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|constant_fits_size_p
parameter_list|(
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|no_symbols
parameter_list|)
block|{
name|offsetT
name|num
init|=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|no_symbols
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_symbol
operator|!=
literal|0
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_op_symbol
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|L_2
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|3
operator|)
operator|==
literal|0
return|;
case|case
name|L_3
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|7
operator|)
operator|==
literal|0
return|;
case|case
name|L_3NZ
case|:
return|return
name|num
operator|>=
literal|1
operator|&&
name|num
operator|<
literal|8
return|;
case|case
name|L_4
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|15
operator|)
operator|==
literal|0
return|;
case|case
name|L_5
case|:
return|return
name|num
operator|>=
literal|1
operator|&&
name|num
operator|<
literal|32
return|;
case|case
name|L_8
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|0xFF
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|unsigned
operator|)
name|num
operator||
literal|0x7F
operator|)
operator|==
operator|~
literal|0u
return|;
case|case
name|L_8U
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|0xFF
operator|)
operator|==
literal|0
return|;
case|case
name|L_16
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|0xFFFF
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|unsigned
operator|)
name|num
operator||
literal|0x7FFF
operator|)
operator|==
operator|~
literal|0u
return|;
case|case
name|L_16U
case|:
return|return
operator|(
name|num
operator|&
operator|~
literal|0xFFFF
operator|)
operator|==
literal|0
return|;
case|case
name|L_32
case|:
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|h8_op
modifier|*
name|op
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|op_type
name|mode
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|op
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* Check for '(' and ')' for instructions ldm and stm.  */
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
name|src
index|[
literal|8
index|]
operator|==
literal|')'
condition|)
operator|++
name|src
expr_stmt|;
comment|/* Gross.  Gross.  ldm and stm have a format not easily handled      by get_operand.  We deal with it explicitly here.  */
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'e'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|ISDIGIT
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'-'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
operator|==
literal|'e'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|5
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|ISDIGIT
argument_list|(
name|src
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
name|high
operator|=
name|src
index|[
literal|6
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* Check register pair's validity as per tech note TN-H8*-193A/E 	  from Renesas for H8S and H8SX hardware manual.  */
if|if
condition|(
operator|!
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|high
operator|==
literal|1
operator|||
name|high
operator|==
literal|2
operator|||
name|high
operator|==
literal|3
operator|)
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|1
operator|&&
operator|(
name|high
operator|==
literal|2
operator|||
name|high
operator|==
literal|3
operator|||
name|high
operator|==
literal|4
operator|)
operator|&&
name|SXmode
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|2
operator|&&
operator|(
name|high
operator|==
literal|3
operator|||
operator|(
operator|(
name|high
operator|==
literal|4
operator|||
name|high
operator|==
literal|5
operator|)
operator|&&
name|SXmode
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|3
operator|&&
operator|(
name|high
operator|==
literal|4
operator|||
name|high
operator|==
literal|5
operator|||
name|high
operator|==
literal|6
operator|)
operator|&&
name|SXmode
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|4
operator|&&
operator|(
name|high
operator|==
literal|5
operator|||
name|high
operator|==
literal|6
operator|)
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|4
operator|&&
name|high
operator|==
literal|7
operator|&&
name|SXmode
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|5
operator|&&
operator|(
name|high
operator|==
literal|6
operator|||
name|high
operator|==
literal|7
operator|)
operator|&&
name|SXmode
operator|)
operator|&&
operator|!
operator|(
name|low
operator|==
literal|6
operator|&&
name|high
operator|==
literal|7
operator|&&
name|SXmode
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register list for ldm/stm\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even sicker.  We encode two registers into op->reg.  One 	 for the low register to save, the other for the high 	 register to save;  we also set the high bit in op->reg 	 so we know this is "very special".  */
name|op
operator|->
name|reg
operator|=
literal|0x80000000
operator||
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|REG
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|7
index|]
operator|==
literal|')'
condition|)
operator|*
name|ptr
operator|=
name|src
operator|+
literal|8
expr_stmt|;
else|else
operator|*
name|ptr
operator|=
name|src
operator|+
literal|7
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|op
operator|->
name|mode
argument_list|,
operator|&
name|op
operator|->
name|reg
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
name|int
name|size
init|=
name|op
operator|->
name|mode
operator|&
name|SIZE
decl_stmt|;
switch|switch
condition|(
name|src
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|size
operator|!=
name|L_32
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatch between register and suffix"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|LOWREG
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
if|if
condition|(
name|size
operator|!=
name|L_32
operator|&&
name|size
operator|!=
name|L_16
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatch between register and suffix"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|LOWREG
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|SIZE
operator|)
operator||
name|L_16
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|LOWREG
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|L_32
operator|&&
name|size
operator|!=
name|L_8
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatch between register and suffix"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|LOWREG
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|(
name|op
operator|->
name|mode
operator|&
operator|~
name|SIZE
operator|)
operator||
name|L_8
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"invalid suffix after register."
argument_list|)
expr_stmt|;
break|break;
block|}
name|src
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
block|{
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
block|{
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
operator|+
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|>=
literal|0x100
condition|)
block|{
name|int
name|divisor
init|=
literal|1
decl_stmt|;
name|op
operator|->
name|mode
operator|=
name|VECIND
expr_stmt|;
comment|/* FIXME : 2?  or 4?  */
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|>=
literal|0x400
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"address too high for vector table jmp/jsr"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|>=
literal|0x200
condition|)
name|divisor
operator|=
literal|4
expr_stmt|;
else|else
name|divisor
operator|=
literal|2
expr_stmt|;
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
operator|/
name|divisor
operator|-
literal|0x80
expr_stmt|;
block|}
else|else
name|op
operator|->
name|mode
operator|=
name|MEMIND
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'-'
operator|||
operator|*
name|src
operator|==
literal|'+'
condition|)
block|{
name|len
operator|=
name|parse_reg
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|num
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Oops, not a reg after all, must be ordinary exp.  */
name|op
operator|->
name|mode
operator|=
name|ABS
operator||
name|direction
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|PSIZE
operator|)
comment|/* For Normal mode accept 16 bit and 32 bit pointer registers.  */
operator|&&
operator|(
operator|!
name|Nmode
operator|||
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|L_32
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong size pointer register for architecture."
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|src
index|[
literal|0
index|]
operator|==
literal|'-'
condition|?
name|RDPREDEC
else|:
name|RDPREINC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
name|num
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
literal|1
operator|+
name|len
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* See if this is @(ERn.x, PC).  */
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|op
operator|->
name|reg
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
operator|(
name|mode
operator|&
name|MODE
operator|)
operator|==
name|REG
operator|&&
name|src
index|[
name|len
index|]
operator|==
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
name|mode
operator|=
name|PCIDXB
operator||
name|direction
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mode
operator|=
name|PCIDXW
operator||
name|direction
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mode
operator|=
name|PCIDXL
operator||
name|direction
expr_stmt|;
break|break;
default|default:
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mode
operator|&&
name|src
index|[
name|len
operator|+
literal|2
index|]
operator|==
literal|','
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
name|len
operator|+
literal|3
index|]
argument_list|)
operator|!=
literal|'p'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
name|len
operator|+
literal|4
index|]
argument_list|)
operator|!=
literal|'c'
operator|&&
name|src
index|[
name|len
operator|+
literal|5
index|]
operator|!=
literal|')'
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
operator|+
name|len
operator|+
literal|6
expr_stmt|;
name|op
operator|->
name|mode
operator||=
name|mode
expr_stmt|;
return|return;
block|}
comment|/* Fall through into disp case - the grammar is somewhat 		 ambiguous, so we should try whether it's a DISP operand 		 after all ("ER3.L" might be a poorly named label...).  */
block|}
comment|/* Disp.  */
comment|/* Start off assuming a 16 bit offset.  */
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|')'
condition|)
block|{
name|op
operator|->
name|mode
operator||=
name|ABS
operator||
name|direction
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|src
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected @(exp, reg16)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|++
expr_stmt|;
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|op
operator|->
name|reg
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|(
name|mode
operator|&
name|MODE
operator|)
operator|!=
name|REG
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected @(exp, reg16)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
name|op
operator|->
name|mode
operator||=
name|INDEXB
operator||
name|direction
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|op
operator|->
name|mode
operator||=
name|INDEXW
operator||
name|direction
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|op
operator|->
name|mode
operator||=
name|INDEXL
operator||
name|direction
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected .L, .W or .B for register in indexed addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|+=
literal|2
expr_stmt|;
name|op
operator|->
name|reg
operator|&=
literal|7
expr_stmt|;
block|}
else|else
name|op
operator|->
name|mode
operator||=
name|DISP
operator||
name|direction
expr_stmt|;
name|src
operator|=
name|skip_colonthing
argument_list|(
name|src
argument_list|,
operator|&
name|op
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|')'
operator|&&
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected @(exp, reg16)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|ptr
operator|=
name|src
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|num
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'+'
operator|||
operator|*
name|src
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|PSIZE
operator|)
comment|/* For Normal mode accept 16 bit and 32 bit pointer registers.  */
operator|&&
operator|(
operator|!
name|Nmode
operator|||
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|L_32
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong size pointer register for architecture."
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
operator|*
name|src
operator|==
literal|'+'
condition|?
name|RSPOSTINC
else|:
name|RSPOSTDEC
expr_stmt|;
name|op
operator|->
name|reg
operator|=
name|num
expr_stmt|;
name|src
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|PSIZE
operator|)
comment|/* For Normal mode accept 16 bit and 32 bit pointer registers.  */
operator|&&
operator|(
operator|!
name|Nmode
operator|||
operator|(
operator|(
name|mode
operator|&
name|SIZE
operator|)
operator|!=
name|L_32
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong size pointer register for architecture."
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|direction
operator||
name|IND
operator||
name|PSIZE
expr_stmt|;
name|op
operator|->
name|reg
operator|=
name|num
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* must be a symbol */
name|op
operator|->
name|mode
operator|=
name|ABS
operator||
name|direction
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
block|{
name|op
operator|->
name|mode
operator|=
name|IMM
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
operator|+
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"mach"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"macl"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"MACH"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"MACL"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|reg
operator|=
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'l'
expr_stmt|;
name|op
operator|->
name|mode
operator|=
name|MACREG
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
literal|4
expr_stmt|;
return|return;
block|}
else|else
block|{
name|op
operator|->
name|mode
operator|=
name|PCREL
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
name|unsigned
name|int
name|noperands
parameter_list|,
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
name|op_end
decl_stmt|;
switch|switch
condition|(
name|noperands
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
name|SRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|DST
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
name|SRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|DST
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
name|SRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
name|OP3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* MOVA has special requirements.  Rather than adding twice the amount of    addressing modes, we simply special case it a bit.  */
end_comment

begin_function
specifier|static
name|void
name|get_mova_operands
parameter_list|(
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
name|op_end
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|!=
literal|'@'
operator|||
name|ptr
index|[
literal|2
index|]
operator|!=
literal|'('
condition|)
goto|goto
name|error
goto|;
name|ptr
operator|+=
literal|3
expr_stmt|;
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|parse_exp
argument_list|(
name|ptr
argument_list|,
operator|&
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|','
condition|)
goto|goto
name|error
goto|;
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'.'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXB
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXW
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXL
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|&
name|MODE
operator|)
operator|==
name|LOWREG
condition|)
block|{
switch|switch
condition|(
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|&
name|SIZE
condition|)
block|{
case|case
name|L_8
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXB
expr_stmt|;
break|break;
case|case
name|L_16
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXW
expr_stmt|;
break|break;
case|case
name|L_32
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
operator|~
name|MODE
operator|)
operator||
name|INDEXL
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
block|}
else|else
goto|goto
name|error
goto|;
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|')'
operator|||
operator|*
name|ptr
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|error
goto|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
name|OP3
argument_list|)
expr_stmt|;
comment|/* See if we can use the short form of MOVA.  */
if|if
condition|(
operator|(
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|&
name|MODE
operator|)
operator|==
name|REG
operator|||
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|&
name|MODE
operator|)
operator|==
name|LOWREG
operator|)
operator|&&
operator|(
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|&
name|MODE
operator|)
operator|==
name|REG
operator|&&
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|&
literal|7
operator|)
operator|==
operator|(
name|operand
index|[
literal|2
index|]
operator|.
name|reg
operator|&
literal|7
operator|)
condition|)
block|{
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|operand
index|[
literal|2
index|]
operator|.
name|reg
operator|&
literal|7
expr_stmt|;
block|}
return|return;
name|error
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected valid addressing mode for mova: \"@(disp, ea.sz),ERn\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_rtsl_operands
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|)
block|{
name|int
name|mode
decl_stmt|,
name|num
decl_stmt|,
name|num2
decl_stmt|,
name|len
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|;
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'('
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
block|}
name|len
operator|=
name|parse_reg
argument_list|(
name|ptr
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|num
argument_list|,
name|SRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|(
name|mode
operator|&
name|MODE
operator|)
operator|!=
name|REG
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
name|len
operator|=
name|parse_reg
argument_list|(
operator|++
name|ptr
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|num2
argument_list|,
name|SRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|(
name|mode
operator|&
name|MODE
operator|)
operator|!=
name|REG
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|+=
name|len
expr_stmt|;
comment|/* CONST_xxx are used as placeholders in the opcode table.  */
name|num
operator|=
name|num2
operator|-
name|num
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|num2
operator|=
name|num
operator|,
name|num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|1
operator|&&
operator|*
name|ptr
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected closing paren"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|RS32
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|RD32
expr_stmt|;
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|num
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|num2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Passed a pointer to a list of opcodes which use different    addressing modes, return the opcode which matches the opcodes    provided.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|h8_instruction
modifier|*
name|get_specific
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
name|instruction
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operands
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|h8_instruction
modifier|*
name|this_try
init|=
name|instruction
decl_stmt|;
specifier|const
name|struct
name|h8_instruction
modifier|*
name|found_other
init|=
literal|0
decl_stmt|,
modifier|*
name|found_mismatched
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|this_index
init|=
name|instruction
operator|->
name|idx
decl_stmt|;
name|int
name|noperands
init|=
literal|0
decl_stmt|;
comment|/* There's only one ldm/stm and it's easier to just      get out quick for them.  */
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_LDM
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_STM
condition|)
return|return
name|this_try
return|;
while|while
condition|(
name|noperands
operator|<
literal|3
operator|&&
name|operands
index|[
name|noperands
index|]
operator|.
name|mode
operator|!=
literal|0
condition|)
name|noperands
operator|++
expr_stmt|;
while|while
condition|(
name|this_index
operator|==
name|instruction
operator|->
name|idx
operator|&&
operator|!
name|found
condition|)
block|{
name|int
name|this_size
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|this_try
operator|=
name|instruction
operator|++
expr_stmt|;
name|this_size
operator|=
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|&
name|SN
expr_stmt|;
if|if
condition|(
name|this_try
operator|->
name|noperands
operator|!=
name|noperands
condition|)
name|found
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|this_try
operator|->
name|noperands
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_try
operator|->
name|noperands
operator|&&
name|found
condition|;
name|i
operator|++
control|)
block|{
name|op_type
name|op
init|=
name|this_try
operator|->
name|opcode
operator|->
name|args
operator|.
name|nib
index|[
name|i
index|]
decl_stmt|;
name|int
name|op_mode
init|=
name|op
operator|&
name|MODE
decl_stmt|;
name|int
name|op_size
init|=
name|op
operator|&
name|SIZE
decl_stmt|;
name|int
name|x
init|=
name|operands
index|[
name|i
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|x_mode
init|=
name|x
operator|&
name|MODE
decl_stmt|;
name|int
name|x_size
init|=
name|x
operator|&
name|SIZE
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|LOWREG
operator|&&
operator|(
name|x_mode
operator|==
name|REG
operator|||
name|x_mode
operator|==
name|LOWREG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|x_size
operator|==
name|L_8
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|&
literal|8
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|x_size
operator|==
name|L_16
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|&
literal|8
operator|)
operator|==
literal|8
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"can't use high part of register in operand %d"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_size
operator|!=
name|op_size
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|x_mode
operator|==
name|LOWREG
condition|)
name|x_mode
operator|=
name|REG
expr_stmt|;
if|if
condition|(
name|x_mode
operator|!=
name|REG
condition|)
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x_size
operator|==
name|L_P
condition|)
name|x_size
operator|=
operator|(
name|Hmode
condition|?
name|L_32
else|:
name|L_16
operator|)
expr_stmt|;
if|if
condition|(
name|op_size
operator|==
name|L_P
condition|)
name|op_size
operator|=
operator|(
name|Hmode
condition|?
name|L_32
else|:
name|L_16
operator|)
expr_stmt|;
comment|/* The size of the reg is v important.  */
if|if
condition|(
name|op_size
operator|!=
name|x_size
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_mode
operator|&
name|CTRL
condition|)
comment|/* control register */
block|{
if|if
condition|(
operator|!
operator|(
name|x_mode
operator|&
name|CTRL
operator|)
condition|)
name|found
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|x_mode
condition|)
block|{
case|case
name|CCR
case|:
if|if
condition|(
name|op_mode
operator|!=
name|CCR
operator|&&
name|op_mode
operator|!=
name|CCR_EXR
operator|&&
name|op_mode
operator|!=
name|CC_EX_VB_SB
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EXR
case|:
if|if
condition|(
name|op_mode
operator|!=
name|EXR
operator|&&
name|op_mode
operator|!=
name|CCR_EXR
operator|&&
name|op_mode
operator|!=
name|CC_EX_VB_SB
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MACH
case|:
if|if
condition|(
name|op_mode
operator|!=
name|MACH
operator|&&
name|op_mode
operator|!=
name|MACREG
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MACL
case|:
if|if
condition|(
name|op_mode
operator|!=
name|MACL
operator|&&
name|op_mode
operator|!=
name|MACREG
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VBR
case|:
if|if
condition|(
name|op_mode
operator|!=
name|VBR
operator|&&
name|op_mode
operator|!=
name|VBR_SBR
operator|&&
name|op_mode
operator|!=
name|CC_EX_VB_SB
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SBR
case|:
if|if
condition|(
name|op_mode
operator|!=
name|SBR
operator|&&
name|op_mode
operator|!=
name|VBR_SBR
operator|&&
name|op_mode
operator|!=
name|CC_EX_VB_SB
condition|)
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
name|ABSJMP
operator|)
operator|&&
operator|(
name|x_mode
operator|==
name|ABS
operator|||
name|x_mode
operator|==
name|PCREL
operator|)
condition|)
block|{
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|&=
operator|~
name|MODE
expr_stmt|;
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator||=
name|ABSJMP
expr_stmt|;
comment|/* But it may not be 24 bits long.  */
if|if
condition|(
name|x_mode
operator|==
name|ABS
operator|&&
operator|!
name|Hmode
condition|)
block|{
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|&=
operator|~
name|SIZE
expr_stmt|;
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator||=
name|L_16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|&
name|SIZE
operator|)
operator|==
name|L_32
operator|&&
operator|(
name|op_mode
operator|&
name|SIZE
operator|)
operator|!=
name|L_32
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x_mode
operator|==
name|IMM
operator|&&
name|op_mode
operator|!=
name|IMM
condition|)
block|{
name|offsetT
name|num
init|=
name|operands
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|KBIT
operator|||
name|op_mode
operator|==
name|DBIT
condition|)
comment|/* This is ok if the immediate value is sensible.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|CONST_2
condition|)
name|found
operator|=
name|num
operator|==
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|CONST_4
condition|)
name|found
operator|=
name|num
operator|==
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|CONST_8
condition|)
name|found
operator|=
name|num
operator|==
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|CONST_16
condition|)
name|found
operator|=
name|num
operator|==
literal|16
expr_stmt|;
else|else
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_mode
operator|==
name|PCREL
operator|&&
name|op_mode
operator|==
name|x_mode
condition|)
block|{
comment|/* movsd, bsr/bc and bsr/bs only come in PCREL16 flavour: 		     If x_size is L_8, promote it.  */
if|if
condition|(
name|OP_KIND
argument_list|(
name|this_try
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVSD
operator|||
name|OP_KIND
argument_list|(
name|this_try
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_BSRBC
operator|||
name|OP_KIND
argument_list|(
name|this_try
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_BSRBS
condition|)
if|if
condition|(
name|x_size
operator|==
name|L_8
condition|)
name|x_size
operator|=
name|L_16
expr_stmt|;
comment|/* The size of the displacement is important.  */
if|if
condition|(
name|op_size
operator|!=
name|x_size
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|op_mode
operator|==
name|DISP
operator|||
name|op_mode
operator|==
name|IMM
operator|||
name|op_mode
operator|==
name|ABS
operator|||
name|op_mode
operator|==
name|INDEXB
operator|||
name|op_mode
operator|==
name|INDEXW
operator|||
name|op_mode
operator|==
name|INDEXL
operator|)
operator|&&
name|op_mode
operator|==
name|x_mode
condition|)
block|{
comment|/* Promote a L_24 to L_32 if it makes us match.  */
if|if
condition|(
name|x_size
operator|==
name|L_24
operator|&&
name|op_size
operator|==
name|L_32
condition|)
block|{
name|x
operator|&=
operator|~
name|SIZE
expr_stmt|;
name|x
operator||=
name|x_size
operator|=
name|L_32
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* ??? */
comment|/* Promote an L8 to L_16 if it makes us match.  */
block|if ((op_mode == ABS || op_mode == DISP)&& x_size == L_8) 		    { 		      if (op_size == L_16) 			x_size = L_16; 		    }
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|x_size
operator|==
name|L_16
operator|&&
name|op_size
operator|==
name|L_16U
operator|)
operator|||
operator|(
name|x_size
operator|==
name|L_8
operator|&&
name|op_size
operator|==
name|L_8U
operator|)
operator|||
operator|(
name|x_size
operator|==
name|L_3
operator|&&
name|op_size
operator|==
name|L_3NZ
operator|)
operator|)
comment|/* We're deliberately more permissive for ABS modes.  */
operator|&&
operator|(
name|op_mode
operator|==
name|ABS
operator|||
name|constant_fits_size_p
argument_list|(
name|operands
operator|+
name|i
argument_list|,
name|op_size
argument_list|,
name|op
operator|&
name|NO_SYMBOLS
argument_list|)
operator|)
condition|)
name|x_size
operator|=
name|op_size
expr_stmt|;
if|if
condition|(
name|x_size
operator|!=
literal|0
operator|&&
name|op_size
operator|!=
name|x_size
condition|)
name|found
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x_size
operator|==
literal|0
operator|&&
operator|!
name|constant_fits_size_p
argument_list|(
name|operands
operator|+
name|i
argument_list|,
name|op_size
argument_list|,
name|op
operator|&
name|NO_SYMBOLS
argument_list|)
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_mode
operator|!=
name|x_mode
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
operator|(
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|==
name|AV_H8SX
operator|&&
operator|!
name|SXmode
operator|)
operator|||
operator|(
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|==
name|AV_H8S
operator|&&
operator|!
name|Smode
operator|)
operator|||
operator|(
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|==
name|AV_H8H
operator|&&
operator|!
name|Hmode
operator|)
condition|)
name|found
operator|=
literal|0
operator|,
name|found_other
operator|=
name|this_try
expr_stmt|;
elseif|else
if|if
condition|(
name|this_size
operator|!=
name|size
operator|&&
operator|(
name|this_size
operator|!=
name|SN
operator|&&
name|size
operator|!=
name|SN
operator|)
condition|)
name|found_mismatched
operator|=
name|this_try
operator|,
name|found
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
return|return
name|this_try
return|;
if|if
condition|(
name|found_other
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' with these operand types not available in %s mode"
argument_list|)
argument_list|,
name|found_other
operator|->
name|opcode
operator|->
name|name
argument_list|,
operator|(
operator|!
name|Hmode
operator|&&
operator|!
name|Smode
condition|?
literal|"H8/300"
else|:
name|SXmode
condition|?
literal|"H8sx"
else|:
name|Smode
condition|?
literal|"H8/300S"
else|:
literal|"H8/300H"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_mismatched
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatch between opcode size and operand size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|found_mismatched
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_operand
parameter_list|(
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_op_symbol
operator|==
literal|0
condition|)
block|{
comment|/* No symbol involved, let's look at offset, it's dangerous if 	 any of the high bits are not 0 or ff's, find out by oring or 	 anding with the width and seeing if the answer is 0 or all 	 fs.  */
if|if
condition|(
operator|!
name|constant_fits_width_p
argument_list|(
name|operand
argument_list|,
name|width
argument_list|)
condition|)
block|{
if|if
condition|(
name|width
operator|==
literal|255
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff00
operator|)
operator|==
literal|0xff00
condition|)
block|{
comment|/* Just ignore this one - which happens when trying to 		 fit a 16 bit address truncated into an 8 bit address 		 of something like bset.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
operator|&&
name|width
operator|==
literal|0xffff
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff8000
operator|)
operator|==
literal|0xff8000
condition|)
block|{
comment|/* Just ignore this one - which happens when trying to 		 fit a 24 bit address truncated into a 16 bit address 		 of something like mov.w.  */
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand %s0x%lx out of range."
argument_list|)
argument_list|,
name|string
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|operand
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* RELAXMODE has one of 3 values:     0 Output a "normal" reloc, no relaxing possible for this insn/reloc     1 Output a relaxable 24bit absolute mov.w address relocation      (may relax into a 16bit absolute address).     2 Output a relaxable 16/24 absolute mov.b address relocation      (may relax into an 8bit absolute address).  */
end_comment

begin_function
specifier|static
name|void
name|do_a_fix_imm
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|nibble
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|,
name|int
name|relaxmode
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|where
decl_stmt|;
name|char
modifier|*
name|bytes
init|=
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
decl_stmt|;
name|char
modifier|*
name|t
init|=
operator|(
operator|(
name|operand
operator|->
name|mode
operator|&
name|MODE
operator|)
operator|==
name|IMM
operator|)
condition|?
literal|"#"
else|:
literal|"@"
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
condition|)
block|{
case|case
name|L_2
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0x3
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|3
operator|)
operator|<<
operator|(
name|nibble
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|L_3
case|:
case|case
name|L_3NZ
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0x7
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|7
operator|)
operator|<<
operator|(
name|nibble
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|L_4
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0xF
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|15
operator|)
operator|<<
operator|(
name|nibble
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|L_5
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0x1F
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|31
expr_stmt|;
break|break;
case|case
name|L_8
case|:
case|case
name|L_8U
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0xff
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|L_16
case|:
case|case
name|L_16U
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0xffff
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|8
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|0
expr_stmt|;
break|break;
case|case
name|L_24
case|:
name|check_operand
argument_list|(
name|operand
argument_list|,
literal|0xffffff
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|0
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|8
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|0
expr_stmt|;
break|break;
case|case
name|L_32
case|:
comment|/* This should be done with bfd.  */
name|bytes
index|[
literal|0
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|24
expr_stmt|;
name|bytes
index|[
literal|1
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|bytes
index|[
literal|2
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|8
expr_stmt|;
name|bytes
index|[
literal|3
index|]
operator||=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>>
literal|0
expr_stmt|;
if|if
condition|(
name|relaxmode
operator|!=
literal|0
condition|)
block|{
name|idx
operator|=
operator|(
name|relaxmode
operator|==
literal|2
operator|)
condition|?
name|R_MOV24B1
else|:
name|R_MOVL1
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|,
operator|&
name|operand
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
condition|)
block|{
case|case
name|L_24
case|:
case|case
name|L_32
case|:
name|size
operator|=
literal|4
expr_stmt|;
name|where
operator|=
operator|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
operator|)
operator|==
name|L_24
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|relaxmode
operator|==
literal|2
condition|)
name|idx
operator|=
name|R_MOV24B1
expr_stmt|;
elseif|else
if|if
condition|(
name|relaxmode
operator|==
literal|1
condition|)
name|idx
operator|=
name|R_MOVL1
expr_stmt|;
else|else
name|idx
operator|=
name|R_RELLONG
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't work out size of operand.\n"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|L_16
case|:
case|case
name|L_16U
case|:
name|size
operator|=
literal|2
expr_stmt|;
name|where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|relaxmode
operator|==
literal|2
condition|)
name|idx
operator|=
name|R_MOV16B1
expr_stmt|;
else|else
name|idx
operator|=
name|R_RELWORD
expr_stmt|;
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator||=
operator|(
name|bytes
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|L_8
case|:
name|size
operator|=
literal|1
expr_stmt|;
name|where
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|R_RELBYTE
expr_stmt|;
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff
operator|)
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator||=
name|bytes
index|[
literal|0
index|]
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|offset
operator|+
name|where
argument_list|,
name|size
argument_list|,
operator|&
name|operand
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Now we know what sort of opcodes it is, let's build the bytes.  */
end_comment

begin_function
specifier|static
name|void
name|build_bytes
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
name|this_try
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|frag_more
argument_list|(
name|this_try
operator|->
name|length
argument_list|)
decl_stmt|;
name|op_type
modifier|*
name|nibble_ptr
init|=
name|this_try
operator|->
name|opcode
operator|->
name|data
operator|.
name|nib
decl_stmt|;
name|op_type
name|c
decl_stmt|;
name|unsigned
name|int
name|nibble_count
init|=
literal|0
decl_stmt|;
name|int
name|op_at
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nib
init|=
literal|0
decl_stmt|;
name|int
name|movb
init|=
literal|0
decl_stmt|;
name|char
name|asnibbles
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|asnibbles
decl_stmt|;
name|int
name|high
decl_stmt|,
name|low
decl_stmt|;
if|if
condition|(
operator|!
name|Hmode
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' with these operand types not available in H8/300 mode"
argument_list|)
argument_list|,
name|this_try
operator|->
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Smode
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8H
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' with these operand types not available in H8/300H mode"
argument_list|)
argument_list|,
name|this_try
operator|->
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SXmode
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8H
operator|&&
name|this_try
operator|->
name|opcode
operator|->
name|available
operator|!=
name|AV_H8S
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' with these operand types not available in H8/300S mode"
argument_list|)
argument_list|,
name|this_try
operator|->
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|nibble_ptr
operator|!=
operator|(
name|op_type
operator|)
name|E
condition|)
block|{
name|int
name|d
decl_stmt|;
name|nib
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|nibble_ptr
operator|++
expr_stmt|;
name|d
operator|=
operator|(
name|c
operator|&
name|OP3
operator|)
operator|==
name|OP3
condition|?
literal|2
else|:
operator|(
name|c
operator|&
name|DST
operator|)
operator|==
name|DST
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|16
condition|)
name|nib
operator|=
name|c
expr_stmt|;
else|else
block|{
name|int
name|c2
init|=
name|c
operator|&
name|MODE
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|REG
operator|||
name|c2
operator|==
name|LOWREG
operator|||
name|c2
operator|==
name|IND
operator|||
name|c2
operator|==
name|PREINC
operator|||
name|c2
operator|==
name|PREDEC
operator|||
name|c2
operator|==
name|POSTINC
operator|||
name|c2
operator|==
name|POSTDEC
condition|)
block|{
name|nib
operator|=
name|operand
index|[
name|d
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|LOWREG
condition|)
name|nib
operator|&=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|&
name|CTRL
condition|)
comment|/* Control reg operand.  */
name|nib
operator|=
name|operand
index|[
name|d
index|]
operator|.
name|reg
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|DISPREG
operator|)
operator|==
operator|(
name|DISPREG
operator|)
condition|)
block|{
name|nib
operator|=
name|operand
index|[
name|d
index|]
operator|.
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
name|ABS
condition|)
block|{
name|operand
index|[
name|d
index|]
operator|.
name|mode
operator|=
name|c
expr_stmt|;
name|op_at
index|[
name|d
index|]
operator|=
name|nibble_count
expr_stmt|;
name|nib
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
name|IMM
operator|||
name|c2
operator|==
name|PCREL
operator|||
name|c2
operator|==
name|ABS
operator|||
operator|(
name|c
operator|&
name|ABSJMP
operator|)
operator|||
name|c2
operator|==
name|DISP
condition|)
block|{
name|operand
index|[
name|d
index|]
operator|.
name|mode
operator|=
name|c
expr_stmt|;
name|op_at
index|[
name|d
index|]
operator|=
name|nibble_count
expr_stmt|;
name|nib
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|IGNORE
operator|)
operator|||
operator|(
name|c
operator|&
name|DATA
operator|)
condition|)
name|nib
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c2
operator|==
name|DBIT
condition|)
block|{
switch|switch
condition|(
name|operand
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
condition|)
block|{
case|case
literal|1
case|:
name|nib
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nib
operator|=
literal|0x8
operator||
name|c
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Need #1 or #2 here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
name|KBIT
condition|)
block|{
switch|switch
condition|(
name|operand
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
condition|)
block|{
case|case
literal|1
case|:
name|nib
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nib
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|Hmode
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"#4 not valid on H8/300."
argument_list|)
argument_list|)
expr_stmt|;
name|nib
operator|=
literal|9
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Need #1 or #2 here"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Stop it making a fix.  */
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
name|MEMRELAX
condition|)
name|operand
index|[
name|d
index|]
operator|.
name|mode
operator||=
name|MEMRELAX
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|B31
condition|)
name|nib
operator||=
literal|0x8
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|B21
condition|)
name|nib
operator||=
literal|0x4
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|B11
condition|)
name|nib
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|B01
condition|)
name|nib
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|MACREG
condition|)
block|{
if|if
condition|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|==
name|MACREG
condition|)
comment|/* stmac has mac[hl] as the first operand.  */
name|nib
operator|=
literal|2
operator|+
name|operand
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
else|else
comment|/* ldmac has mac[hl] as the second operand.  */
name|nib
operator|=
literal|2
operator|+
name|operand
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
block|}
name|nibble_count
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|nib
expr_stmt|;
block|}
comment|/* Disgusting.  Why, oh why didn't someone ask us for advice      on the assembler format.  */
if|if
condition|(
name|OP_KIND
argument_list|(
name|this_try
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_LDM
condition|)
block|{
name|high
operator|=
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
name|low
operator|=
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|)
operator|&
literal|0xf
expr_stmt|;
name|asnibbles
index|[
literal|2
index|]
operator|=
name|high
operator|-
name|low
expr_stmt|;
name|asnibbles
index|[
literal|7
index|]
operator|=
name|high
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP_KIND
argument_list|(
name|this_try
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_STM
condition|)
block|{
name|high
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
name|low
operator|=
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|&
literal|0xf
expr_stmt|;
name|asnibbles
index|[
literal|2
index|]
operator|=
name|high
operator|-
name|low
expr_stmt|;
name|asnibbles
index|[
literal|7
index|]
operator|=
name|low
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_try
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|output
index|[
name|i
index|]
operator|=
operator|(
name|asnibbles
index|[
name|i
operator|*
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|asnibbles
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Note if this is a movb or a bit manipulation instruction      there is a special relaxation which only applies.  */
if|if
condition|(
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_MOV
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BCLR
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BAND
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BIAND
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BILD
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BIOR
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BIST
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BIXOR
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BLD
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BNOT
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BOR
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BSET
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BST
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BTST
argument_list|,
name|SB
argument_list|)
operator|||
name|this_try
operator|->
name|opcode
operator|->
name|how
operator|==
name|O
argument_list|(
name|O_BXOR
argument_list|,
name|SB
argument_list|)
condition|)
name|movb
operator|=
literal|1
expr_stmt|;
comment|/* Output any fixes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_try
operator|->
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|operand
index|[
name|i
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|x_mode
init|=
name|x
operator|&
name|MODE
decl_stmt|;
if|if
condition|(
name|x_mode
operator|==
name|IMM
operator|||
name|x_mode
operator|==
name|DISP
condition|)
name|do_a_fix_imm
argument_list|(
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|op_at
index|[
name|i
index|]
operator|/
literal|2
argument_list|,
name|op_at
index|[
name|i
index|]
operator|&
literal|1
argument_list|,
name|operand
operator|+
name|i
argument_list|,
operator|(
name|x
operator|&
name|MEMRELAX
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x_mode
operator|==
name|ABS
condition|)
name|do_a_fix_imm
argument_list|(
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|op_at
index|[
name|i
index|]
operator|/
literal|2
argument_list|,
name|op_at
index|[
name|i
index|]
operator|&
literal|1
argument_list|,
name|operand
operator|+
name|i
argument_list|,
operator|(
name|x
operator|&
name|MEMRELAX
operator|)
condition|?
name|movb
operator|+
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x_mode
operator|==
name|PCREL
condition|)
block|{
name|int
name|size16
init|=
operator|(
name|x
operator|&
name|SIZE
operator|)
operator|==
name|L_16
decl_stmt|;
name|int
name|size
init|=
name|size16
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|type
init|=
name|size16
condition|?
name|R_PCRWORD
else|:
name|R_PCRBYTE
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|check_operand
argument_list|(
name|operand
operator|+
name|i
argument_list|,
name|size16
condition|?
literal|0x7fff
else|:
literal|0x7f
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|1
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"branch operand has odd offset (%lx)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|operand
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
comment|/* The COFF port has always been off by one, changing it 	     now would be an incompatible change, so we leave it as-is.  	     We don't want to do this for ELF as we want to be 	     compatible with the proposed ELF format from Hitachi.  */
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size16
condition|)
block|{
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
block|}
else|else
block|{
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xff
operator|)
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
block|}
comment|/* For BRA/S.  */
if|if
condition|(
operator|!
name|size16
condition|)
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator||=
name|output
index|[
name|op_at
index|[
name|i
index|]
operator|/
literal|2
index|]
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|op_at
index|[
name|i
index|]
operator|/
literal|2
argument_list|,
name|size
argument_list|,
operator|&
name|operand
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_signed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x_mode
operator|==
name|MEMIND
condition|)
block|{
name|check_operand
argument_list|(
name|operand
operator|+
name|i
argument_list|,
literal|0xff
argument_list|,
literal|"@@"
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|operand
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|R_MEM_INDIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x_mode
operator|==
name|VECIND
condition|)
block|{
name|check_operand
argument_list|(
name|operand
operator|+
name|i
argument_list|,
literal|0x7f
argument_list|,
literal|"@@"
argument_list|)
expr_stmt|;
comment|/* FIXME: approximating the effect of "B31" here... 	     This is very hackish, and ought to be done a better way.  */
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator||=
literal|0x80
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|operand
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|R_MEM_INDIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|&
name|ABSJMP
condition|)
block|{
name|int
name|where
init|=
literal|0
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
init|=
name|R_JMPL1
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* To be compatible with the proposed H8 ELF format, we 	     want the relocation's offset to point to the first byte 	     that will be modified, not to the start of the instruction.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
operator|)
operator|==
name|L_32
condition|)
block|{
name|where
operator|=
literal|2
expr_stmt|;
name|reloc_type
operator|=
name|R_RELLONG
expr_stmt|;
block|}
else|else
name|where
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* This jmp may be a jump or a branch.  */
name|check_operand
argument_list|(
name|operand
operator|+
name|i
argument_list|,
name|SXmode
condition|?
literal|0xffffffff
else|:
name|Hmode
condition|?
literal|0xffffff
else|:
literal|0xffff
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|1
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"branch operand has odd offset (%lx)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|operand
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hmode
condition|)
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|operand
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|where
argument_list|,
literal|4
argument_list|,
operator|&
name|operand
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to give an intelligent error message for common and simple to    detect errors.  */
end_comment

begin_function
specifier|static
name|void
name|clever_message
parameter_list|(
specifier|const
name|struct
name|h8_instruction
modifier|*
name|instruction
parameter_list|,
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|)
block|{
comment|/* Find out if there was more than one possible opcode.  */
if|if
condition|(
operator|(
name|instruction
operator|+
literal|1
operator|)
operator|->
name|idx
operator|!=
name|instruction
operator|->
name|idx
condition|)
block|{
name|int
name|argn
decl_stmt|;
comment|/* Only one opcode of this flavour, try to guess which operand          didn't match.  */
for|for
control|(
name|argn
operator|=
literal|0
init|;
name|argn
operator|<
name|instruction
operator|->
name|noperands
condition|;
name|argn
operator|++
control|)
block|{
switch|switch
condition|(
name|instruction
operator|->
name|opcode
operator|->
name|args
operator|.
name|nib
index|[
name|argn
index|]
condition|)
block|{
case|case
name|RD16
case|:
if|if
condition|(
name|operand
index|[
name|argn
index|]
operator|.
name|mode
operator|!=
name|RD16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"destination operand must be 16 bit register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RS8
case|:
if|if
condition|(
name|operand
index|[
name|argn
index|]
operator|.
name|mode
operator|!=
name|RS8
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"source operand must be 8 bit register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ABS16DST
case|:
if|if
condition|(
name|operand
index|[
name|argn
index|]
operator|.
name|mode
operator|!=
name|ABS16DST
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"destination operand must be 16bit absolute address"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RD8
case|:
if|if
condition|(
name|operand
index|[
name|argn
index|]
operator|.
name|mode
operator|!=
name|RD8
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"destination operand must be 8 bit register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ABS16SRC
case|:
if|if
condition|(
name|operand
index|[
name|argn
index|]
operator|.
name|mode
operator|!=
name|ABS16SRC
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"source operand must be 16bit absolute address"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If OPERAND is part of an address, adjust its size and value given    that it addresses SIZE bytes.     This function decides how big non-immediate constants are when no    size was explicitly given.  It also scales down the assembly-level    displacement in an @(d:2,ERn) operand.  */
end_comment

begin_function
specifier|static
name|void
name|fix_operand_size
parameter_list|(
name|struct
name|h8_op
modifier|*
name|operand
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|SXmode
operator|&&
operator|(
name|operand
operator|->
name|mode
operator|&
name|MODE
operator|)
operator|==
name|DISP
condition|)
block|{
comment|/* If the user didn't specify an operand width, see if we 	 can use @(d:2,ERn).  */
if|if
condition|(
operator|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
operator|)
operator|==
literal|0
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_op_symbol
operator|==
literal|0
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
name|size
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
name|size
operator|*
literal|2
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
name|size
operator|*
literal|3
operator|)
condition|)
name|operand
operator|->
name|mode
operator||=
name|L_2
expr_stmt|;
comment|/* Scale down the displacement in an @(d:2,ERn) operand. 	 X_add_number then contains the desired field value.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
operator|)
operator|==
name|L_2
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|%
name|size
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand/size mis-match"
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|/=
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|mode
operator|&
name|SIZE
operator|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|operand
operator|->
name|mode
operator|&
name|MODE
condition|)
block|{
case|case
name|DISP
case|:
case|case
name|INDEXB
case|:
case|case
name|INDEXW
case|:
case|case
name|INDEXL
case|:
case|case
name|ABS
case|:
comment|/* Pick a 24-bit address unless we know that a 16-bit address 	   is safe.  get_specific() will relax L_24 into L_32 where 	   necessary.  */
if|if
condition|(
name|Hmode
operator|&&
operator|!
name|Nmode
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>
literal|32767
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_add_symbol
operator|!=
literal|0
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_op_symbol
operator|!=
literal|0
operator|)
condition|)
name|operand
operator|->
name|mode
operator||=
name|L_24
expr_stmt|;
else|else
name|operand
operator|->
name|mode
operator||=
name|L_16
expr_stmt|;
break|break;
case|case
name|PCREL
case|:
comment|/* This condition is long standing, though somewhat suspect.  */
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>
operator|-
literal|128
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|<
literal|127
condition|)
name|operand
operator|->
name|mode
operator||=
name|L_8
expr_stmt|;
else|else
name|operand
operator|->
name|mode
operator||=
name|L_16
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to    a machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|struct
name|h8_op
name|operand
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|struct
name|h8_instruction
modifier|*
name|instruction
decl_stmt|;
specifier|const
name|struct
name|h8_instruction
modifier|*
name|prev_instruction
decl_stmt|;
name|char
modifier|*
name|dot
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|slash
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|str
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'.'
condition|)
block|{
name|dot
operator|=
name|op_end
operator|+
literal|1
expr_stmt|;
operator|*
name|op_end
operator|=
literal|0
expr_stmt|;
name|op_end
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'/'
operator|&&
operator|!
name|slash
condition|)
name|slash
operator|=
name|op_end
expr_stmt|;
block|}
if|if
condition|(
name|op_end
operator|==
name|op_start
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|op_end
expr_stmt|;
operator|*
name|op_end
operator|=
literal|0
expr_stmt|;
comment|/* The assembler stops scanning the opcode at slashes, so it fails      to make characters following them lower case.  Fix them.  */
if|if
condition|(
name|slash
condition|)
while|while
condition|(
operator|*
operator|++
name|slash
condition|)
operator|*
name|slash
operator|=
name|TOLOWER
argument_list|(
operator|*
name|slash
argument_list|)
expr_stmt|;
name|instruction
operator|=
operator|(
specifier|const
expr|struct
name|h8_instruction
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|op_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We used to set input_line_pointer to the result of get_operands,      but that is wrong.  Our caller assumes we don't change it.  */
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAB
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAW
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAL
condition|)
name|get_mova_operands
argument_list|(
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_RTEL
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_RTSL
condition|)
name|get_rtsl_operands
argument_list|(
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
else|else
name|get_operands
argument_list|(
name|instruction
operator|->
name|noperands
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
operator|*
name|op_end
operator|=
name|c
expr_stmt|;
name|prev_instruction
operator|=
name|instruction
expr_stmt|;
comment|/* Now we have operands from instruction.      Let's check them out for ldm and stm.  */
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_LDM
condition|)
block|{
comment|/* The first operand must be @er7+, and the 	 second operand must be a register pair.  */
if|if
condition|(
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|!=
name|RSINC
operator|)
operator|||
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|!=
literal|7
operator|)
operator|||
operator|(
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand in ldm"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_STM
condition|)
block|{
comment|/* The first operand must be a register pair, 	 and the second operand must be @-er7.  */
if|if
condition|(
operator|(
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|!=
name|RDDEC
operator|)
operator|||
operator|(
name|operand
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
literal|7
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand in stm"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|SN
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
switch|switch
condition|(
name|TOLOWER
argument_list|(
operator|*
name|dot
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
name|size
operator|=
name|SB
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|size
operator|=
name|SW
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|size
operator|=
name|SL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAB
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAW
operator|||
name|OP_KIND
argument_list|(
name|instruction
operator|->
name|opcode
operator|->
name|how
argument_list|)
operator|==
name|O_MOVAL
condition|)
block|{
switch|switch
condition|(
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|&
name|MODE
condition|)
block|{
case|case
name|INDEXB
case|:
default|default:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXW
case|:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEXL
case|:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
name|operand
index|[
name|i
index|]
operator|.
name|mode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|SN
case|:
case|case
name|SB
case|:
default|default:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SW
case|:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SL
case|:
name|fix_operand_size
argument_list|(
operator|&
name|operand
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|instruction
operator|=
name|get_specific
argument_list|(
name|instruction
argument_list|,
name|operand
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands.  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|clever_message
argument_list|(
name|prev_instruction
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_bytes
argument_list|(
name|instruction
argument_list|,
name|operand
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|dwarf2_emit_insn
argument_list|(
name|instruction
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|tc_crawl_symbol_chain
parameter_list|(
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_crawl_symbol_chain \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|tc_headers_hook
parameter_list|(
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_headers_hook \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various routines to kill one day */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_function_decl
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_aout_fix_to_chars \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|,
else|#
directive|else
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|,
endif|#
directive|endif
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to md_convert_frag \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_size
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|register
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call tomd_estimate_size_before_relax \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|valueT
name|use
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|tc_reloc_mangle
parameter_list|(
name|fixS
modifier|*
name|fix_ptr
parameter_list|,
name|struct
name|internal_reloc
modifier|*
name|intr
parameter_list|,
name|bfd_vma
name|base
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbol_ptr
decl_stmt|;
name|symbol_ptr
operator|=
name|fix_ptr
operator|->
name|fx_addsy
expr_stmt|;
comment|/* If this relocation is attached to a symbol then it's ok      to output it.  */
if|if
condition|(
name|fix_ptr
operator|->
name|fx_r_type
operator|==
name|TC_CONS_RELOC
condition|)
block|{
comment|/* cons likes to create reloc32's whatever the size of the reloc..        */
switch|switch
condition|(
name|fix_ptr
operator|->
name|fx_size
condition|)
block|{
case|case
literal|4
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_RELLONG
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_RELWORD
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_RELBYTE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|intr
operator|->
name|r_type
operator|=
name|fix_ptr
operator|->
name|fx_r_type
expr_stmt|;
block|}
name|intr
operator|->
name|r_vaddr
operator|=
name|fix_ptr
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix_ptr
operator|->
name|fx_where
operator|+
name|base
expr_stmt|;
name|intr
operator|->
name|r_offset
operator|=
name|fix_ptr
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|symbol_ptr
condition|)
block|{
if|if
condition|(
name|symbol_ptr
operator|->
name|sy_number
operator|!=
operator|-
literal|1
condition|)
name|intr
operator|->
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|segsym
decl_stmt|;
comment|/* This case arises when a reference is made to `.'.  */
name|segsym
operator|=
name|seg_info
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_ptr
argument_list|)
argument_list|)
operator|->
name|dot
expr_stmt|;
if|if
condition|(
name|segsym
operator|==
name|NULL
condition|)
name|intr
operator|->
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|intr
operator|->
name|r_symndx
operator|=
name|segsym
operator|->
name|sy_number
expr_stmt|;
name|intr
operator|->
name|r_offset
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbol_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|intr
operator|->
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Difference of symbols in different sections is not supported"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|r_type
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
define|#
directive|define
name|DEBUG
value|0
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

