begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-d10v.c -- Assembler code for the Mitsubishi D10V    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/d10v.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"O"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Optimizing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AT_WORD_P
parameter_list|(
name|X
parameter_list|)
value|((X)->X_op == O_right_shift \&& (X)->X_op_symbol != NULL \&& symbol_constant_p ((X)->X_op_symbol) \&& S_GET_VALUE ((X)->X_op_symbol) == AT_WORD_RIGHT_SHIFT)
end_define

begin_define
define|#
directive|define
name|AT_WORD_RIGHT_SHIFT
value|2
end_define

begin_comment
comment|/* Fixups.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|5
end_define

begin_struct
struct|struct
name|d10v_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|operand
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|size
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|_fixups
block|{
name|int
name|fc
decl_stmt|;
name|struct
name|d10v_fixup
name|fix
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
name|struct
name|_fixups
modifier|*
name|next
decl_stmt|;
block|}
name|Fixups
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Fixups
name|FixUps
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Fixups
modifier|*
name|fixups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_not_ignore_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|packing_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PACK_UNSPEC
value|(0)
end_define

begin_comment
comment|/* Packing order not specified.  */
end_comment

begin_define
define|#
directive|define
name|PACK_PARALLEL
value|(1)
end_define

begin_comment
comment|/* "||"  */
end_comment

begin_define
define|#
directive|define
name|PACK_LEFT_RIGHT
value|(2)
end_define

begin_comment
comment|/* "->"  */
end_comment

begin_define
define|#
directive|define
name|PACK_RIGHT_LEFT
value|(3)
end_define

begin_comment
comment|/* "<-"  */
end_comment

begin_decl_stmt
specifier|static
name|packing_type
name|etype
init|=
name|PACK_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by d10v_cleanup.  */
end_comment

begin_comment
comment|/* TRUE if instruction swapping warnings should be inhibited.    --nowarnswap.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|flag_warn_suppress_instructionswap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if instruction packing should be performed when --gstabs is specified.    --gstabs-packing, --no-gstabs-packing.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|flag_allow_gstabs_packing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_enum
enum|enum
name|options
block|{
name|OPTION_NOWARNSWAP
init|=
name|OPTION_MD_BASE
block|,
name|OPTION_GSTABSPACKING
block|,
name|OPTION_NOGSTABSPACKING
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"nowarnswap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOWARNSWAP
block|}
block|,
block|{
literal|"gstabspacking"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GSTABSPACKING
block|}
block|,
block|{
literal|"gstabs-packing"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GSTABSPACKING
block|}
block|,
block|{
literal|"nogstabspacking"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOGSTABSPACKING
block|}
block|,
block|{
literal|"no-gstabs-packing"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOGSTABSPACKING
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|d10v_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a binary search of the d10v_predefined_registers array to see if    NAME is a valid regiter name.  Return the register number from the    array on success, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|d10v_reg_name_cnt
argument_list|()
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|d10v_predefined_registers
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|d10v_predefined_registers
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check the string at input_line_pointer    to see if it is a valid register name.  */
end_comment

begin_function
specifier|static
name|int
name|register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
comment|/* Temporarily store a pointer to the string here.  */
name|expressionP
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|input_line_pointer
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_range
parameter_list|(
name|unsigned
name|long
name|num
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Don't bother checking 16-bit values.  */
if|if
condition|(
name|bits
operator|==
literal|16
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_SHIFT
condition|)
block|{
comment|/* All special shift operands are unsigned and<= 16. 	 We allow 0 for now.  */
if|if
condition|(
name|num
operator|>
literal|16
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OPERAND_SIGNED
condition|)
block|{
comment|/* Signed 3-bit integers are restricted to the (-2, 3) range.  */
if|if
condition|(
name|flags
operator|&
name|RESTRICTED_NUM3
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|num
operator|<
operator|-
literal|2
operator|||
operator|(
name|long
operator|)
name|num
operator|>
literal|3
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|num
operator|>
name|max
operator|)
operator|||
operator|(
operator|(
name|long
operator|)
name|num
operator|<
name|min
operator|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|num
operator|>
name|max
operator|)
operator|||
operator|(
operator|(
name|long
operator|)
name|num
operator|<
name|min
operator|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"D10V options:\n\ -O                      Optimize.  Will do some operations in parallel.\n\ --gstabs-packing        Pack adjacent short instructions together even\n\                         when --gstabs is specified.  On by default.\n\ --no-gstabs-packing     If --gstabs is specified, do not pack adjacent\n\                         instructions together.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'O'
case|:
comment|/* Optimize. Will attempt to parallelize operations.  */
name|Optimizing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NOWARNSWAP
case|:
name|flag_warn_suppress_instructionswap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_GSTABSPACKING
case|:
name|flag_allow_gstabs_packing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NOGSTABSPACKING
case|:
name|flag_allow_gstabs_packing
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|struct
name|d10v_opcode
modifier|*
name|opcode
decl_stmt|;
name|d10v_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  The D10v instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
for|for
control|(
name|opcode
operator|=
operator|(
expr|struct
name|d10v_opcode
operator|*
operator|)
name|d10v_opcodes
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|opcode
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|d10v_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
name|fixups
operator|=
operator|&
name|FixUps
index|[
literal|0
index|]
expr_stmt|;
name|FixUps
index|[
literal|0
index|]
operator|.
name|next
operator|=
operator|&
name|FixUps
index|[
literal|1
index|]
expr_stmt|;
name|FixUps
index|[
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|FixUps
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the postincrement or postdecrement operator ( '+' or '-' )    from an expression.  */
end_comment

begin_function
specifier|static
name|int
name|postfix
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|'+'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|get_reloc
parameter_list|(
name|struct
name|d10v_operand
modifier|*
name|op
parameter_list|)
block|{
name|int
name|bits
init|=
name|op
operator|->
name|bits
decl_stmt|;
if|if
condition|(
name|bits
operator|<=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|op
operator|->
name|flags
operator|&
name|OPERAND_ADDR
condition|)
block|{
if|if
condition|(
name|bits
operator|==
literal|8
condition|)
return|return
name|BFD_RELOC_D10V_10_PCREL_R
return|;
else|else
return|return
name|BFD_RELOC_D10V_18_PCREL
return|;
block|}
return|return
name|BFD_RELOC_16
return|;
block|}
end_function

begin_comment
comment|/* Parse a string of operands.  Return an array of expressions.  */
end_comment

begin_function
specifier|static
name|int
name|get_operands
parameter_list|(
name|expressionS
name|exp
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|numops
init|=
literal|0
decl_stmt|;
name|int
name|post
init|=
literal|0
decl_stmt|;
name|int
name|uses_at
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'@'
condition|)
block|{
name|uses_at
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATPAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATMINUS
expr_stmt|;
block|}
else|else
block|{
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATSIGN
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|numops
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_PLUS
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|post
operator|=
name|postfix
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|numops
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* Just skip the trailing paren.  */
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
comment|/* Check to see if it might be a register name.  */
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
condition|)
block|{
comment|/* Parse as an expression.  */
if|if
condition|(
name|uses_at
condition|)
block|{
comment|/* Any expression that involves the indirect addressing 		 cannot also involve immediate addressing.  Therefore 		 the use of the hash character is illegal.  */
name|int
name|save
init|=
name|do_not_ignore_hash
decl_stmt|;
name|do_not_ignore_hash
operator|=
literal|1
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
expr_stmt|;
name|do_not_ignore_hash
operator|=
name|save
expr_stmt|;
block|}
else|else
name|expression
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@word"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
comment|/* If it looked like a register name but was followed by                  "@word" then it was really a symbol, so change it to                  one.  */
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exp
index|[
name|numops
index|]
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
block|}
comment|/* Check for identifier@word+constant.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'+'
condition|)
block|{
name|expressionS
name|new_exp
decl_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
block|}
comment|/* Convert expr into a right shift by AT_WORD_RIGHT_SHIFT.  */
block|{
name|expressionS
name|new_exp
decl_stmt|;
name|memset
argument_list|(
operator|&
name|new_exp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new_exp
argument_list|)
expr_stmt|;
name|new_exp
operator|.
name|X_add_number
operator|=
name|AT_WORD_RIGHT_SHIFT
expr_stmt|;
name|new_exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|new_exp
operator|.
name|X_unsigned
operator|=
literal|1
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_right_shift
expr_stmt|;
block|}
name|know
argument_list|(
name|AT_WORD_P
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|numops
operator|++
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
block|}
switch|switch
condition|(
name|post
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Postdecrement mode.  */
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_MINUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Postincrement mode.  */
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_PLUS
expr_stmt|;
break|break;
block|}
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
literal|0
expr_stmt|;
return|return
name|numops
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|d10v_insert_operand
parameter_list|(
name|unsigned
name|long
name|insn
parameter_list|,
name|int
name|op_type
parameter_list|,
name|offsetT
name|value
parameter_list|,
name|int
name|left
parameter_list|,
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
name|int
name|shift
decl_stmt|,
name|bits
decl_stmt|;
name|shift
operator|=
name|d10v_operands
index|[
name|op_type
index|]
operator|.
name|shift
expr_stmt|;
if|if
condition|(
name|left
condition|)
name|shift
operator|+=
literal|15
expr_stmt|;
name|bits
operator|=
name|d10v_operands
index|[
name|op_type
index|]
operator|.
name|bits
expr_stmt|;
comment|/* Truncate to the proper number of bits.  */
if|if
condition|(
name|check_range
argument_list|(
name|value
argument_list|,
name|bits
argument_list|,
name|d10v_operands
index|[
name|op_type
index|]
operator|.
name|flags
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|bits
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Take a pointer to the opcode entry in the opcode table and the    array of operand expressions.  Return the instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|build_insn
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|opcode
parameter_list|,
name|expressionS
modifier|*
name|opers
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|,
name|shift
decl_stmt|,
name|flags
decl_stmt|,
name|format
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
comment|/* The insn argument is only used for the DIVS kludge.  */
if|if
condition|(
name|insn
condition|)
name|format
operator|=
name|LONG_R
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|format
operator|=
name|opcode
operator|->
name|format
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opcode
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|bits
operator|=
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|bits
expr_stmt|;
name|shift
operator|=
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|shift
expr_stmt|;
name|number
operator|=
name|opers
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
name|number
operator|&=
name|REGISTER_MASK
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|LONG_L
condition|)
name|shift
operator|+=
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Now create a fixup.  */
if|if
condition|(
name|fixups
operator|->
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AT_WORD_P
argument_list|(
operator|&
name|opers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Recognize XXX>>1+N aka XXX@word+N as special (AT_WORD).  */
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_D10V_18
expr_stmt|;
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|opers
index|[
name|i
index|]
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Should free it.  */
comment|/* number is left shifted by AT_WORD_RIGHT_SHIFT so                  that, it is aligned with the symbol's value.  Later,                  BFD_RELOC_D10V_18 will right shift (symbol_value +                  X_add_number).  */
name|number
operator|<<=
name|AT_WORD_RIGHT_SHIFT
expr_stmt|;
name|opers
index|[
name|i
index|]
operator|.
name|X_add_number
operator|=
name|number
expr_stmt|;
block|}
else|else
block|{
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|=
name|get_reloc
argument_list|(
operator|(
expr|struct
name|d10v_operand
operator|*
operator|)
operator|&
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
comment|/* Check that an immediate was passed to ops that expect one.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|OPERAND_NUM
operator|)
operator|&&
operator|(
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|==
literal|0
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand is not an immediate"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_16
operator|||
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_18
condition|)
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|exp
operator|=
name|opers
index|[
name|i
index|]
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|operand
operator|=
name|opcode
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|pcrel
operator|=
operator|(
name|flags
operator|&
name|OPERAND_ADDR
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
operator|(
name|fixups
operator|->
name|fc
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Truncate to the proper number of bits.  */
if|if
condition|(
operator|(
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
name|check_range
argument_list|(
name|number
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand out of range: %lu"
argument_list|)
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|number
operator|&=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|bits
operator|)
expr_stmt|;
name|insn
operator|=
name|insn
operator||
operator|(
name|number
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
comment|/* kludge: for DIVS, we need to put the operands in twice on the second      pass, format is changed to LONG_R to force the second set of operands      to not be shifted over 15.  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|opcode
operator|==
name|OPCODE_DIVS
operator|)
operator|&&
operator|(
name|format
operator|==
name|LONG_L
operator|)
condition|)
name|insn
operator|=
name|build_insn
argument_list|(
name|opcode
argument_list|,
name|opers
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Write out a long form instruction.  */
end_comment

begin_function
specifier|static
name|void
name|write_long
parameter_list|(
name|unsigned
name|long
name|insn
parameter_list|,
name|Fixups
modifier|*
name|fx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|where
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|frag_more
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|insn
operator||=
name|FM11
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|2
condition|)
name|where
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_18
condition|)
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||=
literal|4096
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||
literal|2048
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a short form instruction by itself.  */
end_comment

begin_function
specifier|static
name|void
name|write_1_short
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|opcode
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|,
name|Fixups
modifier|*
name|fx
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|frag_more
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|where
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|exec_type
operator|&
name|PARONLY
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Instruction must be executed in parallel with another instruction."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The other container needs to be NOP.      According to 4.3.1: for FM=00, sub-instructions performed only by IU      cannot be encoded in L-container.  */
if|if
condition|(
name|opcode
operator|->
name|unit
operator|==
name|IU
condition|)
name|insn
operator||=
name|FM00
operator||
operator|(
name|NOP
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* Right container.  */
else|else
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn
operator|<<
literal|15
operator|)
operator||
name|NOP
expr_stmt|;
comment|/* Left container.  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|2
condition|)
name|where
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_18
condition|)
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||=
literal|4096
expr_stmt|;
comment|/* If it's an R reloc, we may have to switch it to L.  */
if|if
condition|(
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_10_PCREL_R
operator|)
operator|&&
operator|(
name|opcode
operator|->
name|unit
operator|!=
name|IU
operator|)
condition|)
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||=
literal|1024
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||
literal|2048
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if there are any resource conflicts among two manually    parallelized instructions.  Some of this was lifted from parallel_ok.  */
end_comment

begin_function
specifier|static
name|void
name|check_resource_conflict
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|op1
parameter_list|,
name|unsigned
name|long
name|insn1
parameter_list|,
name|struct
name|d10v_opcode
modifier|*
name|op2
parameter_list|,
name|unsigned
name|long
name|insn2
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|flags
decl_stmt|,
name|mask
decl_stmt|,
name|shift
decl_stmt|,
name|regno
decl_stmt|;
name|unsigned
name|long
name|ins
decl_stmt|,
name|mod
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|d10v_opcode
modifier|*
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|op1
operator|->
name|exec_type
operator|&
name|SEQ
operator|)
operator|||
operator|!
operator|(
operator|(
name|op1
operator|->
name|exec_type
operator|&
name|PAR
operator|)
operator|||
operator|(
name|op1
operator|->
name|exec_type
operator|&
name|PARONLY
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"packing conflict: %s must dispatch sequentially"
argument_list|)
argument_list|,
name|op1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|op2
operator|->
name|exec_type
operator|&
name|SEQ
operator|)
operator|||
operator|!
operator|(
operator|(
name|op2
operator|->
name|exec_type
operator|&
name|PAR
operator|)
operator|||
operator|(
name|op2
operator|->
name|exec_type
operator|&
name|PARONLY
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"packing conflict: %s must dispatch sequentially"
argument_list|)
argument_list|,
name|op2
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if both instructions write to the same resource.        The idea here is to create two sets of bitmasks (mod and used) which       indicate which registers are modified or used by each instruction.       The operation can only be done in parallel if neither instruction       modifies the same register. Accesses to control registers and memory       are treated as accesses to a single register. So if both instructions       write memory or if the first instruction writes memory and the second       reads, then they cannot be done in parallel. We treat reads to the PSW       (which includes C, F0, and F1) in isolation. So simultaneously writing       C and F0 in two different sub-instructions is permitted.  */
comment|/* The bitmasks (mod and used) look like this (bit 31 = MSB).      r0-r15	  0-15      a0-a1	  16-17      cr (not psw) 18      psw(other)   19      mem	  20      psw(C flag)  21      psw(F0 flag) 22  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|op
operator|=
name|op1
expr_stmt|;
name|ins
operator|=
name|insn1
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|op2
expr_stmt|;
name|ins
operator|=
name|insn2
expr_stmt|;
block|}
name|mod
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|BRANCH_LINK
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|13
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|op
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|shift
operator|=
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|shift
expr_stmt|;
name|mask
operator|=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|bits
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
name|regno
operator|=
operator|(
name|ins
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|OPERAND_ACC0
operator||
name|OPERAND_ACC1
operator|)
condition|)
name|regno
operator|+=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_CONTROL
condition|)
comment|/* mvtc or mvfc */
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|regno
operator|=
literal|19
expr_stmt|;
else|else
name|regno
operator|=
literal|18
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_FFLAG
condition|)
name|regno
operator|=
literal|22
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_CFLAG
condition|)
name|regno
operator|=
literal|21
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_DEST
comment|/* Auto inc/dec also modifies the register.  */
operator|||
operator|(
name|op
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
index|]
operator|.
name|flags
operator|&
operator|(
name|OPERAND_PLUS
operator||
name|OPERAND_MINUS
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_EVEN
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_ATMINUS
condition|)
block|{
comment|/* SP implicitly used/modified.  */
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|15
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WMEM
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WF0
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WCAR
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|21
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mod
index|[
literal|0
index|]
operator|&
name|mod
index|[
literal|1
index|]
operator|)
operator|==
literal|0
condition|)
return|return;
else|else
block|{
name|unsigned
name|long
name|x
decl_stmt|;
name|x
operator|=
name|mod
index|[
literal|0
index|]
operator|&
name|mod
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|15
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"resource conflict (R%d)"
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|16
init|;
name|j
operator|<=
literal|17
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"resource conflict (A%d)"
argument_list|)
argument_list|,
name|j
operator|-
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
literal|19
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"resource conflict (PSW)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
literal|21
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"resource conflict (C flag)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
literal|22
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"resource conflict (F flag)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check 2 instructions and determine if they can be safely    executed in parallel.  Return 1 if they can be.  */
end_comment

begin_function
specifier|static
name|int
name|parallel_ok
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|op1
parameter_list|,
name|unsigned
name|long
name|insn1
parameter_list|,
name|struct
name|d10v_opcode
modifier|*
name|op2
parameter_list|,
name|unsigned
name|long
name|insn2
parameter_list|,
name|packing_type
name|exec_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|flags
decl_stmt|,
name|mask
decl_stmt|,
name|shift
decl_stmt|,
name|regno
decl_stmt|;
name|unsigned
name|long
name|ins
decl_stmt|,
name|mod
index|[
literal|2
index|]
decl_stmt|,
name|used
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|d10v_opcode
modifier|*
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|op1
operator|->
name|exec_type
operator|&
name|SEQ
operator|)
operator|!=
literal|0
operator|||
operator|(
name|op2
operator|->
name|exec_type
operator|&
name|SEQ
operator|)
operator|!=
literal|0
operator|||
operator|(
name|op1
operator|->
name|exec_type
operator|&
name|PAR
operator|)
operator|==
literal|0
operator|||
operator|(
name|op2
operator|->
name|exec_type
operator|&
name|PAR
operator|)
operator|==
literal|0
operator|||
operator|(
name|op1
operator|->
name|unit
operator|==
name|BOTH
operator|)
operator|||
operator|(
name|op2
operator|->
name|unit
operator|==
name|BOTH
operator|)
operator|||
operator|(
name|op1
operator|->
name|unit
operator|==
name|IU
operator|&&
name|op2
operator|->
name|unit
operator|==
name|IU
operator|)
operator|||
operator|(
name|op1
operator|->
name|unit
operator|==
name|MU
operator|&&
name|op2
operator|->
name|unit
operator|==
name|MU
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If this is auto parallelization, and the first instruction is a      branch or should not be packed, then don't parallelize.  */
if|if
condition|(
name|exec_type
operator|==
name|PACK_UNSPEC
operator|&&
operator|(
name|op1
operator|->
name|exec_type
operator|&
operator|(
name|ALONE
operator||
name|BRANCH
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* The idea here is to create two sets of bitmasks (mod and used)      which indicate which registers are modified or used by each      instruction.  The operation can only be done in parallel if      instruction 1 and instruction 2 modify different registers, and      the first instruction does not modify registers that the second      is using (The second instruction can modify registers that the      first is using as they are only written back after the first      instruction has completed).  Accesses to control registers, PSW,      and memory are treated as accesses to a single register.  So if      both instructions write memory or if the first instruction writes      memory and the second reads, then they cannot be done in      parallel.  Likewise, if the first instruction mucks with the psw      and the second reads the PSW (which includes C, F0, and F1), then      they cannot operate safely in parallel.  */
comment|/* The bitmasks (mod and used) look like this (bit 31 = MSB).      r0-r15	  0-15      a0-a1	  16-17      cr (not psw) 18      psw	  19      mem	  20  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|op
operator|=
name|op1
expr_stmt|;
name|ins
operator|=
name|insn1
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|op2
expr_stmt|;
name|ins
operator|=
name|insn2
expr_stmt|;
block|}
name|mod
index|[
name|j
index|]
operator|=
name|used
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|BRANCH_LINK
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|13
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|op
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|shift
operator|=
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|shift
expr_stmt|;
name|mask
operator|=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|bits
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
name|regno
operator|=
operator|(
name|ins
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|OPERAND_ACC0
operator||
name|OPERAND_ACC1
operator|)
condition|)
name|regno
operator|+=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_CONTROL
condition|)
comment|/* mvtc or mvfc.  */
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|regno
operator|=
literal|19
expr_stmt|;
else|else
name|regno
operator|=
literal|18
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|OPERAND_FFLAG
operator||
name|OPERAND_CFLAG
operator|)
condition|)
name|regno
operator|=
literal|19
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_DEST
condition|)
block|{
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_EVEN
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|used
index|[
name|j
index|]
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_EVEN
condition|)
name|used
index|[
name|j
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Auto inc/dec also modifies the register.  */
if|if
condition|(
name|op
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|d10v_operands
index|[
name|op
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
index|]
operator|.
name|flags
operator|&
operator|(
name|OPERAND_PLUS
operator||
name|OPERAND_MINUS
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_ATMINUS
condition|)
block|{
comment|/* SP implicitly used/modified.  */
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|15
expr_stmt|;
name|used
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|15
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|RMEM
condition|)
name|used
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WMEM
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|RF0
condition|)
name|used
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WF0
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|exec_type
operator|&
name|WCAR
condition|)
name|mod
index|[
name|j
index|]
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mod
index|[
literal|0
index|]
operator|&
name|mod
index|[
literal|1
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mod
index|[
literal|0
index|]
operator|&
name|used
index|[
literal|1
index|]
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expects two short instructions.    If possible, writes out both as a single packed instruction.    Otherwise, writes out the first one, packed with a NOP.    Returns number of instructions not written out.  */
end_comment

begin_function
specifier|static
name|int
name|write_2_short
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|opcode1
parameter_list|,
name|unsigned
name|long
name|insn1
parameter_list|,
name|struct
name|d10v_opcode
modifier|*
name|opcode2
parameter_list|,
name|unsigned
name|long
name|insn2
parameter_list|,
name|packing_type
name|exec_type
parameter_list|,
name|Fixups
modifier|*
name|fx
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|where
decl_stmt|;
if|if
condition|(
operator|(
name|exec_type
operator|!=
name|PACK_PARALLEL
operator|)
operator|&&
operator|(
operator|(
name|opcode1
operator|->
name|exec_type
operator|&
name|PARONLY
operator|)
operator|||
operator|(
name|opcode2
operator|->
name|exec_type
operator|&
name|PARONLY
operator|)
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Instruction must be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opcode1
operator|->
name|format
operator|&
name|LONG_OPCODE
operator|)
operator|||
operator|(
name|opcode2
operator|->
name|format
operator|&
name|LONG_OPCODE
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Long instructions may not be combined."
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exec_type
condition|)
block|{
case|case
name|PACK_UNSPEC
case|:
comment|/* Order not specified.  */
if|if
condition|(
name|opcode1
operator|->
name|exec_type
operator|&
name|ALONE
condition|)
block|{
comment|/* Case of a short branch on a separate GAS line.  Pack with NOP.  */
name|write_1_short
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|fx
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|Optimizing
operator|&&
name|parallel_ok
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|opcode2
argument_list|,
name|insn2
argument_list|,
name|exec_type
argument_list|)
condition|)
block|{
comment|/* Parallel.  */
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|==
name|IU
condition|)
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode2
operator|->
name|unit
operator|==
name|MU
condition|)
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
else|else
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn1
operator|<<
literal|15
operator|)
operator||
name|insn2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|==
name|IU
condition|)
comment|/* Reverse sequential with IU opcode1 on right and done first.  */
name|insn
operator|=
name|FM10
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
else|else
comment|/* Sequential with non-IU opcode1 on left and done first.  */
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn1
operator|<<
literal|15
operator|)
operator||
name|insn2
expr_stmt|;
break|break;
case|case
name|PACK_PARALLEL
case|:
if|if
condition|(
name|opcode1
operator|->
name|exec_type
operator|&
name|SEQ
operator|||
name|opcode2
operator|->
name|exec_type
operator|&
name|SEQ
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"One of these instructions may not be executed in parallel."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|==
name|IU
condition|)
block|{
if|if
condition|(
name|opcode2
operator|->
name|unit
operator|==
name|IU
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Two IU instructions may not be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_warn_suppress_instructionswap
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode2
operator|->
name|unit
operator|==
name|MU
condition|)
block|{
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|==
name|MU
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Two MU instructions may not be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_warn_suppress_instructionswap
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
block|}
else|else
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn1
operator|<<
literal|15
operator|)
operator||
name|insn2
expr_stmt|;
name|check_resource_conflict
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|opcode2
argument_list|,
name|insn2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACK_LEFT_RIGHT
case|:
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|!=
name|IU
condition|)
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn1
operator|<<
literal|15
operator|)
operator||
name|insn2
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode2
operator|->
name|unit
operator|==
name|MU
operator|||
name|opcode2
operator|->
name|unit
operator|==
name|EITHER
condition|)
block|{
if|if
condition|(
operator|!
name|flag_warn_suppress_instructionswap
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM10
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"IU instruction may not be in the left container"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode1
operator|->
name|exec_type
operator|&
name|ALONE
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction in R container is squashed by flow control instruction in L container."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACK_RIGHT_LEFT
case|:
if|if
condition|(
name|opcode2
operator|->
name|unit
operator|!=
name|MU
condition|)
name|insn
operator|=
name|FM10
operator||
operator|(
name|insn1
operator|<<
literal|15
operator|)
operator||
name|insn2
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode1
operator|->
name|unit
operator|==
name|IU
operator|||
name|opcode1
operator|->
name|unit
operator|==
name|EITHER
condition|)
block|{
if|if
condition|(
operator|!
name|flag_warn_suppress_instructionswap
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn2
operator|<<
literal|15
operator|)
operator||
name|insn1
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"MU instruction may not be in the right container"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode2
operator|->
name|exec_type
operator|&
name|ALONE
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction in R container is squashed by flow control instruction in L container."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown execution type passed to write_2_short()"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Process fixup chains.  fx refers to insn2 when j == 0, and to      insn1 when j == 1.  Yes, it's reversed.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|2
condition|)
name|where
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_10_PCREL_R
comment|/* A BFD_RELOC_D10V_10_PCREL_R relocation applied to 		     the instruction in the L container has to be 		     adjusted to BDF_RELOC_D10V_10_PCREL_L.  When 		     j==0, we're processing insn2's operands, so we 		     want to mark the operand if insn2 is *not* in the 		     R container.  When j==1, we're processing insn1's 		     operands, so we want to mark the operand if insn2 		     *is* in the R container.  Note that, if two 		     instructions are identical, we're never going to 		     swap them, so the test is safe.  */
operator|&&
name|j
operator|==
operator|(
operator|(
name|insn
operator|&
literal|0x7fff
operator|)
operator|==
name|insn2
operator|)
condition|)
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||=
literal|1024
expr_stmt|;
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D10V_18
condition|)
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||=
literal|4096
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|operand
operator||
literal|2048
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is the main entry point for the machine-dependent assembler.    str points to a machine-dependent instruction.  This function is    supposed to emit the frags/bytes it assembles to.  For the D10V, it    mostly handles the special VLIW parsing and packing and leaves the    difficult stuff to do_assemble().  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|d10v_opcode
modifier|*
name|prev_opcode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|subsegT
name|prev_subseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|prev_seg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Find the symbol which has the same name as the register in exp.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|find_symbol_matching_register
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_register
condition|)
return|return
name|NULL
return|;
comment|/* Find the name of the register.  */
for|for
control|(
name|i
operator|=
name|d10v_reg_name_cnt
argument_list|()
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|d10v_predefined_registers
index|[
name|i
index|]
operator|.
name|value
operator|==
name|exp
operator|->
name|X_add_number
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now see if a symbol has been defined with the same name.  */
return|return
name|symbol_find
argument_list|(
name|d10v_predefined_registers
index|[
name|i
index|]
operator|.
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a pointer to an entry in the opcode table.    The function must look at all opcodes with the same name and use    the operands to choose the correct opcode.  */
end_comment

begin_function
specifier|static
name|struct
name|d10v_opcode
modifier|*
name|find_opcode
parameter_list|(
name|struct
name|d10v_opcode
modifier|*
name|opcode
parameter_list|,
name|expressionS
name|myops
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|match
decl_stmt|;
name|struct
name|d10v_opcode
modifier|*
name|next_opcode
decl_stmt|;
comment|/* Get all the operands and save them as expressions.  */
name|get_operands
argument_list|(
name|myops
argument_list|)
expr_stmt|;
comment|/* Now see if the operand is a fake.  If so, find the correct size      instruction, if possible.  */
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|OPCODE_FAKE
condition|)
block|{
name|int
name|opnum
init|=
name|opcode
operator|->
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
operator|(
name|char
operator|*
operator|)
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
comment|/* If the first operand is supposed to be a register, make sure 	 we got a valid one.  */
name|flags
operator|=
name|d10v_operands
index|[
name|next_opcode
operator|->
name|operands
index|[
literal|0
index|]
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
name|int
name|X_op
init|=
name|myops
index|[
literal|0
index|]
operator|.
name|X_op
decl_stmt|;
name|int
name|num
init|=
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|X_op
operator|!=
name|O_register
operator|||
operator|(
name|num
operator|&
operator|~
name|flags
operator|&
operator|(
name|OPERAND_GPR
operator||
name|OPERAND_ACC0
operator||
name|OPERAND_ACC1
operator||
name|OPERAND_FFLAG
operator||
name|OPERAND_CFLAG
operator||
name|OPERAND_CONTROL
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_SP
operator|)
operator|&&
operator|!
operator|(
name|num
operator|&
name|OPERAND_SP
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad opcode or operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
operator|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|S_IS_DEFINED
argument_list|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opcode
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bits
init|=
name|d10v_operands
index|[
name|next_opcode
operator|->
name|operands
index|[
name|opnum
index|]
index|]
operator|.
name|bits
decl_stmt|;
name|int
name|flags
init|=
name|d10v_operands
index|[
name|next_opcode
operator|->
name|operands
index|[
name|opnum
index|]
index|]
operator|.
name|flags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_ADDR
condition|)
name|bits
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_number
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
name|unsigned
name|long
name|current_position
decl_stmt|;
name|unsigned
name|long
name|symbol_position
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|bfd_boolean
name|found_symbol
decl_stmt|;
comment|/* Calculate the address of the current instruction 		     and the address of the symbol.  Do this by summing 		     the offsets of previous frags until we reach the 		     frag containing the symbol, and the current frag.  */
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|found_symbol
operator|=
name|FALSE
expr_stmt|;
name|current_position
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|symbol_position
operator|=
name|S_GET_VALUE
argument_list|(
name|myops
index|[
name|opnum
index|]
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
name|current_position
operator|+=
name|f
operator|->
name|fr_fix
operator|+
name|f
operator|->
name|fr_offset
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|sym_frag
condition|)
name|found_symbol
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|found_symbol
condition|)
name|symbol_position
operator|+=
name|f
operator|->
name|fr_fix
operator|+
name|f
operator|->
name|fr_offset
expr_stmt|;
block|}
name|value
operator|=
name|symbol_position
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_ADDR
condition|)
name|value
operator|-=
name|current_position
expr_stmt|;
if|if
condition|(
name|AT_WORD_P
argument_list|(
operator|&
name|myops
index|[
name|opnum
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|bits
operator|>
literal|4
condition|)
block|{
name|bits
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|value
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|value
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
break|break;
block|}
name|next_opcode
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|->
name|operands
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"value out of range"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|opcode
operator|=
name|next_opcode
expr_stmt|;
block|}
else|else
comment|/* Not a constant, so use a long instruction.  */
name|opcode
operator|+=
literal|2
expr_stmt|;
block|}
name|match
operator|=
literal|0
expr_stmt|;
comment|/* Now search the opcode table table for one with operands      that matches what we've got.  */
while|while
condition|(
operator|!
name|match
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opcode
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flags
init|=
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
decl_stmt|;
name|int
name|X_op
init|=
name|myops
index|[
name|i
index|]
operator|.
name|X_op
decl_stmt|;
name|int
name|num
init|=
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|X_op
operator|==
literal|0
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
if|if
condition|(
operator|(
name|X_op
operator|!=
name|O_register
operator|)
operator|||
operator|(
name|num
operator|&
operator|~
name|flags
operator|&
operator|(
name|OPERAND_GPR
operator||
name|OPERAND_ACC0
operator||
name|OPERAND_ACC1
operator||
name|OPERAND_FFLAG
operator||
name|OPERAND_CFLAG
operator||
name|OPERAND_CONTROL
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_SP
operator|)
operator|&&
operator|!
operator|(
name|num
operator|&
name|OPERAND_SP
operator|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|OPERAND_MINUS
operator|)
operator|&&
operator|(
operator|(
name|X_op
operator|!=
name|O_absent
operator|)
operator|||
operator|(
name|num
operator|!=
name|OPERAND_MINUS
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_PLUS
operator|)
operator|&&
operator|(
operator|(
name|X_op
operator|!=
name|O_absent
operator|)
operator|||
operator|(
name|num
operator|!=
name|OPERAND_PLUS
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATMINUS
operator|)
operator|&&
operator|(
operator|(
name|X_op
operator|!=
name|O_absent
operator|)
operator|||
operator|(
name|num
operator|!=
name|OPERAND_ATMINUS
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATPAR
operator|)
operator|&&
operator|(
operator|(
name|X_op
operator|!=
name|O_absent
operator|)
operator|||
operator|(
name|num
operator|!=
name|OPERAND_ATPAR
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATSIGN
operator|)
operator|&&
operator|(
operator|(
name|X_op
operator|!=
name|O_absent
operator|)
operator|||
operator|(
operator|(
name|num
operator|!=
name|OPERAND_ATSIGN
operator|)
operator|&&
operator|(
name|num
operator|!=
name|OPERAND_ATPAR
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Unfortunately, for the indirect operand in instructions such 	     as ``ldb r1, @(c,r14)'' this function can be passed 	     X_op == O_register (because 'c' is a valid register name). 	     However we cannot just ignore the case when X_op == O_register 	     but flags& OPERAND_REG is null, so we check to see if a symbol 	     of the same name as the register exists.  If the symbol does 	     exist, then the parser was unable to distinguish the two cases 	     and we fix things here. (Ref: PR14826)  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OPERAND_REG
operator|)
operator|&&
operator|(
name|X_op
operator|==
name|O_register
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|find_symbol_matching_register
argument_list|(
operator|&
name|myops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|myops
index|[
name|i
index|]
operator|.
name|X_op
operator|=
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|myops
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand - register name found where none expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're only done if the operands matched so far AND there 	     are no more to check.  */
if|if
condition|(
name|match
operator|&&
name|myops
index|[
name|i
index|]
operator|.
name|X_op
operator|==
literal|0
condition|)
break|break;
else|else
name|match
operator|=
literal|0
expr_stmt|;
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next_opcode
operator|->
name|opcode
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|next_opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
break|break;
name|opcode
operator|=
name|next_opcode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad opcode or operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check that all registers that are required to be even are.      Also, if any operands were marked as registers, but were really symbols,      fix that here.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opcode
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
operator|&
name|OPERAND_EVEN
operator|)
operator|&&
operator|(
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|&
literal|1
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Register number must be EVEN"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
operator|&
name|OPERAND_NOSP
operator|)
operator|&&
operator|(
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|&
name|OPERAND_SP
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of sp"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|myops
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
operator|&
name|OPERAND_REG
operator|)
condition|)
block|{
name|myops
index|[
name|i
index|]
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|myops
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
operator|(
name|char
operator|*
operator|)
name|myops
index|[
name|i
index|]
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|myops
index|[
name|i
index|]
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|d10v_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
operator|&
name|OPERAND_CONTROL
operator|)
operator|&&
operator|(
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|4
operator|||
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|5
operator|||
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|6
operator|||
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|12
operator|||
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|13
operator|||
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
literal|15
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"cr%ld is a reserved control register"
argument_list|)
argument_list|,
name|myops
index|[
name|i
index|]
operator|.
name|X_add_number
operator|-
name|OPERAND_CONTROL
argument_list|)
expr_stmt|;
block|}
return|return
name|opcode
return|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction.    Return an opcode, or -1 (an invalid opcode) on error.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|do_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|d10v_opcode
modifier|*
modifier|*
name|opcode
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|op_start
decl_stmt|,
modifier|*
name|op_end
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
name|expressionS
name|myops
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the opcode end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
literal|20
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
name|name
index|[
name|nlen
index|]
operator|=
name|TOLOWER
argument_list|(
name|op_start
index|[
name|nlen
index|]
argument_list|)
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Find the first opcode with the proper name.  */
operator|*
name|opcode
operator|=
operator|(
expr|struct
name|d10v_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|d10v_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown opcode: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|op_end
expr_stmt|;
operator|*
name|opcode
operator|=
name|find_opcode
argument_list|(
operator|*
name|opcode
argument_list|,
name|myops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
name|insn
operator|=
name|build_insn
argument_list|(
operator|(
operator|*
name|opcode
operator|)
argument_list|,
name|myops
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created.    Then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|long
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* We don't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|op_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|op_type
operator|&
literal|2048
condition|)
block|{
name|op_type
operator|-=
literal|2048
expr_stmt|;
if|if
condition|(
name|op_type
operator|&
literal|1024
condition|)
block|{
name|op_type
operator|-=
literal|1024
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_D10V_10_PCREL_L
expr_stmt|;
name|left
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_type
operator|&
literal|4096
condition|)
block|{
name|op_type
operator|-=
literal|4096
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_D10V_18
expr_stmt|;
block|}
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|get_reloc
argument_list|(
operator|(
expr|struct
name|d10v_operand
operator|*
operator|)
operator|&
name|d10v_operands
index|[
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch the instruction, insert the fully resolved operand      value, and stuff the instruction back again.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_D10V_10_PCREL_L
case|:
case|case
name|BFD_RELOC_D10V_10_PCREL_R
case|:
case|case
name|BFD_RELOC_D10V_18_PCREL
case|:
comment|/* If the fix is relative to a global symbol, not a section 	 symbol, then ignore the offset.          XXX - Do we have to worry about branches to a symbol + offset ?  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|segT
name|fseg
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|segf
init|=
name|seg_info
argument_list|(
name|fseg
argument_list|)
decl_stmt|;
if|if
condition|(
name|segf
operator|&&
name|segf
operator|->
name|sym
operator|!=
name|fixP
operator|->
name|fx_addsy
condition|)
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Drop through.  */
case|case
name|BFD_RELOC_D10V_18
case|:
comment|/* Instruction addresses are always right-shifted by 2.  */
name|value
operator|>>=
name|AT_WORD_RIGHT_SHIFT
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|d10v_opcode
modifier|*
name|rep
decl_stmt|,
modifier|*
name|repi
decl_stmt|;
name|rep
operator|=
operator|(
expr|struct
name|d10v_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|d10v_hash
argument_list|,
literal|"rep"
argument_list|)
expr_stmt|;
name|repi
operator|=
operator|(
expr|struct
name|d10v_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|d10v_hash
argument_list|,
literal|"repi"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|FM11
operator|)
operator|==
name|FM11
operator|&&
operator|(
operator|(
name|repi
operator|!=
name|NULL
operator|&&
operator|(
name|insn
operator|&
name|repi
operator|->
name|mask
operator|)
operator|==
operator|(
name|unsigned
operator|)
name|repi
operator|->
name|opcode
operator|)
operator|||
operator|(
name|rep
operator|!=
name|NULL
operator|&&
operator|(
name|insn
operator|&
name|rep
operator|->
name|mask
operator|)
operator|==
operator|(
name|unsigned
operator|)
name|rep
operator|->
name|opcode
operator|)
operator|)
operator|&&
name|value
operator|<
literal|4
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"line %d: rep or repi must include at least 4 instructions"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator|=
name|d10v_insert_operand
argument_list|(
name|insn
argument_list|,
name|op_type
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|left
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_32
case|:
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"line %d: unknown relocation type: 0x%x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* d10v_cleanup() is called after the assembler has finished parsing    the input file, when a label is read from the input file, or when a    stab directive is output.  Because the D10V assembler sometimes    saves short instructions to see if it can package them with the    next instruction, there may be a short instruction that still needs    to be written.     NOTE: accesses a global, etype.    NOTE: invoked by various macros such as md_cleanup: see.  */
end_comment

begin_function
name|int
name|d10v_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
comment|/* If cleanup was invoked because the assembler encountered, e.g., a      user label, we write out the pending instruction, if any.  If it      was invoked because the assembler is outputting a piece of line      debugging information, though, we write out the pending      instruction only if the --no-gstabs-packing command line switch      has been specified.  */
if|if
condition|(
name|prev_opcode
operator|&&
name|etype
operator|==
name|PACK_UNSPEC
operator|&&
operator|(
operator|!
name|outputting_stabs_line_debug
operator|||
operator|!
name|flag_allow_gstabs_packing
operator|)
condition|)
block|{
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|prev_seg
condition|)
name|subseg_set
argument_list|(
name|prev_seg
argument_list|,
name|prev_subseg
argument_list|)
expr_stmt|;
name|write_1_short
argument_list|(
name|prev_opcode
argument_list|,
name|prev_insn
argument_list|,
name|fixups
operator|->
name|next
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|prev_opcode
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like normal .word, except support @word.    Clobbers input_line_pointer, checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|d10v_dot_word
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"@word"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_D10V_18
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mitsubishi asked that we support some old syntax that apparently    had immediate operands starting with '#'.  This is in some of their    sample code but is not documented (although it appears in some    examples in their assembler manual). For now, we'll solve this    compatibility problem by simply ignoring any '#' at the beginning    of an operand.  */
end_comment

begin_comment
comment|/* Operands that begin with '#' should fall through to here.    From expr.c.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
operator|&&
operator|!
name|do_not_ignore_hash
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bfd_boolean
name|d10v_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|d10v_dot_word
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* etype is saved extype.  For multi-line instructions.  */
name|packing_type
name|extype
init|=
name|PACK_UNSPEC
decl_stmt|;
comment|/* Parallel, etc.  */
name|struct
name|d10v_opcode
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
if|if
condition|(
name|etype
operator|==
name|PACK_UNSPEC
condition|)
block|{
comment|/* Look for the special multiple instruction separators.  */
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
name|extype
operator|=
name|PACK_PARALLEL
expr_stmt|;
else|else
block|{
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
name|extype
operator|=
name|PACK_LEFT_RIGHT
expr_stmt|;
else|else
block|{
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"<-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
name|extype
operator|=
name|PACK_RIGHT_LEFT
expr_stmt|;
block|}
block|}
comment|/* str2 points to the separator, if there is one.  */
if|if
condition|(
name|str2
condition|)
block|{
operator|*
name|str2
operator|=
literal|0
expr_stmt|;
comment|/* If two instructions are present and we already have one saved, 	     then first write out the saved one.  */
name|d10v_cleanup
argument_list|()
expr_stmt|;
comment|/* Assemble first instruction and save it.  */
name|prev_insn
operator|=
name|do_assemble
argument_list|(
name|str
argument_list|,
operator|&
name|prev_opcode
argument_list|)
expr_stmt|;
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|prev_insn
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|str
operator|=
name|str2
operator|+
literal|2
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|do_assemble
argument_list|(
name|str
argument_list|,
operator|&
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|extype
operator|!=
name|PACK_UNSPEC
condition|)
block|{
name|etype
operator|=
name|extype
expr_stmt|;
return|return;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etype
operator|!=
name|PACK_UNSPEC
condition|)
block|{
name|extype
operator|=
name|etype
expr_stmt|;
name|etype
operator|=
name|PACK_UNSPEC
expr_stmt|;
block|}
comment|/* If this is a long instruction, write it and any previous short      instruction.  */
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|LONG_OPCODE
condition|)
block|{
if|if
condition|(
name|extype
operator|!=
name|PACK_UNSPEC
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to mix instructions as specified"
argument_list|)
argument_list|)
expr_stmt|;
name|d10v_cleanup
argument_list|()
expr_stmt|;
name|write_long
argument_list|(
name|insn
argument_list|,
name|fixups
argument_list|)
expr_stmt|;
name|prev_opcode
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prev_opcode
operator|&&
name|prev_seg
operator|&&
operator|(
operator|(
name|prev_seg
operator|!=
name|now_seg
operator|)
operator|||
operator|(
name|prev_subseg
operator|!=
name|now_subseg
operator|)
operator|)
condition|)
name|d10v_cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev_opcode
operator|&&
operator|(
literal|0
operator|==
name|write_2_short
argument_list|(
name|prev_opcode
argument_list|,
name|prev_insn
argument_list|,
name|opcode
argument_list|,
name|insn
argument_list|,
name|extype
argument_list|,
name|fixups
argument_list|)
operator|)
condition|)
block|{
comment|/* No instructions saved.  */
name|prev_opcode
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|extype
operator|!=
name|PACK_UNSPEC
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to mix instructions as specified"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save last instruction so it may be packed on next pass.  */
name|prev_opcode
operator|=
name|opcode
expr_stmt|;
name|prev_insn
operator|=
name|insn
expr_stmt|;
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

