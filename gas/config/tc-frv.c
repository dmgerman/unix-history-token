begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-frv.c -- Assembler for the Fujitsu FRV.    Copyright 2002, 2003, 2004, 2005, 2006 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/frv-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/frv-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/frv.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|frv_insn
typedef|;
end_typedef

begin_enum
enum|enum
name|vliw_insn_type
block|{
name|VLIW_GENERIC_TYPE
block|,
comment|/* Don't care about this insn.  */
name|VLIW_BRANCH_TYPE
block|,
comment|/* A Branch.  */
name|VLIW_LABEL_TYPE
block|,
comment|/* A Label.  */
name|VLIW_NOP_TYPE
block|,
comment|/* A NOP.  */
name|VLIW_BRANCH_HAS_NOPS
comment|/* A Branch that requires NOPS.  */
block|}
enum|;
end_enum

begin_comment
comment|/* We're going to use these in the fr_subtype field to mark     whether to keep inserted nops.  */
end_comment

begin_define
define|#
directive|define
name|NOP_KEEP
value|1
end_define

begin_comment
comment|/* Keep these NOPS.  */
end_comment

begin_define
define|#
directive|define
name|NOP_DELETE
value|2
end_define

begin_comment
comment|/* Delete these NOPS.  */
end_comment

begin_define
define|#
directive|define
name|DO_COUNT
value|TRUE
end_define

begin_define
define|#
directive|define
name|DONT_COUNT
value|FALSE
end_define

begin_comment
comment|/* A list of insns within a VLIW insn.  */
end_comment

begin_struct
struct|struct
name|vliw_insn_list
block|{
comment|/*  The type of this insn.  */
name|enum
name|vliw_insn_type
name|type
decl_stmt|;
comment|/*  The corresponding gas insn information.  */
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
comment|/*  For branches and labels, the symbol that is referenced.  */
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/*  For branches, the frag containing the single nop that was generated.  */
name|fragS
modifier|*
name|snop_frag
decl_stmt|;
comment|/*  For branches, the frag containing the double nop that was generated.  */
name|fragS
modifier|*
name|dnop_frag
decl_stmt|;
comment|/*  Pointer to raw data for this insn.  */
name|char
modifier|*
name|address
decl_stmt|;
comment|/* Next insn in list.  */
name|struct
name|vliw_insn_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vliw_insn_list
name|single_nop_insn
init|=
block|{
name|VLIW_NOP_TYPE
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vliw_insn_list
name|double_nop_insn
init|=
block|{
name|VLIW_NOP_TYPE
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vliw_chain
block|{
name|int
name|num
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|insn_list
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vliw_chain
modifier|*
name|vliw_chain_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vliw_chain
modifier|*
name|current_vliw_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vliw_chain
modifier|*
name|previous_vliw_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vliw_insn_list
modifier|*
name|current_vliw_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRV_VLIW
name|vliw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default machine */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_FRV
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_frv
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_GENERIC
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_FR300
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_fr300
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_FR300
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_SIMPLE
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_frvsimple
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_SIMPLE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_TOMCAT
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_frvtomcat
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_TOMCAT
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_FR400
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_fr400
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_FR400
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CPU_FR550
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_fr550
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_FR550
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_fr500
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_FRV_CPU_FR500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TE_LINUX
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_FDPIC
value|EF_FRV_FDPIC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_FDPIC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|frv_mach
init|=
name|bfd_mach_frv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|fr400_audio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to set in the elf header */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|frv_flags
init|=
name|DEFAULT_FLAGS
operator||
name|DEFAULT_FDPIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_user_set_flags_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_pic_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|frv_pic_flag
init|=
name|DEFAULT_FDPIC
condition|?
literal|"-mfdpic"
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print tomcat-specific debugging info.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tomcat_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tomcat-specific NOP statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tomcat_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tomcat_doubles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tomcat_singles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward reference to static functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|frv_set_flags
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_pic_ptr
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_frob_file_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"eflags"
block|,
name|frv_set_flags
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"picptr"
block|,
name|frv_pic_ptr
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|FRV_SHORTOPTS
value|"G:"
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|FRV_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_GPR_32
value|(OPTION_MD_BASE)
end_define

begin_define
define|#
directive|define
name|OPTION_GPR_64
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_FPR_32
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_FPR_64
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_SOFT_FLOAT
value|(OPTION_MD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|OPTION_DWORD_YES
value|(OPTION_MD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|OPTION_DWORD_NO
value|(OPTION_MD_BASE + 6)
end_define

begin_define
define|#
directive|define
name|OPTION_DOUBLE
value|(OPTION_MD_BASE + 7)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_DOUBLE
value|(OPTION_MD_BASE + 8)
end_define

begin_define
define|#
directive|define
name|OPTION_MEDIA
value|(OPTION_MD_BASE + 9)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_MEDIA
value|(OPTION_MD_BASE + 10)
end_define

begin_define
define|#
directive|define
name|OPTION_CPU
value|(OPTION_MD_BASE + 11)
end_define

begin_define
define|#
directive|define
name|OPTION_PIC
value|(OPTION_MD_BASE + 12)
end_define

begin_define
define|#
directive|define
name|OPTION_BIGPIC
value|(OPTION_MD_BASE + 13)
end_define

begin_define
define|#
directive|define
name|OPTION_LIBPIC
value|(OPTION_MD_BASE + 14)
end_define

begin_define
define|#
directive|define
name|OPTION_MULADD
value|(OPTION_MD_BASE + 15)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_MULADD
value|(OPTION_MD_BASE + 16)
end_define

begin_define
define|#
directive|define
name|OPTION_TOMCAT_DEBUG
value|(OPTION_MD_BASE + 17)
end_define

begin_define
define|#
directive|define
name|OPTION_TOMCAT_STATS
value|(OPTION_MD_BASE + 18)
end_define

begin_define
define|#
directive|define
name|OPTION_PACK
value|(OPTION_MD_BASE + 19)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_PACK
value|(OPTION_MD_BASE + 20)
end_define

begin_define
define|#
directive|define
name|OPTION_FDPIC
value|(OPTION_MD_BASE + 21)
end_define

begin_define
define|#
directive|define
name|OPTION_NOPIC
value|(OPTION_MD_BASE + 22)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mgpr-32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GPR_32
block|}
block|,
block|{
literal|"mgpr-64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GPR_64
block|}
block|,
block|{
literal|"mfpr-32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FPR_32
block|}
block|,
block|{
literal|"mfpr-64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FPR_64
block|}
block|,
block|{
literal|"mhard-float"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FPR_64
block|}
block|,
block|{
literal|"msoft-float"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SOFT_FLOAT
block|}
block|,
block|{
literal|"mdword"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DWORD_YES
block|}
block|,
block|{
literal|"mno-dword"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DWORD_NO
block|}
block|,
block|{
literal|"mdouble"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DOUBLE
block|}
block|,
block|{
literal|"mno-double"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DOUBLE
block|}
block|,
block|{
literal|"mmedia"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MEDIA
block|}
block|,
block|{
literal|"mno-media"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MEDIA
block|}
block|,
block|{
literal|"mcpu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU
block|}
block|,
block|{
literal|"mpic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
block|{
literal|"mPIC"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIGPIC
block|}
block|,
block|{
literal|"mlibrary-pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LIBPIC
block|}
block|,
block|{
literal|"mmuladd"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MULADD
block|}
block|,
block|{
literal|"mno-muladd"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MULADD
block|}
block|,
block|{
literal|"mtomcat-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TOMCAT_DEBUG
block|}
block|,
block|{
literal|"mtomcat-stats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TOMCAT_STATS
block|}
block|,
block|{
literal|"mpack"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PACK
block|}
block|,
block|{
literal|"mno-pack"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_PACK
block|}
block|,
block|{
literal|"mfdpic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FDPIC
block|}
block|,
block|{
literal|"mnopic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOPIC
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What value to give to bfd_set_gp_size.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
literal|'G'
case|:
name|g_switch_value
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_switch_value
condition|)
name|frv_flags
operator||=
name|EF_FRV_G0
expr_stmt|;
break|break;
case|case
name|OPTION_GPR_32
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_GPR_MASK
operator|)
operator||
name|EF_FRV_GPR_32
expr_stmt|;
break|break;
case|case
name|OPTION_GPR_64
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_GPR_MASK
operator|)
operator||
name|EF_FRV_GPR_64
expr_stmt|;
break|break;
case|case
name|OPTION_FPR_32
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_FPR_MASK
operator|)
operator||
name|EF_FRV_FPR_32
expr_stmt|;
break|break;
case|case
name|OPTION_FPR_64
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_FPR_MASK
operator|)
operator||
name|EF_FRV_FPR_64
expr_stmt|;
break|break;
case|case
name|OPTION_SOFT_FLOAT
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_FPR_MASK
operator|)
operator||
name|EF_FRV_FPR_NONE
expr_stmt|;
break|break;
case|case
name|OPTION_DWORD_YES
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_DWORD_MASK
operator|)
operator||
name|EF_FRV_DWORD_YES
expr_stmt|;
break|break;
case|case
name|OPTION_DWORD_NO
case|:
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_DWORD_MASK
operator|)
operator||
name|EF_FRV_DWORD_NO
expr_stmt|;
break|break;
case|case
name|OPTION_DOUBLE
case|:
name|frv_flags
operator||=
name|EF_FRV_DOUBLE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DOUBLE
case|:
name|frv_flags
operator|&=
operator|~
name|EF_FRV_DOUBLE
expr_stmt|;
break|break;
case|case
name|OPTION_MEDIA
case|:
name|frv_flags
operator||=
name|EF_FRV_MEDIA
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MEDIA
case|:
name|frv_flags
operator|&=
operator|~
name|EF_FRV_MEDIA
expr_stmt|;
break|break;
case|case
name|OPTION_MULADD
case|:
name|frv_flags
operator||=
name|EF_FRV_MULADD
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MULADD
case|:
name|frv_flags
operator|&=
operator|~
name|EF_FRV_MULADD
expr_stmt|;
break|break;
case|case
name|OPTION_PACK
case|:
name|frv_flags
operator|&=
operator|~
name|EF_FRV_NOPACK
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PACK
case|:
name|frv_flags
operator||=
name|EF_FRV_NOPACK
expr_stmt|;
break|break;
case|case
name|OPTION_CPU
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|cpu_flags
init|=
name|EF_FRV_CPU_GENERIC
decl_stmt|;
comment|/* Identify the processor type */
name|p
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"frv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_GENERIC
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_frv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr500"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR500
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr500
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr550"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR550
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr550
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr450"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR450
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr450
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr405"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR405
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr400
expr_stmt|;
name|fr400_audio
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr400"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR400
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr400
expr_stmt|;
name|fr400_audio
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"fr300"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_FR300
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_fr300
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"simple"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_SIMPLE
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_frvsimple
expr_stmt|;
name|frv_flags
operator||=
name|EF_FRV_NOPACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"tomcat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_flags
operator|=
name|EF_FRV_CPU_TOMCAT
expr_stmt|;
name|frv_mach
operator|=
name|bfd_mach_frvtomcat
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"Unknown cpu -mcpu=%s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|EF_FRV_CPU_MASK
operator|)
operator||
name|cpu_flags
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_PIC
case|:
name|frv_flags
operator||=
name|EF_FRV_PIC
expr_stmt|;
name|frv_pic_p
operator|=
literal|1
expr_stmt|;
name|frv_pic_flag
operator|=
literal|"-fpic"
expr_stmt|;
break|break;
case|case
name|OPTION_BIGPIC
case|:
name|frv_flags
operator||=
name|EF_FRV_BIGPIC
expr_stmt|;
name|frv_pic_p
operator|=
literal|1
expr_stmt|;
name|frv_pic_flag
operator|=
literal|"-fPIC"
expr_stmt|;
break|break;
case|case
name|OPTION_LIBPIC
case|:
name|frv_flags
operator||=
operator|(
name|EF_FRV_LIBPIC
operator||
name|EF_FRV_G0
operator|)
expr_stmt|;
name|frv_pic_p
operator|=
literal|1
expr_stmt|;
name|frv_pic_flag
operator|=
literal|"-mlibrary-pic"
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_FDPIC
case|:
name|frv_flags
operator||=
name|EF_FRV_FDPIC
expr_stmt|;
name|frv_pic_flag
operator|=
literal|"-mfdpic"
expr_stmt|;
break|break;
case|case
name|OPTION_NOPIC
case|:
name|frv_flags
operator|&=
operator|~
operator|(
name|EF_FRV_FDPIC
operator||
name|EF_FRV_PIC
operator||
name|EF_FRV_BIGPIC
operator||
name|EF_FRV_LIBPIC
operator|)
expr_stmt|;
name|frv_pic_flag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_TOMCAT_DEBUG
case|:
name|tomcat_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_TOMCAT_STATS
case|:
name|tomcat_stats
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"FRV specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-G n         Data>= n bytes is in small data area\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mgpr-32     Note 32 gprs are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mgpr-64     Note 64 gprs are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mfpr-32     Note 32 fprs are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mfpr-64     Note 64 fprs are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-msoft-float Note software fp is used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mdword      Note stack is aligned to a 8 byte boundary\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mno-dword   Note stack is aligned to a 4 byte boundary\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mdouble     Note fp double insns are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mmedia      Note media insns are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mmuladd     Note multiply add/subtract insns are used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mpack       Note instructions are packed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mno-pack    Do not allow instructions to be packed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mpic        Note small position independent code\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mPIC        Note large position independent code\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mlibrary-pic Compile library for large position indepedent code\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mfdpic      Assemble for the FDPIC ABI\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mnopic      Disable -mpic, -mPIC, -mlibrary-pic and -mfdpic\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mcpu={fr500|fr550|fr400|fr405|fr450|fr300|frv|simple|tomcat}\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"             Record the cpu type\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mtomcat-stats Print out stats for tomcat workarounds\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mtomcat-debug Debug tomcat workarounds\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|frv_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|frv_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
comment|/* Set the ELF flags if desired. */
if|if
condition|(
name|frv_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|frv_flags
argument_list|)
expr_stmt|;
comment|/* Set the machine type */
name|bfd_default_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_frv
argument_list|,
name|frv_mach
argument_list|)
expr_stmt|;
comment|/* Set up gp size so we can put local common items in .sbss */
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
name|frv_vliw_reset
argument_list|(
operator|&
name|vliw
argument_list|,
name|frv_mach
argument_list|,
name|frv_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|frv_md_fdpic_enabled
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|frv_flags
operator|&
name|EF_FRV_FDPIC
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|chain_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vliw_insn_list
modifier|*
name|frv_insert_vliw_insn
name|PARAMS
argument_list|(
operator|(
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|vliw_insn_list
modifier|*
name|frv_insert_vliw_insn
parameter_list|(
name|count
parameter_list|)
name|bfd_boolean
name|count
decl_stmt|;
block|{
name|struct
name|vliw_insn_list
modifier|*
name|vliw_insn_list_entry
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|vliw_chain_entry
decl_stmt|;
if|if
condition|(
name|current_vliw_chain
operator|==
name|NULL
condition|)
block|{
name|vliw_chain_entry
operator|=
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vliw_chain
argument_list|)
argument_list|)
expr_stmt|;
name|vliw_chain_entry
operator|->
name|insn_count
operator|=
literal|0
expr_stmt|;
name|vliw_chain_entry
operator|->
name|insn_list
operator|=
name|NULL
expr_stmt|;
name|vliw_chain_entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|vliw_chain_entry
operator|->
name|num
operator|=
name|chain_num
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|vliw_chain_top
condition|)
name|vliw_chain_top
operator|=
name|vliw_chain_entry
expr_stmt|;
name|current_vliw_chain
operator|=
name|vliw_chain_entry
expr_stmt|;
if|if
condition|(
name|previous_vliw_chain
condition|)
name|previous_vliw_chain
operator|->
name|next
operator|=
name|vliw_chain_entry
expr_stmt|;
block|}
name|vliw_insn_list_entry
operator|=
operator|(
expr|struct
name|vliw_insn_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vliw_insn_list
argument_list|)
argument_list|)
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|type
operator|=
name|VLIW_GENERIC_TYPE
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|insn
operator|=
name|NULL
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|snop_frag
operator|=
name|NULL
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|dnop_frag
operator|=
name|NULL
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|current_vliw_chain
operator|->
name|insn_count
operator|++
expr_stmt|;
if|if
condition|(
name|current_vliw_insn
condition|)
name|current_vliw_insn
operator|->
name|next
operator|=
name|vliw_insn_list_entry
expr_stmt|;
name|current_vliw_insn
operator|=
name|vliw_insn_list_entry
expr_stmt|;
if|if
condition|(
operator|!
name|current_vliw_chain
operator|->
name|insn_list
condition|)
name|current_vliw_chain
operator|->
name|insn_list
operator|=
name|current_vliw_insn
expr_stmt|;
return|return
name|vliw_insn_list_entry
return|;
block|}
end_function

begin_comment
comment|/* Identify the following cases:        1) A VLIW insn that contains both a branch and the branch destination.         This requires the insertion of two vliw instructions before the         branch.  The first consists of two nops.  The second consists of         a single nop.        2) A single instruction VLIW insn which is the destination of a branch         that is in the next VLIW insn.  This requires the insertion of a vliw         insn containing two nops before the branch.        3) A double instruction VLIW insn which contains the destination of a         branch that is in the next VLIW insn.  This requires the insertion of         a VLIW insn containing a single nop before the branch.        4) A single instruction VLIW insn which contains branch destination (x),         followed by a single instruction VLIW insn which does not contain         the branch to (x), followed by a VLIW insn which does contain the branch         to (x).  This requires the insertion of a VLIW insn containing a single         nop before the VLIW instruction containing the branch.     */
end_comment

begin_define
define|#
directive|define
name|FRV_IS_NOP
parameter_list|(
name|insn
parameter_list|)
value|(insn.buffer[0] == FRV_NOP_PACK || insn.buffer[0] == FRV_NOP_NOPACK)
end_define

begin_define
define|#
directive|define
name|FRV_NOP_PACK
value|0x00880000
end_define

begin_comment
comment|/* ori.p  gr0,0,gr0 */
end_comment

begin_define
define|#
directive|define
name|FRV_NOP_NOPACK
value|0x80880000
end_define

begin_comment
comment|/* ori    gr0,0,gr0 */
end_comment

begin_comment
comment|/* Check a vliw insn for an insn of type containing the sym passed in label_sym.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vliw_insn_list
modifier|*
name|frv_find_in_vliw
name|PARAMS
argument_list|(
operator|(
expr|enum
name|vliw_insn_type
operator|,
expr|struct
name|vliw_chain
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|vliw_insn_list
modifier|*
name|frv_find_in_vliw
parameter_list|(
name|vliw_insn_type
parameter_list|,
name|this_chain
parameter_list|,
name|label_sym
parameter_list|)
name|enum
name|vliw_insn_type
name|vliw_insn_type
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|this_chain
decl_stmt|;
name|symbolS
modifier|*
name|label_sym
decl_stmt|;
block|{
name|struct
name|vliw_insn_list
modifier|*
name|the_insn
decl_stmt|;
if|if
condition|(
operator|!
name|this_chain
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|the_insn
operator|=
name|this_chain
operator|->
name|insn_list
init|;
name|the_insn
condition|;
name|the_insn
operator|=
name|the_insn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|the_insn
operator|->
name|type
operator|==
name|vliw_insn_type
operator|&&
name|the_insn
operator|->
name|sym
operator|==
name|label_sym
condition|)
return|return
name|the_insn
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_enum
enum|enum
name|vliw_nop_type
block|{
comment|/* A Vliw insn containing a single nop insn.  */
name|VLIW_SINGLE_NOP
block|,
comment|/* A Vliw insn containing two nop insns.  */
name|VLIW_DOUBLE_NOP
block|,
comment|/* Two vliw insns.  The first containing two nop insns.        The second contain a single nop insn.  */
name|VLIW_DOUBLE_THEN_SINGLE_NOP
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|frv_debug_tomcat
name|PARAMS
argument_list|(
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|frv_debug_tomcat
parameter_list|(
name|start_chain
parameter_list|)
name|struct
name|vliw_chain
modifier|*
name|start_chain
decl_stmt|;
block|{
name|struct
name|vliw_chain
modifier|*
name|this_chain
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|this_insn
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|this_chain
operator|=
name|start_chain
init|;
name|this_chain
condition|;
name|this_chain
operator|=
name|this_chain
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nVliw Insn #%d, #insns: %d\n"
argument_list|,
name|i
argument_list|,
name|this_chain
operator|->
name|insn_count
argument_list|)
expr_stmt|;
for|for
control|(
name|this_insn
operator|=
name|this_chain
operator|->
name|insn_list
init|;
name|this_insn
condition|;
name|this_insn
operator|=
name|this_insn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_LABEL_TYPE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Label Value: %p\n"
argument_list|,
name|this_insn
operator|->
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_BRANCH_TYPE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s to %p\n"
argument_list|,
name|this_insn
operator|->
name|insn
operator|->
name|base
operator|->
name|name
argument_list|,
name|this_insn
operator|->
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_BRANCH_HAS_NOPS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nop'd %s to %p\n"
argument_list|,
name|this_insn
operator|->
name|insn
operator|->
name|base
operator|->
name|name
argument_list|,
name|this_insn
operator|->
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_NOP_TYPE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Nop\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	%s\n"
argument_list|,
name|this_insn
operator|->
name|insn
operator|->
name|base
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|frv_adjust_vliw_count
name|PARAMS
argument_list|(
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|frv_adjust_vliw_count
parameter_list|(
name|this_chain
parameter_list|)
name|struct
name|vliw_chain
modifier|*
name|this_chain
decl_stmt|;
block|{
name|struct
name|vliw_insn_list
modifier|*
name|this_insn
decl_stmt|;
name|this_chain
operator|->
name|insn_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|this_insn
operator|=
name|this_chain
operator|->
name|insn_list
init|;
name|this_insn
condition|;
name|this_insn
operator|=
name|this_insn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|this_insn
operator|->
name|type
operator|!=
name|VLIW_LABEL_TYPE
condition|)
name|this_chain
operator|->
name|insn_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert the desired nop combination in the vliw chain before insert_before_insn.    Rechain the vliw insn.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vliw_chain
modifier|*
name|frv_tomcat_shuffle
name|PARAMS
argument_list|(
operator|(
expr|enum
name|vliw_nop_type
operator|,
expr|struct
name|vliw_chain
operator|*
operator|,
expr|struct
name|vliw_insn_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|vliw_chain
modifier|*
name|frv_tomcat_shuffle
parameter_list|(
name|this_nop_type
parameter_list|,
name|vliw_to_split
parameter_list|,
name|insert_before_insn
parameter_list|)
name|enum
name|vliw_nop_type
name|this_nop_type
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|vliw_to_split
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|insert_before_insn
decl_stmt|;
block|{
name|bfd_boolean
name|pack_prev
init|=
name|FALSE
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|return_me
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|prev_insn
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|curr_insn
init|=
name|vliw_to_split
operator|->
name|insn_list
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|double_nop
init|=
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vliw_chain
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|single_nop
init|=
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vliw_chain
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|second_part
init|=
operator|(
expr|struct
name|vliw_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vliw_chain
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|curr_vliw
init|=
name|vliw_chain_top
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|prev_vliw
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|curr_insn
operator|&&
name|curr_insn
operator|!=
name|insert_before_insn
condition|)
block|{
comment|/* We can't set the packing bit on a label.  If we have the case 	 label 1: 	 label 2: 	 label 3: 	   branch that needs nops 	Then don't set pack bit later.  */
if|if
condition|(
name|curr_insn
operator|->
name|type
operator|!=
name|VLIW_LABEL_TYPE
condition|)
name|pack_prev
operator|=
name|TRUE
expr_stmt|;
name|prev_insn
operator|=
name|curr_insn
expr_stmt|;
name|curr_insn
operator|=
name|curr_insn
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|curr_vliw
operator|&&
name|curr_vliw
operator|!=
name|vliw_to_split
condition|)
block|{
name|prev_vliw
operator|=
name|curr_vliw
expr_stmt|;
name|curr_vliw
operator|=
name|curr_vliw
operator|->
name|next
expr_stmt|;
block|}
switch|switch
condition|(
name|this_nop_type
condition|)
block|{
case|case
name|VLIW_SINGLE_NOP
case|:
if|if
condition|(
operator|!
name|prev_insn
condition|)
block|{
comment|/* Branch is first,  Insert the NOP prior to this vliw insn.  */
if|if
condition|(
name|prev_vliw
condition|)
name|prev_vliw
operator|->
name|next
operator|=
name|single_nop
expr_stmt|;
else|else
name|vliw_chain_top
operator|=
name|single_nop
expr_stmt|;
name|single_nop
operator|->
name|next
operator|=
name|vliw_to_split
expr_stmt|;
name|vliw_to_split
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
name|return_me
operator|=
name|vliw_to_split
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the packing bit on the previous insn.  */
if|if
condition|(
name|pack_prev
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|prev_insn
operator|->
name|address
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
comment|/* The branch is in the middle.  Split this vliw insn into first 	     and second parts.  Insert the NOP inbetween.  */
name|second_part
operator|->
name|insn_list
operator|=
name|insert_before_insn
expr_stmt|;
name|second_part
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
name|second_part
operator|->
name|next
operator|=
name|vliw_to_split
operator|->
name|next
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|second_part
argument_list|)
expr_stmt|;
name|single_nop
operator|->
name|next
operator|=
name|second_part
expr_stmt|;
name|vliw_to_split
operator|->
name|next
operator|=
name|single_nop
expr_stmt|;
name|prev_insn
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|return_me
operator|=
name|second_part
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|vliw_to_split
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VLIW_DOUBLE_NOP
case|:
if|if
condition|(
operator|!
name|prev_insn
condition|)
block|{
comment|/* Branch is first,  Insert the NOP prior to this vliw insn.  */
if|if
condition|(
name|prev_vliw
condition|)
name|prev_vliw
operator|->
name|next
operator|=
name|double_nop
expr_stmt|;
else|else
name|vliw_chain_top
operator|=
name|double_nop
expr_stmt|;
name|double_nop
operator|->
name|next
operator|=
name|vliw_to_split
expr_stmt|;
name|return_me
operator|=
name|vliw_to_split
expr_stmt|;
name|vliw_to_split
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the packing bit on the previous insn.  */
if|if
condition|(
name|pack_prev
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|prev_insn
operator|->
name|address
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
comment|/* The branch is in the middle.  Split this vliw insn into first 	   and second parts.  Insert the NOP inbetween.  */
name|second_part
operator|->
name|insn_list
operator|=
name|insert_before_insn
expr_stmt|;
name|second_part
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
name|second_part
operator|->
name|next
operator|=
name|vliw_to_split
operator|->
name|next
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|second_part
argument_list|)
expr_stmt|;
name|double_nop
operator|->
name|next
operator|=
name|second_part
expr_stmt|;
name|vliw_to_split
operator|->
name|next
operator|=
name|single_nop
expr_stmt|;
name|prev_insn
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|vliw_to_split
argument_list|)
expr_stmt|;
name|return_me
operator|=
name|second_part
expr_stmt|;
block|}
break|break;
case|case
name|VLIW_DOUBLE_THEN_SINGLE_NOP
case|:
name|double_nop
operator|->
name|next
operator|=
name|single_nop
expr_stmt|;
name|double_nop
operator|->
name|insn_count
operator|=
literal|2
expr_stmt|;
name|double_nop
operator|->
name|insn_list
operator|=
operator|&
name|double_nop_insn
expr_stmt|;
name|single_nop
operator|->
name|insn_count
operator|=
literal|1
expr_stmt|;
name|single_nop
operator|->
name|insn_list
operator|=
operator|&
name|single_nop_insn
expr_stmt|;
if|if
condition|(
operator|!
name|prev_insn
condition|)
block|{
comment|/* The branch is the first insn in this vliw.  Don't split the vliw.  Insert 	     the nops prior to this vliw.  */
if|if
condition|(
name|prev_vliw
condition|)
name|prev_vliw
operator|->
name|next
operator|=
name|double_nop
expr_stmt|;
else|else
name|vliw_chain_top
operator|=
name|double_nop
expr_stmt|;
name|single_nop
operator|->
name|next
operator|=
name|vliw_to_split
expr_stmt|;
name|return_me
operator|=
name|vliw_to_split
expr_stmt|;
name|vliw_to_split
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the packing bit on the previous insn.  */
if|if
condition|(
name|pack_prev
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|prev_insn
operator|->
name|address
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
comment|/* The branch is in the middle of this vliw insn.  Split into first and 	     second parts.  Insert the nop vliws in between.  */
name|second_part
operator|->
name|insn_list
operator|=
name|insert_before_insn
expr_stmt|;
name|second_part
operator|->
name|insn_list
operator|->
name|type
operator|=
name|VLIW_BRANCH_HAS_NOPS
expr_stmt|;
name|second_part
operator|->
name|next
operator|=
name|vliw_to_split
operator|->
name|next
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|second_part
argument_list|)
expr_stmt|;
name|single_nop
operator|->
name|next
operator|=
name|second_part
expr_stmt|;
name|vliw_to_split
operator|->
name|next
operator|=
name|double_nop
expr_stmt|;
name|prev_insn
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|frv_adjust_vliw_count
argument_list|(
name|vliw_to_split
argument_list|)
expr_stmt|;
name|return_me
operator|=
name|second_part
expr_stmt|;
block|}
break|break;
block|}
return|return
name|return_me
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|frv_tomcat_analyze_vliw_chains
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|frv_tomcat_analyze_vliw_chains
parameter_list|()
block|{
name|struct
name|vliw_chain
modifier|*
name|vliw1
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|vliw2
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_chain
modifier|*
name|vliw3
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|this_insn
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|temp_insn
init|=
name|NULL
decl_stmt|;
comment|/* We potentially need to look at three VLIW insns to determine if the      workaround is required.  Set them up.  Ignore existing nops during analysis. */
define|#
directive|define
name|FRV_SET_VLIW_WINDOW
parameter_list|(
name|VLIW1
parameter_list|,
name|VLIW2
parameter_list|,
name|VLIW3
parameter_list|)
define|\
value|if (VLIW1&& VLIW1->next)			 \     VLIW2 = VLIW1->next;			 \   else						 \     VLIW2 = NULL;				 \   if (VLIW2&& VLIW2->next)			 \     VLIW3 = VLIW2->next;			 \   else						 \     VLIW3 = NULL
name|vliw1
operator|=
name|vliw_chain_top
expr_stmt|;
name|workaround_top
label|:
name|FRV_SET_VLIW_WINDOW
argument_list|(
name|vliw1
argument_list|,
name|vliw2
argument_list|,
name|vliw3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vliw1
condition|)
return|return;
if|if
condition|(
name|vliw1
operator|->
name|insn_count
operator|==
literal|1
condition|)
block|{
comment|/* check vliw1 for a label. */
if|if
condition|(
name|vliw1
operator|->
name|insn_list
operator|->
name|type
operator|==
name|VLIW_LABEL_TYPE
condition|)
block|{
name|temp_insn
operator|=
name|frv_find_in_vliw
argument_list|(
name|VLIW_BRANCH_TYPE
argument_list|,
name|vliw2
argument_list|,
name|vliw1
operator|->
name|insn_list
operator|->
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_insn
condition|)
block|{
name|vliw1
operator|=
name|frv_tomcat_shuffle
argument_list|(
name|VLIW_DOUBLE_NOP
argument_list|,
name|vliw2
argument_list|,
name|vliw1
operator|->
name|insn_list
argument_list|)
expr_stmt|;
name|temp_insn
operator|->
name|dnop_frag
operator|->
name|fr_subtype
operator|=
name|NOP_KEEP
expr_stmt|;
name|vliw1
operator|=
name|vliw1
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tomcat_stats
condition|)
name|tomcat_doubles
operator|++
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
elseif|else
if|if
condition|(
name|vliw2
operator|&&
name|vliw2
operator|->
name|insn_count
operator|==
literal|1
operator|&&
operator|(
name|temp_insn
operator|=
name|frv_find_in_vliw
argument_list|(
name|VLIW_BRANCH_TYPE
argument_list|,
name|vliw3
argument_list|,
name|vliw1
operator|->
name|insn_list
operator|->
name|sym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|temp_insn
operator|->
name|snop_frag
operator|->
name|fr_subtype
operator|=
name|NOP_KEEP
expr_stmt|;
name|vliw1
operator|=
name|frv_tomcat_shuffle
argument_list|(
name|VLIW_SINGLE_NOP
argument_list|,
name|vliw3
argument_list|,
name|vliw3
operator|->
name|insn_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tomcat_stats
condition|)
name|tomcat_singles
operator|++
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
block|}
block|}
if|if
condition|(
name|vliw1
operator|->
name|insn_count
operator|==
literal|2
condition|)
block|{
name|struct
name|vliw_insn_list
modifier|*
name|this_insn
decl_stmt|;
comment|/* check vliw1 for a label. */
for|for
control|(
name|this_insn
operator|=
name|vliw1
operator|->
name|insn_list
init|;
name|this_insn
condition|;
name|this_insn
operator|=
name|this_insn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_LABEL_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|temp_insn
operator|=
name|frv_find_in_vliw
argument_list|(
name|VLIW_BRANCH_TYPE
argument_list|,
name|vliw2
argument_list|,
name|this_insn
operator|->
name|sym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|temp_insn
operator|->
name|snop_frag
operator|->
name|fr_subtype
operator|=
name|NOP_KEEP
expr_stmt|;
name|vliw1
operator|=
name|frv_tomcat_shuffle
argument_list|(
name|VLIW_SINGLE_NOP
argument_list|,
name|vliw2
argument_list|,
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tomcat_stats
condition|)
name|tomcat_singles
operator|++
expr_stmt|;
block|}
else|else
name|vliw1
operator|=
name|vliw1
operator|->
name|next
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
block|}
block|}
comment|/* Examine each insn in this VLIW.  Look for the workaround criteria.  */
for|for
control|(
name|this_insn
operator|=
name|vliw1
operator|->
name|insn_list
init|;
name|this_insn
condition|;
name|this_insn
operator|=
name|this_insn
operator|->
name|next
control|)
block|{
comment|/* Don't look at labels or nops.  */
while|while
condition|(
name|this_insn
operator|&&
operator|(
name|this_insn
operator|->
name|type
operator|==
name|VLIW_LABEL_TYPE
operator|||
name|this_insn
operator|->
name|type
operator|==
name|VLIW_NOP_TYPE
operator|||
name|this_insn
operator|->
name|type
operator|==
name|VLIW_BRANCH_HAS_NOPS
operator|)
condition|)
name|this_insn
operator|=
name|this_insn
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|this_insn
condition|)
block|{
name|vliw1
operator|=
name|vliw2
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
if|if
condition|(
name|frv_is_branch_insn
argument_list|(
name|this_insn
operator|->
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|temp_insn
operator|=
name|frv_find_in_vliw
argument_list|(
name|VLIW_LABEL_TYPE
argument_list|,
name|vliw1
argument_list|,
name|this_insn
operator|->
name|sym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Insert [nop/nop] [nop] before branch.  */
name|this_insn
operator|->
name|snop_frag
operator|->
name|fr_subtype
operator|=
name|NOP_KEEP
expr_stmt|;
name|this_insn
operator|->
name|dnop_frag
operator|->
name|fr_subtype
operator|=
name|NOP_KEEP
expr_stmt|;
name|vliw1
operator|=
name|frv_tomcat_shuffle
argument_list|(
name|VLIW_DOUBLE_THEN_SINGLE_NOP
argument_list|,
name|vliw1
argument_list|,
name|this_insn
argument_list|)
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
block|}
block|}
comment|/* This vliw insn checks out okay.  Take a look at the next one.  */
name|vliw1
operator|=
name|vliw1
operator|->
name|next
expr_stmt|;
goto|goto
name|workaround_top
goto|;
block|}
end_function

begin_function
name|void
name|frv_tomcat_workaround
parameter_list|()
block|{
if|if
condition|(
name|frv_mach
operator|!=
name|bfd_mach_frvtomcat
condition|)
return|return;
if|if
condition|(
name|tomcat_debug
condition|)
name|frv_debug_tomcat
argument_list|(
name|vliw_chain_top
argument_list|)
expr_stmt|;
name|frv_tomcat_analyze_vliw_chains
argument_list|()
expr_stmt|;
if|if
condition|(
name|tomcat_stats
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserted %d Single Nops\n"
argument_list|,
name|tomcat_singles
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Inserted %d Double Nops\n"
argument_list|,
name|tomcat_doubles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fr550_check_insn_acc_range
parameter_list|(
name|frv_insn
modifier|*
name|insn
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|int
name|acc
decl_stmt|;
switch|switch
condition|(
name|CGEN_INSN_NUM
argument_list|(
name|insn
operator|->
name|insn
argument_list|)
condition|)
block|{
case|case
name|FRV_INSN_MADDACCS
case|:
case|case
name|FRV_INSN_MSUBACCS
case|:
case|case
name|FRV_INSN_MDADDACCS
case|:
case|case
name|FRV_INSN_MDSUBACCS
case|:
case|case
name|FRV_INSN_MASACCS
case|:
case|case
name|FRV_INSN_MDASACCS
case|:
name|acc
operator|=
name|insn
operator|->
name|fields
operator|.
name|f_ACC40Si
expr_stmt|;
if|if
condition|(
name|acc
operator|<
name|low
operator|||
name|acc
operator|>
name|hi
condition|)
return|return
literal|1
return|;
comment|/* out of range */
name|acc
operator|=
name|insn
operator|->
name|fields
operator|.
name|f_ACC40Sk
expr_stmt|;
if|if
condition|(
name|acc
operator|<
name|low
operator|||
name|acc
operator|>
name|hi
condition|)
return|return
literal|1
return|;
comment|/* out of range */
break|break;
case|case
name|FRV_INSN_MMULHS
case|:
case|case
name|FRV_INSN_MMULHU
case|:
case|case
name|FRV_INSN_MMULXHS
case|:
case|case
name|FRV_INSN_MMULXHU
case|:
case|case
name|FRV_INSN_CMMULHS
case|:
case|case
name|FRV_INSN_CMMULHU
case|:
case|case
name|FRV_INSN_MQMULHS
case|:
case|case
name|FRV_INSN_MQMULHU
case|:
case|case
name|FRV_INSN_MQMULXHS
case|:
case|case
name|FRV_INSN_MQMULXHU
case|:
case|case
name|FRV_INSN_CMQMULHS
case|:
case|case
name|FRV_INSN_CMQMULHU
case|:
case|case
name|FRV_INSN_MMACHS
case|:
case|case
name|FRV_INSN_MMRDHS
case|:
case|case
name|FRV_INSN_CMMACHS
case|:
case|case
name|FRV_INSN_MQMACHS
case|:
case|case
name|FRV_INSN_CMQMACHS
case|:
case|case
name|FRV_INSN_MQXMACHS
case|:
case|case
name|FRV_INSN_MQXMACXHS
case|:
case|case
name|FRV_INSN_MQMACXHS
case|:
case|case
name|FRV_INSN_MCPXRS
case|:
case|case
name|FRV_INSN_MCPXIS
case|:
case|case
name|FRV_INSN_CMCPXRS
case|:
case|case
name|FRV_INSN_CMCPXIS
case|:
case|case
name|FRV_INSN_MQCPXRS
case|:
case|case
name|FRV_INSN_MQCPXIS
case|:
name|acc
operator|=
name|insn
operator|->
name|fields
operator|.
name|f_ACC40Sk
expr_stmt|;
if|if
condition|(
name|acc
operator|<
name|low
operator|||
name|acc
operator|>
name|hi
condition|)
return|return
literal|1
return|;
comment|/* out of range */
break|break;
case|case
name|FRV_INSN_MMACHU
case|:
case|case
name|FRV_INSN_MMRDHU
case|:
case|case
name|FRV_INSN_CMMACHU
case|:
case|case
name|FRV_INSN_MQMACHU
case|:
case|case
name|FRV_INSN_CMQMACHU
case|:
case|case
name|FRV_INSN_MCPXRU
case|:
case|case
name|FRV_INSN_MCPXIU
case|:
case|case
name|FRV_INSN_CMCPXRU
case|:
case|case
name|FRV_INSN_CMCPXIU
case|:
case|case
name|FRV_INSN_MQCPXRU
case|:
case|case
name|FRV_INSN_MQCPXIU
case|:
name|acc
operator|=
name|insn
operator|->
name|fields
operator|.
name|f_ACC40Uk
expr_stmt|;
if|if
condition|(
name|acc
operator|<
name|low
operator|||
name|acc
operator|>
name|hi
condition|)
return|return
literal|1
return|;
comment|/* out of range */
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
comment|/* all is ok */
block|}
end_function

begin_function
specifier|static
name|int
name|fr550_check_acc_range
parameter_list|(
name|FRV_VLIW
modifier|*
name|vliw
parameter_list|,
name|frv_insn
modifier|*
name|insn
parameter_list|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|vliw
operator|->
name|current_vliw
operator|)
index|[
name|vliw
operator|->
name|next_slot
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|UNIT_FM0
case|:
case|case
name|UNIT_FM2
case|:
return|return
name|fr550_check_insn_acc_range
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
return|;
case|case
name|UNIT_FM1
case|:
case|case
name|UNIT_FM3
case|:
return|return
name|fr550_check_insn_acc_range
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
comment|/* all is ok */
block|}
end_function

begin_comment
comment|/* Return true if the target implements instruction INSN.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|target_implements_insn_p
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|)
block|{
switch|switch
condition|(
name|frv_mach
condition|)
block|{
default|default:
comment|/* bfd_mach_frv or generic.  */
return|return
name|TRUE
return|;
case|case
name|bfd_mach_fr300
case|:
case|case
name|bfd_mach_frvsimple
case|:
return|return
name|CGEN_INSN_MACH_HAS_P
argument_list|(
name|insn
argument_list|,
name|MACH_SIMPLE
argument_list|)
return|;
case|case
name|bfd_mach_fr400
case|:
return|return
operator|(
operator|(
name|fr400_audio
operator|||
operator|!
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_AUDIO
argument_list|)
operator|)
operator|&&
name|CGEN_INSN_MACH_HAS_P
argument_list|(
name|insn
argument_list|,
name|MACH_FR400
argument_list|)
operator|)
return|;
case|case
name|bfd_mach_fr450
case|:
return|return
name|CGEN_INSN_MACH_HAS_P
argument_list|(
name|insn
argument_list|,
name|MACH_FR450
argument_list|)
return|;
case|case
name|bfd_mach_fr500
case|:
return|return
name|CGEN_INSN_MACH_HAS_P
argument_list|(
name|insn
argument_list|,
name|MACH_FR500
argument_list|)
return|;
case|case
name|bfd_mach_fr550
case|:
return|return
name|CGEN_INSN_MACH_HAS_P
argument_list|(
name|insn
argument_list|,
name|MACH_FR550
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|frv_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|packing_constraint
decl_stmt|;
name|finished_insnS
name|finished_insn
decl_stmt|;
name|fragS
modifier|*
name|double_nop_frag
init|=
name|NULL
decl_stmt|;
name|fragS
modifier|*
name|single_nop_frag
init|=
name|NULL
decl_stmt|;
name|struct
name|vliw_insn_list
modifier|*
name|vliw_insn_list_entry
init|=
name|NULL
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|frv_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the cpu is tomcat, then we need to insert nops to workaround      hardware limitations.  We need to keep track of each vliw unit      and examine the length of the unit and the individual insns      within the unit to determine the number and location of the      required nops.  */
if|if
condition|(
name|frv_mach
operator|==
name|bfd_mach_frvtomcat
condition|)
block|{
comment|/* If we've just finished a VLIW insn OR this is a branch, 	 then start up a new frag.  Fill it with nops.  We will get rid 	 of those that are not required after we've seen all of the  	 instructions but before we start resolving fixups.  */
if|if
condition|(
operator|!
name|FRV_IS_NOP
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|frv_is_branch_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
operator|||
name|insn
operator|.
name|fields
operator|.
name|f_pack
operator|)
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|double_nop_frag
operator|=
name|frag_now
expr_stmt|;
name|buffer
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|NOP_DELETE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buffer
argument_list|,
name|FRV_NOP_PACK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buffer
operator|+
literal|4
argument_list|,
name|FRV_NOP_NOPACK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|single_nop_frag
operator|=
name|frag_now
expr_stmt|;
name|buffer
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|NOP_DELETE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buffer
argument_list|,
name|FRV_NOP_NOPACK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|vliw_insn_list_entry
operator|=
name|frv_insert_vliw_insn
argument_list|(
name|DO_COUNT
argument_list|)
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|insn
operator|=
name|insn
operator|.
name|insn
expr_stmt|;
if|if
condition|(
name|frv_is_branch_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
condition|)
name|vliw_insn_list_entry
operator|->
name|type
operator|=
name|VLIW_BRANCH_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|FRV_IS_NOP
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|frv_is_branch_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
operator|||
name|insn
operator|.
name|fields
operator|.
name|f_pack
operator|)
condition|)
block|{
name|vliw_insn_list_entry
operator|->
name|snop_frag
operator|=
name|single_nop_frag
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|dnop_frag
operator|=
name|double_nop_frag
expr_stmt|;
block|}
block|}
comment|/* Make sure that this insn does not violate the VLIW packing constraints.  */
comment|/* -mno-pack disallows any packing whatsoever.  */
if|if
condition|(
name|frv_flags
operator|&
name|EF_FRV_NOPACK
condition|)
block|{
if|if
condition|(
operator|!
name|insn
operator|.
name|fields
operator|.
name|f_pack
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"VLIW packing used for -mno-pack"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* -mcpu=FRV is an idealized FR-V implementation that supports all of the      instructions, don't do vliw checking.  */
elseif|else
if|if
condition|(
name|frv_mach
operator|!=
name|bfd_mach_frv
condition|)
block|{
if|if
condition|(
operator|!
name|target_implements_insn_p
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction not supported by this architecture"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|packing_constraint
operator|=
name|frv_vliw_add_insn
argument_list|(
operator|&
name|vliw
argument_list|,
name|insn
operator|.
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|frv_mach
operator|==
name|bfd_mach_fr550
operator|&&
operator|!
name|packing_constraint
condition|)
name|packing_constraint
operator|=
name|fr550_check_acc_range
argument_list|(
operator|&
name|vliw
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|fields
operator|.
name|f_pack
condition|)
name|frv_vliw_reset
argument_list|(
operator|&
name|vliw
argument_list|,
name|frv_mach
argument_list|,
name|frv_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|packing_constraint
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"VLIW packing constraint violation"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|finished_insn
argument_list|)
expr_stmt|;
comment|/* If the cpu is tomcat, then we need to insert nops to workaround      hardware limitations.  We need to keep track of each vliw unit      and examine the length of the unit and the individual insns      within the unit to determine the number and location of the      required nops.  */
if|if
condition|(
name|frv_mach
operator|==
name|bfd_mach_frvtomcat
condition|)
block|{
if|if
condition|(
name|vliw_insn_list_entry
condition|)
name|vliw_insn_list_entry
operator|->
name|address
operator|=
name|finished_insn
operator|.
name|addr
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|fields
operator|.
name|f_pack
condition|)
block|{
comment|/* We've completed a VLIW insn.  */
name|previous_vliw_chain
operator|=
name|current_vliw_chain
expr_stmt|;
name|current_vliw_chain
operator|=
name|NULL
expr_stmt|;
name|current_vliw_insn
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The syntax in the manual says constants begin with '#'.    We just ignore it.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_comment
comment|/* FIXME: Build table by hand, get it working, then machine generate.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|511
operator|-
literal|2
operator|-
literal|2
block|,
operator|-
literal|512
operator|-
literal|2
operator|+
literal|2
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|frv_relax_frag
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|stretch
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|NOP_KEEP
case|:
return|return
name|fragP
operator|->
name|fr_var
return|;
default|default:
case|case
name|NOP_DELETE
case|:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
default|default:
case|case
name|NOP_DELETE
case|:
return|return;
case|case
name|NOP_KEEP
case|:
name|fragP
operator|->
name|fr_fix
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
operator|||
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* If we can't adjust this relocation, or if it references a 	 local symbol in a different section (which 	 TC_FORCE_RELOCATION can't check), let the linker figure it 	 out.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|fixP
parameter_list|)
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|FRV_OPERAND_LABEL16
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
name|TRUE
expr_stmt|;
return|return
name|BFD_RELOC_FRV_LABEL16
return|;
case|case
name|FRV_OPERAND_LABEL24
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
literal|0
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
return|return
name|BFD_RELOC_FRV_LABEL24
return|;
case|case
name|FRV_OPERAND_UHI16
case|:
case|case
name|FRV_OPERAND_ULO16
case|:
case|case
name|FRV_OPERAND_SLO16
case|:
case|case
name|FRV_OPERAND_CALLANN
case|:
case|case
name|FRV_OPERAND_LDANN
case|:
case|case
name|FRV_OPERAND_LDDANN
case|:
comment|/* The relocation type should be recorded in opinfo */
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
literal|0
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
break|break;
case|case
name|FRV_OPERAND_D12
case|:
case|case
name|FRV_OPERAND_S12
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
literal|0
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
return|return
name|BFD_RELOC_FRV_GPREL12
return|;
case|case
name|FRV_OPERAND_U12
case|:
return|return
name|BFD_RELOC_FRV_GPRELU12
return|;
default|default:
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|frv_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
condition|?
operator|(
name|int
operator|)
name|fix
operator|->
name|fx_r_type
else|:
name|fix
operator|->
name|fx_cgen
operator|.
name|opinfo
condition|)
block|{
case|case
name|BFD_RELOC_FRV_GPREL12
case|:
case|case
name|BFD_RELOC_FRV_GPRELU12
case|:
case|case
name|BFD_RELOC_FRV_GPREL32
case|:
case|case
name|BFD_RELOC_FRV_GPRELHI
case|:
case|case
name|BFD_RELOC_FRV_GPRELLO
case|:
case|case
name|BFD_RELOC_FRV_GOT12
case|:
case|case
name|BFD_RELOC_FRV_GOTHI
case|:
case|case
name|BFD_RELOC_FRV_GOTLO
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_VALUE
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GOTOFF12
case|:
case|case
name|BFD_RELOC_FRV_GOTOFFHI
case|:
case|case
name|BFD_RELOC_FRV_GOTOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GETTLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_VALUE
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESC12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCLO
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFF12
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFHI
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFF12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFLO
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_RELAX
case|:
case|case
name|BFD_RELOC_FRV_GETTLSOFF_RELAX
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF_RELAX
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup that could be resolved within the assembler.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
condition|)
block|{
case|case
name|BFD_RELOC_FRV_HI16
case|:
operator|*
name|valP
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_FRV_LO16
case|:
operator|*
name|valP
operator|&=
literal|0xffff
expr_stmt|;
break|break;
comment|/* We need relocations for these, even if their symbols reduce 	   to constants.  */
case|case
name|BFD_RELOC_FRV_GPREL12
case|:
case|case
name|BFD_RELOC_FRV_GPRELU12
case|:
case|case
name|BFD_RELOC_FRV_GPREL32
case|:
case|case
name|BFD_RELOC_FRV_GPRELHI
case|:
case|case
name|BFD_RELOC_FRV_GPRELLO
case|:
case|case
name|BFD_RELOC_FRV_GOT12
case|:
case|case
name|BFD_RELOC_FRV_GOTHI
case|:
case|case
name|BFD_RELOC_FRV_GOTLO
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_VALUE
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GOTOFF12
case|:
case|case
name|BFD_RELOC_FRV_GOTOFFHI
case|:
case|case
name|BFD_RELOC_FRV_GOTOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GETTLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_VALUE
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESC12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCLO
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFF12
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFHI
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFF12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFLO
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_RELAX
case|:
case|case
name|BFD_RELOC_FRV_GETTLSOFF_RELAX
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF_RELAX
case|:
name|fixP
operator|->
name|fx_addsy
operator|=
name|expr_build_uconstant
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
condition|)
block|{
case|case
name|BFD_RELOC_FRV_GETTLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_VALUE
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESC12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSDESCLO
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFF12
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFHI
case|:
case|case
name|BFD_RELOC_FRV_TLSMOFFLO
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFF12
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFHI
case|:
case|case
name|BFD_RELOC_FRV_GOTTLSOFFLO
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF
case|:
case|case
name|BFD_RELOC_FRV_TLSDESC_RELAX
case|:
case|case
name|BFD_RELOC_FRV_GETTLSOFF_RELAX
case|:
case|case
name|BFD_RELOC_FRV_TLSOFF_RELAX
case|:
comment|/* Mark TLS symbols as such.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|absolute_section
condition|)
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
block|}
name|gas_cgen_md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|valP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|frv_md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK. */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|frv_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|NULL
decl_stmt|;
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
comment|/* We need the symbol name for the VTABLE entries */
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_FRV_GPREL12
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_FRV_GPRELU12
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Allow user to set flags bits.  */
end_comment

begin_function
name|void
name|frv_set_flags
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|flagword
name|new_flags
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|flagword
name|new_mask
init|=
operator|~
operator|(
name|flagword
operator|)
literal|0
decl_stmt|;
name|frv_user_set_flags_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|new_mask
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|frv_flags
operator|=
operator|(
name|frv_flags
operator|&
operator|~
name|new_mask
operator|)
operator||
operator|(
name|new_flags
operator|&
name|new_mask
operator|)
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|frv_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frv specific function to handle 4 byte initializations for pointers that are    considered 'safe' for use with pic support.  Until frv_frob_file{,_section}    is run, we encode it a BFD_RELOC_CTOR, and it is turned back into a normal    BFD_RELOC_32 at that time.  */
end_comment

begin_function
name|void
name|frv_pic_ptr
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|bfd_reloc_code_real_type
name|reloc_type
init|=
name|BFD_RELOC_CTOR
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"funcdesc("
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|9
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|')'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing ')'"
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_FRV_FUNCDESC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"tlsmoff("
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|8
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|')'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing ')'"
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_FRV_TLSMOFF
expr_stmt|;
block|}
else|else
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream. */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF1
parameter_list|(
name|A
parameter_list|)
value|fprintf (stderr, A)
end_define

begin_define
define|#
directive|define
name|DPRINTF2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|fprintf (stderr, A, B)
end_define

begin_define
define|#
directive|define
name|DPRINTF3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
value|fprintf (stderr, A, B, C)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF1
parameter_list|(
name|A
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Go through a the sections looking for relocations that are problematical for    pic.  If not pic, just note that this object can't be linked with pic.  If    it is pic, see if it needs to be marked so that it will be fixed up, or if    not possible, issue an error.  */
end_comment

begin_function
specifier|static
name|void
name|frv_frob_file_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|CGEN_CPU_DESC
name|cd
init|=
name|gas_cgen_cpu_desc
decl_stmt|;
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
comment|/* Skip relocations in known sections (.ctors, .dtors, and .gcc_except_table)      since we can fix those up by hand.  */
name|int
name|known_section_p
init|=
operator|(
name|sec
operator|->
name|name
operator|&&
name|sec
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|(
name|sec
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".ctor"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sec
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".dtor"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sec
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".gcc_except_table"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
decl_stmt|;
name|DPRINTF3
argument_list|(
literal|"\nFrv section %s%s\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|,
operator|(
name|known_section_p
operator|)
condition|?
literal|", known section"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF1
argument_list|(
literal|"\tSkipping non-loaded section\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
block|{
name|symbolS
modifier|*
name|s
init|=
name|fixp
operator|->
name|fx_addsy
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|int
name|non_pic_p
decl_stmt|;
name|int
name|opindex
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|fixp
operator|->
name|fx_cgen
operator|.
name|insn
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
name|DPRINTF1
argument_list|(
literal|"\tSkipping reloc that has already been done\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|DPRINTF1
argument_list|(
literal|"\tSkipping reloc that is PC relative\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|DPRINTF1
argument_list|(
literal|"\tSkipping reloc without symbol\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
condition|)
block|{
name|opindex
operator|=
operator|-
literal|1
expr_stmt|;
name|reloc
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
block|}
else|else
block|{
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
name|cgen_operand_lookup_by_num
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixp
argument_list|)
expr_stmt|;
block|}
name|DPRINTF3
argument_list|(
literal|"\treloc %s\t%s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|reloc
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|non_pic_p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_32
case|:
comment|/* Skip relocations in known sections (.ctors, .dtors, and 	     .gcc_except_table) since we can fix those up by hand.  Also 	     skip forward references to constants.  Also skip a difference 	     of two symbols, which still uses the BFD_RELOC_32 at this 	     point.  */
if|if
condition|(
operator|!
name|known_section_p
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
operator|!=
name|absolute_section
operator|&&
operator|!
name|fixp
operator|->
name|fx_subsy
operator|&&
operator|(
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|non_pic_p
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* FIXME -- should determine if any of the GP relocation really uses 	     gr16 (which is not pic safe) or not.  Right now, assume if we 	     aren't being compiled with -mpic, the usage is non pic safe, but 	     is safe with -mpic.  */
case|case
name|BFD_RELOC_FRV_GPREL12
case|:
case|case
name|BFD_RELOC_FRV_GPRELU12
case|:
case|case
name|BFD_RELOC_FRV_GPREL32
case|:
case|case
name|BFD_RELOC_FRV_GPRELHI
case|:
case|case
name|BFD_RELOC_FRV_GPRELLO
case|:
name|non_pic_p
operator|=
operator|!
name|frv_pic_p
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_FRV_LO16
case|:
case|case
name|BFD_RELOC_FRV_HI16
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
operator|!=
name|absolute_section
condition|)
name|non_pic_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|non_pic_p
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* If this is a blessed BFD_RELOC_32, convert it back to the normal              relocation.  */
case|case
name|BFD_RELOC_CTOR
case|:
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|non_pic_p
condition|)
block|{
name|DPRINTF1
argument_list|(
literal|" (Non-pic relocation)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frv_pic_p
condition|)
name|as_warn_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Relocation %s is not safe for %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|reloc
argument_list|)
argument_list|,
name|frv_pic_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|frv_flags
operator|&
name|EF_FRV_NON_PIC_RELOCS
operator|)
operator|==
literal|0
condition|)
block|{
name|frv_flags
operator||=
name|EF_FRV_NON_PIC_RELOCS
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|abfd
argument_list|,
name|frv_flags
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|DPRINTF1
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* After all of the symbols have been adjusted, go over the file looking    for any relocations that pic won't support.  */
end_comment

begin_function
name|void
name|frv_frob_file
parameter_list|()
block|{
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|frv_frob_file_section
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|frv_frob_label
parameter_list|(
name|this_label
parameter_list|)
name|symbolS
modifier|*
name|this_label
decl_stmt|;
block|{
name|struct
name|vliw_insn_list
modifier|*
name|vliw_insn_list_entry
decl_stmt|;
if|if
condition|(
name|frv_mach
operator|!=
name|bfd_mach_frvtomcat
condition|)
return|return;
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
return|return;
name|vliw_insn_list_entry
operator|=
name|frv_insert_vliw_insn
argument_list|(
name|DONT_COUNT
argument_list|)
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|type
operator|=
name|VLIW_LABEL_TYPE
expr_stmt|;
name|vliw_insn_list_entry
operator|->
name|sym
operator|=
name|this_label
expr_stmt|;
block|}
end_function

begin_function
name|fixS
modifier|*
name|frv_cgen_record_fixup_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|operand
parameter_list|,
name|opinfo
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
init|=
name|gas_cgen_record_fixup_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|opinfo
argument_list|,
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|frv_mach
operator|==
name|bfd_mach_frvtomcat
operator|&&
name|current_vliw_insn
operator|&&
name|current_vliw_insn
operator|->
name|type
operator|==
name|VLIW_BRANCH_TYPE
operator|&&
name|exp
operator|!=
name|NULL
condition|)
name|current_vliw_insn
operator|->
name|sym
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

end_unit

