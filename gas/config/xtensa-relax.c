begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Table of relaxations for Xtensa assembly.    Copyright 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the code for generating runtime data structures    for relaxation pattern matching from statically specified strings.    Each action contains an instruction pattern to match and    preconditions for the match as well as an expansion if the pattern    matches.  The preconditions can specify that two operands are the    same or an operand is a specific constant or register.  The expansion    uses the bound variables from the pattern to specify that specific    operands from the pattern should be used in the result.     The code determines whether the condition applies to a constant or    a register depending on the type of the operand.  You may get    unexpected results if you don't match the rule against the operand    type correctly.     The patterns match a language like:     INSN_PATTERN ::= INSN_TEMPL ( '|' PRECOND )* ( '?' OPTIONPRED )*    INSN_TEMPL   ::= OPCODE ' ' [ OPERAND (',' OPERAND)* ]    OPCODE       ::=  id    OPERAND      ::= CONSTANT | VARIABLE | SPECIALFN '(' VARIABLE ')'    SPECIALFN    ::= 'HI24S' | 'F32MINUS' | 'LOW8'                     | 'HI16' | 'LOW16'    VARIABLE     ::= '%' id    PRECOND      ::= OPERAND CMPOP OPERAND    CMPOP        ::= '==' | '!='    OPTIONPRED   ::= OPTIONNAME ('+' OPTIONNAME)    OPTIONNAME   ::= '"' id '"'     The replacement language    INSN_REPL      ::= INSN_LABEL_LIT ( ';' INSN_LABEL_LIT )*    INSN_LABEL_LIT ::= INSN_TEMPL                       | 'LABEL' num                       | 'LITERAL' num ' ' VARIABLE     The operands in a PRECOND must be constants or variables bound by    the INSN_PATTERN.     The configuration options define a predicate on the availability of    options which must be TRUE for this rule to be valid.  Examples are    requiring "density" for replacements with density instructions,    requiring "const16" for replacements that require const16    instructions, etc.  The names are interpreted by the assembler to a    truth value for a particular frag.     The operands in the INSN_REPL must be constants, variables bound in    the associated INSN_PATTERN, special variables that are bound in    the INSN_REPL by LABEL or LITERAL definitions, or special value    manipulation functions.     A simple example of a replacement pattern:    {"movi.n %as,%imm", "movi %as,%imm"} would convert the narrow    movi.n instruction to the wide movi instruction.     A more complex example of a branch around:    {"beqz %as,%label", "bnez %as,%LABEL0;j %label;LABEL0"}    would convert a branch to a negated branch to the following instruction    with a jump to the original label.     An Xtensa-specific example that generates a literal:    {"movi %at,%imm", "LITERAL0 %imm; l32r %at,%LITERAL0"}    will convert a movi instruction to an l32r of a literal    literal defined in the literal pool.     Even more complex is a conversion of a load with immediate offset    to a load of a freshly generated literal, an explicit add and    a load with 0 offset.  This transformation is only valid, though    when the first and second operands are not the same as specified    by the "| %at!=%as" precondition clause.    {"l32i %at,%as,%imm | %at!=%as",    "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"}     There is special case for loop instructions here, but because we do    not currently have the ability to represent the difference of two    symbols, the conversion requires special code in the assembler to    write the operands of the addi/addmi pair representing the    difference of the old and new loop end label.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-relax.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"xtensa-config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XCHAL_HAVE_WIDE_BRANCHES
end_ifndef

begin_define
define|#
directive|define
name|XCHAL_HAVE_WIDE_BRANCHES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Imported from bfd.  */
end_comment

begin_decl_stmt
specifier|extern
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opname_list is a small list of names that we use for opcode and    operand variable names to simplify ownership of these commonly used    strings.  Strings entered in the table can be compared by pointer    equality.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|opname_list_struct
name|opname_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|opname_list
name|opname_e
typedef|;
end_typedef

begin_struct
struct|struct
name|opname_list_struct
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|opname_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|opname_list
modifier|*
name|local_opnames
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "opname_map" and its element structure "opname_map_e" are used    for binding an operand number to a name or a constant.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|opname_map_e_struct
name|opname_map_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|opname_map_struct
name|opname_map
typedef|;
end_typedef

begin_struct
struct|struct
name|opname_map_e_struct
block|{
specifier|const
name|char
modifier|*
name|operand_name
decl_stmt|;
comment|/* If null, then use constant_value.  */
name|int
name|operand_num
decl_stmt|;
name|unsigned
name|constant_value
decl_stmt|;
name|opname_map_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|opname_map_struct
block|{
name|opname_map_e
modifier|*
name|head
decl_stmt|;
name|opname_map_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "precond_list" and its element structure "precond_e" represents    explicit preconditions comparing operand variables and constants.    In the "precond_e" structure, a variable is identified by the name    in the "opname" field.   If that field is NULL, then the operand    is the constant in field "opval".  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|precond_e_struct
name|precond_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|precond_list_struct
name|precond_list
typedef|;
end_typedef

begin_struct
struct|struct
name|precond_e_struct
block|{
specifier|const
name|char
modifier|*
name|opname1
decl_stmt|;
name|unsigned
name|opval1
decl_stmt|;
name|CmpOp
name|cmpop
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname2
decl_stmt|;
name|unsigned
name|opval2
decl_stmt|;
name|precond_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|precond_list_struct
block|{
name|precond_e
modifier|*
name|head
decl_stmt|;
name|precond_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The insn_templ represents the INSN_TEMPL instruction template.  It    is an opcode name with a list of operands.  These are used for    instruction patterns and replacement patterns.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_templ_struct
name|insn_templ
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_templ_struct
block|{
specifier|const
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|opname_map
name|operand_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The insn_pattern represents an INSN_PATTERN instruction pattern.    It is an instruction template with preconditions that specify when    it actually matches a given instruction.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_pattern_struct
name|insn_pattern
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_pattern_struct
block|{
name|insn_templ
name|t
decl_stmt|;
name|precond_list
name|preconds
decl_stmt|;
name|ReqOptionList
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "insn_repl" and associated element structure "insn_repl_e"    instruction replacement list is a list of    instructions/LITERALS/LABELS with constant operands or operands    with names bound to the operand names in the associated pattern.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_repl_e_struct
name|insn_repl_e
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_repl_e_struct
block|{
name|insn_templ
name|t
decl_stmt|;
name|insn_repl_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|insn_repl_struct
name|insn_repl
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_repl_struct
block|{
name|insn_repl_e
modifier|*
name|head
decl_stmt|;
name|insn_repl_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The split_rec is a vector of allocated char * pointers.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|split_rec_struct
name|split_rec
typedef|;
end_typedef

begin_struct
struct|struct
name|split_rec_struct
block|{
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "string_pattern_pair" is a set of pairs containing instruction    patterns and replacement strings.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|string_pattern_pair_struct
name|string_pattern_pair
typedef|;
end_typedef

begin_struct
struct|struct
name|string_pattern_pair_struct
block|{
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|replacement
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The widen_spec_list is a list of valid substitutions that generate    wider representations.  These are generally used to specify    replacements for instructions whose immediates do not fit their    encodings.  A valid transition may require multiple steps of    one-to-one instruction replacements with a final multiple    instruction replacement.  As an example, here are the transitions    required to replace an 'addi.n' with an 'addi', 'addmi'.       addi.n a4, 0x1010      => addi a4, 0x1010      => addmi a4, 0x1010      => addmi a4, 0x1000, addi a4, 0x10.  */
end_comment

begin_decl_stmt
specifier|static
name|string_pattern_pair
name|widen_spec_list
index|[]
init|=
block|{
block|{
literal|"add.n %ar,%as,%at ? IsaUseDensityInstruction"
block|,
literal|"add %ar,%as,%at"
block|}
block|,
block|{
literal|"addi.n %ar,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"addi %ar,%as,%imm"
block|}
block|,
block|{
literal|"beqz.n %as,%label ? IsaUseDensityInstruction"
block|,
literal|"beqz %as,%label"
block|}
block|,
block|{
literal|"bnez.n %as,%label ? IsaUseDensityInstruction"
block|,
literal|"bnez %as,%label"
block|}
block|,
block|{
literal|"l32i.n %at,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"l32i %at,%as,%imm"
block|}
block|,
block|{
literal|"mov.n %at,%as ? IsaUseDensityInstruction"
block|,
literal|"or %at,%as,%as"
block|}
block|,
block|{
literal|"movi.n %as,%imm ? IsaUseDensityInstruction"
block|,
literal|"movi %as,%imm"
block|}
block|,
block|{
literal|"nop.n ? IsaUseDensityInstruction ? realnop"
block|,
literal|"nop"
block|}
block|,
block|{
literal|"nop.n ? IsaUseDensityInstruction ? no-realnop"
block|,
literal|"or 1,1,1"
block|}
block|,
block|{
literal|"ret.n %as ? IsaUseDensityInstruction"
block|,
literal|"ret %as"
block|}
block|,
block|{
literal|"retw.n %as ? IsaUseDensityInstruction"
block|,
literal|"retw %as"
block|}
block|,
block|{
literal|"s32i.n %at,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"s32i %at,%as,%imm"
block|}
block|,
block|{
literal|"srli %at,%as,%imm"
block|,
literal|"extui %at,%as,%imm,F32MINUS(%imm)"
block|}
block|,
block|{
literal|"slli %ar,%as,0"
block|,
literal|"or %ar,%as,%as"
block|}
block|,
comment|/* Widening with literals or const16.  */
block|{
literal|"movi %at,%imm ? IsaUseL32R "
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0"
block|}
block|,
block|{
literal|"movi %at,%imm ? IsaUseConst16"
block|,
literal|"const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm)"
block|}
block|,
block|{
literal|"addi %ar,%as,%imm"
block|,
literal|"addmi %ar,%as,%imm"
block|}
block|,
comment|/* LOW8 is the low 8 bits of the Immed      MID8S is the middle 8 bits of the Immed */
block|{
literal|"addmi %ar,%as,%imm"
block|,
literal|"addmi %ar,%as,HI24S(%imm); addi %ar,%ar,LOW8(%imm)"
block|}
block|,
comment|/* In the end convert to either an l32r or const16.  */
block|{
literal|"addmi %ar,%as,%imm | %ar!=%as ? IsaUseL32R"
block|,
literal|"LITERAL0 %imm; l32r %ar,%LITERAL0; add %ar,%as,%ar"
block|}
block|,
block|{
literal|"addmi %ar,%as,%imm | %ar!=%as ? IsaUseConst16"
block|,
literal|"const16 %ar,HI16U(%imm); const16 %ar,LOW16U(%imm); add %ar,%as,%ar"
block|}
block|,
comment|/* Widening the load instructions with too-large immediates */
block|{
literal|"l8ui %at,%as,%imm | %at!=%as ? IsaUseL32R"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l8ui %at,%at,0"
block|}
block|,
block|{
literal|"l16si %at,%as,%imm | %at!=%as ? IsaUseL32R"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16si %at,%at,0"
block|}
block|,
block|{
literal|"l16ui %at,%as,%imm | %at!=%as ? IsaUseL32R"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16ui %at,%at,0"
block|}
block|,
block|{
literal|"l32i %at,%as,%imm | %at!=%as ? IsaUseL32R"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"
block|}
block|,
comment|/* Widening load instructions with const16s.  */
block|{
literal|"l8ui %at,%as,%imm | %at!=%as ? IsaUseConst16"
block|,
literal|"const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l8ui %at,%at,0"
block|}
block|,
block|{
literal|"l16si %at,%as,%imm | %at!=%as ? IsaUseConst16"
block|,
literal|"const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l16si %at,%at,0"
block|}
block|,
block|{
literal|"l16ui %at,%as,%imm | %at!=%as ? IsaUseConst16"
block|,
literal|"const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l16ui %at,%at,0"
block|}
block|,
block|{
literal|"l32i %at,%as,%imm | %at!=%as ? IsaUseConst16"
block|,
literal|"const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l32i %at,%at,0"
block|}
block|,
comment|/* This is only PART of the loop instruction.  In addition,      hardcoded into its use is a modification of the final operand in      the instruction in bytes 9 and 12.  */
block|{
literal|"loop %as,%label | %as!=1 ? IsaUseLoops"
block|,
literal|"loop %as,%LABEL0;"
literal|"rsr.lend    %as;"
comment|/* LEND */
literal|"wsr.lbeg    %as;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr.lend    %as;"
literal|"isync;"
literal|"rsr.lcount    %as;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
block|{
literal|"loopgtz %as,%label | %as!=1 ? IsaUseLoops"
block|,
literal|"beqz    %as,%label;"
literal|"bltz    %as,%label;"
literal|"loopgtz %as,%LABEL0;"
literal|"rsr.lend    %as;"
comment|/* LEND */
literal|"wsr.lbeg    %as;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr.lend    %as;"
literal|"isync;"
literal|"rsr.lcount    %as;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
block|{
literal|"loopnez %as,%label | %as!=1 ? IsaUseLoops"
block|,
literal|"beqz     %as,%label;"
literal|"loopnez %as,%LABEL0;"
literal|"rsr.lend    %as;"
comment|/* LEND */
literal|"wsr.lbeg    %as;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr.lend    %as;"
literal|"isync;"
literal|"rsr.lcount    %as;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
comment|/* Relaxing to wide branches.  Order is important here.  With wide      branches, there is more than one correct relaxation for an      out-of-range branch.  Put the wide branch relaxations first in the      table since they are more efficient than the branch-around      relaxations.  */
block|{
literal|"beqz %as,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.beqz %as,%label"
block|}
block|,
block|{
literal|"bnez %as,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bnez %as,%label"
block|}
block|,
block|{
literal|"bgez %as,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bgez %as,%label"
block|}
block|,
block|{
literal|"bltz %as,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bltz %as,%label"
block|}
block|,
block|{
literal|"beqi %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.beqi %as,%imm,%label"
block|}
block|,
block|{
literal|"bnei %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bnei %as,%imm,%label"
block|}
block|,
block|{
literal|"bgei %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bgei %as,%imm,%label"
block|}
block|,
block|{
literal|"blti %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.blti %as,%imm,%label"
block|}
block|,
block|{
literal|"bgeui %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bgeui %as,%imm,%label"
block|}
block|,
block|{
literal|"bltui %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bltui %as,%imm,%label"
block|}
block|,
block|{
literal|"bbci %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bbci %as,%imm,%label"
block|}
block|,
block|{
literal|"bbsi %as,%imm,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bbsi %as,%imm,%label"
block|}
block|,
block|{
literal|"beq %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.beq %as,%at,%label"
block|}
block|,
block|{
literal|"bne %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bne %as,%at,%label"
block|}
block|,
block|{
literal|"bge %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bge %as,%at,%label"
block|}
block|,
block|{
literal|"blt %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.blt %as,%at,%label"
block|}
block|,
block|{
literal|"bgeu %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bgeu %as,%at,%label"
block|}
block|,
block|{
literal|"bltu %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bltu %as,%at,%label"
block|}
block|,
block|{
literal|"bany %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bany %as,%at,%label"
block|}
block|,
block|{
literal|"bnone %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bnone %as,%at,%label"
block|}
block|,
block|{
literal|"ball %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.ball %as,%at,%label"
block|}
block|,
block|{
literal|"bnall %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bnall %as,%at,%label"
block|}
block|,
block|{
literal|"bbc %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bbc %as,%at,%label"
block|}
block|,
block|{
literal|"bbs %as,%at,%label ? IsaUseWideBranches"
block|,
literal|"WIDE.bbs %as,%at,%label"
block|}
block|,
comment|/* Widening branch comparisons eq/ne to zero.  Prefer relaxing to narrow      branches if the density option is available.  */
block|{
literal|"beqz %as,%label ? IsaUseDensityInstruction"
block|,
literal|"bnez.n %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnez %as,%label ? IsaUseDensityInstruction"
block|,
literal|"beqz.n %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beqz %as,%label"
block|,
literal|"bnez %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnez %as,%label"
block|,
literal|"beqz %as,%LABEL0;j %label;LABEL0"
block|}
block|,
comment|/* Widening expect-taken branches.  */
block|{
literal|"beqzt %as,%label ? IsaUsePredictedBranches"
block|,
literal|"bnez %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnezt %as,%label ? IsaUsePredictedBranches"
block|,
literal|"beqz %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beqt %as,%at,%label ? IsaUsePredictedBranches"
block|,
literal|"bne %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnet %as,%at,%label ? IsaUsePredictedBranches"
block|,
literal|"beq %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
comment|/* Widening branches from the Xtensa boolean option.  */
block|{
literal|"bt %bs,%label ? IsaUseBooleans"
block|,
literal|"bf %bs,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bf %bs,%label ? IsaUseBooleans"
block|,
literal|"bt %bs,%LABEL0;j %label;LABEL0"
block|}
block|,
comment|/* Other branch-around-jump widenings.  */
block|{
literal|"bgez %as,%label"
block|,
literal|"bltz %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltz %as,%label"
block|,
literal|"bgez %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beqi %as,%imm,%label"
block|,
literal|"bnei %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnei %as,%imm,%label"
block|,
literal|"beqi %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgei %as,%imm,%label"
block|,
literal|"blti %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"blti %as,%imm,%label"
block|,
literal|"bgei %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgeui %as,%imm,%label"
block|,
literal|"bltui %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltui %as,%imm,%label"
block|,
literal|"bgeui %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbci %as,%imm,%label"
block|,
literal|"bbsi %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbsi %as,%imm,%label"
block|,
literal|"bbci %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beq %as,%at,%label"
block|,
literal|"bne %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bne %as,%at,%label"
block|,
literal|"beq %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bge %as,%at,%label"
block|,
literal|"blt %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"blt %as,%at,%label"
block|,
literal|"bge %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgeu %as,%at,%label"
block|,
literal|"bltu %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltu %as,%at,%label"
block|,
literal|"bgeu %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bany %as,%at,%label"
block|,
literal|"bnone %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnone %as,%at,%label"
block|,
literal|"bany %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"ball %as,%at,%label"
block|,
literal|"bnall %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnall %as,%at,%label"
block|,
literal|"ball %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbc %as,%at,%label"
block|,
literal|"bbs %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbs %as,%at,%label"
block|,
literal|"bbc %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
comment|/* Expanding calls with literals.  */
block|{
literal|"call0 %label,%ar0 ? IsaUseL32R"
block|,
literal|"LITERAL0 %label; l32r a0,%LITERAL0; callx0 a0,%ar0"
block|}
block|,
block|{
literal|"call4 %label,%ar4 ? IsaUseL32R"
block|,
literal|"LITERAL0 %label; l32r a4,%LITERAL0; callx4 a4,%ar4"
block|}
block|,
block|{
literal|"call8 %label,%ar8 ? IsaUseL32R"
block|,
literal|"LITERAL0 %label; l32r a8,%LITERAL0; callx8 a8,%ar8"
block|}
block|,
block|{
literal|"call12 %label,%ar12 ? IsaUseL32R"
block|,
literal|"LITERAL0 %label; l32r a12,%LITERAL0; callx12 a12,%ar12"
block|}
block|,
comment|/* Expanding calls with const16.  */
block|{
literal|"call0 %label,%ar0 ? IsaUseConst16"
block|,
literal|"const16 a0,HI16U(%label); const16 a0,LOW16U(%label); callx0 a0,%ar0"
block|}
block|,
block|{
literal|"call4 %label,%ar4 ? IsaUseConst16"
block|,
literal|"const16 a4,HI16U(%label); const16 a4,LOW16U(%label); callx4 a4,%ar4"
block|}
block|,
block|{
literal|"call8 %label,%ar8 ? IsaUseConst16"
block|,
literal|"const16 a8,HI16U(%label); const16 a8,LOW16U(%label); callx8 a8,%ar8"
block|}
block|,
block|{
literal|"call12 %label,%ar12 ? IsaUseConst16"
block|,
literal|"const16 a12,HI16U(%label); const16 a12,LOW16U(%label); callx12 a12,%ar12"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WIDEN_COUNT
value|(sizeof (widen_spec_list) / sizeof (string_pattern_pair))
end_define

begin_comment
comment|/* The simplify_spec_list specifies simplifying transformations that    will reduce the instruction width or otherwise simplify an    instruction.  These are usually applied before relaxation in the    assembler.  It is always legal to simplify.  Even for "addi as, 0",    the "addi.n as, 0" will eventually be widened back to an "addi 0"    after the widening table is applied.  Note: The usage of this table    has changed somewhat so that it is entirely specific to "narrowing"    instructions to use the density option.  This table is not used at    all when the density option is not available.  */
end_comment

begin_decl_stmt
name|string_pattern_pair
name|simplify_spec_list
index|[]
init|=
block|{
block|{
literal|"add %ar,%as,%at ? IsaUseDensityInstruction"
block|,
literal|"add.n %ar,%as,%at"
block|}
block|,
block|{
literal|"addi.n %ar,%as,0 ? IsaUseDensityInstruction"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"addi %ar,%as,0 ? IsaUseDensityInstruction"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"addi %ar,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"addi.n %ar,%as,%imm"
block|}
block|,
block|{
literal|"addmi %ar,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"addi.n %ar,%as,%imm"
block|}
block|,
block|{
literal|"beqz %as,%label ? IsaUseDensityInstruction"
block|,
literal|"beqz.n %as,%label"
block|}
block|,
block|{
literal|"bnez %as,%label ? IsaUseDensityInstruction"
block|,
literal|"bnez.n %as,%label"
block|}
block|,
block|{
literal|"l32i %at,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"l32i.n %at,%as,%imm"
block|}
block|,
block|{
literal|"movi %as,%imm ? IsaUseDensityInstruction"
block|,
literal|"movi.n %as,%imm"
block|}
block|,
block|{
literal|"nop ? realnop ? IsaUseDensityInstruction"
block|,
literal|"nop.n"
block|}
block|,
block|{
literal|"or %ar,%as,%at | %ar==%as | %as==%at ? IsaUseDensityInstruction"
block|,
literal|"nop.n"
block|}
block|,
block|{
literal|"or %ar,%as,%at | %ar!=%as | %as==%at ? IsaUseDensityInstruction"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"ret %as ? IsaUseDensityInstruction"
block|,
literal|"ret.n %as"
block|}
block|,
block|{
literal|"retw %as ? IsaUseDensityInstruction"
block|,
literal|"retw.n %as"
block|}
block|,
block|{
literal|"s32i %at,%as,%imm ? IsaUseDensityInstruction"
block|,
literal|"s32i.n %at,%as,%imm"
block|}
block|,
block|{
literal|"slli %ar,%as,0 ? IsaUseDensityInstruction"
block|,
literal|"mov.n %ar,%as"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIMPLIFY_COUNT
define|\
value|(sizeof (simplify_spec_list) / sizeof (string_pattern_pair))
end_define

begin_escape
end_escape

begin_comment
comment|/* Externally visible functions.  */
end_comment

begin_function_decl
specifier|extern
name|bfd_boolean
name|xg_has_userdef_op_fn
parameter_list|(
name|OpType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|xg_apply_userdef_op_fn
parameter_list|(
name|OpType
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|append_transition
parameter_list|(
name|TransitionTable
modifier|*
name|tt
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|TransitionRule
modifier|*
name|t
parameter_list|,
name|transition_cmp_fn
name|cmp
parameter_list|)
block|{
name|TransitionList
modifier|*
name|tl
init|=
operator|(
name|TransitionList
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionList
argument_list|)
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|prev
decl_stmt|;
name|TransitionList
modifier|*
modifier|*
name|t_p
decl_stmt|;
name|assert
argument_list|(
name|tt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|tt
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
name|prev
operator|=
name|tt
operator|->
name|table
index|[
name|opcode
index|]
expr_stmt|;
name|tl
operator|->
name|rule
operator|=
name|t
expr_stmt|;
name|tl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tt
operator|->
name|table
index|[
name|opcode
index|]
operator|=
name|tl
expr_stmt|;
return|return;
block|}
for|for
control|(
name|t_p
operator|=
operator|&
name|tt
operator|->
name|table
index|[
name|opcode
index|]
init|;
operator|(
operator|*
name|t_p
operator|)
operator|!=
name|NULL
condition|;
name|t_p
operator|=
operator|&
operator|(
operator|*
name|t_p
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cmp
operator|&&
name|cmp
argument_list|(
name|t
argument_list|,
operator|(
operator|*
name|t_p
operator|)
operator|->
name|rule
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Insert it here.  */
name|tl
operator|->
name|next
operator|=
operator|*
name|t_p
expr_stmt|;
operator|*
name|t_p
operator|=
name|tl
expr_stmt|;
return|return;
block|}
block|}
operator|(
operator|*
name|t_p
operator|)
operator|=
name|tl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_condition
parameter_list|(
name|TransitionRule
modifier|*
name|tr
parameter_list|,
name|Precondition
modifier|*
name|cond
parameter_list|)
block|{
name|PreconditionList
modifier|*
name|pl
init|=
operator|(
name|PreconditionList
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PreconditionList
argument_list|)
argument_list|)
decl_stmt|;
name|PreconditionList
modifier|*
name|prev
init|=
name|tr
operator|->
name|conditions
decl_stmt|;
name|PreconditionList
modifier|*
name|nxt
decl_stmt|;
name|pl
operator|->
name|precond
operator|=
name|cond
expr_stmt|;
name|pl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tr
operator|->
name|conditions
operator|=
name|pl
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|nxt
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_value_condition
parameter_list|(
name|TransitionRule
modifier|*
name|tr
parameter_list|,
name|CmpOp
name|cmp
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|op2
parameter_list|)
block|{
name|Precondition
modifier|*
name|cond
init|=
operator|(
name|Precondition
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Precondition
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|->
name|cmp
operator|=
name|cmp
expr_stmt|;
name|cond
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|cond
operator|->
name|typ
operator|=
name|OP_OPERAND
expr_stmt|;
name|cond
operator|->
name|op_data
operator|=
name|op2
expr_stmt|;
name|append_condition
argument_list|(
name|tr
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_constant_value_condition
parameter_list|(
name|TransitionRule
modifier|*
name|tr
parameter_list|,
name|CmpOp
name|cmp
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|cnst
parameter_list|)
block|{
name|Precondition
modifier|*
name|cond
init|=
operator|(
name|Precondition
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Precondition
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|->
name|cmp
operator|=
name|cmp
expr_stmt|;
name|cond
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|cond
operator|->
name|typ
operator|=
name|OP_CONSTANT
expr_stmt|;
name|cond
operator|->
name|op_data
operator|=
name|cnst
expr_stmt|;
name|append_condition
argument_list|(
name|tr
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_build_insn
parameter_list|(
name|TransitionRule
modifier|*
name|tr
parameter_list|,
name|BuildInstr
modifier|*
name|bi
parameter_list|)
block|{
name|BuildInstr
modifier|*
name|prev
init|=
name|tr
operator|->
name|to_instr
decl_stmt|;
name|BuildInstr
modifier|*
name|nxt
decl_stmt|;
name|bi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tr
operator|->
name|to_instr
operator|=
name|bi
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
literal|0
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|bi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|BuildOp
modifier|*
name|b_op
parameter_list|)
block|{
name|BuildOp
modifier|*
name|prev
init|=
name|bi
operator|->
name|ops
decl_stmt|;
name|BuildOp
modifier|*
name|nxt
decl_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|bi
operator|->
name|ops
operator|=
name|b_op
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|nxt
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|b_op
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_literal_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|litnum
parameter_list|)
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_LITERAL
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|litnum
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_label_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|labnum
parameter_list|)
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_LABEL
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|labnum
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_constant_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|cnst
parameter_list|)
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_CONSTANT
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|cnst
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_field_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|src_op
parameter_list|)
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_OPERAND
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|src_op
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These could be generated but are not currently.  */
end_comment

begin_function
specifier|static
name|void
name|append_user_fn_field_op
parameter_list|(
name|BuildInstr
modifier|*
name|bi
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|OpType
name|typ
parameter_list|,
name|unsigned
name|src_op
parameter_list|)
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|typ
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|src_op
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These operand functions are the semantics of user-defined    operand functions.  */
end_comment

begin_function
specifier|static
name|long
name|operand_function_HI24S
parameter_list|(
name|long
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|&
literal|0x80
condition|)
return|return
operator|(
name|a
operator|&
operator|(
operator|~
literal|0xff
operator|)
operator|)
operator|+
literal|0x100
return|;
else|else
return|return
operator|(
name|a
operator|&
operator|(
operator|~
literal|0xff
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|operand_function_F32MINUS
parameter_list|(
name|long
name|a
parameter_list|)
block|{
return|return
operator|(
literal|32
operator|-
name|a
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|operand_function_LOW8
parameter_list|(
name|long
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|&
literal|0x80
condition|)
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
operator||
operator|~
literal|0xff
return|;
else|else
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|operand_function_LOW16U
parameter_list|(
name|long
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|operand_function_HI16U
parameter_list|(
name|long
name|a
parameter_list|)
block|{
name|unsigned
name|long
name|b
init|=
name|a
operator|&
literal|0xffff0000
decl_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|b
operator|>>
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_has_userdef_op_fn
parameter_list|(
name|OpType
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPERAND_F32MINUS
case|:
case|case
name|OP_OPERAND_LOW8
case|:
case|case
name|OP_OPERAND_HI24S
case|:
case|case
name|OP_OPERAND_LOW16U
case|:
case|case
name|OP_OPERAND_HI16U
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|long
name|xg_apply_userdef_op_fn
parameter_list|(
name|OpType
name|op
parameter_list|,
name|long
name|a
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPERAND_F32MINUS
case|:
return|return
name|operand_function_F32MINUS
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_LOW8
case|:
return|return
name|operand_function_LOW8
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_HI24S
case|:
return|return
name|operand_function_HI24S
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_LOW16U
case|:
return|return
name|operand_function_LOW16U
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_HI16U
case|:
return|return
name|operand_function_HI16U
argument_list|(
name|a
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Generate a transition table.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|enter_opname_n
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|opname_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|local_opnames
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|op
operator|->
name|opname
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|len
operator|&&
name|strncmp
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|opname
return|;
block|}
name|op
operator|=
operator|(
name|opname_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_e
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|op
operator|->
name|opname
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|enter_opname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|opname_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|local_opnames
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|opname
return|;
block|}
name|op
operator|=
operator|(
name|opname_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_e
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|op
operator|->
name|opname
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_opname_map
parameter_list|(
name|opname_map
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|tail
operator|=
operator|&
name|m
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_opname_map
parameter_list|(
name|opname_map
modifier|*
name|m
parameter_list|)
block|{
name|opname_map_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|m
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|m
operator|->
name|head
expr_stmt|;
name|m
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|tail
operator|=
operator|&
name|m
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|same_operand_name
parameter_list|(
specifier|const
name|opname_map_e
modifier|*
name|m1
parameter_list|,
specifier|const
name|opname_map_e
modifier|*
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
operator|||
name|m1
operator|->
name|operand_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|m1
operator|->
name|operand_name
operator|==
name|m2
operator|->
name|operand_name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|opname_map_e
modifier|*
name|get_opmatch
parameter_list|(
name|opname_map
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|operand_name
parameter_list|)
block|{
name|opname_map_e
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|map
operator|->
name|head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|operand_name
argument_list|,
name|operand_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|op_is_constant
parameter_list|(
specifier|const
name|opname_map_e
modifier|*
name|m1
parameter_list|)
block|{
return|return
operator|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|op_get_constant
parameter_list|(
specifier|const
name|opname_map_e
modifier|*
name|m1
parameter_list|)
block|{
name|assert
argument_list|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|m1
operator|->
name|constant_value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_precond_list
parameter_list|(
name|precond_list
modifier|*
name|l
parameter_list|)
block|{
name|l
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|tail
operator|=
operator|&
name|l
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_precond_list
parameter_list|(
name|precond_list
modifier|*
name|l
parameter_list|)
block|{
name|precond_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|l
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|l
operator|->
name|head
expr_stmt|;
name|l
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|l
operator|->
name|tail
operator|=
operator|&
name|l
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_insn_templ
parameter_list|(
name|insn_templ
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|opcode_name
operator|=
name|NULL
expr_stmt|;
name|init_opname_map
argument_list|(
operator|&
name|t
operator|->
name|operand_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_insn_templ
parameter_list|(
name|insn_templ
modifier|*
name|t
parameter_list|)
block|{
name|clear_opname_map
argument_list|(
operator|&
name|t
operator|->
name|operand_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_insn_pattern
parameter_list|(
name|insn_pattern
modifier|*
name|p
parameter_list|)
block|{
name|init_insn_templ
argument_list|(
operator|&
name|p
operator|->
name|t
argument_list|)
expr_stmt|;
name|init_precond_list
argument_list|(
operator|&
name|p
operator|->
name|preconds
argument_list|)
expr_stmt|;
name|p
operator|->
name|options
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_insn_pattern
parameter_list|(
name|insn_pattern
modifier|*
name|p
parameter_list|)
block|{
name|clear_insn_templ
argument_list|(
operator|&
name|p
operator|->
name|t
argument_list|)
expr_stmt|;
name|clear_precond_list
argument_list|(
operator|&
name|p
operator|->
name|preconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_insn_repl
parameter_list|(
name|insn_repl
modifier|*
name|r
parameter_list|)
block|{
name|r
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|tail
operator|=
operator|&
name|r
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_insn_repl
parameter_list|(
name|insn_repl
modifier|*
name|r
parameter_list|)
block|{
name|insn_repl_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|r
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|r
operator|->
name|head
expr_stmt|;
name|r
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|clear_insn_templ
argument_list|(
operator|&
name|e
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|tail
operator|=
operator|&
name|r
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|insn_templ_operand_count
parameter_list|(
specifier|const
name|insn_templ
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|opname_map_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|t
operator|->
name|operand_map
operator|.
name|head
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Convert a string to a number.  E.G.: parse_constant("10",&num) */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_constant
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
modifier|*
name|val_p
parameter_list|)
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|in
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
return|return
name|FALSE
return|;
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|val_p
operator|=
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Match a pattern like "foo1" with    parse_id_constant("foo1", "foo",&num).    This may also be used to just match a number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_id_constant
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
modifier|*
name|val_p
parameter_list|)
block|{
name|unsigned
name|namelen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|in
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|&
name|in
index|[
name|namelen
index|]
expr_stmt|;
return|return
name|parse_constant
argument_list|(
name|p
argument_list|,
name|val_p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|parse_special_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fn_name_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|arg_name_p
parameter_list|)
block|{
name|char
modifier|*
name|p_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_end
decl_stmt|;
name|p_start
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_start
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p_end
operator|=
name|strchr
argument_list|(
name|p_start
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_end
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|p_end
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
operator|*
name|fn_name_p
operator|=
name|enter_opname_n
argument_list|(
name|name
argument_list|,
name|p_start
operator|-
name|name
argument_list|)
expr_stmt|;
operator|*
name|arg_name_p
operator|=
name|enter_opname_n
argument_list|(
name|p_start
operator|+
literal|1
argument_list|,
name|p_end
operator|-
name|p_start
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip_white
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|p
return|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trim_whitespace
parameter_list|(
name|char
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|last_white
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|in
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|last_white
operator|==
name|NULL
condition|)
name|last_white
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|last_white
operator|=
name|NULL
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_white
condition|)
operator|*
name|last_white
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a string into component strings where "c" is the    delimiter.  Place the result in the split_rec.  */
end_comment

begin_function
specifier|static
name|void
name|split_string
parameter_list|(
name|split_rec
modifier|*
name|rec
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|char
name|c
parameter_list|,
name|bfd_boolean
name|elide_whitespace
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|in
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|rec
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
name|rec
operator|->
name|vec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|count
operator|==
literal|0
condition|)
return|return;
name|rec
operator|->
name|vec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|elide_whitespace
condition|)
name|q
operator|=
name|skip_white
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|p
operator|-
name|q
expr_stmt|;
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rec
operator|->
name|vec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|elide_whitespace
condition|)
name|trim_whitespace
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|clear_split_rec
parameter_list|(
name|split_rec
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|count
operator|>
literal|0
condition|)
name|free
argument_list|(
name|rec
operator|->
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a split record.  The split record must be initialized    before split_string is called.  */
end_comment

begin_function
specifier|static
name|void
name|init_split_rec
parameter_list|(
name|split_rec
modifier|*
name|rec
parameter_list|)
block|{
name|rec
operator|->
name|vec
operator|=
name|NULL
expr_stmt|;
name|rec
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an instruction template like "insn op1, op2, op3".  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_insn_templ
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|insn_templ
modifier|*
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|insn_name_len
decl_stmt|;
name|split_rec
name|oprec
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First find the first whitespace.  */
name|init_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|insn_name_len
operator|=
name|strcspn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_name_len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|init_insn_templ
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|opcode_name
operator|=
name|enter_opname_n
argument_list|(
name|p
argument_list|,
name|insn_name_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|insn_name_len
expr_stmt|;
comment|/* Split by ',' and skip beginning and trailing whitespace.  */
name|split_string
argument_list|(
operator|&
name|oprec
argument_list|,
name|p
argument_list|,
literal|','
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oprec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
name|oprec
operator|.
name|vec
index|[
name|i
index|]
decl_stmt|;
name|opname_map_e
modifier|*
name|e
init|=
operator|(
name|opname_map_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_map_e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|operand_name
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|constant_value
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|operand_num
operator|=
name|i
expr_stmt|;
comment|/* If it begins with a number, assume that it is a number.  */
if|if
condition|(
name|opname
operator|&&
name|opname
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|opname
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
name|parse_constant
argument_list|(
name|opname
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|e
operator|->
name|constant_value
operator|=
name|val
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
name|clear_insn_templ
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|e
operator|->
name|operand_name
operator|=
name|enter_opname
argument_list|(
name|oprec
operator|.
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|t
operator|->
name|operand_map
operator|.
name|tail
operator|=
name|e
expr_stmt|;
name|t
operator|->
name|operand_map
operator|.
name|tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
name|clear_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|parse_precond
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|precond_e
modifier|*
name|precond
parameter_list|)
block|{
comment|/* All preconditions are currently of the form:      a == b or a != b or a == k (where k is a constant).      Later we may use some special functions like DENSITY == 1      to identify when density is available.  */
specifier|const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|precond
operator|->
name|opname1
operator|=
name|NULL
expr_stmt|;
name|precond
operator|->
name|opval1
operator|=
literal|0
expr_stmt|;
name|precond
operator|->
name|cmpop
operator|=
name|OP_EQUAL
expr_stmt|;
name|precond
operator|->
name|opname2
operator|=
name|NULL
expr_stmt|;
name|precond
operator|->
name|opval2
operator|=
literal|0
expr_stmt|;
name|precond
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|" !="
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|precond
operator|->
name|opname1
operator|=
name|enter_opname_n
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|len
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Check for "==" and "!=".  */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"=="
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|precond
operator|->
name|cmpop
operator|=
name|OP_EQUAL
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"!="
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|precond
operator|->
name|cmpop
operator|=
name|OP_NOTEQUAL
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|p
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* No trailing whitespace from earlier parsing.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
name|parse_constant
argument_list|(
name|p
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|precond
operator|->
name|opval2
operator|=
name|val
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
else|else
name|precond
operator|->
name|opname2
operator|=
name|enter_opname
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_req_or_option_list
parameter_list|(
name|ReqOrOption
modifier|*
modifier|*
name|r_p
parameter_list|)
block|{
if|if
condition|(
operator|*
name|r_p
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
operator|(
operator|*
name|r_p
operator|)
operator|->
name|option_name
argument_list|)
expr_stmt|;
name|clear_req_or_option_list
argument_list|(
operator|&
operator|(
operator|*
name|r_p
operator|)
operator|->
name|next
argument_list|)
expr_stmt|;
operator|*
name|r_p
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_req_option_list
parameter_list|(
name|ReqOption
modifier|*
modifier|*
name|r_p
parameter_list|)
block|{
if|if
condition|(
operator|*
name|r_p
operator|==
name|NULL
condition|)
return|return;
name|clear_req_or_option_list
argument_list|(
operator|&
operator|(
operator|*
name|r_p
operator|)
operator|->
name|or_option_terms
argument_list|)
expr_stmt|;
name|clear_req_option_list
argument_list|(
operator|&
operator|(
operator|*
name|r_p
operator|)
operator|->
name|next
argument_list|)
expr_stmt|;
operator|*
name|r_p
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ReqOrOption
modifier|*
name|clone_req_or_option_list
parameter_list|(
name|ReqOrOption
modifier|*
name|req_or_option
parameter_list|)
block|{
name|ReqOrOption
modifier|*
name|new_req_or_option
decl_stmt|;
if|if
condition|(
name|req_or_option
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|new_req_or_option
operator|=
operator|(
name|ReqOrOption
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ReqOrOption
argument_list|)
argument_list|)
expr_stmt|;
name|new_req_or_option
operator|->
name|option_name
operator|=
name|xstrdup
argument_list|(
name|req_or_option
operator|->
name|option_name
argument_list|)
expr_stmt|;
name|new_req_or_option
operator|->
name|is_true
operator|=
name|req_or_option
operator|->
name|is_true
expr_stmt|;
name|new_req_or_option
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_req_or_option
operator|->
name|next
operator|=
name|clone_req_or_option_list
argument_list|(
name|req_or_option
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|new_req_or_option
return|;
block|}
end_function

begin_function
specifier|static
name|ReqOption
modifier|*
name|clone_req_option_list
parameter_list|(
name|ReqOption
modifier|*
name|req_option
parameter_list|)
block|{
name|ReqOption
modifier|*
name|new_req_option
decl_stmt|;
if|if
condition|(
name|req_option
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|new_req_option
operator|=
operator|(
name|ReqOption
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ReqOption
argument_list|)
argument_list|)
expr_stmt|;
name|new_req_option
operator|->
name|or_option_terms
operator|=
name|NULL
expr_stmt|;
name|new_req_option
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_req_option
operator|->
name|or_option_terms
operator|=
name|clone_req_or_option_list
argument_list|(
name|req_option
operator|->
name|or_option_terms
argument_list|)
expr_stmt|;
name|new_req_option
operator|->
name|next
operator|=
name|clone_req_option_list
argument_list|(
name|req_option
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|new_req_option
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|parse_option_cond
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ReqOption
modifier|*
name|option
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|split_rec
name|option_term_rec
decl_stmt|;
comment|/* All option or conditions are of the form:      optionA + no-optionB + ...      "Ands" are divided by "?".  */
name|init_split_rec
argument_list|(
operator|&
name|option_term_rec
argument_list|)
expr_stmt|;
name|split_string
argument_list|(
operator|&
name|option_term_rec
argument_list|,
name|s
argument_list|,
literal|'+'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_term_rec
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|option_term_rec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|option_term_rec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|option_name
init|=
name|option_term_rec
operator|.
name|vec
index|[
name|i
index|]
decl_stmt|;
name|bfd_boolean
name|is_true
init|=
name|TRUE
decl_stmt|;
name|ReqOrOption
modifier|*
name|req
decl_stmt|;
name|ReqOrOption
modifier|*
modifier|*
name|r_p
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|option_name
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|option_name
operator|=
name|xstrdup
argument_list|(
operator|&
name|option_name
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|is_true
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|option_name
operator|=
name|xstrdup
argument_list|(
name|option_name
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|ReqOrOption
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ReqOrOption
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|option_name
operator|=
name|option_name
expr_stmt|;
name|req
operator|->
name|is_true
operator|=
name|is_true
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Append to list.  */
for|for
control|(
name|r_p
operator|=
operator|&
name|option
operator|->
name|or_option_terms
init|;
operator|(
operator|*
name|r_p
operator|)
operator|!=
name|NULL
condition|;
name|r_p
operator|=
operator|&
operator|(
operator|*
name|r_p
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|(
operator|*
name|r_p
operator|)
operator|=
name|req
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Parse a string like:    "insn op1, op2, op3, op4 | op1 != op2 | op2 == op3 | op4 == 1".    I.E., instruction "insn" with 4 operands where operand 1 and 2 are not    the same and operand 2 and 3 are the same and operand 4 is 1.     or:     "insn op1 | op1 == 1 / density + boolean / no-useroption".    i.e. instruction "insn" with 1 operands where operand 1 is 1    when "density" or "boolean" options are available and    "useroption" is not available.     Because the current implementation of this parsing scheme uses    split_string, it requires that '|' and '?' are only used as    delimiters for predicates and required options.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_insn_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|insn_pattern
modifier|*
name|insn
parameter_list|)
block|{
name|split_rec
name|rec
decl_stmt|;
name|split_rec
name|optionrec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|init_insn_pattern
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|init_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
name|split_string
argument_list|(
operator|&
name|optionrec
argument_list|,
name|in
argument_list|,
literal|'?'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionrec
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|init_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|split_string
argument_list|(
operator|&
name|rec
argument_list|,
name|optionrec
operator|.
name|vec
index|[
literal|0
index|]
argument_list|,
literal|'|'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|parse_insn_templ
argument_list|(
name|rec
operator|.
name|vec
index|[
literal|0
index|]
argument_list|,
operator|&
name|insn
operator|->
name|t
argument_list|)
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|precond_e
modifier|*
name|cond
init|=
operator|(
name|precond_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|precond_e
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parse_precond
argument_list|(
name|rec
operator|.
name|vec
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|)
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Append the condition.  */
operator|*
name|insn
operator|->
name|preconds
operator|.
name|tail
operator|=
name|cond
expr_stmt|;
name|insn
operator|->
name|preconds
operator|.
name|tail
operator|=
operator|&
name|cond
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|optionrec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Handle the option conditions.  */
name|ReqOption
modifier|*
modifier|*
name|r_p
decl_stmt|;
name|ReqOption
modifier|*
name|req_option
init|=
operator|(
name|ReqOption
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ReqOption
argument_list|)
argument_list|)
decl_stmt|;
name|req_option
operator|->
name|or_option_terms
operator|=
name|NULL
expr_stmt|;
name|req_option
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parse_option_cond
argument_list|(
name|optionrec
operator|.
name|vec
index|[
name|i
index|]
argument_list|,
name|req_option
argument_list|)
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|clear_req_option_list
argument_list|(
operator|&
name|req_option
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Append the condition.  */
for|for
control|(
name|r_p
operator|=
operator|&
name|insn
operator|->
name|options
init|;
operator|(
operator|*
name|r_p
operator|)
operator|!=
name|NULL
condition|;
name|r_p
operator|=
operator|&
operator|(
operator|*
name|r_p
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|(
operator|*
name|r_p
operator|)
operator|=
name|req_option
expr_stmt|;
block|}
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|optionrec
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|parse_insn_repl
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|insn_repl
modifier|*
name|r_p
parameter_list|)
block|{
comment|/* This is a list of instruction templates separated by ';'.  */
name|split_rec
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|split_string
argument_list|(
operator|&
name|rec
argument_list|,
name|in
argument_list|,
literal|';'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|insn_repl_e
modifier|*
name|e
init|=
operator|(
name|insn_repl_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|insn_repl_e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_templ
argument_list|(
name|rec
operator|.
name|vec
index|[
name|i
index|]
argument_list|,
operator|&
name|e
operator|->
name|t
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|clear_insn_repl
argument_list|(
name|r_p
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|r_p
operator|->
name|tail
operator|=
name|e
expr_stmt|;
name|r_p
operator|->
name|tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|transition_applies
parameter_list|(
name|insn_pattern
modifier|*
name|initial_insn
parameter_list|,
specifier|const
name|char
modifier|*
name|from_string
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|to_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ReqOption
modifier|*
name|req_option
decl_stmt|;
for|for
control|(
name|req_option
operator|=
name|initial_insn
operator|->
name|options
init|;
name|req_option
operator|!=
name|NULL
condition|;
name|req_option
operator|=
name|req_option
operator|->
name|next
control|)
block|{
name|ReqOrOption
modifier|*
name|req_or_option
init|=
name|req_option
operator|->
name|or_option_terms
decl_stmt|;
if|if
condition|(
name|req_or_option
operator|==
name|NULL
operator|||
name|req_or_option
operator|->
name|next
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|req_or_option
operator|->
name|option_name
argument_list|,
literal|"IsaUse"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_boolean
name|option_available
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|option_name
init|=
name|req_or_option
operator|->
name|option_name
operator|+
literal|6
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"DensityInstruction"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_DENSITY
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"L32R"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_L32R
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"Const16"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_CONST16
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"Loops"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_LOOPS
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"WideBranches"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_WIDE_BRANCHES
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"PredictedBranches"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_PREDICTED_BRANCHES
operator|==
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_name
argument_list|,
literal|"Booleans"
argument_list|)
condition|)
name|option_available
operator|=
operator|(
name|XCHAL_HAVE_BOOLEANS
operator|==
literal|1
operator|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid configuration option '%s' in transition rule '%s'"
argument_list|)
argument_list|,
name|req_or_option
operator|->
name|option_name
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option_available
operator|^
name|req_or_option
operator|->
name|is_true
operator|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|req_or_option
operator|->
name|option_name
argument_list|,
literal|"realnop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_boolean
name|nop_available
init|=
operator|(
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"nop"
argument_list|)
operator|!=
name|XTENSA_UNDEFINED
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|nop_available
operator|^
name|req_or_option
operator|->
name|is_true
operator|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|wide_branch_opcode
parameter_list|(
specifier|const
name|char
modifier|*
name|opcode_name
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|,
name|xtensa_opcode
modifier|*
name|popcode
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
specifier|static
name|char
name|wbr_name_buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|opcode_name
argument_list|,
literal|"WIDE."
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|wbr_name_buf
argument_list|,
name|opcode_name
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|wbr_name_buf
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|wbr_name_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|popcode
operator|=
name|opcode
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|TransitionRule
modifier|*
name|build_transition
parameter_list|(
name|insn_pattern
modifier|*
name|initial_insn
parameter_list|,
name|insn_repl
modifier|*
name|replace_insns
parameter_list|,
specifier|const
name|char
modifier|*
name|from_string
parameter_list|,
specifier|const
name|char
modifier|*
name|to_string
parameter_list|)
block|{
name|TransitionRule
modifier|*
name|tr
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|opname_map_e
modifier|*
name|op1
decl_stmt|;
name|opname_map_e
modifier|*
name|op2
decl_stmt|;
name|precond_e
modifier|*
name|precond
decl_stmt|;
name|insn_repl_e
modifier|*
name|r
decl_stmt|;
name|unsigned
name|label_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|max_label_count
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|has_label
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|literal_count
init|=
literal|0
decl_stmt|;
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|initial_insn
operator|->
name|t
operator|.
name|opcode_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
comment|/* It is OK to not be able to translate some of these opcodes.  */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|!=
name|insn_templ_operand_count
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
argument_list|)
condition|)
block|{
comment|/* This is also OK because there are opcodes that 	 have different numbers of operands on different 	 architecture variations.  */
return|return
name|NULL
return|;
block|}
name|tr
operator|=
operator|(
name|TransitionRule
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionRule
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|tr
operator|->
name|conditions
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|to_instr
operator|=
name|NULL
expr_stmt|;
comment|/* Build the conditions. First, equivalent operand condition....  */
for|for
control|(
name|op1
operator|=
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op1
operator|!=
name|NULL
condition|;
name|op1
operator|=
name|op1
operator|->
name|next
control|)
block|{
for|for
control|(
name|op2
operator|=
name|op1
operator|->
name|next
init|;
name|op2
operator|!=
name|NULL
condition|;
name|op2
operator|=
name|op2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|same_operand_name
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
condition|)
block|{
name|append_value_condition
argument_list|(
name|tr
argument_list|,
name|OP_EQUAL
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now the condition that an operand value must be a constant....  */
for|for
control|(
name|op1
operator|=
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op1
operator|!=
name|NULL
condition|;
name|op1
operator|=
name|op1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|op_is_constant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|OP_EQUAL
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op_get_constant
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add the explicit preconditions listed after the "|" in the spec.      These are currently very limited, so we do a special case      parse for them.  We expect spaces, opname != opname.  */
for|for
control|(
name|precond
operator|=
name|initial_insn
operator|->
name|preconds
operator|.
name|head
init|;
name|precond
operator|!=
name|NULL
condition|;
name|precond
operator|=
name|precond
operator|->
name|next
control|)
block|{
name|op1
operator|=
name|NULL
expr_stmt|;
name|op2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|precond
operator|->
name|opname1
condition|)
block|{
name|op1
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|precond
operator|->
name|opname1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': no bound opname '%s' "
literal|"for precondition in '%s'"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|precond
operator|->
name|opname1
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|precond
operator|->
name|opname2
condition|)
block|{
name|op2
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|precond
operator|->
name|opname2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': no bound opname '%s' "
literal|"for precondition in %s"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|precond
operator|->
name|opname2
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|op1
operator|==
name|NULL
operator|&&
name|op2
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': precondition only contains "
literal|"constants in '%s'"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|op1
operator|!=
name|NULL
operator|&&
name|op2
operator|!=
name|NULL
condition|)
name|append_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op2
operator|==
name|NULL
condition|)
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|precond
operator|->
name|opval2
argument_list|)
expr_stmt|;
else|else
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|,
name|precond
operator|->
name|opval1
argument_list|)
expr_stmt|;
block|}
name|tr
operator|->
name|options
operator|=
name|clone_req_option_list
argument_list|(
name|initial_insn
operator|->
name|options
argument_list|)
expr_stmt|;
comment|/* Generate the replacement instructions.  Some of these      "instructions" are actually labels and literals.  The literals      must be defined in order 0..n and a literal must be defined      (e.g., "LITERAL0 %imm") before use (e.g., "%LITERAL0").  The      labels must be defined in order, but they can be used before they      are defined.  Also there are a number of special operands (e.g.,      HI24S).  */
for|for
control|(
name|r
operator|=
name|replace_insns
operator|->
name|head
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|int
name|operand_count
decl_stmt|;
name|opname_map_e
modifier|*
name|op
decl_stmt|;
name|unsigned
name|idnum
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|operand_arg_name
decl_stmt|;
name|bi
operator|=
operator|(
name|BuildInstr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildInstr
argument_list|)
argument_list|)
expr_stmt|;
name|append_build_insn
argument_list|(
name|tr
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|bi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|bi
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|bi
operator|->
name|ops
operator|=
name|NULL
expr_stmt|;
name|bi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|opcode_name
operator|=
name|r
operator|->
name|t
operator|.
name|opcode_name
expr_stmt|;
name|operand_count
operator|=
name|insn_templ_operand_count
argument_list|(
operator|&
name|r
operator|->
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_id_constant
argument_list|(
name|opcode_name
argument_list|,
literal|"LITERAL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_LITERAL_DEF
expr_stmt|;
name|bi
operator|->
name|id
operator|=
name|idnum
expr_stmt|;
if|if
condition|(
name|idnum
operator|!=
name|literal_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"generated literals must be numbered consecutively"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|literal_count
expr_stmt|;
if|if
condition|(
name|operand_count
operator|!=
literal|1
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected one operand for generated literal"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|opcode_name
argument_list|,
literal|"LABEL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_LABEL_DEF
expr_stmt|;
name|bi
operator|->
name|id
operator|=
name|idnum
expr_stmt|;
if|if
condition|(
name|idnum
operator|!=
name|label_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"generated labels must be numbered consecutively"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|label_count
expr_stmt|;
if|if
condition|(
name|operand_count
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected 0 operands for generated label"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_INSTR
expr_stmt|;
if|if
condition|(
name|wide_branch_opcode
argument_list|(
name|opcode_name
argument_list|,
literal|".w18"
argument_list|,
operator|&
name|bi
operator|->
name|opcode
argument_list|)
operator|||
name|wide_branch_opcode
argument_list|(
name|opcode_name
argument_list|,
literal|".w15"
argument_list|,
operator|&
name|bi
operator|->
name|opcode
argument_list|)
condition|)
name|opcode_name
operator|=
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|bi
operator|->
name|opcode
argument_list|)
expr_stmt|;
else|else
name|bi
operator|->
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|opcode_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid opcode '%s' in transition rule '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check for the right number of ops.  */
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|bi
operator|->
name|opcode
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|operand_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': replacement does not have %d ops"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|bi
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|op
operator|=
name|r
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|unsigned
name|idnum
decl_stmt|;
if|if
condition|(
name|op_is_constant
argument_list|(
name|op
argument_list|)
condition|)
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|op_get_constant
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"%LITERAL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|idnum
operator|>=
name|literal_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: replacement "
literal|"literal %d>= literal_count(%d)"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|idnum
argument_list|,
name|literal_count
argument_list|)
expr_stmt|;
name|append_literal_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"%LABEL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|has_label
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|idnum
operator|>
name|max_label_count
condition|)
name|max_label_count
operator|=
name|idnum
expr_stmt|;
name|append_label_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"a"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|operand_name
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
name|opname_map_e
modifier|*
name|orig_op
decl_stmt|;
name|orig_op
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|op
operator|->
name|operand_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_op
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: unidentified operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|append_field_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|orig_op
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_special_fn
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
operator|&
name|fn_name
argument_list|,
operator|&
name|operand_arg_name
argument_list|)
condition|)
block|{
name|opname_map_e
modifier|*
name|orig_op
decl_stmt|;
name|OpType
name|typ
init|=
name|OP_CONSTANT
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"LOW8"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_LOW8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"HI24S"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_HI24S
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"F32MINUS"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_F32MINUS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"LOW16U"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_LOW16U
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"HI16U"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_HI16U
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown user-defined function %s"
argument_list|)
argument_list|,
name|fn_name
argument_list|)
expr_stmt|;
name|orig_op
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|operand_arg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_op
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: unidentified operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|append_user_fn_field_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|typ
argument_list|,
name|orig_op
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: could not parse operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|has_label
operator|&&
name|max_label_count
operator|>=
name|label_count
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: replacement label %d>= label_count(%d)"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|max_label_count
argument_list|,
name|label_count
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|tr
return|;
block|}
end_function

begin_function
specifier|static
name|TransitionTable
modifier|*
name|build_transition_table
parameter_list|(
specifier|const
name|string_pattern_pair
modifier|*
name|transitions
parameter_list|,
name|int
name|transition_count
parameter_list|,
name|transition_cmp_fn
name|cmp
parameter_list|)
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
name|int
name|num_opcodes
init|=
name|xtensa_isa_num_opcodes
argument_list|(
name|xtensa_default_isa
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tnum
decl_stmt|;
if|if
condition|(
name|table
operator|!=
name|NULL
condition|)
return|return
name|table
return|;
comment|/* Otherwise, build it now.  */
name|table
operator|=
operator|(
name|TransitionTable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionTable
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_opcodes
operator|=
name|num_opcodes
expr_stmt|;
name|table
operator|->
name|table
operator|=
operator|(
name|TransitionList
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionTable
operator|*
argument_list|)
operator|*
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
control|)
name|table
operator|->
name|table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tnum
operator|=
literal|0
init|;
name|tnum
operator|<
name|transition_count
condition|;
name|tnum
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|from_string
init|=
name|transitions
index|[
name|tnum
index|]
operator|.
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_string
init|=
name|transitions
index|[
name|tnum
index|]
operator|.
name|replacement
decl_stmt|;
name|insn_pattern
name|initial_insn
decl_stmt|;
name|insn_repl
name|replace_insns
decl_stmt|;
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|init_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_pattern
argument_list|(
name|from_string
argument_list|,
operator|&
name|initial_insn
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"could not parse INSN_PATTERN '%s'"
argument_list|)
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|init_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_repl
argument_list|(
name|to_string
argument_list|,
operator|&
name|replace_insns
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"could not parse INSN_REPL '%s'"
argument_list|)
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
name|clear_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|transition_applies
argument_list|(
operator|&
name|initial_insn
argument_list|,
name|from_string
argument_list|,
name|to_string
argument_list|)
condition|)
block|{
name|tr
operator|=
name|build_transition
argument_list|(
operator|&
name|initial_insn
argument_list|,
operator|&
name|replace_insns
argument_list|,
name|from_string
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|append_transition
argument_list|(
name|table
argument_list|,
name|tr
operator|->
name|opcode
argument_list|,
name|tr
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|TENSILICA_DEBUG
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not build transition for %s => %s"
argument_list|)
argument_list|,
name|from_string
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|clear_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|extern
name|TransitionTable
modifier|*
name|xg_build_widen_table
parameter_list|(
name|transition_cmp_fn
name|cmp
parameter_list|)
block|{
specifier|static
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
name|table
operator|=
name|build_transition_table
argument_list|(
name|widen_spec_list
argument_list|,
name|WIDEN_COUNT
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_function
specifier|extern
name|TransitionTable
modifier|*
name|xg_build_simplify_table
parameter_list|(
name|transition_cmp_fn
name|cmp
parameter_list|)
block|{
specifier|static
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
name|table
operator|=
name|build_transition_table
argument_list|(
name|simplify_spec_list
argument_list|,
name|SIMPLIFY_COUNT
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

end_unit

