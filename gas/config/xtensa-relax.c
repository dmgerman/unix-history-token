begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Table of relaxations for Xtensa assembly.    Copyright 2003 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,     MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the code for generating runtime data structures    for relaxation pattern matching from statically specified strings.    Each action contains an instruction pattern to match and    preconditions for the match as well as an expansion if the pattern    matches.  The preconditions can specify that two operands are the    same or an operand is a specific constant.  The expansion uses the    bound variables from the pattern to specify that specific operands    from the pattern should be used in the result.       The patterns match a language like:     INSN_PATTERN ::= INSN_TEMPL ( '|' PRECOND )*    INSN_TEMPL   ::= OPCODE ' ' [ OPERAND (',' OPERAND)* ]    OPCODE       ::=  id    OPERAND      ::= CONSTANT | VARIABLE | SPECIALFN '(' VARIABLE ')'    SPECIALFN    ::= 'HI24S' | 'F32MINUS' | 'LOW8'    VARIABLE     ::= '%' id    PRECOND      ::= OPERAND CMPOP OPERAND    CMPOP        ::= '==' | '!='     The replacement language     INSN_REPL      ::= INSN_LABEL_LIT ( ';' INSN_LABEL_LIT )*    INSN_LABEL_LIT ::= INSN_TEMPL                        | 'LABEL' num                        | 'LITERAL' num ' ' VARIABLE     The operands in a PRECOND must be constants or variables bound by    the INSN_PATTERN.     The operands in the INSN_REPL must be constants, variables bound in    the associated INSN_PATTERN, special variables that are bound in    the INSN_REPL by LABEL or LITERAL definitions, or special value    manipulation functions.     A simple example of a replacement pattern:    {"movi.n %as,%imm", "movi %as,%imm"} would convert the narrow    movi.n instruction to the wide movi instruction.     A more complex example of a branch around:    {"beqz %as,%label", "bnez %as,%LABEL0;j %label;LABEL0"}    would convert a branch to a negated branch to the following instruction    with a jump to the original label.        An Xtensa-specific example that generates a literal:    {"movi %at,%imm", "LITERAL0 %imm; l32r %at,%LITERAL0"}    will convert a movi instruction to an l32r of a literal    literal defined in the literal pool.     Even more complex is a conversion of a load with immediate offset    to a load of a freshly generated literal, an explicit add and    a load with 0 offset.  This transformation is only valid, though    when the first and second operands are not the same as specified    by the "| %at!=%as" precondition clause.    {"l32i %at,%as,%imm | %at!=%as",    "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"}     There is special case for loop instructions here, but because we do    not currently have the ability to represent the difference of two    symbols, the conversion requires special code in the assembler to    write the operands of the addi/addmi pair representing the    difference of the old and new loop end label.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-relax.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* Imported from bfd.  */
end_comment

begin_decl_stmt
specifier|extern
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opname_list is a small list of names that we use for opcode and    operand variable names to simplify ownership of these commonly used    strings.  Strings entered in the table can be compared by pointer    equality.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|opname_list_struct
name|opname_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|opname_list
name|opname_e
typedef|;
end_typedef

begin_struct
struct|struct
name|opname_list_struct
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|opname_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|opname_list
modifier|*
name|local_opnames
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "opname_map" and its element structure "opname_map_e" are used    for binding an operand number to a name or a constant.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|opname_map_e_struct
name|opname_map_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|opname_map_struct
name|opname_map
typedef|;
end_typedef

begin_struct
struct|struct
name|opname_map_e_struct
block|{
specifier|const
name|char
modifier|*
name|operand_name
decl_stmt|;
comment|/* If null, then use constant_value.  */
name|size_t
name|operand_num
decl_stmt|;
name|unsigned
name|constant_value
decl_stmt|;
name|opname_map_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|opname_map_struct
block|{
name|opname_map_e
modifier|*
name|head
decl_stmt|;
name|opname_map_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "precond_list" and its element structure "precond_e" represents    explicit preconditions comparing operand variables and constants.    In the "precond_e" structure, a variable is identified by the name    in the "opname" field.   If that field is NULL, then the operand    is the constant in field "opval".  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|precond_e_struct
name|precond_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|precond_list_struct
name|precond_list
typedef|;
end_typedef

begin_struct
struct|struct
name|precond_e_struct
block|{
specifier|const
name|char
modifier|*
name|opname1
decl_stmt|;
name|unsigned
name|opval1
decl_stmt|;
name|CmpOp
name|cmpop
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname2
decl_stmt|;
name|unsigned
name|opval2
decl_stmt|;
name|precond_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|precond_list_struct
block|{
name|precond_e
modifier|*
name|head
decl_stmt|;
name|precond_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The insn_templ represents the INSN_TEMPL instruction template.  It    is an opcode name with a list of operands.  These are used for    instruction patterns and replacement patterns.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_templ_struct
name|insn_templ
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_templ_struct
block|{
specifier|const
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|opname_map
name|operand_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The insn_pattern represents an INSN_PATTERN instruction pattern.    It is an instruction template with preconditions that specify when    it actually matches a given instruction.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_pattern_struct
name|insn_pattern
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_pattern_struct
block|{
name|insn_templ
name|t
decl_stmt|;
name|precond_list
name|preconds
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "insn_repl" and associated element structure "insn_repl_e"    instruction replacement list is a list of    instructions/LITERALS/LABELS with constant operands or operands    with names bound to the operand names in the associated pattern.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|insn_repl_e_struct
name|insn_repl_e
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_repl_e_struct
block|{
name|insn_templ
name|t
decl_stmt|;
name|insn_repl_e
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|insn_repl_struct
name|insn_repl
typedef|;
end_typedef

begin_struct
struct|struct
name|insn_repl_struct
block|{
name|insn_repl_e
modifier|*
name|head
decl_stmt|;
name|insn_repl_e
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The split_rec is a vector of allocated char * pointers.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|split_rec_struct
name|split_rec
typedef|;
end_typedef

begin_struct
struct|struct
name|split_rec_struct
block|{
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|size_t
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The "string_pattern_pair" is a set of pairs containing instruction    patterns and replacement strings.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|string_pattern_pair_struct
name|string_pattern_pair
typedef|;
end_typedef

begin_struct
struct|struct
name|string_pattern_pair_struct
block|{
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|replacement
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The widen_spec_list is a list of valid substitutions that generate    wider representations.  These are generally used to specify    replacements for instructions whose immediates do not fit their    encodings.  A valid transition may require multiple steps of    one-to-one instruction replacements with a final multiple    instruction replacement.  As an example, here are the transitions    required to replace an 'addi.n' with an 'addi', 'addmi'.       addi.n a4, 0x1010      => addi a4, 0x1010      => addmi a4, 0x1010      => addmi a4, 0x1000, addi a4, 0x10.  */
end_comment

begin_decl_stmt
specifier|static
name|string_pattern_pair
name|widen_spec_list
index|[]
init|=
block|{
block|{
literal|"add.n %ar,%as,%at"
block|,
literal|"add %ar,%as,%at"
block|}
block|,
block|{
literal|"addi.n %ar,%as,%imm"
block|,
literal|"addi %ar,%as,%imm"
block|}
block|,
block|{
literal|"beqz.n %as,%label"
block|,
literal|"beqz %as,%label"
block|}
block|,
block|{
literal|"bnez.n %as,%label"
block|,
literal|"bnez %as,%label"
block|}
block|,
block|{
literal|"l32i.n %at,%as,%imm"
block|,
literal|"l32i %at,%as,%imm"
block|}
block|,
block|{
literal|"mov.n %at,%as"
block|,
literal|"or %at,%as,%as"
block|}
block|,
block|{
literal|"movi.n %as,%imm"
block|,
literal|"movi %as,%imm"
block|}
block|,
block|{
literal|"nop.n"
block|,
literal|"or 1,1,1"
block|}
block|,
block|{
literal|"ret.n"
block|,
literal|"ret"
block|}
block|,
block|{
literal|"retw.n"
block|,
literal|"retw"
block|}
block|,
block|{
literal|"s32i.n %at,%as,%imm"
block|,
literal|"s32i %at,%as,%imm"
block|}
block|,
block|{
literal|"srli %at,%as,%imm"
block|,
literal|"extui %at,%as,%imm,F32MINUS(%imm)"
block|}
block|,
block|{
literal|"slli %ar,%as,0"
block|,
literal|"or %ar,%as,%as"
block|}
block|,
comment|/* Widening with literals */
block|{
literal|"movi %at,%imm"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0"
block|}
block|,
block|{
literal|"addi %ar,%as,%imm"
block|,
literal|"addmi %ar,%as,%imm"
block|}
block|,
comment|/* LOW8 is the low 8 bits of the Immed      MID8S is the middle 8 bits of the Immed */
block|{
literal|"addmi %ar,%as,%imm"
block|,
literal|"addmi %ar,%as,HI24S(%imm); addi %ar,%ar,LOW8(%imm)"
block|}
block|,
block|{
literal|"addmi %ar,%as,%imm | %ar!=%as"
block|,
literal|"LITERAL0 %imm; l32r %ar,%LITERAL0; add %ar,%as,%ar"
block|}
block|,
comment|/* Widening the load instructions with too-large immediates */
block|{
literal|"l8ui %at,%as,%imm | %at!=%as"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l8ui %at,%at,0"
block|}
block|,
block|{
literal|"l16si %at,%as,%imm | %at!=%as"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16si %at,%at,0"
block|}
block|,
block|{
literal|"l16ui %at,%as,%imm | %at!=%as"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16ui %at,%at,0"
block|}
block|,
if|#
directive|if
literal|0
comment|/* Xtensa Synchronization Option not yet available */
block|{"l32ai %at,%as,%imm",    "LITERAL0 %imm; l32r %at,%LITERAL0; add.n %at,%at,%as; l32ai %at,%at,0"},
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Xtensa Speculation Option not yet available */
block|{"l32is %at,%as,%imm",    "LITERAL0 %imm; l32r %at,%LITERAL0; add.n %at,%at,%as; l32is %at,%at,0"},
endif|#
directive|endif
block|{
literal|"l32i %at,%as,%imm | %at!=%as"
block|,
literal|"LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"
block|}
block|,
comment|/* This is only PART of the loop instruction.  In addition, hard      coded into it's use is a modification of the final operand in the      instruction in bytes 9 and 12.  */
block|{
literal|"loop %as,%label"
block|,
literal|"loop %as,%LABEL0;"
literal|"rsr     %as, 1;"
comment|/* LEND */
literal|"wsr     %as, 0;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr     %as, 1;"
literal|"isync;"
literal|"rsr     %as, 2;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
block|{
literal|"loopgtz %as,%label"
block|,
literal|"beqz     %as,%label;"
literal|"bltz     %as,%label;"
literal|"loopgtz %as,%LABEL0;"
literal|"rsr     %as, 1;"
comment|/* LEND */
literal|"wsr     %as, 0;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr     %as, 1;"
literal|"isync;"
literal|"rsr     %as, 2;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
block|{
literal|"loopnez %as,%label"
block|,
literal|"beqz     %as,%label;"
literal|"loopnez %as,%LABEL0;"
literal|"rsr     %as, 1;"
comment|/* LEND */
literal|"wsr     %as, 0;"
comment|/* LBEG */
literal|"addi    %as, %as, 0;"
comment|/* lo8(%label-%LABEL1) */
literal|"addmi   %as, %as, 0;"
comment|/* mid8(%label-%LABEL1) */
literal|"wsr     %as, 1;"
literal|"isync;"
literal|"rsr     %as, 2;"
comment|/* LCOUNT */
literal|"addi    %as, %as, 1;"
comment|/* density -> addi.n %as, %as, 1 */
literal|"LABEL0"
block|}
block|,
if|#
directive|if
literal|0
comment|/* no mechanism here to determine if Density Option is available */
block|{"beqz %as,%label", "bnez.n %as,%LABEL0;j %label;LABEL0"},   {"bnez %as,%label", "beqz.n %as,%LABEL0;j %label;LABEL0"},
else|#
directive|else
block|{
literal|"beqz %as,%label"
block|,
literal|"bnez %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnez %as,%label"
block|,
literal|"beqz %as,%LABEL0;j %label;LABEL0"
block|}
block|,
endif|#
directive|endif
block|{
literal|"bgez %as,%label"
block|,
literal|"bltz %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltz %as,%label"
block|,
literal|"bgez %as,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beqi %as,%imm,%label"
block|,
literal|"bnei %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnei %as,%imm,%label"
block|,
literal|"beqi %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgei %as,%imm,%label"
block|,
literal|"blti %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"blti %as,%imm,%label"
block|,
literal|"bgei %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgeui %as,%imm,%label"
block|,
literal|"bltui %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltui %as,%imm,%label"
block|,
literal|"bgeui %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbci %as,%imm,%label"
block|,
literal|"bbsi %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbsi %as,%imm,%label"
block|,
literal|"bbci %as,%imm,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"beq %as,%at,%label"
block|,
literal|"bne %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bne %as,%at,%label"
block|,
literal|"beq %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bge %as,%at,%label"
block|,
literal|"blt %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"blt %as,%at,%label"
block|,
literal|"bge %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bgeu %as,%at,%label"
block|,
literal|"bltu %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bltu %as,%at,%label"
block|,
literal|"bgeu %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bany %as,%at,%label"
block|,
literal|"bnone %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
if|#
directive|if
literal|1
comment|/* provide relaxations for Boolean Option */
block|{
literal|"bt %bs,%label"
block|,
literal|"bf %bs,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bf %bs,%label"
block|,
literal|"bt %bs,%LABEL0;j %label;LABEL0"
block|}
block|,
endif|#
directive|endif
block|{
literal|"bnone %as,%at,%label"
block|,
literal|"bany %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"ball %as,%at,%label"
block|,
literal|"bnall %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bnall %as,%at,%label"
block|,
literal|"ball %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbc %as,%at,%label"
block|,
literal|"bbs %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"bbs %as,%at,%label"
block|,
literal|"bbc %as,%at,%LABEL0;j %label;LABEL0"
block|}
block|,
block|{
literal|"call0 %label"
block|,
literal|"LITERAL0 %label; l32r a0,%LITERAL0; callx0 a0"
block|}
block|,
block|{
literal|"call4 %label"
block|,
literal|"LITERAL0 %label; l32r a4,%LITERAL0; callx4 a4"
block|}
block|,
block|{
literal|"call8 %label"
block|,
literal|"LITERAL0 %label; l32r a8,%LITERAL0; callx8 a8"
block|}
block|,
block|{
literal|"call12 %label"
block|,
literal|"LITERAL0 %label; l32r a12,%LITERAL0; callx12 a12"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WIDEN_COUNT
value|(sizeof (widen_spec_list) / sizeof (string_pattern_pair))
end_define

begin_comment
comment|/* The simplify_spec_list specifies simplifying transformations that    will reduce the instruction width or otherwise simplify an    instruction.  These are usually applied before relaxation in the    assembler.  It is always legal to simplify.  Even for "addi as, 0",    the "addi.n as, 0" will eventually be widened back to an "addi 0"    after the widening table is applied.  Note: The usage of this table    has changed somewhat so that it is entirely specific to "narrowing"    instructions to use the density option.  This table is not used at    all when the density option is not available.  */
end_comment

begin_decl_stmt
name|string_pattern_pair
name|simplify_spec_list
index|[]
init|=
block|{
block|{
literal|"add %ar,%as,%at"
block|,
literal|"add.n %ar,%as,%at"
block|}
block|,
block|{
literal|"addi.n %ar,%as,0"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"addi %ar,%as,0"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"addi %ar,%as,%imm"
block|,
literal|"addi.n %ar,%as,%imm"
block|}
block|,
block|{
literal|"addmi %ar,%as,%imm"
block|,
literal|"addi.n %ar,%as,%imm"
block|}
block|,
block|{
literal|"beqz %as,%label"
block|,
literal|"beqz.n %as,%label"
block|}
block|,
block|{
literal|"bnez %as,%label"
block|,
literal|"bnez.n %as,%label"
block|}
block|,
block|{
literal|"l32i %at,%as,%imm"
block|,
literal|"l32i.n %at,%as,%imm"
block|}
block|,
block|{
literal|"movi %as,%imm"
block|,
literal|"movi.n %as,%imm"
block|}
block|,
block|{
literal|"or %ar,%as,%at | %as==%at"
block|,
literal|"mov.n %ar,%as"
block|}
block|,
block|{
literal|"ret"
block|,
literal|"ret.n"
block|}
block|,
block|{
literal|"retw"
block|,
literal|"retw.n"
block|}
block|,
block|{
literal|"s32i %at,%as,%imm"
block|,
literal|"s32i.n %at,%as,%imm"
block|}
block|,
block|{
literal|"slli %ar,%as,0"
block|,
literal|"mov.n %ar,%as"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIMPLIFY_COUNT
define|\
value|(sizeof (simplify_spec_list) / sizeof (string_pattern_pair))
end_define

begin_escape
end_escape

begin_comment
comment|/* Transition generation helpers.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|append_transition
name|PARAMS
argument_list|(
operator|(
name|TransitionTable
operator|*
operator|,
name|xtensa_opcode
operator|,
name|TransitionRule
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_condition
name|PARAMS
argument_list|(
operator|(
name|TransitionRule
operator|*
operator|,
name|Precondition
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_value_condition
name|PARAMS
argument_list|(
operator|(
name|TransitionRule
operator|*
operator|,
name|CmpOp
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_constant_value_condition
name|PARAMS
argument_list|(
operator|(
name|TransitionRule
operator|*
operator|,
name|CmpOp
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_build_insn
name|PARAMS
argument_list|(
operator|(
name|TransitionRule
operator|*
operator|,
name|BuildInstr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|BuildOp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_literal_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_label_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_constant_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_field_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_user_fn_field_op
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|unsigned
operator|,
name|OpType
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|operand_function_HI24S
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|operand_function_F32MINUS
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|operand_function_LOW8
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Externally visible functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|xg_has_userdef_op_fn
name|PARAMS
argument_list|(
operator|(
name|OpType
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|xg_apply_userdef_op_fn
name|PARAMS
argument_list|(
operator|(
name|OpType
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing helpers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|enter_opname_n
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|enter_opname
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construction and destruction.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_opname_map
name|PARAMS
argument_list|(
operator|(
name|opname_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_opname_map
name|PARAMS
argument_list|(
operator|(
name|opname_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_precond_list
name|PARAMS
argument_list|(
operator|(
name|precond_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_precond_list
name|PARAMS
argument_list|(
operator|(
name|precond_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_insn_templ
name|PARAMS
argument_list|(
operator|(
name|insn_templ
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_insn_templ
name|PARAMS
argument_list|(
operator|(
name|insn_templ
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_insn_pattern
name|PARAMS
argument_list|(
operator|(
name|insn_pattern
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_insn_pattern
name|PARAMS
argument_list|(
operator|(
name|insn_pattern
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_insn_repl
name|PARAMS
argument_list|(
operator|(
name|insn_repl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_insn_repl
name|PARAMS
argument_list|(
operator|(
name|insn_repl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_split_rec
name|PARAMS
argument_list|(
operator|(
name|split_rec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_split_rec
name|PARAMS
argument_list|(
operator|(
name|split_rec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Operand and insn_templ helpers.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|same_operand_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|opname_map_e
operator|*
operator|,
specifier|const
name|opname_map_e
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|opname_map_e
modifier|*
name|get_opmatch
name|PARAMS
argument_list|(
operator|(
name|opname_map
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|op_is_constant
name|PARAMS
argument_list|(
operator|(
specifier|const
name|opname_map_e
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|op_get_constant
name|PARAMS
argument_list|(
operator|(
specifier|const
name|opname_map_e
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|insn_templ_operand_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|insn_templ
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parsing helpers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|skip_white
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trim_whitespace
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|split_string
name|PARAMS
argument_list|(
operator|(
name|split_rec
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Language parsing.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_insn_pattern
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|insn_pattern
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_insn_repl
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|insn_repl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_insn_templ
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|insn_templ
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_special_fn
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_precond
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|precond_e
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_constant
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_id_constant
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transition table building code.  */
end_comment

begin_decl_stmt
specifier|static
name|TransitionRule
modifier|*
name|build_transition
name|PARAMS
argument_list|(
operator|(
name|insn_pattern
operator|*
operator|,
name|insn_repl
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TransitionTable
modifier|*
name|build_transition_table
name|PARAMS
argument_list|(
operator|(
specifier|const
name|string_pattern_pair
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|append_transition
parameter_list|(
name|tt
parameter_list|,
name|opcode
parameter_list|,
name|t
parameter_list|)
name|TransitionTable
modifier|*
name|tt
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|TransitionRule
modifier|*
name|t
decl_stmt|;
block|{
name|TransitionList
modifier|*
name|tl
init|=
operator|(
name|TransitionList
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionList
argument_list|)
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|prev
decl_stmt|;
name|TransitionList
modifier|*
name|nxt
decl_stmt|;
name|assert
argument_list|(
name|tt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|tt
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
name|prev
operator|=
name|tt
operator|->
name|table
index|[
name|opcode
index|]
expr_stmt|;
name|tl
operator|->
name|rule
operator|=
name|t
expr_stmt|;
name|tl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tt
operator|->
name|table
index|[
name|opcode
index|]
operator|=
name|tl
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|nxt
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|tl
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_condition
parameter_list|(
name|tr
parameter_list|,
name|cond
parameter_list|)
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|Precondition
modifier|*
name|cond
decl_stmt|;
block|{
name|PreconditionList
modifier|*
name|pl
init|=
operator|(
name|PreconditionList
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PreconditionList
argument_list|)
argument_list|)
decl_stmt|;
name|PreconditionList
modifier|*
name|prev
init|=
name|tr
operator|->
name|conditions
decl_stmt|;
name|PreconditionList
modifier|*
name|nxt
decl_stmt|;
name|pl
operator|->
name|precond
operator|=
name|cond
expr_stmt|;
name|pl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tr
operator|->
name|conditions
operator|=
name|pl
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|nxt
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_value_condition
parameter_list|(
name|tr
parameter_list|,
name|cmp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|CmpOp
name|cmp
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|op2
decl_stmt|;
block|{
name|Precondition
modifier|*
name|cond
init|=
operator|(
name|Precondition
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Precondition
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|->
name|cmp
operator|=
name|cmp
expr_stmt|;
name|cond
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|cond
operator|->
name|typ
operator|=
name|OP_OPERAND
expr_stmt|;
name|cond
operator|->
name|op_data
operator|=
name|op2
expr_stmt|;
name|append_condition
argument_list|(
name|tr
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_constant_value_condition
parameter_list|(
name|tr
parameter_list|,
name|cmp
parameter_list|,
name|op1
parameter_list|,
name|cnst
parameter_list|)
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|CmpOp
name|cmp
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|cnst
decl_stmt|;
block|{
name|Precondition
modifier|*
name|cond
init|=
operator|(
name|Precondition
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Precondition
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|->
name|cmp
operator|=
name|cmp
expr_stmt|;
name|cond
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|cond
operator|->
name|typ
operator|=
name|OP_CONSTANT
expr_stmt|;
name|cond
operator|->
name|op_data
operator|=
name|cnst
expr_stmt|;
name|append_condition
argument_list|(
name|tr
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_build_insn
parameter_list|(
name|tr
parameter_list|,
name|bi
parameter_list|)
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
block|{
name|BuildInstr
modifier|*
name|prev
init|=
name|tr
operator|->
name|to_instr
decl_stmt|;
name|BuildInstr
modifier|*
name|nxt
decl_stmt|;
name|bi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|tr
operator|->
name|to_instr
operator|=
name|bi
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
literal|0
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|bi
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_op
parameter_list|(
name|bi
parameter_list|,
name|b_op
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|BuildOp
modifier|*
name|b_op
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|prev
init|=
name|bi
operator|->
name|ops
decl_stmt|;
name|BuildOp
modifier|*
name|nxt
decl_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|bi
operator|->
name|ops
operator|=
name|b_op
expr_stmt|;
return|return;
block|}
name|nxt
operator|=
name|prev
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|nxt
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|next
operator|=
name|b_op
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_literal_op
parameter_list|(
name|bi
parameter_list|,
name|op1
parameter_list|,
name|litnum
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|litnum
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_LITERAL
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|litnum
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_label_op
parameter_list|(
name|bi
parameter_list|,
name|op1
parameter_list|,
name|labnum
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|labnum
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_LABEL
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|labnum
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_constant_op
parameter_list|(
name|bi
parameter_list|,
name|op1
parameter_list|,
name|cnst
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|cnst
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_CONSTANT
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|cnst
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|append_field_op
parameter_list|(
name|bi
parameter_list|,
name|op1
parameter_list|,
name|src_op
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|unsigned
name|src_op
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|OP_OPERAND
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|src_op
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These could be generated but are not currently.  */
end_comment

begin_function
name|void
name|append_user_fn_field_op
parameter_list|(
name|bi
parameter_list|,
name|op1
parameter_list|,
name|typ
parameter_list|,
name|src_op
parameter_list|)
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
name|unsigned
name|op1
decl_stmt|;
name|OpType
name|typ
decl_stmt|;
name|unsigned
name|src_op
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|b_op
init|=
operator|(
name|BuildOp
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildOp
argument_list|)
argument_list|)
decl_stmt|;
name|b_op
operator|->
name|op_num
operator|=
name|op1
expr_stmt|;
name|b_op
operator|->
name|typ
operator|=
name|typ
expr_stmt|;
name|b_op
operator|->
name|op_data
operator|=
name|src_op
expr_stmt|;
name|b_op
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|append_op
argument_list|(
name|bi
argument_list|,
name|b_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These operand functions are the semantics of user-defined    operand functions.  */
end_comment

begin_function
name|long
name|operand_function_HI24S
parameter_list|(
name|a
parameter_list|)
name|long
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&
literal|0x80
condition|)
return|return
operator|(
name|a
operator|&
operator|(
operator|~
literal|0xff
operator|)
operator|)
operator|+
literal|0x100
return|;
else|else
return|return
operator|(
name|a
operator|&
operator|(
operator|~
literal|0xff
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|long
name|operand_function_F32MINUS
parameter_list|(
name|a
parameter_list|)
name|long
name|a
decl_stmt|;
block|{
return|return
operator|(
literal|32
operator|-
name|a
operator|)
return|;
block|}
end_function

begin_function
name|long
name|operand_function_LOW8
parameter_list|(
name|a
parameter_list|)
name|long
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&
literal|0x80
condition|)
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
operator||
operator|~
literal|0xff
return|;
else|else
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_has_userdef_op_fn
parameter_list|(
name|op
parameter_list|)
name|OpType
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPERAND_F32MINUS
case|:
case|case
name|OP_OPERAND_LOW8
case|:
case|case
name|OP_OPERAND_HI24S
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|long
name|xg_apply_userdef_op_fn
parameter_list|(
name|op
parameter_list|,
name|a
parameter_list|)
name|OpType
name|op
decl_stmt|;
name|long
name|a
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPERAND_F32MINUS
case|:
return|return
name|operand_function_F32MINUS
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_LOW8
case|:
return|return
name|operand_function_LOW8
argument_list|(
name|a
argument_list|)
return|;
case|case
name|OP_OPERAND_HI24S
case|:
return|return
name|operand_function_HI24S
argument_list|(
name|a
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Generate a transition table.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|enter_opname_n
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|opname_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|local_opnames
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|op
operator|->
name|opname
argument_list|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|opname
return|;
block|}
name|op
operator|=
operator|(
name|opname_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_e
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|op
operator|->
name|opname
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|enter_opname
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|opname_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|local_opnames
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|op
operator|->
name|opname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|opname
return|;
block|}
name|op
operator|=
operator|(
name|opname_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_e
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|opname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|op
operator|->
name|opname
return|;
block|}
end_function

begin_function
name|void
name|init_opname_map
parameter_list|(
name|m
parameter_list|)
name|opname_map
modifier|*
name|m
decl_stmt|;
block|{
name|m
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|tail
operator|=
operator|&
name|m
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_opname_map
parameter_list|(
name|m
parameter_list|)
name|opname_map
modifier|*
name|m
decl_stmt|;
block|{
name|opname_map_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|m
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|m
operator|->
name|head
expr_stmt|;
name|m
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|tail
operator|=
operator|&
name|m
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|same_operand_name
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
specifier|const
name|opname_map_e
modifier|*
name|m1
decl_stmt|;
specifier|const
name|opname_map_e
modifier|*
name|m2
decl_stmt|;
block|{
if|if
condition|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
operator|||
name|m1
operator|->
name|operand_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|m1
operator|->
name|operand_name
operator|==
name|m2
operator|->
name|operand_name
operator|)
return|;
block|}
end_function

begin_function
name|opname_map_e
modifier|*
name|get_opmatch
parameter_list|(
name|map
parameter_list|,
name|operand_name
parameter_list|)
name|opname_map
modifier|*
name|map
decl_stmt|;
specifier|const
name|char
modifier|*
name|operand_name
decl_stmt|;
block|{
name|opname_map_e
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|map
operator|->
name|head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|operand_name
argument_list|,
name|operand_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|op_is_constant
parameter_list|(
name|m1
parameter_list|)
specifier|const
name|opname_map_e
modifier|*
name|m1
decl_stmt|;
block|{
return|return
operator|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|op_get_constant
parameter_list|(
name|m1
parameter_list|)
specifier|const
name|opname_map_e
modifier|*
name|m1
decl_stmt|;
block|{
name|assert
argument_list|(
name|m1
operator|->
name|operand_name
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|m1
operator|->
name|constant_value
return|;
block|}
end_function

begin_function
name|void
name|init_precond_list
parameter_list|(
name|l
parameter_list|)
name|precond_list
modifier|*
name|l
decl_stmt|;
block|{
name|l
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|tail
operator|=
operator|&
name|l
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_precond_list
parameter_list|(
name|l
parameter_list|)
name|precond_list
modifier|*
name|l
decl_stmt|;
block|{
name|precond_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|l
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|l
operator|->
name|head
expr_stmt|;
name|l
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|l
operator|->
name|tail
operator|=
operator|&
name|l
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_insn_templ
parameter_list|(
name|t
parameter_list|)
name|insn_templ
modifier|*
name|t
decl_stmt|;
block|{
name|t
operator|->
name|opcode_name
operator|=
name|NULL
expr_stmt|;
name|init_opname_map
argument_list|(
operator|&
name|t
operator|->
name|operand_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_insn_templ
parameter_list|(
name|t
parameter_list|)
name|insn_templ
modifier|*
name|t
decl_stmt|;
block|{
name|clear_opname_map
argument_list|(
operator|&
name|t
operator|->
name|operand_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_insn_pattern
parameter_list|(
name|p
parameter_list|)
name|insn_pattern
modifier|*
name|p
decl_stmt|;
block|{
name|init_insn_templ
argument_list|(
operator|&
name|p
operator|->
name|t
argument_list|)
expr_stmt|;
name|init_precond_list
argument_list|(
operator|&
name|p
operator|->
name|preconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_insn_pattern
parameter_list|(
name|p
parameter_list|)
name|insn_pattern
modifier|*
name|p
decl_stmt|;
block|{
name|clear_insn_templ
argument_list|(
operator|&
name|p
operator|->
name|t
argument_list|)
expr_stmt|;
name|clear_precond_list
argument_list|(
operator|&
name|p
operator|->
name|preconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_insn_repl
parameter_list|(
name|r
parameter_list|)
name|insn_repl
modifier|*
name|r
decl_stmt|;
block|{
name|r
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|tail
operator|=
operator|&
name|r
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_insn_repl
parameter_list|(
name|r
parameter_list|)
name|insn_repl
modifier|*
name|r
decl_stmt|;
block|{
name|insn_repl_e
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|r
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
name|r
operator|->
name|head
expr_stmt|;
name|r
operator|->
name|head
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|clear_insn_templ
argument_list|(
operator|&
name|e
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|tail
operator|=
operator|&
name|r
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|insn_templ_operand_count
parameter_list|(
name|t
parameter_list|)
specifier|const
name|insn_templ
modifier|*
name|t
decl_stmt|;
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|opname_map_e
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|t
operator|->
name|operand_map
operator|.
name|head
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
operator|,
operator|++
name|i
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Convert a string to a number.  E.G.: parse_constant("10",&num) */
end_comment

begin_function
name|bfd_boolean
name|parse_constant
parameter_list|(
name|in
parameter_list|,
name|val_p
parameter_list|)
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
name|unsigned
modifier|*
name|val_p
decl_stmt|;
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|in
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
return|return
name|FALSE
return|;
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|val_p
operator|=
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Match a pattern like "foo1" with    parse_id_constant("foo1", "foo",&num).    This may also be used to just match a number.  */
end_comment

begin_function
name|bfd_boolean
name|parse_id_constant
parameter_list|(
name|in
parameter_list|,
name|name
parameter_list|,
name|val_p
parameter_list|)
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
modifier|*
name|val_p
decl_stmt|;
block|{
name|unsigned
name|namelen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|in
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|&
name|in
index|[
name|namelen
index|]
expr_stmt|;
return|return
name|parse_constant
argument_list|(
name|p
argument_list|,
name|val_p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|parse_special_fn
parameter_list|(
name|name
parameter_list|,
name|fn_name_p
parameter_list|,
name|arg_name_p
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fn_name_p
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arg_name_p
decl_stmt|;
block|{
name|char
modifier|*
name|p_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_end
decl_stmt|;
name|p_start
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_start
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p_end
operator|=
name|strchr
argument_list|(
name|p_start
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_end
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|p_end
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
operator|*
name|fn_name_p
operator|=
name|enter_opname_n
argument_list|(
name|name
argument_list|,
name|p_start
operator|-
name|name
argument_list|)
expr_stmt|;
operator|*
name|arg_name_p
operator|=
name|enter_opname_n
argument_list|(
name|p_start
operator|+
literal|1
argument_list|,
name|p_end
operator|-
name|p_start
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|skip_white
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|p
return|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|trim_whitespace
parameter_list|(
name|in
parameter_list|)
name|char
modifier|*
name|in
decl_stmt|;
block|{
name|char
modifier|*
name|last_white
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|in
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|last_white
operator|==
name|NULL
condition|)
name|last_white
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|last_white
operator|=
name|NULL
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_white
condition|)
operator|*
name|last_white
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a string into component strings where "c" is the    delimiter.  Place the result in the split_rec.  */
end_comment

begin_function
name|void
name|split_string
parameter_list|(
name|rec
parameter_list|,
name|in
parameter_list|,
name|c
parameter_list|,
name|elide_whitespace
parameter_list|)
name|split_rec
modifier|*
name|rec
decl_stmt|;
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bfd_boolean
name|elide_whitespace
decl_stmt|;
block|{
name|size_t
name|cnt
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|in
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|rec
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
name|rec
operator|->
name|vec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|count
operator|==
literal|0
condition|)
return|return;
name|rec
operator|->
name|vec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|elide_whitespace
condition|)
name|q
operator|=
name|skip_white
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|p
operator|-
name|q
expr_stmt|;
name|rec
operator|->
name|vec
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rec
operator|->
name|vec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|elide_whitespace
condition|)
name|trim_whitespace
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|clear_split_rec
parameter_list|(
name|rec
parameter_list|)
name|split_rec
modifier|*
name|rec
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|->
name|count
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|rec
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|count
operator|>
literal|0
condition|)
name|free
argument_list|(
name|rec
operator|->
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_split_rec
parameter_list|(
name|rec
parameter_list|)
name|split_rec
modifier|*
name|rec
decl_stmt|;
block|{
name|rec
operator|->
name|vec
operator|=
name|NULL
expr_stmt|;
name|rec
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an instruction template like "insn op1, op2, op3".  */
end_comment

begin_function
name|bfd_boolean
name|parse_insn_templ
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|insn_templ
modifier|*
name|t
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
comment|/* First find the first whitespace.  */
name|size_t
name|insn_name_len
decl_stmt|;
name|split_rec
name|oprec
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|init_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|insn_name_len
operator|=
name|strcspn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_name_len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|init_insn_templ
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|opcode_name
operator|=
name|enter_opname_n
argument_list|(
name|p
argument_list|,
name|insn_name_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|insn_name_len
expr_stmt|;
comment|/* Split by ',' and skip beginning and trailing whitespace.  */
name|split_string
argument_list|(
operator|&
name|oprec
argument_list|,
name|p
argument_list|,
literal|','
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oprec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
name|oprec
operator|.
name|vec
index|[
name|i
index|]
decl_stmt|;
name|opname_map_e
modifier|*
name|e
init|=
operator|(
name|opname_map_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opname_map_e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|operand_name
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|constant_value
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|operand_num
operator|=
name|i
expr_stmt|;
comment|/* If it begins with a number, assume that it is a number.  */
if|if
condition|(
name|opname
operator|&&
name|opname
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|opname
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
name|parse_constant
argument_list|(
name|opname
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|e
operator|->
name|constant_value
operator|=
name|val
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|clear_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
name|clear_insn_templ
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|e
operator|->
name|operand_name
operator|=
name|enter_opname
argument_list|(
name|oprec
operator|.
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|t
operator|->
name|operand_map
operator|.
name|tail
operator|=
name|e
expr_stmt|;
name|t
operator|->
name|operand_map
operator|.
name|tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
name|clear_split_rec
argument_list|(
operator|&
name|oprec
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|parse_precond
parameter_list|(
name|s
parameter_list|,
name|precond
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|precond_e
modifier|*
name|precond
decl_stmt|;
block|{
comment|/* All preconditions are currently of the form:      a == b or a != b or a == k (where k is a constant).      Later we may use some special functions like DENSITY == 1      to identify when density is available.  */
specifier|const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|precond
operator|->
name|opname1
operator|=
name|NULL
expr_stmt|;
name|precond
operator|->
name|opval1
operator|=
literal|0
expr_stmt|;
name|precond
operator|->
name|cmpop
operator|=
name|OP_EQUAL
expr_stmt|;
name|precond
operator|->
name|opname2
operator|=
name|NULL
expr_stmt|;
name|precond
operator|->
name|opval2
operator|=
literal|0
expr_stmt|;
name|precond
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|" !="
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|precond
operator|->
name|opname1
operator|=
name|enter_opname_n
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|len
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Check for "==" and "!=".  */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"=="
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|precond
operator|->
name|cmpop
operator|=
name|OP_EQUAL
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"!="
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|precond
operator|->
name|cmpop
operator|=
name|OP_NOTEQUAL
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|p
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* No trailing whitespace from earlier parsing.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
name|parse_constant
argument_list|(
name|p
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|precond
operator|->
name|opval2
operator|=
name|val
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
else|else
name|precond
operator|->
name|opname2
operator|=
name|enter_opname
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Parse a string like:    "insn op1, op2, op3, op4 | op1 != op2 | op2 == op3 | op4 == 1".    I.E., instruction "insn" with 4 operands where operand 1 and 2 are not    the same and operand 2 and 3 are the same and operand 4 is 1.  */
end_comment

begin_function
name|bfd_boolean
name|parse_insn_pattern
parameter_list|(
name|in
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
name|insn_pattern
modifier|*
name|insn
decl_stmt|;
block|{
name|split_rec
name|rec
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|init_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|init_insn_pattern
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|split_string
argument_list|(
operator|&
name|rec
argument_list|,
name|in
argument_list|,
literal|'|'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|parse_insn_templ
argument_list|(
name|rec
operator|.
name|vec
index|[
literal|0
index|]
argument_list|,
operator|&
name|insn
operator|->
name|t
argument_list|)
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|precond_e
modifier|*
name|cond
init|=
operator|(
name|precond_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|precond_e
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parse_precond
argument_list|(
name|rec
operator|.
name|vec
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|)
condition|)
block|{
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Append the condition.  */
operator|*
name|insn
operator|->
name|preconds
operator|.
name|tail
operator|=
name|cond
expr_stmt|;
name|insn
operator|->
name|preconds
operator|.
name|tail
operator|=
operator|&
name|cond
operator|->
name|next
expr_stmt|;
block|}
name|clear_split_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|parse_insn_repl
parameter_list|(
name|in
parameter_list|,
name|r_p
parameter_list|)
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
name|insn_repl
modifier|*
name|r_p
decl_stmt|;
block|{
comment|/* This is a list of instruction templates separated by ';'.  */
name|split_rec
name|rec
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|split_string
argument_list|(
operator|&
name|rec
argument_list|,
name|in
argument_list|,
literal|';'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|insn_repl_e
modifier|*
name|e
init|=
operator|(
name|insn_repl_e
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|insn_repl_e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_templ
argument_list|(
name|rec
operator|.
name|vec
index|[
name|i
index|]
argument_list|,
operator|&
name|e
operator|->
name|t
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|clear_insn_repl
argument_list|(
name|r_p
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|r_p
operator|->
name|tail
operator|=
name|e
expr_stmt|;
name|r_p
operator|->
name|tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|TransitionRule
modifier|*
name|build_transition
parameter_list|(
name|initial_insn
parameter_list|,
name|replace_insns
parameter_list|,
name|from_string
parameter_list|,
name|to_string
parameter_list|)
name|insn_pattern
modifier|*
name|initial_insn
decl_stmt|;
name|insn_repl
modifier|*
name|replace_insns
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_string
decl_stmt|;
block|{
name|TransitionRule
modifier|*
name|tr
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|opname_map_e
modifier|*
name|op1
decl_stmt|;
name|opname_map_e
modifier|*
name|op2
decl_stmt|;
name|precond_e
modifier|*
name|precond
decl_stmt|;
name|insn_repl_e
modifier|*
name|r
decl_stmt|;
name|unsigned
name|label_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|max_label_count
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|has_label
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|literal_count
init|=
literal|0
decl_stmt|;
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|initial_insn
operator|->
name|t
operator|.
name|opcode_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
comment|/* It is OK to not be able to translate some of these opcodes.  */
if|#
directive|if
literal|0
block|as_warn (_("Invalid opcode '%s' in transition rule '%s'\n"), 	       initial_insn->t.opcode_name, to_string);
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|insn_templ_operand_count
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
argument_list|)
condition|)
block|{
comment|/* This is also OK because there are opcodes that 	 have different numbers of operands on different 	 architecture variations.  */
if|#
directive|if
literal|0
block|as_fatal (_("opcode %s mismatched operand count %d != expected %d"), 		xtensa_opcode_name (isa, opcode), 		xtensa_num_operands (isa, opcode), 		insn_templ_operand_count (&initial_insn->t));
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
name|tr
operator|=
operator|(
name|TransitionRule
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionRule
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|tr
operator|->
name|conditions
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|to_instr
operator|=
name|NULL
expr_stmt|;
comment|/* Build the conditions. First, equivalent operand condition....  */
for|for
control|(
name|op1
operator|=
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op1
operator|!=
name|NULL
condition|;
name|op1
operator|=
name|op1
operator|->
name|next
control|)
block|{
for|for
control|(
name|op2
operator|=
name|op1
operator|->
name|next
init|;
name|op2
operator|!=
name|NULL
condition|;
name|op2
operator|=
name|op2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|same_operand_name
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
condition|)
block|{
name|append_value_condition
argument_list|(
name|tr
argument_list|,
name|OP_EQUAL
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now the condition that an operand value must be a constant....  */
for|for
control|(
name|op1
operator|=
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op1
operator|!=
name|NULL
condition|;
name|op1
operator|=
name|op1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|op_is_constant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|OP_EQUAL
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op_get_constant
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add the explicit preconditions listed after the "|" in the spec.      These are currently very limited, so we do a special case      parse for them.  We expect spaces, opname != opname.  */
for|for
control|(
name|precond
operator|=
name|initial_insn
operator|->
name|preconds
operator|.
name|head
init|;
name|precond
operator|!=
name|NULL
condition|;
name|precond
operator|=
name|precond
operator|->
name|next
control|)
block|{
name|op1
operator|=
name|NULL
expr_stmt|;
name|op2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|precond
operator|->
name|opname1
condition|)
block|{
name|op1
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|precond
operator|->
name|opname1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': no bound opname '%s' "
literal|"for precondition in '%s'"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|precond
operator|->
name|opname1
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|precond
operator|->
name|opname2
condition|)
block|{
name|op2
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|precond
operator|->
name|opname2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': no bound opname '%s' "
literal|"for precondition in %s"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|precond
operator|->
name|opname2
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|op1
operator|==
name|NULL
operator|&&
name|op2
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': precondition only contains "
literal|"constants in '%s'"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|op1
operator|!=
name|NULL
operator|&&
name|op2
operator|!=
name|NULL
condition|)
name|append_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op2
operator|==
name|NULL
condition|)
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op1
operator|->
name|operand_num
argument_list|,
name|precond
operator|->
name|opval1
argument_list|)
expr_stmt|;
else|else
name|append_constant_value_condition
argument_list|(
name|tr
argument_list|,
name|precond
operator|->
name|cmpop
argument_list|,
name|op2
operator|->
name|operand_num
argument_list|,
name|precond
operator|->
name|opval2
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the replacement instructions.  Some of these      "instructions" are actually labels and literals.  The literals      must be defined in order 0..n and a literal must be defined      (e.g., "LITERAL0 %imm") before use (e.g., "%LITERAL0").  The      labels must be defined in order, but they can be used before they      are defined.  Also there are a number of special operands (e.g.,      HI24S).  */
for|for
control|(
name|r
operator|=
name|replace_insns
operator|->
name|head
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|size_t
name|operand_count
decl_stmt|;
name|opname_map_e
modifier|*
name|op
decl_stmt|;
name|unsigned
name|idnum
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|operand_arg_name
decl_stmt|;
name|bi
operator|=
operator|(
name|BuildInstr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BuildInstr
argument_list|)
argument_list|)
expr_stmt|;
name|append_build_insn
argument_list|(
name|tr
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|bi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|bi
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|bi
operator|->
name|ops
operator|=
name|NULL
expr_stmt|;
name|bi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|opcode_name
operator|=
name|r
operator|->
name|t
operator|.
name|opcode_name
expr_stmt|;
name|operand_count
operator|=
name|insn_templ_operand_count
argument_list|(
operator|&
name|r
operator|->
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_id_constant
argument_list|(
name|opcode_name
argument_list|,
literal|"LITERAL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_LITERAL_DEF
expr_stmt|;
name|bi
operator|->
name|id
operator|=
name|idnum
expr_stmt|;
if|if
condition|(
name|idnum
operator|!=
name|literal_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"generated literals must be numbered consecutively"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|literal_count
expr_stmt|;
if|if
condition|(
name|operand_count
operator|!=
literal|1
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected one operand for generated literal"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|opcode_name
argument_list|,
literal|"LABEL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_LABEL_DEF
expr_stmt|;
name|bi
operator|->
name|id
operator|=
name|idnum
expr_stmt|;
if|if
condition|(
name|idnum
operator|!=
name|label_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"generated labels must be numbered consecutively"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|label_count
expr_stmt|;
if|if
condition|(
name|operand_count
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected 0 operands for generated label"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bi
operator|->
name|typ
operator|=
name|INSTR_INSTR
expr_stmt|;
name|bi
operator|->
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|r
operator|->
name|t
operator|.
name|opcode_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|NULL
return|;
comment|/* Check for the right number of ops.  */
if|if
condition|(
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|bi
operator|->
name|opcode
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|operand_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode '%s': replacement does not have %d ops"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|bi
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|op
operator|=
name|r
operator|->
name|t
operator|.
name|operand_map
operator|.
name|head
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|unsigned
name|idnum
decl_stmt|;
if|if
condition|(
name|op_is_constant
argument_list|(
name|op
argument_list|)
condition|)
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|op_get_constant
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"%LITERAL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|idnum
operator|>=
name|literal_count
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: replacement "
literal|"literal %d>= literal_count(%d)"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|idnum
argument_list|,
name|literal_count
argument_list|)
expr_stmt|;
name|append_literal_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"%LABEL"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
block|{
name|has_label
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|idnum
operator|>
name|max_label_count
condition|)
name|max_label_count
operator|=
name|idnum
expr_stmt|;
name|append_label_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_id_constant
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
literal|"a"
argument_list|,
operator|&
name|idnum
argument_list|)
condition|)
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|operand_name
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
name|opname_map_e
modifier|*
name|orig_op
decl_stmt|;
name|orig_op
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|op
operator|->
name|operand_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_op
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: unidentified operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|append_field_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|orig_op
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_special_fn
argument_list|(
name|op
operator|->
name|operand_name
argument_list|,
operator|&
name|fn_name
argument_list|,
operator|&
name|operand_arg_name
argument_list|)
condition|)
block|{
name|opname_map_e
modifier|*
name|orig_op
decl_stmt|;
name|OpType
name|typ
init|=
name|OP_CONSTANT
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"LOW8"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_LOW8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"HI24S"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_HI24S
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fn_name
argument_list|,
literal|"F32MINUS"
argument_list|)
operator|==
literal|0
condition|)
name|typ
operator|=
name|OP_OPERAND_F32MINUS
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown user defined function %s"
argument_list|)
argument_list|,
name|fn_name
argument_list|)
expr_stmt|;
name|orig_op
operator|=
name|get_opmatch
argument_list|(
operator|&
name|initial_insn
operator|->
name|t
operator|.
name|operand_map
argument_list|,
name|operand_arg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_op
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: unidentified operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|append_user_fn_field_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
name|typ
argument_list|,
name|orig_op
operator|->
name|operand_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: could not parse operand '%s' in '%s'"
argument_list|)
argument_list|,
name|opcode_name
argument_list|,
name|op
operator|->
name|operand_name
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|append_constant_op
argument_list|(
name|bi
argument_list|,
name|op
operator|->
name|operand_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|has_label
operator|&&
name|max_label_count
operator|>=
name|label_count
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode %s: replacement label %d>= label_count(%d)"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|max_label_count
argument_list|,
name|label_count
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|tr
return|;
block|}
end_function

begin_function
name|TransitionTable
modifier|*
name|build_transition_table
parameter_list|(
name|transitions
parameter_list|,
name|transition_count
parameter_list|)
specifier|const
name|string_pattern_pair
modifier|*
name|transitions
decl_stmt|;
name|size_t
name|transition_count
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
name|int
name|num_opcodes
init|=
name|xtensa_num_opcodes
argument_list|(
name|xtensa_default_isa
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|tnum
decl_stmt|;
if|if
condition|(
name|table
operator|!=
name|NULL
condition|)
return|return
name|table
return|;
comment|/* Otherwise, build it now.  */
name|table
operator|=
operator|(
name|TransitionTable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionTable
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_opcodes
operator|=
name|num_opcodes
expr_stmt|;
name|table
operator|->
name|table
operator|=
operator|(
name|TransitionList
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TransitionTable
operator|*
argument_list|)
operator|*
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
control|)
name|table
operator|->
name|table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tnum
operator|=
literal|0
init|;
name|tnum
operator|<
name|transition_count
condition|;
name|tnum
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|from_string
init|=
name|transitions
index|[
name|tnum
index|]
operator|.
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_string
init|=
name|transitions
index|[
name|tnum
index|]
operator|.
name|replacement
decl_stmt|;
name|insn_pattern
name|initial_insn
decl_stmt|;
name|insn_repl
name|replace_insns
decl_stmt|;
name|TransitionRule
modifier|*
name|tr
decl_stmt|;
name|init_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_pattern
argument_list|(
name|from_string
argument_list|,
operator|&
name|initial_insn
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"could not parse INSN_PATTERN '%s'"
argument_list|)
argument_list|,
name|from_string
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|init_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_insn_repl
argument_list|(
name|to_string
argument_list|,
operator|&
name|replace_insns
argument_list|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"could not parse INSN_REPL '%s'"
argument_list|)
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
name|clear_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tr
operator|=
name|build_transition
argument_list|(
operator|&
name|initial_insn
argument_list|,
operator|&
name|replace_insns
argument_list|,
name|from_string
argument_list|,
name|to_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|append_transition
argument_list|(
name|table
argument_list|,
name|tr
operator|->
name|opcode
argument_list|,
name|tr
argument_list|)
expr_stmt|;
name|clear_insn_repl
argument_list|(
operator|&
name|replace_insns
argument_list|)
expr_stmt|;
name|clear_insn_pattern
argument_list|(
operator|&
name|initial_insn
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|extern
name|TransitionTable
modifier|*
name|xg_build_widen_table
parameter_list|()
block|{
specifier|static
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
name|table
operator|=
name|build_transition_table
argument_list|(
name|widen_spec_list
argument_list|,
name|WIDEN_COUNT
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_function
specifier|extern
name|TransitionTable
modifier|*
name|xg_build_simplify_table
parameter_list|()
block|{
specifier|static
name|TransitionTable
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
name|table
operator|=
name|build_transition_table
argument_list|(
name|simplify_spec_list
argument_list|,
name|SIMPLIFY_COUNT
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

end_unit

