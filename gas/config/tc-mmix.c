begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mmix.c -- Assembler for Don Knuth's MMIX.    Copyright (C) 2001, 2002, 2003 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Knuth's assembler mmixal does not provide a relocatable format; mmo is    to be considered a final link-format.  In the final link, we make mmo,    but for relocatable files, we use ELF.     One goal is to provide a superset of what mmixal does, including    compatible syntax, but the main purpose is to serve GCC.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mmix.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mmix.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Something to describe what we need to do with a fixup before output,    for example assert something of what it became or make a relocation.  */
end_comment

begin_enum
enum|enum
name|mmix_fixup_action
block|{
name|mmix_fixup_byte
block|,
name|mmix_fixup_register
block|,
name|mmix_fixup_register_or_adjust_for_byte
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|get_spec_regno
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_operands
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|expressionS
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_putget_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mmix_opcode
operator|*
operator|,
name|char
operator|*
operator|,
name|expressionS
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_prefix
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_greg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_loc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_bspec
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_espec
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_s_local
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_greg_internal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_set_geta_branch_offset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|offsetT
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_set_jmp_offset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_fill_nops
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmp_greg_symbol_fixes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmp_greg_val_greg_symbol_fixes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
name|p1
operator|,
specifier|const
name|PTR
name|p2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_handle_rest_of_empty_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_discard_rest_of_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_byte
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Continue the tradition of symbols.c; use control characters to enforce    magic.  These are used when replacing e.g. 8F and 8B so we can handle    such labels correctly with the common parser hooks.  */
end_comment

begin_define
define|#
directive|define
name|MAGIC_FB_BACKWARD_CHAR
value|'\003'
end_define

begin_define
define|#
directive|define
name|MAGIC_FB_FORWARD_CHAR
value|'\004'
end_define

begin_comment
comment|/* Copy the location of a frag to a fix.  */
end_comment

begin_define
define|#
directive|define
name|COPY_FR_WHERE_TO_FX
parameter_list|(
name|FRAG
parameter_list|,
name|FIX
parameter_list|)
define|\
value|do						\    {						\      (FIX)->fx_file = (FRAG)->fr_file;		\      (FIX)->fx_line = (FRAG)->fr_line;		\    }						\  while (0)
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_fb_label
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pending_label
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|lowest_text_loc
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|text_has_contents
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alignment of the previous instruction, and a boolean for whether we    want to avoid aligning the next WYDE, TETRA, OCTA or insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_alignment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|want_unaligned
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|lowest_data_loc
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|data_has_contents
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The fragS of the instruction being assembled.  Only valid from within    md_assemble.  */
end_comment

begin_decl_stmt
name|fragS
modifier|*
name|mmix_opcode_frag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Raw GREGs as appearing in input.  These may be fewer than the number    after relaxing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_of_raw_gregs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
name|mmix_raw_gregs
index|[
name|MAX_GREGS
index|]
struct|;
end_struct

begin_comment
comment|/* Fixups for all unique GREG registers.  We store the fixups here in    md_convert_frag, then we use the array to convert    BFD_RELOC_MMIX_BASE_PLUS_OFFSET fixups in tc_gen_reloc.  The index is    just a running number and is not supposed to be correlated to a    register number.  */
end_comment

begin_decl_stmt
specifier|static
name|fixS
modifier|*
name|mmix_gregs
index|[
name|MAX_GREGS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_of_cooked_gregs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointing to the register section we use for output.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|real_reg_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each symbol; unknown or section symbol, we keep a list of GREG    definitions sorted on increasing offset.  It seems no use keeping count    to allocate less room than the maximum number of gregs when we've found    one for a section or symbol.  */
end_comment

begin_struct
struct|struct
name|mmix_symbol_gregs
block|{
name|int
name|n_gregs
decl_stmt|;
struct|struct
name|mmix_symbol_greg_fixes
block|{
name|fixS
modifier|*
name|fix
decl_stmt|;
comment|/* A signed type, since we may have GREGs pointing slightly before the 	contents of a section.  */
name|offsetT
name|offs
decl_stmt|;
block|}
name|greg_fixes
index|[
name|MAX_GREGS
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Should read insert a colon on something that starts in column 0 on    this line?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_without_colon_this_line
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we automatically expand instructions into multiple insns in    order to generate working code?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|expand_op
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we warn when expanding operands?  FIXME: test-cases for when -x    is absent.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_on_expansion
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we merge non-zero GREG register definitions?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|merge_gregs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we pass on undefined BFD_RELOC_MMIX_BASE_PLUS_OFFSET relocs    (missing suitable GREG definitions) to the linker?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocate_undefined_gregs_in_linker
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we emit built-in symbols?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|predefined_syms
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we allow anything but the listed special register name    (e.g. equated symbols)?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equated_spec_regs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we require standard GNU syntax?  */
end_comment

begin_decl_stmt
name|int
name|mmix_gnu_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we globalize all symbols?  */
end_comment

begin_decl_stmt
name|int
name|mmix_globalize_symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When expanding insns, do we want to expand PUSHJ as a call to a stub    (or else as a series of insns)?  */
end_comment

begin_decl_stmt
name|int
name|pushj_stubs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we know that the next semicolon is at the end of the operands field    (in mmixal mode; constant 1 in GNU mode)?  */
end_comment

begin_decl_stmt
name|int
name|mmix_next_semicolon_is_eoln
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we have a BSPEC in progress?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|doing_bspec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bspec_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|bspec_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_NOEXPAND
value|(OPTION_RELAX + 1)
define|#
directive|define
name|OPTION_NOMERGEGREG
value|(OPTION_NOEXPAND + 1)
define|#
directive|define
name|OPTION_NOSYMS
value|(OPTION_NOMERGEGREG + 1)
define|#
directive|define
name|OPTION_GNU_SYNTAX
value|(OPTION_NOSYMS + 1)
define|#
directive|define
name|OPTION_GLOBALIZE_SYMBOLS
value|(OPTION_GNU_SYNTAX + 1)
define|#
directive|define
name|OPTION_FIXED_SPEC_REGS
value|(OPTION_GLOBALIZE_SYMBOLS + 1)
define|#
directive|define
name|OPTION_LINKER_ALLOCATED_GREGS
value|(OPTION_FIXED_SPEC_REGS + 1)
define|#
directive|define
name|OPTION_NOPUSHJSTUBS
value|(OPTION_LINKER_ALLOCATED_GREGS + 1)
block|{
literal|"linkrelax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
block|{
literal|"no-expand"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOEXPAND
block|}
block|,
block|{
literal|"no-merge-gregs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOMERGEGREG
block|}
block|,
block|{
literal|"no-predefined-syms"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOSYMS
block|}
block|,
block|{
literal|"gnu-syntax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GNU_SYNTAX
block|}
block|,
block|{
literal|"globalize-symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GLOBALIZE_SYMBOLS
block|}
block|,
block|{
literal|"fixed-special-register-names"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FIXED_SPEC_REGS
block|}
block|,
block|{
literal|"linker-allocated-gregs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LINKER_ALLOCATED_GREGS
block|}
block|,
block|{
literal|"no-pushj-stubs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOPUSHJSTUBS
block|}
block|,
block|{
literal|"no-stubs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOPUSHJSTUBS
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mmix_opcode_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use these when implementing the PREFIX pseudo.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mmix_current_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|mmix_sym_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For MMIX, we encode the relax_substateT:s (in e.g. fr_substate) as one    bit length, and the relax-type shifted on top of that.  There seems to    be no point in making the relaxation more fine-grained; the linker does    that better and we might interfere by changing non-optimal relaxations    into other insns that cannot be relaxed as easily.     Groups for MMIX relaxing:     1. GETA       extra length: zero or three insns.     2. Bcc       extra length: zero or five insns.     3. PUSHJ       extra length: zero or four insns.       Special handling to deal with transition to PUSHJSTUB.     4. JMP       extra length: zero or four insns.     5. GREG       special handling, allocates a named global register unless another       is within reach for all uses.     6. PUSHJSTUB       special handling (mostly) for external references; assumes the       linker will generate a stub if target is no longer than 256k from       the end of the section plus max size of previous stubs.  Zero or       four insns.  */
end_comment

begin_define
define|#
directive|define
name|STATE_GETA
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_BCC
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_PUSHJ
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_JMP
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_GREG
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_PUSHJSTUB
value|(6)
end_define

begin_comment
comment|/* No fine-grainedness here.  */
end_comment

begin_define
define|#
directive|define
name|STATE_LENGTH_MASK
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_ZERO
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_MAX
value|(1)
end_define

begin_comment
comment|/* More descriptive name for convenience.  */
end_comment

begin_comment
comment|/* FIXME: We should start on something different, not MAX.  */
end_comment

begin_define
define|#
directive|define
name|STATE_UNDF
value|STATE_MAX
end_define

begin_comment
comment|/* FIXME: For GREG, we must have other definitions; UNDF == MAX isn't    appropriate; we need it the other way round.  This value together with    fragP->tc_frag_data shows what state the frag is in: tc_frag_data    non-NULL means 0, NULL means 8 bytes.  */
end_comment

begin_define
define|#
directive|define
name|STATE_GREG_UNDF
value|ENCODE_RELAX (STATE_GREG, STATE_ZERO)
end_define

begin_define
define|#
directive|define
name|STATE_GREG_DEF
value|ENCODE_RELAX (STATE_GREG, STATE_MAX)
end_define

begin_comment
comment|/* These displacements are relative to the address following the opcode    word of the instruction.  The catch-all states have zero for "reach"    and "next" entries.  */
end_comment

begin_define
define|#
directive|define
name|GETA_0F
value|(65536 * 4 - 8)
end_define

begin_define
define|#
directive|define
name|GETA_0B
value|(-65536 * 4 - 4)
end_define

begin_define
define|#
directive|define
name|GETA_MAX_LEN
value|4 * 4
end_define

begin_define
define|#
directive|define
name|GETA_3F
value|0
end_define

begin_define
define|#
directive|define
name|GETA_3B
value|0
end_define

begin_define
define|#
directive|define
name|BCC_0F
value|GETA_0F
end_define

begin_define
define|#
directive|define
name|BCC_0B
value|GETA_0B
end_define

begin_define
define|#
directive|define
name|BCC_MAX_LEN
value|6 * 4
end_define

begin_define
define|#
directive|define
name|BCC_5F
value|GETA_3F
end_define

begin_define
define|#
directive|define
name|BCC_5B
value|GETA_3B
end_define

begin_define
define|#
directive|define
name|PUSHJ_0F
value|GETA_0F
end_define

begin_define
define|#
directive|define
name|PUSHJ_0B
value|GETA_0B
end_define

begin_define
define|#
directive|define
name|PUSHJ_MAX_LEN
value|5 * 4
end_define

begin_define
define|#
directive|define
name|PUSHJ_4F
value|GETA_3F
end_define

begin_define
define|#
directive|define
name|PUSHJ_4B
value|GETA_3B
end_define

begin_comment
comment|/* We'll very rarely have sections longer than LONG_MAX, but we'll make a    feeble attempt at getting 64-bit C99 or gcc-specific values (assuming    long long is 64 bits on the host).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LLONG_MIN
end_ifdef

begin_define
define|#
directive|define
name|PUSHJSTUB_MIN
value|LLONG_MIN
end_define

begin_empty
empty|#elsif defined (LONG_LONG_MIN)
end_empty

begin_define
define|#
directive|define
name|PUSHJSTUB_MIN
value|LONG_LONG_MIN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUSHJSTUB_MIN
value|LONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LLONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|PUSHJSTUB_MAX
value|LLONG_MAX
end_define

begin_empty
empty|#elsif defined (LONG_LONG_MAX)
end_empty

begin_define
define|#
directive|define
name|PUSHJSTUB_MAX
value|LONG_LONG_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUSHJSTUB_MAX
value|LONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|JMP_0F
value|(65536 * 256 * 4 - 8)
end_define

begin_define
define|#
directive|define
name|JMP_0B
value|(-65536 * 256 * 4 - 4)
end_define

begin_define
define|#
directive|define
name|JMP_MAX_LEN
value|5 * 4
end_define

begin_define
define|#
directive|define
name|JMP_4F
value|0
end_define

begin_define
define|#
directive|define
name|JMP_4B
value|0
end_define

begin_define
define|#
directive|define
name|RELAX_ENCODE_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< RELAX_ENCODE_SHIFT) + (length))
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|mmix_relax_table
index|[]
init|=
block|{
comment|/* Error sentinel (0, 0).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unused (0, 1).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* GETA (1, 0).  */
block|{
name|GETA_0F
block|,
name|GETA_0B
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_GETA
argument_list|,
argument|STATE_MAX
argument_list|)
block|}
block|,
comment|/* GETA (1, 1).  */
block|{
name|GETA_3F
block|,
name|GETA_3B
block|,
name|GETA_MAX_LEN
operator|-
literal|4
block|,
literal|0
block|}
block|,
comment|/* BCC (2, 0).  */
block|{
name|BCC_0F
block|,
name|BCC_0B
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_BCC
argument_list|,
argument|STATE_MAX
argument_list|)
block|}
block|,
comment|/* BCC (2, 1).  */
block|{
name|BCC_5F
block|,
name|BCC_5B
block|,
name|BCC_MAX_LEN
operator|-
literal|4
block|,
literal|0
block|}
block|,
comment|/* PUSHJ (3, 0).  Next state is actually PUSHJSTUB (6, 0).  */
block|{
name|PUSHJ_0F
block|,
name|PUSHJ_0B
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_PUSHJSTUB
argument_list|,
argument|STATE_ZERO
argument_list|)
block|}
block|,
comment|/* PUSHJ (3, 1).  */
block|{
name|PUSHJ_4F
block|,
name|PUSHJ_4B
block|,
name|PUSHJ_MAX_LEN
operator|-
literal|4
block|,
literal|0
block|}
block|,
comment|/* JMP (4, 0).  */
block|{
name|JMP_0F
block|,
name|JMP_0B
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_JMP
argument_list|,
argument|STATE_MAX
argument_list|)
block|}
block|,
comment|/* JMP (4, 1).  */
block|{
name|JMP_4F
block|,
name|JMP_4B
block|,
name|JMP_MAX_LEN
operator|-
literal|4
block|,
literal|0
block|}
block|,
comment|/* GREG (5, 0), (5, 1), though the table entry isn't used.  */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PUSHJSTUB (6, 0).  PUSHJ (3, 0) uses the range, so we set it to infinite.  */
block|{
name|PUSHJSTUB_MAX
block|,
name|PUSHJSTUB_MIN
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_PUSHJ
argument_list|,
argument|STATE_MAX
argument_list|)
block|}
block|,
comment|/* PUSHJSTUB (6, 1) isn't used.  */
block|{
literal|0
block|,
literal|0
block|,
name|PUSHJ_MAX_LEN
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* Support " .greg sym,expr" syntax.  */
block|{
literal|"greg"
block|,
name|s_greg
block|,
literal|0
block|}
block|,
comment|/* Support " .bspec expr" syntax.  */
block|{
literal|"bspec"
block|,
name|s_bspec
block|,
literal|1
block|}
block|,
comment|/* Support " .espec" syntax.  */
block|{
literal|"espec"
block|,
name|s_espec
block|,
literal|1
block|}
block|,
comment|/* Support " .local $45" syntax.  */
block|{
literal|"local"
block|,
name|mmix_s_local
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|mmix_comment_chars
index|[]
init|=
literal|"%!"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A ':' is a valid symbol character in mmixal.  It's the prefix    delimiter, but other than that, it works like a symbol character,    except that we strip one off at the beginning of symbols.  An '@' is a    symbol by itself (for the current location); space around it must not    be stripped.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|mmix_symbol_chars
index|[]
init|=
literal|":@"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"*#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|mmix_exp_chars
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|mmix_flt_chars
index|[]
init|=
literal|"rf"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill in the offset-related part of GETA or Bcc.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_set_geta_branch_offset
parameter_list|(
name|opcodep
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|opcodep
decl_stmt|;
name|offsetT
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|+=
literal|65536
operator|*
literal|4
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|value
operator|/=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
operator|+
literal|2
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in the offset-related part of JMP.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_set_jmp_offset
parameter_list|(
name|opcodep
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|opcodep
decl_stmt|;
name|offsetT
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|+=
literal|65536
operator|*
literal|256
operator|*
literal|4
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|value
operator|/=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
operator|+
literal|1
argument_list|,
name|value
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in NOP:s for the expanded part of GETA/JMP/Bcc/PUSHJ.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_fill_nops
parameter_list|(
name|opcodep
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|opcodep
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|md_number_to_chars
argument_list|(
name|opcodep
operator|+
name|i
operator|*
literal|4
argument_list|,
name|SWYM_INSN_BYTE
operator|<<
literal|24
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See macro md_parse_name in tc-mmix.h.  */
end_comment

begin_function_decl
name|int
name|mmix_current_location
parameter_list|(
name|fn
parameter_list|,
name|exp
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|expressionS
modifier|*
name|exp
decl_stmt|;
end_decl_stmt

begin_block
block|{
call|(
modifier|*
name|fn
call|)
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Get up to three operands, filling them into the exp array.    General idea and code stolen from the tic80 port.  */
end_comment

begin_function
specifier|static
name|int
name|get_operands
parameter_list|(
name|max_operands
parameter_list|,
name|s
parameter_list|,
name|exp
parameter_list|)
name|int
name|max_operands
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
name|exp
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|numexp
init|=
literal|0
decl_stmt|;
name|int
name|nextchar
init|=
literal|','
decl_stmt|;
while|while
condition|(
name|nextchar
operator|==
literal|','
condition|)
block|{
comment|/* Skip leading whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Check to see if we have any operands left to parse */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|numexp
operator|==
name|max_operands
condition|)
block|{
comment|/* This seems more sane than saying "too many operands".  We'll 	     get here only if the trailing trash starts with a comma.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Begin operand parsing at the current scan point.  */
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
index|[
name|numexp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numexp
operator|++
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Skip leading whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|nextchar
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* If we allow "naked" comments, ignore the rest of the line.  */
if|if
condition|(
name|nextchar
operator|!=
literal|','
condition|)
block|{
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
block|}
comment|/* Mark the end of the valid operands with an illegal expression.  */
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
return|return
operator|(
name|numexp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the value of a special register, or -1 if the name does not match    one.  NAME is a null-terminated string.  */
end_comment

begin_function
specifier|static
name|int
name|get_spec_regno
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
condition|)
name|name
operator|++
expr_stmt|;
comment|/* Well, it's a short array and we'll most often just match the first      entry, rJ.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|number
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* For GET and PUT, parse the register names "manually", so we don't use    user labels.  */
end_comment

begin_function
specifier|static
name|int
name|get_putget_operands
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|,
name|exp
parameter_list|)
name|struct
name|mmix_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|operands
decl_stmt|;
name|expressionS
name|exp
index|[]
decl_stmt|;
block|{
name|expressionS
modifier|*
name|expp_reg
decl_stmt|;
name|expressionS
modifier|*
name|expp_sreg
decl_stmt|;
name|char
modifier|*
name|sregp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sregend
init|=
name|operands
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|operands
decl_stmt|;
name|char
name|c
init|=
operator|*
name|sregend
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Skip leading whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
comment|/* Initialize both possible operands to error state, in case we never      get further.  */
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|operands
operator|==
name|mmix_operands_get
condition|)
block|{
name|expp_reg
operator|=
operator|&
name|exp
index|[
literal|0
index|]
expr_stmt|;
name|expp_sreg
operator|=
operator|&
name|exp
index|[
literal|1
index|]
expr_stmt|;
name|expression
argument_list|(
name|expp_reg
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Skip whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Skip whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|sregp
operator|=
name|p
expr_stmt|;
name|input_line_pointer
operator|=
name|sregp
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sregend
operator|=
name|input_line_pointer
expr_stmt|;
block|}
block|}
else|else
block|{
name|expp_sreg
operator|=
operator|&
name|exp
index|[
literal|0
index|]
expr_stmt|;
name|expp_reg
operator|=
operator|&
name|exp
index|[
literal|1
index|]
expr_stmt|;
name|sregp
operator|=
name|p
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sregend
operator|=
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* Skip whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Skip whitespace */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|expression
argument_list|(
name|expp_reg
argument_list|)
expr_stmt|;
block|}
operator|*
name|sregend
operator|=
literal|0
expr_stmt|;
block|}
name|regno
operator|=
name|get_spec_regno
argument_list|(
name|sregp
argument_list|)
expr_stmt|;
operator|*
name|sregend
operator|=
name|c
expr_stmt|;
comment|/* Let the caller issue errors; we've made sure the operands are      invalid.  */
if|if
condition|(
name|expp_reg
operator|->
name|X_op
operator|!=
name|O_illegal
operator|&&
name|expp_reg
operator|->
name|X_op
operator|!=
name|O_absent
operator|&&
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|expp_sreg
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expp_sreg
operator|->
name|X_add_number
operator|=
name|regno
operator|+
literal|256
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Handle MMIX-specific option.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
name|warn_on_expansion
operator|=
literal|0
expr_stmt|;
name|allocate_undefined_gregs_in_linker
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_RELAX
case|:
name|linkrelax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NOEXPAND
case|:
name|expand_op
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NOMERGEGREG
case|:
name|merge_gregs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NOSYMS
case|:
name|predefined_syms
operator|=
literal|0
expr_stmt|;
name|equated_spec_regs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_GNU_SYNTAX
case|:
name|mmix_gnu_syntax
operator|=
literal|1
expr_stmt|;
name|label_without_colon_this_line
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_GLOBALIZE_SYMBOLS
case|:
name|mmix_globalize_symbols
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_FIXED_SPEC_REGS
case|:
name|equated_spec_regs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_LINKER_ALLOCATED_GREGS
case|:
name|allocate_undefined_gregs_in_linker
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NOPUSHJSTUBS
case|:
name|pushj_stubs
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Display MMIX-specific help text.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" MMIX-specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -fixed-special-register-names\n\                           Allow only the original special register names.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -globalize-symbols      Make all symbols global.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -gnu-syntax             Turn off mmixal syntax compatibility.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -relax                  Create linker relaxable code.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-predefined-syms     Do not provide mmixal built-in constants.\n\                           Implies -fixed-special-register-names.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-expand              Do not expand GETA, branches, PUSHJ or JUMP\n\                           into multiple instructions.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -no-merge-gregs         Do not merge GREG definitions with nearby values.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -linker-allocated-gregs If there's no suitable GREG definition for the\                           operands of an instruction, let the linker resolve.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -x                      Do not warn when an operand to GETA, a branch,\n\                           PUSHJ or JUMP is not known to be within range.\n\                           The linker will catch any errors.  Implies\n\                           -linker-allocated-gregs."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Step to end of line, but don't step over the end of the line.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_discard_rest_of_line
parameter_list|()
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|||
name|TC_EOL_IN_INSN
argument_list|(
name|input_line_pointer
argument_list|)
operator|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Act as demand_empty_rest_of_line if we're in strict GNU syntax mode,    otherwise just ignore the rest of the line (and skip the end-of-line    delimiter).  */
end_comment

begin_function
specifier|static
name|void
name|mmix_handle_rest_of_empty_line
parameter_list|()
block|{
if|if
condition|(
name|mmix_gnu_syntax
condition|)
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|else
block|{
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize GAS MMIX specifics.  */
end_comment

begin_function
name|void
name|mmix_md_begin
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|mmix_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* We assume nobody will use this, so don't allocate any room.  */
name|obstack_begin
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This will break the day the "lex" thingy changes.  For now, it's the      only way to make ':' part of a name, and a name beginner.  */
name|lex_type
index|[
literal|':'
index|]
operator|=
operator|(
name|LEX_NAME
operator||
name|LEX_BEGIN_NAME
operator|)
expr_stmt|;
name|mmix_opcode_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|real_reg_section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|mmix_opcodes
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|mmix_opcode_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* We always insert the ordinary registers 0..255 as registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* Alternatively, we could diddle with '$' and the following number, 	 but keeping the registers as symbols helps keep parsing simple.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|reg_section
argument_list|,
name|i
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert mmixal built-in names if allowed.  */
if|if
condition|(
name|predefined_syms
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
name|mmix_spec_regs
index|[
name|i
index|]
operator|.
name|number
operator|+
literal|256
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: Perhaps these should be recognized as specials; as field 	 names for those instructions.  */
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"ROUND_CURRENT"
argument_list|,
name|reg_section
argument_list|,
literal|512
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"ROUND_OFF"
argument_list|,
name|reg_section
argument_list|,
literal|512
operator|+
literal|1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"ROUND_UP"
argument_list|,
name|reg_section
argument_list|,
literal|512
operator|+
literal|2
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"ROUND_DOWN"
argument_list|,
name|reg_section
argument_list|,
literal|512
operator|+
literal|3
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"ROUND_NEAR"
argument_list|,
name|reg_section
argument_list|,
literal|512
operator|+
literal|4
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble one insn in STR.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|operands
init|=
name|str
decl_stmt|;
name|char
name|modified_char
init|=
literal|0
decl_stmt|;
name|struct
name|mmix_opcode
modifier|*
name|instruction
decl_stmt|;
name|fragS
modifier|*
name|opc_fragP
init|=
name|NULL
decl_stmt|;
name|int
name|max_operands
init|=
literal|3
decl_stmt|;
comment|/* Note that the struct frag member fr_literal in frags.h is char[], so      I have to make this a plain char *.  */
comment|/* unsigned */
name|char
modifier|*
name|opcodep
init|=
name|NULL
decl_stmt|;
name|expressionS
name|exp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|n_operands
init|=
literal|0
decl_stmt|;
comment|/* Move to end of opcode.  */
for|for
control|(
name|operands
operator|=
name|str
init|;
name|is_part_of_name
argument_list|(
operator|*
name|operands
argument_list|)
condition|;
operator|++
name|operands
control|)
empty_stmt|;
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|operands
argument_list|)
condition|)
block|{
name|modified_char
operator|=
operator|*
name|operands
expr_stmt|;
operator|*
name|operands
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|instruction
operator|=
operator|(
expr|struct
name|mmix_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mmix_opcode_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Avoid "unhandled label" errors.  */
name|pending_label
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Put back the character after the opcode.  */
if|if
condition|(
name|modified_char
operator|!=
literal|0
condition|)
name|operands
index|[
operator|-
literal|1
index|]
operator|=
name|modified_char
expr_stmt|;
name|input_line_pointer
operator|=
name|operands
expr_stmt|;
comment|/* Is this a mmixal pseudodirective?  */
if|if
condition|(
name|instruction
operator|->
name|type
operator|==
name|mmix_type_pseudo
condition|)
block|{
comment|/* For mmixal compatibility, a label for an instruction (and 	 emitting pseudo) refers to the _aligned_ address.  We emit the 	 label here for the pseudos that don't handle it themselves.  When 	 having an fb-label, emit it here, and increment the counter after 	 the pseudo.  */
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_loc
case|:
case|case
name|mmix_operands_byte
case|:
case|case
name|mmix_operands_prefix
case|:
case|case
name|mmix_operands_local
case|:
case|case
name|mmix_operands_bspec
case|:
case|case
name|mmix_operands_espec
case|:
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
name|colon
argument_list|(
name|fb_label_name
argument_list|(
name|current_fb_label
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pending_label
operator|!=
name|NULL
condition|)
block|{
name|colon
argument_list|(
name|pending_label
argument_list|)
expr_stmt|;
name|pending_label
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Some of the pseudos emit contents, others don't.  Set a 	 contents-emitted flag when we emit something into .text   */
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_loc
case|:
comment|/* LOC */
name|s_loc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_byte
case|:
comment|/* BYTE */
name|mmix_byte
argument_list|()
expr_stmt|;
break|break;
case|case
name|mmix_operands_wyde
case|:
comment|/* WYDE */
name|mmix_cons
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_tetra
case|:
comment|/* TETRA */
name|mmix_cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_octa
case|:
comment|/* OCTA */
name|mmix_cons
argument_list|(
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_prefix
case|:
comment|/* PREFIX */
name|s_prefix
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_local
case|:
comment|/* LOCAL */
name|mmix_s_local
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_bspec
case|:
comment|/* BSPEC */
name|s_bspec
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_espec
case|:
comment|/* ESPEC */
name|s_espec
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|instruction
operator|->
name|operands
argument_list|)
expr_stmt|;
block|}
comment|/* These are all working like the pseudo functions in read.c:s_..., 	 in that they step over the end-of-line marker at the end of the 	 line.  We don't want that here.  */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Step up the fb-label counter if there was a definition on this 	 line.  */
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
block|{
name|fb_label_instance_inc
argument_list|(
name|current_fb_label
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Reset any don't-align-next-datum request, unless this was a LOC          directive.  */
if|if
condition|(
name|instruction
operator|->
name|operands
operator|!=
name|mmix_operands_loc
condition|)
name|want_unaligned
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Not a pseudo; we *will* emit contents.  */
if|if
condition|(
name|now_seg
operator|==
name|data_section
condition|)
block|{
if|if
condition|(
name|lowest_data_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|lowest_data_loc
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|data_has_contents
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"specified location wasn't TETRA-aligned"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_unaligned
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unaligned data at an absolute location is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|lowest_data_loc
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
expr_stmt|;
name|lowest_data_loc
operator|+=
literal|4
expr_stmt|;
block|}
name|data_has_contents
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
block|{
if|if
condition|(
name|lowest_text_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|lowest_text_loc
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|text_has_contents
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"specified location wasn't TETRA-aligned"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_unaligned
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unaligned data at an absolute location is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|lowest_text_loc
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
expr_stmt|;
name|lowest_text_loc
operator|+=
literal|4
expr_stmt|;
block|}
name|text_has_contents
operator|=
literal|1
expr_stmt|;
block|}
comment|/* After a sequence of BYTEs or WYDEs, we need to get to instruction      alignment.  For other pseudos, a ".p2align 2" is supposed to be      inserted by the user.  */
if|if
condition|(
name|last_alignment
operator|<
literal|2
operator|&&
operator|!
name|want_unaligned
condition|)
block|{
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|last_alignment
operator|=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Reset any don't-align-next-datum request.  */
name|want_unaligned
operator|=
literal|0
expr_stmt|;
comment|/* For mmixal compatibility, a label for an instruction (and emitting      pseudo) refers to the _aligned_ address.  So we have to emit the      label here.  */
if|if
condition|(
name|pending_label
operator|!=
name|NULL
condition|)
block|{
name|colon
argument_list|(
name|pending_label
argument_list|)
expr_stmt|;
name|pending_label
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We assume that mmix_opcodes keeps having unique mnemonics for each      opcode, so we don't have to iterate over more than one opcode; if the      syntax does not match, then there's a syntax error.  */
comment|/* Operands have little or no context and are all comma-separated; it is      easier to parse each expression first.   */
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_reg_yz
case|:
case|case
name|mmix_operands_pop
case|:
case|case
name|mmix_operands_regaddr
case|:
case|case
name|mmix_operands_pushj
case|:
case|case
name|mmix_operands_get
case|:
case|case
name|mmix_operands_put
case|:
case|case
name|mmix_operands_set
case|:
case|case
name|mmix_operands_save
case|:
case|case
name|mmix_operands_unsave
case|:
name|max_operands
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|mmix_operands_sync
case|:
case|case
name|mmix_operands_jmp
case|:
case|case
name|mmix_operands_resume
case|:
name|max_operands
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* The original 3 is fine for the rest.  */
default|default:
break|break;
block|}
comment|/* If this is GET or PUT, and we don't do allow those names to be      equated, we need to parse the names ourselves, so we don't pick up a      user label instead of the special register.  */
if|if
condition|(
operator|!
name|equated_spec_regs
operator|&&
operator|(
name|instruction
operator|->
name|operands
operator|==
name|mmix_operands_get
operator|||
name|instruction
operator|->
name|operands
operator|==
name|mmix_operands_put
operator|)
condition|)
name|n_operands
operator|=
name|get_putget_operands
argument_list|(
name|instruction
argument_list|,
name|operands
argument_list|,
name|exp
argument_list|)
expr_stmt|;
else|else
name|n_operands
operator|=
name|get_operands
argument_list|(
name|max_operands
argument_list|,
name|operands
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* If there's a fb-label on the current line, set that label.  This must      be done *after* evaluating expressions of operands, since neither a      "1B" nor a "1F" refers to "1H" on the same line.  */
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
block|{
name|fb_label_instance_inc
argument_list|(
name|current_fb_label
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|fb_label_name
argument_list|(
name|current_fb_label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We also assume that the length of the instruction is at least 4, the      size of an unexpanded instruction.  We need a self-contained frag      since we want the relocation to point to the instruction, not the      variant part.  */
name|opcodep
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|mmix_opcode_frag
operator|=
name|opc_fragP
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|fr_opcode
operator|=
name|opcodep
expr_stmt|;
comment|/* Mark start of insn for DWARF2 debug features.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|instruction
operator|->
name|match
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_jmp
case|:
if|if
condition|(
name|n_operands
operator|==
literal|0
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
comment|/* Zeros are in place - nothing needs to be done when we have no 	   operands.  */
break|break;
comment|/* Add a frag for a JMP relaxation; we need room for max four 	 extra instructions.  We don't do any work around here to check if 	 we can determine the offset right away.  */
if|if
condition|(
name|n_operands
operator|!=
literal|1
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|expand_op
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_JMP
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_symbol
argument_list|,
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_ADDR27
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_pushj
case|:
comment|/* We take care of PUSHJ in full here.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
operator|(
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_op
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|PUSHJ_MAX_LEN
operator|-
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_symbol
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_ADDR19
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_regaddr
case|:
comment|/* GETA/branch: Add a frag for relaxation.  We don't do any work 	 around here to check if we can determine the offset right away.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|expand_op
condition|)
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_ADDR19
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|type
operator|==
name|mmix_type_condbranch
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|BCC_MAX_LEN
operator|-
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_BCC
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_symbol
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
else|else
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|GETA_MAX_LEN
operator|-
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_GETA
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_symbol
argument_list|,
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_regs
case|:
comment|/* We check the number of operands here, since we're in a 	 FALLTHROUGH sequence in the next switch.  */
if|if
condition|(
name|n_operands
operator|!=
literal|3
operator|||
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_regs_z
case|:
if|if
condition|(
name|n_operands
operator|!=
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_reg_yz
case|:
case|case
name|mmix_operands_roundregs_z
case|:
case|case
name|mmix_operands_roundregs
case|:
case|case
name|mmix_operands_regs_z_opt
case|:
case|case
name|mmix_operands_neg
case|:
case|case
name|mmix_operands_regaddr
case|:
case|case
name|mmix_operands_get
case|:
case|case
name|mmix_operands_set
case|:
case|case
name|mmix_operands_save
case|:
if|if
condition|(
name|n_operands
operator|<
literal|1
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
comment|/* A corresponding once-over for those who take an 8-bit constant as      their first operand.  */
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_pushgo
case|:
comment|/* PUSHGO: X is a constant, but can be expressed as a register. 	 We handle X here and use the common machinery of T,X,3,$ for 	 the rest of the operands.  */
if|if
condition|(
name|n_operands
operator|<
literal|2
operator|||
operator|(
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_pop
case|:
if|if
condition|(
operator|(
name|n_operands
operator|==
literal|0
operator|||
name|n_operands
operator|==
literal|1
operator|)
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
break|break;
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_x_regs_z
case|:
if|if
condition|(
name|n_operands
operator|<
literal|1
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
comment|/* FIXME: This doesn't bring us unsignedness checking.  */
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
default|default:
empty_stmt|;
block|}
comment|/* Handle the rest.  */
switch|switch
condition|(
name|instruction
operator|->
name|operands
condition|)
block|{
case|case
name|mmix_operands_set
case|:
comment|/* SET: Either two registers, "$X,$Y", with Z field as zero, or 	 "$X,YZ", meaning change the opcode to SETL.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|0xffff
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* There's an ambiguity with "SET $0,Y" when Y isn't defined 	     yet.  To keep things simple, we assume that Y is then a 	     register, and only change the opcode if Y is defined at this 	     point.  	     There's no compatibility problem with mmixal, since it emits 	     errors if the field is not defined at this point.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SETL_INSN_BYTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opcodep
index|[
literal|2
index|]
operator|=
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_x_regs_z
case|:
comment|/* SYNCD: "X,$Y,$Z|Z".  */
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_regs
case|:
comment|/* Three registers, $X,$Y,$Z.  */
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_regs_z
case|:
comment|/* Operands "$X,$Y,$Z|Z", number of arguments checked above.  */
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_pushgo
case|:
comment|/* Operands "$X|X,$Y,$Z|Z", optional Z.  */
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_regs_z_opt
case|:
comment|/* Operands "$X,$Y,$Z|Z", with $Z|Z being optional, default 0.  Any 	 operands not completely decided yet are postponed to later in 	 assembly (but not until link-time yet).  */
if|if
condition|(
operator|(
name|n_operands
operator|!=
literal|2
operator|&&
name|n_operands
operator|!=
literal|3
operator|)
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
operator|||
operator|(
name|n_operands
operator|==
literal|3
operator|&&
operator|(
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|&&
name|mmix_gnu_syntax
operator|)
operator|||
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n_operands
operator|==
literal|2
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* The last operand is immediate whenever we see just two 	     operands.  */
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
comment|/* Now, we could either have an implied "0" as the Z operand, or 	     it could be the constant of a "base address plus offset".  It 	     depends on whether it is allowed; only memory operations, as 	     signified by instruction->type and "T" and "X" operand types, 	     and it depends on whether we find a register in the second 	     operand, exp[1].  */
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<=
literal|255
condition|)
block|{
comment|/* A zero then; all done.  */
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
break|break;
block|}
comment|/* Not known as a register.  Is base address plus offset 	     allowed, or can we assume that it is a register anyway?  */
if|if
condition|(
operator|(
name|instruction
operator|->
name|operands
operator|!=
name|mmix_operands_regs_z_opt
operator|&&
name|instruction
operator|->
name|operands
operator|!=
name|mmix_operands_x_regs_z
operator|&&
name|instruction
operator|->
name|operands
operator|!=
name|mmix_operands_pushgo
operator|)
operator|||
operator|(
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_memaccess_octa
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_memaccess_tetra
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_memaccess_wyde
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_memaccess_byte
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_memaccess_block
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_jsr
operator|&&
name|instruction
operator|->
name|type
operator|!=
name|mmix_type_branch
operator|)
condition|)
block|{
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* To avoid getting a NULL add_symbol for constants and then 	     catching a SEGV in write_relocs since it doesn't handle 	     constants well for relocs other than PC-relative, we need to 	     pass expressions as symbols and use fix_new, not fix_new_exp.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|exp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now we know it can be a "base address plus offset".  Add 	     proper fixup types so we can handle this later, when we've 	     parsed everything.  */
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|8
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_BASE_PLUS_OFFSET
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG
argument_list|)
expr_stmt|;
comment|/* In mmixal compatibility mode, we allow special registers as 	 constants for the Z operand.  They have 256 added to their 	 register numbers, so the right thing will happen if we just treat 	 those as constants.  */
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<=
literal|255
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
block|{
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
operator|(
name|instruction
operator|->
name|operands
operator|==
name|mmix_operands_set
operator|||
name|instruction
operator|->
name|operands
operator|==
name|mmix_operands_regs
operator|)
condition|?
name|BFD_RELOC_MMIX_REG
else|:
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_pop
case|:
comment|/* POP, one eight and one 16-bit operand.  */
if|if
condition|(
name|n_operands
operator|==
literal|0
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
break|break;
if|if
condition|(
name|n_operands
operator|==
literal|1
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
goto|goto
name|a_single_24_bit_number_operand
goto|;
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_reg_yz
case|:
comment|/* A register and a 16-bit unsigned number.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|0xffff
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|2
index|]
operator|=
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
comment|/* FIXME: This doesn't bring us unsignedness checking.  */
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_jmp
case|:
comment|/* A JMP.  Everything is already done.  */
break|break;
case|case
name|mmix_operands_roundregs
case|:
comment|/* Two registers with optional rounding mode or constant in between.  */
if|if
condition|(
operator|(
name|n_operands
operator|==
literal|3
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|||
operator|(
name|n_operands
operator|==
literal|2
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|mmix_operands_roundregs_z
case|:
comment|/* Like FLOT, "$X,ROUND_MODE,$Z|Z", but the rounding mode is 	 optional and can be the corresponding constant.  */
block|{
comment|/* Which exp index holds the second operand (not the rounding 	   mode).  */
name|int
name|op2no
init|=
name|n_operands
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|n_operands
operator|!=
literal|2
operator|&&
name|n_operands
operator|!=
literal|3
operator|)
operator|||
operator|(
operator|(
name|exp
index|[
name|op2no
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
name|op2no
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
operator|||
operator|(
name|exp
index|[
name|op2no
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
name|op2no
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
name|op2no
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|n_operands
operator|==
literal|3
comment|/* We don't allow for the rounding mode to be deferred; it 		   must be determined in the "first pass".  It cannot be a 		   symbol equated to a rounding mode, but defined after 		   the first use.  */
operator|&&
operator|(
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|512
operator|)
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|4
operator|)
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add rounding mode if present.  */
if|if
condition|(
name|n_operands
operator|==
literal|3
condition|)
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|exp
index|[
name|op2no
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
name|op2no
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
name|op2no
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
name|op2no
index|]
operator|.
name|X_add_number
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
name|op2no
argument_list|,
literal|0
argument_list|,
name|instruction
operator|->
name|operands
operator|==
name|mmix_operands_roundregs
condition|?
name|BFD_RELOC_MMIX_REG
else|:
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|mmix_operands_sync
case|:
name|a_single_24_bit_number_operand
label|:
if|if
condition|(
name|n_operands
operator|!=
literal|1
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|0xffffff
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|1
index|]
operator|=
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|2
index|]
operator|=
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
comment|/* FIXME: This doesn't bring us unsignedness checking.  */
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_24
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_neg
case|:
comment|/* Operands "$X,Y,$Z|Z"; NEG or NEGU.  Y is optional, 0 is default.  */
if|if
condition|(
operator|(
name|n_operands
operator|!=
literal|3
operator|&&
name|n_operands
operator|!=
literal|2
operator|)
operator|||
operator|(
name|n_operands
operator|==
literal|3
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|||
operator|(
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|n_operands
operator|==
literal|3
operator|&&
operator|(
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
operator|||
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n_operands
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_regaddr
case|:
comment|/* A GETA/branch-type.  */
break|break;
case|case
name|mmix_operands_get
case|:
comment|/* "$X,spec_reg"; GET. 	 Like with rounding modes, we demand that the special register or 	 symbol is already defined when we get here at the point of use.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|256
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>=
literal|512
operator|)
operator|)
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|256
operator|)
operator|)
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|-
literal|256
expr_stmt|;
break|break;
case|case
name|mmix_operands_put
case|:
comment|/* "spec_reg,$Z|Z"; PUT.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|256
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>=
literal|512
operator|)
operator|)
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|256
operator|)
operator|)
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|-
literal|256
expr_stmt|;
comment|/* Note that the Y field is zero.  */
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_save
case|:
comment|/* "$X,0"; SAVE.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|mmix_operands_unsave
case|:
if|if
condition|(
name|n_operands
operator|<
literal|2
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
block|{
if|if
condition|(
name|n_operands
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* "0,$Z"; UNSAVE.  */
if|if
condition|(
name|n_operands
operator|!=
literal|2
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|!=
literal|0
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|||
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_xyz_opt
case|:
comment|/* SWYM, TRIP, TRAP: zero, one, two or three operands.  */
if|if
condition|(
name|n_operands
operator|==
literal|0
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
comment|/* Zeros are in place - nothing needs to be done for zero 	   operands.  We don't allow this in GNU syntax mode, because it 	   was believed that the risk of missing to supply an operand is 	   higher than the benefit of not having to specify a zero.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|n_operands
operator|==
literal|1
operator|&&
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|*
literal|255
operator|*
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|opcodep
index|[
literal|1
index|]
operator|=
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|2
index|]
operator|=
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_24
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_operands
operator|==
literal|2
operator|&&
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
comment|/* Two operands.  */
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|*
literal|255
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|opcodep
index|[
literal|2
index|]
operator|=
operator|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_operands
operator|==
literal|3
operator|&&
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
comment|/* Three operands.  */
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|||
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
operator|&
literal|255
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_operands
operator|<=
literal|3
operator|&&
operator|(
name|strcmp
argument_list|(
name|instruction
operator|->
name|name
argument_list|,
literal|"trip"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|instruction
operator|->
name|name
argument_list|,
literal|"trap"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* The meaning of operands to TRIP and TRAP are not defined, so 	     we add combinations not handled above here as we find them.  */
if|if
condition|(
name|n_operands
operator|==
literal|3
condition|)
block|{
comment|/* Don't require non-register operands.  Always generate 		 fixups, so we don't have to copy lots of code and create 		 maintenance problems.  TRIP is supposed to be a rare 		 instruction, so the overhead should not matter.  We 		 aren't allowed to fix_new_exp for an expression which is 		 an  O_register at this point, however.  */
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|2
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|2
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_operands
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|2
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_REG_OR_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported operands to %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|mmix_operands_resume
case|:
if|if
condition|(
name|n_operands
operator|==
literal|0
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
break|break;
if|if
condition|(
name|n_operands
operator|!=
literal|1
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|>
literal|255
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to opcode %s: `%s'"
argument_list|)
argument_list|,
name|instruction
operator|->
name|name
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|opcodep
index|[
literal|3
index|]
operator|=
name|exp
index|[
literal|0
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|exp
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmix_operands_pushj
case|:
comment|/* All is done for PUSHJ already.  */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|instruction
operator|->
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For the benefit of insns that start with a digit, we assemble by way of    tc_unrecognized_line too, through this function.  */
end_comment

begin_function
name|int
name|mmix_assemble_return_nonzero
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|last_error_count
init|=
name|had_errors
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Normal instruction handling downcases, so we must too.  */
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s2
argument_list|)
condition|)
operator|*
name|s2
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
comment|/* Cut the line for sake of the assembly.  */
for|for
control|(
name|s2
operator|=
name|str
init|;
operator|*
name|s2
operator|&&
operator|*
name|s2
operator|!=
literal|'\n'
condition|;
name|s2
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|s2
expr_stmt|;
operator|*
name|s2
operator|=
literal|0
expr_stmt|;
name|md_assemble
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|s2
operator|=
name|c
expr_stmt|;
return|return
name|had_errors
argument_list|()
operator|==
name|last_error_count
return|;
block|}
end_function

begin_comment
comment|/* The PREFIX pseudo.  */
end_comment

begin_function
specifier|static
name|void
name|s_prefix
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Reseting prefix?  */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|mmix_current_prefix
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Put this prefix on the mmix symbols obstack.  We could malloc and 	 free it separately, but then we'd have to worry about that. 	 People using up memory on prefixes have other problems.  */
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
expr_stmt|;
comment|/* Accumulate prefixes, and strip a leading ':'.  */
if|if
condition|(
name|mmix_current_prefix
operator|!=
name|NULL
operator|||
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|=
name|mmix_prefix_name
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mmix_current_prefix
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We implement prefixes by using the tc_canonicalize_symbol_name hook,    and store each prefixed name on a (separate) obstack.  This means that    the name is on the "notes" obstack in non-prefixed form and on the    mmix_sym_obstack in prefixed form, but currently it is not worth    rewriting the whole GAS symbol handling to improve "hooking" to avoid    that.  (It might be worth a rewrite for other reasons, though).  */
end_comment

begin_function
name|char
modifier|*
name|mmix_prefix_name
parameter_list|(
name|shortname
parameter_list|)
name|char
modifier|*
name|shortname
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|shortname
operator|==
literal|':'
condition|)
return|return
name|shortname
operator|+
literal|1
return|;
if|if
condition|(
name|mmix_current_prefix
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: mmix_prefix_name but empty prefix"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|shortname
operator|==
literal|'$'
condition|)
return|return
name|shortname
return|;
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|mmix_current_prefix
argument_list|,
name|strlen
argument_list|(
name|mmix_current_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|shortname
argument_list|,
name|strlen
argument_list|(
name|shortname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The GREG pseudo.  At LABEL, we have the name of a symbol that we    want to make a register symbol, and which should be initialized with    the value in the expression at INPUT_LINE_POINTER (defaulting to 0).    Either and (perhaps less meaningful) both may be missing.  LABEL must    be persistent, perhaps allocated on an obstack.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_greg_internal
parameter_list|(
name|label
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|expressionS
modifier|*
name|expP
init|=
operator|&
name|mmix_raw_gregs
index|[
name|n_of_raw_gregs
index|]
operator|.
name|exp
decl_stmt|;
comment|/* Don't set the section to register contents section before the      expression has been parsed; it may refer to the current position.  */
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
comment|/* FIXME: Check that no expression refers to the register contents      section.  May need to be done in elf64-mmix.c.  */
if|if
condition|(
name|expP
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
comment|/* Default to zero if the expression was absent.  */
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_unsigned
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We must handle prefixes here, as we save the labels and expressions      to be output later.  */
name|mmix_raw_gregs
index|[
name|n_of_raw_gregs
index|]
operator|.
name|label
operator|=
name|mmix_current_prefix
operator|==
name|NULL
condition|?
name|label
else|:
name|mmix_prefix_name
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_of_raw_gregs
operator|==
name|MAX_GREGS
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many GREG registers allocated (max %d)"
argument_list|)
argument_list|,
name|MAX_GREGS
argument_list|)
expr_stmt|;
else|else
name|n_of_raw_gregs
operator|++
expr_stmt|;
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The ".greg label,expr" worker.  */
end_comment

begin_function
specifier|static
name|void
name|s_greg
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* This will skip over what can be a symbol and zero out the next      character, which we assume is a ',' or other meaningful delimiter.      What comes after that is the initializer expression for the      register.  */
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* The label must be persistent; it's not used until after all input 	 has been seen.  */
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mmix_greg_internal
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mmix_greg_internal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "BSPEC expr" worker.  */
end_comment

begin_function
specifier|static
name|void
name|s_bspec
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|asection
modifier|*
name|expsec
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
name|secname
index|[
sizeof|sizeof
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
operator|+
literal|20
index|]
init|=
name|MMIX_OTHER_SPEC_SECTION_PREFIX
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Get a constant expression which we can evaluate *now*.  Supporting      more complex (though assembly-time computable) expressions is      feasible but Too Much Work for something of unknown usefulness like      BSPEC-ESPEC.  */
name|expsec
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
comment|/* Check that we don't have another BSPEC in progress.  */
if|if
condition|(
name|doing_bspec
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"BSPEC already active.  Nesting is not supported."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|expsec
operator|!=
name|absolute_section
operator|||
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
operator|.
name|X_add_number
operator|>
literal|65535
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid BSPEC expression"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|int
operator|)
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|sprintf
argument_list|(
name|secname
operator|+
name|strlen
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
comment|/* We need a non-volatile name as it will be stored in the section          struct.  */
name|char
modifier|*
name|newsecname
init|=
name|xstrdup
argument_list|(
name|secname
argument_list|)
decl_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|stdoutput
argument_list|,
name|newsecname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't create section %s"
argument_list|)
argument_list|,
name|newsecname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_READONLY
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't set section flags for section %s"
argument_list|)
argument_list|,
name|newsecname
argument_list|)
expr_stmt|;
block|}
comment|/* Tell ELF about the pending section change.  */
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save position for missing ESPEC.  */
name|as_where
argument_list|(
operator|&
name|bspec_file
argument_list|,
operator|&
name|bspec_line
argument_list|)
expr_stmt|;
name|doing_bspec
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "ESPEC" worker.  */
end_comment

begin_function
specifier|static
name|void
name|s_espec
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* First, check that we *do* have a BSPEC in progress.  */
if|if
condition|(
operator|!
name|doing_bspec
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ESPEC without preceding BSPEC"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
name|doing_bspec
operator|=
literal|0
expr_stmt|;
comment|/* When we told ELF about the section change in s_bspec, it stored the      previous section for us so we can get at it with the equivalent of a      .previous pseudo.  */
name|obj_elf_previous
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The " .local expr" and " local expr" worker.  We make a BFD_MMIX_LOCAL    relocation against the current position against the expression.    Implementing this by means of contents in a section lost.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_s_local
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
comment|/* Don't set the section to register contents section before the      expression has been parsed; it may refer to the current position in      some contorted way.  */
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing local expression"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
comment|/* fix_new_exp doesn't like O_register.  Should be configurable. 	 We're fine with a constant here, though.  */
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MMIX_LOCAL
argument_list|)
expr_stmt|;
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set fragP->fr_var to the initial guess of the size of a relaxable insn    and return it.  Sizes of other instructions are not known.  This    function may be called multiple times.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
define|#
directive|define
name|HANDLE_RELAXABLE
parameter_list|(
name|state
parameter_list|)
define|\
value|case ENCODE_RELAX (state, STATE_UNDF):					\    if (fragP->fr_symbol != NULL						\&& S_GET_SEGMENT (fragP->fr_symbol) == segment			\&& !S_IS_WEAK (fragP->fr_symbol))				\      {									\
comment|/* The symbol lies in the same segment - a relaxable case.  */
value|\        fragP->fr_subtype						\ 	 = ENCODE_RELAX (state, STATE_ZERO);				\      }									\    break;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_GETA
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_BCC
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_JMP
argument_list|)
expr_stmt|;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
comment|/* The symbol lies in the same segment - a relaxable case.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_ZERO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pushj_stubs
condition|)
comment|/* If we're to generate stubs, assume we can reach a stub after            the section.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJSTUB
argument_list|,
name|STATE_ZERO
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH.  */
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJSTUB
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
comment|/* We need to distinguish different relaxation rounds.  */
name|seg_info
argument_list|(
name|segment
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|last_stubfrag
operator|=
name|fragP
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_GETA
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BCC
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_JMP
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
comment|/* When relaxing a section for the second time, we don't need to do 	 anything except making sure that fr_var is set right.  */
break|break;
case|case
name|STATE_GREG_DEF
case|:
name|length
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|!=
name|NULL
condition|?
literal|0
else|:
literal|8
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|length
expr_stmt|;
comment|/* Don't consult the relax_table; it isn't valid for this 	 relaxation.  */
return|return
name|length
return|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
name|length
operator|=
name|mmix_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on    OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* FIXME: Having 'f' in mmix_flt_chars (and here) makes it 	 problematic to also have a forward reference in an expression. 	 The testsuite wants it, and it's customary. 	 We'll deal with the real problems when they come; we share the 	 problem with most other ports.  */
case|case
literal|'f'
case|:
case|case
literal|'r'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Convert variable-sized frags into one or more fixups.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
comment|/* Pointer to first byte in variable-sized part of the frag.  */
name|char
modifier|*
name|var_partp
decl_stmt|;
comment|/* Pointer to first opcode byte in frag.  */
name|char
modifier|*
name|opcodep
decl_stmt|;
comment|/* Size in bytes of variable-sized part of frag.  */
name|int
name|var_part_size
init|=
literal|0
decl_stmt|;
comment|/* This is part of *fragP.  It contains all information about addresses      and offsets to varying parts.  */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|long
name|var_part_offset
decl_stmt|;
comment|/* This is the frag for the opcode.  It, rather than fragP, must be used      when emitting a frag for the opcode.  */
name|fragS
modifier|*
name|opc_fragP
init|=
name|fragP
operator|->
name|tc_frag_data
decl_stmt|;
name|fixS
modifier|*
name|tmpfixP
decl_stmt|;
comment|/* Where, in file space, does addr point?  */
name|bfd_vma
name|target_address
decl_stmt|;
name|bfd_vma
name|opcode_address
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|var_part_offset
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|var_partp
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|var_part_offset
expr_stmt|;
name|opcodep
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|target_address
operator|=
operator|(
operator|(
name|symbolP
condition|?
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
else|:
literal|0
operator|)
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
expr_stmt|;
comment|/* The opcode that would be extended is the last four "fixed" bytes.  */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
literal|4
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJSTUB
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
comment|/* Setting the unknown bits to 0 seems the most appropriate.  */
name|mmix_set_geta_branch_offset
argument_list|(
name|opcodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpfixP
operator|=
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_PUSHJ_STUBBABLE
argument_list|)
expr_stmt|;
name|COPY_FR_WHERE_TO_FX
argument_list|(
name|fragP
argument_list|,
name|tmpfixP
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_GETA
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BCC
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
name|mmix_set_geta_branch_offset
argument_list|(
name|opcodep
argument_list|,
name|target_address
operator|-
name|opcode_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkrelax
condition|)
block|{
name|tmpfixP
operator|=
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_ADDR19
argument_list|)
expr_stmt|;
name|COPY_FR_WHERE_TO_FX
argument_list|(
name|fragP
argument_list|,
name|tmpfixP
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_JMP
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
name|mmix_set_jmp_offset
argument_list|(
name|opcodep
argument_list|,
name|target_address
operator|-
name|opcode_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkrelax
condition|)
block|{
name|tmpfixP
operator|=
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MMIX_ADDR27
argument_list|)
expr_stmt|;
name|COPY_FR_WHERE_TO_FX
argument_list|(
name|fragP
argument_list|,
name|tmpfixP
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STATE_GREG_DEF
case|:
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|==
name|NULL
condition|)
block|{
comment|/* We must initialize data that's supposed to be "fixed up" to 	     avoid emitting garbage, because md_apply_fix3 won't do 	     anything for undefined symbols.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tmpfixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
name|COPY_FR_WHERE_TO_FX
argument_list|(
name|fragP
argument_list|,
name|tmpfixP
argument_list|)
expr_stmt|;
name|mmix_gregs
index|[
name|n_of_cooked_gregs
operator|++
index|]
operator|=
name|tmpfixP
expr_stmt|;
name|var_part_size
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
define|#
directive|define
name|HANDLE_MAX_RELOC
parameter_list|(
name|state
parameter_list|,
name|reloc
parameter_list|)
define|\
value|case ENCODE_RELAX (state, STATE_MAX):					\     var_part_size							\       = mmix_relax_table[ENCODE_RELAX (state, STATE_MAX)].rlx_length;	\     mmix_fill_nops (var_partp, var_part_size / 4);			\     if (warn_on_expansion)						\       as_warn_where (fragP->fr_file, fragP->fr_line,			\ 		     _("operand out of range, instruction expanded"));	\     tmpfixP = fix_new (fragP, var_partp - fragP->fr_literal - 4, 8,	\ 		       fragP->fr_symbol, fragP->fr_offset, 1, reloc);	\     COPY_FR_WHERE_TO_FX (fragP, tmpfixP);				\     break
name|HANDLE_MAX_RELOC
argument_list|(
name|STATE_GETA
argument_list|,
name|BFD_RELOC_MMIX_GETA
argument_list|)
expr_stmt|;
name|HANDLE_MAX_RELOC
argument_list|(
name|STATE_BCC
argument_list|,
name|BFD_RELOC_MMIX_CBRANCH
argument_list|)
expr_stmt|;
name|HANDLE_MAX_RELOC
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|BFD_RELOC_MMIX_PUSHJ
argument_list|)
expr_stmt|;
name|HANDLE_MAX_RELOC
argument_list|(
name|STATE_JMP
argument_list|,
name|BFD_RELOC_MMIX_JMP
argument_list|)
expr_stmt|;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|var_part_size
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Applies the desired value to the specified location.    Also sets up addends for RELA type relocations.    Stolen from tc-mcore.c.     Note that this function isn't called when linkrelax != 0.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|segment
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
comment|/* Note: use offsetT because it is signed, valueT is unsigned.  */
name|offsetT
name|val
init|=
operator|(
name|offsetT
operator|)
operator|*
name|valP
decl_stmt|;
name|segT
name|symsec
init|=
operator|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|?
name|absolute_section
else|:
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
decl_stmt|;
comment|/* If the fix is relative to a symbol which is not defined, or, (if      pcrel), not in the same segment as the fix, we cannot resolve it      here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|symsec
operator|!=
name|segment
operator|)
operator|||
operator|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|symsec
operator|!=
name|absolute_section
operator|&&
operator|(
operator|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_MMIX_REG
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_MMIX_REG_OR_BYTE
operator|)
operator|||
name|symsec
operator|!=
name|reg_section
operator|)
operator|)
operator|)
condition|)
block|{
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MMIX_LOCAL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
comment|/* These are never "fixed".  */
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
comment|/* We assume every other relocation is "fixed".  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_24
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_24_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_ADDR19
case|:
if|if
condition|(
name|expand_op
condition|)
block|{
comment|/* This shouldn't happen.  */
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|BFD_RELOC_MMIX_GETA
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_STUBBABLE
case|:
comment|/* If this fixup is out of range, punt to the linker to emit an 	 error.  This should only happen with -no-expand.  */
if|if
condition|(
name|val
operator|<
operator|-
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|19
operator|)
operator|/
literal|2
operator|)
operator|||
name|val
operator|>=
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|19
operator|)
operator|/
literal|2
operator|-
literal|1
operator|||
operator|(
name|val
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|warn_on_expansion
condition|)
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|mmix_set_geta_branch_offset
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_ADDR27
case|:
if|if
condition|(
name|expand_op
condition|)
block|{
comment|/* This shouldn't happen.  */
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|BFD_RELOC_MMIX_JMP
case|:
comment|/* If this fixup is out of range, punt to the linker to emit an 	 error.  This should only happen with -no-expand.  */
if|if
condition|(
name|val
operator|<
operator|-
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|27
operator|)
operator|/
literal|2
operator|)
operator|||
name|val
operator|>=
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|27
operator|)
operator|/
literal|2
operator|-
literal|1
operator|||
operator|(
name|val
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|warn_on_expansion
condition|)
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|mmix_set_jmp_offset
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_REG_OR_BYTE
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|reg_section
operator|||
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|>
literal|255
operator|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|absolute_section
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't want this "symbol" appearing in output, because 	     that will fail.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
comment|/* If this reloc is for a Z field, we need to adjust 	 the opcode if we got a constant here. 	 FIXME: Can we make this more robust?  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_where
operator|&
literal|3
operator|)
operator|==
literal|3
operator|&&
operator|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|absolute_section
operator|)
condition|)
name|buf
index|[
operator|-
literal|3
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_REG
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|reg_section
operator|||
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|>
literal|255
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|buf
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_BASE_PLUS_OFFSET
case|:
comment|/* These are never "fixed".  */
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_MMIX_PUSHJ_1
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_2
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_3
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_J
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_1
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_2
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_3
case|:
case|case
name|BFD_RELOC_MMIX_GETA_1
case|:
case|case
name|BFD_RELOC_MMIX_GETA_2
case|:
case|case
name|BFD_RELOC_MMIX_GETA_3
case|:
case|case
name|BFD_RELOC_MMIX_JMP_1
case|:
case|case
name|BFD_RELOC_MMIX_JMP_2
case|:
case|case
name|BFD_RELOC_MMIX_JMP_3
case|:
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
comment|/* Make sure that for completed fixups we have the value around for        use by e.g. mmix_frob_file.  */
name|fixP
operator|->
name|fx_offset
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A bsearch function for looking up a value against offsets for GREG    definitions.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_greg_val_greg_symbol_fixes
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
name|offsetT
name|val1
init|=
operator|*
operator|(
name|offsetT
operator|*
operator|)
name|p1
decl_stmt|;
name|offsetT
name|val2
init|=
operator|(
operator|(
expr|struct
name|mmix_symbol_greg_fixes
operator|*
operator|)
name|p2
operator|)
operator|->
name|offs
decl_stmt|;
if|if
condition|(
name|val1
operator|>=
name|val2
operator|&&
name|val1
operator|<
name|val2
operator|+
literal|255
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val1
operator|>
name|val2
condition|)
return|return
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a machine-dependent relocation.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|bfd_signed_vma
name|val
init|=
name|fixP
operator|->
name|fx_offset
operator|+
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|arelent
modifier|*
name|relP
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
init|=
name|BFD_RELOC_NONE
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|symbolS
modifier|*
name|addsy
init|=
name|fixP
operator|->
name|fx_addsy
decl_stmt|;
name|asection
modifier|*
name|addsec
init|=
name|addsy
operator|==
name|NULL
condition|?
name|NULL
else|:
name|S_GET_SEGMENT
argument_list|(
name|addsy
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|baddsy
init|=
name|addsy
operator|!=
name|NULL
condition|?
name|symbol_get_bfdsym
argument_list|(
name|addsy
argument_list|)
else|:
name|NULL
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|val
operator|-
operator|(
name|baddsy
operator|==
name|NULL
operator|||
name|S_IS_COMMON
argument_list|(
name|addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|addsy
argument_list|)
condition|?
literal|0
else|:
name|bfd_asymbol_value
argument_list|(
name|baddsy
argument_list|)
operator|)
decl_stmt|;
comment|/* A single " LOCAL expression" in the wrong section will not work when      linking to MMO; relocations for zero-content sections are then      ignored.  Normally, relocations would modify section contents, and      you'd never think or be able to do something like that.  The      relocation resulting from a LOCAL directive doesn't have an obvious      and mandatory location.  I can't figure out a way to do this better      than just helping the user around this limitation here; hopefully the      code using the local expression is around.  Putting the LOCAL      semantics in a relocation still seems right; a section didn't do.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|)
operator|==
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MMIX_LOCAL
comment|/* The BFD_RELOC_MMIX_LOCAL-specific message is supposed to be 	  user-friendly, though a little bit non-substantial.  */
condition|?
name|_
argument_list|(
literal|"directive LOCAL must be placed in code or data"
argument_list|)
else|:
name|_
argument_list|(
literal|"internal confusion: relocation in a section without contents"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: Range tests for all these.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_24
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_8
case|:
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|addsy
operator|==
name|NULL
operator|||
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
condition|)
block|{
comment|/* Resolve this reloc now, as md_apply_fix3 would have done (not 	     called if -linkrelax).  There is no point in keeping a reloc 	     to an absolute symbol.  No reloc that is subject to 	     relaxation must be to an absolute symbol; difference 	     involving symbols in a specific section must be signalled as 	     an error if the relaxing cannot be expressed; having a reloc 	     to the resolved (now absolute) value does not help.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_24_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_MMIX_LOCAL
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_MMIX_GETA
case|:
case|case
name|BFD_RELOC_MMIX_GETA_1
case|:
case|case
name|BFD_RELOC_MMIX_GETA_2
case|:
case|case
name|BFD_RELOC_MMIX_GETA_3
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_J
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_1
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_2
case|:
case|case
name|BFD_RELOC_MMIX_CBRANCH_3
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_1
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_2
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_3
case|:
case|case
name|BFD_RELOC_MMIX_PUSHJ_STUBBABLE
case|:
case|case
name|BFD_RELOC_MMIX_JMP
case|:
case|case
name|BFD_RELOC_MMIX_JMP_1
case|:
case|case
name|BFD_RELOC_MMIX_JMP_2
case|:
case|case
name|BFD_RELOC_MMIX_JMP_3
case|:
case|case
name|BFD_RELOC_MMIX_ADDR19
case|:
case|case
name|BFD_RELOC_MMIX_ADDR27
case|:
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MMIX_REG_OR_BYTE
case|:
comment|/* If we have this kind of relocation to an unknown symbol or to the 	 register contents section (that is, to a register), then we can't 	 resolve the relocation here.  */
if|if
condition|(
name|addsy
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_is_und_section
argument_list|(
name|addsec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|addsec
operator|->
name|owner
argument_list|,
name|addsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
break|break;
block|}
comment|/* If the relocation is not to the register section or to the 	 absolute section (a numeric value), then we have an error.  */
if|if
condition|(
name|addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|addsy
argument_list|)
operator|!=
name|real_reg_section
operator|||
name|val
operator|>
literal|255
operator|||
name|val
operator|<
literal|0
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
condition|)
goto|goto
name|badop
goto|;
comment|/* Set the "immediate" bit of the insn if this relocation is to Z 	 field when the value is a numeric value, i.e. not a register.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_where
operator|&
literal|3
operator|)
operator|==
literal|3
operator|&&
operator|(
name|addsy
operator|==
name|NULL
operator|||
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
operator|)
condition|)
name|buf
index|[
operator|-
literal|3
index|]
operator||=
name|IMM_OFFSET_BIT
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_MMIX_BASE_PLUS_OFFSET
case|:
if|if
condition|(
name|addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|addsec
operator|->
name|owner
argument_list|,
name|addsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This changed into a register; the relocation is for the 	     register-contents section.  The constant part remains zero.  */
name|code
operator|=
name|BFD_RELOC_MMIX_REG
expr_stmt|;
break|break;
block|}
comment|/* If we've found out that this was indeed a register, then replace 	 with the register number.  The constant part is already zero.  	 If we encounter any other defined symbol, then we must find a 	 suitable register and emit a reloc.  */
if|if
condition|(
name|addsy
operator|==
name|NULL
operator|||
name|addsec
operator|!=
name|real_reg_section
condition|)
block|{
name|struct
name|mmix_symbol_gregs
modifier|*
name|gregs
decl_stmt|;
name|struct
name|mmix_symbol_greg_fixes
modifier|*
name|fix
decl_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|addsy
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|addsec
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|addsy
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|symbol_section_p
argument_list|(
name|addsy
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: BFD_RELOC_MMIX_BASE_PLUS_OFFSET not resolved to section"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is an absolute symbol sufficiently near 		 lowest_data_loc, then we canonicalize on the data 		 section.  Note that val is signed here; we may subtract 		 lowest_data_loc which is unsigned.  Careful with those 		 comparisons.  */
if|if
condition|(
name|lowest_data_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|bfd_vma
operator|)
name|val
operator|+
literal|256
operator|>
name|lowest_data_loc
operator|&&
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
condition|)
block|{
name|val
operator|-=
operator|(
name|offsetT
operator|)
name|lowest_data_loc
expr_stmt|;
name|addsy
operator|=
name|section_symbol
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise text section.  */
elseif|else
if|if
condition|(
name|lowest_text_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|bfd_vma
operator|)
name|val
operator|+
literal|256
operator|>
name|lowest_text_loc
operator|&&
name|bfd_is_abs_section
argument_list|(
name|addsec
argument_list|)
condition|)
block|{
name|val
operator|-=
operator|(
name|offsetT
operator|)
name|lowest_text_loc
expr_stmt|;
name|addsy
operator|=
name|section_symbol
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
block|}
block|}
name|gregs
operator|=
operator|*
name|symbol_get_tc
argument_list|(
name|addsy
argument_list|)
expr_stmt|;
comment|/* If that symbol does not have any associated GREG definitions, 	     we can't do anything.  */
if|if
condition|(
name|gregs
operator|==
name|NULL
operator|||
operator|(
name|fix
operator|=
name|bsearch
argument_list|(
operator|&
name|val
argument_list|,
name|gregs
operator|->
name|greg_fixes
argument_list|,
name|gregs
operator|->
name|n_gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|gregs
operator|->
name|greg_fixes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmp_greg_val_greg_symbol_fixes
argument_list|)
operator|)
operator|==
name|NULL
comment|/* The register must not point *after* the address we want.  */
operator|||
name|fix
operator|->
name|offs
operator|>
name|val
comment|/* Neither must the register point more than 255 bytes 		 before the address we want.  */
operator|||
name|fix
operator|->
name|offs
operator|+
literal|255
operator|<
name|val
condition|)
block|{
comment|/* We can either let the linker allocate GREGs 		 automatically, or emit an error.  */
if|if
condition|(
name|allocate_undefined_gregs_in_linker
condition|)
block|{
comment|/* The values in baddsy and addend are right.  */
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
break|break;
block|}
else|else
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"no suitable GREG definition for operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Transform the base-plus-offset reloc for the actual area 		 to a reloc for the register with the address of the area. 		 Put addend for register in Z operand.  */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|-
name|fix
operator|->
name|offs
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_MMIX_REG
expr_stmt|;
name|baddsy
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|->
name|symbol
operator|)
expr_stmt|;
name|addend
operator|=
name|fix
operator|->
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix
operator|->
name|fix
operator|->
name|fx_where
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|addsy
argument_list|)
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid operands"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|buf
operator|=
name|val
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|BFD_RELOC_MMIX_REG
case|:
if|if
condition|(
name|addsy
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_is_und_section
argument_list|(
name|addsec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|addsec
operator|->
name|owner
argument_list|,
name|addsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addsy
operator|!=
name|NULL
operator|&&
operator|(
name|addsec
operator|!=
name|real_reg_section
operator|||
name|val
operator|>
literal|255
operator|||
name|val
operator|<
literal|0
operator|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|addsec
argument_list|)
condition|)
comment|/* Drop through to error message.  */
empty_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FALLTHROUGH.  */
comment|/* The others are supposed to be handled by md_apply_fix3. 	 FIXME: ... which isn't called when -linkrelax.  Move over 	 md_apply_fix3 code here for everything reasonable.  */
name|badop
label|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operands were not reducible at assembly-time"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unmark this symbol as used in a reloc, so we don't bump into a BFD 	 assert when trying to output reg_section.  FIXME: A gas bug.  */
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|relP
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|relP
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relP
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relP
operator|->
name|sym_ptr_ptr
operator|=
name|baddsy
expr_stmt|;
name|relP
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|relP
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
comment|/* If this had been a.out, we would have had a kludge for weak symbols      here.  */
name|relP
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relP
operator|->
name|howto
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot generate relocation type for symbol %s, code %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relP
return|;
block|}
end_function

begin_comment
comment|/* Do some reformatting of a line.  FIXME: We could transform a mmixal    line into traditional (GNU?) format, unless #NO_APP, and get rid of all    ugly labels_without_colons etc.  */
end_comment

begin_function
name|void
name|mmix_handle_mmixal
parameter_list|()
block|{
name|char
modifier|*
name|s0
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|pending_label
operator|!=
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: unhandled label %s"
argument_list|)
argument_list|,
name|pending_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmix_gnu_syntax
condition|)
return|return;
comment|/* If the first character is a '.', then it's a pseudodirective, not a      label.  Make GAS not handle label-without-colon on this line.  We      also don't do mmixal-specific stuff on this line.  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|label_without_colon_this_line
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Don't handle empty lines here.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|s0
operator|==
literal|0
operator|||
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s0
index|]
condition|)
return|return;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s0
argument_list|)
condition|)
break|break;
name|s0
operator|++
expr_stmt|;
block|}
comment|/* If we're on a line with a label, check if it's a mmixal fb-label.      Save an indicator and skip the label; it must be set only after all      fb-labels of expressions are evaluated.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'H'
operator|&&
name|ISSPACE
argument_list|(
name|input_line_pointer
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|current_fb_label
operator|=
name|input_line_pointer
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* We have to skip the label, but also preserve the newlineness of 	 the previous character, since the caller checks that.  It's a 	 mess we blame on the caller.  */
name|input_line_pointer
index|[
literal|1
index|]
operator|=
name|input_line_pointer
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
comment|/* For errors emitted here, the book-keeping is off by one; the 	 caller is about to bump the counters.  Adjust the error messages.  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|name
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"[0-9]H labels may not appear alone on a line"
argument_list|)
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|name
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"[0-9]H labels do not mix with dot-pseudos"
argument_list|)
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|is_name_beginner
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
condition|)
name|label
operator|=
name|input_line_pointer
expr_stmt|;
block|}
name|s0
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Skip over label.  */
while|while
condition|(
operator|*
name|s0
operator|&&
name|is_part_of_name
argument_list|(
operator|*
name|s0
argument_list|)
condition|)
name|s0
operator|++
expr_stmt|;
comment|/* Remove trailing ":" off labels, as they'd otherwise be considered      part of the name.  But don't do it for local labels.  */
if|if
condition|(
name|s0
operator|!=
name|input_line_pointer
operator|&&
name|s0
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|s0
operator|-
literal|2
operator|!=
name|input_line_pointer
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|s0
index|[
operator|-
literal|2
index|]
argument_list|)
operator|)
condition|)
name|s0
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
comment|/* For labels that don't end in ":", we save it so we can later give 	 it the same alignment and address as the associated instruction.  */
comment|/* Make room for the label including the ending nul.  */
name|int
name|len_0
init|=
name|s0
operator|-
name|label
operator|+
literal|1
decl_stmt|;
comment|/* Save this label on the MMIX symbol obstack.  Saving it on an 	 obstack is needless for "IS"-pseudos, but it's harmless and we 	 avoid a little code-cluttering.  */
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|label
argument_list|,
name|len_0
argument_list|)
expr_stmt|;
name|pending_label
operator|=
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
expr_stmt|;
name|pending_label
index|[
name|len_0
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s0
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|s0
argument_list|)
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s0
index|]
condition|)
name|s0
operator|++
expr_stmt|;
if|if
condition|(
name|pending_label
operator|!=
name|NULL
operator|&&
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s0
index|]
condition|)
comment|/* Whoops, this was actually a lone label on a line.  Like :-ended        labels, we don't attach such labels to the next instruction or        pseudo.  */
name|pending_label
operator|=
name|NULL
expr_stmt|;
comment|/* Find local labels of operands.  Look for "[0-9][FB]" where the      characters before and after are not part of words.  Break if a single      or double quote is seen anywhere.  It means we can't have local      labels as part of list with mixed quoted and unquoted members for      mmixal compatibility but we can't have it all.  For the moment.      Replace the '<N>B' or '<N>F' with MAGIC_FB_BACKWARD_CHAR<N> and      MAGIC_FB_FORWARD_CHAR<N> respectively.  */
comment|/* First make sure we don't have any of the magic characters on the line      appearing as input.  */
name|s
operator|=
name|s0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
name|c
index|]
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|MAGIC_FB_BACKWARD_CHAR
operator|||
name|c
operator|==
name|MAGIC_FB_FORWARD_CHAR
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid characters in input"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scan again, this time looking for ';' after operands.  */
name|s
operator|=
name|s0
expr_stmt|;
comment|/* Skip the insn.  */
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|';'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip the spaces after the insn.  */
while|while
condition|(
operator|*
name|s
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|';'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip the operands.  While doing this, replace [0-9][BF] with      (MAGIC_FB_BACKWARD_CHAR|MAGIC_FB_FORWARD_CHAR)[0-9].  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|';'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
name|c
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* FIXME: Test-case for semi-colon in string.  */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'"'
operator|&&
operator|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
operator|||
operator|*
name|s
operator|==
literal|';'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'B'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'F'
operator|)
operator|||
name|is_part_of_name
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|is_part_of_name
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
block|{
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'B'
condition|?
name|MAGIC_FB_BACKWARD_CHAR
else|:
name|MAGIC_FB_FORWARD_CHAR
operator|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
comment|/* Skip any spaces after the operands.  */
while|while
condition|(
operator|*
name|s
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|';'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
comment|/* If we're now looking at a semi-colon, then it's an end-of-line      delimiter.  */
name|mmix_next_semicolon_is_eoln
operator|=
operator|(
operator|*
name|s
operator|==
literal|';'
operator|)
expr_stmt|;
comment|/* Make IS into an EQU by replacing it with "= ".  Only match upper-case      though; let lower-case be a syntax error.  */
name|s
operator|=
name|s0
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'I'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'S'
operator|&&
name|ISSPACE
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|'='
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Since labels can start without ":", we have to handle "X IS 42" 	 in full here, or "X" will be parsed as a label to be set at ".".  */
name|input_line_pointer
operator|=
name|s
expr_stmt|;
comment|/* Right after this function ends, line numbers will be bumped if 	 input_line_pointer[-1] = '\n'.  We want accurate line numbers for 	 the equals call, so we bump them before the call, and make sure 	 they aren't bumped afterwards.  */
name|bump_line_counters
argument_list|()
expr_stmt|;
comment|/* A fb-label is valid as an IS-label.  */
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|fb_name
decl_stmt|;
comment|/* We need to save this name on our symbol obstack, since the 	     string we got in fb_label_name is volatile and will change 	     with every call to fb_label_name, like those resulting from 	     parsing the IS-operand.  */
name|fb_name
operator|=
name|fb_label_name
argument_list|(
name|current_fb_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|fb_name
argument_list|,
name|strlen
argument_list|(
name|fb_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|equals
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fb_label_instance_inc
argument_list|(
name|current_fb_label
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pending_label
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"empty label field for IS"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|equals
argument_list|(
name|pending_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_label
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* For mmixal, we can have comments without a comment-start 	 character.   */
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'G'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'R'
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"GREG"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ISSPACE
argument_list|(
name|s
index|[
literal|4
index|]
argument_list|)
operator|||
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|4
index|]
index|]
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
name|s
operator|+
literal|4
expr_stmt|;
comment|/* Right after this function ends, line numbers will be bumped if 	 input_line_pointer[-1] = '\n'.  We want accurate line numbers for 	 the s_greg call, so we bump them before the call, and make sure 	 they aren't bumped afterwards.  */
name|bump_line_counters
argument_list|()
expr_stmt|;
comment|/* A fb-label is valid as a GREG-label.  */
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|fb_name
decl_stmt|;
comment|/* We need to save this name on our symbol obstack, since the 	     string we got in fb_label_name is volatile and will change 	     with every call to fb_label_name, like those resulting from 	     parsing the IS-operand.  */
name|fb_name
operator|=
name|fb_label_name
argument_list|(
name|current_fb_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure we save the canonical name and don't get bitten by              prefixes.  */
name|obstack_1grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|,
name|fb_name
argument_list|,
name|strlen
argument_list|(
name|fb_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mmix_greg_internal
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|mmix_sym_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_instance_inc
argument_list|(
name|current_fb_label
argument_list|)
expr_stmt|;
name|current_fb_label
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|mmix_greg_internal
argument_list|(
name|pending_label
argument_list|)
expr_stmt|;
comment|/* Back up before the end-of-line marker that was skipped in 	 mmix_greg_internal.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|pending_label
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pending_label
operator|!=
name|NULL
condition|)
block|{
name|input_line_pointer
operator|+=
name|strlen
argument_list|(
name|pending_label
argument_list|)
expr_stmt|;
comment|/* See comment above about getting line numbers bumped.  */
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Give the value of an fb-label rewritten as in mmix_handle_mmixal, when    parsing an expression.     On valid calls, input_line_pointer points at a MAGIC_FB_BACKWARD_CHAR    or MAGIC_FB_BACKWARD_CHAR, followed by an ascii digit for the label.    We fill in the label as an expression.  */
end_comment

begin_function
name|void
name|mmix_fb_label
parameter_list|(
name|expP
parameter_list|)
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|fb_internal_name
decl_stmt|;
comment|/* This doesn't happen when not using mmixal syntax.  */
if|if
condition|(
name|mmix_gnu_syntax
operator|||
operator|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
name|MAGIC_FB_BACKWARD_CHAR
operator|&&
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
name|MAGIC_FB_FORWARD_CHAR
operator|)
condition|)
return|return;
comment|/* The current backward reference has augmentation 0.  A forward      reference has augmentation 1, unless it's the same as a fb-label on      _this_ line, in which case we add one more so we don't refer to it.      This is the semantics of mmixal; it differs to that of common      fb-labels which refer to a here-label on the current line as a      backward reference.  */
name|fb_internal_name
operator|=
name|fb_label_name
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
operator|-
literal|'0'
argument_list|,
operator|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
name|MAGIC_FB_FORWARD_CHAR
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|input_line_pointer
index|[
literal|1
index|]
operator|-
literal|'0'
operator|==
name|current_fb_label
operator|&&
name|input_line_pointer
index|[
literal|0
index|]
operator|==
name|MAGIC_FB_FORWARD_CHAR
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|fb_internal_name
argument_list|)
expr_stmt|;
comment|/* We don't have to clean up unrelated fields here; we just do what the      expr machinery does, but *not* just what it does for [0-9][fb], since      we need to treat those as ordinary symbols sometimes; see testcases      err-byte2.s and fb-2.s.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|mmix_force_relocation
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MMIX_LOCAL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MMIX_BASE_PLUS_OFFSET
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|linkrelax
condition|)
return|return
literal|1
return|;
comment|/* All our pcrel relocations are must-keep.  Note that md_apply_fix3 is      called *after* this, and will handle getting rid of the presumed      reloc; a relocation isn't *forced* other than to be handled by      md_apply_fix3 (or tc_gen_reloc if linkrelax).  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fixP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section). 	 Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  We make reg_section relative to the real    register section.  */
end_comment

begin_function
name|void
name|mmix_adjust_symtab
parameter_list|()
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symbolS
modifier|*
name|regsec
init|=
name|section_symbol
argument_list|(
name|reg_section
argument_list|)
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|reg_section
condition|)
block|{
if|if
condition|(
name|sym
operator|==
name|regsec
condition|)
block|{
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|sym
argument_list|)
operator|||
name|symbol_used_in_reloc_p
argument_list|(
name|sym
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Change section to the *real* register section, so it gets 	     proper treatment when writing it out.  Only do this for 	     global symbols.  This also means we don't have to check for 	     $0..$255.  */
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|real_reg_section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the expansion of LABELS_WITHOUT_COLONS.    We let md_start_line_hook tweak label_without_colon_this_line, and then    this function returns the tweaked value, and sets it to 1 for the next    line.  FIXME: Very, very brittle.  Not sure it works the way I    thought at the time I first wrote this.  */
end_comment

begin_function
name|int
name|mmix_label_without_colon_this_line
parameter_list|()
block|{
name|int
name|retval
init|=
name|label_without_colon_this_line
decl_stmt|;
if|if
condition|(
operator|!
name|mmix_gnu_syntax
condition|)
name|label_without_colon_this_line
operator|=
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* This is the expansion of md_relax_frag.  We go through the ordinary    relax table function except when the frag is for a GREG.  Then we have    to check whether there's another GREG by the same value that we can    join with.  */
end_comment

begin_function
name|long
name|mmix_md_relax_frag
parameter_list|(
name|seg
parameter_list|,
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
comment|/* Growth for this type has been handled by mmix_md_end and 	 correctly estimated, so there's nothing more to do here.  */
case|case
name|STATE_GREG_DEF
case|:
return|return
literal|0
return|;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
block|{
comment|/* We need to handle relaxation type ourselves, since relax_frag 	   doesn't update fr_subtype if there's no size increase in the 	   current section; when going from plain PUSHJ to a stub.  This 	   is otherwise functionally the same as relax_frag in write.c, 	   simplified for this case.  */
name|offsetT
name|aim
decl_stmt|;
name|addressT
name|target
decl_stmt|;
name|addressT
name|address
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|target
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|absolute_section
operator|||
name|sym_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, assume it will 	       move by STRETCH just as we did.  If this is not so, it will 	       be because some frag between grows, and that will force 	       another pass.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|fragP
operator|->
name|relax_marker
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|seg
condition|)
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
name|aim
operator|=
name|target
operator|-
name|address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|aim
operator|>=
name|PUSHJ_0B
operator|&&
name|aim
operator|<=
name|PUSHJ_0F
condition|)
block|{
comment|/* Target is reachable with a PUSHJ.  */
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
decl_stmt|;
comment|/* If we're at the end of a relaxation round, clear the stub 	       counter as initialization for the next round.  */
if|if
condition|(
name|fragP
operator|==
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_stubfrag
condition|)
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|nstubs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Not reachable.  Try a stub.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJSTUB
argument_list|,
name|STATE_ZERO
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH.  */
comment|/* See if this PUSHJ is redirectable to a stub.  */
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJSTUB
argument_list|,
name|STATE_ZERO
argument_list|)
case|:
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|lastfrag
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_last
decl_stmt|;
name|relax_substateT
name|prev_type
init|=
name|fragP
operator|->
name|fr_subtype
decl_stmt|;
comment|/* The last frag is always an empty frag, so it suffices to look 	   at its address to know the ending address of this section.  */
name|know
argument_list|(
name|lastfrag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|lastfrag
operator|->
name|fr_fix
operator|==
literal|0
operator|&&
name|lastfrag
operator|->
name|fr_var
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* For this PUSHJ to be relaxable into a call to a stub, the 	   distance must be no longer than 256k bytes from the PUSHJ to 	   the end of the section plus the maximum size of stubs so far.  */
if|if
condition|(
operator|(
name|lastfrag
operator|->
name|fr_address
operator|+
name|stretch
operator|+
name|PUSHJ_MAX_LEN
operator|*
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|nstubs
operator|)
operator|-
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|>
name|GETA_0F
operator|||
operator|!
name|pushj_stubs
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|mmix_relax_table
index|[
name|prev_type
index|]
operator|.
name|rlx_more
expr_stmt|;
else|else
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|nstubs
operator|++
expr_stmt|;
comment|/* If we're at the end of a relaxation round, clear the stub 	   counter as initialization for the next round.  */
if|if
condition|(
name|fragP
operator|==
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_stubfrag
condition|)
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|nstubs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mmix_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
operator|-
name|mmix_relax_table
index|[
name|prev_type
index|]
operator|.
name|rlx_length
operator|)
return|;
block|}
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PUSHJ
argument_list|,
name|STATE_MAX
argument_list|)
case|:
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
decl_stmt|;
comment|/* Need to cover all STATE_PUSHJ states to act on the last stub 	   frag (the end of this relax round; initialization for the 	   next).  */
if|if
condition|(
name|fragP
operator|==
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_stubfrag
condition|)
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|nstubs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|relax_frag
argument_list|(
name|seg
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|)
return|;
case|case
name|STATE_GREG_UNDF
case|:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: unexpected relax type %d:%d"
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_type
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Various things we punt until all input is seen.  */
end_comment

begin_function
name|void
name|mmix_md_end
parameter_list|()
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|symbolS
modifier|*
name|mainsym
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The first frag of GREG:s going into the register contents section.  */
name|fragS
modifier|*
name|mmix_reg_contents_frags
init|=
name|NULL
decl_stmt|;
comment|/* Reset prefix.  All labels reachable at this point must be      canonicalized.  */
name|mmix_current_prefix
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|doing_bspec
condition|)
name|as_bad_where
argument_list|(
name|bspec_file
argument_list|,
name|bspec_line
argument_list|,
name|_
argument_list|(
literal|"BSPEC without ESPEC."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the low LOC setting of .text.  */
if|if
condition|(
name|text_has_contents
operator|&&
name|lowest_text_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
name|locsymbol
index|[
sizeof|sizeof
argument_list|(
literal|":"
argument_list|)
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|)
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
literal|".text"
argument_list|)
index|]
decl_stmt|;
comment|/* An exercise in non-ISO-C-ness, this one.  */
name|sprintf
argument_list|(
name|locsymbol
argument_list|,
literal|":%s%s"
argument_list|,
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|locsymbol
argument_list|,
name|absolute_section
argument_list|,
name|lowest_text_loc
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* Ditto .data.  */
if|if
condition|(
name|data_has_contents
operator|&&
name|lowest_data_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
name|locsymbol
index|[
sizeof|sizeof
argument_list|(
literal|":"
argument_list|)
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|)
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
literal|".data"
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|locsymbol
argument_list|,
literal|":%s%s"
argument_list|,
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|locsymbol
argument_list|,
name|absolute_section
argument_list|,
name|lowest_data_loc
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* Unless GNU syntax mode, set "Main" to be a function, so the      disassembler doesn't get confused when we write truly      mmixal-compatible code (and don't use .type).  Similarly set it      global (regardless of -globalize-symbols), so the linker sees it as      the start symbol in ELF mode.  */
name|mainsym
operator|=
name|symbol_find
argument_list|(
name|MMIX_START_SYMBOL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainsym
operator|!=
name|NULL
operator|&&
operator|!
name|mmix_gnu_syntax
condition|)
block|{
name|symbol_get_bfdsym
argument_list|(
name|mainsym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|mainsym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_of_raw_gregs
operator|!=
literal|0
condition|)
block|{
comment|/* Emit GREGs.  They are collected in order of appearance, but must 	 be emitted in opposite order to both have section address regno*8 	 and the same allocation order (within a file) as mmixal.  */
name|segT
name|this_segment
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|this_subsegment
init|=
name|now_subseg
decl_stmt|;
name|asection
modifier|*
name|regsec
init|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
decl_stmt|;
name|subseg_set
argument_list|(
name|regsec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally emit the initialization-value.  Emit a variable frag, which 	 we'll fix in md_estimate_size_before_relax.  We set the initializer 	 for the tc_frag_data field to NULL, so we can use that field for 	 relaxation purposes.  */
name|mmix_opcode_frag
operator|=
name|NULL
expr_stmt|;
name|frag_grow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mmix_reg_contents_frags
operator|=
name|frag_now
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_of_raw_gregs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mmix_raw_gregs
index|[
name|i
index|]
operator|.
name|label
operator|!=
name|NULL
condition|)
comment|/* There's a symbol.  Let it refer to this location in the 	       register contents section.  The symbol must be globalized 	       separately.  */
name|colon
argument_list|(
name|mmix_raw_gregs
index|[
name|i
index|]
operator|.
name|label
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|STATE_GREG_UNDF
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|mmix_raw_gregs
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|this_segment
argument_list|,
name|this_subsegment
argument_list|)
expr_stmt|;
block|}
comment|/* Iterate over frags resulting from GREGs and move those that evidently      have the same value together and point one to another.       This works in time O(N^2) but since the upper bound for non-error use      is 223, it's best to keep this simpler algorithm.  */
for|for
control|(
name|fragP
operator|=
name|mmix_reg_contents_frags
init|;
name|fragP
operator|!=
name|NULL
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragS
modifier|*
modifier|*
name|fpp
decl_stmt|;
name|fragS
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|fragS
modifier|*
name|osymfrag
decl_stmt|;
name|offsetT
name|osymval
decl_stmt|;
name|expressionS
modifier|*
name|oexpP
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
operator|||
name|fragP
operator|->
name|fr_subtype
operator|!=
name|STATE_GREG_UNDF
condition|)
continue|continue;
comment|/* Whatever the outcome, we will have this GREG judged merged or 	 non-merged.  Since the tc_frag_data is NULL at this point, we 	 default to non-merged.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|STATE_GREG_DEF
expr_stmt|;
comment|/* If we're not supposed to merge GREG definitions, then just don't 	 look for equivalents.  */
if|if
condition|(
operator|!
name|merge_gregs
condition|)
continue|continue;
name|osymval
operator|=
operator|(
name|offsetT
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|osymfrag
operator|=
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* If the symbol isn't defined, we can't say that another symbol 	 equals this frag, then.  FIXME: We can look at the "deepest" 	 defined name; if a = c and b = c then obviously a == b.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
continue|continue;
name|oexpP
operator|=
name|symbol_get_value_expression
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
comment|/* If the initialization value is zero, then we must not merge them.  */
if|if
condition|(
name|oexpP
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|osymval
operator|==
literal|0
condition|)
continue|continue;
comment|/* Iterate through the frags downward this one.  If we find one that 	 has the same non-zero value, move it to after this one and point 	 to it as the equivalent.  */
for|for
control|(
name|fpp
operator|=
operator|&
name|fragP
operator|->
name|fr_next
init|;
operator|*
name|fpp
operator|!=
name|NULL
condition|;
name|fpp
operator|=
operator|&
name|fpp
index|[
literal|0
index|]
operator|->
name|fr_next
control|)
block|{
name|fp
operator|=
operator|*
name|fpp
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
operator|||
name|fp
operator|->
name|fr_subtype
operator|!=
name|STATE_GREG_UNDF
condition|)
continue|continue;
comment|/* Calling S_GET_VALUE may simplify the symbol, changing from 	     expr_section etc. so call it first.  */
if|if
condition|(
operator|(
name|offsetT
operator|)
name|S_GET_VALUE
argument_list|(
name|fp
operator|->
name|fr_symbol
argument_list|)
operator|==
name|osymval
operator|&&
name|symbol_get_frag
argument_list|(
name|fp
operator|->
name|fr_symbol
argument_list|)
operator|==
name|osymfrag
condition|)
block|{
comment|/* Move the frag links so the one we found equivalent comes 		 after the current one, carefully considering that 		 sometimes fpp ==&fragP->fr_next and the moves must be a 		 NOP then.  */
operator|*
name|fpp
operator|=
name|fp
operator|->
name|fr_next
expr_stmt|;
name|fp
operator|->
name|fr_next
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
name|fragP
operator|->
name|fr_next
operator|=
name|fp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|fpp
operator|!=
name|NULL
condition|)
name|fragP
operator|->
name|tc_frag_data
operator|=
name|fp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* qsort function for mmix_symbol_gregs.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_greg_symbol_fixes
parameter_list|(
name|parg
parameter_list|,
name|qarg
parameter_list|)
specifier|const
name|PTR
name|parg
decl_stmt|;
specifier|const
name|PTR
name|qarg
decl_stmt|;
block|{
specifier|const
name|struct
name|mmix_symbol_greg_fixes
modifier|*
name|p
init|=
operator|(
specifier|const
expr|struct
name|mmix_symbol_greg_fixes
operator|*
operator|)
name|parg
decl_stmt|;
specifier|const
name|struct
name|mmix_symbol_greg_fixes
modifier|*
name|q
init|=
operator|(
specifier|const
expr|struct
name|mmix_symbol_greg_fixes
operator|*
operator|)
name|qarg
decl_stmt|;
return|return
name|p
operator|->
name|offs
operator|>
name|q
operator|->
name|offs
condition|?
literal|1
else|:
name|p
operator|->
name|offs
operator|<
name|q
operator|->
name|offs
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Collect GREG definitions from mmix_gregs and hang them as lists sorted    on increasing offsets onto each section symbol or undefined symbol.     Also, remove the register convenience section so it doesn't get output    as an ELF section.  */
end_comment

begin_function
name|void
name|mmix_frob_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mmix_symbol_gregs
modifier|*
name|all_greg_symbols
index|[
name|MAX_GREGS
index|]
decl_stmt|;
name|int
name|n_greg_symbols
init|=
literal|0
decl_stmt|;
comment|/* Collect all greg fixups and decorate each corresponding symbol with      the greg fixups for it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_of_cooked_gregs
condition|;
name|i
operator|++
control|)
block|{
name|offsetT
name|offs
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|struct
name|mmix_symbol_gregs
modifier|*
name|gregs
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|fixP
operator|=
name|mmix_gregs
index|[
name|i
index|]
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
comment|/* This case isn't doable in general anyway, methinks.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"GREG expression too complicated"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sym
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
name|offs
operator|=
operator|(
name|offsetT
operator|)
name|fixP
operator|->
name|fx_offset
expr_stmt|;
comment|/* If the symbol is defined, then it must be resolved to a section 	 symbol at this time, or else we don't know how to handle it.  */
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|symbol_section_p
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: GREG expression not resolved to section"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an absolute symbol sufficiently near lowest_data_loc, 	 then we canonicalize on the data section.  Note that offs is 	 signed here; we may subtract lowest_data_loc which is unsigned. 	 Careful with those comparisons.  */
if|if
condition|(
name|lowest_data_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|bfd_vma
operator|)
name|offs
operator|+
literal|256
operator|>
name|lowest_data_loc
operator|&&
name|bfd_is_abs_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|offs
operator|-=
operator|(
name|offsetT
operator|)
name|lowest_data_loc
expr_stmt|;
name|sym
operator|=
name|section_symbol
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise text section.  */
elseif|else
if|if
condition|(
name|lowest_text_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|bfd_vma
operator|)
name|offs
operator|+
literal|256
operator|>
name|lowest_text_loc
operator|&&
name|bfd_is_abs_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|offs
operator|-=
operator|(
name|offsetT
operator|)
name|lowest_text_loc
expr_stmt|;
name|sym
operator|=
name|section_symbol
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
block|}
name|gregs
operator|=
operator|*
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|gregs
operator|==
name|NULL
condition|)
block|{
name|gregs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gregs
argument_list|)
argument_list|)
expr_stmt|;
name|gregs
operator|->
name|n_gregs
operator|=
literal|0
expr_stmt|;
name|symbol_set_tc
argument_list|(
name|sym
argument_list|,
operator|&
name|gregs
argument_list|)
expr_stmt|;
name|all_greg_symbols
index|[
name|n_greg_symbols
operator|++
index|]
operator|=
name|gregs
expr_stmt|;
block|}
name|gregs
operator|->
name|greg_fixes
index|[
name|gregs
operator|->
name|n_gregs
index|]
operator|.
name|fix
operator|=
name|fixP
expr_stmt|;
name|gregs
operator|->
name|greg_fixes
index|[
name|gregs
operator|->
name|n_gregs
operator|++
index|]
operator|.
name|offs
operator|=
name|offs
expr_stmt|;
block|}
comment|/* For each symbol having a GREG definition, sort those definitions on      offset.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_greg_symbols
condition|;
name|i
operator|++
control|)
name|qsort
argument_list|(
name|all_greg_symbols
index|[
name|i
index|]
operator|->
name|greg_fixes
argument_list|,
name|all_greg_symbols
index|[
name|i
index|]
operator|->
name|n_gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|all_greg_symbols
index|[
name|i
index|]
operator|->
name|greg_fixes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmp_greg_symbol_fixes
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_reg_section
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
comment|/* FIXME: Pass error state gracefully.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|real_reg_section
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"register section has contents\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|real_reg_section
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|stdoutput
operator|->
name|section_count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Provide an expression for a built-in name provided when-used.    Either a symbol that is a handler; living in 0x10*[1..8] and having    name [DVWIOUZX]_Handler, or a mmixal built-in symbol.     If the name isn't a built-in name and parsed into *EXPP, return zero.  */
end_comment

begin_function
name|int
name|mmix_parse_predefined_name
parameter_list|(
name|name
parameter_list|,
name|expP
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
name|char
modifier|*
name|canon_name
decl_stmt|;
name|char
modifier|*
name|handler_charp
decl_stmt|;
specifier|const
name|char
name|handler_chars
index|[]
init|=
literal|"DVWIOUZX"
decl_stmt|;
name|symbolS
modifier|*
name|symp
decl_stmt|;
if|if
condition|(
operator|!
name|predefined_syms
condition|)
return|return
literal|0
return|;
name|canon_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|canon_name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|canon_name
operator|+
literal|2
argument_list|,
literal|"Handler"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|handler_charp
operator|=
name|strchr
argument_list|(
name|handler_chars
argument_list|,
operator|*
name|canon_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If the symbol doesn't exist, provide one relative to the .text 	 section.  	 FIXME: We should provide separate sections, mapped in the linker 	 script.  */
name|symp
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|==
name|NULL
condition|)
name|symp
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|text_section
argument_list|,
literal|0x10
operator|*
operator|(
name|handler_charp
operator|+
literal|1
operator|-
name|handler_chars
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* These symbols appear when referenced; needed for          mmixal-compatible programs.  */
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|valueT
name|val
decl_stmt|;
block|}
name|predefined_abs_syms
index|[]
init|=
block|{
block|{
literal|"Data_Segment"
block|,
operator|(
name|valueT
operator|)
literal|0x20
operator|<<
literal|56
block|}
block|,
block|{
literal|"Pool_Segment"
block|,
operator|(
name|valueT
operator|)
literal|0x40
operator|<<
literal|56
block|}
block|,
block|{
literal|"Stack_Segment"
block|,
operator|(
name|valueT
operator|)
literal|0x60
operator|<<
literal|56
block|}
block|,
block|{
literal|"StdIn"
block|,
literal|0
block|}
block|,
block|{
literal|"StdOut"
block|,
literal|1
block|}
block|,
block|{
literal|"StdErr"
block|,
literal|2
block|}
block|,
block|{
literal|"TextRead"
block|,
literal|0
block|}
block|,
block|{
literal|"TextWrite"
block|,
literal|1
block|}
block|,
block|{
literal|"BinaryRead"
block|,
literal|2
block|}
block|,
block|{
literal|"BinaryWrite"
block|,
literal|3
block|}
block|,
block|{
literal|"BinaryReadWrite"
block|,
literal|4
block|}
block|,
block|{
literal|"Halt"
block|,
literal|0
block|}
block|,
block|{
literal|"Fopen"
block|,
literal|1
block|}
block|,
block|{
literal|"Fclose"
block|,
literal|2
block|}
block|,
block|{
literal|"Fread"
block|,
literal|3
block|}
block|,
block|{
literal|"Fgets"
block|,
literal|4
block|}
block|,
block|{
literal|"Fgetws"
block|,
literal|5
block|}
block|,
block|{
literal|"Fwrite"
block|,
literal|6
block|}
block|,
block|{
literal|"Fputs"
block|,
literal|7
block|}
block|,
block|{
literal|"Fputws"
block|,
literal|8
block|}
block|,
block|{
literal|"Fseek"
block|,
literal|9
block|}
block|,
block|{
literal|"Ftell"
block|,
literal|10
block|}
block|,
block|{
literal|"D_BIT"
block|,
literal|0x80
block|}
block|,
block|{
literal|"V_BIT"
block|,
literal|0x40
block|}
block|,
block|{
literal|"W_BIT"
block|,
literal|0x20
block|}
block|,
block|{
literal|"I_BIT"
block|,
literal|0x10
block|}
block|,
block|{
literal|"O_BIT"
block|,
literal|0x08
block|}
block|,
block|{
literal|"U_BIT"
block|,
literal|0x04
block|}
block|,
block|{
literal|"Z_BIT"
block|,
literal|0x02
block|}
block|,
block|{
literal|"X_BIT"
block|,
literal|0x01
block|}
block|,
block|{
literal|"Inf"
block|,
literal|0x7ff00000
block|}
block|}
struct|;
comment|/* If it's already in the symbol table, we shouldn't do anything.  */
name|symp
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|predefined_abs_syms
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|predefined_abs_syms
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|canon_name
argument_list|,
name|predefined_abs_syms
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|predefined_abs_syms
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|absolute_section
argument_list|,
name|predefined_abs_syms
index|[
name|i
index|]
operator|.
name|val
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let gas find the symbol we just created, through its                ordinary lookup.  */
return|return
literal|0
return|;
block|}
comment|/* Not one of those symbols.  Let gas handle it.  */
return|return
literal|0
return|;
block|}
name|expP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|symp
expr_stmt|;
name|expP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Just check that we don't have a BSPEC/ESPEC pair active when changing    sections "normally", and get knowledge about alignment from the new    section.  */
end_comment

begin_function
name|void
name|mmix_md_elf_section_change_hook
parameter_list|()
block|{
if|if
condition|(
name|doing_bspec
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"section change from within a BSPEC/ESPEC pair is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|last_alignment
operator|=
name|bfd_get_section_alignment
argument_list|(
name|now_seg
operator|->
name|owner
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|want_unaligned
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The LOC worker.  This is like s_org, but we have to support changing    section too.   */
end_comment

begin_function
specifier|static
name|void
name|s_loc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segT
name|section
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
comment|/* Must not have a BSPEC in progress.  */
if|if
condition|(
name|doing_bspec
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directive LOC from within a BSPEC/ESPEC pair is not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|section
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
operator|||
name|exp
operator|.
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|.
name|X_op
operator|==
name|O_big
operator|||
name|section
operator|==
name|undefined_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid LOC expression"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|section
operator|==
name|absolute_section
condition|)
block|{
comment|/* Translate a constant into a suitable section.  */
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|<
operator|(
operator|(
name|offsetT
operator|)
literal|0x20
operator|<<
literal|56
operator|)
condition|)
block|{
comment|/* Lower than Data_Segment - assume it's .text.  */
name|section
operator|=
name|text_section
expr_stmt|;
comment|/* Save the lowest seen location, so we can pass on this 	     information to the linker.  We don't actually org to this 	     location here, we just pass on information to the linker so 	     it can put the code there for us.  */
comment|/* If there was already a loc (that has to be set lower than 	     this one), we org at (this - lower).  There's an implicit 	     "LOC 0" before any entered code.  FIXME: handled by spurious 	     settings of text_has_contents.  */
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
operator|.
name|X_add_number
operator|<
operator|(
name|offsetT
operator|)
name|lowest_text_loc
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"LOC expression stepping backwards is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|text_has_contents
operator|&&
name|lowest_text_loc
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|lowest_text_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lowest_text_loc
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|lowest_text_loc
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* We want only to change the section, not set an offset.  */
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
name|exp
operator|.
name|X_add_number
operator|-=
name|lowest_text_loc
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Do the same for the .data section.  */
name|section
operator|=
name|data_section
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|<
operator|(
name|offsetT
operator|)
name|lowest_data_loc
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"LOC expression stepping backwards is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data_has_contents
operator|&&
name|lowest_data_loc
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|lowest_data_loc
operator|=
operator|(
name|bfd_vma
operator|)
literal|0x20
operator|<<
literal|56
expr_stmt|;
if|if
condition|(
name|lowest_data_loc
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|lowest_data_loc
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* We want only to change the section, not set an offset.  */
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
name|exp
operator|.
name|X_add_number
operator|-=
name|lowest_data_loc
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|section
operator|!=
name|now_seg
condition|)
block|{
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call our section change hooks using the official hook.  */
name|md_elf_section_change_hook
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The BYTE worker.  We have to support sequences of mixed "strings",    numbers and other constant "first-pass" reducible expressions separated    by comma.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_byte
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|text_has_contents
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|now_seg
operator|==
name|data_section
condition|)
name|data_has_contents
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\"'
condition|)
block|{
comment|/* We will only get here in rare cases involving #NO_APP, 		 where the unterminated string is not recognized by the 		 preformatting pass.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|expressionS
name|exp
decl_stmt|;
name|segT
name|expseg
init|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
decl_stmt|;
comment|/* We have to allow special register names as constant numbers.  */
if|if
condition|(
operator|(
name|expseg
operator|!=
name|absolute_section
operator|&&
name|expseg
operator|!=
name|reg_section
operator|)
operator|||
operator|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
operator|(
name|exp
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|exp
operator|.
name|X_add_number
operator|<=
literal|255
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"BYTE expression not a pure number"
argument_list|)
argument_list|)
expr_stmt|;
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|exp
operator|.
name|X_add_number
operator|>
literal|255
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_register
operator|)
operator|||
name|exp
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
comment|/* Note that mmixal does not allow negative numbers in 		   BYTE sequences, so neither should we.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"BYTE expression not in the range 0..255"
argument_list|)
argument_list|)
expr_stmt|;
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
if|if
condition|(
name|mmix_gnu_syntax
condition|)
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|else
block|{
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Do like demand_empty_rest_of_line and step over the end-of-line          boundary.  */
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* Make sure we align for the next instruction.  */
name|last_alignment
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like cons_worker, but we have to ignore "naked comments", not barf on    them.  Implements WYDE, TETRA and OCTA.  We're a little bit more    lenient than mmix_byte but FIXME: they should eventually merge.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_cons
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
comment|/* If we don't have any contents, then it's ok to have a specified start      address that is not a multiple of the max data size.  We will then      align it as necessary when we get here.  Otherwise, it's a fatal sin.  */
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
block|{
if|if
condition|(
name|lowest_text_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|lowest_text_loc
operator|&
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|text_has_contents
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"data item with alignment larger than location"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_unaligned
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unaligned data at an absolute location is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|lowest_text_loc
operator|&=
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
name|nbytes
operator|-
literal|1
operator|)
expr_stmt|;
name|lowest_text_loc
operator|+=
operator|(
name|bfd_vma
operator|)
name|nbytes
expr_stmt|;
block|}
name|text_has_contents
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now_seg
operator|==
name|data_section
condition|)
block|{
if|if
condition|(
name|lowest_data_loc
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|lowest_data_loc
operator|&
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|data_has_contents
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"data item with alignment larger than location"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_unaligned
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unaligned data at an absolute location is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|lowest_data_loc
operator|&=
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
name|nbytes
operator|-
literal|1
operator|)
expr_stmt|;
name|lowest_data_loc
operator|+=
operator|(
name|bfd_vma
operator|)
name|nbytes
expr_stmt|;
block|}
name|data_has_contents
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Always align these unless asked not to (valid for the current pseudo).  */
if|if
condition|(
operator|!
name|want_unaligned
condition|)
block|{
name|last_alignment
operator|=
name|nbytes
operator|==
literal|2
condition|?
literal|1
else|:
operator|(
name|nbytes
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
expr_stmt|;
name|frag_align
argument_list|(
name|last_alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|last_alignment
argument_list|)
expr_stmt|;
block|}
comment|/* For mmixal compatibility, a label for an instruction (and emitting      pseudo) refers to the _aligned_ address.  So we have to emit the      label here.  */
if|if
condition|(
name|current_fb_label
operator|>=
literal|0
condition|)
name|colon
argument_list|(
name|fb_label_name
argument_list|(
name|current_fb_label
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pending_label
operator|!=
name|NULL
condition|)
block|{
name|colon
argument_list|(
name|pending_label
argument_list|)
expr_stmt|;
name|pending_label
operator|=
name|NULL
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
comment|/* Default to zero if the expression was absent.  */
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_unsigned
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
do|do
block|{
name|unsigned
name|int
name|c
decl_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
comment|/* We support strings here too; each character takes up nbytes 	       bytes.  */
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|c
expr_stmt|;
name|exp
operator|.
name|X_unsigned
operator|=
literal|1
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\"'
condition|)
block|{
comment|/* We will only get here in rare cases involving #NO_APP, 		   where the unterminated string is not recognized by the 		   preformatting pass.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|mmix_discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|mmix_handle_rest_of_empty_line
argument_list|()
expr_stmt|;
comment|/* We don't need to step up the counter for the current_fb_label here;      that's handled by the caller.  */
block|}
end_function

begin_comment
comment|/* The md_do_align worker.  At present, we just record an alignment to    nullify the automatic alignment we do for WYDE, TETRA and OCTA, as gcc    does not use the unaligned macros when attribute packed is used.    Arguably this is a GCC bug.  */
end_comment

begin_function
name|void
name|mmix_md_do_align
parameter_list|(
name|n
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|fill
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|len
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|last_alignment
operator|=
name|n
expr_stmt|;
name|want_unaligned
operator|=
name|n
operator|==
literal|0
expr_stmt|;
block|}
end_function

end_unit

