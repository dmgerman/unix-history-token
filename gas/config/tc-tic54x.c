begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-tic54x.c -- Assembly code for the Texas Instruments TMS320C54X    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Timothy Wall (twall@cygnus.com)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Texas Instruments TMS320C54X machine specific gas.    Written by Timothy Wall (twall@alum.mit.edu).     Valuable things to do:    Pipeline conflict warnings    We encode/decode "ld #_label, dp" differently in relocatable files      This means we're not compatible with TI output containing those      expressions.  We store the upper nine bits; TI stores the lower nine      bits.  How they recover the original upper nine bits is beyond me.     Tests to add to expect testsuite:      '=' and '==' with .if, .elseif, and .break     Incompatibilities (mostly trivial):    We don't allow '''    We fill text section with zeroes instead of "nop"s    We don't convert '' or "" to a single instance    We don't convert '' to '\0'    We don't allow strings with .byte/.half/.short/.long    Probably details of the subsym stuff are different    TI sets labels to be data type 4 (T_INT); GAS uses T_NULL.     COFF1 limits section names to 8 characters.    Some of the default behavior changed from COFF1 to COFF2.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic54x.h"
end_include

begin_include
include|#
directive|include
file|"obj-coff.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_struct
specifier|static
struct|struct
name|stag
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* Symbol for this stag; value is offset.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Shortcut to symbol name.  */
name|bfd_vma
name|size
decl_stmt|;
comment|/* Size of struct/union.  */
name|int
name|current_bitfield_offset
decl_stmt|;
comment|/* Temporary for tracking fields.  */
name|int
name|is_union
decl_stmt|;
struct|struct
name|stag_field
comment|/* List of fields.  */
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* Of start of this field.  */
name|int
name|bitfield_offset
decl_stmt|;
comment|/* Of start of this field.  */
name|struct
name|stag
modifier|*
name|stag
decl_stmt|;
comment|/* If field is struct/union.  */
name|struct
name|stag_field
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|field
struct|;
comment|/* For nesting; used only in stag construction.  */
name|struct
name|stag
modifier|*
name|inner
decl_stmt|;
comment|/* Enclosed .struct.  */
name|struct
name|stag
modifier|*
name|outer
decl_stmt|;
comment|/* Enclosing .struct.  */
block|}
modifier|*
name|current_stag
init|=
name|NULL
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_LINE
value|256
end_define

begin_comment
comment|/* Lines longer than this are truncated by TI's asm.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_tic54x_insn
block|{
specifier|const
name|template
modifier|*
name|tm
decl_stmt|;
comment|/* Opcode template.  */
name|char
name|mnemonic
index|[
name|MAX_LINE
index|]
decl_stmt|;
comment|/* Opcode name/mnemonic.  */
name|char
name|parmnemonic
index|[
name|MAX_LINE
index|]
decl_stmt|;
comment|/* 2nd mnemonic of parallel insn.  */
name|int
name|opcount
decl_stmt|;
struct|struct
name|opstruct
block|{
name|char
name|buf
index|[
name|MAX_LINE
index|]
decl_stmt|;
name|enum
name|optype
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
name|operands
index|[
name|MAX_OPERANDS
index|]
struct|;
name|int
name|paropcount
decl_stmt|;
name|struct
name|opstruct
name|paroperands
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
name|int
name|is_lkaddr
decl_stmt|;
name|int
name|lkoperand
decl_stmt|;
name|int
name|words
decl_stmt|;
comment|/* Size of insn in 16-bit words.  */
name|int
name|using_default_dst
decl_stmt|;
comment|/* Do we need to explicitly set an 				   omitted OP_DST operand?  */
struct|struct
block|{
name|unsigned
name|short
name|word
decl_stmt|;
comment|/* Final encoded opcode data.  */
name|int
name|unresolved
decl_stmt|;
name|int
name|r_nchars
decl_stmt|;
comment|/* Relocation size.  */
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
comment|/* Relocation type.  */
name|expressionS
name|addr_expr
decl_stmt|;
comment|/* Storage for unresolved expressions.  */
block|}
name|opcode
index|[
literal|3
index|]
struct|;
block|}
name|tic54x_insn
typedef|;
end_typedef

begin_enum
enum|enum
name|cpu_version
block|{
name|VNONE
init|=
literal|0
block|,
name|V541
init|=
literal|1
block|,
name|V542
init|=
literal|2
block|,
name|V543
init|=
literal|3
block|,
name|V545
init|=
literal|5
block|,
name|V548
init|=
literal|8
block|,
name|V549
init|=
literal|9
block|,
name|V545LP
init|=
literal|15
block|,
name|V546LP
init|=
literal|16
block|}
enum|;
end_enum

begin_enum
enum|enum
name|address_mode
block|{
name|c_mode
block|,
comment|/* 16-bit addresses.  */
name|far_mode
comment|/*>16-bit addresses.  */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|segT
name|stag_saved_seg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|subsegT
name|stag_saved_subseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";*#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At column zero only.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not permitted.  */
end_comment

begin_decl_stmt
name|int
name|emitting_long
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which indicate that this is a floating point constant.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to separate mantissa from exp in FP    nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_ADDRESS_MODE
value|(OPTION_MD_BASE)
end_define

begin_define
define|#
directive|define
name|OPTION_CPU_VERSION
value|(OPTION_ADDRESS_MODE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_COFF_VERSION
value|(OPTION_CPU_VERSION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STDERR_TO_FILE
value|(OPTION_COFF_VERSION + 1)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mfar-mode"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ADDRESS_MODE
block|}
block|,
block|{
literal|"mf"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ADDRESS_MODE
block|}
block|,
block|{
literal|"mcpu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU_VERSION
block|}
block|,
block|{
literal|"merrors-to-file"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_STDERR_TO_FILE
block|}
block|,
block|{
literal|"me"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_STDERR_TO_FILE
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|assembly_begun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addressing mode is not entirely implemented; the latest rev of the Other    assembler doesn't seem to make any distinction whatsoever; all relocations    are stored as extended relocatiosn.  Older versions used REL16 vs RELEXT16,    but now it seems all relocations are RELEXT16.  We use all RELEXT16.     The cpu version is kind of a waste of time as well.  There is one    instruction (RND) for LP devices only, and several for devices with    extended addressing only.  We include it for compatibility.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|address_mode
name|amode
init|=
name|c_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|cpu_version
name|cpu
init|=
name|VNONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Include string substitutions in listing?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|listing_sslist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Did we do subsym substitutions on the line?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|substitution_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last label seen.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|last_label_seen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This ensures that all new labels are unique.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_label_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|subsym_recurse_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prevent infinite recurse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|math_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Built-in math functions.  */
end_comment

begin_comment
comment|/* Allow maximum levels of macro nesting; level 0 is the main substitution    symbol table.  The other assembler only does 32 levels, so there!  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|subsym_hash
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of local labels so we can substitute them before GAS sees them    since macros use their own 'namespace' for local labels, use a separate hash     We do our own local label handling 'cuz it's subtly different from the    stock GAS handling.     We use our own macro nesting counter, since GAS overloads it when expanding    other things (like conditionals and repeat loops).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|local_label_hash
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of struct/union tags.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|stag_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|parop_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mmreg_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|cc_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|cc2_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|cc3_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|sbit_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|misc_symbol_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only word (et al.), align, or conditionals are allowed within    .struct/.union.  */
end_comment

begin_define
define|#
directive|define
name|ILLEGAL_WITHIN_STRUCT
parameter_list|()
define|\
value|do								\     if (current_stag != NULL)					\       { 							\ 	as_bad (_("pseudo-op illegal within .struct/.union"));	\ 	return;							\       }								\   while (0)
end_define

begin_decl_stmt
specifier|static
name|void
name|tic54x_emit_char
name|PARAMS
argument_list|(
operator|(
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|frag_prev
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|bit_offset_frag
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frag_bit_offset
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_asg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_eval
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stag_add_field_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stag
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|symbolS
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stag_add_field
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stag
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
expr|struct
name|stag
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_struct
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_endstruct
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_tag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_struct_field
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_remove_local_label
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_clear_local_labels
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_sect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_space
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_usect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|cpu_version
name|lookup_version
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_cpu
name|PARAMS
argument_list|(
operator|(
expr|enum
name|cpu_version
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_version
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_float_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_stringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_p2align
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_align_words
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_field
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic54x_initialized_section
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_clink
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_set_default_include
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_include
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_message
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_label
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_mmregs
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_loop
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_endloop
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_break
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_address_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_address_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_sblock
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_fclist
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_sslist
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_var
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic54x_mlib
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_symlen
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_symcmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_firstch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_lastch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_isdefed
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_ismember
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_iscons
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_isname
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_isreg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_structsz
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subsym_structacc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_ceil
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_cvi
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_floor
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_fmod
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_int
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_round
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_sgn
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_trunc
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_acos
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_asin
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_atan
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_atan2
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_cosh
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_cos
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_cvf
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_exp
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_fabs
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_ldexp
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_log10
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_log
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_max
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_min
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_pow
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_sin
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_sinh
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_sqrt
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_tan
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|math_tanh
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_accumulator
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
name|operands
index|[]
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_immediate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_absolute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_indirect
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_dual
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_mmreg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|opstruct
operator|*
operator|,
expr|enum
name|optype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|operands_match
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|,
name|int
operator|,
specifier|const
expr|enum
name|optype
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_dmad
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_address
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_indirect
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_integer
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_condition
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_cc3
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_arx
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_cc2
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encode_operand
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
expr|enum
name|optype
operator|,
expr|struct
name|opstruct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_insn
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_insn
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|optimize_insn
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic54x_parse_insn
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_line_shows_parallel
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic54x_parse_parallel_insn_firstline
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic54x_parse_parallel_insn_lastline
name|PARAMS
argument_list|(
operator|(
name|tic54x_insn
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subsym_get_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subsym_create_or_replace
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subsym_lookup
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subsym_substitute
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"C54x-specific command line  options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mfar-mode | -mf          Use extended addressing\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-mcpu=<CPU version>       Specify the CPU version\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-merrors-to-file<filename>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"-me<filename>            Redirect errors to a file\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a single character (upper octect is zero).  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_emit_char
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|c
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk backwards in the frag chain.  */
end_comment

begin_function
specifier|static
name|fragS
modifier|*
name|frag_prev
parameter_list|(
name|frag
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|seg
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
for|for
control|(
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragp
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
if|if
condition|(
name|fragp
operator|->
name|fr_next
operator|==
name|frag
condition|)
return|return
name|fragp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|fragS
modifier|*
name|bit_offset_frag
parameter_list|(
name|frag
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
while|while
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|frag
operator|->
name|fr_fix
operator|==
literal|0
operator|&&
name|frag
operator|->
name|fr_opcode
operator|==
name|NULL
operator|&&
name|frag
operator|->
name|tc_frag_data
operator|==
literal|0
condition|)
name|frag
operator|=
name|frag_prev
argument_list|(
name|frag
argument_list|,
name|seg
argument_list|)
expr_stmt|;
else|else
return|return
name|frag
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits allocated in the most recent word, or zero if    none. .field/.space/.bes may leave words partially allocated.  */
end_comment

begin_function
specifier|static
name|int
name|frag_bit_offset
parameter_list|(
name|frag
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|frag
operator|=
name|bit_offset_frag
argument_list|(
name|frag
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
return|return
name|frag
operator|->
name|fr_opcode
operator|!=
name|NULL
condition|?
operator|-
literal|1
else|:
name|frag
operator|->
name|tc_frag_data
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read an expression from a C string; returns a pointer past the end of the    expression.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_expression
parameter_list|(
name|str
parameter_list|,
name|exp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Save line pointer.  */
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|tmp
expr_stmt|;
comment|/* Restore line pointer.  */
return|return
name|s
return|;
comment|/* Return pointer to where parsing stopped.  */
block|}
end_function

begin_comment
comment|/* .asg "character-string"|character-string, symbol     .eval is the only pseudo-op allowed to perform arithmetic on substitution    symbols.  all other use of symbols defined with .asg are currently    unsupported.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_asg
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|quoted
init|=
operator|*
name|input_line_pointer
operator|==
literal|'"'
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
name|int
name|len
decl_stmt|;
name|str
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|)
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma and symbol expected for '.asg STRING, SYMBOL'"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"symbols assigned with .asg must begin with a letter"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|tmp
expr_stmt|;
name|subsym_create_or_replace
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .eval expression, symbol    There's something screwy about this.  The other assembler sometimes does and    sometimes doesn't substitute symbols defined with .eval.    We'll put the symbols into the subsym table as well as the normal symbol    table, since that's what works best.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_eval
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
name|valuestr
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|quoted
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|quoted
operator|=
operator|*
name|input_line_pointer
operator|==
literal|'"'
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|value
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unterminated string after absolute expression"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Comma and symbol expected for '.eval EXPR, SYMBOL'"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbols assigned with .eval must begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* The "other" assembler sometimes doesn't put .eval's in the subsym table      But since there's not written rule as to when, don't even bother trying      to match their behavior.  */
name|sprintf
argument_list|(
name|valuestr
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|valuestr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|valuestr
argument_list|)
expr_stmt|;
name|subsym_create_or_replace
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .bss symbol, size [, [blocking flag] [, alignment flag]     alignment is to a longword boundary; blocking is to 128-word boundary.     1) if there is a hole in memory, this directive should attempt to fill it       (not yet implemented).     2) if the blocking flag is not set, allocate at the current SPC       otherwise, check to see if the current SPC plus the space to be       allocated crosses the page boundary (128 words).       if there's not enough space, create a hole and align with the next page       boundary.       (not yet implemented).  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_bss
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|words
decl_stmt|;
name|segT
name|current_seg
decl_stmt|;
name|subsegT
name|current_subseg
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|block
init|=
literal|0
decl_stmt|;
name|int
name|align
init|=
literal|0
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|current_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* Save current seg.  */
name|current_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Save current subseg.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|".bss size argument missing\n"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|words
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|words
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|".bss size %d< 0!"
argument_list|,
name|words
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
comment|/* The blocking flag may be missing.  */
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|block
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|block
operator|=
name|align
operator|=
literal|0
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
call|(
name|offsetT
call|)
argument_list|(
name|words
operator|*
name|OCTETS_PER_BYTE
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Fill char.  */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
comment|/* The symbol may already have been created with a preceding      ".globl" directive -- be careful not to step on storage class      in that case.  Otherwise, set it to static.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
comment|/* s_align eats end of line; restore it */
name|s_align_bytes
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|block
condition|)
name|bss_section
operator|->
name|flags
operator||=
name|SEC_TIC54X_BLOCK
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* Restore current seg.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stag_add_field_symbols
parameter_list|(
name|stag
parameter_list|,
name|path
parameter_list|,
name|base_offset
parameter_list|,
name|rootsym
parameter_list|,
name|root_stag_name
parameter_list|)
name|struct
name|stag
modifier|*
name|stag
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|bfd_vma
name|base_offset
decl_stmt|;
name|symbolS
modifier|*
name|rootsym
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_stag_name
decl_stmt|;
block|{
name|char
name|prefix
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|stag_field
modifier|*
name|field
init|=
name|stag
operator|->
name|field
decl_stmt|;
comment|/* Construct a symbol for every field contained within this structure      including fields within structure fields.  */
name|strcpy
argument_list|(
name|prefix
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|path
condition|)
name|strcat
argument_list|(
name|prefix
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|field
operator|->
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|field
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootsym
operator|==
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|field
operator|->
name|stag
condition|?
name|field
operator|->
name|offset
else|:
call|(
name|valueT
call|)
argument_list|(
name|base_offset
operator|+
name|field
operator|->
name|offset
argument_list|)
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|replacement
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|stag
operator|->
name|name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|replacement
argument_list|,
name|S_GET_NAME
argument_list|(
name|rootsym
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|replacement
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|replacement
argument_list|,
name|root_stag_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|replacement
argument_list|,
name|name
operator|+
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|rootsym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
block|}
comment|/* Recurse if the field is a structure. 	 Note the field offset is relative to the outermost struct.  */
if|if
condition|(
name|field
operator|->
name|stag
operator|!=
name|NULL
condition|)
name|stag_add_field_symbols
argument_list|(
name|field
operator|->
name|stag
argument_list|,
name|name
argument_list|,
name|field
operator|->
name|offset
argument_list|,
name|rootsym
argument_list|,
name|root_stag_name
argument_list|)
expr_stmt|;
name|field
operator|=
name|field
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keep track of stag fields so that when structures are nested we can add the    complete dereferencing symbols to the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|stag_add_field
parameter_list|(
name|parent
parameter_list|,
name|name
parameter_list|,
name|offset
parameter_list|,
name|stag
parameter_list|)
name|struct
name|stag
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|stag
modifier|*
name|stag
decl_stmt|;
block|{
name|struct
name|stag_field
modifier|*
name|sfield
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stag_field
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|sfield
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sfield
argument_list|)
argument_list|)
expr_stmt|;
name|sfield
operator|->
name|name
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sfield
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|sfield
operator|->
name|bitfield_offset
operator|=
name|parent
operator|->
name|current_bitfield_offset
expr_stmt|;
name|sfield
operator|->
name|stag
operator|=
name|stag
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|field
operator|==
name|NULL
condition|)
name|parent
operator|->
name|field
operator|=
name|sfield
expr_stmt|;
else|else
block|{
name|struct
name|stag_field
modifier|*
name|sf
init|=
name|parent
operator|->
name|field
decl_stmt|;
while|while
condition|(
name|sf
operator|->
name|next
operator|!=
name|NULL
condition|)
name|sf
operator|=
name|sf
operator|->
name|next
expr_stmt|;
name|sf
operator|->
name|next
operator|=
name|sfield
expr_stmt|;
block|}
comment|/* Only create a symbol for this field if the parent has no name.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|".fake"
argument_list|,
name|parent
operator|->
name|name
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
decl_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* [STAG] .struct       [OFFSET]    Start defining structure offsets (symbols in absolute section).  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_struct
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|int
name|start_offset
init|=
literal|0
decl_stmt|;
name|int
name|is_union
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|current_stag
condition|)
block|{
comment|/* Starting a new struct, switch to absolute section.  */
name|stag_saved_seg
operator|=
name|now_seg
expr_stmt|;
name|stag_saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|absolute_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Align the current pointer.  */
elseif|else
if|if
condition|(
name|current_stag
operator|->
name|current_bitfield_offset
operator|!=
literal|0
condition|)
block|{
operator|++
name|abs_section_offset
expr_stmt|;
name|current_stag
operator|->
name|current_bitfield_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Offset expression is only meaningful for global .structs.  */
if|if
condition|(
operator|!
name|is_union
condition|)
block|{
comment|/* Offset is ignored in inner structs.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|start_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|start_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_stag
condition|)
block|{
comment|/* Nesting, link to outer one.  */
name|current_stag
operator|->
name|inner
operator|=
operator|(
expr|struct
name|stag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stag
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|current_stag
operator|->
name|inner
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stag
argument_list|)
argument_list|)
expr_stmt|;
name|current_stag
operator|->
name|inner
operator|->
name|outer
operator|=
name|current_stag
expr_stmt|;
name|current_stag
operator|=
name|current_stag
operator|->
name|inner
expr_stmt|;
if|if
condition|(
name|start_offset
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Offset on nested structures is ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|start_offset
operator|=
name|abs_section_offset
expr_stmt|;
block|}
else|else
block|{
name|current_stag
operator|=
operator|(
expr|struct
name|stag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stag
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|current_stag
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stag
argument_list|)
argument_list|)
expr_stmt|;
name|abs_section_offset
operator|=
name|start_offset
expr_stmt|;
block|}
name|current_stag
operator|->
name|is_union
operator|=
name|is_union
expr_stmt|;
if|if
condition|(
name|line_label
operator|==
name|NULL
condition|)
block|{
specifier|static
name|int
name|struct_count
init|=
literal|0
decl_stmt|;
name|char
name|fake
index|[]
init|=
literal|".fake_stagNNNNNNN"
decl_stmt|;
name|sprintf
argument_list|(
name|fake
argument_list|,
literal|".fake_stag%d"
argument_list|,
name|struct_count
operator|++
argument_list|)
expr_stmt|;
name|current_stag
operator|->
name|sym
operator|=
name|symbol_new
argument_list|(
name|fake
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|abs_section_offset
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|label
index|[
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|label
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|current_stag
operator|->
name|sym
operator|=
name|symbol_new
argument_list|(
name|label
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|abs_section_offset
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
name|current_stag
operator|->
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
expr_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
expr_stmt|;
comment|/* Nested .structs don't go into the symbol table.  */
if|if
condition|(
name|current_stag
operator|->
name|outer
operator|==
name|NULL
condition|)
name|symbol_table_insert
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [LABEL] .endstruct    finish defining structure offsets; optional LABEL's value will be the size    of the structure.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_endstruct
parameter_list|(
name|is_union
parameter_list|)
name|int
name|is_union
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
operator|!
name|strncmp
argument_list|(
name|current_stag
operator|->
name|name
argument_list|,
literal|".fake"
argument_list|,
literal|5
argument_list|)
condition|?
literal|""
else|:
name|current_stag
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|current_stag
operator|||
name|current_stag
operator|->
name|is_union
operator|!=
name|is_union
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".end%s without preceding .%s"
argument_list|)
argument_list|,
name|is_union
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|is_union
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Align end of structures.  */
if|if
condition|(
name|current_stag
operator|->
name|current_bitfield_offset
condition|)
block|{
operator|++
name|abs_section_offset
expr_stmt|;
name|current_stag
operator|->
name|current_bitfield_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_stag
operator|->
name|is_union
condition|)
name|size
operator|=
name|current_stag
operator|->
name|size
expr_stmt|;
else|else
name|size
operator|=
name|abs_section_offset
operator|-
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|line_label
argument_list|)
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Union size has already been calculated.  */
if|if
condition|(
operator|!
name|current_stag
operator|->
name|is_union
condition|)
name|current_stag
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* Nested .structs don't get put in the stag table.  */
if|if
condition|(
name|current_stag
operator|->
name|outer
operator|==
name|NULL
condition|)
block|{
name|hash_insert
argument_list|(
name|stag_hash
argument_list|,
name|current_stag
operator|->
name|name
argument_list|,
name|current_stag
argument_list|)
expr_stmt|;
name|stag_add_field_symbols
argument_list|(
name|current_stag
argument_list|,
name|path
argument_list|,
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|current_stag
operator|=
name|current_stag
operator|->
name|outer
expr_stmt|;
comment|/* If this is a nested .struct/.union, add it as a field to the enclosing      one.  otherwise, restore the section we were in.  */
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
block|{
name|stag_add_field
argument_list|(
name|current_stag
argument_list|,
name|current_stag
operator|->
name|inner
operator|->
name|name
argument_list|,
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|inner
operator|->
name|sym
argument_list|)
argument_list|,
name|current_stag
operator|->
name|inner
argument_list|)
expr_stmt|;
block|}
else|else
name|subseg_set
argument_list|(
name|stag_saved_seg
argument_list|,
name|stag_saved_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [LABEL]      .tag    STAG    Reference a structure within a structure, as a sized field with an optional    label.    If used outside of a .struct/.endstruct, overlays the given structure    format on the existing allocated space.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_tag
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
name|struct
name|stag
modifier|*
name|stag
init|=
operator|(
expr|struct
name|stag
operator|*
operator|)
name|hash_find
argument_list|(
name|stag_hash
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stag
condition|)
block|{
if|if
condition|(
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized struct/union tag '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".tag requires a structure tag"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|line_label
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Label required for .tag"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
name|label
index|[
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|label
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
name|stag_add_field
argument_list|(
name|current_stag
argument_list|,
name|label
argument_list|,
name|abs_section_offset
operator|-
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
argument_list|,
name|stag
argument_list|)
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|sym
init|=
name|symbol_find
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".tag target '%s' undefined"
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|stag_add_field_symbols
argument_list|(
name|stag
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|stag
operator|->
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|stag
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bump by the struct size, but only if we're within a .struct section.  */
if|if
condition|(
name|current_stag
operator|!=
name|NULL
operator|&&
operator|!
name|current_stag
operator|->
name|is_union
condition|)
name|abs_section_offset
operator|+=
name|stag
operator|->
name|size
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle all .byte, .char, .double, .field, .float, .half, .int, .long,    .short, .string, .ubyte, .uchar, .uhalf, .uint, .ulong, .ushort, .uword,    and .word.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_struct_field
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|int
name|new_bitfield_offset
init|=
literal|0
decl_stmt|;
name|int
name|field_align
init|=
name|current_stag
operator|->
name|current_bitfield_offset
operator|!=
literal|0
decl_stmt|;
name|int
name|longword_align
init|=
literal|0
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'*'
case|:
comment|/* String.  */
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|longword_align
operator|=
literal|1
expr_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* Bitfield.  */
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
operator|||
name|count
operator|>
literal|32
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".field count '%d' out of range (1<= X<= 32)"
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_stag
operator|->
name|current_bitfield_offset
operator|+
name|count
operator|>
literal|16
condition|)
block|{
comment|/* Set the appropriate size and new field offset.  */
if|if
condition|(
name|count
operator|==
literal|32
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|16
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|new_bitfield_offset
operator|=
name|count
operator|-
literal|16
expr_stmt|;
block|}
else|else
name|new_bitfield_offset
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
name|field_align
operator|=
literal|0
expr_stmt|;
name|new_bitfield_offset
operator|=
name|current_stag
operator|->
name|current_bitfield_offset
operator|+
name|count
expr_stmt|;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized field type '%c'"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|field_align
condition|)
block|{
comment|/* Align to the actual starting position of the field.  */
name|current_stag
operator|->
name|current_bitfield_offset
operator|=
literal|0
expr_stmt|;
operator|++
name|abs_section_offset
expr_stmt|;
block|}
comment|/* Align to longword boundary.  */
if|if
condition|(
name|longword_align
operator|&&
operator|(
name|abs_section_offset
operator|&
literal|0x1
operator|)
condition|)
operator|++
name|abs_section_offset
expr_stmt|;
if|if
condition|(
name|line_label
operator|==
name|NULL
condition|)
block|{
specifier|static
name|int
name|fieldno
init|=
literal|0
decl_stmt|;
name|char
name|fake
index|[]
init|=
literal|".fake_fieldNNNNN"
decl_stmt|;
name|sprintf
argument_list|(
name|fake
argument_list|,
literal|".fake_field%d"
argument_list|,
name|fieldno
operator|++
argument_list|)
expr_stmt|;
name|stag_add_field
argument_list|(
name|current_stag
argument_list|,
name|fake
argument_list|,
name|abs_section_offset
operator|-
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|label
index|[
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
operator|+
literal|1
argument_list|)
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|label
argument_list|,
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|stag_add_field
argument_list|(
name|current_stag
argument_list|,
name|label
argument_list|,
name|abs_section_offset
operator|-
name|S_GET_VALUE
argument_list|(
name|current_stag
operator|->
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_stag
operator|->
name|is_union
condition|)
block|{
comment|/* Note we treat the element as if it were an array of COUNT.  */
if|if
condition|(
name|current_stag
operator|->
name|size
operator|<
operator|(
name|unsigned
operator|)
name|size
operator|*
name|count
condition|)
name|current_stag
operator|->
name|size
operator|=
name|size
operator|*
name|count
expr_stmt|;
block|}
else|else
block|{
name|abs_section_offset
operator|+=
operator|(
name|unsigned
operator|)
name|size
operator|*
name|count
expr_stmt|;
name|current_stag
operator|->
name|current_bitfield_offset
operator|=
name|new_bitfield_offset
expr_stmt|;
block|}
name|line_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .byte, .word. .int, .long and all variants.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_cons
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|octets
decl_stmt|;
comment|/* If we're within a .struct construct, don't actually allocate space.  */
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
block|{
name|tic54x_struct_field
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|generate_lineno_debug
argument_list|()
expr_stmt|;
comment|/* Align long words to long word boundaries (4 octets).  */
if|if
condition|(
name|type
operator|==
literal|'l'
operator|||
name|type
operator|==
literal|'L'
condition|)
block|{
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If there's a label, assign it to the first allocated word.  */
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'x'
case|:
name|octets
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|octets
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|octets
operator|=
literal|2
expr_stmt|;
break|break;
block|}
do|do
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
name|tic54x_emit_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|input_line_pointer
operator|=
name|parse_expression
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offsetT
name|value
init|=
name|exp
operator|.
name|X_add_number
decl_stmt|;
comment|/* Truncate overflows.  */
switch|switch
condition|(
name|octets
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|>
literal|0xFF
operator|)
operator|||
operator|(
name|value
operator|<
literal|0
operator|&&
name|value
operator|<
operator|-
literal|0x100
operator|)
condition|)
name|as_warn
argument_list|(
literal|"Overflow in expression, truncated to 8 bits"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|>
literal|0xFFFF
operator|)
operator|||
operator|(
name|value
operator|<
literal|0
operator|&&
name|value
operator|<
operator|-
literal|0x10000
operator|)
condition|)
name|as_warn
argument_list|(
literal|"Overflow in expression, truncated to 16 bits"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|octets
operator|<
literal|2
condition|)
block|{
comment|/* Disallow .byte with a non constant expression that will 		 require relocation.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Relocatable values require at least WORD storage"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|amode
operator|==
name|c_mode
operator|&&
name|octets
operator|==
literal|4
condition|)
block|{
comment|/* FIXME -- at one point TI tools used to output REL16 		 relocations, but I don't think the latest tools do at all 		 The current tools output extended relocations regardless of 		 the addressing mode (I actually think that ".c_mode" is 		 totally ignored in the latest tools).  */
name|amode
operator|=
name|far_mode
expr_stmt|;
name|emitting_long
operator|=
literal|1
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emitting_long
operator|=
literal|0
expr_stmt|;
name|amode
operator|=
name|c_mode
expr_stmt|;
block|}
else|else
block|{
name|emitting_long
operator|=
name|octets
operator|==
literal|4
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|octets
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
name|octets
argument_list|)
expr_stmt|;
name|emitting_long
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .global<symbol>[,...,<symbolN>]    .def<symbol>[,...,<symbolN>]    .ref<symbol>[,...,<symbolN>]     These all identify global symbols.     .def means the symbol is defined in the current module and can be accessed    by other files.  The symbol should be placed in the symbol table.     .ref means the symbol is used in the current module but defined in another    module.  The linker is to resolve this symbol's definition at link time.     .global should act as a .ref or .def, as needed.     global, def and ref all have symbol storage classes of C_EXT.     I can't identify any difference in how the "other" c54x assembler treats    these, so we ignore the type here.  */
end_comment

begin_function
name|void
name|tic54x_global
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|'r'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Use of .def/.ref is deprecated.  Use .global instead"
argument_list|)
argument_list|)
expr_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the symbol from the local label hash lookup.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_remove_local_label
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|PTR
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|PTR
modifier|*
name|elem
init|=
name|hash_delete
argument_list|(
name|local_label_hash
index|[
name|macro_level
index|]
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset all local labels.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_clear_local_labels
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|hash_traverse
argument_list|(
name|local_label_hash
index|[
name|macro_level
index|]
argument_list|,
name|tic54x_remove_local_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .text    .data    .sect "section name"     Initialized section    make sure local labels get cleared when changing sections     ARG is 't' for text, 'd' for data, or '*' for a named section     For compatibility, '*' sections are SEC_CODE if instructions are    encountered, or SEC_DATA if not. */
end_comment

begin_function
specifier|static
name|void
name|tic54x_sect
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
comment|/* Local labels are cleared when changing sections.  */
name|tic54x_clear_local_labels
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|'t'
condition|)
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
literal|'d'
condition|)
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* If there are quotes, remove them.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|name
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|len
operator|+
literal|10
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|len
operator|+
literal|10
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure all named initialized sections flagged properly.  If we          encounter instructions, we'll flag it with SEC_CODE as well.  */
name|strcat
argument_list|(
name|name
argument_list|,
literal|",\"w\"\n"
argument_list|)
expr_stmt|;
name|input_scrub_insert_line
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|obj_coff_section
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If there was a line label, make sure that it gets assigned the proper 	 section.  This is for compatibility, even though the actual behavior 	 is not explicitly defined.  For consistency, we make .sect behave 	 like .usect, since that is probably what people expect.  */
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* [symbol] .space space_in_bits    [symbol] .bes space_in_bits    BES puts the symbol at the *last* word allocated     cribbed from s_space.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_space
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|int
name|octets
init|=
literal|0
decl_stmt|;
name|long
name|words
decl_stmt|;
name|int
name|bits_per_byte
init|=
operator|(
name|OCTETS_PER_BYTE
operator|*
literal|8
operator|)
decl_stmt|;
name|int
name|bit_offset
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|label
init|=
name|line_label
decl_stmt|;
name|int
name|bes
init|=
name|arg
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Read the bit count.  */
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* Some expressions are unresolvable until later in the assembly pass;      postpone until relaxation/fixup.  we also have to postpone if a previous      partial allocation has not been completed yet.  */
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|frag_bit_offset
argument_list|(
name|frag_now
argument_list|,
name|now_seg
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|bit_info
modifier|*
name|bi
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bit_info
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|bi
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|bi
operator|->
name|type
operator|=
name|bes
expr_stmt|;
name|bi
operator|->
name|sym
operator|=
name|label
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|65536
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Reduce the required size by any bit offsets currently left over      from a previous .space/.bes/.field directive.  */
name|bit_offset
operator|=
name|frag_now
operator|->
name|tc_frag_data
expr_stmt|;
if|if
condition|(
name|bit_offset
operator|!=
literal|0
operator|&&
name|bit_offset
operator|<
literal|16
condition|)
block|{
name|int
name|spare_bits
init|=
name|bits_per_byte
operator|-
name|bit_offset
decl_stmt|;
if|if
condition|(
name|spare_bits
operator|>=
name|exp
operator|.
name|X_add_number
condition|)
block|{
comment|/* Don't have to do anything; sufficient bits have already been 	     allocated; just point the label to the right place.  */
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
block|}
name|frag_now
operator|->
name|tc_frag_data
operator|+=
name|exp
operator|.
name|X_add_number
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|exp
operator|.
name|X_add_number
operator|-=
name|spare_bits
expr_stmt|;
comment|/* Set the label to point to the first word allocated, which in this 	 case is the previous word, which was only partially filled.  */
if|if
condition|(
operator|!
name|bes
operator|&&
name|label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Convert bits to bytes/words and octets, rounding up.  */
name|words
operator|=
operator|(
operator|(
name|exp
operator|.
name|X_add_number
operator|+
name|bits_per_byte
operator|-
literal|1
operator|)
operator|/
name|bits_per_byte
operator|)
expr_stmt|;
comment|/* How many do we have left over?  */
name|bit_offset
operator|=
name|exp
operator|.
name|X_add_number
operator|%
name|bits_per_byte
expr_stmt|;
name|octets
operator|=
name|words
operator|*
name|OCTETS_PER_BYTE
expr_stmt|;
if|if
condition|(
name|octets
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".space/.bes repeat count is negative, ignored"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
elseif|else
if|if
condition|(
name|octets
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".space/.bes repeat count is zero, ignored"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* If we are in the absolute section, just bump the offset.  */
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|abs_section_offset
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|bes
operator|&&
name|label
operator|!=
name|NULL
condition|)
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|abs_section_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|=
name|bit_offset
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|octets
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Make note of how many bits of this word we've allocated so far.  */
name|frag_now
operator|->
name|tc_frag_data
operator|=
name|bit_offset
expr_stmt|;
comment|/* .bes puts label at *last* word allocated.  */
if|if
condition|(
name|bes
operator|&&
name|label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|getout
label|:
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [symbol] .usect "section-name", size-in-words 		   [, [blocking-flag] [, alignment-flag]]     Uninitialized section.    Non-zero blocking means that if the section would cross a page (128-word)    boundary, it will be page-aligned.    Non-zero alignment aligns on a longword boundary.     Has no effect on the current section.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_usect
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|int
name|size
decl_stmt|,
name|blocking_flag
decl_stmt|,
name|alignment_flag
decl_stmt|;
name|segT
name|current_seg
decl_stmt|;
name|subsegT
name|current_subseg
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|current_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* Save current seg.  */
name|current_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Save current subseg.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip null symbol terminator.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing size argument"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* Read a possibly present third argument (blocking flag).  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|blocking_flag
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|blocking_flag
operator|=
literal|0
expr_stmt|;
comment|/* Read a possibly present fourth argument (alignment flag).  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|alignment_flag
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|alignment_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|blocking_flag
operator|=
name|alignment_flag
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator||
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|alignment_flag
condition|)
block|{
comment|/* s_align eats end of line; restore it.  */
name|s_align_bytes
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set scl to label, since that's what TI does.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
comment|/* Uninitialized data.  */
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|line_label
argument_list|,
name|size
operator|*
name|OCTETS_PER_BYTE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blocking_flag
condition|)
name|flags
operator||=
name|SEC_TIC54X_BLOCK
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Error setting flags for \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* Restore current seg.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|cpu_version
name|lookup_version
parameter_list|(
name|ver
parameter_list|)
specifier|const
name|char
modifier|*
name|ver
decl_stmt|;
block|{
name|enum
name|cpu_version
name|version
init|=
name|VNONE
decl_stmt|;
if|if
condition|(
name|ver
index|[
literal|0
index|]
operator|==
literal|'5'
operator|&&
name|ver
index|[
literal|1
index|]
operator|==
literal|'4'
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ver
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|ver
index|[
literal|2
index|]
operator|==
literal|'1'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'2'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'3'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'5'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'8'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'9'
operator|)
condition|)
name|version
operator|=
name|ver
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|ver
argument_list|)
operator|==
literal|5
operator|&&
name|TOUPPER
argument_list|(
name|ver
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'L'
operator|&&
name|TOUPPER
argument_list|(
name|ver
index|[
literal|4
index|]
argument_list|)
operator|==
literal|'P'
operator|&&
operator|(
name|ver
index|[
literal|2
index|]
operator|==
literal|'5'
operator|||
name|ver
index|[
literal|2
index|]
operator|==
literal|'6'
operator|)
condition|)
name|version
operator|=
name|ver
index|[
literal|2
index|]
operator|-
literal|'0'
operator|+
literal|10
expr_stmt|;
block|}
return|return
name|version
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cpu
parameter_list|(
name|version
parameter_list|)
name|enum
name|cpu_version
name|version
decl_stmt|;
block|{
name|cpu
operator|=
name|version
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|V545LP
operator|||
name|version
operator|==
name|V546LP
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_new
argument_list|(
literal|"__allow_lp"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
decl_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .version cpu-version    cpu-version may be one of the following:    541    542    543    545    545LP    546LP    548    549     This is for compatibility only.  It currently has no affect on assembly.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_needs_set
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tic54x_version
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|cpu_version
name|version
init|=
name|VNONE
decl_stmt|;
name|enum
name|cpu_version
name|old_version
init|=
name|cpu
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|ver
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|ver
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
name|version
operator|=
name|lookup_version
argument_list|(
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|!=
name|VNONE
operator|&&
name|cpu
operator|!=
name|version
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"CPU version has already been set"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|VNONE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized version '%s'"
argument_list|)
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|assembly_begun
operator|&&
name|version
operator|!=
name|old_version
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Changing of CPU version on the fly not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|set_cpu
argument_list|(
name|version
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 'f' = float, 'x' = xfloat, 'd' = double, 'l' = ldouble.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_float_cons
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|current_stag
operator|!=
literal|0
condition|)
name|tic54x_struct_field
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Align to long word boundary (4 octets) unless it's ".xfloat".  */
if|if
condition|(
name|type
operator|!=
literal|'x'
condition|)
block|{
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If there's a label, assign it to the first allocated word.  */
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|float_cons
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The argument is capitalized if it should be zero-terminated    's' is normal string with upper 8-bits zero-filled, 'p' is packed.    Code copied from stringer, and slightly modified so that strings are packed    and encoded into the correct octets.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_stringer
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|append_zero
init|=
name|type
operator|==
literal|'S'
operator|||
name|type
operator|==
literal|'P'
decl_stmt|;
name|int
name|packed
init|=
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'P'
decl_stmt|;
name|int
name|last_char
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Packed strings need two bytes at a time to encode.  */
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
block|{
name|tic54x_struct_field
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop.  */
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
default|default:
block|{
name|unsigned
name|short
name|value
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* -> 1st char of string.  */
name|start
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|packed
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Packed strings are filled MS octet first.  */
if|if
condition|(
name|last_char
operator|==
operator|-
literal|1
condition|)
name|last_char
operator|=
name|c
expr_stmt|;
else|else
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|last_char
argument_list|)
expr_stmt|;
name|last_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
if|if
condition|(
name|packed
operator|&&
name|last_char
operator|!=
operator|-
literal|1
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|last_char
argument_list|)
expr_stmt|;
name|last_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
break|break;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|c
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
comment|/* Finish up any leftover packed string.  */
if|if
condition|(
name|packed
operator|&&
name|last_char
operator|!=
operator|-
literal|1
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|last_char
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic54x_p2align
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"p2align not supported on this target"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic54x_align_words
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
comment|/* Only ".align" with no argument is allowed within .struct/.union.  */
name|int
name|count
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|==
literal|2
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Argument to .even ignored"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|current_stag
operator|!=
name|NULL
operator|&&
name|arg
operator|==
literal|128
condition|)
block|{
if|if
condition|(
name|current_stag
operator|->
name|current_bitfield_offset
operator|!=
literal|0
condition|)
block|{
name|current_stag
operator|->
name|current_bitfield_offset
operator|=
literal|0
expr_stmt|;
operator|++
name|abs_section_offset
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|s_align_bytes
argument_list|(
name|count
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize multiple-bit fields withing a single word of memory.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_field
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|size
init|=
literal|16
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|valueT
name|value
decl_stmt|;
name|symbolS
modifier|*
name|label
init|=
name|line_label
decl_stmt|;
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
block|{
name|tic54x_struct_field
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|=
name|parse_expression
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|32
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid field size, must be from 1 to 32"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* Truncate values to the field width.  */
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* If the expression value is relocatable, the field size *must*          be 16.  */
if|if
condition|(
name|size
operator|!=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field size must be 16 when value is relocatable"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|frag_now
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|fmask
init|=
operator|(
name|size
operator|==
literal|32
operator|)
condition|?
literal|0xFFFFFFFF
else|:
operator|(
literal|1ul
operator|<<
name|size
operator|)
operator|-
literal|1
decl_stmt|;
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|&=
name|fmask
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"field value truncated"
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* Bits are stored MS first.  */
while|while
condition|(
name|size
operator|>=
literal|16
condition|)
block|{
name|frag_now
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|value
operator|>>
operator|(
name|size
operator|-
literal|16
operator|)
operator|)
operator|&
literal|0xFFFF
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|bit_offset
init|=
name|frag_bit_offset
argument_list|(
name|frag_now
argument_list|,
name|now_seg
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|alloc_frag
init|=
name|bit_offset_frag
argument_list|(
name|frag_now
argument_list|,
name|now_seg
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|bit_info
modifier|*
name|bi
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bit_info
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We don't know the previous offset at this time, so store the 		 info we need and figure it out later.  */
name|expressionS
name|size_exp
decl_stmt|;
name|size_exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|size_exp
operator|.
name|X_add_number
operator|=
name|size
expr_stmt|;
name|bi
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|bi
operator|->
name|type
operator|=
name|TYPE_FIELD
expr_stmt|;
name|bi
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|make_expr_symbol
argument_list|(
operator|&
name|size_exp
argument_list|)
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
elseif|else
if|if
condition|(
name|bit_offset
operator|==
literal|0
operator|||
name|bit_offset
operator|+
name|size
operator|>
literal|16
condition|)
block|{
comment|/* Align a new field.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
name|alloc_frag
operator|=
name|frag_now
expr_stmt|;
block|}
else|else
block|{
comment|/* Put the new value entirely within the existing one.  */
name|p
operator|=
name|alloc_frag
operator|==
name|frag_now
condition|?
name|frag_now
operator|->
name|fr_literal
operator|+
name|frag_now_fix_octets
argument_list|()
operator|-
literal|2
else|:
name|alloc_frag
operator|->
name|fr_literal
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|alloc_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_frag
operator|==
name|frag_now
condition|)
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|frag_now_fix
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|value
operator|<<=
literal|16
operator|-
name|alloc_frag
operator|->
name|tc_frag_data
operator|-
name|size
expr_stmt|;
comment|/* OR in existing value.  */
if|if
condition|(
name|alloc_frag
operator|->
name|tc_frag_data
condition|)
name|value
operator||=
operator|(
operator|(
name|unsigned
name|short
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|0
index|]
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|alloc_frag
operator|->
name|tc_frag_data
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|alloc_frag
operator|->
name|tc_frag_data
operator|==
literal|16
condition|)
name|alloc_frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|getout
label|:
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ideally, we want to check SEC_LOAD and SEC_HAS_CONTENTS, but those aren't    available yet.  seg_info ()->bss is the next best thing.  */
end_comment

begin_function
specifier|static
name|int
name|tic54x_initialized_section
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
return|return
operator|!
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|bss
return|;
block|}
end_function

begin_comment
comment|/* .clink ["section name"]     Marks the section as conditionally linked (link only if contents are    referenced elsewhere.    Without a name, refers to the current initialized section.    Name is required for uninitialized sections.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_clink
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segT
name|seg
init|=
name|now_seg
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|char
modifier|*
name|section_name
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|seg
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized section '%s'"
argument_list|)
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tic54x_initialized_section
argument_list|(
name|seg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Current section is unitialized, "
literal|"section name required for .clink"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|seg
operator|->
name|flags
operator||=
name|SEC_TIC54X_CLINK
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the default include directory to be the current source file's    directory, instead of the current working directory.  If DOT is non-zero,    set to "." instead.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_set_default_include
parameter_list|(
name|dot
parameter_list|)
name|int
name|dot
decl_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
literal|"."
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dot
condition|)
block|{
name|char
modifier|*
name|curfile
decl_stmt|;
name|unsigned
name|lineno
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|curfile
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|dir
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|curfile
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|tmp
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_dir_count
operator|==
literal|0
condition|)
block|{
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
name|include_dir_count
operator|=
literal|1
expr_stmt|;
block|}
name|include_dirs
index|[
literal|0
index|]
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|include_dir_maxlen
condition|)
name|include_dir_maxlen
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|include_dirs
operator|!=
name|NULL
condition|)
name|include_dirs
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .include "filename" | filename    .copy    "filename" | filename     FIXME 'include' file should be omitted from any output listing,      'copy' should be included in any output listing    FIXME -- prevent any included files from changing listing (compat only)    FIXME -- need to include source file directory in search path; what's a       good way to do this?     Entering/exiting included/copied file clears all local labels.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_include
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|newblock
index|[]
init|=
literal|" .newblock\n"
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|;
name|int
name|len
decl_stmt|,
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|filename
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|filename
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Insert a partial line with the filename (for the sake of s_include)      and a .newblock.      The included file will be inserted before the newblock, so that the      newblock is executed after the included file is processed.  */
name|input
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|newblock
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|input
argument_list|,
literal|"\"%s\"\n%s"
argument_list|,
name|filename
argument_list|,
name|newblock
argument_list|)
expr_stmt|;
name|input_scrub_insert_line
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|tic54x_clear_local_labels
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tic54x_set_default_include
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|s_include
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic54x_message
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
name|msg
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|msg
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'m'
case|:
name|as_tsktsk
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|as_warn
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .label<symbol>    Define a special symbol that refers to the loadtime address rather than the    runtime address within the current section.     This symbol gets a special storage class so that when it is resolved, it is    resolved relative to the load address (lma) of the section rather than the    run address (vma).  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_label
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|colon
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STATLAB
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .mmregs    Install all memory-mapped register names into the symbol table as    absolute local symbols.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_mmregs
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|mmregs
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_new
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|sym
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
decl_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .loop [count]    Count defaults to 1024.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_loop
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|count
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|do_repeat
argument_list|(
name|count
argument_list|,
literal|"LOOP"
argument_list|,
literal|"ENDLOOP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Normally, endloop gets eaten by the preceding loop.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_endloop
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ENDLOOP without corresponding LOOP"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .break [condition].  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_break
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|cond
init|=
literal|1
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|cond
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|end_repeat
argument_list|(
name|substitution_line
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_address_mode
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|amode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|far_mode
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_new
argument_list|(
literal|"__allow_far"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
decl_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|address_mode_needs_set
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tic54x_address_mode
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|assembly_begun
operator|&&
name|amode
operator|!=
operator|(
name|unsigned
operator|)
name|mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Mixing of normal and extended addressing not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mode
operator|==
name|far_mode
operator|&&
name|cpu
operator|!=
name|VNONE
operator|&&
name|cpu
operator|!=
name|V548
operator|&&
name|cpu
operator|!=
name|V549
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Extended addressing not supported on the specified CPU"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|set_address_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .sblock "section"|section [,...,"section"|section]    Designate initialized sections for blocking.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_sblock
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|c
init|=
literal|','
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|segT
name|seg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|int
name|len
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|section_name
init|=
name|input_line_pointer
decl_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|section_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
name|seg
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized section '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|tic54x_initialized_section
argument_list|(
name|seg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".sblock may be used for initialized sections only"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|seg
operator|->
name|flags
operator||=
name|SEC_TIC54X_BLOCK
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
name|c
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* symbol .set value    symbol .equ value     value must be defined externals; no forward-referencing allowed    symbols assigned with .set/.equ may not be redefined.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_set
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line_label
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol missing for .set/.equ"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|xstrdup
argument_list|(
name|S_GET_NAME
argument_list|(
name|line_label
argument_list|)
argument_list|)
expr_stmt|;
name|line_label
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|absolute_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_INT
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .fclist    .fcnolist    List false conditional blocks.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_fclist
parameter_list|(
name|show
parameter_list|)
name|int
name|show
decl_stmt|;
block|{
if|if
condition|(
name|show
condition|)
name|listing
operator|&=
operator|~
name|LISTING_NOCOND
expr_stmt|;
else|else
name|listing
operator||=
name|LISTING_NOCOND
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic54x_sslist
parameter_list|(
name|show
parameter_list|)
name|int
name|show
decl_stmt|;
block|{
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
name|listing_sslist
operator|=
name|show
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .var SYM[,...,SYMN]    Define a substitution string to be local to a macro.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_var
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|char
name|empty
index|[]
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
if|if
condition|(
name|macro_level
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".var may only be used within a macro definition"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Substitution symbols must begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* .var symbols start out with a null string.  */
name|name
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|subsym_hash
index|[
name|macro_level
index|]
argument_list|,
name|name
argument_list|,
name|empty
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .mlib<macro library filename>     Macro libraries are archived (standard AR-format) text macro definitions    Expand the file and include it.     FIXME need to try the source file directory as well.  */
end_comment

begin_function
specifier|static
name|void
name|tic54x_mlib
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|,
modifier|*
name|mbfd
decl_stmt|;
name|ILLEGAL_WITHIN_STRUCT
argument_list|()
expr_stmt|;
comment|/* Parse the filename.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
operator|(
name|filename
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
block|}
else|else
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|filename
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|tic54x_set_default_include
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|len
operator|+
name|include_dir_maxlen
operator|+
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_dir_count
condition|;
name|i
operator|++
control|)
block|{
name|FILE
modifier|*
name|try
decl_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|include_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|try
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|try
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|include_dir_count
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|filename
expr_stmt|;
block|}
comment|/* FIXME: if path is found, malloc'd storage is not freed.  Of course, this      happens all over the place, and since the assembler doesn't usually keep      running for a very long time, it really doesn't matter.  */
name|register_dependency
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Expand all archive entries to temporary files and include them.  */
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't open macro library file '%s' for reading."
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|as_perror
argument_list|(
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"File '%s' not in macro archive format"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Open each BFD as binary (it should be straight ASCII text).  */
for|for
control|(
name|mbfd
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
init|;
name|mbfd
operator|!=
name|NULL
condition|;
name|mbfd
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
name|mbfd
argument_list|)
control|)
block|{
comment|/* Get a size at least as big as the archive member.  */
name|bfd_size_type
name|size
init|=
name|bfd_get_size
argument_list|(
name|mbfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|tmpnam
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ftmp
decl_stmt|;
comment|/* We're not sure how big it is, but it will be smaller than "size".  */
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|mbfd
argument_list|)
expr_stmt|;
comment|/* Write to a temporary file, then use s_include to include it 	 a bit of a hack.  */
name|ftmp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fwrite
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ftmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|input_scrub_insert_file
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"algebraic"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|tic54x_align_words
block|,
literal|128
block|}
block|,
block|{
literal|"ascii"
block|,
name|tic54x_stringer
block|,
literal|'p'
block|}
block|,
block|{
literal|"asciz"
block|,
name|tic54x_stringer
block|,
literal|'P'
block|}
block|,
block|{
literal|"even"
block|,
name|tic54x_align_words
block|,
literal|2
block|}
block|,
block|{
literal|"asg"
block|,
name|tic54x_asg
block|,
literal|0
block|}
block|,
block|{
literal|"eval"
block|,
name|tic54x_eval
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|tic54x_bss
block|,
literal|0
block|}
block|,
block|{
literal|"byte"
block|,
name|tic54x_cons
block|,
literal|'b'
block|}
block|,
block|{
literal|"ubyte"
block|,
name|tic54x_cons
block|,
literal|'B'
block|}
block|,
block|{
literal|"char"
block|,
name|tic54x_cons
block|,
literal|'c'
block|}
block|,
block|{
literal|"uchar"
block|,
name|tic54x_cons
block|,
literal|'C'
block|}
block|,
block|{
literal|"clink"
block|,
name|tic54x_clink
block|,
literal|0
block|}
block|,
block|{
literal|"c_mode"
block|,
name|tic54x_address_mode
block|,
name|c_mode
block|}
block|,
block|{
literal|"copy"
block|,
name|tic54x_include
block|,
literal|'c'
block|}
block|,
block|{
literal|"include"
block|,
name|tic54x_include
block|,
literal|'i'
block|}
block|,
block|{
literal|"data"
block|,
name|tic54x_sect
block|,
literal|'d'
block|}
block|,
block|{
literal|"double"
block|,
name|tic54x_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|tic54x_float_cons
block|,
literal|'l'
block|}
block|,
block|{
literal|"drlist"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"drnolist"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"emsg"
block|,
name|tic54x_message
block|,
literal|'e'
block|}
block|,
block|{
literal|"mmsg"
block|,
name|tic54x_message
block|,
literal|'m'
block|}
block|,
block|{
literal|"wmsg"
block|,
name|tic54x_message
block|,
literal|'w'
block|}
block|,
block|{
literal|"far_mode"
block|,
name|tic54x_address_mode
block|,
name|far_mode
block|}
block|,
block|{
literal|"fclist"
block|,
name|tic54x_fclist
block|,
literal|1
block|}
block|,
block|{
literal|"fcnolist"
block|,
name|tic54x_fclist
block|,
literal|0
block|}
block|,
block|{
literal|"field"
block|,
name|tic54x_field
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"float"
block|,
name|tic54x_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"xfloat"
block|,
name|tic54x_float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"global"
block|,
name|tic54x_global
block|,
literal|'g'
block|}
block|,
block|{
literal|"def"
block|,
name|tic54x_global
block|,
literal|'d'
block|}
block|,
block|{
literal|"ref"
block|,
name|tic54x_global
block|,
literal|'r'
block|}
block|,
block|{
literal|"half"
block|,
name|tic54x_cons
block|,
literal|'h'
block|}
block|,
block|{
literal|"uhalf"
block|,
name|tic54x_cons
block|,
literal|'H'
block|}
block|,
block|{
literal|"short"
block|,
name|tic54x_cons
block|,
literal|'s'
block|}
block|,
block|{
literal|"ushort"
block|,
name|tic54x_cons
block|,
literal|'S'
block|}
block|,
block|{
literal|"if"
block|,
name|s_if
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"elseif"
block|,
name|s_elseif
block|,
operator|(
name|int
operator|)
name|O_ne
block|}
block|,
block|{
literal|"else"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"endif"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|tic54x_cons
block|,
literal|'i'
block|}
block|,
block|{
literal|"uint"
block|,
name|tic54x_cons
block|,
literal|'I'
block|}
block|,
block|{
literal|"word"
block|,
name|tic54x_cons
block|,
literal|'w'
block|}
block|,
block|{
literal|"uword"
block|,
name|tic54x_cons
block|,
literal|'W'
block|}
block|,
block|{
literal|"label"
block|,
name|tic54x_label
block|,
literal|0
block|}
block|,
comment|/* Loadtime                                                              address.  */
block|{
literal|"length"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"width"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|tic54x_cons
block|,
literal|'l'
block|}
block|,
block|{
literal|"ulong"
block|,
name|tic54x_cons
block|,
literal|'L'
block|}
block|,
block|{
literal|"xlong"
block|,
name|tic54x_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"loop"
block|,
name|tic54x_loop
block|,
literal|1024
block|}
block|,
block|{
literal|"break"
block|,
name|tic54x_break
block|,
literal|0
block|}
block|,
block|{
literal|"endloop"
block|,
name|tic54x_endloop
block|,
literal|0
block|}
block|,
block|{
literal|"mlib"
block|,
name|tic54x_mlib
block|,
literal|0
block|}
block|,
block|{
literal|"mlist"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"mnolist"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"mmregs"
block|,
name|tic54x_mmregs
block|,
literal|0
block|}
block|,
block|{
literal|"newblock"
block|,
name|tic54x_clear_local_labels
block|,
literal|0
block|}
block|,
block|{
literal|"option"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"p2align"
block|,
name|tic54x_p2align
block|,
literal|0
block|}
block|,
block|{
literal|"sblock"
block|,
name|tic54x_sblock
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|tic54x_sect
block|,
literal|'*'
block|}
block|,
block|{
literal|"set"
block|,
name|tic54x_set
block|,
literal|0
block|}
block|,
block|{
literal|"equ"
block|,
name|tic54x_set
block|,
literal|0
block|}
block|,
block|{
literal|"space"
block|,
name|tic54x_space
block|,
literal|0
block|}
block|,
block|{
literal|"bes"
block|,
name|tic54x_space
block|,
literal|1
block|}
block|,
block|{
literal|"sslist"
block|,
name|tic54x_sslist
block|,
literal|1
block|}
block|,
block|{
literal|"ssnolist"
block|,
name|tic54x_sslist
block|,
literal|0
block|}
block|,
block|{
literal|"string"
block|,
name|tic54x_stringer
block|,
literal|'s'
block|}
block|,
block|{
literal|"pstring"
block|,
name|tic54x_stringer
block|,
literal|'p'
block|}
block|,
block|{
literal|"struct"
block|,
name|tic54x_struct
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|tic54x_tag
block|,
literal|0
block|}
block|,
block|{
literal|"endstruct"
block|,
name|tic54x_endstruct
block|,
literal|0
block|}
block|,
block|{
literal|"tab"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|tic54x_sect
block|,
literal|'t'
block|}
block|,
block|{
literal|"union"
block|,
name|tic54x_struct
block|,
literal|1
block|}
block|,
block|{
literal|"endunion"
block|,
name|tic54x_endstruct
block|,
literal|1
block|}
block|,
block|{
literal|"usect"
block|,
name|tic54x_usect
block|,
literal|0
block|}
block|,
block|{
literal|"var"
block|,
name|tic54x_var
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|tic54x_version
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|OPTION_COFF_VERSION
case|:
block|{
name|int
name|version
init|=
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0
operator|&&
name|version
operator|!=
literal|1
operator|&&
name|version
operator|!=
literal|2
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Bad COFF version '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* FIXME -- not yet implemented.  */
break|break;
block|}
case|case
name|OPTION_CPU_VERSION
case|:
block|{
name|cpu
operator|=
name|lookup_version
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cpu_needs_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|VNONE
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Bad CPU version '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPTION_ADDRESS_MODE
case|:
name|amode
operator|=
name|far_mode
expr_stmt|;
name|address_mode_needs_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_STDERR_TO_FILE
case|:
block|{
name|char
modifier|*
name|filename
init|=
name|arg
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't redirect stderr to the file '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|freopen
argument_list|(
name|filename
argument_list|,
literal|"w+"
argument_list|,
name|stderr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't redirect stderr to the file '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create a "local" substitution string hash table for a new macro level    Some docs imply that macros have to use .newblock in order to be able    to re-use a local label.  We effectively do an automatic .newblock by    deleting the local label hash between macro invocations.  */
end_comment

begin_function
name|void
name|tic54x_macro_start
parameter_list|()
block|{
operator|++
name|macro_level
expr_stmt|;
name|subsym_hash
index|[
name|macro_level
index|]
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|local_label_hash
index|[
name|macro_level
index|]
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tic54x_macro_info
parameter_list|(
name|macro
parameter_list|)
specifier|const
name|macro_entry
modifier|*
name|macro
decl_stmt|;
block|{
specifier|const
name|formal_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Put the formal args into the substitution symbol table.  */
for|for
control|(
name|entry
operator|=
name|macro
operator|->
name|formals
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|strncpy
argument_list|(
name|xmalloc
argument_list|(
name|entry
operator|->
name|name
operator|.
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|entry
operator|->
name|name
operator|.
name|ptr
argument_list|,
name|entry
operator|->
name|name
operator|.
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|strncpy
argument_list|(
name|xmalloc
argument_list|(
name|entry
operator|->
name|actual
operator|.
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|entry
operator|->
name|actual
operator|.
name|ptr
argument_list|,
name|entry
operator|->
name|actual
operator|.
name|len
argument_list|)
decl_stmt|;
name|name
index|[
name|entry
operator|->
name|name
operator|.
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
index|[
name|entry
operator|->
name|actual
operator|.
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hash_insert
argument_list|(
name|subsym_hash
index|[
name|macro_level
index|]
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get rid of this macro's .var's, arguments, and local labels.  */
end_comment

begin_function
name|void
name|tic54x_macro_end
parameter_list|()
block|{
name|hash_die
argument_list|(
name|subsym_hash
index|[
name|macro_level
index|]
argument_list|)
expr_stmt|;
name|subsym_hash
index|[
name|macro_level
index|]
operator|=
name|NULL
expr_stmt|;
name|hash_die
argument_list|(
name|local_label_hash
index|[
name|macro_level
index|]
argument_list|)
expr_stmt|;
name|local_label_hash
index|[
name|macro_level
index|]
operator|=
name|NULL
expr_stmt|;
operator|--
name|macro_level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|subsym_symlen
parameter_list|(
name|a
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|strlen
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare symbol A to string B.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_symcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the first occurrence of B in A, or zero if none    assumes b is an integer char value as a string.  Index is one-based.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_firstch
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|val
init|=
name|atoi
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|strchr
argument_list|(
name|a
argument_list|,
name|val
argument_list|)
decl_stmt|;
return|return
name|tmp
condition|?
name|tmp
operator|-
name|a
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to firstch, but returns index of last occurrence of B in A.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_lastch
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|val
init|=
name|atoi
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|strrchr
argument_list|(
name|a
argument_list|,
name|val
argument_list|)
decl_stmt|;
return|return
name|tmp
condition|?
name|tmp
operator|-
name|a
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if string A is defined in the symbol table (NOT the substitution    symbol table).  */
end_comment

begin_function
specifier|static
name|int
name|subsym_isdefed
parameter_list|(
name|a
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_find
argument_list|(
name|a
argument_list|)
decl_stmt|;
return|return
name|symbolP
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assign first member of comma-separated list B (e.g. "1,2,3") to the symbol    A, or zero if B is a null string.  Both arguments *must* be substitution    symbols, unsubstituted.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_ismember
parameter_list|(
name|sym
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|listv
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
literal|0
return|;
name|listv
operator|=
name|subsym_lookup
argument_list|(
name|list
argument_list|,
name|macro_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|listv
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Undefined substitution symbol '%s'"
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr
operator|=
name|elem
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|listv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|elem
argument_list|,
name|listv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|','
condition|)
operator|++
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|subsym_create_or_replace
argument_list|(
name|sym
argument_list|,
name|elem
argument_list|)
expr_stmt|;
comment|/* Reassign the list.  */
name|subsym_create_or_replace
argument_list|(
name|list
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Assume this value, docs aren't clear.  */
return|return
operator|*
name|list
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return zero if not a constant; otherwise:    1 if binary    2 if octal    3 if hexadecimal    4 if character    5 if decimal.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_iscons
parameter_list|(
name|a
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|parse_expression
argument_list|(
name|a
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|a
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TOUPPER
argument_list|(
name|a
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|'B'
case|:
return|return
literal|1
return|;
case|case
literal|'Q'
case|:
return|return
literal|2
return|;
case|case
literal|'H'
case|:
return|return
literal|3
return|;
case|case
literal|'\''
case|:
return|return
literal|4
return|;
default|default:
break|break;
block|}
comment|/* No suffix; either octal, hex, or decimal.  */
if|if
condition|(
operator|*
name|a
operator|==
literal|'0'
operator|&&
name|len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|TOUPPER
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'X'
condition|)
return|return
literal|3
return|;
return|return
literal|2
return|;
block|}
return|return
literal|5
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if A is a valid symbol name.  Expects string input.   */
end_comment

begin_function
specifier|static
name|int
name|subsym_isname
parameter_list|(
name|a
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
operator|!
name|is_part_of_name
argument_list|(
operator|*
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
operator|++
name|a
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return whether the string is a register; accepts ar0-7, unless .mmregs has    been seen; if so, recognize any memory-mapped register.    Note this does not recognize "A" or "B" accumulators.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_isreg
parameter_list|(
name|a
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|a
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|hash_find
argument_list|(
name|mmreg_hash
argument_list|,
name|a
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the structure size, given the stag.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_structsz
parameter_list|(
name|name
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|stag
modifier|*
name|stag
init|=
operator|(
expr|struct
name|stag
operator|*
operator|)
name|hash_find
argument_list|(
name|stag_hash
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|stag
condition|)
return|return
name|stag
operator|->
name|size
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If anybody actually uses this, they can fix it :)    FIXME I'm not sure what the "reference point" of a structure is.  It might    be either the initial offset given .struct, or it may be the offset of the    structure within another structure, or it might be something else    altogether.  since the TI assembler doesn't seem to ever do anything but    return zero, we punt and return zero.  */
end_comment

begin_function
specifier|static
name|int
name|subsym_structacc
parameter_list|(
name|stag_name
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|stag_name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_ceil
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|ceil
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_cvi
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|arg1
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_floor
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|floor
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_fmod
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|arg1
operator|%
operator|(
name|int
operator|)
name|arg2
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_int
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
call|(
name|float
call|)
argument_list|(
operator|(
name|int
operator|)
name|arg1
argument_list|)
operator|)
operator|==
name|arg1
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_round
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|arg1
operator|>
literal|0
condition|?
call|(
name|int
call|)
argument_list|(
name|arg1
operator|+
literal|0.5
argument_list|)
else|:
call|(
name|int
call|)
argument_list|(
name|arg1
operator|-
literal|0.5
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_sgn
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|arg1
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|arg1
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_trunc
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|arg1
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_acos
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|acos
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_asin
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|asin
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_atan
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|atan
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_atan2
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|atan2
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_cosh
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|cosh
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_cos
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|cos
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_cvf
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|arg1
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_exp
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|exp
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_fabs
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|fabs
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* expr1 * 2^expr2.  */
end_comment

begin_function
specifier|static
name|float
name|math_ldexp
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
name|arg1
operator|*
operator|(
name|float
operator|)
name|pow
argument_list|(
literal|2.0
argument_list|,
name|arg2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_log10
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|log10
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_log
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|log
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_max
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
operator|(
name|arg1
operator|>
name|arg2
operator|)
condition|?
name|arg1
else|:
name|arg2
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_min
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
operator|(
name|arg1
operator|<
name|arg2
operator|)
condition|?
name|arg1
else|:
name|arg2
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_pow
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|arg2
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|pow
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_sin
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|sin
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_sinh
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|sinh
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_sqrt
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|sqrt
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_tan
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|tan
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|math_tanh
parameter_list|(
name|arg1
parameter_list|,
name|ignore
parameter_list|)
name|float
name|arg1
decl_stmt|;
name|float
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|float
operator|)
name|tanh
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Built-in substitution symbol functions and math functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|*proc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
name|nargs
decl_stmt|;
block|}
name|subsym_proc_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|subsym_proc_entry
name|subsym_procs
index|[]
init|=
block|{
comment|/* Assembler built-in string substitution functions.  */
block|{
literal|"$symlen"
block|,
name|subsym_symlen
block|,
literal|1
block|,  }
block|,
block|{
literal|"$symcmp"
block|,
name|subsym_symcmp
block|,
literal|2
block|,  }
block|,
block|{
literal|"$firstch"
block|,
name|subsym_firstch
block|,
literal|2
block|,  }
block|,
block|{
literal|"$lastch"
block|,
name|subsym_lastch
block|,
literal|2
block|,  }
block|,
block|{
literal|"$isdefed"
block|,
name|subsym_isdefed
block|,
literal|1
block|,  }
block|,
block|{
literal|"$ismember"
block|,
name|subsym_ismember
block|,
literal|2
block|,  }
block|,
block|{
literal|"$iscons"
block|,
name|subsym_iscons
block|,
literal|1
block|,  }
block|,
block|{
literal|"$isname"
block|,
name|subsym_isname
block|,
literal|1
block|,  }
block|,
block|{
literal|"$isreg"
block|,
name|subsym_isreg
block|,
literal|1
block|,  }
block|,
block|{
literal|"$structsz"
block|,
name|subsym_structsz
block|,
literal|1
block|,  }
block|,
block|{
literal|"$structacc"
block|,
name|subsym_structacc
block|,
literal|1
block|,  }
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|float
argument_list|(
argument|*proc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|float
operator|,
name|float
operator|)
argument_list|)
expr_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|int_return
decl_stmt|;
block|}
name|math_proc_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|math_proc_entry
name|math_procs
index|[]
init|=
block|{
comment|/* Integer-returning built-in math functions.  */
block|{
literal|"$cvi"
block|,
name|math_cvi
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"$int"
block|,
name|math_int
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"$sgn"
block|,
name|math_sgn
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* Float-returning built-in math functions.  */
block|{
literal|"$acos"
block|,
name|math_acos
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$asin"
block|,
name|math_asin
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$atan"
block|,
name|math_atan
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$atan2"
block|,
name|math_atan2
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$ceil"
block|,
name|math_ceil
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$cosh"
block|,
name|math_cosh
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$cos"
block|,
name|math_cos
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$cvf"
block|,
name|math_cvf
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$exp"
block|,
name|math_exp
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$fabs"
block|,
name|math_fabs
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$floor"
block|,
name|math_floor
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$fmod"
block|,
name|math_fmod
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$ldexp"
block|,
name|math_ldexp
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$log10"
block|,
name|math_log10
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$log"
block|,
name|math_log
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$max"
block|,
name|math_max
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$min"
block|,
name|math_min
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$pow"
block|,
name|math_pow
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"$round"
block|,
name|math_round
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$sin"
block|,
name|math_sin
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$sinh"
block|,
name|math_sinh
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$sqrt"
block|,
name|math_sqrt
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$tan"
block|,
name|math_tan
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$tanh"
block|,
name|math_tanh
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"$trunc"
block|,
name|math_trunc
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|template
modifier|*
name|tm
decl_stmt|;
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|const
name|subsym_proc_entry
modifier|*
name|subsym_proc
decl_stmt|;
specifier|const
name|math_proc_entry
modifier|*
name|math_proc
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
name|char
modifier|*
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|TIC54X_DIR
init|=
name|getenv
argument_list|(
literal|"TIC54X_DIR"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|A_DIR
init|=
name|TIC54X_DIR
condition|?
name|TIC54X_DIR
else|:
name|getenv
argument_list|(
literal|"A_DIR"
argument_list|)
decl_stmt|;
name|local_label_id
operator|=
literal|0
expr_stmt|;
comment|/* Look for A_DIR and add it to the include list.  */
if|if
condition|(
name|A_DIR
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|A_DIR
argument_list|)
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|next
init|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
operator|*
name|next
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|add_include_dir
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
do|;
block|}
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|tm
operator|=
operator|(
name|template
operator|*
operator|)
name|tic54x_optab
init|;
name|tm
operator|->
name|name
condition|;
name|tm
operator|++
control|)
block|{
if|if
condition|(
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|tm
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|tm
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't hash %s: %s"
argument_list|,
name|tm
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|parop_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|tm
operator|=
operator|(
name|template
operator|*
operator|)
name|tic54x_paroptab
init|;
name|tm
operator|->
name|name
condition|;
name|tm
operator|++
control|)
block|{
if|if
condition|(
name|hash_find
argument_list|(
name|parop_hash
argument_list|,
name|tm
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|parop_hash
argument_list|,
name|tm
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't hash %s: %s"
argument_list|,
name|tm
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|regs
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
block|{
comment|/* Add basic registers to the symbol table.  */
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_new
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|sym
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
decl_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|mmregs
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|mmreg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|mmregs
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|mmreg_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|cc_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|condition_codes
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|cc_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|cc2_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|cc2_codes
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|cc2_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|cc3_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|cc3_codes
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|cc3_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|sbit_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|status_bits
init|;
name|sym
operator|->
name|name
condition|;
name|sym
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|sbit_hash
argument_list|,
name|sym
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|misc_symbol_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|symname
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|misc_symbols
init|;
operator|*
name|symname
condition|;
name|symname
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|misc_symbol_hash
argument_list|,
operator|*
name|symname
argument_list|,
operator|*
name|symname
argument_list|)
expr_stmt|;
comment|/* Only the base substitution table and local label table are initialized;      the others (for local macro substitution) get instantiated as needed.  */
name|local_label_hash
index|[
literal|0
index|]
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|subsym_hash
index|[
literal|0
index|]
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|subsym_proc
operator|=
name|subsym_procs
init|;
name|subsym_proc
operator|->
name|name
condition|;
name|subsym_proc
operator|++
control|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|subsym_proc
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|subsym_proc
argument_list|)
expr_stmt|;
name|math_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|math_proc
operator|=
name|math_procs
init|;
name|math_proc
operator|->
name|name
condition|;
name|math_proc
operator|++
control|)
block|{
comment|/* Insert into the main subsym hash for recognition; insert into 	 the math hash to actually store information.  */
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|math_proc
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|math_proc
argument_list|)
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|math_hash
argument_list|,
name|math_proc
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|math_proc
argument_list|)
expr_stmt|;
block|}
name|subsym_recurse_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|stag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_accumulator
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
return|return
name|strcasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"a"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"b"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of operands found, or -1 on error, copying the    operands into the given array and the accompanying expressions into    the next array.  */
end_comment

begin_function
specifier|static
name|int
name|get_operands
parameter_list|(
name|operands
parameter_list|,
name|line
parameter_list|)
name|struct
name|opstruct
name|operands
index|[]
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|lptr
init|=
name|line
decl_stmt|;
name|int
name|numexp
init|=
literal|0
decl_stmt|;
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|numexp
operator|<
name|MAX_OPERANDS
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|lptr
index|]
condition|)
block|{
name|int
name|paren_not_balanced
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|op_start
decl_stmt|,
modifier|*
name|op_end
decl_stmt|;
while|while
condition|(
operator|*
name|lptr
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|lptr
argument_list|)
condition|)
operator|++
name|lptr
expr_stmt|;
name|op_start
operator|=
name|lptr
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|lptr
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|lptr
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unbalanced parenthesis in operand %d"
argument_list|,
name|numexp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|lptr
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|lptr
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
operator|++
name|lptr
expr_stmt|;
block|}
name|op_end
operator|=
name|lptr
expr_stmt|;
if|if
condition|(
name|op_end
operator|!=
name|op_start
condition|)
block|{
name|int
name|len
init|=
name|op_end
operator|-
name|op_start
decl_stmt|;
name|strncpy
argument_list|(
name|operands
index|[
name|numexp
index|]
operator|.
name|buf
argument_list|,
name|op_start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|operands
index|[
name|numexp
index|]
operator|.
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Trim trailing spaces; while the preprocessor gets rid of most, 	     there are weird usage patterns that can introduce them 	     (i.e. using strings for macro args).  */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|ISSPACE
argument_list|(
name|operands
index|[
name|numexp
index|]
operator|.
name|buf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
name|numexp
index|]
operator|.
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|lptr
operator|=
name|op_end
expr_stmt|;
operator|++
name|numexp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
operator|||
operator|*
name|lptr
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand after ','"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|lptr
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|lptr
operator|==
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand after ','"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|lptr
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|lptr
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|lptr
index|]
condition|)
block|{
name|as_bad
argument_list|(
literal|"Extra junk on line"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* OK, now parse them into expressions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numexp
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* Immediate.  */
name|parse_expression
argument_list|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* Direct notation.  */
name|parse_expression
argument_list|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* Indirect.  */
name|char
modifier|*
name|paren
init|=
name|strchr
argument_list|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
literal|'('
argument_list|)
decl_stmt|;
comment|/* Allow immediate syntax in the inner expression.  */
if|if
condition|(
name|paren
operator|&&
name|paren
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
operator|*
operator|++
name|paren
operator|=
literal|'('
expr_stmt|;
comment|/* Pull out the lk expression or SP offset, if present.  */
if|if
condition|(
name|paren
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|paren
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|paren
operator|+
name|len
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
if|if
condition|(
operator|--
name|end
operator|<=
name|paren
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Badly formed address expression"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|=
operator|*
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|parse_expression
argument_list|(
name|paren
argument_list|,
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|c
expr_stmt|;
block|}
else|else
name|operands
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
name|parse_expression
argument_list|(
name|operands
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|numexp
return|;
block|}
end_function

begin_comment
comment|/* Predicates for different operand types.  */
end_comment

begin_function
specifier|static
name|int
name|is_immediate
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
return|return
operator|*
name|operand
operator|->
name|buf
operator|==
literal|'#'
return|;
block|}
end_function

begin_comment
comment|/* This is distinguished from immediate because some numbers must be constants    and must *not* have the '#' prefix.  */
end_comment

begin_function
specifier|static
name|int
name|is_absolute
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
return|return
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|!
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Is this an indirect operand?  */
end_comment

begin_function
specifier|static
name|int
name|is_indirect
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
return|return
name|operand
operator|->
name|buf
index|[
literal|0
index|]
operator|==
literal|'*'
return|;
block|}
end_function

begin_comment
comment|/* Is this a valid dual-memory operand?  */
end_comment

begin_function
specifier|static
name|int
name|is_dual
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|is_indirect
argument_list|(
name|operand
argument_list|)
operator|&&
name|strncasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"*ar"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|operand
operator|->
name|buf
operator|+
literal|3
decl_stmt|;
name|int
name|arf
decl_stmt|;
name|int
name|valid_mod
decl_stmt|;
name|arf
operator|=
operator|*
name|tmp
operator|++
operator|-
literal|'0'
expr_stmt|;
comment|/* Only allow *ARx, *ARx-, *ARx+, or *ARx+0%.  */
name|valid_mod
operator|=
operator|*
name|tmp
operator|==
literal|'\0'
operator|||
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"+0%"
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
name|arf
operator|>=
literal|2
operator|&&
name|arf
operator|<=
literal|5
operator|&&
name|valid_mod
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_mmreg
parameter_list|(
name|operand
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
return|return
operator|(
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|||
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|hash_find
argument_list|(
name|mmreg_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_type
parameter_list|(
name|operand
parameter_list|,
name|type
parameter_list|)
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
name|enum
name|optype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_None
case|:
return|return
name|operand
operator|->
name|buf
index|[
literal|0
index|]
operator|==
literal|0
return|;
case|case
name|OP_Xmem
case|:
case|case
name|OP_Ymem
case|:
return|return
name|is_dual
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_Sind
case|:
return|return
name|is_indirect
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_xpmad_ms7
case|:
comment|/* This one *must* be immediate.  */
return|return
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_xpmad
case|:
case|case
name|OP_pmad
case|:
case|case
name|OP_PA
case|:
case|case
name|OP_dmad
case|:
case|case
name|OP_Lmem
case|:
case|case
name|OP_MMR
case|:
return|return
literal|1
return|;
case|case
name|OP_Smem
case|:
comment|/* Address may be a numeric, indirect, or an expression.  */
return|return
operator|!
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_MMRY
case|:
case|case
name|OP_MMRX
case|:
return|return
name|is_mmreg
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_SRC
case|:
case|case
name|OP_SRC1
case|:
case|case
name|OP_RND
case|:
case|case
name|OP_DST
case|:
return|return
name|is_accumulator
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_B
case|:
return|return
name|is_accumulator
argument_list|(
name|operand
argument_list|)
operator|&&
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'B'
return|;
case|case
name|OP_A
case|:
return|return
name|is_accumulator
argument_list|(
name|operand
argument_list|)
operator|&&
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'A'
return|;
case|case
name|OP_ARX
case|:
return|return
name|strncasecmp
argument_list|(
literal|"ar"
argument_list|,
name|operand
operator|->
name|buf
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIGIT
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|OP_SBIT
case|:
return|return
name|hash_find
argument_list|(
name|sbit_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|!=
literal|0
operator|||
name|is_absolute
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_CC
case|:
return|return
name|hash_find
argument_list|(
name|cc_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|!=
literal|0
return|;
case|case
name|OP_CC2
case|:
return|return
name|hash_find
argument_list|(
name|cc2_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|!=
literal|0
return|;
case|case
name|OP_CC3
case|:
return|return
name|hash_find
argument_list|(
name|cc3_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|!=
literal|0
operator|||
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|is_absolute
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_16
case|:
return|return
operator|(
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|)
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
literal|16
return|;
case|case
name|OP_N
case|:
comment|/* Allow st0 or st1 instead of a numeric.  */
return|return
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|||
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|strcasecmp
argument_list|(
literal|"st0"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"st1"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_12
case|:
case|case
name|OP_123
case|:
return|return
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|||
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_SHFT
case|:
return|return
operator|(
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|)
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|<
literal|16
return|;
case|case
name|OP_SHIFT
case|:
comment|/* Let this one catch out-of-range values.  */
return|return
operator|(
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|||
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|)
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|!=
literal|16
return|;
case|case
name|OP_BITC
case|:
case|case
name|OP_031
case|:
case|case
name|OP_k8
case|:
return|return
name|is_absolute
argument_list|(
name|operand
argument_list|)
operator|||
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_k8u
case|:
return|return
name|is_immediate
argument_list|(
name|operand
argument_list|)
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|<
literal|256
return|;
case|case
name|OP_lk
case|:
case|case
name|OP_lku
case|:
comment|/* Allow anything; assumes opcodes are ordered with Smem operands 	 versions first.  */
return|return
literal|1
return|;
case|case
name|OP_k5
case|:
case|case
name|OP_k3
case|:
case|case
name|OP_k9
case|:
comment|/* Just make sure it's an integer; check range later.  */
return|return
name|is_immediate
argument_list|(
name|operand
argument_list|)
return|;
case|case
name|OP_T
case|:
return|return
name|strcasecmp
argument_list|(
literal|"t"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"treg"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_TS
case|:
return|return
name|strcasecmp
argument_list|(
literal|"ts"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_ASM
case|:
return|return
name|strcasecmp
argument_list|(
literal|"asm"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_TRN
case|:
return|return
name|strcasecmp
argument_list|(
literal|"trn"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_DP
case|:
return|return
name|strcasecmp
argument_list|(
literal|"dp"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
case|case
name|OP_ARP
case|:
return|return
name|strcasecmp
argument_list|(
literal|"arp"
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|operands_match
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|,
name|opcount
parameter_list|,
name|refoptype
parameter_list|,
name|minops
parameter_list|,
name|maxops
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operands
decl_stmt|;
name|int
name|opcount
decl_stmt|;
specifier|const
name|enum
name|optype
modifier|*
name|refoptype
decl_stmt|;
name|int
name|minops
decl_stmt|;
name|int
name|maxops
decl_stmt|;
block|{
name|int
name|op
init|=
literal|0
decl_stmt|,
name|refop
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|opcount
operator|==
literal|0
operator|&&
name|minops
operator|==
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|op
operator|<=
name|maxops
operator|&&
name|refop
operator|<=
name|maxops
condition|)
block|{
while|while
condition|(
operator|!
name|is_type
argument_list|(
operator|&
name|operands
index|[
name|op
index|]
argument_list|,
name|OPTYPE
argument_list|(
name|refoptype
index|[
name|refop
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Skip an optional template operand if it doesn't agree 	     with the current operand.  */
if|if
condition|(
name|refoptype
index|[
name|refop
index|]
operator|&
name|OPT
condition|)
block|{
operator|++
name|refop
expr_stmt|;
operator|--
name|maxops
expr_stmt|;
if|if
condition|(
name|refop
operator|>
name|maxops
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* Save the actual operand type for later use.  */
name|operands
index|[
name|op
index|]
operator|.
name|type
operator|=
name|OPTYPE
argument_list|(
name|refoptype
index|[
name|refop
index|]
argument_list|)
expr_stmt|;
operator|++
name|refop
expr_stmt|;
operator|++
name|op
expr_stmt|;
comment|/* Have we matched them all yet?  */
if|if
condition|(
name|op
operator|==
name|opcount
condition|)
block|{
while|while
condition|(
name|op
operator|<
name|maxops
condition|)
block|{
comment|/* If a later operand is *not* optional, no match.  */
if|if
condition|(
operator|(
name|refoptype
index|[
name|refop
index|]
operator|&
name|OPT
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Flag any implicit default OP_DST operands so we know to add 		 them explicitly when encoding the operand later.  */
if|if
condition|(
name|OPTYPE
argument_list|(
name|refoptype
index|[
name|refop
index|]
argument_list|)
operator|==
name|OP_DST
condition|)
name|insn
operator|->
name|using_default_dst
operator|=
literal|1
expr_stmt|;
operator|++
name|refop
expr_stmt|;
operator|++
name|op
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* 16-bit direct memory address    Explicit dmad operands are always in last word of insn (usually second    word, but bumped to third if lk addressing is used)     We allow *(dmad) notation because the TI assembler allows it.     XPC_CODE:    0 for 16-bit addresses    1 for full 23-bit addresses    2 for the upper 7 bits of a 23-bit address (LDX).  */
end_comment

begin_function
specifier|static
name|int
name|encode_dmad
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|xpc_code
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
name|int
name|xpc_code
decl_stmt|;
block|{
name|int
name|op
init|=
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
decl_stmt|;
comment|/* Only allow *(dmad) expressions; all others are invalid.  */
if|if
condition|(
name|is_indirect
argument_list|(
name|operand
argument_list|)
operator|&&
name|operand
operator|->
name|buf
index|[
name|strlen
argument_list|(
name|operand
operator|->
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid dmad syntax '%s'"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|addr_expr
operator|=
name|operand
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|addr_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|valueT
name|value
init|=
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|addr_expr
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|xpc_code
operator|==
literal|1
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&=
literal|0xFF80
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|word
operator|=
name|value
operator|&
literal|0xFFFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xpc_code
operator|==
literal|2
condition|)
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|word
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
else|else
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|word
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Do the fixup later; just store the expression.  */
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|r_nchars
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|amode
operator|==
name|c_mode
condition|)
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_16_OF_23
expr_stmt|;
elseif|else
if|if
condition|(
name|xpc_code
operator|==
literal|1
condition|)
block|{
comment|/* This relocation spans two words, so adjust accordingly.  */
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|addr_expr
operator|=
name|operand
operator|->
name|exp
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_23
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|r_nchars
operator|=
literal|4
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|unresolved
operator|=
literal|1
expr_stmt|;
comment|/* It's really 2 words, but we want to stop encoding after the 	     first, since we must encode both words at once.  */
name|insn
operator|->
name|words
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xpc_code
operator|==
literal|2
condition|)
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_MS7_OF_23
expr_stmt|;
else|else
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_16_OF_23
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
name|op
index|]
operator|.
name|unresolved
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* 7-bit direct address encoding.  */
end_comment

begin_function
specifier|static
name|int
name|encode_address
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
comment|/* Assumes that dma addresses are *always* in word 0 of the opcode.  */
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|addr_expr
operator|=
name|operand
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|&
literal|0x7F
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Use the .mmregs directive to use memory-mapped register names such as '%s'"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
comment|/* Do the fixup later; just store the expression.  */
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|r_nchars
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_PARTLS7
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|unresolved
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_indirect
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|int
name|arf
decl_stmt|;
name|int
name|mod
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|is_lkaddr
condition|)
block|{
comment|/* lk addresses always go in the second insn word.  */
name|mod
operator|=
operator|(
operator|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'A'
operator|)
condition|?
literal|12
else|:
operator|(
name|operand
operator|->
name|buf
index|[
literal|1
index|]
operator|==
literal|'('
operator|)
condition|?
literal|15
else|:
operator|(
name|strchr
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
literal|14
else|:
literal|13
operator|)
expr_stmt|;
name|arf
operator|=
operator|(
operator|(
name|mod
operator|==
literal|12
operator|)
condition|?
name|operand
operator|->
name|buf
index|[
literal|3
index|]
operator|-
literal|'0'
else|:
operator|(
name|mod
operator|==
literal|15
operator|)
condition|?
literal|0
else|:
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|addr_expr
operator|=
name|operand
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|word
operator|=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
else|else
block|{
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|r_nchars
operator|=
literal|2
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|r_type
operator|=
name|BFD_RELOC_TIC54X_16_OF_23
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|1
index|]
operator|.
name|unresolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"*sp ("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stack offsets look the same as 7-bit direct addressing.  */
return|return
name|encode_address
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
block|}
else|else
block|{
name|arf
operator|=
operator|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'A'
condition|?
name|operand
operator|->
name|buf
index|[
literal|3
index|]
else|:
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|)
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|buf
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|mod
operator|=
literal|3
expr_stmt|;
comment|/* *+ARx  */
if|if
condition|(
name|insn
operator|->
name|tm
operator|->
name|flags
operator|&
name|FL_SMR
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Address mode *+ARx is write-only. "
literal|"Results of reading are undefined."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
name|mod
operator|=
literal|0
expr_stmt|;
comment|/* *ARx  */
elseif|else
if|if
condition|(
name|operand
operator|->
name|buf
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
name|mod
operator|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
comment|/* *ARx+ / *ARx-  */
elseif|else
if|if
condition|(
name|operand
operator|->
name|buf
index|[
literal|6
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|buf
index|[
literal|5
index|]
operator|==
literal|'0'
condition|)
name|mod
operator|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|5
else|:
literal|6
operator|)
expr_stmt|;
comment|/* *ARx+0 / *ARx-0  */
else|else
name|mod
operator|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|8
else|:
literal|10
operator|)
expr_stmt|;
comment|/* *ARx+% / *ARx-%  */
block|}
elseif|else
if|if
condition|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|6
index|]
argument_list|)
operator|==
literal|'B'
condition|)
name|mod
operator|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|4
else|:
literal|7
operator|)
expr_stmt|;
comment|/* ARx+0B / *ARx-0B  */
elseif|else
if|if
condition|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|6
index|]
argument_list|)
operator|==
literal|'%'
condition|)
name|mod
operator|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|9
else|:
literal|11
operator|)
expr_stmt|;
comment|/* ARx+0% / *ARx - 0%  */
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized indirect address format \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
literal|0x80
operator||
operator|(
name|mod
operator|<<
literal|3
operator|)
operator||
name|arf
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_integer
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|which
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|mask
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|unsigned
name|short
name|mask
decl_stmt|;
block|{
name|long
name|parse
decl_stmt|,
name|integer
decl_stmt|;
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|addr_expr
operator|=
name|operand
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|parse
operator|=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* Hack -- fixup for 16-bit hex quantities that get converted positive 	 instead of negative.  */
if|if
condition|(
operator|(
name|parse
operator|&
literal|0x8000
operator|)
operator|&&
name|min
operator|==
operator|-
literal|32768
operator|&&
name|max
operator|==
literal|32767
condition|)
name|integer
operator|=
operator|(
name|short
operator|)
name|parse
expr_stmt|;
else|else
name|integer
operator|=
name|parse
expr_stmt|;
if|if
condition|(
name|integer
operator|>=
name|min
operator|&&
name|integer
operator|<=
name|max
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|word
operator||=
operator|(
name|integer
operator|&
name|mask
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand '%s' out of range (%d<= x<= %d)"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|addr_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|word
operator||=
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|addr_expr
operator|.
name|X_add_number
operator|&
name|mask
expr_stmt|;
block|}
else|else
block|{
comment|/* Do the fixup later; just store the expression.  */
name|bfd_reloc_code_real_type
name|rtype
init|=
operator|(
name|mask
operator|==
literal|0x1FF
condition|?
name|BFD_RELOC_TIC54X_PARTMS9
else|:
name|mask
operator|==
literal|0xFFFF
condition|?
name|BFD_RELOC_TIC54X_16_OF_23
else|:
name|mask
operator|==
literal|0x7F
condition|?
name|BFD_RELOC_TIC54X_PARTLS7
else|:
name|BFD_RELOC_8
operator|)
decl_stmt|;
name|int
name|size
init|=
operator|(
name|mask
operator|==
literal|0x1FF
operator|||
name|mask
operator|==
literal|0xFFFF
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|rtype
operator|==
name|BFD_RELOC_8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Error in relocation handling"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|r_nchars
operator|=
name|size
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|r_type
operator|=
name|rtype
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
name|which
index|]
operator|.
name|unresolved
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_condition
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|symbol
modifier|*
name|cc
init|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cc
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized condition code \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
define|#
directive|define
name|CC_GROUP
value|0x40
define|#
directive|define
name|CC_ACC
value|0x08
define|#
directive|define
name|CATG_A1
value|0x07
define|#
directive|define
name|CATG_B1
value|0x30
define|#
directive|define
name|CATG_A2
value|0x30
define|#
directive|define
name|CATG_B2
value|0x0C
define|#
directive|define
name|CATG_C2
value|0x03
comment|/* Disallow group 1 conditions mixed with group 2 conditions      if group 1, allow only one category A and one category B      if group 2, allow only one each of category A, B, and C.  */
if|if
condition|(
operator|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
literal|0xFF
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CC_GROUP
operator|)
operator|!=
operator|(
name|cc
operator|->
name|value
operator|&
name|CC_GROUP
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Condition \"%s\" does not match preceding group"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CC_GROUP
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CC_ACC
operator|)
operator|!=
operator|(
name|cc
operator|->
name|value
operator|&
name|CC_ACC
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Condition \"%s\" uses a different accumulator from "
literal|"a preceding condition"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CATG_A1
operator|)
operator|&&
operator|(
name|cc
operator|->
name|value
operator|&
name|CATG_A1
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Only one comparison conditional allowed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CATG_B1
operator|)
operator|&&
operator|(
name|cc
operator|->
name|value
operator|&
name|CATG_B1
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Only one overflow conditional allowed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CATG_A2
operator|)
operator|&&
operator|(
name|cc
operator|->
name|value
operator|&
name|CATG_A2
operator|)
operator|)
operator|||
operator|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CATG_B2
operator|)
operator|&&
operator|(
name|cc
operator|->
name|value
operator|&
name|CATG_B2
operator|)
operator|)
operator|||
operator|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
name|CATG_C2
operator|)
operator|&&
operator|(
name|cc
operator|->
name|value
operator|&
name|CATG_C2
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Duplicate %s conditional"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|cc
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_cc3
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|symbol
modifier|*
name|cc3
init|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc3_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|cc3
condition|?
name|cc3
operator|->
name|value
else|:
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|<<
literal|8
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0x0300
operator|)
operator|!=
name|value
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized condition code \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_arx
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|int
name|arf
init|=
name|strlen
argument_list|(
name|operand
operator|->
name|buf
argument_list|)
operator|>=
literal|3
condition|?
name|operand
operator|->
name|buf
index|[
literal|2
index|]
operator|-
literal|'0'
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"ar"
argument_list|,
name|operand
operator|->
name|buf
argument_list|,
literal|2
argument_list|)
operator|||
name|arf
operator|<
literal|0
operator|||
name|arf
operator|>
literal|7
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid auxiliary register (use AR0-AR7)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|arf
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_cc2
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|symbol
modifier|*
name|cc2
init|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc2_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cc2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized condition code \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|cc2
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_operand
parameter_list|(
name|insn
parameter_list|,
name|type
parameter_list|,
name|operand
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|enum
name|optype
name|type
decl_stmt|;
name|struct
name|opstruct
modifier|*
name|operand
decl_stmt|;
block|{
name|int
name|ext
init|=
operator|(
name|insn
operator|->
name|tm
operator|->
name|flags
operator|&
name|FL_EXT
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_MMR
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Disallow long-constant addressing for memory-mapped addressing.  */
if|if
condition|(
name|insn
operator|->
name|is_lkaddr
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"lk addressing modes are invalid for memory-mapped "
literal|"register addressing"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|type
operator|=
name|OP_Smem
expr_stmt|;
comment|/* Warn about *+ARx when used with MMR operands.  */
if|if
condition|(
name|strncasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"*+ar"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Address mode *+ARx is not allowed in memory-mapped "
literal|"register addressing.  Resulting behavior is "
literal|"undefined."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_None
case|:
return|return
literal|1
return|;
case|case
name|OP_dmad
case|:
comment|/* 16-bit immediate value.  */
return|return
name|encode_dmad
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|OP_SRC
case|:
if|if
condition|(
name|TOUPPER
argument_list|(
operator|*
name|operand
operator|->
name|buf
argument_list|)
operator|==
literal|'B'
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
name|ext
condition|?
operator|(
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
operator|)
else|:
literal|0
index|]
operator|.
name|word
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|using_default_dst
condition|)
name|insn
operator|->
name|opcode
index|[
name|ext
condition|?
operator|(
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
operator|)
else|:
literal|0
index|]
operator|.
name|word
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
name|OP_RND
case|:
comment|/* Make sure this agrees with the OP_DST operand.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'B'
operator|)
operator|^
operator|(
operator|(
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Destination accumulator for each part of this parallel "
literal|"instruction must be different"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|OP_SRC1
case|:
case|case
name|OP_DST
case|:
if|if
condition|(
name|TOUPPER
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'B'
condition|)
name|insn
operator|->
name|opcode
index|[
name|ext
condition|?
operator|(
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
operator|)
else|:
literal|0
index|]
operator|.
name|word
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|OP_Xmem
case|:
case|case
name|OP_Ymem
case|:
block|{
name|int
name|mod
init|=
operator|(
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|?
literal|0
else|:
comment|/* *arx  */
name|operand
operator|->
name|buf
index|[
literal|4
index|]
operator|==
literal|'-'
condition|?
literal|1
else|:
comment|/* *arx-  */
name|operand
operator|->
name|buf
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|?
literal|2
else|:
literal|3
operator|)
decl_stmt|;
comment|/* *arx+, *arx+0%  */
name|int
name|arf
init|=
name|operand
operator|->
name|buf
index|[
literal|3
index|]
operator|-
literal|'0'
operator|-
literal|2
decl_stmt|;
name|int
name|code
init|=
operator|(
name|mod
operator|<<
literal|2
operator|)
operator||
name|arf
decl_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|code
operator|<<
operator|(
name|type
operator|==
name|OP_Xmem
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|OP_Lmem
case|:
case|case
name|OP_Smem
case|:
if|if
condition|(
operator|!
name|is_indirect
argument_list|(
name|operand
argument_list|)
condition|)
return|return
name|encode_address
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
comment|/* Fall through.  */
case|case
name|OP_Sind
case|:
return|return
name|encode_indirect
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
case|case
name|OP_xpmad_ms7
case|:
return|return
name|encode_dmad
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|OP_xpmad
case|:
return|return
name|encode_dmad
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|OP_PA
case|:
case|case
name|OP_pmad
case|:
return|return
name|encode_dmad
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|OP_ARX
case|:
return|return
name|encode_arx
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
case|case
name|OP_MMRX
case|:
case|case
name|OP_MMRY
case|:
case|case
name|OP_MMR
case|:
block|{
name|int
name|value
init|=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_MMR
condition|)
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|value
expr_stmt|;
else|else
block|{
if|if
condition|(
name|value
operator|<
literal|16
operator|||
name|value
operator|>
literal|24
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Memory mapped register \"%s\" out of range"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type
operator|==
name|OP_MMRX
condition|)
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|value
operator|-
literal|16
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|value
operator|-
literal|16
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
case|case
name|OP_B
case|:
case|case
name|OP_A
case|:
return|return
literal|1
return|;
case|case
name|OP_SHFT
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ext
operator|+
name|insn
operator|->
name|is_lkaddr
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0xF
argument_list|)
return|;
case|case
name|OP_SHIFT
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ext
operator|+
name|insn
operator|->
name|is_lkaddr
argument_list|,
operator|-
literal|16
argument_list|,
literal|15
argument_list|,
literal|0x1F
argument_list|)
return|;
case|case
name|OP_lk
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|,
literal|0xFFFF
argument_list|)
return|;
case|case
name|OP_CC
case|:
return|return
name|encode_condition
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
case|case
name|OP_CC2
case|:
return|return
name|encode_cc2
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
case|case
name|OP_CC3
case|:
return|return
name|encode_cc3
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
return|;
case|case
name|OP_BITC
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0xF
argument_list|)
return|;
case|case
name|OP_k8
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
operator|-
literal|128
argument_list|,
literal|127
argument_list|,
literal|0xFF
argument_list|)
return|;
case|case
name|OP_123
case|:
block|{
name|int
name|value
init|=
name|operand
operator|->
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|1
operator|||
name|value
operator|>
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operand (use 1, 2, or 3)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|code
operator|=
name|value
operator|==
literal|1
condition|?
literal|0
else|:
name|value
operator|==
literal|2
condition|?
literal|0x2
else|:
literal|0x1
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|code
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|OP_031
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|,
literal|0x1F
argument_list|)
return|;
case|case
name|OP_k8u
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0xFF
argument_list|)
return|;
case|case
name|OP_lku
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
argument_list|,
literal|0
argument_list|,
literal|65535
argument_list|,
literal|0xFFFF
argument_list|)
return|;
case|case
name|OP_SBIT
case|:
block|{
name|symbol
modifier|*
name|sbit
init|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|sbit_hash
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|is_absolute
argument_list|(
name|operand
argument_list|)
condition|?
name|operand
operator|->
name|exp
operator|.
name|X_add_number
else|:
operator|(
name|sbit
condition|?
name|sbit
operator|->
name|value
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|reg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|opcount
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|sbit
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"A status register or status bit name is required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Guess the register based on the status bit; "ovb" is the last 	       status bit defined for st0.  */
if|if
condition|(
name|sbit
operator|>
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|sbit_hash
argument_list|,
literal|"ovb"
argument_list|)
condition|)
name|reg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized status bit \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
name|value
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|reg
operator|<<
literal|9
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|OP_N
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"st0"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|operand
operator|->
name|buf
argument_list|,
literal|"st1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|operand
operator|->
name|buf
index|[
literal|2
index|]
operator|-
literal|'0'
argument_list|)
operator|)
operator|<<
literal|9
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
literal|0
operator|||
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|==
literal|1
operator|)
condition|)
block|{
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
operator|<<
literal|9
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid status register \"%s\""
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OP_k5
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
operator|-
literal|16
argument_list|,
literal|15
argument_list|,
literal|0x1F
argument_list|)
return|;
case|case
name|OP_k3
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0x7
argument_list|)
return|;
case|case
name|OP_k9
case|:
return|return
name|encode_integer
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x1FF
argument_list|,
literal|0x1FF
argument_list|)
return|;
case|case
name|OP_12
case|:
if|if
condition|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|!=
literal|1
operator|&&
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|!=
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand \"%s\" out of range (use 1 or 2)"
argument_list|)
argument_list|,
name|operand
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator||=
operator|(
name|operand
operator|->
name|exp
operator|.
name|X_add_number
operator|-
literal|1
operator|)
operator|<<
literal|9
expr_stmt|;
return|return
literal|1
return|;
case|case
name|OP_16
case|:
case|case
name|OP_T
case|:
case|case
name|OP_TS
case|:
case|case
name|OP_ASM
case|:
case|case
name|OP_TRN
case|:
case|case
name|OP_DP
case|:
case|case
name|OP_ARP
case|:
comment|/* No encoding necessary.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_insn
parameter_list|(
name|insn
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|flagword
name|oldflags
init|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
decl_stmt|;
name|flagword
name|flags
init|=
name|oldflags
operator||
name|SEC_CODE
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|words
condition|;
name|i
operator|++
control|)
block|{
name|int
name|size
init|=
operator|(
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|unresolved
operator|&&
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|r_type
operator|==
name|BFD_RELOC_TIC54X_23
operator|)
condition|?
literal|4
else|:
literal|2
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|word
operator|<<
literal|16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|unresolved
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|r_nchars
argument_list|,
operator|&
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|addr_expr
argument_list|,
name|FALSE
argument_list|,
name|insn
operator|->
name|opcode
index|[
name|i
index|]
operator|.
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert the operand strings into appropriate opcode values    return the total number of words used by the instruction.  */
end_comment

begin_function
specifier|static
name|int
name|build_insn
parameter_list|(
name|insn
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Only non-parallel instructions support lk addressing.  */
if|if
condition|(
operator|!
operator|(
name|insn
operator|->
name|tm
operator|->
name|flags
operator|&
name|FL_PAR
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|opcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|==
name|OP_Smem
operator|||
name|OPTYPE
argument_list|(
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|==
name|OP_Lmem
operator|||
name|OPTYPE
argument_list|(
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|==
name|OP_Sind
operator|)
operator|&&
name|strchr
argument_list|(
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
literal|'('
argument_list|)
comment|/* Don't mistake stack-relative addressing for lk addressing.  */
operator|&&
name|strncasecmp
argument_list|(
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
literal|"*sp ("
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|insn
operator|->
name|is_lkaddr
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|lkoperand
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|insn
operator|->
name|words
operator|=
name|insn
operator|->
name|tm
operator|->
name|words
operator|+
name|insn
operator|->
name|is_lkaddr
expr_stmt|;
name|insn
operator|->
name|opcode
index|[
literal|0
index|]
operator|.
name|word
operator|=
name|insn
operator|->
name|tm
operator|->
name|opcode
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|tm
operator|->
name|flags
operator|&
name|FL_EXT
condition|)
name|insn
operator|->
name|opcode
index|[
literal|1
operator|+
name|insn
operator|->
name|is_lkaddr
index|]
operator|.
name|word
operator|=
name|insn
operator|->
name|tm
operator|->
name|opcode2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|opcount
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|optype
name|type
init|=
name|insn
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|encode_operand
argument_list|(
name|insn
argument_list|,
name|type
argument_list|,
operator|&
name|insn
operator|->
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|insn
operator|->
name|tm
operator|->
name|flags
operator|&
name|FL_PAR
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|paropcount
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|optype
name|partype
init|=
name|insn
operator|->
name|paroperands
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|encode_operand
argument_list|(
name|insn
argument_list|,
name|partype
argument_list|,
operator|&
name|insn
operator|->
name|paroperands
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|->
name|words
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|optimize_insn
parameter_list|(
name|insn
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
block|{
comment|/* Optimize some instructions, helping out the brain-dead programmer.  */
define|#
directive|define
name|is_zero
parameter_list|(
name|op
parameter_list|)
value|((op).exp.X_op == O_constant&& (op).exp.X_add_number == 0)
if|if
condition|(
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|opcount
operator|>
literal|1
operator|&&
name|is_accumulator
argument_list|(
operator|&
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|is_accumulator
argument_list|(
operator|&
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|strcasecmp
argument_list|(
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|2
index|]
operator|.
name|buf
argument_list|,
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|1
index|]
operator|.
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|insn
operator|->
name|opcount
expr_stmt|;
name|insn
operator|->
name|using_default_dst
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Try to collapse if Xmem and shift count is zero.  */
if|if
condition|(
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|==
name|OP_Xmem
operator|&&
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHFT
operator|&&
name|is_zero
argument_list|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|)
operator|)
comment|/* Or if Smem, shift is zero or absent, and SRC == DST.  */
operator|||
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|==
name|OP_Smem
operator|&&
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHIFT
operator|&&
name|is_type
argument_list|(
operator|&
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|,
name|OP_SHIFT
argument_list|)
operator|&&
name|is_zero
argument_list|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|insn
operator|->
name|opcount
operator|==
literal|3
operator|)
condition|)
block|{
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|=
name|insn
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|insn
operator|->
name|opcount
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
literal|"ld"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|opcount
operator|==
literal|3
operator|&&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|OP_SRC
condition|)
block|{
if|if
condition|(
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHIFT
operator|||
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHFT
operator|)
operator|&&
name|is_zero
argument_list|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|!=
name|OP_lk
operator|||
operator|(
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<=
literal|255
operator|&&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|=
name|insn
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|insn
operator|->
name|opcount
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
literal|"sth"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
literal|"stl"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHIFT
operator|||
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHFT
operator|)
operator|&&
name|is_zero
argument_list|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|=
name|insn
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|insn
operator|->
name|opcount
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
literal|"sub"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|opcount
operator|>
literal|1
operator|&&
name|is_accumulator
argument_list|(
operator|&
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|is_accumulator
argument_list|(
operator|&
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|strcasecmp
argument_list|(
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|2
index|]
operator|.
name|buf
argument_list|,
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|opcount
operator|-
literal|1
index|]
operator|.
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|insn
operator|->
name|opcount
expr_stmt|;
name|insn
operator|->
name|using_default_dst
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|==
name|OP_Smem
operator|&&
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHIFT
operator|)
operator|||
operator|(
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|)
operator|==
name|OP_Xmem
operator|&&
name|OPTYPE
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
operator|==
name|OP_SHFT
operator|)
operator|)
operator|&&
name|is_zero
argument_list|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|insn
operator|->
name|opcount
operator|==
literal|3
condition|)
block|{
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|=
name|insn
operator|->
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|insn
operator|->
name|opcount
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find a matching template if possible, and get the operand strings.  */
end_comment

begin_function
specifier|static
name|int
name|tic54x_parse_insn
parameter_list|(
name|insn
parameter_list|,
name|line
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|insn
operator|->
name|tm
operator|=
operator|(
name|template
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|->
name|tm
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized instruction \"%s\""
argument_list|)
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|opcount
operator|=
name|get_operands
argument_list|(
name|insn
operator|->
name|operands
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|opcount
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check each variation of operands for this mnemonic.  */
while|while
condition|(
name|insn
operator|->
name|tm
operator|->
name|name
operator|&&
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|opcount
operator|>=
name|insn
operator|->
name|tm
operator|->
name|minops
operator|&&
name|insn
operator|->
name|opcount
operator|<=
name|insn
operator|->
name|tm
operator|->
name|maxops
operator|&&
name|operands_match
argument_list|(
name|insn
argument_list|,
operator|&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
name|insn
operator|->
name|opcount
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|operand_types
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|minops
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|maxops
argument_list|)
condition|)
block|{
comment|/* SUCCESS! now try some optimizations.  */
if|if
condition|(
name|optimize_insn
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|->
name|tm
operator|=
operator|(
name|template
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
literal|1
return|;
block|}
operator|++
operator|(
name|insn
operator|->
name|tm
operator|)
expr_stmt|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized operand list '%s' for instruction '%s'"
argument_list|)
argument_list|,
name|line
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We set this in start_line_hook, 'cause if we do a line replacement, we    won't be able to see the next line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parallel_on_next_line_hint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See if this is part of a parallel instruction    Look for a subsequent line starting with "||".  */
end_comment

begin_function
specifier|static
name|int
name|next_line_shows_parallel
parameter_list|(
name|next_line
parameter_list|)
name|char
modifier|*
name|next_line
decl_stmt|;
block|{
comment|/* Look for the second half.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|next_line
argument_list|)
condition|)
operator|++
name|next_line
expr_stmt|;
return|return
operator|(
name|next_line
index|[
literal|0
index|]
operator|==
name|PARALLEL_SEPARATOR
operator|&&
name|next_line
index|[
literal|1
index|]
operator|==
name|PARALLEL_SEPARATOR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic54x_parse_parallel_insn_firstline
parameter_list|(
name|insn
parameter_list|,
name|line
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|insn
operator|->
name|tm
operator|=
operator|(
name|template
operator|*
operator|)
name|hash_find
argument_list|(
name|parop_hash
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|->
name|tm
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized parallel instruction \"%s\""
argument_list|)
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|insn
operator|->
name|tm
operator|->
name|name
operator|&&
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
operator|==
literal|0
condition|)
block|{
name|insn
operator|->
name|opcount
operator|=
name|get_operands
argument_list|(
name|insn
operator|->
name|operands
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|opcount
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|insn
operator|->
name|opcount
operator|==
literal|2
operator|&&
name|operands_match
argument_list|(
name|insn
argument_list|,
operator|&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
name|insn
operator|->
name|opcount
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|operand_types
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
operator|++
operator|(
name|insn
operator|->
name|tm
operator|)
expr_stmt|;
block|}
comment|/* Didn't find a matching parallel; try for a normal insn.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse the second line of a two-line parallel instruction.  */
end_comment

begin_function
specifier|static
name|int
name|tic54x_parse_parallel_insn_lastline
parameter_list|(
name|insn
parameter_list|,
name|line
parameter_list|)
name|tic54x_insn
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|valid_mnemonic
init|=
literal|0
decl_stmt|;
name|insn
operator|->
name|paropcount
operator|=
name|get_operands
argument_list|(
name|insn
operator|->
name|paroperands
argument_list|,
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|->
name|tm
operator|->
name|name
operator|&&
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|name
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|insn
operator|->
name|tm
operator|->
name|parname
argument_list|,
name|insn
operator|->
name|parmnemonic
argument_list|)
operator|==
literal|0
condition|)
block|{
name|valid_mnemonic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|paropcount
operator|>=
name|insn
operator|->
name|tm
operator|->
name|minops
operator|&&
name|insn
operator|->
name|paropcount
operator|<=
name|insn
operator|->
name|tm
operator|->
name|maxops
operator|&&
name|operands_match
argument_list|(
name|insn
argument_list|,
name|insn
operator|->
name|paroperands
argument_list|,
name|insn
operator|->
name|paropcount
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|paroperand_types
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|minops
argument_list|,
name|insn
operator|->
name|tm
operator|->
name|maxops
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
operator|++
operator|(
name|insn
operator|->
name|tm
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_mnemonic
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operand (s) for parallel instruction \"%s\""
argument_list|)
argument_list|,
name|insn
operator|->
name|parmnemonic
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized parallel instruction combination \"%s || %s\""
argument_list|)
argument_list|,
name|insn
operator|->
name|mnemonic
argument_list|,
name|insn
operator|->
name|parmnemonic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If quotes found, return copy of line up to closing quote;    otherwise up until terminator.    If it's a string, pass as-is; otherwise attempt substitution symbol    replacement on the value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|subsym_get_arg
parameter_list|(
name|line
parameter_list|,
name|terminators
parameter_list|,
name|str
parameter_list|,
name|nosub
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|terminators
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|nosub
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|is_string
init|=
operator|*
name|line
operator|==
literal|'"'
decl_stmt|;
name|int
name|is_char
init|=
name|ISDIGIT
argument_list|(
operator|*
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_char
condition|)
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
name|endp
operator|=
name|ptr
expr_stmt|;
operator|*
name|str
operator|=
name|xmalloc
argument_list|(
name|ptr
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|str
argument_list|,
name|line
argument_list|,
name|ptr
operator|-
name|line
argument_list|)
expr_stmt|;
operator|(
operator|*
name|str
operator|)
index|[
name|ptr
operator|-
name|line
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_string
condition|)
block|{
name|char
modifier|*
name|savedp
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|len
decl_stmt|;
name|input_line_pointer
operator|=
name|ptr
expr_stmt|;
operator|*
name|str
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|endp
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|savedp
expr_stmt|;
comment|/* Do forced substitutions if requested.  */
if|if
condition|(
operator|!
name|nosub
operator|&&
operator|*
operator|*
name|str
operator|==
literal|':'
condition|)
operator|*
name|str
operator|=
name|subsym_substitute
argument_list|(
operator|*
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|term
init|=
name|terminators
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
operator|*
name|term
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|term
condition|)
block|{
name|term
operator|=
name|terminators
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
else|else
operator|++
name|term
expr_stmt|;
block|}
name|endp
operator|=
name|ptr
expr_stmt|;
operator|*
name|str
operator|=
name|xmalloc
argument_list|(
name|ptr
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|str
argument_list|,
name|line
argument_list|,
name|ptr
operator|-
name|line
argument_list|)
expr_stmt|;
operator|(
operator|*
name|str
operator|)
index|[
name|ptr
operator|-
name|line
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Do simple substitution, if available.  */
if|if
condition|(
operator|!
name|nosub
operator|&&
operator|(
name|value
operator|=
name|subsym_lookup
argument_list|(
operator|*
name|str
argument_list|,
name|macro_level
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|str
operator|=
name|value
expr_stmt|;
block|}
return|return
name|endp
return|;
block|}
end_function

begin_comment
comment|/* Replace the given substitution string.    We start at the innermost macro level, so that existing locals remain local    Note: we're treating macro args identically to .var's; I don't know if    that's compatible w/TI's assembler.  */
end_comment

begin_function
specifier|static
name|void
name|subsym_create_or_replace
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|macro_level
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|hash_find
argument_list|(
name|subsym_hash
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|hash_replace
argument_list|(
name|subsym_hash
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|hash_find
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
condition|)
name|hash_replace
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|hash_insert
argument_list|(
name|subsym_hash
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up the substitution string replacement for the given symbol.    Start with the innermost macro substitution table given and work    outwards.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|subsym_lookup
parameter_list|(
name|name
parameter_list|,
name|nest_level
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|nest_level
decl_stmt|;
block|{
name|char
modifier|*
name|value
init|=
name|hash_find
argument_list|(
name|subsym_hash
index|[
name|nest_level
index|]
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|||
name|nest_level
operator|==
literal|0
condition|)
return|return
name|value
return|;
return|return
name|subsym_lookup
argument_list|(
name|name
argument_list|,
name|nest_level
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do substitution-symbol replacement on the given line (recursively).    return the argument if no substitution was done     Also look for built-in functions ($func (arg)) and local labels.     If FORCED is set, look for forced substitutions of the form ':SYMBOL:'.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|subsym_substitute
parameter_list|(
name|line
parameter_list|,
name|forced
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|forced
decl_stmt|;
block|{
comment|/* For each apparent symbol, see if it's a substitution symbol, and if so,      replace it in the input.  */
name|char
modifier|*
name|replacement
decl_stmt|;
comment|/* current replacement for LINE.  */
name|char
modifier|*
name|head
decl_stmt|;
comment|/* Start of line.  */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* Current examination point.  */
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* Did we make a substitution?  */
name|int
name|eval_line
init|=
literal|0
decl_stmt|;
comment|/* Is this line a .eval/.asg statement?  */
name|int
name|eval_symbol
init|=
literal|0
decl_stmt|;
comment|/* Are we in the middle of the symbol for                           .eval/.asg?  */
name|char
modifier|*
name|eval_end
init|=
name|NULL
decl_stmt|;
name|int
name|recurse
init|=
literal|1
decl_stmt|;
name|int
name|line_conditional
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* Work with a copy of the input line.  */
name|replacement
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|replacement
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|head
operator|=
name|replacement
expr_stmt|;
comment|/* Flag lines where we might need to replace a single '=' with two;      GAS uses single '=' to assign macro args values, and possibly other      places, so limit what we replace.  */
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|".if"
argument_list|)
operator|||
name|strstr
argument_list|(
name|line
argument_list|,
literal|".elseif"
argument_list|)
operator|||
name|strstr
argument_list|(
name|line
argument_list|,
literal|".break"
argument_list|)
condition|)
name|line_conditional
operator|=
literal|1
expr_stmt|;
comment|/* Watch out for .eval, so that we avoid doing substitution on the      symbol being assigned a value.  */
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|".eval"
argument_list|)
operator|||
name|strstr
argument_list|(
name|line
argument_list|,
literal|".asg"
argument_list|)
condition|)
name|eval_line
operator|=
literal|1
expr_stmt|;
comment|/* If it's a macro definition, don't do substitution on the argument      names.  */
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|".macro"
argument_list|)
condition|)
return|return
name|line
return|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|ptr
index|]
condition|)
block|{
name|int
name|current_char
init|=
operator|*
name|ptr
decl_stmt|;
comment|/* Need to update this since LINE may have been modified.  */
if|if
condition|(
name|eval_line
condition|)
name|eval_end
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* Replace triple double quotes with bounding quote/escapes.  */
if|if
condition|(
name|current_char
operator|==
literal|'"'
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
literal|'"'
operator|&&
name|ptr
index|[
literal|2
index|]
operator|==
literal|'"'
condition|)
block|{
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\\'
expr_stmt|;
name|tmp
operator|=
name|strstr
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
literal|"\"\"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Replace a single '=' with a '=='; 	 for compatibility with older code only.  */
if|if
condition|(
name|line_conditional
operator|&&
name|current_char
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|head
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s==%s"
argument_list|,
name|head
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Continue examining after the '=='.  */
name|ptr
operator|=
name|tmp
operator|+
name|strlen
argument_list|(
name|head
argument_list|)
operator|+
literal|2
expr_stmt|;
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|head
operator|=
name|replacement
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Flag when we've reached the symbol part of .eval/.asg.  */
if|if
condition|(
name|eval_line
operator|&&
name|ptr
operator|>=
name|eval_end
condition|)
name|eval_symbol
operator|=
literal|1
expr_stmt|;
comment|/* For each apparent symbol, see if it's a substitution symbol, and if 	 so, replace it in the input.  */
if|if
condition|(
operator|(
name|forced
operator|&&
name|current_char
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|!
name|forced
operator|&&
name|is_name_beginner
argument_list|(
name|current_char
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Symbol to be replaced.  */
name|char
modifier|*
name|savedp
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
comment|/* Rest of line after symbol.  */
comment|/* Skip the colon.  */
if|if
condition|(
name|forced
condition|)
operator|++
name|ptr
expr_stmt|;
name|name
operator|=
name|input_line_pointer
operator|=
name|ptr
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* '?' is not normally part of a symbol, but it IS part of a local 	     label.  */
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Avoid infinite recursion; if a symbol shows up a second time for 	     substitution, leave it as is.  */
if|if
condition|(
name|hash_find
argument_list|(
name|subsym_recurse_hash
argument_list|,
name|name
argument_list|)
operator|==
name|NULL
condition|)
name|value
operator|=
name|subsym_lookup
argument_list|(
name|name
argument_list|,
name|macro_level
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s symbol recursion stopped at "
literal|"second appearance of '%s'"
argument_list|)
argument_list|,
name|forced
condition|?
literal|"Forced substitution"
else|:
literal|"Substitution"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tail
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|savedp
expr_stmt|;
comment|/* Check for local labels; replace them with the appropriate 	     substitution.  */
if|if
condition|(
operator|(
operator|*
name|name
operator|==
literal|'$'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|||
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
comment|/* Use an existing identifier for that label if, available, or 		 create a new, unique identifier.  */
name|value
operator|=
name|hash_find
argument_list|(
name|local_label_hash
index|[
name|macro_level
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|char
name|digit
index|[
literal|11
index|]
decl_stmt|;
name|char
modifier|*
name|namecopy
init|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|value
operator|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|digit
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|!=
literal|'$'
condition|)
name|value
index|[
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|digit
argument_list|,
literal|".%d"
argument_list|,
name|local_label_id
operator|++
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|value
argument_list|,
name|digit
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|local_label_hash
index|[
name|macro_level
index|]
argument_list|,
name|namecopy
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate where to continue looking for substitutions.  */
name|ptr
operator|=
name|tail
expr_stmt|;
block|}
comment|/* Check for built-in subsym and math functions.  */
elseif|else
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|==
literal|'$'
condition|)
block|{
name|subsym_proc_entry
modifier|*
name|entry
init|=
operator|(
name|subsym_proc_entry
operator|*
operator|)
name|value
decl_stmt|;
name|math_proc_entry
modifier|*
name|math_entry
init|=
name|hash_find
argument_list|(
name|math_hash
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
init|=
name|NULL
decl_stmt|;
operator|*
name|ptr
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized substitution symbol function"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing '(' after substitution symbol function"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|math_entry
operator|!=
name|NULL
condition|)
block|{
name|float
name|arg1
decl_stmt|,
name|arg2
init|=
literal|0
decl_stmt|;
specifier|volatile
name|float
name|fresult
decl_stmt|;
name|arg1
operator|=
operator|(
name|float
operator|)
name|strtod
argument_list|(
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|math_entry
operator|->
name|nargs
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expecting second argument"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|arg2
operator|=
operator|(
name|float
operator|)
name|strtod
argument_list|(
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
block|}
name|fresult
operator|=
call|(
modifier|*
name|math_entry
operator|->
name|proc
call|)
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|math_entry
operator|->
name|int_return
condition|)
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|fresult
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%f"
argument_list|,
name|fresult
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Extra junk in function call, expecting ')'"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Don't bother recursing; the replacement isn't a                      symbol.  */
name|recurse
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|val
decl_stmt|;
name|int
name|arg_type
index|[
literal|2
index|]
init|=
block|{
operator|*
name|ptr
operator|==
literal|'"'
block|,
literal|0
block|}
decl_stmt|;
name|int
name|ismember
init|=
operator|!
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
literal|"$ismember"
argument_list|)
decl_stmt|;
comment|/* Parse one or two args, which must be a substitution 		     symbol, string or a character-string constant.  */
comment|/* For all functions, a string or substitution symbol may be 		     used, with the following exceptions: 		     firstch/lastch: 2nd arg must be character constant 		     ismember: both args must be substitution symbols.  */
name|ptr
operator|=
name|subsym_get_arg
argument_list|(
name|ptr
argument_list|,
literal|",)"
argument_list|,
operator|&
name|arg1
argument_list|,
name|ismember
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
break|break;
if|if
condition|(
name|entry
operator|->
name|nargs
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Function expects two arguments"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Character constants are converted to numerics 			 by the preprocessor.  */
name|arg_type
index|[
literal|1
index|]
operator|=
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
condition|?
literal|2
else|:
operator|(
operator|*
name|ptr
operator|==
literal|'"'
operator|)
expr_stmt|;
name|ptr
operator|=
name|subsym_get_arg
argument_list|(
name|ptr
argument_list|,
literal|")"
argument_list|,
operator|&
name|arg2
argument_list|,
name|ismember
argument_list|)
expr_stmt|;
block|}
comment|/* Args checking.  */
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
literal|"$firstch"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
literal|"$lastch"
argument_list|)
operator|)
operator|&&
name|arg_type
index|[
literal|1
index|]
operator|!=
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expecting character constant argument"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ismember
operator|&&
operator|(
name|arg_type
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|arg_type
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Both arguments must be substitution symbols"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Extra junk in function call, expecting ')'"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
call|(
modifier|*
name|entry
operator|->
name|proc
call|)
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Fix things up to replace the entire expression, not just the 		 function name.  */
name|tail
operator|=
name|ptr
expr_stmt|;
name|c
operator|=
operator|*
name|tail
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
operator|!
name|eval_symbol
condition|)
block|{
comment|/* Replace the symbol with its string replacement and 		 continue.  Recursively replace VALUE until either no 		 substitutions are performed, or a substitution that has been 		 previously made is encountered again.  		 put the symbol into the recursion hash table so we only 		 try to replace a symbol once.  */
if|if
condition|(
name|recurse
condition|)
block|{
name|hash_insert
argument_list|(
name|subsym_recurse_hash
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|subsym_substitute
argument_list|(
name|value
argument_list|,
name|macro_level
operator|>
literal|0
argument_list|)
expr_stmt|;
name|hash_delete
argument_list|(
name|subsym_recurse_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Temporarily zero-terminate where the symbol started.  */
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|forced
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
comment|/* Subscripted substitution symbol -- use just the 			 indicated portion of the string; the description 			 kinda indicates that forced substitution is not 			 supposed to be recursive, but I'm not sure.  */
name|unsigned
name|beg
decl_stmt|,
name|len
init|=
literal|1
decl_stmt|;
comment|/* default to a single char */
name|char
modifier|*
name|newval
init|=
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|savedp
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
name|beg
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|beg
operator|<
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid subscript (use 1 to %d)"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|len
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|beg
operator|+
name|len
operator|>
name|strlen
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid length (use 0 to %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
name|beg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|newval
operator|+=
name|beg
operator|-
literal|1
expr_stmt|;
name|newval
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|tail
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|++
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing ')' in subscripted substitution "
literal|"symbol expression"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|tail
expr_stmt|;
name|input_line_pointer
operator|=
name|savedp
expr_stmt|;
name|value
operator|=
name|newval
expr_stmt|;
block|}
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|head
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|tail
operator|+
literal|1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Make sure forced substitutions are properly terminated.  */
if|if
condition|(
name|forced
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing forced substitution terminator ':'"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|tail
expr_stmt|;
block|}
else|else
comment|/* Restore the character after the symbol end.  */
operator|*
name|tail
operator|=
name|c
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* Continue examining after the replacement value.  */
name|ptr
operator|=
name|tmp
operator|+
name|strlen
argument_list|(
name|head
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|head
operator|=
name|replacement
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|ptr
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
operator|++
name|ptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
return|return
name|replacement
return|;
else|else
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/* We use this to handle substitution symbols    hijack input_line_pointer, replacing it with our substituted string.     .sslist should enable listing the line after replacements are made...     returns the new buffer limit.  */
end_comment

begin_function
name|void
name|tic54x_start_line_hook
parameter_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|replacement
init|=
name|NULL
decl_stmt|;
comment|/* Work with a copy of the input line, including EOL char.  */
name|endp
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|endp
operator|++
index|]
condition|)
empty_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|endp
operator|-
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|line
argument_list|,
name|input_line_pointer
argument_list|,
name|endp
operator|-
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|endp
operator|-
name|input_line_pointer
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Scan ahead for parallel insns.  */
name|parallel_on_next_line_hint
operator|=
name|next_line_shows_parallel
argument_list|(
name|endp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If within a macro, first process forced replacements.  */
if|if
condition|(
name|macro_level
operator|>
literal|0
condition|)
name|replacement
operator|=
name|subsym_substitute
argument_list|(
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|replacement
operator|=
name|line
expr_stmt|;
name|replacement
operator|=
name|subsym_substitute
argument_list|(
name|replacement
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|line
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|replacement
decl_stmt|;
name|char
modifier|*
name|comment
init|=
name|strchr
argument_list|(
name|replacement
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
name|char
name|endc
init|=
name|replacement
index|[
name|strlen
argument_list|(
name|replacement
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
comment|/* Clean up the replacement; we'd prefer to have this done by the 	 standard preprocessing equipment (maybe do_scrub_chars?) 	 but for now, do a quick-and-dirty.  */
if|if
condition|(
name|comment
operator|!=
name|NULL
condition|)
block|{
name|comment
index|[
literal|0
index|]
operator|=
name|endc
expr_stmt|;
name|comment
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|--
name|comment
expr_stmt|;
block|}
else|else
name|comment
operator|=
name|replacement
operator|+
name|strlen
argument_list|(
name|replacement
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Trim trailing whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|comment
argument_list|)
condition|)
block|{
name|comment
index|[
literal|0
index|]
operator|=
name|endc
expr_stmt|;
name|comment
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|--
name|comment
expr_stmt|;
block|}
comment|/* Compact leading whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISSPACE
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|input_line_pointer
operator|=
name|endp
expr_stmt|;
name|input_scrub_insert_line
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Keep track of whether we've done a substitution.  */
name|substitution_line
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* No change.  */
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|substitution_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
specifier|static
name|int
name|repeat_slot
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|delay_slots
init|=
literal|0
decl_stmt|;
comment|/* How many delay slots left to fill?  */
specifier|static
name|int
name|is_parallel
init|=
literal|0
decl_stmt|;
specifier|static
name|tic54x_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|lptr
decl_stmt|;
name|char
modifier|*
name|savedp
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|c
decl_stmt|;
name|input_line_pointer
operator|=
name|line
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|VNONE
condition|)
name|cpu
operator|=
name|V542
expr_stmt|;
if|if
condition|(
name|address_mode_needs_set
condition|)
block|{
name|set_address_mode
argument_list|(
name|amode
argument_list|)
expr_stmt|;
name|address_mode_needs_set
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cpu_needs_set
condition|)
block|{
name|set_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|cpu_needs_set
operator|=
literal|0
expr_stmt|;
block|}
name|assembly_begun
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_parallel
condition|)
block|{
name|is_parallel
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|insn
operator|.
name|parmnemonic
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|lptr
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|savedp
expr_stmt|;
if|if
condition|(
name|tic54x_parse_parallel_insn_lastline
argument_list|(
operator|&
name|insn
argument_list|,
name|lptr
argument_list|)
condition|)
block|{
name|int
name|words
init|=
name|build_insn
argument_list|(
operator|&
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|delay_slots
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|words
operator|>
name|delay_slots
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction does not fit in available delay "
literal|"slots (%d-word insn, %d slots left)"
argument_list|)
argument_list|,
name|words
argument_list|,
name|delay_slots
argument_list|)
expr_stmt|;
name|delay_slots
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|delay_slots
operator|-=
name|words
expr_stmt|;
block|}
block|}
return|return;
block|}
name|memset
argument_list|(
operator|&
name|insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|insn
operator|.
name|mnemonic
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|lptr
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|savedp
expr_stmt|;
comment|/* See if this line is part of a parallel instruction; if so, either this      line or the next line will have the "||" specifier preceding the      mnemonic, and we look for it in the parallel insn hash table.  */
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"||"
argument_list|)
operator|!=
name|NULL
operator|||
name|parallel_on_next_line_hint
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|strstr
argument_list|(
name|line
argument_list|,
literal|"||"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
operator|*
name|tmp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tic54x_parse_parallel_insn_firstline
argument_list|(
operator|&
name|insn
argument_list|,
name|lptr
argument_list|)
condition|)
block|{
name|is_parallel
operator|=
literal|1
expr_stmt|;
comment|/* If the parallel part is on the same line, process it now, 	     otherwise let the assembler pick up the next line for us.  */
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
name|tmp
index|[
literal|2
index|]
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|md_assemble
argument_list|(
name|tmp
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized parallel instruction '%s'"
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|tic54x_parse_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|lptr
argument_list|)
condition|)
block|{
name|int
name|words
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|FL_LP
operator|)
operator|&&
name|cpu
operator|!=
name|V545LP
operator|&&
name|cpu
operator|!=
name|V546LP
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction '%s' requires an LP cpu version"
argument_list|)
argument_list|,
name|insn
operator|.
name|tm
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|FL_FAR
operator|)
operator|&&
name|amode
operator|!=
name|far_mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction '%s' requires far mode addressing"
argument_list|)
argument_list|,
name|insn
operator|.
name|tm
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|words
operator|=
name|build_insn
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* Is this instruction in a delay slot?  */
if|if
condition|(
name|delay_slots
condition|)
block|{
if|if
condition|(
name|words
operator|>
name|delay_slots
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction does not fit in available delay "
literal|"slots (%d-word insn, %d slots left). "
literal|"Resulting behavior is undefined."
argument_list|)
argument_list|,
name|words
argument_list|,
name|delay_slots
argument_list|)
expr_stmt|;
name|delay_slots
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Branches in delay slots are not allowed.  */
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|FL_BMASK
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instructions which cause PC discontinuity are not "
literal|"allowed in a delay slot. "
literal|"Resulting behavior is undefined."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delay_slots
operator|-=
name|words
expr_stmt|;
block|}
comment|/* Is this instruction the target of a repeat?  */
if|if
condition|(
name|repeat_slot
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|FL_NR
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"'%s' is not repeatable. "
literal|"Resulting behavior is undefined."
argument_list|)
argument_list|,
name|insn
operator|.
name|tm
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|is_lkaddr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instructions using long offset modifiers or absolute "
literal|"addresses are not repeatable. "
literal|"Resulting behavior is undefined."
argument_list|)
argument_list|)
expr_stmt|;
name|repeat_slot
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure we check the target of a repeat instruction.  */
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|B_REPEAT
condition|)
block|{
name|repeat_slot
operator|=
literal|1
expr_stmt|;
comment|/* FIXME -- warn if repeat_slot == 1 at EOF.  */
block|}
comment|/* Make sure we check our delay slots for validity.  */
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|flags
operator|&
name|FL_DELAY
condition|)
block|{
name|delay_slots
operator|=
literal|2
expr_stmt|;
comment|/* FIXME -- warn if delay_slots != 0 at EOF.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do a final adjustment on the symbol table; in this case, make sure we have    a ".file" symbol.  */
end_comment

begin_function
name|void
name|tic54x_adjust_symtab
parameter_list|()
block|{
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|lineno
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|filename
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|c_dot_file_symbol
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In order to get gas to ignore any | chars at the start of a line,    this function returns true if a | is found in a line.    This lets us process parallel instructions, which span two lines.  */
end_comment

begin_function
name|int
name|tic54x_unrecognized_line
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|PARALLEL_SEPARATOR
return|;
block|}
end_function

begin_comment
comment|/* Watch for local labels of the form $[0-9] and [_a-zA-Z][_a-zA-Z0-9]*?    Encode their names so that only we see them and can map them to the    appropriate places.    FIXME -- obviously this isn't done yet.  These locals still show up in the    symbol table.  */
end_comment

begin_function
name|void
name|tic54x_define_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* Just in case we need this later; note that this is not necessarily the      same thing as line_label...      When aligning or assigning labels to fields, sometimes the label is      assigned other than the address at which the label appears.      FIXME -- is this really needed? I think all the proper label assignment      is done in tic54x_cons.  */
name|last_label_seen
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to parse something that normal parsing failed at.  */
end_comment

begin_function
name|symbolS
modifier|*
name|tic54x_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Not sure how to handle predefined symbols.  */
if|if
condition|(
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc2_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|cc3_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|misc_symbol_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|sbit_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
name|symbol_new
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
operator|(
name|valueT
operator|)
name|sym
operator|->
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|sym
operator|=
operator|(
name|symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|mmreg_hash
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"a"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"b"
argument_list|)
condition|)
block|{
return|return
name|symbol_new
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
operator|(
name|valueT
operator|)
name|sym
condition|?
name|sym
operator|->
name|value
else|:
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse a name in an expression before the expression parser takes a stab at    it.  */
end_comment

begin_function
name|int
name|tic54x_parse_name
parameter_list|(
name|name
parameter_list|,
name|exp
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|expressionS
modifier|*
name|exp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|literalP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|literalP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
define|#
directive|define
name|MAX_LITTLENUMS
value|2
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|word
decl_stmt|;
comment|/* Only one precision on the c54x.  */
name|int
name|prec
init|=
literal|2
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
literal|4
expr_stmt|;
comment|/* Target data is little-endian, but floats are stored      big-"word"ian.  ugh.  */
for|for
control|(
name|word
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|literalP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|word
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|literalP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
init|=
name|fixP
operator|->
name|fx_r_type
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|sym
expr_stmt|;
comment|/* We assume that all rel->address are host byte offsets.  */
name|rel
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|rel
operator|->
name|address
operator|/=
name|OCTETS_PER_BYTE
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|section
operator|->
name|name
argument_list|)
condition|)
name|rel
operator|->
name|howto
operator|+=
name|HOWTO_BANK
expr_stmt|;
if|if
condition|(
operator|!
name|rel
operator|->
name|howto
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"<unknown>"
expr_stmt|;
name|as_fatal
argument_list|(
literal|"Cannot generate relocation type for symbol %s, code %s"
argument_list|,
name|name
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_comment
comment|/* Handle cons expressions.  */
end_comment

begin_function
name|void
name|tic54x_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|octets
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|octets
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
switch|switch
condition|(
name|octets
condition|)
block|{
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported relocation size %d"
argument_list|)
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_TIC54X_16_OF_23
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_TIC54X_16_OF_23
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* TI assembler always uses this, regardless of addressing mode.  */
if|if
condition|(
name|emitting_long
condition|)
name|r
operator|=
name|BFD_RELOC_TIC54X_23
expr_stmt|;
else|else
comment|/* We never want to directly generate this; this is provided for 	   stabs support only.  */
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|octets
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify or even eliminate a fixup.    To indicate that a fixup has been eliminated, set fixP->fx_done.     If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry.   */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|val
init|=
operator|*
name|valP
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
name|as_fatal
argument_list|(
literal|"Bad relocation type: 0x%02x"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_TIC54X_MS7_OF_23
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x7F
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_TIC54X_16_OF_23
case|:
case|case
name|BFD_RELOC_16
case|:
name|bfd_put_16
argument_list|(
name|stdoutput
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Indicate what we're actually writing, so that we don't get warnings 	 about exceeding available space.  */
operator|*
name|valP
operator|=
name|val
operator|&
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_TIC54X_PARTLS7
case|:
name|bfd_put_16
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_get_16
argument_list|(
name|stdoutput
argument_list|,
name|buf
argument_list|)
operator|&
literal|0xFF80
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7F
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Indicate what we're actually writing, so that we don't get warnings 	 about exceeding available space.  */
operator|*
name|valP
operator|=
name|val
operator|&
literal|0x7F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_TIC54X_PARTMS9
case|:
comment|/* TI assembler doesn't shift its encoding for relocatable files, and is 	 thus incompatible with this implementation's relocatable files.  */
name|bfd_put_16
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_get_16
argument_list|(
name|stdoutput
argument_list|,
name|buf
argument_list|)
operator|&
literal|0xFE00
operator|)
operator||
operator|(
name|val
operator|>>
literal|7
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_TIC54X_23
case|:
name|bfd_put_32
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_get_32
argument_list|(
name|stdoutput
argument_list|,
name|buf
argument_list|)
operator|&
literal|0xFF800000
operator|)
operator||
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is our chance to record section alignment    don't need to do anything here, since BFD does the proper encoding.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|section_size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|section_size
decl_stmt|;
block|{
return|return
name|section_size
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mostly little-endian, but longwords (4 octets) get MS word stored    first.  */
end_comment

begin_function
name|void
name|tic54x_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|4
condition|)
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
block|{
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|val
operator|&
literal|0xFFFF
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|tic54x_estimate_size_before_relax
parameter_list|(
name|frag
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We use this to handle bit allocations which we couldn't handle before due    to symbols being in different frags.  return number of octets added.  */
end_comment

begin_function
name|int
name|tic54x_relax_frag
parameter_list|(
name|frag
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|long
name|stretch
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
init|=
name|frag
operator|->
name|fr_symbol
decl_stmt|;
name|int
name|growth
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bit_info
modifier|*
name|bi
init|=
operator|(
expr|struct
name|bit_info
operator|*
operator|)
name|frag
operator|->
name|fr_opcode
decl_stmt|;
name|int
name|bit_offset
init|=
name|frag_bit_offset
argument_list|(
name|frag_prev
argument_list|(
name|frag
argument_list|,
name|bi
operator|->
name|seg
argument_list|)
argument_list|,
name|bi
operator|->
name|seg
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|prev_frag
init|=
name|bit_offset_frag
argument_list|(
name|frag_prev
argument_list|(
name|frag
argument_list|,
name|bi
operator|->
name|seg
argument_list|)
argument_list|,
name|bi
operator|->
name|seg
argument_list|)
decl_stmt|;
name|int
name|available
init|=
literal|16
operator|-
name|bit_offset
decl_stmt|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|!=
operator|&
name|zero_address_frag
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|frag
operator|->
name|fr_file
argument_list|,
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"non-absolute value used with .space/.bes"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"negative value ignored in %s"
argument_list|)
argument_list|,
name|bi
operator|->
name|type
operator|==
name|TYPE_SPACE
condition|?
literal|".space"
else|:
name|bi
operator|->
name|type
operator|==
name|TYPE_BES
condition|?
literal|".bes"
else|:
literal|".field"
argument_list|)
expr_stmt|;
name|growth
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|tc_frag_data
operator|=
name|frag
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bi
operator|->
name|type
operator|==
name|TYPE_FIELD
condition|)
block|{
comment|/* Bit fields of 16 or larger will have already been handled.  */
if|if
condition|(
name|bit_offset
operator|!=
literal|0
operator|&&
name|available
operator|>=
name|size
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|prev_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
name|bi
operator|->
name|value
decl_stmt|;
name|value
operator|<<=
name|available
operator|-
name|size
expr_stmt|;
name|value
operator||=
operator|(
operator|(
name|unsigned
name|short
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|0
index|]
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prev_frag
operator|->
name|tc_frag_data
operator|+=
name|size
operator|)
operator|==
literal|16
condition|)
name|prev_frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|sym
condition|)
name|symbol_set_frag
argument_list|(
name|bi
operator|->
name|sym
argument_list|,
name|prev_frag
argument_list|)
expr_stmt|;
comment|/* This frag is no longer used.  */
name|growth
operator|=
operator|-
name|frag
operator|->
name|fr_fix
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|value
init|=
name|bi
operator|->
name|value
operator|<<
operator|(
literal|16
operator|-
name|size
operator|)
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frag
operator|->
name|tc_frag_data
operator|=
name|size
operator|)
operator|==
literal|16
condition|)
name|frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
name|growth
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bit_offset
operator|!=
literal|0
operator|&&
name|bit_offset
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|available
operator|>=
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|prev_frag
operator|->
name|tc_frag_data
operator|+=
name|size
operator|)
operator|==
literal|16
condition|)
name|prev_frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|sym
condition|)
name|symbol_set_frag
argument_list|(
name|bi
operator|->
name|sym
argument_list|,
name|prev_frag
argument_list|)
expr_stmt|;
comment|/* This frag is no longer used.  */
name|growth
operator|=
operator|-
name|frag
operator|->
name|fr_fix
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|tc_frag_data
operator|=
literal|0
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
if|if
condition|(
name|bi
operator|->
name|type
operator|==
name|TYPE_SPACE
operator|&&
name|bi
operator|->
name|sym
condition|)
name|symbol_set_frag
argument_list|(
name|bi
operator|->
name|sym
argument_list|,
name|prev_frag
argument_list|)
expr_stmt|;
name|size
operator|-=
name|available
expr_stmt|;
block|}
name|growth
operator|=
operator|(
name|size
operator|+
literal|15
operator|)
operator|/
literal|16
operator|*
name|OCTETS_PER_BYTE
operator|-
name|frag
operator|->
name|fr_fix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|growth
condition|;
name|i
operator|++
control|)
name|frag
operator|->
name|fr_literal
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|=
name|growth
expr_stmt|;
name|frag
operator|->
name|tc_frag_data
operator|=
name|size
operator|%
literal|16
expr_stmt|;
comment|/* Make sure any BES label points to the LAST word allocated.  */
if|if
condition|(
name|bi
operator|->
name|type
operator|==
name|TYPE_BES
operator|&&
name|bi
operator|->
name|sym
condition|)
name|S_SET_VALUE
argument_list|(
name|bi
operator|->
name|sym
argument_list|,
name|frag
operator|->
name|fr_fix
operator|/
name|OCTETS_PER_BYTE
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|getout
label|:
name|frag
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_opcode
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bi
argument_list|)
expr_stmt|;
block|}
return|return
name|growth
return|;
block|}
end_function

begin_function
name|void
name|tic54x_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|seg
parameter_list|,
name|frag
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
comment|/* Offset is in bytes.  */
name|frag
operator|->
name|fr_offset
operator|=
operator|(
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_fix
operator|)
operator|/
name|frag
operator|->
name|fr_var
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_offset
operator|<
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|frag
operator|->
name|fr_file
argument_list|,
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"attempt to .space/.bes backwards? (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|frag
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|fr_type
operator|=
name|rs_space
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to avoid having labels defined for certain directives/pseudo-ops    since once the label is defined, it's in the symbol table for good.  TI    syntax puts the symbol *before* the pseudo (which is kinda like MRI syntax,    I guess, except I've never seen a definition of MRI syntax).     C is the character that used to be at *REST, which points to the end of the    label.     Don't allow labels to start with '.'  */
end_comment

begin_function
name|int
name|tic54x_start_label
parameter_list|(
name|c
parameter_list|,
name|rest
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|rest
decl_stmt|;
block|{
comment|/* If within .struct/.union, no auto line labels, please.  */
if|if
condition|(
name|current_stag
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Disallow labels starting with "."  */
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|char
modifier|*
name|label
init|=
name|rest
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
name|label
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|label
expr_stmt|;
if|if
condition|(
operator|*
name|label
operator|==
literal|'.'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid label '%s'"
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|int
operator|)
name|c
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
while|while
condition|(
name|ISSPACE
argument_list|(
name|c
operator|=
operator|*
operator|++
name|rest
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
comment|/* Don't let colon () define a label for any of these...  */
return|return
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".tag"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|4
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".struct"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|7
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".union"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|6
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".macro"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|6
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".set"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|4
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|".equ"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISSPACE
argument_list|(
name|rest
index|[
literal|4
index|]
argument_list|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

