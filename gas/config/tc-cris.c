begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-cris.c -- Assembler code for the CRIS CPU core.    Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Axis Communications AB, Lund, Sweden.    Originally written for GAS 1.38.1 by Mikael Asker.    Updates, BFDizing, GNUifying and ELF support by Hans-Peter Nilsson.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cris.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_comment
comment|/* Conventions used here:    Generally speaking, pointers to binutils types such as "fragS" and    "expressionS" get parameter and variable names ending in "P", such as    "fragP", to harmonize with the rest of the binutils code.  Other    pointers get a "p" suffix, such as "bufp".  Any function or type-name    that could clash with a current or future binutils or GAS function get    a "cris_" prefix.  */
end_comment

begin_define
define|#
directive|define
name|SYNTAX_RELAX_REG_PREFIX
value|"no_register_prefix"
end_define

begin_define
define|#
directive|define
name|SYNTAX_ENFORCE_REG_PREFIX
value|"register_prefix"
end_define

begin_define
define|#
directive|define
name|SYNTAX_USER_SYM_LEADING_UNDERSCORE
value|"leading_underscore"
end_define

begin_define
define|#
directive|define
name|SYNTAX_USER_SYM_NO_LEADING_UNDERSCORE
value|"no_leading_underscore"
end_define

begin_define
define|#
directive|define
name|REGISTER_PREFIX_CHAR
value|'$'
end_define

begin_comment
comment|/* True for expressions where getting X_add_symbol and X_add_number is    enough to get the "base" and "offset"; no need to make_expr_symbol.    It's not enough to check if X_op_symbol is NULL; that misses unary    operations like O_uminus.  */
end_comment

begin_define
define|#
directive|define
name|SIMPLE_EXPR
parameter_list|(
name|EXP
parameter_list|)
define|\
value|((EXP)->X_op == O_constant || (EXP)->X_op == O_symbol)
end_define

begin_comment
comment|/* Like in ":GOT", ":GOTOFF" etc.  Other ports use '@', but that's in    line_separator_chars for CRIS, so we avoid it.  */
end_comment

begin_define
define|#
directive|define
name|PIC_SUFFIX_CHAR
value|':'
end_define

begin_comment
comment|/* This might be CRIS_INSN_NONE if we're assembling a prefix-insn only.    Note that some prefix-insns might be assembled as CRIS_INSN_NORMAL.  */
end_comment

begin_enum
enum|enum
name|cris_insn_kind
block|{
name|CRIS_INSN_NORMAL
block|,
name|CRIS_INSN_NONE
block|,
name|CRIS_INSN_BRANCH
block|,
name|CRIS_INSN_MUL
block|}
enum|;
end_enum

begin_comment
comment|/* An instruction will have one of these prefixes.    Although the same bit-pattern, we handle BDAP with an immediate    expression (eventually quick or [pc+]) different from when we only have    register expressions.  */
end_comment

begin_enum
enum|enum
name|prefix_kind
block|{
name|PREFIX_NONE
block|,
name|PREFIX_BDAP_IMM
block|,
name|PREFIX_BDAP
block|,
name|PREFIX_BIAP
block|,
name|PREFIX_DIP
block|,
name|PREFIX_PUSH
block|}
enum|;
end_enum

begin_comment
comment|/* The prefix for an instruction.  */
end_comment

begin_struct
struct|struct
name|cris_prefix
block|{
name|enum
name|prefix_kind
name|kind
decl_stmt|;
name|int
name|base_reg_number
decl_stmt|;
name|unsigned
name|int
name|opcode
decl_stmt|;
comment|/* There might be an expression to be evaluated, like I in [rN+I].  */
name|expressionS
name|expr
decl_stmt|;
comment|/* If there's an expression, we might need a relocation.  Here's the      type of what relocation to start relaxaton with.      The relocation is assumed to start immediately after the prefix insn,      so we don't provide an offset.  */
name|enum
name|bfd_reloc_code_real
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The description of the instruction being assembled.  */
end_comment

begin_struct
struct|struct
name|cris_instruction
block|{
comment|/* If CRIS_INSN_NONE, then this insn is of zero length.  */
name|enum
name|cris_insn_kind
name|insn_type
decl_stmt|;
comment|/* If a special register was mentioned, this is its description, else      it is NULL.  */
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|spec_reg
decl_stmt|;
name|unsigned
name|int
name|opcode
decl_stmt|;
comment|/* An insn may have at most one expression; theoretically there could be      another in its prefix (but I don't see how that could happen).  */
name|expressionS
name|expr
decl_stmt|;
comment|/* The expression might need a relocation.  Here's one to start      relaxation with.  */
name|enum
name|bfd_reloc_code_real
name|reloc
decl_stmt|;
comment|/* The size in bytes of an immediate expression, or zero if      nonapplicable.  */
name|int
name|imm_oprnd_size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|cris_archs
block|{
name|arch_cris_unknown
block|,
name|arch_crisv0
block|,
name|arch_crisv3
block|,
name|arch_crisv8
block|,
name|arch_crisv10
block|,
name|arch_cris_any_v0_v10
block|,
name|arch_crisv32
block|,
name|arch_cris_common_v10_v32
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|enum
name|cris_archs
name|cris_arch_from_string
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cris_insn_ver_valid_for_arch
parameter_list|(
name|enum
name|cris_insn_version_usage
parameter_list|,
name|enum
name|cris_archs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_process_instruction
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|cris_instruction
modifier|*
parameter_list|,
name|struct
name|cris_prefix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_bwd_size_modifier
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_bw_size_modifier
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_gen_reg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_spec_reg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|struct
name|cris_spec_reg
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sup_reg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_autoinc_prefix_or_indir_op
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|cris_prefix
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_3op_or_dip_prefix_op
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|cris_prefix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cris_get_expression
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_flags
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_bdap
parameter_list|(
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|branch_disp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_cond_branch_32
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|long
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_number_to_imm
parameter_list|(
name|char
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|,
name|fixS
modifier|*
parameter_list|,
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_create_short_jump
parameter_list|(
name|char
modifier|*
parameter_list|,
name|addressT
parameter_list|,
name|addressT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_syntax
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cris_file
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cris_loc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cris_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Get ":GOT", ":GOTOFF", ":PLT" etc. suffixes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|cris_get_pic_suffix
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|cris_get_pic_reloc_size
parameter_list|(
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* All the .syntax functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|cris_force_reg_prefix
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_relax_reg_prefix
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_sym_leading_underscore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cris_sym_no_leading_underscore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cris_insn_first_word_frag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Handle to the opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we target cris-axis-linux-gnu (as opposed to generic cris-axis-elf),    we default to no underscore and required register-prefixes.  The    difference is in the default values.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TE_LINUX
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_CRIS_AXIS_LINUX_GNU
value|TRUE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_CRIS_AXIS_LINUX_GNU
value|FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether we demand that registers have a `$' prefix.  Default here.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|demand_register_prefix
init|=
name|DEFAULT_CRIS_AXIS_LINUX_GNU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether global user symbols have a leading underscore.  Default here.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|symbols_have_leading_underscore
init|=
operator|!
name|DEFAULT_CRIS_AXIS_LINUX_GNU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not we allow PIC, and expand to PIC-friendly constructs.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|pic
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we're configured for "cris", default to allow all v0..v10    instructions and register names.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_CRIS_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_CRIS_ARCH
value|cris_any_v0_v10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No whitespace in the CONCAT2 parameter list.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|cris_archs
name|cris_arch
init|=
name|XCONCAT2
argument_list|(
name|arch_
argument_list|,
name|DEFAULT_CRIS_ARCH
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"dword"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"syntax"
block|,
name|s_syntax
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_cris_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|s_cris_loc
block|,
literal|0
block|}
block|,
block|{
literal|"arch"
block|,
name|s_cris_arch
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_for_branch_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to emit error when a MULS/MULU could be located last on a    cache-line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|err_for_dangerous_mul_placement
init|=
operator|(
name|XCONCAT2
argument_list|(
name|arch_
argument_list|,
name|DEFAULT_CRIS_ARCH
argument_list|)
operator|!=
name|arch_crisv32
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|cris_comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.  */
end_comment

begin_comment
comment|/* Note that input_file.c hand-checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that slash-star will always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now all floating point support is shut off.  See md_atof.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For CRIS, we encode the relax_substateTs (in e.g. fr_substate) as: 		       2		 1		   0       ---/ /--+-----------------+-----------------+-----------------+ 	      |	 what state ?	|	     how long ?		    |       ---/ /--+-----------------+-----------------+-----------------+     The "how long" bits are 00 = byte, 01 = word, 10 = dword (long).    Not all lengths are legit for a given value of (what state).     Groups for CRIS address relaxing:     1. Bcc (pre-V32)       length: byte, word, 10-byte expansion     2. BDAP       length: byte, word, dword     3. MULS/MULU       Not really a relaxation (no infrastructure to get delay-slots       right), just an alignment and placement checker for the v10       multiply/cache-bug.     4. Bcc (V32 and later)       length: byte, word, 14-byte expansion     5. Bcc (V10+V32)       length: byte, word, error     6. BA (V32)       length: byte, word, dword     7. LAPC (V32)       length: byte, dword   */
end_comment

begin_define
define|#
directive|define
name|STATE_COND_BRANCH
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_BASE_PLUS_DISP_PREFIX
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_MUL
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_COND_BRANCH_V32
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_COND_BRANCH_COMMON
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_ABS_BRANCH_V32
value|(6)
end_define

begin_define
define|#
directive|define
name|STATE_LAPC
value|(7)
end_define

begin_define
define|#
directive|define
name|STATE_COND_BRANCH_PIC
value|(8)
end_define

begin_define
define|#
directive|define
name|STATE_LENGTH_MASK
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_BYTE
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_WORD
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_DWORD
value|(2)
end_define

begin_comment
comment|/* Symbol undefined.  */
end_comment

begin_define
define|#
directive|define
name|STATE_UNDF
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_MAX_LENGTH
value|(3)
end_define

begin_comment
comment|/* These displacements are relative to the address following the opcode    word of the instruction.  The first letter is Byte, Word.  The 2nd    letter is Forward, Backward.  */
end_comment

begin_define
define|#
directive|define
name|BRANCH_BF
value|( 254)
end_define

begin_define
define|#
directive|define
name|BRANCH_BB
value|(-256)
end_define

begin_define
define|#
directive|define
name|BRANCH_BF_V32
value|( 252)
end_define

begin_define
define|#
directive|define
name|BRANCH_BB_V32
value|(-258)
end_define

begin_define
define|#
directive|define
name|BRANCH_WF
value|(2 +  32767)
end_define

begin_define
define|#
directive|define
name|BRANCH_WB
value|(2 + -32768)
end_define

begin_define
define|#
directive|define
name|BRANCH_WF_V32
value|(-2 + 32767)
end_define

begin_define
define|#
directive|define
name|BRANCH_WB_V32
value|(-2 + -32768)
end_define

begin_define
define|#
directive|define
name|BDAP_BF
value|( 127)
end_define

begin_define
define|#
directive|define
name|BDAP_BB
value|(-128)
end_define

begin_define
define|#
directive|define
name|BDAP_WF
value|( 32767)
end_define

begin_define
define|#
directive|define
name|BDAP_WB
value|(-32768)
end_define

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_cris_relax_table
index|[]
init|=
block|{
comment|/* Error sentinel (0, 0).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unused (0, 1).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unused (0, 2).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unused (0, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bcc o (1, 0).  */
block|{
name|BRANCH_BF
block|,
name|BRANCH_BB
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* Bcc [PC+] (1, 1).  */
block|{
name|BRANCH_WF
block|,
name|BRANCH_WB
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* BEXT/BWF, BA, JUMP (external), JUMP (always), Bnot_cc, JUMP (default)      (1, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
comment|/* Unused (1, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BDAP o (2, 0).  */
block|{
name|BDAP_BF
block|,
name|BDAP_BB
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* BDAP.[bw] [PC+] (2, 1).  */
block|{
name|BDAP_WF
block|,
name|BDAP_WB
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* BDAP.d [PC+] (2, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* Unused (2, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MULS/MULU (3, 0).  Positions (3, 1..3) are unused.  */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* V32: Bcc o (4, 0).  */
block|{
name|BRANCH_BF_V32
block|,
name|BRANCH_BB_V32
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* V32: Bcc [PC+] (4, 1).  */
block|{
name|BRANCH_WF_V32
block|,
name|BRANCH_WB_V32
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* V32: BA .+12; NOP; BA32 target; NOP; Bcc .-6  (4, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|}
block|,
comment|/* Unused (4, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* COMMON: Bcc o (5, 0).  The offsets are calculated as for v32.  Code      should contain two nop insns (or four if offset size is large or      unknown) after every label.  */
block|{
name|BRANCH_BF_V32
block|,
name|BRANCH_BB_V32
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* COMMON: Bcc [PC+] (5, 1).  */
block|{
name|BRANCH_WF_V32
block|,
name|BRANCH_WB_V32
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* COMMON: FIXME: ???.  Treat as error currently.  */
block|{
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|}
block|,
comment|/* Unused (5, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* V32: BA o (6, 0).  */
block|{
name|BRANCH_BF_V32
block|,
name|BRANCH_BB_V32
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* V32: BA.W (6, 1).  */
block|{
name|BRANCH_WF_V32
block|,
name|BRANCH_WB_V32
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* V32: BA.D (6, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* Unused (6, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* LAPC: LAPCQ .+0..15*2,Rn  (7, 0).  */
block|{
literal|14
operator|*
literal|2
block|,
operator|-
literal|1
operator|*
literal|2
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* Unused (7, 1).      While there's a shorter sequence, e.g. LAPCQ + an ADDQ or SUBQ,      that would affect flags, so we can't do that as it wouldn't be a      proper insn expansion of LAPCQ.  This row is associated with a      2-byte expansion, so it's unused rather than the next.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* LAPC: LAPC.D (7, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* Unused (7, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PIC for pre-v32: Bcc o (8, 0).  */
block|{
name|BRANCH_BF
block|,
name|BRANCH_BB
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_COND_BRANCH_PIC
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* Bcc [PC+] (8, 1).  */
block|{
name|BRANCH_WF
block|,
name|BRANCH_WB
block|,
literal|2
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_COND_BRANCH_PIC
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* 32-bit expansion, PIC (8, 2).  */
block|{
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|}
block|,
comment|/* Unused (8, 3).  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|BDAP_BF
end_undef

begin_undef
undef|#
directive|undef
name|BDAP_BB
end_undef

begin_undef
undef|#
directive|undef
name|BDAP_WF
end_undef

begin_undef
undef|#
directive|undef
name|BDAP_WB
end_undef

begin_comment
comment|/* Target-specific multicharacter options, not const-declared.  */
end_comment

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_NO_US
value|(OPTION_MD_BASE + 0)
block|{
literal|"no-underscore"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_US
block|}
block|,
define|#
directive|define
name|OPTION_US
value|(OPTION_MD_BASE + 1)
block|{
literal|"underscore"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_US
block|}
block|,
define|#
directive|define
name|OPTION_PIC
value|(OPTION_US + 1)
block|{
literal|"pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
define|#
directive|define
name|OPTION_MULBUG_ABORT_ON
value|(OPTION_PIC + 1)
block|{
literal|"mul-bug-abort"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MULBUG_ABORT_ON
block|}
block|,
define|#
directive|define
name|OPTION_MULBUG_ABORT_OFF
value|(OPTION_MULBUG_ABORT_ON + 1)
block|{
literal|"no-mul-bug-abort"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MULBUG_ABORT_OFF
block|}
block|,
define|#
directive|define
name|OPTION_ARCH
value|(OPTION_MULBUG_ABORT_OFF + 1)
block|{
literal|"march"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ARCH
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not const-declared.  */
end_comment

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"hHN"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At first glance, this may seems wrong and should be 4 (ba + nop); but    since a short_jump must skip a *number* of long jumps, it must also be    a long jump.  Here, we hope to make it a "ba [16bit_offs]" and a "nop"    for the delay slot and hope that the jump table at most needs    32767/4=8191 long-jumps.  A branch is better than a jump, since it is    relative; we will not have a reloc to fix up somewhere.     Note that we can't add relocs, because relaxation uses these fixed    numbers, and md_create_short_jump is called after relaxation.  */
end_comment

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The v32 version has a delay-slot, hence two bytes longer.    The pre-v32 PIC version uses a prefixed insn.  */
end_comment

begin_define
define|#
directive|define
name|cris_any_v0_v10_long_jump_size
value|6
end_define

begin_define
define|#
directive|define
name|cris_any_v0_v10_long_jump_size_pic
value|8
end_define

begin_define
define|#
directive|define
name|crisv32_long_jump_size
value|8
end_define

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
name|XCONCAT2
argument_list|(
name|DEFAULT_CRIS_ARCH
argument_list|,
name|_long_jump_size
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report output format.  Small changes in output format (like elf    variants below) can happen until all options are parsed, but after    that, the output format must remain fixed.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cris_target_format
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
case|case
name|bfd_target_aout_flavour
case|:
return|return
literal|"a.out-cris"
return|;
case|case
name|bfd_target_elf_flavour
case|:
if|if
condition|(
name|symbols_have_leading_underscore
condition|)
return|return
literal|"elf32-us-cris"
return|;
return|return
literal|"elf32-cris"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a bfd_mach_cris... value corresponding to the value of    cris_arch.  */
end_comment

begin_function
name|unsigned
name|int
name|cris_mach
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|retval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cris_arch
condition|)
block|{
case|case
name|arch_cris_common_v10_v32
case|:
name|retval
operator|=
name|bfd_mach_cris_v10_v32
expr_stmt|;
break|break;
case|case
name|arch_crisv32
case|:
name|retval
operator|=
name|bfd_mach_cris_v32
expr_stmt|;
break|break;
case|case
name|arch_crisv10
case|:
case|case
name|arch_cris_any_v0_v10
case|:
name|retval
operator|=
name|bfd_mach_cris_v0_v10
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|cris_arch
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* We need a port-specific relaxation function to cope with sym2 - sym1    relative expressions with both symbols in the same segment (but not    necessarily in the same frag as this insn), for example:      move.d [pc+sym2-(sym1-2)],r10     sym1:    The offset can be 8, 16 or 32 bits long.  */
end_comment

begin_function
name|long
name|cris_relax_frag
parameter_list|(
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|growth
decl_stmt|;
name|offsetT
name|aim
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
name|relax_substateT
name|next_state
decl_stmt|;
name|relax_substateT
name|this_state
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|table
init|=
name|TC_GENERIC_RELAX_TABLE
decl_stmt|;
comment|/* We only have to cope with frags as prepared by      md_estimate_size_before_relax.  The dword cases may get here      because of the different reasons that they aren't relaxable.  */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
comment|/* When we get to these states, the frag won't grow any more.  */
return|return
literal|0
return|;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: fr_symbol %lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
if|if
condition|(
name|symbol_resolved_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: resolved symbol"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|aim
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_MUL
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
comment|/* Nothing to do here.  */
return|return
literal|0
return|;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: fr_subtype %d"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
comment|/* The rest is stolen from relax_frag.  There's no obvious way to      share the code, but fortunately no requirement to keep in sync as      long as fragP->fr_symbol does not have its segment changed.  */
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
expr_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look forwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
expr_stmt|;
if|if
condition|(
name|growth
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Prepare machine-dependent frags for relaxation.     Called just before relaxation starts. Any symbol that is now undefined    will not become defined.     Return the correct fr_subtype in the frag.     Return the initial "guess for fr_var" to caller.  The guess for fr_var    is *actually* the growth beyond fr_fix. Whatever we do to grow fr_fix    or fr_var contributes to our returned value.     Although it may not be explicit in the frag, pretend    fr_var starts with a value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment_type
parameter_list|)
block|{
name|int
name|old_fr_fix
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
define|#
directive|define
name|HANDLE_RELAXABLE
parameter_list|(
name|state
parameter_list|)
define|\
value|case ENCODE_RELAX (state, STATE_UNDF):				\       if (symbolP != NULL						\&& S_GET_SEGMENT (symbolP) == segment_type			\&& !S_IS_WEAK (symbolP))					\
comment|/* The symbol lies in the same segment - a relaxable		\ 	   case.  */
value|\ 	fragP->fr_subtype						\ 	  = ENCODE_RELAX (state, STATE_BYTE);				\       else								\
comment|/* Unknown or not the same segment, so not relaxable.  */
value|\ 	fragP->fr_subtype						\ 	  = ENCODE_RELAX (state, STATE_DWORD);				\       fragP->fr_var							\ 	= md_cris_relax_table[fragP->fr_subtype].rlx_length;		\       break
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_COND_BRANCH
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|)
expr_stmt|;
name|HANDLE_RELAXABLE
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|)
expr_stmt|;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|symbolP
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|segment_type
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* The symbol lies in the same segment - a relaxable case. 	     Check if we currently have an odd offset; we can't code 	     that into the instruction.  Relaxing presumably only cause 	     multiple-of-two changes, so we should only need to adjust 	     for that here.  */
name|bfd_vma
name|target_address
init|=
operator|(
name|symbolP
condition|?
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
else|:
literal|0
operator|)
operator|+
name|fragP
operator|->
name|fr_offset
decl_stmt|;
name|bfd_vma
name|var_part_offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|bfd_vma
name|address_of_var_part
init|=
name|fragP
operator|->
name|fr_address
operator|+
name|var_part_offset
decl_stmt|;
name|long
name|offset
init|=
name|target_address
operator|-
operator|(
name|address_of_var_part
operator|-
literal|2
operator|)
decl_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
operator|(
name|offset
operator|&
literal|1
operator|)
condition|?
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_DWORD
argument_list|)
else|:
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Unknown or not the same segment, so not relaxable.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_DWORD
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_cris_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
comment|/* Note that we can not do anything sane with relaxing 	 [rX + a_known_symbol_in_text], it will have to be a 32-bit 	 value.  	 We could play tricks with managing a constant pool and make 	 a_known_symbol_in_text a "bdap [pc + offset]" pointing there 	 (like the GOT for ELF shared libraries), but that's no use, it 	 would in general be no shorter or faster code, only more 	 complicated.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|absolute_section
condition|)
block|{
comment|/* Go for dword if not absolute or same segment.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_DWORD
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_cris_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|symbol_resolved_p
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
comment|/* The symbol will eventually be completely resolved as an 	     absolute expression, but right now it depends on the result 	     of relaxation and we don't know anything else about the 	     value.  We start relaxation with the assumption that it'll 	     fit in a byte.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|md_cris_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
block|}
else|else
block|{
comment|/* Absolute expression.  */
name|long
name|int
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|symbolP
operator|!=
name|NULL
condition|?
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
else|:
literal|0
operator|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
if|if
condition|(
name|value
operator|>=
operator|-
literal|128
operator|&&
name|value
operator|<=
literal|127
condition|)
block|{
comment|/* Byte displacement.  */
operator|(
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Word or dword displacement.  */
name|int
name|pow2_of_size
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|writep
decl_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|32767
condition|)
block|{
comment|/* Outside word range, make it a dword.  */
name|pow2_of_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Modify the byte-offset BDAP into a word or dword offset 		 BDAP.	Or really, a BDAP rX,8bit into a 		 BDAP.[wd] rX,[PC+] followed by a word or dword.  */
operator|(
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|=
name|BDAP_PC_LOW
operator|+
name|pow2_of_size
operator|*
literal|16
expr_stmt|;
comment|/* Keep the register number in the highest four bits.  */
operator|(
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|1
index|]
operator|&=
literal|0xF0
expr_stmt|;
operator|(
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|1
index|]
operator||=
name|BDAP_INCR_HIGH
expr_stmt|;
comment|/* It grew by two or four bytes.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|<<
name|pow2_of_size
expr_stmt|;
name|writep
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|writep
argument_list|,
name|value
argument_list|,
literal|1
operator|<<
name|pow2_of_size
argument_list|)
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
comment|/* When relaxing a section for the second time, we don't need to 	 do anything except making sure that fr_var is set right.  */
name|fragP
operator|->
name|fr_var
operator|=
name|md_cris_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_MUL
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
comment|/* Nothing to do here.  */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
return|return
name|fragP
operator|->
name|fr_var
operator|+
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform post-processing of machine-dependent frags after relaxation.    Called after relaxation is finished.    In:	Address of frag. 	fr_type == rs_machine_dependent. 	fr_subtype is what the address relaxed to.     Out: Any fixS:s and constants are set up.     The caller will turn the frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* Pointer to first byte in variable-sized part of the frag.  */
name|char
modifier|*
name|var_partp
decl_stmt|;
comment|/* Pointer to first opcode byte in frag.  */
name|char
modifier|*
name|opcodep
decl_stmt|;
comment|/* Used to check integrity of the relaxation.      One of 2 = long, 1 = word, or 0 = byte.  */
name|int
name|length_code
decl_stmt|;
comment|/* Size in bytes of variable-sized part of frag.  */
name|int
name|var_part_size
init|=
literal|0
decl_stmt|;
comment|/* This is part of *fragP.  It contains all information about addresses      and offsets to varying parts.  */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|long
name|var_part_offset
decl_stmt|;
comment|/* Where, in file space, is _var of *fragP?  */
name|unsigned
name|long
name|address_of_var_part
init|=
literal|0
decl_stmt|;
comment|/* Where, in file space, does addr point?  */
name|unsigned
name|long
name|target_address
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|length_code
operator|=
name|fragP
operator|->
name|fr_subtype
operator|&
name|STATE_LENGTH_MASK
expr_stmt|;
name|know
argument_list|(
name|length_code
operator|>=
literal|0
operator|&&
name|length_code
operator|<
name|STATE_MAX_LENGTH
argument_list|)
expr_stmt|;
name|var_part_offset
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|var_partp
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|var_part_offset
expr_stmt|;
name|opcodep
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|target_address
operator|=
operator|(
name|symbolP
condition|?
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
else|:
literal|0
operator|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|address_of_var_part
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|var_part_offset
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|opcodep
index|[
literal|0
index|]
operator|=
name|branch_disp
argument_list|(
operator|(
name|target_address
operator|-
name|address_of_var_part
operator|)
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_WORD
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* We had a quick immediate branch, now turn it into a word one i.e. a 	 PC autoincrement.  */
name|opcodep
index|[
literal|0
index|]
operator|=
name|BRANCH_PC_LOW
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator|&=
literal|0xF0
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator||=
name|BRANCH_INCR_HIGH
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
call|(
name|long
call|)
argument_list|(
name|target_address
operator|-
operator|(
name|address_of_var_part
operator|+
operator|(
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|?
operator|-
literal|2
else|:
literal|2
operator|)
operator|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
name|gen_cond_branch_32
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|var_partp
argument_list|,
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
comment|/* Ten bytes added: a branch, nop and a jump.  */
name|var_part_size
operator|=
literal|2
operator|+
literal|2
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_PIC
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
name|gen_cond_branch_32
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|var_partp
argument_list|,
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
comment|/* Twelve bytes added: a branch, nop and a pic-branch-32.  */
name|var_part_size
operator|=
literal|2
operator|+
literal|2
operator|+
literal|4
operator|+
literal|2
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
name|gen_cond_branch_32
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|var_partp
argument_list|,
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
comment|/* Twelve bytes added: a branch, nop and another branch and nop.  */
name|var_part_size
operator|=
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COND_BRANCH_COMMON
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"Relaxation to long branches for .arch common_v10_v32\  not implemented"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pretend we have twelve bytes for sake of quelling further          errors.  */
name|var_part_size
operator|=
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ABS_BRANCH_V32
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
comment|/* We had a quick immediate branch or a word immediate ba.  Now 	 turn it into a dword one.  */
name|opcodep
index|[
literal|0
index|]
operator|=
name|BA_DWORD_OPCODE
operator|&
literal|255
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator|=
operator|(
name|BA_DWORD_OPCODE
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|symbolP
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|6
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
block|{
name|long
name|offset
init|=
name|target_address
operator|-
operator|(
name|address_of_var_part
operator|-
literal|2
operator|)
decl_stmt|;
comment|/* This is mostly a sanity check; useful occurrences (if there 	   really are any) should have been caught in 	   md_estimate_size_before_relax.  We can (at least 	   theoretically) stumble over invalid code with odd sizes and 	   .p2aligns within the code, so emit an error if that happens. 	   (The generic relaxation machinery is not fit to check this.)  */
if|if
condition|(
name|offset
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"Complicated LAPC target operand is not\  a multiple of two.  Use LAPC.D"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This *is* a sanity check.  Remove when done with.  */
if|if
condition|(
name|offset
operator|>
literal|15
operator|*
literal|2
operator|||
name|offset
operator|<
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error found in md_convert_frag: offset %ld.\   Please report this."
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator||=
operator|(
name|offset
operator|/
literal|2
operator|)
operator|&
literal|0xf
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
block|{
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|LAPC_DWORD_OPCODE
operator|+
operator|(
name|opcodep
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|*
literal|256
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Remember that the reloc is against the position *after* the 	   relocated contents, so we need to adjust to the start of 	   the insn.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|6
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency in %s: bdapq no symbol"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|opcodep
index|[
literal|0
index|]
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* We had a BDAP 8-bit "quick immediate", now turn it into a 16-bit 	 one that uses PC autoincrement.  */
name|opcodep
index|[
literal|0
index|]
operator|=
name|BDAP_PC_LOW
operator|+
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator|&=
literal|0xF0
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator||=
name|BDAP_INCR_HIGH
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency in %s: bdap.w with no symbol"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_DWORD
argument_list|)
case|:
comment|/* We had a BDAP 16-bit "word", change the offset to a dword.  */
name|opcodep
index|[
literal|0
index|]
operator|=
name|BDAP_PC_LOW
operator|+
operator|(
literal|2
operator|<<
literal|4
operator|)
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator|&=
literal|0xF0
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator||=
name|BDAP_INCR_HIGH
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|)
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_MUL
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
comment|/* This is the only time we check position and aligmnent of the 	 placement-tracking frag.  */
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|<
literal|2
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"section alignment must be>= 4 bytes to check MULS/MULU safeness"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the address after the MULS/MULU has alignment which is 	     that of the section and may be that of a cache-size of the 	     buggy versions, then the MULS/MULU can be placed badly.  */
if|if
condition|(
operator|(
name|address_of_var_part
operator|&
operator|(
operator|(
literal|1
operator|<<
name|sec
operator|->
name|alignment_power
operator|)
operator|-
literal|1
operator|)
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"dangerous MULS/MULU location; give it higher alignment"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|var_part_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a short jump around a secondary jump table.    Used by md_create_long_jump.     This used to be md_create_short_jump, but is now called from    md_create_long_jump instead, when sufficient, since the sizes of the    jumps are the same for pre-v32.  */
end_comment

begin_function
specifier|static
name|void
name|cris_create_short_jump
parameter_list|(
name|char
modifier|*
name|storep
parameter_list|,
name|addressT
name|from_addr
parameter_list|,
name|addressT
name|to_addr
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|int
name|distance
decl_stmt|;
comment|/* See md_create_long_jump about the comment on the "+ 2".  */
name|long
name|int
name|max_minimal_minus_distance
decl_stmt|;
name|long
name|int
name|max_minimal_plus_distance
decl_stmt|;
name|int
name|nop_opcode
decl_stmt|;
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
condition|)
block|{
name|max_minimal_minus_distance
operator|=
name|BRANCH_BB_V32
operator|+
literal|2
expr_stmt|;
name|max_minimal_plus_distance
operator|=
name|BRANCH_BF_V32
operator|+
literal|2
expr_stmt|;
name|nop_opcode
operator|=
name|NOP_OPCODE_V32
expr_stmt|;
block|}
else|else
block|{
name|max_minimal_minus_distance
operator|=
name|BRANCH_BB
operator|+
literal|2
expr_stmt|;
name|max_minimal_plus_distance
operator|=
name|BRANCH_BF
operator|+
literal|2
expr_stmt|;
name|nop_opcode
operator|=
name|NOP_OPCODE
expr_stmt|;
block|}
name|distance
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
if|if
condition|(
name|max_minimal_minus_distance
operator|<=
name|distance
operator|&&
name|distance
operator|<=
name|max_minimal_plus_distance
condition|)
block|{
comment|/* Create a "short" short jump: "BA distance - 2".  */
name|storep
index|[
literal|0
index|]
operator|=
name|branch_disp
argument_list|(
name|distance
operator|-
literal|2
argument_list|)
expr_stmt|;
name|storep
index|[
literal|1
index|]
operator|=
name|BA_QUICK_HIGH
expr_stmt|;
comment|/* A nop for the delay slot.  */
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|2
argument_list|,
name|nop_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The extra word should be filled with something sane too.  Make it 	 a nop to keep disassembly sane.  */
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|4
argument_list|,
name|nop_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make it a "long" short jump: "BA (PC+)".  */
name|md_number_to_chars
argument_list|(
name|storep
argument_list|,
name|BA_PC_INCR_OPCODE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ".WORD distance - 4".  */
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|2
argument_list|,
call|(
name|long
call|)
argument_list|(
name|distance
operator|-
literal|4
operator|-
operator|(
name|cris_arch
operator|==
name|arch_crisv32
condition|?
operator|-
literal|4
else|:
literal|0
operator|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* A nop for the delay slot.  */
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|4
argument_list|,
name|nop_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a long jump in a secondary jump table.     storep  Where to store the jump instruction.    from_addr  Address of the jump instruction.    to_addr    Destination address of the jump.    fragP      Which frag the destination address operand 	      lies in.    to_symbol  Destination symbol.  */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|char
modifier|*
name|storep
parameter_list|,
name|addressT
name|from_addr
parameter_list|,
name|addressT
name|to_addr
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
parameter_list|)
block|{
name|long
name|int
name|distance
decl_stmt|;
comment|/* FIXME: What's that "+ 3"?  It comes from the magic numbers that      used to be here, it's just translated to the limit macros used in      the relax table.  But why + 3?  */
name|long
name|int
name|max_short_minus_distance
init|=
name|cris_arch
operator|!=
name|arch_crisv32
condition|?
name|BRANCH_WB
operator|+
literal|3
else|:
name|BRANCH_WB_V32
operator|+
literal|3
decl_stmt|;
name|long
name|int
name|max_short_plus_distance
init|=
name|cris_arch
operator|!=
name|arch_crisv32
condition|?
name|BRANCH_WF
operator|+
literal|3
else|:
name|BRANCH_WF_V32
operator|+
literal|3
decl_stmt|;
comment|/* Bail out for compatibility mode.  (It seems it can be implemented,      perhaps with a 10-byte sequence: "move.d NNNN,$pc/$acr", "jump      $acr", "nop"; but doesn't seem worth it at the moment.)  */
if|if
condition|(
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Out-of-range .word offset handling\  is not implemented for .arch common_v10_v32"
argument_list|)
argument_list|)
expr_stmt|;
name|distance
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
if|if
condition|(
name|max_short_minus_distance
operator|<=
name|distance
operator|&&
name|distance
operator|<=
name|max_short_plus_distance
condition|)
comment|/* Then make it a "short" long jump.  */
name|cris_create_short_jump
argument_list|(
name|storep
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|fragP
argument_list|,
name|to_symbol
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We have a "long" long jump: "JUMP [PC+]".  If CRISv32, always 	 make it a BA.  Else make it an "MOVE [PC=PC+N],P0" if we're supposed 	 to emit PIC code.  */
name|md_number_to_chars
argument_list|(
name|storep
argument_list|,
name|cris_arch
operator|==
name|arch_crisv32
condition|?
name|BA_DWORD_OPCODE
else|:
operator|(
name|pic
condition|?
name|MOVE_PC_INCR_OPCODE_PREFIX
else|:
name|JUMP_PC_INCR_OPCODE
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Follow with a ".DWORD to_addr", PC-relative for PIC.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|storep
operator|+
literal|2
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
name|cris_arch
operator|==
name|arch_crisv32
condition|?
literal|6
else|:
literal|0
argument_list|,
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|pic
condition|?
literal|1
else|:
literal|0
argument_list|,
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|pic
condition|?
name|BFD_RELOC_32_PCREL
else|:
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
comment|/* Follow it with a "NOP" for CRISv32.  */
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
condition|)
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|6
argument_list|,
name|NOP_OPCODE_V32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pic
condition|)
comment|/* ...and the rest of the move-opcode for pre-v32 PIC.  */
name|md_number_to_chars
argument_list|(
name|storep
operator|+
literal|6
argument_list|,
name|MOVE_PC_INCR_OPCODE_SUFFIX
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate space for the first piece of an insn, and mark it as the    start of the insn for debug-format use.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cris_insn_first_word_frag
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|insnp
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/* We need to mark the start of the insn by passing dwarf2_emit_insn      the offset from the current fragment position.  This must be done      after the first fragment is created but before any other fragments      (fixed or varying) are created.  Note that the offset only      corresponds to the "size" of the insn for a fixed-size,      non-expanded insn.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
name|dwarf2_emit_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|insnp
return|;
block|}
end_function

begin_comment
comment|/* Port-specific assembler initialization.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hashret
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Set up a hash table for the instructions.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|op_hash
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable use of ".if ..asm.arch.cris.v32"      and ".if ..asm.arch.cris.common_v10_v32" and a few others.  */
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"..asm.arch.cris.v32"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|cris_arch
operator|==
name|arch_crisv32
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"..asm.arch.cris.v10"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|cris_arch
operator|==
name|arch_crisv10
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"..asm.arch.cris.common_v10_v32"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"..asm.arch.cris.any_v0_v10"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|cris_arch
operator|==
name|arch_cris_any_v0_v10
operator|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|applicable_version
argument_list|,
name|cris_arch
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Need to cast to get rid of "const".  FIXME: Fix hash_insert instead.  */
name|hashret
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cris_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashret
operator|!=
name|NULL
operator|&&
operator|*
name|hashret
operator|!=
literal|'\0'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|hashret
operator|==
literal|0
condition|?
name|_
argument_list|(
literal|"(unknown reason)"
argument_list|)
else|:
name|hashret
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Buggy opcode: `%s' \"%s\"\n"
argument_list|)
argument_list|,
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cris_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a source line.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|cris_instruction
name|output_instruction
decl_stmt|;
name|struct
name|cris_prefix
name|prefix
decl_stmt|;
name|char
modifier|*
name|opcodep
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Do the low-level grunt - assemble to bits and split up into a prefix      and ordinary insn.  */
name|cris_process_instruction
argument_list|(
name|str
argument_list|,
operator|&
name|output_instruction
argument_list|,
operator|&
name|prefix
argument_list|)
expr_stmt|;
comment|/* Handle any prefixes to the instruction.  */
switch|switch
condition|(
name|prefix
operator|.
name|kind
condition|)
block|{
case|case
name|PREFIX_NONE
case|:
break|break;
comment|/* When the expression is unknown for a BDAP, it can need 0, 2 or 4 	 extra bytes, so we handle it separately.  */
case|case
name|PREFIX_BDAP_IMM
case|:
comment|/* We only do it if the relocation is unspecified, i.e. not a PIC 	 relocation.  */
if|if
condition|(
name|prefix
operator|.
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
block|{
name|gen_bdap
argument_list|(
name|prefix
operator|.
name|base_reg_number
argument_list|,
operator|&
name|prefix
operator|.
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|PREFIX_BDAP
case|:
case|case
name|PREFIX_BIAP
case|:
case|case
name|PREFIX_DIP
case|:
name|opcodep
operator|=
name|cris_insn_first_word_frag
argument_list|()
expr_stmt|;
comment|/* Output the prefix opcode.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
operator|(
name|long
operator|)
name|prefix
operator|.
name|opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Having a specified reloc only happens for DIP and for BDAP with 	 PIC operands, but it is ok to drop through here for the other 	 prefixes as they can have no relocs specified.  */
if|if
condition|(
name|prefix
operator|.
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|unsigned
name|int
name|relocsize
init|=
operator|(
name|prefix
operator|.
name|kind
operator|==
name|PREFIX_DIP
condition|?
literal|4
else|:
name|cris_get_pic_reloc_size
argument_list|(
name|prefix
operator|.
name|reloc
argument_list|)
operator|)
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|relocsize
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
name|relocsize
argument_list|,
operator|&
name|prefix
operator|.
name|expr
argument_list|,
literal|0
argument_list|,
name|prefix
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PREFIX_PUSH
case|:
name|opcodep
operator|=
name|cris_insn_first_word_frag
argument_list|()
expr_stmt|;
comment|/* Output the prefix opcode.  Being a "push", we add the negative 	 size of the register to "sp".  */
if|if
condition|(
name|output_instruction
operator|.
name|spec_reg
operator|!=
name|NULL
condition|)
block|{
comment|/* Special register.  */
name|opcodep
index|[
literal|0
index|]
operator|=
operator|-
name|output_instruction
operator|.
name|spec_reg
operator|->
name|reg_size
expr_stmt|;
block|}
else|else
block|{
comment|/* General register.  */
name|opcodep
index|[
literal|0
index|]
operator|=
operator|-
literal|4
expr_stmt|;
block|}
name|opcodep
index|[
literal|1
index|]
operator|=
operator|(
name|REG_SP
operator|<<
literal|4
operator|)
operator|+
operator|(
name|BDAP_QUICK_OPCODE
operator|>>
literal|8
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|prefix
operator|.
name|kind
argument_list|)
expr_stmt|;
block|}
comment|/* If we only had a prefix insn, we're done.  */
if|if
condition|(
name|output_instruction
operator|.
name|insn_type
operator|==
name|CRIS_INSN_NONE
condition|)
return|return;
comment|/* Done with the prefix.  Continue with the main instruction.  */
if|if
condition|(
name|prefix
operator|.
name|kind
operator|==
name|PREFIX_NONE
condition|)
name|opcodep
operator|=
name|cris_insn_first_word_frag
argument_list|()
expr_stmt|;
else|else
name|opcodep
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Output the instruction opcode.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
call|(
name|long
call|)
argument_list|(
name|output_instruction
operator|.
name|opcode
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Output the symbol-dependent instruction stuff.  */
if|if
condition|(
name|output_instruction
operator|.
name|insn_type
operator|==
name|CRIS_INSN_BRANCH
condition|)
block|{
name|segT
name|to_seg
init|=
name|absolute_section
decl_stmt|;
name|int
name|is_undefined
init|=
literal|0
decl_stmt|;
name|int
name|length_code
decl_stmt|;
if|if
condition|(
name|output_instruction
operator|.
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|to_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_seg
operator|==
name|undefined_section
condition|)
name|is_undefined
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|to_seg
operator|==
name|now_seg
operator|||
name|is_undefined
comment|/* In CRISv32, there *is* a 32-bit absolute branch, so don't 	     emit the 12-byte sequence for known symbols in other 	     segments.  */
operator|||
operator|(
name|cris_arch
operator|==
name|arch_crisv32
operator|&&
name|output_instruction
operator|.
name|opcode
operator|==
name|BA_QUICK_OPCODE
operator|)
condition|)
block|{
comment|/* Handle complex expressions.  */
name|valueT
name|addvalue
init|=
operator|(
name|SIMPLE_EXPR
argument_list|(
operator|&
name|output_instruction
operator|.
name|expr
argument_list|)
condition|?
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_number
else|:
literal|0
operator|)
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
operator|(
name|SIMPLE_EXPR
argument_list|(
operator|&
name|output_instruction
operator|.
name|expr
argument_list|)
condition|?
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_symbol
else|:
name|make_expr_symbol
argument_list|(
operator|&
name|output_instruction
operator|.
name|expr
argument_list|)
operator|)
decl_stmt|;
comment|/* If is_undefined, the expression may still become now_seg. 	     That case is handled by md_estimate_size_before_relax.  */
name|length_code
operator|=
name|to_seg
operator|==
name|now_seg
condition|?
name|STATE_BYTE
else|:
name|STATE_UNDF
expr_stmt|;
comment|/* Make room for max twelve bytes of variable length for v32 mode 	     or PIC, ten for v10 and older.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
operator|(
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
operator|||
name|pic
operator|)
condition|?
literal|12
else|:
literal|10
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|cris_arch
operator|==
name|arch_crisv32
condition|?
operator|(
name|output_instruction
operator|.
name|opcode
operator|==
name|BA_QUICK_OPCODE
condition|?
name|STATE_ABS_BRANCH_V32
else|:
name|STATE_COND_BRANCH_V32
operator|)
else|:
operator|(
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|?
name|STATE_COND_BRANCH_COMMON
else|:
operator|(
name|pic
condition|?
name|STATE_COND_BRANCH_PIC
else|:
name|STATE_COND_BRANCH
operator|)
operator|)
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|sym
argument_list|,
name|addvalue
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have: to_seg != now_seg&& to_seg != undefined_section. 	     This means it is a branch to a known symbol in another 	     section, perhaps an absolute address.  Emit a 32-bit branch.  */
name|char
modifier|*
name|cond_jump
init|=
name|frag_more
argument_list|(
operator|(
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
operator|||
name|pic
operator|)
condition|?
literal|12
else|:
literal|10
argument_list|)
decl_stmt|;
name|gen_cond_branch_32
argument_list|(
name|opcodep
argument_list|,
name|cond_jump
argument_list|,
name|frag_now
argument_list|,
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|output_instruction
operator|.
name|insn_type
operator|==
name|CRIS_INSN_MUL
operator|&&
name|err_for_dangerous_mul_placement
condition|)
comment|/* Create a frag which which we track the location of the mul insn        (in the last two bytes before the mul-frag).  */
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_MUL
argument_list|,
name|STATE_BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|output_instruction
operator|.
name|imm_oprnd_size
operator|>
literal|0
condition|)
block|{
comment|/* The instruction has an immediate operand.  */
name|enum
name|bfd_reloc_code_real
name|reloc
init|=
name|BFD_RELOC_NONE
decl_stmt|;
switch|switch
condition|(
name|output_instruction
operator|.
name|imm_oprnd_size
condition|)
block|{
comment|/* Any byte-size immediate constants are treated as 		 word-size.  FIXME: Thus overflow check does not work 		 correctly.  */
case|case
literal|2
case|:
comment|/* Note that size-check for the explicit reloc has already 		 been done when we get here.  */
if|if
condition|(
name|output_instruction
operator|.
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
name|reloc
operator|=
name|output_instruction
operator|.
name|reloc
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Allow a relocation specified in the operand.  */
if|if
condition|(
name|output_instruction
operator|.
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
name|reloc
operator|=
name|output_instruction
operator|.
name|reloc
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|output_instruction
operator|.
name|imm_oprnd_size
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|output_instruction
operator|.
name|imm_oprnd_size
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
name|output_instruction
operator|.
name|imm_oprnd_size
argument_list|,
operator|&
name|output_instruction
operator|.
name|expr
argument_list|,
name|reloc
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|reloc
operator|==
name|BFD_RELOC_16_PCREL
operator|||
name|reloc
operator|==
name|BFD_RELOC_8_PCREL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_instruction
operator|.
name|reloc
operator|==
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
operator|&&
name|output_instruction
operator|.
name|expr
operator|.
name|X_md
operator|!=
literal|0
condition|)
block|{
comment|/* Handle complex expressions.  */
name|valueT
name|addvalue
init|=
operator|(
name|output_instruction
operator|.
name|expr
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|?
literal|0
else|:
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_number
operator|)
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
operator|(
name|output_instruction
operator|.
name|expr
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|?
name|make_expr_symbol
argument_list|(
operator|&
name|output_instruction
operator|.
name|expr
argument_list|)
else|:
name|output_instruction
operator|.
name|expr
operator|.
name|X_add_symbol
operator|)
decl_stmt|;
comment|/* This is a relaxing construct, so we need a frag_var rather 	     than the fix_new_exp call below.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_LAPC
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|sym
argument_list|,
name|addvalue
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_instruction
operator|.
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
comment|/* An immediate operand that has a relocation and needs to be 	     processed further.  */
comment|/* It is important to use fix_new_exp here and everywhere else 	     (and not fix_new), as fix_new_exp can handle "difference 	     expressions" - where the expression contains a difference of 	     two symbols in the same segment.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
name|opcodep
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|2
argument_list|,
operator|&
name|output_instruction
operator|.
name|expr
argument_list|,
name|output_instruction
operator|.
name|reloc
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|output_instruction
operator|.
name|reloc
operator|==
name|BFD_RELOC_16_PCREL
operator|||
name|output_instruction
operator|.
name|reloc
operator|==
name|BFD_RELOC_8_PCREL
operator|||
operator|(
name|output_instruction
operator|.
name|reloc
operator|==
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
operator|)
argument_list|,
name|output_instruction
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Low level text-to-bits assembly.  */
end_comment

begin_function
specifier|static
name|void
name|cris_process_instruction
parameter_list|(
name|char
modifier|*
name|insn_text
parameter_list|,
name|struct
name|cris_instruction
modifier|*
name|out_insnp
parameter_list|,
name|struct
name|cris_prefix
modifier|*
name|prefixp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|modified_char
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|struct
name|cris_opcode
modifier|*
name|instruction
decl_stmt|;
name|char
modifier|*
name|operands
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|size_bits
decl_stmt|;
comment|/* Reset these fields to a harmless state in case we need to return in      error.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_NONE
expr_stmt|;
name|prefixp
operator|->
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|out_insnp
operator|->
name|insn_type
operator|=
name|CRIS_INSN_NONE
expr_stmt|;
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|0
expr_stmt|;
comment|/* Find the end of the opcode mnemonic.  We assume (true in 2.9.1)      that the caller has translated the opcode to lower-case, up to the      first non-letter.  */
for|for
control|(
name|operands
operator|=
name|insn_text
init|;
name|ISLOWER
argument_list|(
operator|*
name|operands
argument_list|)
condition|;
operator|++
name|operands
control|)
empty_stmt|;
comment|/* Terminate the opcode after letters, but save the character there if      it was of significance.  */
switch|switch
condition|(
operator|*
name|operands
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'.'
case|:
comment|/* Put back the modified character later.  */
name|modified_char
operator|=
operator|*
name|operands
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|' '
case|:
comment|/* Consume the character after the mnemonic 	 and replace it with '\0'.  */
operator|*
name|operands
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|insn_text
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the instruction.  */
name|instruction
operator|=
operator|(
expr|struct
name|cris_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|insn_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|insn_text
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Put back the modified character.  */
switch|switch
condition|(
name|modified_char
condition|)
block|{
case|case
literal|0
case|:
break|break;
default|default:
operator|*
operator|--
name|operands
operator|=
name|modified_char
expr_stmt|;
block|}
comment|/* Try to match an opcode table slot.  */
for|for
control|(
name|s
operator|=
name|operands
init|;
condition|;
control|)
block|{
name|int
name|imm_expr_found
decl_stmt|;
comment|/* Initialize *prefixp, perhaps after being modified for a 	 "near match".  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_NONE
expr_stmt|;
name|prefixp
operator|->
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* Initialize *out_insnp.  */
name|memset
argument_list|(
name|out_insnp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|out_insnp
argument_list|)
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|opcode
operator|=
name|instruction
operator|->
name|match
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|out_insnp
operator|->
name|insn_type
operator|=
name|CRIS_INSN_NORMAL
expr_stmt|;
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|0
expr_stmt|;
name|imm_expr_found
operator|=
literal|0
expr_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the 	 operands match.  */
for|for
control|(
name|args
operator|=
name|instruction
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* If we've come to the end of arguments, we're done.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|match
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* Non-matcher character for disassembly. 		 Ignore it here.  */
continue|continue;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|','
case|:
case|case
literal|' '
case|:
comment|/* These must match exactly.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
case|case
literal|'A'
case|:
comment|/* "ACR", case-insensitive. 		 Handle a sometimes-mandatory dollar sign as register 		 prefix.  */
if|if
condition|(
operator|*
name|s
operator|==
name|REGISTER_PREFIX_CHAR
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|demand_register_prefix
condition|)
break|break;
if|if
condition|(
operator|(
operator|*
name|s
operator|++
operator|!=
literal|'a'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'A'
operator|)
operator|||
operator|(
operator|*
name|s
operator|++
operator|!=
literal|'c'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'C'
operator|)
operator|||
operator|(
operator|*
name|s
operator|++
operator|!=
literal|'r'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'R'
operator|)
condition|)
break|break;
continue|continue;
case|case
literal|'B'
case|:
comment|/* This is not really an operand, but causes a "BDAP 		 -size,SP" prefix to be output, for PUSH instructions.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_PUSH
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
comment|/* This letter marks an operand that should not be matched 		 in the assembler. It is a branch with 16-bit 		 displacement.  The assembler will create them from the 		 8-bit flavor when necessary.  The assembler does not 		 support the [rN+] operand, as the [r15+] that is 		 generated for 16-bit displacements.  */
break|break;
case|case
literal|'c'
case|:
comment|/* A 5-bit unsigned immediate in bits<4:0>.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|31
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 5 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_UNSIGNED_5
expr_stmt|;
continue|continue;
block|}
case|case
literal|'C'
case|:
comment|/* A 4-bit unsigned immediate in bits<3:0>.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|15
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 4 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_UNSIGNED_4
expr_stmt|;
continue|continue;
block|}
comment|/* For 'd', check for an optional ".d" or ".D" at the                  start of the operands, followed by a space character.  */
case|case
literal|'d'
case|:
if|if
condition|(
name|modified_char
operator|==
literal|'.'
operator|&&
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|||
operator|!
name|ISSPACE
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
continue|continue;
case|case
literal|'D'
case|:
comment|/* General register in bits<15:12> and<3:0>.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
comment|/*<< 0 */
expr_stmt|;
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
operator|<<
literal|12
expr_stmt|;
continue|continue;
block|}
case|case
literal|'f'
case|:
comment|/* Flags from the condition code register.  */
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|get_flags
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
break|break;
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
operator|(
name|flags
operator|&
literal|0xf0
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|flags
operator|&
literal|0xf
operator|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'i'
case|:
comment|/* A 6-bit signed immediate in bits<5:0>.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|32
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|31
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 6 bit range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_SIGNED_6
expr_stmt|;
continue|continue;
block|}
case|case
literal|'I'
case|:
comment|/* A 6-bit unsigned immediate in bits<5:0>.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|63
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 6 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_UNSIGNED_6
expr_stmt|;
continue|continue;
block|}
case|case
literal|'M'
case|:
comment|/* A size modifier, B, W or D, to be put in a bit position 		 suitable for CLEAR instructions (i.e. reflecting a zero 		 register).  */
if|if
condition|(
operator|!
name|get_bwd_size_modifier
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
break|break;
else|else
block|{
switch|switch
condition|(
name|size_bits
condition|)
block|{
case|case
literal|0
case|:
name|out_insnp
operator|->
name|opcode
operator||=
literal|0
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|out_insnp
operator|->
name|opcode
operator||=
literal|4
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out_insnp
operator|->
name|opcode
operator||=
literal|8
operator|<<
literal|12
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
case|case
literal|'m'
case|:
comment|/* A size modifier, B, W or D, to be put in bits<5:4>.  */
if|if
condition|(
name|modified_char
operator|!=
literal|'.'
operator|||
operator|!
name|get_bwd_size_modifier
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
continue|continue;
block|}
case|case
literal|'o'
case|:
comment|/* A branch expression.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|insn_type
operator|=
name|CRIS_INSN_BRANCH
expr_stmt|;
continue|continue;
block|}
case|case
literal|'Q'
case|:
comment|/* A 8-bit quick BDAP expression, "expr,R".  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
condition|)
break|break;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
break|break;
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
operator|<<
literal|12
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_SIGNED_8
expr_stmt|;
continue|continue;
case|case
literal|'O'
case|:
comment|/* A BDAP expression for any size, "expr,R".  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
condition|)
break|break;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|prefixp
operator|->
name|base_reg_number
argument_list|)
condition|)
break|break;
comment|/* Since 'O' is used with an explicit bdap, we have no 		     "real" instruction.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
name|BDAP_QUICK_OPCODE
operator||
operator|(
name|prefixp
operator|->
name|base_reg_number
operator|<<
literal|12
operator|)
expr_stmt|;
name|out_insnp
operator|->
name|insn_type
operator|=
name|CRIS_INSN_NONE
expr_stmt|;
continue|continue;
block|}
case|case
literal|'P'
case|:
comment|/* Special register in bits<15:12>.  */
if|if
condition|(
operator|!
name|get_spec_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|spec_reg
argument_list|)
condition|)
break|break;
else|else
block|{
comment|/* Use of some special register names come with a 		     specific warning.	Note that we have no ".cpu type" 		     pseudo yet, so some of this is just unused 		     framework.  */
if|if
condition|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|warning
condition|)
name|as_warn
argument_list|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|applicable_version
operator|==
name|cris_ver_warning
condition|)
comment|/* Others have a generic warning.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unimplemented register `%s' specified"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|spec_reg
operator|->
name|name
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|opcode
operator||=
name|out_insnp
operator|->
name|spec_reg
operator|->
name|number
operator|<<
literal|12
expr_stmt|;
continue|continue;
block|}
case|case
literal|'p'
case|:
comment|/* This character is used in the disassembler to 		 recognize a prefix instruction to fold into the 		 addressing mode for the next instruction.  It is 		 ignored here.  */
continue|continue;
case|case
literal|'R'
case|:
comment|/* General register in bits<15:12>.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
operator|<<
literal|12
expr_stmt|;
continue|continue;
block|}
case|case
literal|'r'
case|:
comment|/* General register in bits<3:0>.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
comment|/*<< 0 */
expr_stmt|;
continue|continue;
block|}
case|case
literal|'S'
case|:
comment|/* Source operand in bit<10> and a prefix; a 3-operand 		 prefix.  */
if|if
condition|(
operator|!
name|get_3op_or_dip_prefix_op
argument_list|(
operator|&
name|s
argument_list|,
name|prefixp
argument_list|)
condition|)
break|break;
else|else
continue|continue;
case|case
literal|'s'
case|:
comment|/* Source operand in bits<10>,<3:0> and optionally a 		 prefix; i.e. an indirect operand or an side-effect 		 prefix (where valid).  */
if|if
condition|(
operator|!
name|get_autoinc_prefix_or_indir_op
argument_list|(
operator|&
name|s
argument_list|,
name|prefixp
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|imm_expr_found
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|prefixp
operator|->
name|kind
operator|!=
name|PREFIX_NONE
condition|)
block|{
comment|/* A prefix, so it has the autoincrement bit 			 set.  */
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
name|AUTOINCR_BIT
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No prefix.  The "mode" variable contains bits like 			 whether or not this is autoincrement mode.  */
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
name|mode
operator|<<
literal|10
operator|)
expr_stmt|;
comment|/* If there was a PIC reloc specifier, then it was 			 attached to the prefix.  Note that we can't check 			 that the reloc size matches, since we don't have 			 all the operands yet in all cases.  */
if|if
condition|(
name|prefixp
operator|->
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
name|out_insnp
operator|->
name|reloc
operator|=
name|prefixp
operator|->
name|reloc
expr_stmt|;
block|}
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
comment|/*<< 0 */
expr_stmt|;
continue|continue;
block|}
case|case
literal|'N'
case|:
case|case
literal|'Y'
case|:
comment|/* Like 's', but immediate operand only.  Also does not 		 modify insn.  There are no insns where a PIC reloc 		 specifier makes sense.  */
if|if
condition|(
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
block|{
name|imm_expr_found
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* Like 'N', but PC-relative to the start of the insn. 		 There might be a :PLT to request a PLT entry.  */
if|if
condition|(
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
block|{
name|imm_expr_found
operator|=
literal|1
expr_stmt|;
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
comment|/* We have to adjust the expression, because that 		     relocation is to the location *after* the 		     relocation.  So add 2 for the insn and 4 for the 		     relocation.  */
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|pic
operator|&&
operator|*
name|s
operator|==
name|PIC_SUFFIX_CHAR
condition|)
name|cris_get_pic_suffix
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|reloc
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* Maybe 'u', maybe 'n'.  Only for LAPC/LAPCQ.  */
if|if
condition|(
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
block|{
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
expr_stmt|;
comment|/* Define 1 as relaxing.  */
name|out_insnp
operator|->
name|expr
operator|.
name|X_md
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'u'
case|:
comment|/* Four PC-relative bits in<3:0> representing<4:1>:0 of 		 an offset relative to the beginning of the current 		 insn.  */
if|if
condition|(
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
condition|)
block|{
name|out_insnp
operator|->
name|reloc
operator|=
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
expr_stmt|;
comment|/* Define 0 as non-relaxing.  */
name|out_insnp
operator|->
name|expr
operator|.
name|X_md
operator|=
literal|0
expr_stmt|;
comment|/* We have to adjust the expression, because that 		     relocation is to the location *after* the 		     insn.  So add 2 for the insn.  */
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'x'
case|:
comment|/* Rs.m in bits<15:12> and<5:4>.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
operator|||
operator|!
name|get_bwd_size_modifier
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
name|regno
operator|<<
literal|12
operator|)
operator||
operator|(
name|size_bits
operator|<<
literal|4
operator|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'y'
case|:
comment|/* Source operand in bits<10>,<3:0> and optionally a 		 prefix; i.e. an indirect operand or an side-effect 		 prefix.  		 The difference to 's' is that this does not allow an 		 "immediate" expression.  */
if|if
condition|(
operator|!
name|get_autoinc_prefix_or_indir_op
argument_list|(
operator|&
name|s
argument_list|,
name|prefixp
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|imm_expr_found
argument_list|,
operator|&
name|out_insnp
operator|->
name|expr
argument_list|)
operator|||
name|imm_expr_found
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|prefixp
operator|->
name|kind
operator|!=
name|PREFIX_NONE
condition|)
block|{
comment|/* A prefix, and those matched here always have 			 side-effects (see 's' case).  */
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
name|AUTOINCR_BIT
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No prefix.  The "mode" variable contains bits 			 like whether or not this is autoincrement 			 mode.  */
name|out_insnp
operator|->
name|opcode
operator||=
operator|(
name|mode
operator|<<
literal|10
operator|)
expr_stmt|;
block|}
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
comment|/*<< 0 */
expr_stmt|;
continue|continue;
block|}
case|case
literal|'z'
case|:
comment|/* Size modifier (B or W) in bit<4>.  */
if|if
condition|(
operator|!
name|get_bw_size_modifier
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
break|break;
else|else
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
continue|continue;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
operator|&&
name|get_sup_reg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
block|{
name|out_insnp
operator|->
name|opcode
operator||=
name|regno
operator|<<
literal|12
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* We get here when we fail a match above or we found a 	     complete match.  Break out of this loop.  */
break|break;
block|}
comment|/* Was it a match or a miss?  */
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* If it's just that the args don't match, maybe the next 	     item in the table is the same opcode but with 	     matching operands.  First skip any invalid ones.  */
while|while
condition|(
name|instruction
index|[
literal|1
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|instruction
operator|->
name|name
argument_list|,
name|instruction
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|instruction
index|[
literal|1
index|]
operator|.
name|applicable_version
argument_list|,
name|cris_arch
argument_list|)
condition|)
operator|++
name|instruction
expr_stmt|;
if|if
condition|(
name|instruction
index|[
literal|1
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|instruction
operator|->
name|name
argument_list|,
name|instruction
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|cris_insn_ver_valid_for_arch
argument_list|(
name|instruction
index|[
literal|1
index|]
operator|.
name|applicable_version
argument_list|,
name|cris_arch
argument_list|)
condition|)
block|{
comment|/* Yep.  Restart and try that one instead.  */
operator|++
name|instruction
expr_stmt|;
name|s
operator|=
name|operands
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* We've come to the end of instructions with this 		 opcode, so it must be an error.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As discard_rest_of_line, but without continuing to the 		 next line.  */
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* We have a match.  Check if there's anything more to do.  */
if|if
condition|(
name|imm_expr_found
condition|)
block|{
comment|/* There was an immediate mode operand, so we must check 		 that it has an appropriate size.  */
switch|switch
condition|(
name|instruction
operator|->
name|imm_oprnd_size
condition|)
block|{
default|default:
case|case
name|SIZE_NONE
case|:
comment|/* Shouldn't happen; this one does not have immediate 		     operands with different sizes.  */
name|BAD_CASE
argument_list|(
name|instruction
operator|->
name|imm_oprnd_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZE_FIX_32
case|:
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|SIZE_SPEC_REG
case|:
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
condition|)
comment|/* All immediate loads of special registers are 		       32-bit on CRISv32.  */
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|4
expr_stmt|;
else|else
switch|switch
condition|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|reg_size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|128
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 8 bit range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
comment|/* FIXME:  We need an indicator in the instruction 			   table to pass on, to indicate if we need to check 			   overflow for a signed or unsigned number.  */
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|65535
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 16 bit range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|reg_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIZE_FIELD
case|:
case|case
name|SIZE_FIELD_SIGNED
case|:
case|case
name|SIZE_FIELD_UNSIGNED
case|:
switch|switch
condition|(
name|size_bits
condition|)
block|{
comment|/* FIXME: Find way to pass un/signedness to 			 caller, and set reloc type instead, postponing 			 this check until cris_number_to_imm.  That 			 necessarily corrects the reloc type for the 			 byte case, maybe requiring further changes.  */
case|case
literal|0
case|:
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|128
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 8 bit range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD_SIGNED
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|128
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|127
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 8 bit signed range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD_UNSIGNED
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|255
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 8 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|1
case|:
if|if
condition|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|65535
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 16 bit range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD_SIGNED
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|32767
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 16 bit signed range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIELD_UNSIGNED
operator|&&
operator|(
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
operator|>
literal|65535
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value not in 16 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|out_insnp
operator|->
name|expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|out_insnp
operator|->
name|imm_oprnd_size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|out_insnp
operator|->
name|spec_reg
operator|->
name|reg_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there was a relocation specified for the immediate 		 expression (i.e. it had a PIC modifier) check that the 		 size of the PIC relocation matches the size specified by 		 the opcode.  */
if|if
condition|(
name|out_insnp
operator|->
name|reloc
operator|!=
name|BFD_RELOC_NONE
operator|&&
operator|(
name|cris_get_pic_reloc_size
argument_list|(
name|out_insnp
operator|->
name|reloc
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|out_insnp
operator|->
name|imm_oprnd_size
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC relocation size does not match operand size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|op
operator|==
name|cris_muls_op
operator|||
name|instruction
operator|->
name|op
operator|==
name|cris_mulu_op
condition|)
name|out_insnp
operator|->
name|insn_type
operator|=
name|CRIS_INSN_MUL
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Get a B, W, or D size modifier from the string pointed out by *cPP,    which must point to a '.' in front of the modifier.	On successful    return, *cPP is advanced to the character following the size    modifier, and is undefined otherwise.     cPP		Pointer to pointer to string starting 		with the size modifier.     size_bitsp	Pointer to variable to contain the size bits on 		successful return.     Return 1 iff a correct size modifier is found, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|get_bwd_size_modifier
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|int
modifier|*
name|size_bitsp
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Consume the '.'.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|cPP
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
operator|*
name|size_bitsp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
operator|*
name|size_bitsp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
operator|*
name|size_bitsp
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Consume the size letter.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a B or W size modifier from the string pointed out by *cPP,    which must point to a '.' in front of the modifier.	On successful    return, *cPP is advanced to the character following the size    modifier, and is undefined otherwise.     cPP		Pointer to pointer to string starting 		with the size modifier.     size_bitsp	Pointer to variable to contain the size bits on 		successful return.     Return 1 iff a correct size modifier is found, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|get_bw_size_modifier
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|int
modifier|*
name|size_bitsp
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Consume the '.'.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|cPP
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
operator|*
name|size_bitsp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
operator|*
name|size_bitsp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Consume the size letter.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a general register from the string pointed out by *cPP.  The    variable *cPP is advanced to the character following the general    register name on a successful return, and has its initial position    otherwise.     cPP	    Pointer to pointer to string, beginning with a general 	    register name.     regnop   Pointer to int containing the register number.     Return 1 iff a correct general register designator is found, 	    else 0.  */
end_comment

begin_function
specifier|static
name|int
name|get_gen_reg
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|int
modifier|*
name|regnop
parameter_list|)
block|{
name|char
modifier|*
name|oldp
decl_stmt|;
name|oldp
operator|=
operator|*
name|cPP
expr_stmt|;
comment|/* Handle a sometimes-mandatory dollar sign as register prefix.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
name|REGISTER_PREFIX_CHAR
condition|)
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|demand_register_prefix
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
operator|*
operator|*
name|cPP
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
comment|/* "P" as in "PC"?  Consume the "P".  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|cPP
operator|==
literal|'C'
operator|||
operator|*
operator|*
name|cPP
operator|==
literal|'c'
operator|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
operator|(
operator|*
name|cPP
operator|)
index|[
literal|1
index|]
argument_list|)
comment|/* Here's a little twist: For v32 and the compatibility mode, 	     we only recognize PC as a register number if there's '+]' 	     after.  We don't consume that, but the presence can only be 	     valid after a register in a post-increment context, which 	     is also the only valid context for PC as a register for 	     v32.  Not that it's used very often, but saying "MOVE.D 	     [PC+],R5" should remain valid.  It's not supported for 	     jump-type insns or other insns with no [Rn+] mode, though.  */
operator|&&
operator|(
operator|(
name|cris_arch
operator|!=
name|arch_crisv32
operator|&&
name|cris_arch
operator|!=
name|arch_cris_common_v10_v32
operator|)
operator|||
operator|(
operator|(
operator|*
name|cPP
operator|)
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
operator|(
operator|*
name|cPP
operator|)
index|[
literal|2
index|]
operator|==
literal|']'
operator|)
operator|)
condition|)
block|{
comment|/* It's "PC": consume the "c" and we're done.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
operator|*
name|regnop
operator|=
name|REG_PC
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
comment|/* Like with PC, we recognize ACR, but only if it's *not* followed 	 by '+', and only for v32.  */
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|cris_arch
operator|!=
name|arch_crisv32
operator|||
operator|(
operator|(
operator|*
name|cPP
operator|)
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|&&
operator|(
operator|*
name|cPP
operator|)
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|)
operator|||
operator|(
operator|(
operator|*
name|cPP
operator|)
index|[
literal|2
index|]
operator|!=
literal|'r'
operator|&&
operator|(
operator|*
name|cPP
operator|)
index|[
literal|2
index|]
operator|!=
literal|'R'
operator|)
operator|||
name|ISALNUM
argument_list|(
operator|(
operator|*
name|cPP
operator|)
index|[
literal|3
index|]
argument_list|)
operator|||
operator|(
operator|*
name|cPP
operator|)
index|[
literal|3
index|]
operator|==
literal|'+'
condition|)
break|break;
operator|(
operator|*
name|cPP
operator|)
operator|+=
literal|3
expr_stmt|;
operator|*
name|regnop
operator|=
literal|15
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
comment|/* Hopefully r[0-9] or r1[0-5].  Consume 'R' or 'r'.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
operator|*
name|cPP
argument_list|)
condition|)
block|{
comment|/* It's r[0-9].  Consume and check the next digit.  */
operator|*
name|regnop
operator|=
operator|*
operator|*
name|cPP
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
operator|*
name|cPP
argument_list|)
condition|)
block|{
comment|/* No more digits, we're done.  */
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* One more digit.  Consume and add.  */
operator|*
name|regnop
operator|=
operator|*
name|regnop
operator|*
literal|10
operator|+
operator|(
operator|*
operator|*
name|cPP
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* We need to check for a valid register number; Rn, 		 0<= n<= MAX_REG.  */
if|if
condition|(
operator|*
name|regnop
operator|<=
name|MAX_REG
condition|)
block|{
comment|/* Consume second digit.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
comment|/* "S" as in "SP"?  Consume the "S".  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'P'
operator|||
operator|*
operator|*
name|cPP
operator|==
literal|'p'
condition|)
block|{
comment|/* It's "SP": consume the "p" and we're done.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
operator|*
name|regnop
operator|=
name|REG_SP
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
comment|/* Just here to silence compilation warnings.  */
empty_stmt|;
block|}
comment|/* We get here if we fail.  Restore the pointer.  */
operator|*
name|cPP
operator|=
name|oldp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get a special register from the string pointed out by *cPP. The    variable *cPP is advanced to the character following the special    register name if one is found, and retains its original position    otherwise.     cPP	    Pointer to pointer to string starting with a special register 	    name.     sregpp   Pointer to Pointer to struct spec_reg, where a pointer to the 	    register description will be stored.     Return 1 iff a correct special register name is found.  */
end_comment

begin_function
specifier|static
name|int
name|get_spec_reg
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
specifier|const
name|struct
name|cris_spec_reg
modifier|*
modifier|*
name|sregpp
parameter_list|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|name_begin
init|=
operator|*
name|cPP
decl_stmt|;
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
decl_stmt|;
comment|/* Handle a sometimes-mandatory dollar sign as register prefix.  */
if|if
condition|(
operator|*
name|name_begin
operator|==
name|REGISTER_PREFIX_CHAR
condition|)
name|name_begin
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|demand_register_prefix
condition|)
return|return
literal|0
return|;
comment|/* Loop over all special registers.  */
for|for
control|(
name|sregp
operator|=
name|cris_spec_regs
init|;
name|sregp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sregp
operator|++
control|)
block|{
comment|/* Start over from beginning of the supposed name.  */
name|s1
operator|=
name|name_begin
expr_stmt|;
name|s2
operator|=
name|sregp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
operator|*
name|s2
condition|)
block|{
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
comment|/* For a match, we must have consumed the name in the table, and we 	 must be outside what could be part of a name.	Assume here that a 	 test for alphanumerics is sufficient for a name test.  */
if|if
condition|(
operator|*
name|s2
operator|==
literal|0
operator|&&
operator|!
name|ISALNUM
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|cris_insn_ver_valid_for_arch
argument_list|(
name|sregp
operator|->
name|applicable_version
argument_list|,
name|cris_arch
argument_list|)
condition|)
block|{
comment|/* We have a match.  Update the pointer and be done.  */
operator|*
name|cPP
operator|=
name|s1
expr_stmt|;
operator|*
name|sregpp
operator|=
name|sregp
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If we got here, we did not find any name.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get a support register from the string pointed out by *cPP. The    variable *cPP is advanced to the character following the support-    register name if one is found, and retains its original position    otherwise.     cPP	    Pointer to pointer to string starting with a support-register 	    name.     sregpp   Pointer to int containing the register number.     Return 1 iff a correct support-register name is found.  */
end_comment

begin_function
specifier|static
name|int
name|get_sup_reg
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|int
modifier|*
name|regnop
parameter_list|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|name_begin
init|=
operator|*
name|cPP
decl_stmt|;
specifier|const
name|struct
name|cris_support_reg
modifier|*
name|sregp
decl_stmt|;
comment|/* Handle a sometimes-mandatory dollar sign as register prefix.  */
if|if
condition|(
operator|*
name|name_begin
operator|==
name|REGISTER_PREFIX_CHAR
condition|)
name|name_begin
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|demand_register_prefix
condition|)
return|return
literal|0
return|;
comment|/* Loop over all support-registers.  */
for|for
control|(
name|sregp
operator|=
name|cris_support_regs
init|;
name|sregp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sregp
operator|++
control|)
block|{
comment|/* Start over from beginning of the supposed name.  */
name|s1
operator|=
name|name_begin
expr_stmt|;
name|s2
operator|=
name|sregp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
operator|*
name|s2
condition|)
block|{
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
comment|/* For a match, we must have consumed the name in the table, and we 	 must be outside what could be part of a name.	Assume here that a 	 test for alphanumerics is sufficient for a name test.  */
if|if
condition|(
operator|*
name|s2
operator|==
literal|0
operator|&&
operator|!
name|ISALNUM
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
block|{
comment|/* We have a match.  Update the pointer and be done.  */
operator|*
name|cPP
operator|=
name|s1
expr_stmt|;
operator|*
name|regnop
operator|=
name|sregp
operator|->
name|number
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If we got here, we did not find any name.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get an unprefixed or side-effect-prefix operand from the string pointed    out by *cPP.  The pointer *cPP is advanced to the character following    the indirect operand if we have success, else it contains an undefined    value.     cPP		 Pointer to pointer to string beginning with the first 		 character of the supposed operand.     prefixp	 Pointer to structure containing an optional instruction 		 prefix.     is_autoincp	 Pointer to int indicating the indirect or autoincrement 		 bits.     src_regnop	 Pointer to int containing the source register number in 		 the instruction.     imm_foundp	 Pointer to an int indicating if an immediate expression 		 is found.     imm_exprP	 Pointer to a structure containing an immediate 		 expression, if success and if *imm_foundp is nonzero.     Return 1 iff a correct indirect operand is found.  */
end_comment

begin_function
specifier|static
name|int
name|get_autoinc_prefix_or_indir_op
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|struct
name|cris_prefix
modifier|*
name|prefixp
parameter_list|,
name|int
modifier|*
name|is_autoincp
parameter_list|,
name|int
modifier|*
name|src_regnop
parameter_list|,
name|int
modifier|*
name|imm_foundp
parameter_list|,
name|expressionS
modifier|*
name|imm_exprP
parameter_list|)
block|{
comment|/* Assume there was no immediate mode expression.  */
operator|*
name|imm_foundp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'['
condition|)
block|{
comment|/* So this operand is one of: 	 Indirect: [rN] 	 Autoincrement: [rN+] 	 Indexed with assign: [rN=rM+rO.S] 	 Offset with assign: [rN=rM+I], [rN=rM+[rO].s], [rN=rM+[rO+].s]  	 Either way, consume the '['.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
comment|/* Get the rN register.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
name|src_regnop
argument_list|)
condition|)
comment|/* If there was no register, then this cannot match.  */
return|return
literal|0
return|;
else|else
block|{
comment|/* We got the register, now check the next character.  */
switch|switch
condition|(
operator|*
operator|*
name|cPP
condition|)
block|{
case|case
literal|']'
case|:
comment|/* Indirect mode.  We're done here.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_NONE
expr_stmt|;
operator|*
name|is_autoincp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
comment|/* This must be an auto-increment mode, if there's a 		 match.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_NONE
expr_stmt|;
operator|*
name|is_autoincp
operator|=
literal|1
expr_stmt|;
comment|/* We consume this character and break out to check the 		 closing ']'.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* This must be indexed with assign, or offset with assign 		 to match.  Not supported for crisv32 or in 		 compatibility mode.  */
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
comment|/* Either way, the next thing must be a register.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|base_reg_number
argument_list|)
condition|)
comment|/* No register, no match.  */
return|return
literal|0
return|;
else|else
block|{
comment|/* We've consumed "[rN=rM", so we must be looking at 		     "+rO.s]" or "+I]", or "-I]", or "+[rO].s]" or 		     "+[rO+].s]".  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'+'
condition|)
block|{
name|int
name|index_reg_number
decl_stmt|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'['
condition|)
block|{
name|int
name|size_bits
decl_stmt|;
comment|/* This must be [rx=ry+[rz].s] or 			     [rx=ry+[rz+].s] or no match.  We must be 			     looking at rz after consuming the '['.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|index_reg_number
argument_list|)
condition|)
return|return
literal|0
return|;
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BDAP_INDIR_OPCODE
operator|+
operator|(
name|prefixp
operator|->
name|base_reg_number
operator|<<
literal|12
operator|)
operator|+
name|index_reg_number
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'+'
condition|)
block|{
comment|/* We've seen "[rx=ry+[rz+" here, so now we 				 know that there must be "].s]" left to 				 check.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator||=
name|AUTOINCR_BIT
operator|<<
literal|8
expr_stmt|;
block|}
comment|/* If it wasn't autoincrement, we don't need to 			     add anything.  */
comment|/* Check the next-to-last ']'.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
comment|/* Check the ".s" modifier.  */
if|if
condition|(
operator|!
name|get_bwd_size_modifier
argument_list|(
name|cPP
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
return|return
literal|0
return|;
name|prefixp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
comment|/* Now we got [rx=ry+[rz+].s or [rx=ry+[rz].s. 			     We break out to check the final ']'.  */
break|break;
block|}
comment|/* It wasn't an indirection.  Check if it's a 			 register.  */
elseif|else
if|if
condition|(
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|index_reg_number
argument_list|)
condition|)
block|{
name|int
name|size_bits
decl_stmt|;
comment|/* Indexed with assign mode: "[rN+rM.S]".  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BIAP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BIAP_OPCODE
operator|+
operator|(
name|index_reg_number
operator|<<
literal|12
operator|)
operator|+
name|prefixp
operator|->
name|base_reg_number
comment|/*<< 0 */
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_bwd_size_modifier
argument_list|(
name|cPP
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
comment|/* Size missing, this isn't a match.  */
return|return
literal|0
return|;
else|else
block|{
comment|/* Size found, break out to check the 				 final ']'.  */
name|prefixp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
break|break;
block|}
block|}
comment|/* Not a register.  Then this must be "[rN+I]".  */
elseif|else
if|if
condition|(
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
block|{
comment|/* We've got offset with assign mode.  Fill 			     in the blanks and break out to match the 			     final ']'.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
comment|/* We tentatively put an opcode corresponding to 			     a 32-bit operand here, although it may be 			     relaxed when there's no PIC specifier for the 			     operand.  */
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BDAP_INDIR_OPCODE
operator||
operator|(
name|prefixp
operator|->
name|base_reg_number
operator|<<
literal|12
operator|)
operator||
operator|(
name|AUTOINCR_BIT
operator|<<
literal|8
operator|)
operator||
operator|(
literal|2
operator|<<
literal|4
operator|)
operator||
name|REG_PC
comment|/*<< 0 */
operator|)
expr_stmt|;
comment|/* This can have a PIC suffix, specifying reloc 			     type to use.  */
if|if
condition|(
name|pic
operator|&&
operator|*
operator|*
name|cPP
operator|==
name|PIC_SUFFIX_CHAR
condition|)
block|{
name|unsigned
name|int
name|relocsize
decl_stmt|;
name|cris_get_pic_suffix
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|reloc
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* Tweak the size of the immediate operand 				 in the prefix opcode if it isn't what we 				 set.  */
name|relocsize
operator|=
name|cris_get_pic_reloc_size
argument_list|(
name|prefixp
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocsize
operator|!=
literal|4
condition|)
name|prefixp
operator|->
name|opcode
operator|=
operator|(
operator|(
name|prefixp
operator|->
name|opcode
operator|&
operator|~
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator||
operator|(
operator|(
name|relocsize
operator|>>
literal|1
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
block|}
break|break;
block|}
else|else
comment|/* Neither register nor expression found, so 			   this can't be a match.  */
return|return
literal|0
return|;
block|}
comment|/* Not "[rN+" but perhaps "[rN-"?  */
elseif|else
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'-'
condition|)
block|{
comment|/* We must have an offset with assign mode.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
comment|/* No expression, no match.  */
return|return
literal|0
return|;
else|else
block|{
comment|/* We've got offset with assign mode.  Fill 			     in the blanks and break out to match the 			     final ']'.  			     Note that we don't allow a PIC suffix for an 			     operand with a minus sign.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* Neither '+' nor '-' after "[rN=rM".  Lose.  */
return|return
literal|0
return|;
block|}
default|default:
comment|/* Neither ']' nor '+' nor '=' after "[rN".  Lose.  */
return|return
literal|0
return|;
block|}
block|}
comment|/* When we get here, we have a match and will just check the closing 	 ']'.  We can still fail though.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Don't forget to consume the final ']'. 	     Then return in glory.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* No indirection.  Perhaps a constant?  */
elseif|else
if|if
condition|(
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
name|imm_exprP
argument_list|)
condition|)
block|{
comment|/* Expression found, this is immediate mode.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_NONE
expr_stmt|;
operator|*
name|is_autoincp
operator|=
literal|1
expr_stmt|;
operator|*
name|src_regnop
operator|=
name|REG_PC
expr_stmt|;
operator|*
name|imm_foundp
operator|=
literal|1
expr_stmt|;
comment|/* This can have a PIC suffix, specifying reloc type to use.  The 	 caller must check that the reloc size matches the operand size.  */
if|if
condition|(
name|pic
operator|&&
operator|*
operator|*
name|cPP
operator|==
name|PIC_SUFFIX_CHAR
condition|)
name|cris_get_pic_suffix
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|reloc
argument_list|,
name|imm_exprP
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* No luck today.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function gets an indirect operand in a three-address operand    combination from the string pointed out by *cPP.  The pointer *cPP is    advanced to the character following the indirect operand on success, or    has an unspecified value on failure.     cPP	     Pointer to pointer to string beginning 	     with the operand     prefixp   Pointer to structure containing an 	     instruction prefix     Returns 1 iff a correct indirect operand is found.  */
end_comment

begin_function
specifier|static
name|int
name|get_3op_or_dip_prefix_op
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|struct
name|cris_prefix
modifier|*
name|prefixp
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|'['
condition|)
comment|/* We must have a '[' or it's a clean failure.  */
return|return
literal|0
return|;
comment|/* Eat the first '['.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'['
condition|)
block|{
comment|/* A second '[', so this must be double-indirect mode.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_DIP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
name|DIP_OPCODE
expr_stmt|;
comment|/* Get the register or fail entirely.  */
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|reg_number
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|prefixp
operator|->
name|opcode
operator||=
name|reg_number
comment|/*<< 0 */
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'+'
condition|)
block|{
comment|/* Since we found a '+', this must be double-indirect 		 autoincrement mode.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator||=
name|AUTOINCR_BIT
operator|<<
literal|8
expr_stmt|;
block|}
comment|/* There's nothing particular to do, if this was a 	     double-indirect *without* autoincrement.  */
block|}
comment|/* Check the first ']'.  The second one is checked at the end.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
condition|)
return|return
literal|0
return|;
comment|/* Eat the first ']', so we'll be looking at a second ']'.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
block|}
comment|/* No second '['.  Then we should have a register here, making      it "[rN".  */
elseif|else
if|if
condition|(
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|base_reg_number
argument_list|)
condition|)
block|{
comment|/* This must be indexed or offset mode: "[rN+I]" or 	 "[rN+rM.S]" or "[rN+[rM].S]" or "[rN+[rM+].S]".  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'+'
condition|)
block|{
name|int
name|index_reg_number
decl_stmt|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'['
condition|)
block|{
comment|/* This is "[rx+["...  Expect a register next.  */
name|int
name|size_bits
decl_stmt|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|index_reg_number
argument_list|)
condition|)
return|return
literal|0
return|;
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BDAP_INDIR_OPCODE
operator|+
operator|(
name|prefixp
operator|->
name|base_reg_number
operator|<<
literal|12
operator|)
operator|+
name|index_reg_number
operator|)
expr_stmt|;
comment|/* We've seen "[rx+[ry", so check if this is 		 autoincrement.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'+'
condition|)
block|{
comment|/* Yep, now at "[rx+[ry+".  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator||=
name|AUTOINCR_BIT
operator|<<
literal|8
expr_stmt|;
block|}
comment|/* If it wasn't autoincrement, we don't need to 		 add anything.  */
comment|/* Check a first closing ']': "[rx+[ry]" or 		 "[rx+[ry+]".  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
comment|/* Now expect a size modifier ".S".  */
if|if
condition|(
operator|!
name|get_bwd_size_modifier
argument_list|(
name|cPP
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
return|return
literal|0
return|;
name|prefixp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
comment|/* Ok, all interesting stuff has been seen: 		 "[rx+[ry+].S" or "[rx+[ry].S".  We only need to 		 expect a final ']', which we'll do in a common 		 closing session.  */
block|}
comment|/* Seen "[rN+", but not a '[', so check if we have a 	     register.  */
elseif|else
if|if
condition|(
name|get_gen_reg
argument_list|(
name|cPP
argument_list|,
operator|&
name|index_reg_number
argument_list|)
condition|)
block|{
comment|/* This is indexed mode: "[rN+rM.S]" or 		 "[rN+rM.S+]".  */
name|int
name|size_bits
decl_stmt|;
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BIAP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BIAP_OPCODE
operator||
name|prefixp
operator|->
name|base_reg_number
comment|/*<< 0 */
operator||
operator|(
name|index_reg_number
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
comment|/* Consume the ".S".  */
if|if
condition|(
operator|!
name|get_bwd_size_modifier
argument_list|(
name|cPP
argument_list|,
operator|&
name|size_bits
argument_list|)
condition|)
comment|/* Missing size, so fail.  */
return|return
literal|0
return|;
else|else
comment|/* Size found.  Add that piece and drop down to 		   the common checking of the closing ']'.  */
name|prefixp
operator|->
name|opcode
operator||=
name|size_bits
operator|<<
literal|4
expr_stmt|;
block|}
comment|/* Seen "[rN+", but not a '[' or a register, so then 	     it must be a constant "I".  	     As a quality of implementation improvement, we check for a 	     closing ']', like in an erroneous "[rN+]".  If we don't, 	     the expression parser will emit a confusing "bad 	     expression" when it sees the ']', probably because it 	     doesn't like seeing no expression.  */
elseif|else
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
operator|&&
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
block|{
comment|/* Expression found, so fill in the bits of offset 		 mode and drop down to check the closing ']'.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
comment|/* We tentatively put an opcode corresponding to a 32-bit 		 operand here, although it may be relaxed when there's no 		 PIC specifier for the operand.  */
name|prefixp
operator|->
name|opcode
operator|=
operator|(
name|BDAP_INDIR_OPCODE
operator||
operator|(
name|prefixp
operator|->
name|base_reg_number
operator|<<
literal|12
operator|)
operator||
operator|(
name|AUTOINCR_BIT
operator|<<
literal|8
operator|)
operator||
operator|(
literal|2
operator|<<
literal|4
operator|)
operator||
name|REG_PC
comment|/*<< 0 */
operator|)
expr_stmt|;
comment|/* This can have a PIC suffix, specifying reloc type to use.  */
if|if
condition|(
name|pic
operator|&&
operator|*
operator|*
name|cPP
operator|==
name|PIC_SUFFIX_CHAR
condition|)
block|{
name|unsigned
name|int
name|relocsize
decl_stmt|;
name|cris_get_pic_suffix
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|reloc
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* Tweak the size of the immediate operand in the prefix 		     opcode if it isn't what we set.  */
name|relocsize
operator|=
name|cris_get_pic_reloc_size
argument_list|(
name|prefixp
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocsize
operator|!=
literal|4
condition|)
name|prefixp
operator|->
name|opcode
operator|=
operator|(
operator|(
name|prefixp
operator|->
name|opcode
operator|&
operator|~
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator||
operator|(
operator|(
name|relocsize
operator|>>
literal|1
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Nothing valid here: lose.  */
return|return
literal|0
return|;
block|}
comment|/* Seen "[rN" but no '+', so check if it's a '-'.  */
elseif|else
if|if
condition|(
operator|*
operator|*
name|cPP
operator|==
literal|'-'
condition|)
block|{
comment|/* Yep, we must have offset mode.  */
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
comment|/* No expression, so we lose.  */
return|return
literal|0
return|;
else|else
block|{
comment|/* Expression found to make this offset mode, so 		 fill those bits and drop down to check the 		 closing ']'.  		 Note that we don't allow a PIC suffix for 		 an operand with a minus sign like this.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We've seen "[rN", but not '+' or '-'; rather a ']'. 	     Hmm.  Normally this is a simple indirect mode that we 	     shouldn't match, but if we expect ']', then we have a 	     zero offset, so it can be a three-address-operand, 	     like "[rN],rO,rP", thus offset mode.  	     Don't eat the ']', that will be done in the closing 	     ceremony.  */
name|prefixp
operator|->
name|expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|prefixp
operator|->
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|prefixp
operator|->
name|expr
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|prefixp
operator|->
name|expr
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_BDAP_IMM
expr_stmt|;
block|}
block|}
comment|/* A '[', but no second '[', and no register.  Check if we      have an expression, making this "[I]" for a double-indirect      prefix.  */
elseif|else
if|if
condition|(
name|cris_get_expression
argument_list|(
name|cPP
argument_list|,
operator|&
name|prefixp
operator|->
name|expr
argument_list|)
condition|)
block|{
comment|/* Expression found, the so called absolute mode for a 	 double-indirect prefix on PC.  */
name|prefixp
operator|->
name|kind
operator|=
name|PREFIX_DIP
expr_stmt|;
name|prefixp
operator|->
name|opcode
operator|=
name|DIP_OPCODE
operator||
operator|(
name|AUTOINCR_BIT
operator|<<
literal|8
operator|)
operator||
name|REG_PC
expr_stmt|;
name|prefixp
operator|->
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
else|else
comment|/* Neither '[' nor register nor expression.  We lose.  */
return|return
literal|0
return|;
comment|/* We get here as a closing ceremony to a successful match.  We just      need to check the closing ']'.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|']'
condition|)
comment|/* Oops.  Close but no air-polluter.  */
return|return
literal|0
return|;
comment|/* Don't forget to consume that ']', before returning in glory.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get an expression from the string pointed out by *cPP.    The pointer *cPP is advanced to the character following the expression    on a success, or retains its original value otherwise.     cPP	   Pointer to pointer to string beginning with the expression.     exprP   Pointer to structure containing the expression.     Return 1 iff a correct expression is found.  */
end_comment

begin_function
specifier|static
name|int
name|cris_get_expression
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|expressionS
modifier|*
name|exprP
parameter_list|)
block|{
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|segT
name|exp
decl_stmt|;
comment|/* The "expression" function expects to find an expression at the      global variable input_line_pointer, so we have to save it to give      the impression that we don't fiddle with global variables.  */
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|cPP
expr_stmt|;
comment|/* Avoid a common error, confusing addressing modes.  Beware that the      call to expression below does not signal that error; it treats []      as parentheses, unless #define NEED_INDEX_OPERATOR in which case it      gives them other confusing semantics rather than plain outlawing      them, which is what we want.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'['
condition|)
block|{
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
name|expression
argument_list|(
name|exprP
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprP
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|exprP
operator|->
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Everything seems to be fine, just restore the global      input_line_pointer and say we're successful.  */
operator|*
name|cPP
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a sequence of flag characters from *spp.  The pointer *cPP is    advanced to the character following the expression.	The flag    characters are consecutive, no commas or spaces.     cPP	     Pointer to pointer to string beginning with the expression.     flagp     Pointer to int to return the flags expression.     Return 1 iff a correct flags expression is found.  */
end_comment

begin_function
specifier|static
name|int
name|get_flags
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|cPP
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v0_3
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x80
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v8_10
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x80
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v0_3
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v8_10
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v32p
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x80
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|cris_insn_ver_valid_for_arch
argument_list|(
name|cris_ver_v32p
argument_list|,
name|cris_arch
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|flagsp
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
operator|*
name|flagsp
operator||=
literal|0x20
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
operator|*
name|flagsp
operator||=
literal|0x10
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
operator|*
name|flagsp
operator||=
literal|0x8
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
operator|*
name|flagsp
operator||=
literal|0x4
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
operator|*
name|flagsp
operator||=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
operator|*
name|flagsp
operator||=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* We consider this successful if we stop at a comma or 	     whitespace.  Anything else, and we consider it a failure.  */
if|if
condition|(
operator|*
operator|*
name|cPP
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|cPP
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
operator|*
name|cPP
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/* Don't forget to consume each flag character.  */
operator|(
operator|*
name|cPP
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code and fixes for a BDAP prefix.    For v32, this handles ADDOQ because thankfully the opcodes are the    same.     base_regno	Int containing the base register number.     exprP	Pointer to structure containing the offset expression.  */
end_comment

begin_function
specifier|static
name|void
name|gen_bdap
parameter_list|(
name|int
name|base_regno
parameter_list|,
name|expressionS
modifier|*
name|exprP
parameter_list|)
block|{
name|unsigned
name|int
name|opcode
decl_stmt|;
name|char
modifier|*
name|opcodep
decl_stmt|;
comment|/* Put out the prefix opcode; assume quick immediate mode at first.  */
name|opcode
operator|=
name|BDAP_QUICK_OPCODE
operator||
operator|(
name|base_regno
operator|<<
literal|12
operator|)
expr_stmt|;
name|opcodep
operator|=
name|cris_insn_first_word_frag
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprP
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* We have an absolute expression that we know the size of right 	 now.  */
name|long
name|int
name|value
decl_stmt|;
name|int
name|size
decl_stmt|;
name|value
operator|=
name|exprP
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|32768
operator|||
name|value
operator|>
literal|32767
condition|)
comment|/* Outside range for a "word", make it a dword.  */
name|size
operator|=
literal|2
expr_stmt|;
else|else
comment|/* Assume "word" size.  */
name|size
operator|=
literal|1
expr_stmt|;
comment|/* If this is a signed-byte value, we can fit it into the prefix 	 insn itself.  */
if|if
condition|(
name|value
operator|>=
operator|-
literal|128
operator|&&
name|value
operator|<=
literal|127
condition|)
name|opcodep
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
else|else
block|{
comment|/* This is a word or dword displacement, which will be put in a 	     word or dword after the prefix.  */
name|char
modifier|*
name|p
decl_stmt|;
name|opcodep
index|[
literal|0
index|]
operator|=
name|BDAP_PC_LOW
operator|+
operator|(
name|size
operator|<<
literal|4
operator|)
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator|&=
literal|0xF0
expr_stmt|;
name|opcodep
index|[
literal|1
index|]
operator||=
name|BDAP_INCR_HIGH
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|<<
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
literal|1
operator|<<
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Handle complex expressions.  */
name|valueT
name|addvalue
init|=
name|SIMPLE_EXPR
argument_list|(
name|exprP
argument_list|)
condition|?
name|exprP
operator|->
name|X_add_number
else|:
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
operator|(
name|SIMPLE_EXPR
argument_list|(
name|exprP
argument_list|)
condition|?
name|exprP
operator|->
name|X_add_symbol
else|:
name|make_expr_symbol
argument_list|(
name|exprP
argument_list|)
operator|)
decl_stmt|;
comment|/* The expression is not defined yet but may become absolute.  We 	 make it a relocation to be relaxed.  */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_BASE_PLUS_DISP_PREFIX
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|sym
argument_list|,
name|addvalue
argument_list|,
name|opcodep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode a branch displacement in the range -256..254 into the form used    by CRIS conditional branch instructions.     offset  The displacement value in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|branch_disp
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|int
name|disp
decl_stmt|;
comment|/* Adjust all short branch offsets here.  */
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
operator|||
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|)
name|offset
operator|+=
literal|2
expr_stmt|;
name|disp
operator|=
name|offset
operator|&
literal|0xFE
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|disp
operator||=
literal|1
expr_stmt|;
return|return
name|disp
return|;
block|}
end_function

begin_comment
comment|/* Generate code and fixes for a 32-bit conditional branch instruction    created by "extending" an existing 8-bit branch instruction.     opcodep    Pointer to the word containing the original 8-bit branch 	      instruction.     writep     Pointer to "extension area" following the first instruction 	      word.     fragP      Pointer to the frag containing the instruction.     add_symP,  Parts of the destination address expression.    sub_symP,    add_num.  */
end_comment

begin_function
specifier|static
name|void
name|gen_cond_branch_32
parameter_list|(
name|char
modifier|*
name|opcodep
parameter_list|,
name|char
modifier|*
name|writep
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|symbolS
modifier|*
name|add_symP
parameter_list|,
name|symbolS
modifier|*
name|sub_symP
parameter_list|,
name|long
name|int
name|add_num
parameter_list|)
block|{
name|int
name|nop_opcode
decl_stmt|;
name|int
name|opc_offset
decl_stmt|;
name|int
name|branch_offset
decl_stmt|;
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
condition|)
block|{
name|nop_opcode
operator|=
name|NOP_OPCODE_V32
expr_stmt|;
name|opc_offset
operator|=
literal|10
expr_stmt|;
name|branch_offset
operator|=
operator|-
literal|2
operator|-
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pic
condition|)
block|{
name|nop_opcode
operator|=
name|NOP_OPCODE
expr_stmt|;
name|opc_offset
operator|=
literal|10
expr_stmt|;
name|branch_offset
operator|=
operator|-
literal|2
operator|-
literal|8
expr_stmt|;
block|}
else|else
block|{
name|nop_opcode
operator|=
name|NOP_OPCODE
expr_stmt|;
name|opc_offset
operator|=
literal|8
expr_stmt|;
name|branch_offset
operator|=
operator|-
literal|2
operator|-
literal|6
expr_stmt|;
block|}
comment|/* We should never get here for compatibility mode.  */
if|if
condition|(
name|cris_arch
operator|==
name|arch_cris_common_v10_v32
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Calling gen_cond_branch_32 for .arch common_v10_v32\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_for_branch_expansion
condition|)
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"32-bit conditional branch generated"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Here, writep points to what will be opcodep + 2.  First, we change      the actual branch in opcodep[0] and opcodep[1], so that in the      final insn, it will look like:        opcodep+10: Bcc .-6       This means we don't have to worry about changing the opcode or      messing with the delay-slot instruction.  So, we move it to last in      the "extended" branch, and just change the displacement.  Admittedly,      it's not the optimal extended construct, but we should get this      rarely enough that it shouldn't matter.  */
name|writep
index|[
name|opc_offset
index|]
operator|=
name|branch_disp
argument_list|(
name|branch_offset
argument_list|)
expr_stmt|;
name|writep
index|[
name|opc_offset
operator|+
literal|1
index|]
operator|=
name|opcodep
index|[
literal|1
index|]
expr_stmt|;
comment|/* Then, we change the branch to an unconditional branch over the      extended part, to the new location of the Bcc:        opcodep:	  BA .+10        opcodep+2: NOP       Note that these two writes are to currently different locations,      merged later.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|BA_QUICK_OPCODE
operator|+
operator|(
name|cris_arch
operator|==
name|arch_crisv32
condition|?
literal|12
else|:
operator|(
name|pic
condition|?
literal|10
else|:
literal|8
operator|)
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|writep
argument_list|,
name|nop_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Then the extended thing, the 32-bit jump insn.        opcodep+4: JUMP [PC+]      or, in the PIC case,        opcodep+4: MOVE [PC=PC+N],P0.  */
name|md_number_to_chars
argument_list|(
name|writep
operator|+
literal|2
argument_list|,
name|cris_arch
operator|==
name|arch_crisv32
condition|?
name|BA_DWORD_OPCODE
else|:
operator|(
name|pic
condition|?
name|MOVE_PC_INCR_OPCODE_PREFIX
else|:
name|JUMP_PC_INCR_OPCODE
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* We have to fill in the actual value too.        opcodep+6: .DWORD      This is most probably an expression, but we can cope with an absolute      value too.  FIXME: Testcase needed with and without pic.  */
if|if
condition|(
name|add_symP
operator|==
name|NULL
operator|&&
name|sub_symP
operator|==
name|NULL
condition|)
block|{
comment|/* An absolute address.  */
if|if
condition|(
name|pic
operator|||
name|cris_arch
operator|==
name|arch_crisv32
condition|)
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|writep
operator|+
literal|4
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
argument_list|,
name|add_num
operator|+
operator|(
name|cris_arch
operator|==
name|arch_crisv32
condition|?
literal|6
else|:
literal|0
operator|)
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
else|else
name|md_number_to_chars
argument_list|(
name|writep
operator|+
literal|4
argument_list|,
name|add_num
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sub_symP
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"Complex expression not supported"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not absolute, we have to make it a frag for later evaluation.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|writep
operator|+
literal|4
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|add_symP
argument_list|,
name|add_num
operator|+
operator|(
name|cris_arch
operator|==
name|arch_crisv32
condition|?
literal|6
else|:
literal|0
operator|)
argument_list|,
name|pic
operator|||
name|cris_arch
operator|==
name|arch_crisv32
condition|?
literal|1
else|:
literal|0
argument_list|,
name|pic
operator|||
name|cris_arch
operator|==
name|arch_crisv32
condition|?
name|BFD_RELOC_32_PCREL
else|:
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cris_arch
operator|==
name|arch_crisv32
condition|)
comment|/* Follow it with a "NOP" for CRISv32.  */
name|md_number_to_chars
argument_list|(
name|writep
operator|+
literal|8
argument_list|,
name|NOP_OPCODE_V32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pic
condition|)
comment|/* ...and the rest of the move-opcode for pre-v32 PIC.  */
name|md_number_to_chars
argument_list|(
name|writep
operator|+
literal|8
argument_list|,
name|MOVE_PC_INCR_OPCODE_SUFFIX
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the size of an immediate-reloc in bytes.  Only valid for PIC    relocs.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|cris_get_pic_reloc_size
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|)
block|{
return|return
name|reloc
operator|==
name|BFD_RELOC_CRIS_16_GOTPLT
operator|||
name|reloc
operator|==
name|BFD_RELOC_CRIS_16_GOT
condition|?
literal|2
else|:
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Store a reloc type at *RELOCP corresponding to the PIC suffix at *CPP.    Adjust *EXPRP with any addend found after the PIC suffix.  */
end_comment

begin_function
specifier|static
name|void
name|cris_get_pic_suffix
parameter_list|(
name|char
modifier|*
modifier|*
name|cPP
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|relocp
parameter_list|,
name|expressionS
modifier|*
name|exprP
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|cPP
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|expressionS
name|const_expr
decl_stmt|;
specifier|const
struct|struct
name|pic_suffixes_struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|suffix
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
name|pic_suffixes
index|[]
init|=
block|{
undef|#
directive|undef
name|PICMAP
define|#
directive|define
name|PICMAP
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
value|{s, sizeof (s) - 1, r}
comment|/* Keep this in order with longest unambiguous prefix first.  */
name|PICMAP
argument_list|(
literal|"GOTPLT16"
argument_list|,
name|BFD_RELOC_CRIS_16_GOTPLT
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"GOTPLT"
argument_list|,
name|BFD_RELOC_CRIS_32_GOTPLT
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"PLTG"
argument_list|,
name|BFD_RELOC_CRIS_32_PLT_GOTREL
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"PLT"
argument_list|,
name|BFD_RELOC_CRIS_32_PLT_PCREL
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"GOTOFF"
argument_list|,
name|BFD_RELOC_CRIS_32_GOTREL
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"GOT16"
argument_list|,
name|BFD_RELOC_CRIS_16_GOT
argument_list|)
block|,
name|PICMAP
argument_list|(
literal|"GOT"
argument_list|,
argument|BFD_RELOC_CRIS_32_GOT
argument_list|)
block|}
struct|;
comment|/* We've already seen the ':', so consume it.  */
name|s
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|pic_suffixes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pic_suffixes
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|pic_suffixes
index|[
name|i
index|]
operator|.
name|suffix
argument_list|,
name|pic_suffixes
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|s
index|[
name|pic_suffixes
index|[
name|i
index|]
operator|.
name|len
index|]
argument_list|)
condition|)
block|{
comment|/* We have a match.  Consume the suffix and set the relocation 	     type.   */
name|s
operator|+=
name|pic_suffixes
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
comment|/* There can be a constant term appended.  If so, we will add it 	     to *EXPRP.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|cris_get_expression
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|const_expr
argument_list|)
condition|)
comment|/* There was some kind of syntax error.  Bail out.  */
break|break;
comment|/* Allow complex expressions as the constant part.  It still 		 has to be an assembly-time constant or there will be an 		 error emitting the reloc.  This makes the PIC qualifiers 		 idempotent; foo:GOTOFF+32 == foo+32:GOTOFF.  The former we 		 recognize here; the latter is parsed in the incoming 		 expression.  */
name|exprP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|exprP
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_op
operator|=
name|O_add
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exprP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|const_expr
argument_list|)
expr_stmt|;
block|}
operator|*
name|relocp
operator|=
name|pic_suffixes
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
operator|*
name|cPP
operator|=
name|s
expr_stmt|;
return|return;
block|}
block|}
comment|/* No match.  Don't consume anything; fall back and there will be a      syntax error.  */
block|}
end_function

begin_comment
comment|/* This *could* have been:     Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.     type	  A character from FLTCHARS that describes what kind of 	  floating-point number is wanted.     litp	  A pointer to an array that the result should be stored in.     sizep  A pointer to an integer where the size of the result is stored.     But we don't support floating point constants in assembly code *at all*,    since it's suboptimal and just opens up bug opportunities.  GCC emits    the bit patterns as hex.  All we could do here is to emit what GCC    would have done in the first place.	*Nobody* writes floating-point    code as assembly code, but if they do, they should be able enough to    find out the correct bit patterns and use them.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|litp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|sizep
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* FIXME:  Is this function mentioned in the internals.texi manual?  If      not, add it.  */
return|return
name|_
argument_list|(
literal|"Bad call to md_atof () - floating point formats are not supported"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn a number as a fixS * into a series of bytes that represents the    number on the target machine.  The purpose of this procedure is the    same as that of md_number_to_chars but this procedure is supposed to    handle general bit field fixes and machine-dependent fixups.     bufp	       Pointer to an array where the result should be stored.     val	      The value to store.     n	      The number of bytes in "val" that should be stored.     fixP	      The fix to be applied to the bit field starting at bufp.     seg	      The segment containing this number.  */
end_comment

begin_function
specifier|static
name|void
name|cris_number_to_imm
parameter_list|(
name|char
modifier|*
name|bufp
parameter_list|,
name|long
name|val
parameter_list|,
name|int
name|n
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|segT
name|sym_seg
decl_stmt|;
name|know
argument_list|(
name|n
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
comment|/* We put the relative "vma" for the other segment for inter-segment      relocations in the object data to stay binary "compatible" (with an      uninteresting old version) for the relocation.      Maybe delete some day.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|(
name|sym_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|!=
name|seg
condition|)
name|val
operator|+=
name|sym_seg
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* These must be fully resolved when getting here.  */
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"PC-relative relocation must be trivially resolved"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
empty_stmt|;
block|}
comment|/* Only do this for old-arch binaries.  */
if|if
condition|(
name|cris_arch
operator|!=
name|arch_cris_any_v0_v10
operator|&&
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|||
name|fixP
operator|->
name|fx_pcrel
operator|)
condition|)
return|return;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* Ditto here, we put the addend into the object code as 	 well as the reloc addend.  Keep it that way for now, to simplify 	 regression tests on the object file contents.	FIXME:	Seems 	 uninteresting now that we have a test suite.  */
case|case
name|BFD_RELOC_CRIS_16_GOT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_16_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_PCREL
case|:
comment|/* We don't want to put in any kind of non-zero bits in the data 	 being relocated for these.  */
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
comment|/* If this one isn't fully resolved, we don't want to put anything 	 in the object.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_32
case|:
comment|/* No use having warnings here, since most hosts have a 32-bit type 	 for "long" (which will probably change soon, now that I wrote 	 this).  */
name|bufp
index|[
literal|3
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|bufp
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|bufp
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
break|break;
comment|/* FIXME: The 16 and 8-bit cases should have a way to check 	 whether a signed or unsigned (or any signedness) number is 	 accepted.  */
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
if|if
condition|(
name|val
operator|>
literal|0xffff
operator|||
name|val
operator|<
operator|-
literal|32768
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 16 bit range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|bufp
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_CRIS_SIGNED_16
case|:
if|if
condition|(
name|val
operator|>
literal|32767
operator|||
name|val
operator|<
operator|-
literal|32768
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 16 bit signed range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|bufp
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
if|if
condition|(
name|val
operator|>
literal|255
operator|||
name|val
operator|<
operator|-
literal|128
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 8 bit range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_SIGNED_8
case|:
if|if
condition|(
name|val
operator|>
literal|127
operator|||
name|val
operator|<
operator|-
literal|128
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 8 bit signed range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
case|:
comment|/* FIXME: Test-cases for out-of-range values.  Probably also need 	 to use as_bad_where.  */
case|case
name|BFD_RELOC_CRIS_UNSIGNED_4
case|:
if|if
condition|(
name|val
operator|>
literal|15
operator|||
name|val
operator|<
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 4 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0x0F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_UNSIGNED_5
case|:
if|if
condition|(
name|val
operator|>
literal|31
operator|||
name|val
operator|<
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 5 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0x1F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_SIGNED_6
case|:
if|if
condition|(
name|val
operator|>
literal|31
operator|||
name|val
operator|<
operator|-
literal|32
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 6 bit range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0x3F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_UNSIGNED_6
case|:
if|if
condition|(
name|val
operator|>
literal|63
operator|||
name|val
operator|<
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value not in 6 bit unsigned range: %ld"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0x3F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_BDISP8
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|bufp
index|[
literal|0
index|]
operator|=
name|branch_disp
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_NONE
case|:
comment|/* May actually happen automatically.  For example at broken 	 words, if the word turns out not to be broken. 	 FIXME: When?  Which testcase?  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|md_number_to_chars
argument_list|(
name|bufp
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
comment|/* This borrowed from tc-ppc.c on a whim.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Processes machine-dependent command line options.  Called once for    each option on the command line that the machine-independent part of    GAS does not understand.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|arg
parameter_list|,
name|char
modifier|*
name|argp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Please use --help to see usage and options for this assembler.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|md_show_usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'N'
case|:
name|warn_for_branch_expansion
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_US
case|:
name|demand_register_prefix
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"--no-underscore is invalid with a.out format"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|symbols_have_leading_underscore
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_US
case|:
name|demand_register_prefix
operator|=
name|FALSE
expr_stmt|;
name|symbols_have_leading_underscore
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_PIC
case|:
name|pic
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cris_arch
operator|!=
name|arch_crisv32
condition|)
name|md_long_jump_size
operator|=
name|cris_any_v0_v10_long_jump_size_pic
expr_stmt|;
else|else
name|md_long_jump_size
operator|=
name|crisv32_long_jump_size
expr_stmt|;
break|break;
case|case
name|OPTION_ARCH
case|:
block|{
name|char
modifier|*
name|str
init|=
name|argp
decl_stmt|;
name|enum
name|cris_archs
name|argarch
init|=
name|cris_arch_from_string
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|argarch
operator|==
name|arch_cris_unknown
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid<arch> in --march=<arch>: %s"
argument_list|)
argument_list|,
name|argp
argument_list|)
expr_stmt|;
else|else
name|cris_arch
operator|=
name|argarch
expr_stmt|;
if|if
condition|(
name|argarch
operator|==
name|arch_crisv32
condition|)
block|{
name|err_for_dangerous_mul_placement
operator|=
literal|0
expr_stmt|;
name|md_long_jump_size
operator|=
name|crisv32_long_jump_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pic
condition|)
name|md_long_jump_size
operator|=
name|cris_any_v0_v10_long_jump_size_pic
expr_stmt|;
else|else
name|md_long_jump_size
operator|=
name|cris_any_v0_v10_long_jump_size
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPTION_MULBUG_ABORT_OFF
case|:
name|err_for_dangerous_mul_placement
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MULBUG_ABORT_ON
case|:
name|err_for_dangerous_mul_placement
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
comment|/* Round all sects to multiple of 4, except the bss section, which      we'll round to word-size.       FIXME: Check if this really matters.  All sections should be      rounded up, and all sections should (optionally) be assumed to be      dword-aligned, it's just that there is actual usage of linking to a      multiple of two.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
if|if
condition|(
name|segment
operator|==
name|bss_section
condition|)
return|return
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
return|;
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
return|;
block|}
else|else
block|{
comment|/* FIXME: Is this wanted?  It matches the testsuite, but that's not 	 really a valid reason.  */
if|if
condition|(
name|segment
operator|==
name|text_section
condition|)
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
return|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Generate a machine-dependent relocation.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|arelent
modifier|*
name|relP
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CRIS_SIGNED_8
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_SIGNED_16
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CRIS_16_GOT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOT
case|:
case|case
name|BFD_RELOC_CRIS_16_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_PCREL
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_CRIS_UNSIGNED_8
case|:
case|case
name|BFD_RELOC_CRIS_UNSIGNED_16
case|:
case|case
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
case|:
name|code
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Semantics error.  This type of operand can not be relocated, it must be an assembly-time constant"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|relP
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|relP
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relP
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relP
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|relP
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|relP
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
comment|/* This is the standard place for KLUDGEs to work around bugs in      bfd_install_relocation (first such note in the documentation      appears with binutils-2.8).       That function bfd_install_relocation does the wrong thing with      putting stuff into the addend of a reloc (it should stay out) for a      weak symbol.  The really bad thing is that it adds the      "segment-relative offset" of the symbol into the reloc.  In this      case, the reloc should instead be relative to the symbol with no      other offset than the assembly code shows; and since the symbol is      weak, any local definition should be ignored until link time (or      thereafter).      To wit:  weaksym+42  should be weaksym+42 in the reloc,      not weaksym+(offset_from_segment_of_local_weaksym_definition)       To "work around" this, we subtract the segment-relative offset of      "known" weak symbols.  This evens out the extra offset.       That happens for a.out but not for ELF, since for ELF,      bfd_install_relocation uses the "special function" field of the      howto, and does not execute the code that needs to be undone.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|&&
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
condition|)
block|{
name|relP
operator|->
name|addend
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
name|relP
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relP
operator|->
name|howto
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Cannot generate relocation type for symbol %s, code %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relP
return|;
block|}
end_function

begin_comment
comment|/* Machine-dependent usage-output.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
comment|/* The messages are formatted to line up with the generic options.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"CRIS-specific options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  -h, -H                  Don't execute, print this help text.  Deprecated.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  -N                      Warn when branches are expanded to jumps.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  --underscore            User symbols are normally prepended with underscore.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"                          Registers will not need any prefix.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  --no-underscore         User symbols do not have any prefix.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"                          Registers will require a `$'-prefix.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  --pic			Enable generation of position-independent code.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  --march=<arch>		Generate code for<arch>.  Valid choices for<arch>\n\ 				are v0_v10, v10, v32 and common_v10_v32.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply a fixS (fixup of an instruction or data that we didn't have    enough info to complete immediately) to the data in a frag.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
comment|/* This assignment truncates upper bits if valueT is 64 bits (as with      --enable-64-bit-bfd), which is fine here, though we cast to avoid      any compiler warnings.  */
name|long
name|val
init|=
operator|(
name|long
operator|)
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_bit_fixP
operator|||
name|fixP
operator|->
name|fx_im_disp
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid relocation"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This operand-type is scaled.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
condition|)
name|val
operator|/=
literal|2
expr_stmt|;
name|cris_number_to_imm
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|fixP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All relocations are relative to the location just after the fixup;    the address of the fixup plus its size.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
comment|/* FIXME:  We get here only at the end of assembly, when X in ".-X" is      still unknown.  Since we don't have pc-relative relocations in a.out,      this is invalid.  What to do if anything for a.out, is to add      pc-relative relocations everywhere including the elinux program      loader.  For ELF, allow straight-forward PC-relative relocations,      which are always relative to the location after the relocation.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_8_PCREL
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_16_PCREL
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_PCREL
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_CRIS_LAPCQ_OFFSET
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid pc-relative relocation"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|addr
return|;
block|}
end_function

begin_comment
comment|/* We have no need to give defaults for symbol-values.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If this function returns non-zero, it prevents the relocation    against symbol(s) in the FIXP from being replaced with relocations    against section symbols, and guarantees that a relocation will be    emitted even when the value can be resolved locally.  */
end_comment

begin_function
name|int
name|md_cris_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixp
parameter_list|)
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_CRIS_16_GOT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOT
case|:
case|case
name|BFD_RELOC_CRIS_16_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTPLT
case|:
case|case
name|BFD_RELOC_CRIS_32_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_GOTREL
case|:
case|case
name|BFD_RELOC_CRIS_32_PLT_PCREL
case|:
return|return
literal|1
return|;
default|default:
empty_stmt|;
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check and emit error if broken-word handling has failed to fix up a    case-table.	This is called from write.c, after doing everything it    knows about how to handle broken words.  */
end_comment

begin_function
name|void
name|tc_cris_check_adjusted_broken_word
parameter_list|(
name|offsetT
name|new_offset
parameter_list|,
name|struct
name|broken_word
modifier|*
name|brokwP
parameter_list|)
block|{
if|if
condition|(
name|new_offset
operator|>
literal|32767
operator|||
name|new_offset
operator|<
operator|-
literal|32768
condition|)
comment|/* We really want a genuine error, not a warning, so make it one.  */
name|as_bad_where
argument_list|(
name|brokwP
operator|->
name|frag
operator|->
name|fr_file
argument_list|,
name|brokwP
operator|->
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"Adjusted signed .word (%ld) overflows: `switch'-statement too large."
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a leading REGISTER_PREFIX_CHAR mandatory for all registers.  */
end_comment

begin_function
specifier|static
name|void
name|cris_force_reg_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|demand_register_prefix
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do not demand a leading REGISTER_PREFIX_CHAR for all registers.  */
end_comment

begin_function
specifier|static
name|void
name|cris_relax_reg_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|demand_register_prefix
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust for having a leading '_' on all user symbols.  */
end_comment

begin_function
specifier|static
name|void
name|cris_sym_leading_underscore
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We can't really do anything more than assert that what the program      thinks symbol starts with agrees with the command-line options, since      the bfd is already created.  */
if|if
condition|(
operator|!
name|symbols_have_leading_underscore
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".syntax %s requires command-line option `--underscore'"
argument_list|)
argument_list|,
name|SYNTAX_USER_SYM_LEADING_UNDERSCORE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust for not having any particular prefix on user symbols.  */
end_comment

begin_function
specifier|static
name|void
name|cris_sym_no_leading_underscore
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|symbols_have_leading_underscore
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".syntax %s requires command-line option `--no-underscore'"
argument_list|)
argument_list|,
name|SYNTAX_USER_SYM_NO_LEADING_UNDERSCORE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .syntax pseudo, which takes an argument that decides what    syntax the assembly code has.  */
end_comment

begin_function
specifier|static
name|void
name|s_syntax
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|syntaxes
block|{
specifier|const
name|char
modifier|*
specifier|const
name|operand
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
name|syntax_table
index|[]
init|=
block|{
block|{
name|SYNTAX_ENFORCE_REG_PREFIX
block|,
name|cris_force_reg_prefix
block|}
block|,
block|{
name|SYNTAX_RELAX_REG_PREFIX
block|,
name|cris_relax_reg_prefix
block|}
block|,
block|{
name|SYNTAX_USER_SYM_LEADING_UNDERSCORE
block|,
name|cris_sym_leading_underscore
block|}
block|,
block|{
name|SYNTAX_USER_SYM_NO_LEADING_UNDERSCORE
block|,
name|cris_sym_no_leading_underscore
block|}
block|}
struct|;
specifier|const
name|struct
name|syntaxes
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|syntax_table
init|;
name|sp
operator|<
name|syntax_table
operator|+
sizeof|sizeof
argument_list|(
name|syntax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|syntax_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|sp
operator|->
name|operand
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|operand
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
name|sp
operator|->
name|fn
call|)
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|+=
name|strlen
argument_list|(
name|sp
operator|->
name|operand
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown .syntax operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for dwarf2_directive_file to emit error if this is seen when    not emitting ELF.  */
end_comment

begin_function
specifier|static
name|void
name|s_cris_file
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Pseudodirective .file is only valid when generating ELF"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dwarf2_directive_file
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for dwarf2_directive_loc to emit error if this is seen when not    emitting ELF.  */
end_comment

begin_function
specifier|static
name|void
name|s_cris_loc
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Pseudodirective .loc is only valid when generating ELF"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dwarf2_directive_loc
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate a<arch> string (as common to --march=<arch> and .arch<arch>)    into an enum.  If the string *STR is recognized, *STR is updated to point    to the end of the string.  If the string is not recognized,    arch_cris_unknown is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|cris_archs
name|cris_arch_from_string
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|cris_arch_struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
name|enum
name|cris_archs
name|arch
decl_stmt|;
block|}
name|arch_table
index|[]
init|=
comment|/* Keep in order longest-first for choices where one is a prefix 	 of another.  */
block|{
block|{
literal|"v0_v10"
block|,
name|arch_cris_any_v0_v10
block|}
block|,
block|{
literal|"v10"
block|,
name|arch_crisv10
block|}
block|,
block|{
literal|"v32"
block|,
name|arch_crisv32
block|}
block|,
block|{
literal|"common_v10_v32"
block|,
name|arch_cris_common_v10_v32
block|}
block|}
struct|;
specifier|const
name|struct
name|cris_arch_struct
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|arch_table
init|;
name|ap
operator|<
name|arch_table
operator|+
sizeof|sizeof
argument_list|(
name|arch_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arch_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|ap
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
name|ap
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|str
index|[
literal|0
index|]
index|[
name|len
index|]
operator|==
literal|0
operator|||
name|ISSPACE
argument_list|(
name|str
index|[
literal|0
index|]
index|[
name|len
index|]
argument_list|)
operator|)
condition|)
block|{
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|ap
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ap
operator|->
name|arch
return|;
block|}
block|}
return|return
name|arch_cris_unknown
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if architecture version ARCH matches version range in    IVER.  */
end_comment

begin_function
specifier|static
name|int
name|cris_insn_ver_valid_for_arch
parameter_list|(
name|enum
name|cris_insn_version_usage
name|iver
parameter_list|,
name|enum
name|cris_archs
name|arch
parameter_list|)
block|{
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|arch_cris_any_v0_v10
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_warning
operator|||
name|iver
operator|==
name|cris_ver_v0_3
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v0_10
operator|||
name|iver
operator|==
name|cris_ver_sim_v0_10
operator|||
name|iver
operator|==
name|cris_ver_v3_10
operator|||
name|iver
operator|==
name|cris_ver_v8
operator|||
name|iver
operator|==
name|cris_ver_v8p
operator|||
name|iver
operator|==
name|cris_ver_v8_10
operator|||
name|iver
operator|==
name|cris_ver_v10
operator|||
name|iver
operator|==
name|cris_ver_v10p
operator|)
return|;
case|case
name|arch_crisv32
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v8p
operator|||
name|iver
operator|==
name|cris_ver_v10p
operator|||
name|iver
operator|==
name|cris_ver_v32p
operator|)
return|;
case|case
name|arch_cris_common_v10_v32
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v8p
operator|||
name|iver
operator|==
name|cris_ver_v10p
operator|)
return|;
case|case
name|arch_crisv0
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v0_3
operator|||
name|iver
operator|==
name|cris_ver_v0_10
operator|||
name|iver
operator|==
name|cris_ver_sim_v0_10
operator|)
return|;
case|case
name|arch_crisv3
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v0_3
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v0_10
operator|||
name|iver
operator|==
name|cris_ver_sim_v0_10
operator|||
name|iver
operator|==
name|cris_ver_v3_10
operator|)
return|;
case|case
name|arch_crisv8
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v0_10
operator|||
name|iver
operator|==
name|cris_ver_sim_v0_10
operator|||
name|iver
operator|==
name|cris_ver_v3_10
operator|||
name|iver
operator|==
name|cris_ver_v8
operator|||
name|iver
operator|==
name|cris_ver_v8p
operator|||
name|iver
operator|==
name|cris_ver_v8_10
operator|)
return|;
case|case
name|arch_crisv10
case|:
return|return
operator|(
name|iver
operator|==
name|cris_ver_version_all
operator|||
name|iver
operator|==
name|cris_ver_v3p
operator|||
name|iver
operator|==
name|cris_ver_v0_10
operator|||
name|iver
operator|==
name|cris_ver_sim_v0_10
operator|||
name|iver
operator|==
name|cris_ver_v3_10
operator|||
name|iver
operator|==
name|cris_ver_v8p
operator|||
name|iver
operator|==
name|cris_ver_v8_10
operator|||
name|iver
operator|==
name|cris_ver_v10
operator|||
name|iver
operator|==
name|cris_ver_v10p
operator|)
return|;
default|default:
name|BAD_CASE
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assert that the .arch ARCHCHOICE1 is compatible with the specified or    default --march=<ARCHCHOICE2> option.  */
end_comment

begin_function
specifier|static
name|void
name|s_cris_arch
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Right now we take the easy route and check for sameness.  It's not      obvious that allowing e.g. --march=v32 and .arch common_v0_v32      would be more useful than confusing, implementation-wise and      user-wise.  */
name|char
modifier|*
name|str
init|=
name|input_line_pointer
decl_stmt|;
name|enum
name|cris_archs
name|arch
init|=
name|cris_arch_from_string
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|arch
operator|==
name|arch_cris_unknown
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operand to .arch"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For this one, str does not reflect the end of the operand, 	 since there was no matching arch.  Skip it manually; skip 	 things that can be part of a word (a name).  */
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arch
operator|!=
name|cris_arch
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".arch<arch> requires a matching --march=... option"
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Local variables:  * eval: (c-set-style "gnu")  * indent-tabs-mode: t  * End:  */
end_comment

end_unit

