begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-hppa.c -- Assemble for the PA    Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* HP PA-RISC support was contributed by the Center for Software Science    at the University of Utah.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_include
include|#
directive|include
file|"bfd/libhppa.h"
end_include

begin_comment
comment|/* Be careful, this file includes data *declarations*.  */
end_comment

begin_include
include|#
directive|include
file|"opcode/hppa.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_SOM
argument_list|)
end_if

begin_expr_stmt
name|error
name|only
name|one
name|of
name|OBJ_ELF
name|and
name|OBJ_SOM
name|can
name|be
name|defined
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we are using ELF, then we probably can support dwarf2 debug    records.  Furthermore, if we are supporting dwarf2 debug records,    then we want to use the assembler support for compact line numbers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_comment
comment|/* A "convenient" place to put object file dependencies which do    not need to be seen outside of tc-hppa.c.  */
end_comment

begin_comment
comment|/* Object file formats specify relocation types.  */
end_comment

begin_typedef
typedef|typedef
name|enum
name|elf_hppa_reloc_type
name|reloc_type
typedef|;
end_typedef

begin_comment
comment|/* Object file formats specify BFD symbol types.  */
end_comment

begin_typedef
typedef|typedef
name|elf_symbol_type
name|obj_symbol_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|symbol_arg_reloc_info
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.hppa_arg_reloc)
end_define

begin_if
if|#
directive|if
name|TARGET_ARCH_SIZE
operator|==
literal|64
end_if

begin_comment
comment|/* How to generate a relocation.  */
end_comment

begin_define
define|#
directive|define
name|hppa_gen_reloc_type
value|_bfd_elf64_hppa_gen_reloc_type
end_define

begin_define
define|#
directive|define
name|elf_hppa_reloc_final_type
value|elf64_hppa_reloc_final_type
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hppa_gen_reloc_type
value|_bfd_elf32_hppa_gen_reloc_type
end_define

begin_define
define|#
directive|define
name|elf_hppa_reloc_final_type
value|elf32_hppa_reloc_final_type
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ELF objects can have versions, but apparently do not have anywhere    to store a copyright string.  */
end_comment

begin_define
define|#
directive|define
name|obj_version
value|obj_elf_version
end_define

begin_define
define|#
directive|define
name|obj_copyright
value|obj_elf_version
end_define

begin_define
define|#
directive|define
name|UNWIND_SECTION_NAME
value|".PARISC.unwind"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* Names of various debugging spaces/subspaces.  */
end_comment

begin_define
define|#
directive|define
name|GDB_DEBUG_SPACE_NAME
value|"$GDB_DEBUG$"
end_define

begin_define
define|#
directive|define
name|GDB_STRINGS_SUBSPACE_NAME
value|"$GDB_STRINGS$"
end_define

begin_define
define|#
directive|define
name|GDB_SYMBOLS_SUBSPACE_NAME
value|"$GDB_SYMBOLS$"
end_define

begin_define
define|#
directive|define
name|UNWIND_SECTION_NAME
value|"$UNWIND$"
end_define

begin_comment
comment|/* Object file formats specify relocation types.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|reloc_type
typedef|;
end_typedef

begin_comment
comment|/* SOM objects can have both a version string and a copyright string.  */
end_comment

begin_define
define|#
directive|define
name|obj_version
value|obj_som_version
end_define

begin_define
define|#
directive|define
name|obj_copyright
value|obj_som_copyright
end_define

begin_comment
comment|/* How to generate a relocation.  */
end_comment

begin_define
define|#
directive|define
name|hppa_gen_reloc_type
value|hppa_som_gen_reloc_type
end_define

begin_comment
comment|/* Object file formats specify BFD symbol types.  */
end_comment

begin_typedef
typedef|typedef
name|som_symbol_type
name|obj_symbol_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|symbol_arg_reloc_info
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.ap.hppa_arg_reloc)
end_define

begin_comment
comment|/* This apparently isn't in older versions of hpux reloc.h.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_DLT_REL
end_ifndef

begin_define
define|#
directive|define
name|R_DLT_REL
value|0x78
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N0SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N0SEL
value|0xd8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N1SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N1SEL
value|0xd9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_SOM */
end_comment

begin_if
if|#
directive|if
name|TARGET_ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|DEFAULT_LEVEL
value|25
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_LEVEL
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various structures and types used internally in tc-hppa.c.  */
end_comment

begin_comment
comment|/* Unwind table and descriptor.  FIXME: Sync this with GDB version.  */
end_comment

begin_struct
struct|struct
name|unwind_desc
block|{
name|unsigned
name|int
name|cannot_unwind
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|millicode
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|millicode_save_rest
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|region_desc
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|save_sr
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|entry_fr
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|entry_gr
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|args_stored
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|call_fr
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|call_gr
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|save_sp
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|save_rp
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|save_rp_in_frame
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|extn_ptr_defined
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|cleanup_defined
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|hpe_interrupt_marker
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|hpux_interrupt_marker
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|reserved
range|:
literal|3
decl_stmt|;
name|unsigned
name|int
name|frame_size
range|:
literal|27
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We can't rely on compilers placing bitfields in any particular    place, so use these macros when dumping unwind descriptors to    object files.  */
end_comment

begin_define
define|#
directive|define
name|UNWIND_LOW32
parameter_list|(
name|U
parameter_list|)
define|\
value|(((U)->cannot_unwind<< 31)		\    | ((U)->millicode<< 30)		\    | ((U)->millicode_save_rest<< 29)	\    | ((U)->region_desc<< 27)		\    | ((U)->save_sr<< 25)		\    | ((U)->entry_fr<< 21)		\    | ((U)->entry_gr<< 16)		\    | ((U)->args_stored<< 15)		\    | ((U)->call_fr<< 10)		\    | ((U)->call_gr<< 5)		\    | ((U)->save_sp<< 4)		\    | ((U)->save_rp<< 3)		\    | ((U)->save_rp_in_frame<< 2)	\    | ((U)->extn_ptr_defined<< 1)	\    | ((U)->cleanup_defined<< 0))
end_define

begin_define
define|#
directive|define
name|UNWIND_HIGH32
parameter_list|(
name|U
parameter_list|)
define|\
value|(((U)->hpe_interrupt_marker<< 31)	\    | ((U)->hpux_interrupt_marker<< 30)	\    | ((U)->frame_size<< 0))
end_define

begin_struct
struct|struct
name|unwind_table
block|{
comment|/* Starting and ending offsets of the region described by        descriptor.  */
name|unsigned
name|int
name|start_offset
decl_stmt|;
name|unsigned
name|int
name|end_offset
decl_stmt|;
name|struct
name|unwind_desc
name|descriptor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used by the .callinfo, .enter, .leave pseudo-ops to    control the entry and exit code they generate. It is also used in    creation of the correct stack unwind descriptors.     NOTE:  GAS does not support .enter and .leave for the generation of    prologues and epilogues.  FIXME.     The fields in structure roughly correspond to the arguments available on the    .callinfo pseudo-op.  */
end_comment

begin_struct
struct|struct
name|call_info
block|{
comment|/* The unwind descriptor being built.  */
name|struct
name|unwind_table
name|ci_unwind
decl_stmt|;
comment|/* Name of this function.  */
name|symbolS
modifier|*
name|start_symbol
decl_stmt|;
comment|/* (temporary) symbol used to mark the end of this function.  */
name|symbolS
modifier|*
name|end_symbol
decl_stmt|;
comment|/* Next entry in the chain.  */
name|struct
name|call_info
modifier|*
name|ci_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Operand formats for FP instructions.   Note not all FP instructions    allow all four formats to be used (for example fmpysub only allows    SGL and DBL).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SGL
block|,
name|DBL
block|,
name|ILLEGAL_FMT
block|,
name|QUAD
block|,
name|W
block|,
name|UW
block|,
name|DW
block|,
name|UDW
block|,
name|QW
block|,
name|UQW
block|}
name|fp_operand_format
typedef|;
end_typedef

begin_comment
comment|/* This fully describes the symbol types which may be attached to    an EXPORT or IMPORT directive.  Only SOM uses this formation    (ELF has no need for it).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SYMBOL_TYPE_UNKNOWN
block|,
name|SYMBOL_TYPE_ABSOLUTE
block|,
name|SYMBOL_TYPE_CODE
block|,
name|SYMBOL_TYPE_DATA
block|,
name|SYMBOL_TYPE_ENTRY
block|,
name|SYMBOL_TYPE_MILLICODE
block|,
name|SYMBOL_TYPE_PLABEL
block|,
name|SYMBOL_TYPE_PRI_PROG
block|,
name|SYMBOL_TYPE_SEC_PROG
block|,   }
name|pa_symbol_type
typedef|;
end_typedef

begin_comment
comment|/* This structure contains information needed to assemble    individual instructions.  */
end_comment

begin_struct
struct|struct
name|pa_it
block|{
comment|/* Holds the opcode after parsing by pa_ip.  */
name|unsigned
name|long
name|opcode
decl_stmt|;
comment|/* Holds an expression associated with the current instruction.  */
name|expressionS
name|exp
decl_stmt|;
comment|/* Does this instruction use PC-relative addressing.  */
name|int
name|pcrel
decl_stmt|;
comment|/* Floating point formats for operand1 and operand2.  */
name|fp_operand_format
name|fpof1
decl_stmt|;
name|fp_operand_format
name|fpof2
decl_stmt|;
comment|/* Whether or not we saw a truncation request on an fcnv insn.  */
name|int
name|trunc
decl_stmt|;
comment|/* Holds the field selector for this instruction        (for example L%, LR%, etc).  */
name|long
name|field_selector
decl_stmt|;
comment|/* Holds any argument relocation bits associated with this        instruction.  (instruction should be some sort of call).  */
name|unsigned
name|int
name|arg_reloc
decl_stmt|;
comment|/* The format specification for this instruction.  */
name|int
name|format
decl_stmt|;
comment|/* The relocation (if any) associated with this instruction.  */
name|reloc_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* PA-89 floating point registers are arranged like this:     +--------------+--------------+    |   0 or 16L   |  16 or 16R   |    +--------------+--------------+    |   1 or 17L   |  17 or 17R   |    +--------------+--------------+    |              |              |     .              .              .    .              .              .    .              .              .     |              |              |    +--------------+--------------+    |  14 or 30L   |  30 or 30R   |    +--------------+--------------+    |  15 or 31L   |  31 or 31R   |    +--------------+--------------+  */
end_comment

begin_comment
comment|/* Additional information needed to build argument relocation stubs.  */
end_comment

begin_struct
struct|struct
name|call_desc
block|{
comment|/* The argument relocation specification.  */
name|unsigned
name|int
name|arg_reloc
decl_stmt|;
comment|/* Number of arguments.  */
name|unsigned
name|int
name|arg_count
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* This structure defines an entry in the subspace dictionary    chain.  */
end_comment

begin_struct
struct|struct
name|subspace_dictionary_chain
block|{
comment|/* Nonzero if this space has been defined by the user code.  */
name|unsigned
name|int
name|ssd_defined
decl_stmt|;
comment|/* Name of this subspace.  */
name|char
modifier|*
name|ssd_name
decl_stmt|;
comment|/* GAS segment and subsegment associated with this subspace.  */
name|asection
modifier|*
name|ssd_seg
decl_stmt|;
name|int
name|ssd_subseg
decl_stmt|;
comment|/* Next space in the subspace dictionary chain.  */
name|struct
name|subspace_dictionary_chain
modifier|*
name|ssd_next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|subspace_dictionary_chain
name|ssd_chain_struct
typedef|;
end_typedef

begin_comment
comment|/* This structure defines an entry in the subspace dictionary    chain.  */
end_comment

begin_struct
struct|struct
name|space_dictionary_chain
block|{
comment|/* Nonzero if this space has been defined by the user code or        as a default space.  */
name|unsigned
name|int
name|sd_defined
decl_stmt|;
comment|/* Nonzero if this spaces has been defined by the user code.  */
name|unsigned
name|int
name|sd_user_defined
decl_stmt|;
comment|/* The space number (or index).  */
name|unsigned
name|int
name|sd_spnum
decl_stmt|;
comment|/* The name of this subspace.  */
name|char
modifier|*
name|sd_name
decl_stmt|;
comment|/* GAS segment to which this subspace corresponds.  */
name|asection
modifier|*
name|sd_seg
decl_stmt|;
comment|/* Current subsegment number being used.  */
name|int
name|sd_last_subseg
decl_stmt|;
comment|/* The chain of subspaces contained within this space.  */
name|ssd_chain_struct
modifier|*
name|sd_subspaces
decl_stmt|;
comment|/* The next entry in the space dictionary chain.  */
name|struct
name|space_dictionary_chain
modifier|*
name|sd_next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|space_dictionary_chain
name|sd_chain_struct
typedef|;
end_typedef

begin_comment
comment|/* This structure defines attributes of the default subspace    dictionary entries.  */
end_comment

begin_struct
struct|struct
name|default_subspace_dict
block|{
comment|/* Name of the subspace.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* FIXME.  Is this still needed?  */
name|char
name|defined
decl_stmt|;
comment|/* Nonzero if this subspace is loadable.  */
name|char
name|loadable
decl_stmt|;
comment|/* Nonzero if this subspace contains only code.  */
name|char
name|code_only
decl_stmt|;
comment|/* Nonzero if this is a comdat subspace.  */
name|char
name|comdat
decl_stmt|;
comment|/* Nonzero if this is a common subspace.  */
name|char
name|common
decl_stmt|;
comment|/* Nonzero if this is a common subspace which allows symbols        to be multiply defined.  */
name|char
name|dup_common
decl_stmt|;
comment|/* Nonzero if this subspace should be zero filled.  */
name|char
name|zero
decl_stmt|;
comment|/* Sort key for this subspace.  */
name|unsigned
name|char
name|sort
decl_stmt|;
comment|/* Access control bits for this subspace.  Can represent RWX access        as well as privilege level changes for gateways.  */
name|int
name|access
decl_stmt|;
comment|/* Index of containing space.  */
name|int
name|space_index
decl_stmt|;
comment|/* Alignment (in bytes) of this subspace.  */
name|int
name|alignment
decl_stmt|;
comment|/* Quadrant within space where this subspace should be loaded.  */
name|int
name|quadrant
decl_stmt|;
comment|/* An index into the default spaces array.  */
name|int
name|def_space_index
decl_stmt|;
comment|/* Subsegment associated with this subspace.  */
name|subsegT
name|subsegment
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure defines attributes of the default space    dictionary entries.  */
end_comment

begin_struct
struct|struct
name|default_space_dict
block|{
comment|/* Name of the space.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Space number.  It is possible to identify spaces within        assembly code numerically!  */
name|int
name|spnum
decl_stmt|;
comment|/* Nonzero if this space is loadable.  */
name|char
name|loadable
decl_stmt|;
comment|/* Nonzero if this space is "defined".  FIXME is still needed */
name|char
name|defined
decl_stmt|;
comment|/* Nonzero if this space can not be shared.  */
name|char
name|private
decl_stmt|;
comment|/* Sort key for this space.  */
name|unsigned
name|char
name|sort
decl_stmt|;
comment|/* Segment associated with this space.  */
name|asection
modifier|*
name|segment
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure for previous label tracking.  Needed so that alignments,    callinfo declarations, etc can be easily attached to a particular    label.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|label_symbol_struct
block|{
name|struct
name|symbol
modifier|*
name|lss_label
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
name|sd_chain_struct
modifier|*
name|lss_space
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|segT
name|lss_segment
decl_stmt|;
endif|#
directive|endif
name|struct
name|label_symbol_struct
modifier|*
name|lss_next
decl_stmt|;
block|}
name|label_symbol_struct
typedef|;
end_typedef

begin_comment
comment|/* Extra information needed to perform fixups (relocations) on the PA.  */
end_comment

begin_struct
struct|struct
name|hppa_fix_struct
block|{
comment|/* The field selector.  */
name|enum
name|hppa_reloc_field_selector_type_alt
name|fx_r_field
decl_stmt|;
comment|/* Type of fixup.  */
name|int
name|fx_r_type
decl_stmt|;
comment|/* Format of fixup.  */
name|int
name|fx_r_format
decl_stmt|;
comment|/* Argument relocation bits.  */
name|unsigned
name|int
name|fx_arg_reloc
decl_stmt|;
comment|/* The segment this fixup appears in.  */
name|segT
name|segment
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|pd_reg
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure defines the mapping from a FP condition string    to a condition number which can be recorded in an instruction.  */
end_comment

begin_struct
struct|struct
name|fp_cond_map
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure defines a mapping from a field selector    string to a field selector type.  */
end_comment

begin_struct
struct|struct
name|selector_entry
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|field_selector
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Prototypes for functions local to tc-hppa.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_function_decl
specifier|static
name|void
name|pa_check_current_space_and_subspace
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
end_if

begin_function_decl
specifier|static
name|void
name|pa_text
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_data
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_comm
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_function_decl
specifier|static
name|int
name|exact_log2
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_compiler
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_align
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_space
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_spnum
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa_subspace
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sd_chain_struct
modifier|*
name|create_new_space
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssd_chain_struct
modifier|*
name|create_new_subspace
parameter_list|(
name|sd_chain_struct
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssd_chain_struct
modifier|*
name|update_subspace
parameter_list|(
name|sd_chain_struct
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sd_chain_struct
modifier|*
name|is_defined_space
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssd_chain_struct
modifier|*
name|is_defined_subspace
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sd_chain_struct
modifier|*
name|pa_segment_to_space
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssd_chain_struct
modifier|*
name|pa_subsegment_to_subspace
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sd_chain_struct
modifier|*
name|pa_find_space_by_number
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|pa_subspace_start
parameter_list|(
name|sd_chain_struct
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sd_chain_struct
modifier|*
name|pa_parse_space_stmt
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* File and globally scoped variable declarations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* Root and final entry in the space chain.  */
end_comment

begin_decl_stmt
specifier|static
name|sd_chain_struct
modifier|*
name|space_dict_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sd_chain_struct
modifier|*
name|space_dict_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current space and subspace.  */
end_comment

begin_decl_stmt
specifier|static
name|sd_chain_struct
modifier|*
name|current_space
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssd_chain_struct
modifier|*
name|current_subspace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Root of the call_info chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|call_info
modifier|*
name|call_info_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last call_info (for functions) structure    seen so it can be associated with fixups and    function labels.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|call_info
modifier|*
name|last_call_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last call description (for actual calls).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|call_desc
name|last_call_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These characters can be suffixes of opcode names and they may be    followed by meaningful whitespace.  We don't include `,' and `!'    as they never appear followed by meaningful whitespace.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|hppa_symbol_chars
index|[]
init|=
literal|"*?=<>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.     Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.     Also note that C style comments will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the characters which act as line separators.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.    As in 0f12.456 or 0d1.2345e12.     Be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c.  Ideally it shouldn't hae to know abou it at    all, but nothing is ideal around here.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pa_it
name|the_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the end of an expression just parsed by get_expression    and friends.  FIXME.  This shouldn't be handled with a file-global    variable.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if a .callinfo appeared within the current procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|callinfo_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the assembler is currently within a .entry/.exit pair.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|within_entry_exit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the assembler is currently within a procedure definition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|within_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle on structure which keep track of the last symbol    seen in each subspace.  */
end_comment

begin_decl_stmt
specifier|static
name|label_symbol_struct
modifier|*
name|label_symbols_rootp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the last field selector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hppa_field_selector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when strict matching is enabled.  Zero otherwise.     Each opcode in the table has a flag which indicates whether or    not strict matching should be enabled for that instruction.     Mainly, strict causes errors to be ignored when a match failure    occurs.  However, it also affects the parsing of register fields    by pa_parse_number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strict
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pa_parse_number returns values in `pa_number'.  Mostly    pa_parse_number is used to return a register number, with floating    point registers being numbered from FP_REG_BASE upwards.    The bit specified with FP_REG_RSEL is set if the floating point    register has a `r' suffix.  */
end_comment

begin_define
define|#
directive|define
name|FP_REG_BASE
value|64
end_define

begin_define
define|#
directive|define
name|FP_REG_RSEL
value|128
end_define

begin_decl_stmt
specifier|static
name|int
name|pa_number
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* A dummy bfd symbol so that all relocations have symbols of some kind.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|dummy_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if errors are to be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_errors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of registers that are pre-defined:     Each general register has one predefined name of the form    %r<REGNUM> which has the value<REGNUM>.     Space and control registers are handled in a similar manner,    but use %sr<REGNUM> and %cr<REGNUM> as their predefined names.     Likewise for the floating point registers, but of the form    %fr<REGNUM>.  Floating point registers have additional predefined    names with 'L' and 'R' suffixes (e.g. %fr19L, %fr19R) which    again have the value<REGNUM>.     Many registers also have synonyms:     %r26 - %r23 have %arg0 - %arg3 as synonyms    %r28 - %r29 have %ret0 - %ret1 as synonyms    %fr4 - %fr7 have %farg0 - %farg3 as synonyms    %r30 has %sp as a synonym    %r27 has %dp as a synonym    %r2  has %rp as a synonym     Almost every control register has a synonym; they are not listed    here for brevity.     The table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pd_reg
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"%arg0"
block|,
literal|26
block|}
block|,
block|{
literal|"%arg1"
block|,
literal|25
block|}
block|,
block|{
literal|"%arg2"
block|,
literal|24
block|}
block|,
block|{
literal|"%arg3"
block|,
literal|23
block|}
block|,
block|{
literal|"%cr0"
block|,
literal|0
block|}
block|,
block|{
literal|"%cr10"
block|,
literal|10
block|}
block|,
block|{
literal|"%cr11"
block|,
literal|11
block|}
block|,
block|{
literal|"%cr12"
block|,
literal|12
block|}
block|,
block|{
literal|"%cr13"
block|,
literal|13
block|}
block|,
block|{
literal|"%cr14"
block|,
literal|14
block|}
block|,
block|{
literal|"%cr15"
block|,
literal|15
block|}
block|,
block|{
literal|"%cr16"
block|,
literal|16
block|}
block|,
block|{
literal|"%cr17"
block|,
literal|17
block|}
block|,
block|{
literal|"%cr18"
block|,
literal|18
block|}
block|,
block|{
literal|"%cr19"
block|,
literal|19
block|}
block|,
block|{
literal|"%cr20"
block|,
literal|20
block|}
block|,
block|{
literal|"%cr21"
block|,
literal|21
block|}
block|,
block|{
literal|"%cr22"
block|,
literal|22
block|}
block|,
block|{
literal|"%cr23"
block|,
literal|23
block|}
block|,
block|{
literal|"%cr24"
block|,
literal|24
block|}
block|,
block|{
literal|"%cr25"
block|,
literal|25
block|}
block|,
block|{
literal|"%cr26"
block|,
literal|26
block|}
block|,
block|{
literal|"%cr27"
block|,
literal|27
block|}
block|,
block|{
literal|"%cr28"
block|,
literal|28
block|}
block|,
block|{
literal|"%cr29"
block|,
literal|29
block|}
block|,
block|{
literal|"%cr30"
block|,
literal|30
block|}
block|,
block|{
literal|"%cr31"
block|,
literal|31
block|}
block|,
block|{
literal|"%cr8"
block|,
literal|8
block|}
block|,
block|{
literal|"%cr9"
block|,
literal|9
block|}
block|,
block|{
literal|"%dp"
block|,
literal|27
block|}
block|,
block|{
literal|"%eiem"
block|,
literal|15
block|}
block|,
block|{
literal|"%eirr"
block|,
literal|23
block|}
block|,
block|{
literal|"%farg0"
block|,
literal|4
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%farg1"
block|,
literal|5
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%farg2"
block|,
literal|6
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%farg3"
block|,
literal|7
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr0"
block|,
literal|0
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr0l"
block|,
literal|0
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr0r"
block|,
literal|0
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr1"
block|,
literal|1
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr10"
block|,
literal|10
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr10l"
block|,
literal|10
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr10r"
block|,
literal|10
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr11"
block|,
literal|11
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr11l"
block|,
literal|11
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr11r"
block|,
literal|11
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr12"
block|,
literal|12
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr12l"
block|,
literal|12
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr12r"
block|,
literal|12
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr13"
block|,
literal|13
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr13l"
block|,
literal|13
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr13r"
block|,
literal|13
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr14"
block|,
literal|14
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr14l"
block|,
literal|14
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr14r"
block|,
literal|14
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr15"
block|,
literal|15
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr15l"
block|,
literal|15
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr15r"
block|,
literal|15
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr16"
block|,
literal|16
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr16l"
block|,
literal|16
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr16r"
block|,
literal|16
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr17"
block|,
literal|17
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr17l"
block|,
literal|17
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr17r"
block|,
literal|17
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr18"
block|,
literal|18
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr18l"
block|,
literal|18
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr18r"
block|,
literal|18
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr19"
block|,
literal|19
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr19l"
block|,
literal|19
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr19r"
block|,
literal|19
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr1l"
block|,
literal|1
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr1r"
block|,
literal|1
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr2"
block|,
literal|2
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr20"
block|,
literal|20
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr20l"
block|,
literal|20
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr20r"
block|,
literal|20
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr21"
block|,
literal|21
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr21l"
block|,
literal|21
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr21r"
block|,
literal|21
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr22"
block|,
literal|22
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr22l"
block|,
literal|22
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr22r"
block|,
literal|22
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr23"
block|,
literal|23
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr23l"
block|,
literal|23
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr23r"
block|,
literal|23
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr24"
block|,
literal|24
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr24l"
block|,
literal|24
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr24r"
block|,
literal|24
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr25"
block|,
literal|25
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr25l"
block|,
literal|25
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr25r"
block|,
literal|25
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr26"
block|,
literal|26
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr26l"
block|,
literal|26
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr26r"
block|,
literal|26
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr27"
block|,
literal|27
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr27l"
block|,
literal|27
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr27r"
block|,
literal|27
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr28"
block|,
literal|28
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr28l"
block|,
literal|28
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr28r"
block|,
literal|28
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr29"
block|,
literal|29
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr29l"
block|,
literal|29
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr29r"
block|,
literal|29
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr2l"
block|,
literal|2
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr2r"
block|,
literal|2
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr3"
block|,
literal|3
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr30"
block|,
literal|30
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr30l"
block|,
literal|30
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr30r"
block|,
literal|30
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr31"
block|,
literal|31
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr31l"
block|,
literal|31
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr31r"
block|,
literal|31
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr3l"
block|,
literal|3
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr3r"
block|,
literal|3
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr4"
block|,
literal|4
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr4l"
block|,
literal|4
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr4r"
block|,
literal|4
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr5"
block|,
literal|5
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr5l"
block|,
literal|5
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr5r"
block|,
literal|5
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr6"
block|,
literal|6
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr6l"
block|,
literal|6
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr6r"
block|,
literal|6
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr7"
block|,
literal|7
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr7l"
block|,
literal|7
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr7r"
block|,
literal|7
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr8"
block|,
literal|8
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr8l"
block|,
literal|8
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr8r"
block|,
literal|8
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fr9"
block|,
literal|9
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr9l"
block|,
literal|9
operator|+
name|FP_REG_BASE
block|}
block|,
block|{
literal|"%fr9r"
block|,
literal|9
operator|+
name|FP_REG_BASE
operator|+
name|FP_REG_RSEL
block|}
block|,
block|{
literal|"%fret"
block|,
literal|4
block|}
block|,
block|{
literal|"%hta"
block|,
literal|25
block|}
block|,
block|{
literal|"%iir"
block|,
literal|19
block|}
block|,
block|{
literal|"%ior"
block|,
literal|21
block|}
block|,
block|{
literal|"%ipsw"
block|,
literal|22
block|}
block|,
block|{
literal|"%isr"
block|,
literal|20
block|}
block|,
block|{
literal|"%itmr"
block|,
literal|16
block|}
block|,
block|{
literal|"%iva"
block|,
literal|14
block|}
block|,
if|#
directive|if
name|TARGET_ARCH_SIZE
operator|==
literal|64
block|{
literal|"%mrp"
block|,
literal|2
block|}
block|,
else|#
directive|else
block|{
literal|"%mrp"
block|,
literal|31
block|}
block|,
endif|#
directive|endif
block|{
literal|"%pcoq"
block|,
literal|18
block|}
block|,
block|{
literal|"%pcsq"
block|,
literal|17
block|}
block|,
block|{
literal|"%pidr1"
block|,
literal|8
block|}
block|,
block|{
literal|"%pidr2"
block|,
literal|9
block|}
block|,
block|{
literal|"%pidr3"
block|,
literal|12
block|}
block|,
block|{
literal|"%pidr4"
block|,
literal|13
block|}
block|,
block|{
literal|"%ppda"
block|,
literal|24
block|}
block|,
block|{
literal|"%r0"
block|,
literal|0
block|}
block|,
block|{
literal|"%r1"
block|,
literal|1
block|}
block|,
block|{
literal|"%r10"
block|,
literal|10
block|}
block|,
block|{
literal|"%r11"
block|,
literal|11
block|}
block|,
block|{
literal|"%r12"
block|,
literal|12
block|}
block|,
block|{
literal|"%r13"
block|,
literal|13
block|}
block|,
block|{
literal|"%r14"
block|,
literal|14
block|}
block|,
block|{
literal|"%r15"
block|,
literal|15
block|}
block|,
block|{
literal|"%r16"
block|,
literal|16
block|}
block|,
block|{
literal|"%r17"
block|,
literal|17
block|}
block|,
block|{
literal|"%r18"
block|,
literal|18
block|}
block|,
block|{
literal|"%r19"
block|,
literal|19
block|}
block|,
block|{
literal|"%r2"
block|,
literal|2
block|}
block|,
block|{
literal|"%r20"
block|,
literal|20
block|}
block|,
block|{
literal|"%r21"
block|,
literal|21
block|}
block|,
block|{
literal|"%r22"
block|,
literal|22
block|}
block|,
block|{
literal|"%r23"
block|,
literal|23
block|}
block|,
block|{
literal|"%r24"
block|,
literal|24
block|}
block|,
block|{
literal|"%r25"
block|,
literal|25
block|}
block|,
block|{
literal|"%r26"
block|,
literal|26
block|}
block|,
block|{
literal|"%r27"
block|,
literal|27
block|}
block|,
block|{
literal|"%r28"
block|,
literal|28
block|}
block|,
block|{
literal|"%r29"
block|,
literal|29
block|}
block|,
block|{
literal|"%r3"
block|,
literal|3
block|}
block|,
block|{
literal|"%r30"
block|,
literal|30
block|}
block|,
block|{
literal|"%r31"
block|,
literal|31
block|}
block|,
block|{
literal|"%r4"
block|,
literal|4
block|}
block|,
block|{
literal|"%r5"
block|,
literal|5
block|}
block|,
block|{
literal|"%r6"
block|,
literal|6
block|}
block|,
block|{
literal|"%r7"
block|,
literal|7
block|}
block|,
block|{
literal|"%r8"
block|,
literal|8
block|}
block|,
block|{
literal|"%r9"
block|,
literal|9
block|}
block|,
block|{
literal|"%rctr"
block|,
literal|0
block|}
block|,
block|{
literal|"%ret0"
block|,
literal|28
block|}
block|,
block|{
literal|"%ret1"
block|,
literal|29
block|}
block|,
block|{
literal|"%rp"
block|,
literal|2
block|}
block|,
block|{
literal|"%sar"
block|,
literal|11
block|}
block|,
block|{
literal|"%sp"
block|,
literal|30
block|}
block|,
block|{
literal|"%sr0"
block|,
literal|0
block|}
block|,
block|{
literal|"%sr1"
block|,
literal|1
block|}
block|,
block|{
literal|"%sr2"
block|,
literal|2
block|}
block|,
block|{
literal|"%sr3"
block|,
literal|3
block|}
block|,
block|{
literal|"%sr4"
block|,
literal|4
block|}
block|,
block|{
literal|"%sr5"
block|,
literal|5
block|}
block|,
block|{
literal|"%sr6"
block|,
literal|6
block|}
block|,
block|{
literal|"%sr7"
block|,
literal|7
block|}
block|,
block|{
literal|"%t1"
block|,
literal|22
block|}
block|,
block|{
literal|"%t2"
block|,
literal|21
block|}
block|,
block|{
literal|"%t3"
block|,
literal|20
block|}
block|,
block|{
literal|"%t4"
block|,
literal|19
block|}
block|,
block|{
literal|"%tf1"
block|,
literal|11
block|}
block|,
block|{
literal|"%tf2"
block|,
literal|10
block|}
block|,
block|{
literal|"%tf3"
block|,
literal|9
block|}
block|,
block|{
literal|"%tf4"
block|,
literal|8
block|}
block|,
block|{
literal|"%tr0"
block|,
literal|24
block|}
block|,
block|{
literal|"%tr1"
block|,
literal|25
block|}
block|,
block|{
literal|"%tr2"
block|,
literal|26
block|}
block|,
block|{
literal|"%tr3"
block|,
literal|27
block|}
block|,
block|{
literal|"%tr4"
block|,
literal|28
block|}
block|,
block|{
literal|"%tr5"
block|,
literal|29
block|}
block|,
block|{
literal|"%tr6"
block|,
literal|30
block|}
block|,
block|{
literal|"%tr7"
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is sorted by order of the length of the string. This is    so we check for<> before we check for<. If we had a<> and checked    for< first, we would get a false match.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fp_cond_map
name|fp_cond_map
index|[]
init|=
block|{
block|{
literal|"false?"
block|,
literal|0
block|}
block|,
block|{
literal|"false"
block|,
literal|1
block|}
block|,
block|{
literal|"true?"
block|,
literal|30
block|}
block|,
block|{
literal|"true"
block|,
literal|31
block|}
block|,
block|{
literal|"!<=>"
block|,
literal|3
block|}
block|,
block|{
literal|"!?>="
block|,
literal|8
block|}
block|,
block|{
literal|"!?<="
block|,
literal|16
block|}
block|,
block|{
literal|"!<>"
block|,
literal|7
block|}
block|,
block|{
literal|"!>="
block|,
literal|11
block|}
block|,
block|{
literal|"!?>"
block|,
literal|12
block|}
block|,
block|{
literal|"?<="
block|,
literal|14
block|}
block|,
block|{
literal|"!<="
block|,
literal|19
block|}
block|,
block|{
literal|"!?<"
block|,
literal|20
block|}
block|,
block|{
literal|"?>="
block|,
literal|22
block|}
block|,
block|{
literal|"!?="
block|,
literal|24
block|}
block|,
block|{
literal|"!=t"
block|,
literal|27
block|}
block|,
block|{
literal|"<=>"
block|,
literal|29
block|}
block|,
block|{
literal|"=t"
block|,
literal|5
block|}
block|,
block|{
literal|"?="
block|,
literal|6
block|}
block|,
block|{
literal|"?<"
block|,
literal|10
block|}
block|,
block|{
literal|"<="
block|,
literal|13
block|}
block|,
block|{
literal|"!>"
block|,
literal|15
block|}
block|,
block|{
literal|"?>"
block|,
literal|18
block|}
block|,
block|{
literal|">="
block|,
literal|21
block|}
block|,
block|{
literal|"!<"
block|,
literal|23
block|}
block|,
block|{
literal|"<>"
block|,
literal|25
block|}
block|,
block|{
literal|"!="
block|,
literal|26
block|}
block|,
block|{
literal|"!?"
block|,
literal|28
block|}
block|,
block|{
literal|"?"
block|,
literal|2
block|}
block|,
block|{
literal|"="
block|,
literal|4
block|}
block|,
block|{
literal|"<"
block|,
literal|9
block|}
block|,
block|{
literal|">"
block|,
literal|17
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|selector_entry
name|selector_table
index|[]
init|=
block|{
block|{
literal|"f"
block|,
name|e_fsel
block|}
block|,
block|{
literal|"l"
block|,
name|e_lsel
block|}
block|,
block|{
literal|"ld"
block|,
name|e_ldsel
block|}
block|,
block|{
literal|"lp"
block|,
name|e_lpsel
block|}
block|,
block|{
literal|"lr"
block|,
name|e_lrsel
block|}
block|,
block|{
literal|"ls"
block|,
name|e_lssel
block|}
block|,
block|{
literal|"lt"
block|,
name|e_ltsel
block|}
block|,
block|{
literal|"ltp"
block|,
name|e_ltpsel
block|}
block|,
block|{
literal|"n"
block|,
name|e_nsel
block|}
block|,
block|{
literal|"nl"
block|,
name|e_nlsel
block|}
block|,
block|{
literal|"nlr"
block|,
name|e_nlrsel
block|}
block|,
block|{
literal|"p"
block|,
name|e_psel
block|}
block|,
block|{
literal|"r"
block|,
name|e_rsel
block|}
block|,
block|{
literal|"rd"
block|,
name|e_rdsel
block|}
block|,
block|{
literal|"rp"
block|,
name|e_rpsel
block|}
block|,
block|{
literal|"rr"
block|,
name|e_rrsel
block|}
block|,
block|{
literal|"rs"
block|,
name|e_rssel
block|}
block|,
block|{
literal|"rt"
block|,
name|e_rtsel
block|}
block|,
block|{
literal|"rtp"
block|,
name|e_rtpsel
block|}
block|,
block|{
literal|"t"
block|,
name|e_tsel
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* default space and subspace dictionaries */
end_comment

begin_define
define|#
directive|define
name|GDB_SYMBOLS
value|GDB_SYMBOLS_SUBSPACE_NAME
end_define

begin_define
define|#
directive|define
name|GDB_STRINGS
value|GDB_STRINGS_SUBSPACE_NAME
end_define

begin_comment
comment|/* pre-defined subsegments (subspaces) for the HPPA.  */
end_comment

begin_define
define|#
directive|define
name|SUBSEG_CODE
value|0
end_define

begin_define
define|#
directive|define
name|SUBSEG_LIT
value|1
end_define

begin_define
define|#
directive|define
name|SUBSEG_MILLI
value|2
end_define

begin_define
define|#
directive|define
name|SUBSEG_DATA
value|0
end_define

begin_define
define|#
directive|define
name|SUBSEG_BSS
value|2
end_define

begin_define
define|#
directive|define
name|SUBSEG_UNWIND
value|3
end_define

begin_define
define|#
directive|define
name|SUBSEG_GDB_STRINGS
value|0
end_define

begin_define
define|#
directive|define
name|SUBSEG_GDB_SYMBOLS
value|1
end_define

begin_decl_stmt
specifier|static
name|struct
name|default_subspace_dict
name|pa_def_subspaces
index|[]
init|=
block|{
block|{
literal|"$CODE$"
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|24
block|,
literal|0x2c
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
name|SUBSEG_CODE
block|}
block|,
block|{
literal|"$DATA$"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|24
block|,
literal|0x1f
block|,
literal|1
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|,
name|SUBSEG_DATA
block|}
block|,
block|{
literal|"$LIT$"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|0x2c
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
name|SUBSEG_LIT
block|}
block|,
block|{
literal|"$MILLICODE$"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|0x2c
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
name|SUBSEG_MILLI
block|}
block|,
block|{
literal|"$BSS$"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|80
block|,
literal|0x1f
block|,
literal|1
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|,
name|SUBSEG_BSS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|,
literal|0x1f
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|default_space_dict
name|pa_def_spaces
index|[]
init|=
block|{
block|{
literal|"$TEXT$"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|8
block|,
name|ASEC_NULL
block|}
block|,
block|{
literal|"$PRIVATE$"
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|16
block|,
name|ASEC_NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ASEC_NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc local definitions used by the assembler.  */
end_comment

begin_comment
comment|/* These macros are used to maintain spaces/subspaces.  */
end_comment

begin_define
define|#
directive|define
name|SPACE_DEFINED
parameter_list|(
name|space_chain
parameter_list|)
value|(space_chain)->sd_defined
end_define

begin_define
define|#
directive|define
name|SPACE_USER_DEFINED
parameter_list|(
name|space_chain
parameter_list|)
value|(space_chain)->sd_user_defined
end_define

begin_define
define|#
directive|define
name|SPACE_SPNUM
parameter_list|(
name|space_chain
parameter_list|)
value|(space_chain)->sd_spnum
end_define

begin_define
define|#
directive|define
name|SPACE_NAME
parameter_list|(
name|space_chain
parameter_list|)
value|(space_chain)->sd_name
end_define

begin_define
define|#
directive|define
name|SUBSPACE_DEFINED
parameter_list|(
name|ss_chain
parameter_list|)
value|(ss_chain)->ssd_defined
end_define

begin_define
define|#
directive|define
name|SUBSPACE_NAME
parameter_list|(
name|ss_chain
parameter_list|)
value|(ss_chain)->ssd_name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return nonzero if the string pointed to by S potentially represents    a right or left half of a FP register  */
end_comment

begin_define
define|#
directive|define
name|IS_R_SELECT
parameter_list|(
name|S
parameter_list|)
value|(*(S) == 'R' || *(S) == 'r')
end_define

begin_define
define|#
directive|define
name|IS_L_SELECT
parameter_list|(
name|S
parameter_list|)
value|(*(S) == 'L' || *(S) == 'l')
end_define

begin_comment
comment|/* Insert FIELD into OPCODE starting at bit START.  Continue pa_ip    main loop after insertion.  */
end_comment

begin_define
define|#
directive|define
name|INSERT_FIELD_AND_CONTINUE
parameter_list|(
name|OPCODE
parameter_list|,
name|FIELD
parameter_list|,
name|START
parameter_list|)
define|\
value|{ \     ((OPCODE) |= (FIELD)<< (START)); \     continue; \   }
end_define

begin_comment
comment|/* Simple range checking for FIELD against HIGH and LOW bounds.    IGNORE is used to suppress the error message.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_FIELD
parameter_list|(
name|FIELD
parameter_list|,
name|HIGH
parameter_list|,
name|LOW
parameter_list|,
name|IGNORE
parameter_list|)
define|\
value|{ \     if ((FIELD)> (HIGH) || (FIELD)< (LOW)) \       { \ 	if (! IGNORE) \           as_bad (_("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \ 		  (int) (FIELD));\         break; \       } \   }
end_define

begin_comment
comment|/* Variant of CHECK_FIELD for use in md_apply_fix and other places where    the current file and line number are not valid.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_FIELD_WHERE
parameter_list|(
name|FIELD
parameter_list|,
name|HIGH
parameter_list|,
name|LOW
parameter_list|,
name|FILENAME
parameter_list|,
name|LINE
parameter_list|)
define|\
value|{ \     if ((FIELD)> (HIGH) || (FIELD)< (LOW)) \       { \         as_bad_where ((FILENAME), (LINE), \ 		      _("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \ 		      (int) (FIELD));\         break; \       } \   }
end_define

begin_comment
comment|/* Simple alignment checking for FIELD against ALIGN (a power of two).    IGNORE is used to suppress the error message.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_ALIGN
parameter_list|(
name|FIELD
parameter_list|,
name|ALIGN
parameter_list|,
name|IGNORE
parameter_list|)
define|\
value|{ \     if ((FIELD)& ((ALIGN) - 1)) \       { \ 	if (! IGNORE) \           as_bad (_("Field not properly aligned [%d] (%d)."), (ALIGN), \ 		  (int) (FIELD));\         break; \       } \   }
end_define

begin_define
define|#
directive|define
name|is_DP_relative
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$global$") == 0)
end_define

begin_define
define|#
directive|define
name|is_PC_relative
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$PIC_pcrel$0") == 0)
end_define

begin_define
define|#
directive|define
name|is_tls_gdidx
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_gdidx$") == 0)
end_define

begin_define
define|#
directive|define
name|is_tls_ldidx
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_ldidx$") == 0)
end_define

begin_define
define|#
directive|define
name|is_tls_dtpoff
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_dtpoff$") == 0)
end_define

begin_define
define|#
directive|define
name|is_tls_ieoff
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_ieoff$") == 0)
end_define

begin_define
define|#
directive|define
name|is_tls_leoff
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op == O_subtract			\&& strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_leoff$") == 0)
end_define

begin_comment
comment|/* We need some complex handling for stabs (sym1 - sym2).  Luckily, we'll    always be able to reduce the expression to a constant, so we don't    need real complex handling yet.  */
end_comment

begin_define
define|#
directive|define
name|is_complex
parameter_list|(
name|exp
parameter_list|)
define|\
value|((exp).X_op != O_constant&& (exp).X_op != O_symbol)
end_define

begin_comment
comment|/* Actual functions to implement the PA specific code for the assembler.  */
end_comment

begin_comment
comment|/* Called before writing the object file.  Make sure entry/exit and    proc/procend pairs match.  */
end_comment

begin_function
name|void
name|pa_check_eof
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|within_entry_exit
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing .exit\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_procedure
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Missing .procend\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the label_symbol_struct for the current space.    or NULL if no label_symbol_struct exists for the current space.  */
end_comment

begin_function
specifier|static
name|label_symbol_struct
modifier|*
name|pa_get_label
parameter_list|(
name|void
parameter_list|)
block|{
name|label_symbol_struct
modifier|*
name|label_chain
decl_stmt|;
for|for
control|(
name|label_chain
operator|=
name|label_symbols_rootp
init|;
name|label_chain
condition|;
name|label_chain
operator|=
name|label_chain
operator|->
name|lss_next
control|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
if|if
condition|(
name|current_space
operator|==
name|label_chain
operator|->
name|lss_space
operator|&&
name|label_chain
operator|->
name|lss_label
condition|)
return|return
name|label_chain
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|now_seg
operator|==
name|label_chain
operator|->
name|lss_segment
operator|&&
name|label_chain
operator|->
name|lss_label
condition|)
return|return
name|label_chain
return|;
endif|#
directive|endif
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Defines a label for the current space.  If one is already defined,    this function will replace it with the new label.  */
end_comment

begin_function
name|void
name|pa_define_label
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|)
block|{
name|label_symbol_struct
modifier|*
name|label_chain
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|label_chain
condition|)
name|label_chain
operator|->
name|lss_label
operator|=
name|symbol
expr_stmt|;
else|else
block|{
comment|/* Create a new label entry and add it to the head of the chain.  */
name|label_chain
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|label_symbol_struct
argument_list|)
argument_list|)
expr_stmt|;
name|label_chain
operator|->
name|lss_label
operator|=
name|symbol
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
name|label_chain
operator|->
name|lss_space
operator|=
name|current_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|label_chain
operator|->
name|lss_segment
operator|=
name|now_seg
expr_stmt|;
endif|#
directive|endif
name|label_chain
operator|->
name|lss_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|label_symbols_rootp
condition|)
name|label_chain
operator|->
name|lss_next
operator|=
name|label_symbols_rootp
expr_stmt|;
name|label_symbols_rootp
operator|=
name|label_chain
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_label
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Removes a label definition for the current space.    If there is no label_symbol_struct entry, then no action is taken.  */
end_comment

begin_function
specifier|static
name|void
name|pa_undefine_label
parameter_list|(
name|void
parameter_list|)
block|{
name|label_symbol_struct
modifier|*
name|label_chain
decl_stmt|;
name|label_symbol_struct
modifier|*
name|prev_label_chain
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|label_chain
operator|=
name|label_symbols_rootp
init|;
name|label_chain
condition|;
name|label_chain
operator|=
name|label_chain
operator|->
name|lss_next
control|)
block|{
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|OBJ_SOM
operator|&&
name|current_space
operator|==
name|label_chain
operator|->
name|lss_space
operator|&&
name|label_chain
operator|->
name|lss_label
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
operator|&&
name|now_seg
operator|==
name|label_chain
operator|->
name|lss_segment
operator|&&
name|label_chain
operator|->
name|lss_label
endif|#
directive|endif
condition|)
block|{
comment|/* Remove the label from the chain and free its memory.  */
if|if
condition|(
name|prev_label_chain
condition|)
name|prev_label_chain
operator|->
name|lss_next
operator|=
name|label_chain
operator|->
name|lss_next
expr_stmt|;
else|else
name|label_symbols_rootp
operator|=
name|label_chain
operator|->
name|lss_next
expr_stmt|;
name|free
argument_list|(
name|label_chain
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_label_chain
operator|=
name|label_chain
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* An HPPA-specific version of fix_new.  This is required because the HPPA    code needs to keep track of some extra stuff.  Each call to fix_new_hppa    results in the creation of an instance of an hppa_fix_struct.  An    hppa_fix_struct stores the extra information along with a pointer to the    original fixS.  This is attached to the original fixup via the    tc_fix_data field.  */
end_comment

begin_function
specifier|static
name|void
name|fix_new_hppa
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|symbolS
modifier|*
name|add_symbol
parameter_list|,
name|offsetT
name|offset
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|bfd_reloc_code_real_type
name|r_type
parameter_list|,
name|enum
name|hppa_reloc_field_selector_type_alt
name|r_field
parameter_list|,
name|int
name|r_format
parameter_list|,
name|unsigned
name|int
name|arg_reloc
parameter_list|,
name|int
name|unwind_bits
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fix
init|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hppa_fix_struct
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
name|NULL
condition|)
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
name|new_fix
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|tc_fix_data
operator|=
operator|(
name|void
operator|*
operator|)
name|hppa_fix
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_type
operator|=
name|r_type
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_field
operator|=
name|r_field
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_format
operator|=
name|r_format
expr_stmt|;
name|hppa_fix
operator|->
name|fx_arg_reloc
operator|=
name|arg_reloc
expr_stmt|;
name|hppa_fix
operator|->
name|segment
operator|=
name|now_seg
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
if|if
condition|(
name|r_type
operator|==
name|R_ENTRY
operator|||
name|r_type
operator|==
name|R_EXIT
condition|)
name|new_fix
operator|->
name|fx_offset
operator|=
name|unwind_bits
expr_stmt|;
endif|#
directive|endif
comment|/* foo-$global$ is used to access non-automatic storage.  $global$      is really just a marker and has served its purpose, so eliminate      it now so as not to confuse write.c.  Ditto for $PIC_pcrel$0.  */
if|if
condition|(
name|new_fix
operator|->
name|fx_subsy
operator|&&
operator|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$global$"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$PIC_pcrel$0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$tls_gdidx$"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$tls_ldidx$"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$tls_dtpoff$"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$tls_ieoff$"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|new_fix
operator|->
name|fx_subsy
argument_list|)
argument_list|,
literal|"$tls_leoff$"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|new_fix
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This fix_new is called by cons via TC_CONS_FIX_NEW.    hppa_field_selector is set by the parse_cons_expression_hppa.  */
end_comment

begin_function
name|void
name|cons_fix_new_hppa
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|unsigned
name|int
name|rel_type
decl_stmt|;
comment|/* Get a base relocation type.  */
if|if
condition|(
name|is_DP_relative
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|is_complex
argument_list|(
operator|*
name|exp
argument_list|)
condition|)
name|rel_type
operator|=
name|R_HPPA_COMPLEX
expr_stmt|;
else|else
name|rel_type
operator|=
name|R_HPPA
expr_stmt|;
if|if
condition|(
name|hppa_field_selector
operator|!=
name|e_psel
operator|&&
name|hppa_field_selector
operator|!=
name|e_fsel
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid field selector.  Assuming F%%."
argument_list|)
argument_list|)
expr_stmt|;
name|hppa_field_selector
operator|=
name|e_fsel
expr_stmt|;
block|}
name|fix_new_hppa
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|rel_type
argument_list|,
name|hppa_field_selector
argument_list|,
name|size
operator|*
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset field selector to its default state.  */
name|hppa_field_selector
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark (via expr_end) the end of an expression (I think).  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|get_expression
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|asection
modifier|*
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|the_insn
operator|.
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|seg
operator|==
name|absolute_section
operator|||
name|seg
operator|==
name|undefined_section
operator|||
name|SEG_NORMAL
argument_list|(
name|seg
argument_list|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad segment in expression."
argument_list|)
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return;
block|}
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a PA nullification completer (,n).  Return nonzero if the    completer was found; return zero if no completer was found.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_nullif
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|nullif
decl_stmt|;
name|nullif
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|=
operator|*
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|nullif
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Nullification: (%c)"
argument_list|)
argument_list|,
operator|*
operator|*
name|s
argument_list|)
expr_stmt|;
name|nullif
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|s
operator|=
operator|*
name|s
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|nullif
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message or NULL is returned.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write out big-endian.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fixp
decl_stmt|;
specifier|static
name|arelent
modifier|*
name|no_relocs
init|=
name|NULL
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|reloc_type
modifier|*
modifier|*
name|codes
decl_stmt|;
name|reloc_type
name|code
decl_stmt|;
name|int
name|n_relocs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hppa_fixp
operator|=
operator|(
expr|struct
name|hppa_fix_struct
operator|*
operator|)
name|fixp
operator|->
name|tc_fix_data
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
return|return
operator|&
name|no_relocs
return|;
name|assert
argument_list|(
name|hppa_fixp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|section
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|codes
operator|=
name|hppa_gen_reloc_type
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|,
name|hppa_fixp
operator|->
name|fx_r_format
argument_list|,
name|hppa_fixp
operator|->
name|fx_r_field
argument_list|,
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
argument_list|,
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codes
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot handle fixup"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|n_relocs
operator|=
literal|0
init|;
name|codes
index|[
name|n_relocs
index|]
condition|;
name|n_relocs
operator|++
control|)
empty_stmt|;
name|relocs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
name|n_relocs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
operator|*
name|n_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_relocs
condition|;
name|i
operator|++
control|)
name|relocs
index|[
name|i
index|]
operator|=
operator|&
name|reloc
index|[
name|i
index|]
expr_stmt|;
name|relocs
index|[
name|n_relocs
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
default|default:
name|assert
argument_list|(
name|n_relocs
operator|==
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
operator|*
name|codes
index|[
literal|0
index|]
expr_stmt|;
comment|/* Now, do any processing that is dependent on the relocation type.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|R_PARISC_DLTREL21L
case|:
case|case
name|R_PARISC_DLTREL14R
case|:
case|case
name|R_PARISC_DLTREL14F
case|:
case|case
name|R_PARISC_PLABEL32
case|:
case|case
name|R_PARISC_PLABEL21L
case|:
case|case
name|R_PARISC_PLABEL14R
case|:
comment|/* For plabel relocations, the addend of the 	     relocation should be either 0 (no static link) or 2 	     (static link required).  This adjustment is done in 	     bfd/elf32-hppa.c:elf32_hppa_relocate_section.  	     We also slam a zero addend into the DLT relative relocs; 	     it doesn't make a lot of sense to use any addend since 	     it gets you a different (eg unknown) DLT entry.  */
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ELF_ARG_RELOC
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_DIR21L
case|:
name|reloc
operator|->
name|addend
operator|=
name|HPPA_R_ADDEND
argument_list|(
name|hppa_fixp
operator|->
name|fx_arg_reloc
argument_list|,
name|fixp
operator|->
name|fx_offset
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|R_PARISC_DIR32
case|:
comment|/* Facilitate hand-crafted unwind info.  */
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|UNWIND_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|R_PARISC_SEGREL32
expr_stmt|;
comment|/* Fall thru */
default|default:
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
break|break;
block|}
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
name|code
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|assert
argument_list|(
name|reloc
operator|->
name|howto
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|code
operator|==
name|reloc
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* OBJ_SOM */
comment|/* Walk over reach relocation returned by the BFD backend.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_relocs
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|=
operator|*
name|codes
index|[
name|i
index|]
expr_stmt|;
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
name|code
argument_list|)
expr_stmt|;
name|relocs
index|[
name|i
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|R_COMP2
case|:
comment|/* The only time we ever use a R_COMP2 fixup is for the difference 	     of two symbols.  With that in mind we fill in all four 	     relocs now and break out of the loop.  */
name|assert
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|0
index|]
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relocs
index|[
literal|0
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
operator|*
name|codes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|0
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|relocs
index|[
literal|0
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|relocs
index|[
literal|1
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs
index|[
literal|1
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|1
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
operator|*
name|codes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|1
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|relocs
index|[
literal|1
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|relocs
index|[
literal|2
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs
index|[
literal|2
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|2
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
operator|*
name|codes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|2
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|relocs
index|[
literal|2
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|relocs
index|[
literal|3
index|]
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relocs
index|[
literal|3
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
operator|*
name|codes
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|3
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|relocs
index|[
literal|3
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|relocs
index|[
literal|4
index|]
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relocs
index|[
literal|4
index|]
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
operator|*
name|codes
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|4
index|]
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|relocs
index|[
literal|4
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|R_PCREL_CALL
case|:
case|case
name|R_ABS_CALL
case|:
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|=
name|HPPA_R_ADDEND
argument_list|(
name|hppa_fixp
operator|->
name|fx_arg_reloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_DLT_REL
case|:
case|case
name|R_DATA_PLABEL
case|:
case|case
name|R_CODE_PLABEL
case|:
comment|/* For plabel relocations, the addend of the 	     relocation should be either 0 (no static link) or 2 	     (static link required).  	     FIXME: We always assume no static link!  	     We also slam a zero addend into the DLT relative relocs; 	     it doesn't make a lot of sense to use any addend since 	     it gets you a different (eg unknown) DLT entry.  */
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_N_MODE
case|:
case|case
name|R_S_MODE
case|:
case|case
name|R_D_MODE
case|:
case|case
name|R_R_MODE
case|:
case|case
name|R_FSEL
case|:
case|case
name|R_LSEL
case|:
case|case
name|R_RSEL
case|:
case|case
name|R_BEGIN_BRTAB
case|:
case|case
name|R_END_BRTAB
case|:
case|case
name|R_BEGIN_TRY
case|:
case|case
name|R_N0SEL
case|:
case|case
name|R_N1SEL
case|:
comment|/* There is no symbol or addend associated with these fixups.  */
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|dummy_symbol
argument_list|)
expr_stmt|;
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_END_TRY
case|:
case|case
name|R_ENTRY
case|:
case|case
name|R_EXIT
case|:
comment|/* There is no symbol associated with these fixups.  */
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|dummy_symbol
argument_list|)
expr_stmt|;
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
break|break;
default|default:
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
block|}
block|}
name|done
label|:
endif|#
directive|endif
return|return
name|relocs
return|;
block|}
end_function

begin_comment
comment|/* Process any machine dependent frag types.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|unsigned
name|int
name|address
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
literal|0
case|:
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_var
operator|==
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|address
operator|%
name|fragP
operator|->
name|fr_offset
condition|)
block|{
name|fragP
operator|->
name|fr_offset
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
block|}
else|else
name|fragP
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
name|int
name|align2
init|=
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|size
operator|+
name|align2
operator|)
operator|&
operator|~
name|align2
return|;
block|}
end_function

begin_comment
comment|/* Return the approximate size of a frag before relaxation has occurred.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|asection
modifier|*
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|size
operator|)
operator|%
name|fragP
operator|->
name|fr_offset
condition|)
name|size
operator|++
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|WARN_COMMENTS
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"Vc"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"V"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|WARN_COMMENTS
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"c"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|WARN_COMMENTS
block|{
literal|"warn-comment"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WARN_COMMENTS
case|case
literal|'c'
case|:
name|warn_comment
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -Q                      ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WARN_COMMENTS
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -c                      print a warning if a comment is found\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_SOM
argument_list|)
operator|||
name|defined
argument_list|(
name|ELF_ARG_RELOC
argument_list|)
end_if

begin_define
define|#
directive|define
name|nonzero_dibits
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) | (((x)& 0x55555555)<< 1) | (((x)& 0xAAAAAAAA)>> 1))
end_define

begin_define
define|#
directive|define
name|arg_reloc_stub_needed
parameter_list|(
name|CALLER
parameter_list|,
name|CALLEE
parameter_list|)
define|\
value|(((CALLER) ^ (CALLEE))& nonzero_dibits (CALLER)& nonzero_dibits (CALLEE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|arg_reloc_stub_needed
parameter_list|(
name|CALLER
parameter_list|,
name|CALLEE
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Apply a fixup to an instruction.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|fixpos
decl_stmt|;
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fixP
decl_stmt|;
name|offsetT
name|new_val
decl_stmt|;
name|int
name|insn
decl_stmt|,
name|val
decl_stmt|,
name|fmt
decl_stmt|;
comment|/* SOM uses R_HPPA_ENTRY and R_HPPA_EXIT relocations which can      never be "applied" (they are just markers).  Likewise for      R_HPPA_BEGIN_BRTAB and R_HPPA_END_BRTAB.  */
ifdef|#
directive|ifdef
name|OBJ_SOM
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_ENTRY
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_EXIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_BEGIN_BRTAB
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_END_BRTAB
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_BEGIN_TRY
condition|)
return|return;
comment|/* Disgusting.  We must set fx_offset ourselves -- R_HPPA_END_TRY      fixups are considered not adjustable, which in turn causes      adjust_reloc_syms to not set fx_offset.  Ugh.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|R_HPPA_END_TRY
condition|)
block|{
name|fixP
operator|->
name|fx_offset
operator|=
operator|*
name|valP
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTENTRY
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTINHERIT
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* There should be a HPPA specific fixup associated with the GAS fixup.  */
name|hppa_fixP
operator|=
operator|(
expr|struct
name|hppa_fix_struct
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
expr_stmt|;
if|if
condition|(
name|hppa_fixP
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"no hppa_fixup entry for fixup type 0x%x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|fixpos
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
literal|4
operator|||
name|hppa_fixP
operator|->
name|fx_r_format
operator|==
literal|32
condition|)
block|{
comment|/* Handle constant output. */
name|number_to_chars_bigendian
argument_list|(
name|fixpos
argument_list|,
operator|*
name|valP
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|stdoutput
argument_list|,
name|fixpos
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|bfd_hppa_insn2fmt
argument_list|(
name|stdoutput
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If there is a symbol associated with this fixup, then it's something      which will need a SOM relocation (except for some PC-relative relocs).      In such cases we should treat the "val" or "addend" as zero since it      will be added in as needed from fx_offset in tc_gen_reloc.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_NONE
operator|)
ifdef|#
directive|ifdef
name|OBJ_SOM
operator|&&
name|fmt
operator|!=
literal|32
endif|#
directive|endif
condition|)
name|new_val
operator|=
operator|(
operator|(
name|fmt
operator|==
literal|12
operator|||
name|fmt
operator|==
literal|17
operator|||
name|fmt
operator|==
literal|22
operator|)
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* These field selectors imply that we do not want an addend.  */
elseif|else
if|if
condition|(
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_psel
operator|||
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_rpsel
operator|||
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_lpsel
operator|||
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_tsel
operator|||
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_rtsel
operator|||
name|hppa_fixP
operator|->
name|fx_r_field
operator|==
name|e_ltsel
condition|)
name|new_val
operator|=
operator|(
operator|(
name|fmt
operator|==
literal|12
operator|||
name|fmt
operator|==
literal|17
operator|||
name|fmt
operator|==
literal|22
operator|)
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
else|else
name|new_val
operator|=
name|hppa_field_adjust
argument_list|(
operator|*
name|valP
argument_list|,
literal|0
argument_list|,
name|hppa_fixP
operator|->
name|fx_r_field
argument_list|)
expr_stmt|;
comment|/* Handle pc-relative exceptions from above.  */
if|if
condition|(
operator|(
name|fmt
operator|==
literal|12
operator|||
name|fmt
operator|==
literal|17
operator|||
name|fmt
operator|==
literal|22
operator|)
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|!
name|arg_reloc_stub_needed
argument_list|(
name|symbol_arg_reloc_info
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|hppa_fixP
operator|->
name|fx_arg_reloc
argument_list|)
ifdef|#
directive|ifdef
name|OBJ_ELF
operator|&&
operator|(
operator|*
name|valP
operator|-
literal|8
operator|+
literal|8192
operator|<
literal|16384
operator|||
operator|(
name|fmt
operator|==
literal|17
operator|&&
operator|*
name|valP
operator|-
literal|8
operator|+
literal|262144
operator|<
literal|524288
operator|)
operator|||
operator|(
name|fmt
operator|==
literal|22
operator|&&
operator|*
name|valP
operator|-
literal|8
operator|+
literal|8388608
operator|<
literal|16777216
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_SOM
operator|&&
operator|(
operator|*
name|valP
operator|-
literal|8
operator|+
literal|262144
operator|<
literal|524288
operator|||
operator|(
name|fmt
operator|==
literal|22
operator|&&
operator|*
name|valP
operator|-
literal|8
operator|+
literal|8388608
operator|<
literal|16777216
operator|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|hppa_fixP
operator|->
name|segment
operator|&&
operator|!
operator|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|hppa_fixP
operator|->
name|segment
operator|)
condition|)
block|{
name|new_val
operator|=
name|hppa_field_adjust
argument_list|(
operator|*
name|valP
argument_list|,
literal|0
argument_list|,
name|hppa_fixP
operator|->
name|fx_r_field
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
literal|10
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|&
literal|0x1ff8
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
operator|)
operator|)
expr_stmt|;
break|break;
case|case
operator|-
literal|11
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x3ff9
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|&
literal|0x1ffc
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
operator|)
operator|)
expr_stmt|;
break|break;
comment|/* Handle all opcodes with the 'j' operand type.  */
case|case
literal|14
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
operator|(
name|insn
operator|&
operator|~
literal|0x3fff
operator|)
operator||
name|low_sign_unext
argument_list|(
name|val
argument_list|,
literal|14
argument_list|)
operator|)
expr_stmt|;
break|break;
comment|/* Handle all opcodes with the 'k' operand type.  */
case|case
literal|21
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
argument_list|,
literal|1048575
argument_list|,
operator|-
literal|1048576
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x1fffff
operator|)
operator||
name|re_assemble_21
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle all the opcodes with the 'i' operand type.  */
case|case
literal|11
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
argument_list|,
literal|1023
argument_list|,
operator|-
literal|1024
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x7ff
operator|)
operator||
name|low_sign_unext
argument_list|(
name|val
argument_list|,
literal|11
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle all the opcodes with the 'w' operand type.  */
case|case
literal|12
case|:
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
operator|-
literal|8
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
operator|-
literal|8
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x1ffd
operator|)
operator||
name|re_assemble_12
argument_list|(
name|val
operator|>>
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle some of the opcodes with the 'W' operand type.  */
case|case
literal|17
case|:
block|{
name|offsetT
name|distance
init|=
operator|*
name|valP
decl_stmt|;
comment|/* If this is an absolute branch (ie no link) with an out of 	   range target, then we want to complain.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_PCREL_CALL
operator|&&
operator|(
name|insn
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xe8000000
condition|)
name|CHECK_FIELD_WHERE
argument_list|(
name|distance
operator|-
literal|8
argument_list|,
literal|262143
argument_list|,
operator|-
literal|262144
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
operator|-
literal|8
argument_list|,
literal|262143
argument_list|,
operator|-
literal|262144
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
operator|-
literal|8
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x1f1ffd
operator|)
operator||
name|re_assemble_17
argument_list|(
name|val
operator|>>
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|22
case|:
block|{
name|offsetT
name|distance
init|=
operator|*
name|valP
decl_stmt|;
comment|/* If this is an absolute branch (ie no link) with an out of 	   range target, then we want to complain.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_PCREL_CALL
operator|&&
operator|(
name|insn
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xe8000000
condition|)
name|CHECK_FIELD_WHERE
argument_list|(
name|distance
operator|-
literal|8
argument_list|,
literal|8388607
argument_list|,
operator|-
literal|8388608
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|CHECK_FIELD_WHERE
argument_list|(
name|new_val
operator|-
literal|8
argument_list|,
literal|8388607
argument_list|,
operator|-
literal|8388608
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|val
operator|=
name|new_val
operator|-
literal|8
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1ffd
operator|)
operator||
name|re_assemble_22
argument_list|(
name|val
operator|>>
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|-
literal|10
case|:
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xfff1
operator|)
operator||
name|re_assemble_16
argument_list|(
name|val
operator|&
operator|-
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|16
case|:
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xfff9
operator|)
operator||
name|re_assemble_16
argument_list|(
name|val
operator|&
operator|-
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|val
operator|=
name|new_val
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
name|re_assemble_16
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|insn
operator|=
name|new_val
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unknown relocation encountered in md_apply_fix."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|R_PARISC_TLS_GD21L
case|:
case|case
name|R_PARISC_TLS_GD14R
case|:
case|case
name|R_PARISC_TLS_LDM21L
case|:
case|case
name|R_PARISC_TLS_LDM14R
case|:
case|case
name|R_PARISC_TLS_LE21L
case|:
case|case
name|R_PARISC_TLS_LE14R
case|:
case|case
name|R_PARISC_TLS_IE21L
case|:
case|case
name|R_PARISC_TLS_IE14R
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* Insert the relocation.  */
name|bfd_put_32
argument_list|(
name|stdoutput
argument_list|,
name|insn
argument_list|,
name|fixpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the PA, they're relative to the address of the offset.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the input line pointer is at the end of    a statement.  */
end_comment

begin_function
specifier|static
name|int
name|is_end_of_statement
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|input_line_pointer
operator|==
literal|';'
operator|)
operator|||
operator|(
operator|*
name|input_line_pointer
operator|==
literal|'!'
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REG_NAME_CNT
value|(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
end_define

begin_comment
comment|/* Given NAME, find the register number associated with that name, return    the integer value associated with the given name or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|REG_NAME_CNT
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|pre_defined_registers
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|pre_defined_registers
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read a number from S.  The number might come in one of many forms,    the most common will be a hex or decimal constant, but it could be    a pre-defined register (Yuk!), or an absolute symbol.     Return 1 on success or 0 on failure.  If STRICT, then a missing    register prefix will cause a failure.  The number itself is    returned in `pa_number'.     IS_FLOAT indicates that a PA-89 FP register number should be    parsed;  A `l' or `r' suffix is checked for if but 2 of IS_FLOAT is    not set.     pa_parse_number can not handle negative constants and will fail    horribly if it is passed such a constant.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_number
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|int
name|is_float
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
name|bfd_boolean
name|have_prefix
decl_stmt|;
comment|/* Skip whitespace before the number.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|pa_number
operator|=
operator|-
literal|1
expr_stmt|;
name|have_prefix
operator|=
literal|0
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strict
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* Looks like a number.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
block|{
comment|/* The number is specified in hex.  */
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|<=
literal|'F'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|num
operator|=
name|num
operator|*
literal|16
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|num
operator|=
name|num
operator|*
literal|16
operator|+
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
name|num
operator|=
name|num
operator|*
literal|16
operator|+
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The number is specified in decimal.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|pa_number
operator|=
name|num
expr_stmt|;
comment|/* Check for a `l' or `r' suffix.  */
if|if
condition|(
name|is_float
condition|)
block|{
name|pa_number
operator|+=
name|FP_REG_BASE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|is_float
operator|&
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|IS_R_SELECT
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|pa_number
operator|+=
name|FP_REG_RSEL
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_L_SELECT
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
comment|/* The number might be a predefined register.  */
name|have_prefix
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Tege hack: Special case for general registers as the general          code makes a binary search with case translation, and is VERY          slow.  */
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'t'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|==
literal|'0'
operator|||
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|==
literal|'1'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|num
operator|=
operator|*
name|p
operator|-
literal|'0'
operator|+
literal|28
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'p'
condition|)
block|{
name|num
operator|=
literal|2
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Undefined register: '%s'."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
do|do
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
block|}
block|}
else|else
block|{
comment|/* Do a normal register search.  */
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|reg_name_search
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|num
operator|=
name|status
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Undefined register: '%s'."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
name|pa_number
operator|=
name|num
expr_stmt|;
block|}
else|else
block|{
comment|/* And finally, it could be a symbol in the absolute section which          is effectively a constant, or a register alias symbol.  */
name|name
operator|=
name|p
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|reg_section
condition|)
block|{
name|num
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Well, we don't really have one, but we do have a 		 register, so...  */
name|have_prefix
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
operator|&
name|bfd_abs_section
condition|)
name|num
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strict
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Non-absolute symbol: '%s'."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strict
condition|)
block|{
comment|/* There is where we'd come for an undefined symbol 	     or for an empty string.  For an empty string we 	     will return zero.  That's a concession made for 	     compatibility with the braindamaged HP assemblers.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Undefined absolute constant: '%s'."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|pa_number
operator|=
name|num
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strict
operator|||
name|have_prefix
condition|)
block|{
operator|*
name|s
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given INSN and L/R information will require    a new PA-1.1 opcode.  */
end_comment

begin_function
specifier|static
name|int
name|need_pa11_opcode
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|the_insn
operator|.
name|fpof1
operator|==
name|DBL
operator|&&
name|the_insn
operator|.
name|fpof2
operator|==
name|DBL
operator|)
condition|)
block|{
comment|/* If this instruction is specific to a particular architecture, 	 then set a new architecture.  */
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|stdoutput
argument_list|)
operator|<
name|pa11
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
name|pa11
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not update architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Parse a condition for a fcmp instruction.  Return the numerical    code associated with the condition.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_fp_cmp_cond
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cond
decl_stmt|,
name|i
decl_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
name|fp_cond_map
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|strlen
argument_list|(
name|fp_cond_map
index|[
name|i
index|]
operator|.
name|string
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cond
operator|=
name|fp_cond_map
index|[
name|i
index|]
operator|.
name|cond
expr_stmt|;
operator|*
name|s
operator|+=
name|strlen
argument_list|(
name|fp_cond_map
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* If not a complete match, back up the input string and 	     report an error.  */
if|if
condition|(
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|s
operator|-=
name|strlen
argument_list|(
name|fp_cond_map
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|*
name|s
operator|=
operator|*
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|cond
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid FP Compare Condition: %s"
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* Advance over the bogus completer.  */
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a graphics test complete for ftest.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_ftest_gfx_completer
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"acc8"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|5
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"acc6"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|9
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"acc4"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|13
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"acc2"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|17
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"acc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"rej8"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|6
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"rej"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
operator|*
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid FTEST completer: %s"
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse an FP operand format completer returning the completer    type.  */
end_comment

begin_function
specifier|static
name|fp_operand_format
name|pa_parse_fp_cnv_format
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|format
decl_stmt|;
name|format
operator|=
name|SGL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"sgl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|SGL
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"dbl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|DBL
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"quad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QUAD
expr_stmt|;
operator|*
name|s
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"w"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|W
expr_stmt|;
operator|*
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"uw"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UW
expr_stmt|;
operator|*
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"dw"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|DW
expr_stmt|;
operator|*
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"udw"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UDW
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"qw"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QW
expr_stmt|;
operator|*
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"uqw"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UQW
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
name|ILLEGAL_FMT
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid FP Operand Format: %3s"
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|format
return|;
block|}
end_function

begin_comment
comment|/* Parse an FP operand format completer returning the completer    type.  */
end_comment

begin_function
specifier|static
name|fp_operand_format
name|pa_parse_fp_format
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|format
decl_stmt|;
name|format
operator|=
name|SGL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"sgl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|SGL
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"dbl"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|DBL
expr_stmt|;
operator|*
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"quad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QUAD
expr_stmt|;
operator|*
name|s
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
name|ILLEGAL_FMT
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid FP Operand Format: %3s"
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|format
return|;
block|}
end_function

begin_comment
comment|/* Convert from a selector string into a selector type.  */
end_comment

begin_function
specifier|static
name|int
name|pa_chk_field_selector
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
comment|/* Read past any whitespace.  */
comment|/* FIXME: should we read past newlines and formfeeds??? */
while|while
condition|(
operator|*
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
operator|*
name|str
operator|==
literal|'\t'
operator|||
operator|*
operator|*
name|str
operator|==
literal|'\n'
operator|||
operator|*
operator|*
name|str
operator|==
literal|'\f'
condition|)
operator|*
name|str
operator|=
operator|*
name|str
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|str
operator|)
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
operator|(
operator|*
name|str
operator|)
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|name
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
argument_list|)
operator|,
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|str
operator|)
index|[
literal|2
index|]
operator|==
literal|'\''
operator|||
operator|(
operator|*
name|str
operator|)
index|[
literal|2
index|]
operator|==
literal|'%'
condition|)
name|name
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
argument_list|)
operator|,
name|name
index|[
literal|1
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|1
index|]
argument_list|)
operator|,
name|name
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|str
operator|)
index|[
literal|3
index|]
operator|==
literal|'\''
operator|||
operator|(
operator|*
name|str
operator|)
index|[
literal|3
index|]
operator|==
literal|'%'
condition|)
name|name
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
argument_list|)
operator|,
name|name
index|[
literal|1
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|1
index|]
argument_list|)
operator|,
name|name
index|[
literal|2
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
literal|2
index|]
argument_list|)
operator|,
name|name
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|e_fsel
return|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
sizeof|sizeof
argument_list|(
name|selector_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|selector_entry
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcmp
argument_list|(
name|name
argument_list|,
name|selector_table
index|[
name|middle
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_SOM
if|if
condition|(
name|selector_table
index|[
name|middle
index|]
operator|.
name|field_selector
operator|==
name|e_nsel
condition|)
return|return
name|e_fsel
return|;
endif|#
directive|endif
return|return
name|selector_table
index|[
name|middle
index|]
operator|.
name|field_selector
return|;
block|}
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
name|e_fsel
return|;
block|}
end_function

begin_comment
comment|/* Parse a .byte, .word, .long expression for the HPPA.  Called by    cons via the TC_PARSE_CONS_EXPRESSION macro.  */
end_comment

begin_function
name|void
name|parse_cons_expression_hppa
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|hppa_field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Evaluate an absolute expression EXP which may be modified by    the selector FIELD_SELECTOR.  Return the value of the expression.  */
end_comment

begin_function
specifier|static
name|int
name|evaluate_absolute
parameter_list|(
name|struct
name|pa_it
modifier|*
name|insn
parameter_list|)
block|{
name|offsetT
name|value
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|field_selector
init|=
name|insn
operator|->
name|field_selector
decl_stmt|;
name|exp
operator|=
name|insn
operator|->
name|exp
expr_stmt|;
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
name|hppa_field_adjust
argument_list|(
literal|0
argument_list|,
name|value
argument_list|,
name|field_selector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark (via expr_end) the end of an absolute expression.  FIXME.  */
end_comment

begin_function
specifier|static
name|int
name|pa_get_absolute_expression
parameter_list|(
name|struct
name|pa_it
modifier|*
name|insn
parameter_list|,
name|char
modifier|*
modifier|*
name|strp
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|insn
operator|->
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
name|strp
argument_list|)
expr_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|strp
expr_stmt|;
name|expression
argument_list|(
operator|&
name|insn
operator|->
name|exp
argument_list|)
expr_stmt|;
comment|/* This is not perfect, but is a huge improvement over doing nothing.       The PA assembly syntax is ambiguous in a variety of ways.  Consider      this string "4 %r5"  Is that the number 4 followed by the register      r5, or is that 4 MOD r5?       If we get a modulo expression when looking for an absolute, we try      again cutting off the input string at the first whitespace character.  */
if|if
condition|(
name|insn
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_modulus
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|input_line_pointer
operator|=
operator|*
name|strp
expr_stmt|;
name|s
operator|=
operator|*
name|strp
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|pa_get_absolute_expression
argument_list|(
name|insn
argument_list|,
name|strp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
return|return
name|evaluate_absolute
argument_list|(
name|insn
argument_list|)
return|;
block|}
comment|/* When in strict mode we have a non-match, fix up the pointers      and return to our caller.  */
if|if
condition|(
name|insn
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|strict
condition|)
block|{
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|insn
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad segment (should be absolute)."
argument_list|)
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
name|evaluate_absolute
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an argument location specification return the associated    argument location number.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pa_build_arg_reloc
parameter_list|(
name|char
modifier|*
name|type_name
parameter_list|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|type_name
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|type_name
argument_list|,
literal|"gr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|type_name
argument_list|,
literal|"fr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|type_name
argument_list|,
literal|"fu"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|3
return|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid argument location: %s\n"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Encode and return an argument relocation specification for    the given register in the location specified by arg_reloc.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pa_align_arg_reloc
parameter_list|(
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|arg_reloc
parameter_list|)
block|{
name|unsigned
name|int
name|new_reloc
decl_stmt|;
name|new_reloc
operator|=
name|arg_reloc
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
name|new_reloc
operator|<<=
literal|8
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|new_reloc
operator|<<=
literal|6
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|new_reloc
operator|<<=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|new_reloc
operator|<<=
literal|2
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid argument description: %d"
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|new_reloc
return|;
block|}
end_function

begin_comment
comment|/* Parse a non-negated compare/subtract completer returning the    number (for encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_nonneg_cmpsub_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save_s
init|=
operator|*
name|s
decl_stmt|;
name|int
name|nullify
init|=
literal|0
decl_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
comment|/* If we have something like addb,n then there is no condition          completer.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
comment|/* Reset pointers if this was really a ,n for a branch instruction.  */
if|if
condition|(
name|nullify
condition|)
operator|*
name|s
operator|=
name|save_s
expr_stmt|;
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a negated compare/subtract completer returning the    number (for encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_neg_cmpsub_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save_s
init|=
operator|*
name|s
decl_stmt|;
name|int
name|nullify
init|=
literal|0
decl_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nsv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
comment|/* If we have something like addb,n then there is no condition          completer.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
comment|/* Reset pointers if this was really a ,n for a branch instruction.  */
if|if
condition|(
name|nullify
condition|)
operator|*
name|s
operator|=
name|save_s
expr_stmt|;
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a 64 bit compare and branch completer returning the number (for    encoding in instructions) of the given completer.     Nonnegated comparisons are returned as 0-7, negated comparisons are    returned as 8-15.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_cmpb_64_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*sv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*od"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*>>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*>>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|13
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*nsv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|15
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a 64 bit compare immediate and branch completer returning the number    (for encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_cmpib_64_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*>>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a non-negated addition completer returning the number    (for encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_nonneg_add_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save_s
init|=
operator|*
name|s
decl_stmt|;
name|int
name|nullify
init|=
literal|0
decl_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nuv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"znv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
comment|/* If we have something like addb,n then there is no condition          completer.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
comment|/* Reset pointers if this was really a ,n for a branch instruction.  */
if|if
condition|(
name|nullify
condition|)
operator|*
name|s
operator|=
name|save_s
expr_stmt|;
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a negated addition completer returning the number    (for encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_neg_add_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save_s
init|=
operator|*
name|s
decl_stmt|;
name|int
name|nullify
init|=
literal|0
decl_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"uv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"vnz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nsv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
comment|/* If we have something like addb,n then there is no condition          completer.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
comment|/* Reset pointers if this was really a ,n for a branch instruction.  */
if|if
condition|(
name|nullify
condition|)
operator|*
name|s
operator|=
name|save_s
expr_stmt|;
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Parse a 64 bit wide mode add and branch completer returning the number (for    encoding in instructions) of the given completer.  */
end_comment

begin_function
specifier|static
name|int
name|pa_parse_addb_64_cmpltr
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|cmpltr
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|*
name|s
operator|+
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|save_s
init|=
operator|*
name|s
decl_stmt|;
name|int
name|nullify
init|=
literal|0
decl_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
operator|*
name|s
operator|!=
literal|'\t'
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|s
expr_stmt|;
operator|*
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nuv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*<"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*<="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"uv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|13
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"*>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|15
expr_stmt|;
block|}
comment|/* If we have something like addb,n then there is no condition          completer.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmpltr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
comment|/* Reset pointers if this was really a ,n for a branch instruction.  */
if|if
condition|(
name|nullify
condition|)
operator|*
name|s
operator|=
name|save_s
expr_stmt|;
return|return
name|cmpltr
return|;
block|}
end_function

begin_comment
comment|/* Do the real work for assembling a single instruction.  Store results    into the global "the_insn" variable.  */
end_comment

begin_function
specifier|static
name|void
name|pa_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|error_message
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|argstart
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|save_s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|match
init|=
name|FALSE
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
name|int
name|cmpltr
decl_stmt|,
name|nullif
decl_stmt|,
name|flag
decl_stmt|,
name|cond
decl_stmt|,
name|num
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|pa_opcode
modifier|*
name|insn
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Convert everything up to the first whitespace character into lower      case.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* Skip to something interesting.  */
for|for
control|(
name|s
operator|=
name|str
init|;
name|ISUPPER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'3'
operator|)
condition|;
operator|++
name|s
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
name|comma
operator|=
literal|1
expr_stmt|;
comment|/*FALLTHROUGH */
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look up the opcode in the has table.  */
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|pa_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|comma
condition|)
operator|*
operator|--
name|s
operator|=
literal|','
expr_stmt|;
comment|/* Mark the location where arguments for the instruction start, then      start processing them.  */
name|argstart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Do some initialization.  */
name|opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|strict
operator|=
operator|(
name|insn
operator|->
name|flags
operator|&
name|FLAG_STRICT
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_NONE
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|arch
operator|>=
name|pa20
operator|&&
name|bfd_get_mach
argument_list|(
name|stdoutput
argument_list|)
operator|<
name|insn
operator|->
name|arch
condition|)
goto|goto
name|failed
goto|;
comment|/* Build the opcode, checking as we go to make          sure that the operands match.  */
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
comment|/* Absorb white space in instruction.  */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
comment|/* End of arguments.  */
case|case
literal|'\0'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
continue|continue;
break|break;
comment|/* These must match exactly.  */
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|','
case|:
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
comment|/* Handle a 5 bit register or control register field at 10.  */
case|case
literal|'b'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* Handle %sar or %cr11.  No bits get set, we just verify that it 	       is there.  */
case|case
literal|'!'
case|:
comment|/* Skip whitespace before register.  */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"%sar"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"%cr11"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Handle a 5 bit register field at 15.  */
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit register field at 31.  */
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit register field at 10 and 15.  */
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|16
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit field length at 31.  */
case|case
literal|'T'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
literal|32
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit immediate at 15.  */
case|case
literal|'5'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
comment|/* When in strict mode, we want to just reject this 		 match instead of giving an out of range error.  */
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|15
argument_list|,
operator|-
literal|16
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit immediate at 31.  */
case|case
literal|'V'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
comment|/* When in strict mode, we want to just reject this 		 match instead of giving an out of range error.  */
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|15
argument_list|,
operator|-
literal|16
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle an unsigned 5 bit immediate at 31.  */
case|case
literal|'r'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle an unsigned 5 bit immediate at 15.  */
case|case
literal|'R'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Handle an unsigned 10 bit immediate at 15.  */
case|case
literal|'U'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|1023
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Handle a 2 bit space identifier at 17.  */
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Handle a 3 bit space identifier at 18.  */
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|num
operator|=
name|pa_number
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_3
argument_list|(
name|num
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Handle all completers.  */
case|case
literal|'c'
case|:
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
comment|/* Handle a completer for an indexing load or store.  */
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
block|{
name|int
name|uu
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|i
operator|<
literal|2
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"sm"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uu
operator|=
literal|1
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"m"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"s "
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"s,"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|uu
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strict
condition|)
block|{
comment|/* This is a match failure.  */
name|s
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Indexed Load Completer."
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Indexed Load Completer Syntax."
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|m
operator|<<
literal|5
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|uu
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a short load/store completer.  */
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
case|case
literal|'q'
case|:
case|case
literal|'J'
case|:
case|case
literal|'e'
case|:
block|{
name|int
name|a
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"ma"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|=
literal|0
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"mb"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|=
literal|1
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strict
condition|)
comment|/* This is a match failure.  */
name|s
operator|--
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Short Load/Store Completer."
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* If we did not get a ma/mb completer, then we do not 		       consider this a positive match for 'ce'.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'e'
condition|)
break|break;
comment|/* 'J', 'm', 'M' and 'q' are the same, except for where they 		       encode the before/after field.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'m'
operator|||
operator|*
name|args
operator|==
literal|'M'
condition|)
block|{
name|opcode
operator||=
name|m
operator|<<
literal|5
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|a
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'q'
condition|)
block|{
name|opcode
operator||=
name|m
operator|<<
literal|3
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'J'
condition|)
block|{
comment|/* M bit is explicit in the major opcode.  */
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'e'
condition|)
block|{
comment|/* Stash the ma/mb flag temporarily in the 			   instruction.  We will use (and remove it) 			   later when handling 'J', 'K', '<'& '>'.  */
name|opcode
operator||=
name|a
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Handle a stbys completer.  */
case|case
literal|'A'
case|:
case|case
literal|'s'
case|:
block|{
name|int
name|a
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|i
operator|<
literal|2
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"m"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"b "
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"b,"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|a
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"e"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|=
literal|1
expr_stmt|;
comment|/* In strict mode, this is a match failure.  */
elseif|else
if|if
condition|(
name|strict
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Store Bytes Short Completer"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Store Bytes Short Completer"
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|m
operator|<<
literal|5
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|a
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
comment|/* Handle load cache hint completer.  */
case|case
literal|'c'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|",sl"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle store cache hint completer.  */
case|case
literal|'C'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|",sl"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|cmpltr
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|",bc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle load and clear cache hint completer.  */
case|case
literal|'d'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|",co"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|cmpltr
operator|=
literal|1
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle load ordering completer.  */
case|case
literal|'o'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|",o"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
comment|/* Handle a branch gate completer.  */
case|case
literal|'g'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",gate"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
comment|/* Handle a branch link and push completer.  */
case|case
literal|'p'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",l,push"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|7
expr_stmt|;
continue|continue;
comment|/* Handle a branch link completer.  */
case|case
literal|'l'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",l"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
comment|/* Handle a branch pop completer.  */
case|case
literal|'P'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",pop"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
comment|/* Handle a local processor completer.  */
case|case
literal|'L'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",l"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
comment|/* Handle a PROBE read/write completer.  */
case|case
literal|'w'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",w"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",r"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle MFCTL wide completer.  */
case|case
literal|'W'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",w"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
comment|/* Handle an RFI restore completer.  */
case|case
literal|'r'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",r"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|5
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle a system control completer.  */
case|case
literal|'Z'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'m'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'M'
operator|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle intermediate/final completer for DCOR.  */
case|case
literal|'i'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",i"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle zero/sign extension completer.  */
case|case
literal|'z'
case|:
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",z"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle add completer.  */
case|case
literal|'a'
case|:
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",l"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|2
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|3
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle 64 bit carry for ADD.  */
case|case
literal|'Y'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",dc,tsv"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv,dc"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",dc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle 32 bit carry for ADD.  */
case|case
literal|'y'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",c,tsv"
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv,c"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",c"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle trap on signed overflow.  */
case|case
literal|'v'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle trap on condition and overflow.  */
case|case
literal|'t'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tc,tsv"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv,tc"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle 64 bit borrow for SUB.  */
case|case
literal|'B'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",db,tsv"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv,db"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",db"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle 32 bit borrow for SUB.  */
case|case
literal|'b'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",b,tsv"
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tsv,b"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",b"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle trap condition completer for UADDCM.  */
case|case
literal|'T'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",tc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle signed/unsigned at 21.  */
case|case
literal|'S'
case|:
block|{
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",s"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",u"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sign
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|sign
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Handle left/right combination at 17:18.  */
case|case
literal|'h'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
name|int
name|lr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'r'
condition|)
name|lr
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'l'
condition|)
name|lr
operator|=
literal|0
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid left/right combination completer"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|lr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid left/right combination completer"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle saturation at 24:25.  */
case|case
literal|'H'
case|:
block|{
name|int
name|sat
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",ss"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sat
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|",us"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sat
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|sat
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* Handle permutation completer.  */
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
name|int
name|permloc
index|[
literal|4
index|]
decl_stmt|;
name|int
name|perm
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|permloc
index|[
literal|0
index|]
operator|=
literal|13
expr_stmt|;
name|permloc
index|[
literal|1
index|]
operator|=
literal|10
expr_stmt|;
name|permloc
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
name|permloc
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
name|perm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|perm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|perm
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|perm
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid permutation completer"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|opcode
operator||=
name|perm
operator|<<
name|permloc
index|[
name|i
index|]
expr_stmt|;
block|}
continue|continue;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid permutation completer"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* Handle all conditions.  */
case|case
literal|'?'
case|:
block|{
name|args
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
comment|/* Handle FP compare conditions.  */
case|case
literal|'f'
case|:
name|cond
operator|=
name|pa_parse_fp_cmp_cond
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle an add condition.  */
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 64 bit conditions.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
name|name
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nuv"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"znv"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sv"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"uv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"vnz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nsv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ",*" is a valid condition.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'a'
operator|||
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Add Condition: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
name|opcode
operator||=
name|cmpltr
operator|<<
literal|13
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* Handle non-negated add and branch condition.  */
case|case
literal|'d'
case|:
name|cmpltr
operator|=
name|pa_parse_nonneg_add_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Add and Branch Condition"
argument_list|)
argument_list|)
expr_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle 64 bit wide-mode add and branch condition.  */
case|case
literal|'W'
case|:
name|cmpltr
operator|=
name|pa_parse_addb_64_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Add and Branch Condition"
argument_list|)
argument_list|)
expr_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Negated condition requires an opcode change.  */
name|opcode
operator||=
operator|(
name|cmpltr
operator|&
literal|8
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
operator|&
literal|7
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a negated or non-negated add and branch 		     condition.  */
case|case
literal|'@'
case|:
name|save_s
operator|=
name|s
expr_stmt|;
name|cmpltr
operator|=
name|pa_parse_nonneg_add_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|s
operator|=
name|save_s
expr_stmt|;
name|cmpltr
operator|=
name|pa_parse_neg_add_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Compare/Subtract Condition"
argument_list|)
argument_list|)
expr_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Negated condition requires an opcode change.  */
name|opcode
operator||=
literal|1
operator|<<
literal|27
expr_stmt|;
block|}
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle branch on bit conditions.  */
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'B'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"<"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|">="
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Bit Branch Condition: %c"
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* Handle a compare/subtract condition.  */
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 64 bit conditions.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'S'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
name|name
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"<<"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"<<="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sv"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|">>="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|">>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"nsv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ",*" is a valid condition.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|!=
literal|'S'
operator|||
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Compare/Subtract Condition: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
name|opcode
operator||=
name|cmpltr
operator|<<
literal|13
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* Handle a non-negated compare condition.  */
case|case
literal|'t'
case|:
name|cmpltr
operator|=
name|pa_parse_nonneg_cmpsub_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Compare/Subtract Condition"
argument_list|)
argument_list|)
expr_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a 32 bit compare and branch condition.  */
case|case
literal|'n'
case|:
name|save_s
operator|=
name|s
expr_stmt|;
name|cmpltr
operator|=
name|pa_parse_nonneg_cmpsub_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|s
operator|=
name|save_s
expr_stmt|;
name|cmpltr
operator|=
name|pa_parse_neg_cmpsub_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Compare and Branch Condition"
argument_list|)
argument_list|)
expr_stmt|;
name|cmpltr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Negated condition requires an opcode change.  */
name|opcode
operator||=
literal|1
operator|<<
literal|27
expr_stmt|;
block|}
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a 64 bit compare and branch condition.  */
case|case
literal|'N'
case|:
name|cmpltr
operator|=
name|pa_parse_cmpb_64_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|>=
literal|0
condition|)
block|{
comment|/* Negated condition requires an opcode change.  */
name|opcode
operator||=
operator|(
name|cmpltr
operator|&
literal|8
operator|)
operator|<<
literal|26
expr_stmt|;
block|}
else|else
comment|/* Not a 64 bit cond.  Give 32 bit a chance.  */
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
operator|&
literal|7
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a 64 bit cmpib condition.  */
case|case
literal|'Q'
case|:
name|cmpltr
operator|=
name|pa_parse_cmpib_64_cmpltr
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmpltr
operator|<
literal|0
condition|)
comment|/* Not a 64 bit cond.  Give 32 bit a chance.  */
break|break;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a logical instruction condition.  */
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 64 bit conditions.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
name|name
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ",*" is a valid condition.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|!=
literal|'L'
operator|||
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Logical Instruction Condition."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
name|opcode
operator||=
name|cmpltr
operator|<<
literal|13
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* Handle a shift/extract/deposit condition.  */
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|save_s
operator|=
name|s
operator|++
expr_stmt|;
comment|/* 64 bit conditions.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
name|name
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|+=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"od"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"tr"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|">="
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ev"
argument_list|)
operator|==
literal|0
condition|)
name|cmpltr
operator|=
literal|7
expr_stmt|;
comment|/* Handle movb,n.  Put things back the way they were. 			   This includes moving s back to where it started.  */
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
operator|&&
operator|*
name|args
operator|==
literal|'y'
condition|)
block|{
operator|*
name|s
operator|=
name|c
expr_stmt|;
name|s
operator|=
name|save_s
expr_stmt|;
continue|continue;
block|}
comment|/* ",*" is a valid condition.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|!=
literal|'X'
operator|||
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Shift/Extract/Deposit Condition."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|cmpltr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a unit instruction condition.  */
case|case
literal|'U'
case|:
case|case
literal|'u'
case|:
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 64 bit conditions.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
break|break;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"sbz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"shz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"sdc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"sbc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"shc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"tr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nbz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|2
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nhz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|3
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"ndc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|4
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nbc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|6
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nhc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|7
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"swz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"swc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nwz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"nwc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmpltr
operator|=
literal|5
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* ",*" is a valid condition.  */
elseif|else
if|if
condition|(
operator|*
name|args
operator|!=
literal|'U'
operator|||
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Unit Instruction Condition."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|opcode
operator||=
name|cmpltr
operator|<<
literal|13
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|12
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* Handle a nullification completer for branch instructions.  */
case|case
literal|'n'
case|:
name|nullif
operator|=
name|pa_parse_nullif
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|nullif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Handle a nullification completer for copr and spop insns.  */
case|case
literal|'N'
case|:
name|nullif
operator|=
name|pa_parse_nullif
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|nullif
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle ,%r2 completer for new syntax branches.  */
case|case
literal|'L'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|strncasecmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"%r2"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|strncasecmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"%rp"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|+=
literal|4
expr_stmt|;
else|else
break|break;
continue|continue;
comment|/* Handle 3 bit entry into the fp compare array.   Valid values 	       are 0..6 inclusive.  */
case|case
literal|'h'
case|:
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* Handle 3 bit entry into the fp compare array.   Valid values 	       are 0..6 inclusive.  */
case|case
literal|'m'
case|:
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|s
operator|=
name|expr_end
expr_stmt|;
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|+
literal|1
operator|)
operator|^
literal|1
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* Handle graphics test completers for ftest */
case|case
literal|'='
case|:
block|{
name|num
operator|=
name|pa_parse_ftest_gfx_completer
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a 11 bit immediate at 31.  */
case|case
literal|'i'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|1023
argument_list|,
operator|-
literal|1024
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|11
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 14 bit immediate at 31.  */
case|case
literal|'J'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|mb
decl_stmt|;
comment|/* XXX the completer stored away tidbits of information 		     for us to extract.  We need a cleaner way to do this. 		     Now that we have lots of letters again, it would be 		     good to rethink this.  */
name|mb
operator|=
name|opcode
operator|&
literal|1
expr_stmt|;
name|opcode
operator|-=
name|mb
expr_stmt|;
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle a 14 bit immediate at 31.  */
case|case
literal|'K'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|mb
decl_stmt|;
name|mb
operator|=
name|opcode
operator|&
literal|1
expr_stmt|;
name|opcode
operator|-=
name|mb
expr_stmt|;
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle a 16 bit immediate at 31.  */
case|case
literal|'<'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|mb
decl_stmt|;
name|mb
operator|=
name|opcode
operator|&
literal|1
expr_stmt|;
name|opcode
operator|-=
name|mb
expr_stmt|;
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
operator|-
literal|32768
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|re_assemble_16
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle a 16 bit immediate at 31.  */
case|case
literal|'>'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|mb
decl_stmt|;
name|mb
operator|=
name|opcode
operator|&
literal|1
expr_stmt|;
name|opcode
operator|-=
name|mb
expr_stmt|;
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
operator|-
literal|32768
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|re_assemble_16
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle 14 bit immediate, shifted left three times.  */
case|case
literal|'#'
case|:
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|stdoutput
argument_list|)
operator|!=
name|pa20
condition|)
break|break;
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|&
literal|0x7
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|opcode
operator||=
literal|1
expr_stmt|;
name|num
operator|&=
literal|0x1fff
expr_stmt|;
name|num
operator|>>=
literal|3
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Handle 14 bit immediate, shifted left twice.  */
case|case
literal|'d'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|&
literal|0x3
condition|)
break|break;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|opcode
operator||=
literal|1
expr_stmt|;
name|num
operator|&=
literal|0x1fff
expr_stmt|;
name|num
operator|>>=
literal|2
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 14 bit immediate at 31.  */
case|case
literal|'j'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|low_sign_unext
argument_list|(
name|num
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 21 bit immediate at 31.  */
case|case
literal|'k'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
operator|>>
literal|11
argument_list|,
literal|1048575
argument_list|,
operator|-
literal|1048576
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_21
argument_list|(
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|21
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 16 bit immediate at 31 (PA 2.0 wide mode only).  */
case|case
literal|'l'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
operator|-
literal|32768
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_16
argument_list|(
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* ??? Is this valid for wide mode?  */
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a word-aligned 16-bit imm. at 31 (PA2.0 wide).  */
case|case
literal|'y'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
operator|-
literal|32768
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ALIGN
argument_list|(
name|num
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_16
argument_list|(
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* ??? Is this valid for wide mode?  */
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a dword-aligned 16-bit imm. at 31 (PA2.0 wide).  */
case|case
literal|'&'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
operator|-
literal|32768
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ALIGN
argument_list|(
name|num
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_16
argument_list|(
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* ??? Is this valid for wide mode?  */
if|if
condition|(
name|is_DP_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|is_PC_relative
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|is_tls_gdidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_GD21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ldidx
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDM21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_dtpoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LDO21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_ieoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_IE21L
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tls_leoff
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|R_PARISC_TLS_LE21L
expr_stmt|;
endif|#
directive|endif
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|14
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 12 bit branch displacement.  */
case|case
literal|'w'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|||
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Branch to unaligned address"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
name|num
operator|-=
literal|8
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
operator|-
literal|8192
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_12
argument_list|(
name|num
operator|>>
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|12
expr_stmt|;
name|the_insn
operator|.
name|arg_reloc
operator|=
name|last_call_desc
operator|.
name|arg_reloc
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_call_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|call_desc
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 17 bit branch displacement.  */
case|case
literal|'W'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|||
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Branch to unaligned address"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
name|num
operator|-=
literal|8
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|262143
argument_list|,
operator|-
literal|262144
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_17
argument_list|(
name|num
operator|>>
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|17
expr_stmt|;
name|the_insn
operator|.
name|arg_reloc
operator|=
name|last_call_desc
operator|.
name|arg_reloc
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_call_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|call_desc
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Handle a 22 bit branch displacement.  */
case|case
literal|'X'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|||
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Branch to unaligned address"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
name|num
operator|-=
literal|8
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8388607
argument_list|,
operator|-
literal|8388608
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_22
argument_list|(
name|num
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_PCREL_CALL
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|22
expr_stmt|;
name|the_insn
operator|.
name|arg_reloc
operator|=
name|last_call_desc
operator|.
name|arg_reloc
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_call_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|call_desc
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Handle an absolute 17 bit branch target.  */
case|case
literal|'z'
case|:
name|the_insn
operator|.
name|field_selector
operator|=
name|pa_chk_field_selector
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|||
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
condition|)
block|{
name|num
operator|=
name|evaluate_absolute
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|%
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Branch to unaligned address"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
name|num
operator|-=
literal|8
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|262143
argument_list|,
operator|-
literal|262144
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|re_assemble_17
argument_list|(
name|num
operator|>>
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|the_insn
operator|.
name|reloc
operator|=
name|R_HPPA_ABS_CALL
expr_stmt|;
name|the_insn
operator|.
name|format
operator|=
literal|17
expr_stmt|;
name|the_insn
operator|.
name|arg_reloc
operator|=
name|last_call_desc
operator|.
name|arg_reloc
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_call_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|call_desc
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Handle '%r1' implicit operand of addil instruction.  */
case|case
literal|'Z'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'%'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
operator|==
literal|'1'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|==
literal|'r'
operator|||
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|==
literal|'R'
operator|)
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
comment|/* Handle '%sr0,%r31' implicit operand of be,l instruction.  */
case|case
literal|'Y'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"%sr0,%r31"
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|9
expr_stmt|;
continue|continue;
comment|/* Handle immediate value of 0 for ordered load/store instructions.  */
case|case
literal|'@'
case|:
if|if
condition|(
operator|*
name|s
operator|!=
literal|'0'
condition|)
break|break;
name|s
operator|++
expr_stmt|;
continue|continue;
comment|/* Handle a 2 bit shift count at 25.  */
case|case
literal|'.'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle a 4 bit shift count at 25.  */
case|case
literal|'*'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit shift count at 26.  */
case|case
literal|'p'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
literal|31
operator|-
name|num
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle a 6 bit shift count at 20,22:26.  */
case|case
literal|'~'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
literal|63
operator|-
name|num
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x20
operator|)
operator|<<
literal|6
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
operator|&
literal|0x1f
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle a 6 bit field length at 23,27:31.  */
case|case
literal|'%'
case|:
name|flag
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|64
argument_list|,
literal|1
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|--
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x20
operator|)
operator|<<
literal|3
expr_stmt|;
name|num
operator|=
literal|31
operator|-
operator|(
name|num
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 6 bit field length at 19,27:31.  */
case|case
literal|'|'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|64
argument_list|,
literal|1
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|--
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x20
operator|)
operator|<<
literal|7
expr_stmt|;
name|num
operator|=
literal|31
operator|-
operator|(
name|num
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit bit position at 26.  */
case|case
literal|'P'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle a 6 bit bit position at 20,22:26.  */
case|case
literal|'q'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x20
operator|)
operator|<<
literal|6
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
operator|&
literal|0x1f
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit immediate at 10 with 'd' as the complement 	       of the high bit of the immediate.  */
case|case
literal|'B'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|&
literal|0x20
condition|)
empty_stmt|;
else|else
name|opcode
operator||=
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
operator|&
literal|0x1f
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* Handle a 5 bit immediate at 10.  */
case|case
literal|'Q'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|21
argument_list|)
expr_stmt|;
comment|/* Handle a 9 bit immediate at 28.  */
case|case
literal|'$'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|511
argument_list|,
literal|1
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Handle a 13 bit immediate at 18.  */
case|case
literal|'A'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|8191
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a 26 bit immediate at 31.  */
case|case
literal|'D'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|67108863
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 3 bit SFU identifier at 25.  */
case|case
literal|'v'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid SFU identifier"
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle a 20 bit SOP field for spop0.  */
case|case
literal|'O'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|1048575
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|&
literal|0x1f
operator|)
operator||
operator|(
operator|(
name|num
operator|&
literal|0x000fffe0
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 15bit SOP field for spop1.  */
case|case
literal|'o'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle a 10bit SOP field for spop3.  */
case|case
literal|'0'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|1023
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|&
literal|0x1f
operator|)
operator||
operator|(
operator|(
name|num
operator|&
literal|0x000003e0
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 15 bit SOP field for spop2.  */
case|case
literal|'1'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|32767
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|&
literal|0x1f
operator|)
operator||
operator|(
operator|(
name|num
operator|&
literal|0x00007fe0
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a 3-bit co-processor ID field.  */
case|case
literal|'u'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid COPR identifier"
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Handle a 22bit SOP field for copr.  */
case|case
literal|'2'
case|:
name|num
operator|=
name|pa_get_absolute_expression
argument_list|(
operator|&
name|the_insn
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|4194303
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|&
literal|0x1f
operator|)
operator||
operator|(
operator|(
name|num
operator|&
literal|0x003fffe0
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle a source FP operand format completer.  */
case|case
literal|'{'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'t'
condition|)
block|{
name|the_insn
operator|.
name|trunc
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|the_insn
operator|.
name|trunc
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
name|pa_parse_fp_cnv_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fpof1
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|W
operator|||
name|flag
operator|==
name|UW
condition|)
name|flag
operator|=
name|SGL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|DW
operator|||
name|flag
operator|==
name|UDW
condition|)
name|flag
operator|=
name|DBL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|QW
operator|||
name|flag
operator|==
name|UQW
condition|)
name|flag
operator|=
name|QUAD
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle a destination FP operand format completer.  */
case|case
literal|'_'
case|:
comment|/* pa_parse_format needs the ',' prefix.  */
name|s
operator|--
expr_stmt|;
name|flag
operator|=
name|pa_parse_fp_cnv_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fpof2
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|W
operator|||
name|flag
operator|==
name|UW
condition|)
name|flag
operator|=
name|SGL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|DW
operator|||
name|flag
operator|==
name|UDW
condition|)
name|flag
operator|=
name|DBL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|QW
operator|||
name|flag
operator|==
name|UQW
condition|)
name|flag
operator|=
name|QUAD
expr_stmt|;
name|opcode
operator||=
name|flag
operator|<<
literal|13
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|DBL
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|QUAD
condition|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|fpof2
operator|==
name|SGL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|DBL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|QUAD
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|fpof2
operator|==
name|W
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|DW
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|QW
condition|)
name|flag
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|fpof2
operator|==
name|UW
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|UDW
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|UQW
condition|)
name|flag
operator|=
literal|6
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|W
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|DW
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|QW
condition|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|fpof2
operator|==
name|SGL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|DBL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|QUAD
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|UW
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|UDW
operator|||
name|the_insn
operator|.
name|fpof1
operator|==
name|UQW
condition|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|fpof2
operator|==
name|SGL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|DBL
operator|||
name|the_insn
operator|.
name|fpof2
operator|==
name|QUAD
condition|)
name|flag
operator|=
literal|5
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|flag
operator||=
name|the_insn
operator|.
name|trunc
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* Handle a source FP operand format completer.  */
case|case
literal|'F'
case|:
name|flag
operator|=
name|pa_parse_fp_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fpof1
operator|=
name|flag
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle a destination FP operand format completer.  */
case|case
literal|'G'
case|:
comment|/* pa_parse_format needs the ',' prefix.  */
name|s
operator|--
expr_stmt|;
name|flag
operator|=
name|pa_parse_fp_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fpof2
operator|=
name|flag
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* Handle a source FP operand format completer at 20.  */
case|case
literal|'I'
case|:
name|flag
operator|=
name|pa_parse_fp_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fpof1
operator|=
name|flag
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|flag
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Handle a floating point operand format at 26. 	       Only allows single and double precision.  */
case|case
literal|'H'
case|:
name|flag
operator|=
name|pa_parse_fp_format
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SGL
case|:
name|opcode
operator||=
literal|0x20
expr_stmt|;
case|case
name|DBL
case|:
name|the_insn
operator|.
name|fpof1
operator|=
name|flag
expr_stmt|;
continue|continue;
case|case
name|QUAD
case|:
case|case
name|ILLEGAL_FMT
case|:
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Floating Point Operand Format."
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle all floating point registers.  */
case|case
literal|'f'
case|:
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
comment|/* Float target register.  */
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Float target register with L/R selection.  */
case|case
literal|'T'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
expr_stmt|;
comment|/* 0x30 opcodes are FP arithmetic operation opcodes 		       and need to be turned into 0x38 opcodes.  This 		       is not necessary for loads/stores.  */
if|if
condition|(
name|need_pa11_opcode
argument_list|()
operator|&&
operator|(
operator|(
name|opcode
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x30000000
operator|)
condition|)
name|opcode
operator||=
literal|1
operator|<<
literal|27
expr_stmt|;
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|6
else|:
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Float operand 1.  */
case|case
literal|'a'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|21
expr_stmt|;
if|if
condition|(
name|need_pa11_opcode
argument_list|()
condition|)
block|{
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|7
else|:
literal|0
operator|)
expr_stmt|;
name|opcode
operator||=
literal|1
operator|<<
literal|27
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Float operand 1 with L/R selection.  */
case|case
literal|'X'
case|:
case|case
literal|'A'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|21
expr_stmt|;
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|7
else|:
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Float operand 2.  */
case|case
literal|'b'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|need_pa11_opcode
argument_list|()
condition|)
block|{
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|12
else|:
literal|0
operator|)
expr_stmt|;
name|opcode
operator||=
literal|1
operator|<<
literal|27
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Float operand 2 with L/R selection.  */
case|case
literal|'B'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|16
expr_stmt|;
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|12
else|:
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Float operand 3 for fmpyfadd, fmpynfadd.  */
case|case
literal|'C'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x1c
operator|)
operator|<<
literal|11
expr_stmt|;
name|opcode
operator||=
operator|(
name|num
operator|&
literal|0x03
operator|)
operator|<<
literal|9
expr_stmt|;
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|8
else|:
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Float mult operand 1 for fmpyadd, fmpysub */
case|case
literal|'i'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for single precision fmpyadd or fmpysub"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|&=
literal|0xF
expr_stmt|;
name|num
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
comment|/* Float mult operand 2 for fmpyadd, fmpysub */
case|case
literal|'j'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for single precision fmpyadd or fmpysub"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|&=
literal|0xF
expr_stmt|;
name|num
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Float mult target for fmpyadd, fmpysub */
case|case
literal|'k'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for single precision fmpyadd or fmpysub"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|&=
literal|0xF
expr_stmt|;
name|num
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Float add operand 1 for fmpyadd, fmpysub */
case|case
literal|'l'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for single precision fmpyadd or fmpysub"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|&=
literal|0xF
expr_stmt|;
name|num
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* Float add target for fmpyadd, fmpysub */
case|case
literal|'m'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|fpof1
operator|==
name|SGL
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for single precision fmpyadd or fmpysub"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|&=
literal|0xF
expr_stmt|;
name|num
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
comment|/* Handle L/R register halves like 'x'.  */
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
block|{
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|num
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|need_pa11_opcode
argument_list|()
condition|)
block|{
name|opcode
operator||=
operator|(
name|pa_number
operator|&
name|FP_REG_RSEL
condition|?
literal|1
operator|<<
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Float target register (PA 2.0 wide).  */
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|s
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
name|num
operator|=
operator|(
name|pa_number
operator|&
operator|~
name|FP_REG_RSEL
operator|)
operator|-
name|FP_REG_BASE
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|num
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERT_FIELD_AND_CONTINUE
argument_list|(
name|opcode
argument_list|,
name|num
argument_list|,
literal|16
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* If this instruction is specific to a particular architecture, 	 then set a new architecture.  This automatic promotion crud is 	 for compatibility with HP's old assemblers only.  */
if|if
condition|(
name|match
operator|==
name|TRUE
operator|&&
name|bfd_get_mach
argument_list|(
name|stdoutput
argument_list|)
operator|<
name|insn
operator|->
name|arch
operator|&&
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
name|insn
operator|->
name|arch
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not update architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|match
operator|=
name|FALSE
expr_stmt|;
block|}
name|failed
label|:
comment|/* Check if the args matched.  */
if|if
condition|(
operator|!
name|match
condition|)
block|{
if|if
condition|(
operator|&
name|insn
index|[
literal|1
index|]
operator|-
name|pa_opcodes
operator|<
operator|(
name|int
operator|)
name|NUMOPCODES
operator|&&
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argstart
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operands %s"
argument_list|)
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction storing it into a frag.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|to
decl_stmt|;
comment|/* The had better be something to assemble.  */
name|assert
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* If we are within a procedure definition, make sure we've      defined a label for the procedure; handle case where the      label was defined after the .PROC directive.       Note there's not need to diddle with the segment or fragment      for the label symbol in this case.  We have already switched      into the new $CODE$ subspace at this point.  */
if|if
condition|(
name|within_procedure
operator|&&
name|last_call_info
operator|->
name|start_symbol
operator|==
name|NULL
condition|)
block|{
name|label_symbol_struct
modifier|*
name|label_symbol
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|label_symbol
condition|)
block|{
if|if
condition|(
name|label_symbol
operator|->
name|lss_label
condition|)
block|{
name|last_call_info
operator|->
name|start_symbol
operator|=
name|label_symbol
operator|->
name|lss_label
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|label_symbol
operator|->
name|lss_label
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* Also handle allocation of a fixup to hold the unwind 		 information when the label appears after the proc/procend.  */
if|if
condition|(
name|within_entry_exit
condition|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|u
operator|=
name|UNWIND_LOW32
argument_list|(
operator|&
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
expr_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_HPPA_ENTRY
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing function name for .PROC (corrupted label chain)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing function name for .PROC"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Assemble the instruction.  Results are saved into "the_insn".  */
name|pa_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Get somewhere to put the assembled instruction.  */
name|to
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Output the opcode.  */
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If necessary output more stuff.  */
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|R_HPPA_NONE
condition|)
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
operator|(
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|&
name|the_insn
operator|.
name|exp
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|,
name|the_insn
operator|.
name|field_selector
argument_list|,
name|the_insn
operator|.
name|format
argument_list|,
name|the_insn
operator|.
name|arg_reloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* Handle an alignment directive.  Special so that we can update the    alignment of the subspace if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|pa_align
parameter_list|(
name|int
name|bytes
parameter_list|)
block|{
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
comment|/* Let the generic gas code do most of the work.  */
name|s_align_bytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|/* If bytes is a power of 2, then update the current subspace's      alignment if necessary.  */
if|if
condition|(
name|exact_log2
argument_list|(
name|bytes
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|record_alignment
argument_list|(
name|current_subspace
operator|->
name|ssd_seg
argument_list|,
name|exact_log2
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a .BLOCK type pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_block
parameter_list|(
name|int
name|z
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|temp_size
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|temp_size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp_size
operator|>
literal|0x3FFFFFFF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Argument to .BLOCK/.BLOCKZ must be between 0 and 0x3fffffff"
argument_list|)
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Always fill with zeros, that's what the HP assembler does.  */
name|char
modifier|*
name|p
init|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|temp_size
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|pa_undefine_label
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .begin_brtab and .end_brtab pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_brtab
parameter_list|(
name|int
name|begin
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* The BRTAB relocations are only available in SOM (to denote      the beginning and end of branch tables).  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|begin
condition|?
name|R_HPPA_BEGIN_BRTAB
else|:
name|R_HPPA_END_BRTAB
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .begin_try and .end_try pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_try
parameter_list|(
name|int
name|begin
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|begin
condition|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* The TRY relocations are only available in SOM (to denote      the beginning and end of exception handling regions).  */
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|begin
condition|?
name|NULL
else|:
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|begin
condition|?
name|R_HPPA_BEGIN_TRY
else|:
name|R_HPPA_END_TRY
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the dirty work of building a call descriptor which describes    where the caller placed arguments to a function call.  */
end_comment

begin_function
specifier|static
name|void
name|pa_call_args
parameter_list|(
name|struct
name|call_desc
modifier|*
name|call_desc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|arg_reloc
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Process a source argument.  */
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"argw"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|temp
operator|=
name|atoi
argument_list|(
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|arg_reloc
operator|=
name|pa_build_arg_reloc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|call_desc
operator|->
name|arg_reloc
operator||=
name|pa_align_arg_reloc
argument_list|(
name|temp
argument_list|,
name|arg_reloc
argument_list|)
expr_stmt|;
block|}
comment|/* Process a return value.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"rtnval"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|arg_reloc
operator|=
name|pa_build_arg_reloc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|call_desc
operator|->
name|arg_reloc
operator||=
operator|(
name|arg_reloc
operator|&
literal|0x3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .CALL argument: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a .CALL pseudo-op.  This involves storing away information    about where arguments are to be found so the linker can detect    (and correct) argument location mismatches between caller and callee.  */
end_comment

begin_function
specifier|static
name|void
name|pa_call
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pa_call_args
argument_list|(
operator|&
name|last_call_desc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if FRAG1 and FRAG2 are the same.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_same_frag
parameter_list|(
name|fragS
modifier|*
name|frag1
parameter_list|,
name|fragS
modifier|*
name|frag2
parameter_list|)
block|{
if|if
condition|(
name|frag1
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|frag2
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|frag1
operator|==
name|frag2
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|frag2
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|frag2
operator|->
name|fr_fix
operator|==
literal|0
condition|)
return|return
operator|(
name|is_same_frag
argument_list|(
name|frag1
argument_list|,
name|frag2
operator|->
name|fr_next
argument_list|)
operator|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Build an entry in the UNWIND subspace from the given function    attributes in CALL_INFO.  This is not needed for SOM as using    R_ENTRY and R_EXIT relocations allow the linker to handle building    of the unwind spaces.  */
end_comment

begin_function
specifier|static
name|void
name|pa_build_unwind_subspace
parameter_list|(
name|struct
name|call_info
modifier|*
name|call_info
parameter_list|)
block|{
name|asection
modifier|*
name|seg
decl_stmt|,
modifier|*
name|save_seg
decl_stmt|;
name|subsegT
name|save_subseg
decl_stmt|;
name|unsigned
name|int
name|unwind
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
operator|)
operator|!=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
condition|)
return|return;
name|reloc
operator|=
name|R_PARISC_SEGREL32
expr_stmt|;
name|save_seg
operator|=
name|now_seg
expr_stmt|;
name|save_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Get into the right seg/subseg.  This may involve creating      the seg the first time through.  Make sure to have the      old seg/subseg so that we can reset things when we are done.  */
name|seg
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|UNWIND_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|ASEC_NULL
condition|)
block|{
name|seg
operator|=
name|subseg_new
argument_list|(
name|UNWIND_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_ALLOC
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get some space to hold relocation information for the unwind      descriptor.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* Relocation info. for start offset of the function.  */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|call_info
operator|->
name|start_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|,
name|e_fsel
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Relocation info. for end offset of the function.       Because we allow reductions of 32bit relocations for ELF, this will be      reduced to section_sym + offset which avoids putting the temporary      symbol into the symbol table.  It (should) end up giving the same      value as call_info->start_symbol + function size once the linker is      finished with its work.  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|4
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|call_info
operator|->
name|end_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|,
name|e_fsel
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dump the descriptor.  */
name|unwind
operator|=
name|UNWIND_LOW32
argument_list|(
operator|&
name|call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|unwind
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|unwind
operator|=
name|UNWIND_HIGH32
argument_list|(
operator|&
name|call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|12
argument_list|,
name|unwind
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Return back to the original segment/subsegment.  */
name|subseg_set
argument_list|(
name|save_seg
argument_list|,
name|save_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Process a .CALLINFO pseudo-op.  This information is used later    to build unwind descriptors and maybe one day to support    .ENTER and .LEAVE.  */
end_comment

begin_function
specifier|static
name|void
name|pa_callinfo
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* .CALLINFO must appear within a procedure definition.  */
if|if
condition|(
operator|!
name|within_procedure
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".callinfo is not within a procedure definition"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the fact that we found the .CALLINFO for the      current procedure.  */
name|callinfo_found
operator|=
name|TRUE
expr_stmt|;
comment|/* Iterate over the .CALLINFO arguments.  */
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Frame size specification.  */
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"frame"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"FRAME parameter must be a multiple of 8: %d\n"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* callinfo is in bytes and unwind_desc is in 8 byte units.  */
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|frame_size
operator|=
name|temp
operator|/
literal|8
expr_stmt|;
block|}
comment|/* Entry register (GR, GR and SR) specifications.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"entry_gr"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* The HP assembler accepts 19 as the high bound for ENTRY_GR 	     even though %r19 is caller saved.  I think this is a bug in 	     the HP assembler, and we are not going to emulate it.  */
if|if
condition|(
name|temp
operator|<
literal|3
operator|||
name|temp
operator|>
literal|18
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Value for ENTRY_GR must be in the range 3..18\n"
argument_list|)
argument_list|)
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|entry_gr
operator|=
name|temp
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"entry_fr"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* Similarly the HP assembler takes 31 as the high bound even 	     though %fr21 is the last callee saved floating point register.  */
if|if
condition|(
name|temp
operator|<
literal|12
operator|||
name|temp
operator|>
literal|21
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Value for ENTRY_FR must be in the range 12..21\n"
argument_list|)
argument_list|)
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|entry_fr
operator|=
name|temp
operator|-
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"entry_sr"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Value for ENTRY_SR must be 3\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note whether or not this function performs any calls.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"calls"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"caller"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"no_calls"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
comment|/* Should RP be saved into the stack.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"save_rp"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|save_rp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Likewise for SP.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"save_sp"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|save_sp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Is this an unwindable procedure.  If so mark it so          in the unwind descriptor.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"no_unwind"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|cannot_unwind
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Is this an interrupt routine.  If so mark it in the          unwind descriptor.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"hpux_int"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|hpux_interrupt_marker
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Is this a millicode routine.  "millicode" isn't in my 	 assembler manual, but my copy is old.  The HP assembler 	 accepts it, and there's a place in the unwind descriptor 	 to drop the information, so we'll accept it too.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"millicode"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|millicode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .CALLINFO argument: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
end_if

begin_comment
comment|/* Switch to the text space.  Like s_text, but delete our    label when finished.  */
end_comment

begin_function
specifier|static
name|void
name|pa_text
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
name|current_space
operator|=
name|is_defined_space
argument_list|(
literal|"$TEXT$"
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|current_space
operator|->
name|sd_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to the data space.  As usual delete our label.  */
end_comment

begin_function
specifier|static
name|void
name|pa_data
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
name|current_space
operator|=
name|is_defined_space
argument_list|(
literal|"$PRIVATE$"
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|current_space
operator|->
name|sd_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is different than the standard GAS s_comm(). On HP9000/800 machines,    the .comm pseudo-op has the following symtax:<label> .comm<length>     where<label> is optional and is a symbol whose address will be the start of    a block of memory<length> bytes long.<length> must be an absolute    expression.<length> bytes will be allocated in the current space    and subspace.     Also note the label may not even be on the same line as the .comm.     This difference in syntax means the colon function will be called    on the symbol before we arrive in pa_comm.  colon will set a number    of attributes of the symbol that need to be fixed here.  In particular    the value, section pointer, fragment pointer, flags, etc.  What    a pain.     This also makes error detection all but impossible.  */
end_comment

begin_function
specifier|static
name|void
name|pa_comm
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|label_symbol_struct
modifier|*
name|label_symbol
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|label_symbol
condition|)
name|symbol
operator|=
name|label_symbol
operator|->
name|lss_label
expr_stmt|;
else|else
name|symbol
operator|=
name|NULL
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|symbol_get_bfdsym
argument_list|(
name|symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbol
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbol
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* colon() has already set the frag to the current location in the          current subspace; we need to reset the fragment to the zero address          fragment.  We also need to reset the segment pointer.  */
name|symbol_set_frag
argument_list|(
name|symbol
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(defined (OBJ_ELF)&& (defined (TE_LINUX) || defined (TE_NetBSD))) */
end_comment

begin_comment
comment|/* Process a .END pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_end
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a .ENTER pseudo-op.  This is not supported.  */
end_comment

begin_function
specifier|static
name|void
name|pa_enter
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The .ENTER pseudo-op is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a .ENTRY pseudo-op.  .ENTRY marks the beginning of the    procedure.  */
end_comment

begin_function
specifier|static
name|void
name|pa_entry
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|within_procedure
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Misplaced .entry. Ignored."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|callinfo_found
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing .callinfo."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|within_entry_exit
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* SOM defers building of unwind descriptors until the link phase.      The assembler is responsible for creating an R_ENTRY relocation      to mark the beginning of a region and hold the unwind bits, and      for creating an R_EXIT relocation to mark the end of the region.       FIXME.  ELF should be using the same conventions!  The problem      is an unwind requires too much relocation space.  Hmmm.  Maybe      if we split the unwind bits up between the relocations which      denote the entry and exit points.  */
if|if
condition|(
name|last_call_info
operator|->
name|start_symbol
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|u
operator|=
name|UNWIND_LOW32
argument_list|(
operator|&
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
expr_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_HPPA_ENTRY
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Silly nonsense for pa_equ.  The only half-sensible use for this is    being able to subtract two register symbols that specify a range of    registers, to get the size of the range.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fudge_reg_expressions
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hppa_force_reg_syms_absolute
parameter_list|(
name|expressionS
modifier|*
name|resultP
parameter_list|,
name|operatorT
name|op
name|ATTRIBUTE_UNUSED
parameter_list|,
name|expressionS
modifier|*
name|rightP
parameter_list|)
block|{
if|if
condition|(
name|fudge_reg_expressions
operator|&&
name|rightP
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|resultP
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|rightP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|resultP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Continue normal expr handling.  */
block|}
end_function

begin_comment
comment|/* Handle a .EQU pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_equ
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|label_symbol_struct
modifier|*
name|label_symbol
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
if|if
condition|(
name|label_symbol
condition|)
block|{
name|symbol
operator|=
name|label_symbol
operator|->
name|lss_label
expr_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
name|strict
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pa_parse_number
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".REG expression must be a register"
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbol
argument_list|,
name|pa_number
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbol
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|fudge_reg_expressions
operator|=
literal|1
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|fudge_reg_expressions
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad or irreducible absolute expression; zero assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|absolute_section
expr_stmt|;
block|}
name|S_SET_VALUE
argument_list|(
name|symbol
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbol
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".REG must use a label"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".EQU must use a label"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pa_undefine_label
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Mark the end of a function so that it's possible to compute    the size of the function in elf_hppa_final_processing.  */
end_comment

begin_function
specifier|static
name|void
name|hppa_elf_mark_end_of_function
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* ELF does not have EXIT relocations.  All we do is create a      temporary symbol marking the end of the function.  */
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|last_call_info
operator|==
name|NULL
operator|||
name|last_call_info
operator|->
name|start_symbol
operator|==
name|NULL
condition|)
block|{
comment|/* We have already warned about a missing label, 	 or other problems.  */
return|return;
block|}
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"L$\001end_"
argument_list|)
operator|+
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|last_call_info
operator|->
name|start_symbol
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"L$\001end_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|S_GET_NAME
argument_list|(
name|last_call_info
operator|->
name|start_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a .exit followed by a .procend, then the 	 symbol will have already been defined.  */
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
comment|/* The symbol has already been defined!  This can 	     happen if we have a .exit followed by a .procend.  	     This is *not* an error.  All we want to do is free 	     the memory we just allocated for the name and continue.  */
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* symbol value should be the offset of the 	     last instruction of the function */
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|now_seg
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|frag_now_fix
argument_list|()
operator|-
literal|4
argument_list|)
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbolP
condition|)
name|last_call_info
operator|->
name|end_symbol
operator|=
name|symbolP
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol '%s' could not be created."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No memory for symbol name."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Helper function.  Does processing for the end of a function.  This    usually involves creating some relocations or building special    symbols to mark the end of the function.  */
end_comment

begin_function
specifier|static
name|void
name|process_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Mark the end of the function, stuff away the location of the frag      for the end of the function, and finally call pa_build_unwind_subspace      to add an entry in the unwind table.  */
name|hppa_elf_mark_end_of_function
argument_list|()
expr_stmt|;
name|pa_build_unwind_subspace
argument_list|(
name|last_call_info
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SOM defers building of unwind descriptors until the link phase.      The assembler is responsible for creating an R_ENTRY relocation      to mark the beginning of a region and hold the unwind bits, and      for creating an R_EXIT relocation to mark the end of the region.       FIXME.  ELF should be using the same conventions!  The problem      is an unwind requires too much relocation space.  Hmmm.  Maybe      if we split the unwind bits up between the relocations which      denote the entry and exit points.  */
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_HPPA_EXIT
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|UNWIND_HIGH32
argument_list|(
operator|&
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Process a .EXIT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_exit
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|within_procedure
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".EXIT must appear within a procedure"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|callinfo_found
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing .callinfo"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|within_entry_exit
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No .ENTRY for this .EXIT"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|within_entry_exit
operator|=
name|FALSE
expr_stmt|;
name|process_exit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function to process arguments to a .EXPORT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_type_args
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|int
name|is_export
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|arg_reloc
decl_stmt|;
name|pa_symbol_type
name|type
init|=
name|SYMBOL_TYPE_UNKNOWN
decl_stmt|;
name|asymbol
modifier|*
name|bfdsym
init|=
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"absolute"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|8
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator|&=
operator|~
name|BSF_FUNCTION
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_abs_section_ptr
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_ABSOLUTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"code"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
comment|/* IMPORTing/EXPORTing CODE types for functions is meaningless for SOM,          instead one should be IMPORTing/EXPORTing ENTRY types.           Complain if one tries to EXPORT a CODE type since that's never          done.  Both GCC and HP C still try to IMPORT CODE types, so          silently fix them to be ENTRY types.  */
if|if
condition|(
name|S_IS_FUNCTION
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_export
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Using ENTRY rather than CODE in export directive for %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_ENTRY
expr_stmt|;
block|}
else|else
block|{
name|bfdsym
operator|->
name|flags
operator|&=
operator|~
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_CODE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"data"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator|&=
operator|~
name|BSF_FUNCTION
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"entry"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_ENTRY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"millicode"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|9
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
name|elf_symbol_type
modifier|*
name|elfsym
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfdsym
decl_stmt|;
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
argument_list|,
name|STT_PARISC_MILLI
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|type
operator|=
name|SYMBOL_TYPE_MILLICODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"plabel"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator|&=
operator|~
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_PLABEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"pri_prog"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|8
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_PRI_PROG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"sec_prog"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|8
expr_stmt|;
name|bfdsym
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE_SEC_PROG
expr_stmt|;
block|}
comment|/* SOM requires much more information about symbol types      than BFD understands.  This is how we get this information      to the SOM BFD backend.  */
ifdef|#
directive|ifdef
name|obj_set_symbol_type
name|obj_set_symbol_type
argument_list|(
name|bfdsym
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now that the type of the exported symbol has been handled,      handle any argument relocation information.  */
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Argument sources.  */
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"argw"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|atoi
argument_list|(
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|arg_reloc
operator|=
name|pa_align_arg_reloc
argument_list|(
name|temp
argument_list|,
name|pa_build_arg_reloc
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_SOM
argument_list|)
operator|||
name|defined
argument_list|(
name|ELF_ARG_RELOC
argument_list|)
name|symbol_arg_reloc_info
argument_list|(
name|symbolP
argument_list|)
operator||=
name|arg_reloc
expr_stmt|;
endif|#
directive|endif
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
comment|/* The return value.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"rtnval"
argument_list|,
literal|6
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|arg_reloc
operator|=
name|pa_build_arg_reloc
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_SOM
argument_list|)
operator|||
name|defined
argument_list|(
name|ELF_ARG_RELOC
argument_list|)
name|symbol_arg_reloc_info
argument_list|(
name|symbolP
argument_list|)
operator||=
name|arg_reloc
expr_stmt|;
endif|#
directive|endif
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
comment|/* Privilege level.  */
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"priv_lev"
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|temp
operator|=
name|atoi
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
operator|(
operator|(
name|obj_symbol_type
operator|*
operator|)
name|bfdsym
operator|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_priv_level
operator|=
name|temp
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Undefined .EXPORT/.IMPORT argument (ignored): %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a .EXPORT directive.  This makes functions external    and provides information such as argument relocation entries    to callers.  */
end_comment

begin_function
specifier|static
name|void
name|pa_export
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Make sure the given symbol exists.  */
if|if
condition|(
operator|(
name|symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cannot define export symbol: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* OK.  Set the external bits and process argument relocations.          For the HP, weak and global are not mutually exclusive.          S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.          Call S_SET_EXTERNAL to get the other processing.  Manually          set BSF_GLOBAL when we get back.  */
name|S_SET_EXTERNAL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|pa_type_args
argument_list|(
name|symbol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an .IMPORT pseudo-op.  Any symbol referenced in a given    assembly file must either be defined in the assembly file, or    explicitly IMPORTED from another.  */
end_comment

begin_function
specifier|static
name|void
name|pa_import
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Ugh.  We might be importing a symbol defined earlier in the file,      in which case all the code below will really screw things up      (set the wrong segment, symbol flags& type, etc).  */
if|if
condition|(
name|symbol
operator|==
name|NULL
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|pa_type_args
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sigh.  To be compatible with the HP assembler and to help 	     poorly written assembly code, we assign a type based on 	     the current segment.  Note only BSF_FUNCTION really 	     matters, we do not need to set the full SYMBOL_TYPE_* info.  */
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|symbol_get_bfdsym
argument_list|(
name|symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
comment|/* If the section is undefined, then the symbol is undefined 	     Since this is an import, leave the section undefined.  */
name|S_SET_SEGMENT
argument_list|(
name|symbol
argument_list|,
name|bfd_und_section_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The symbol was already defined.  Just eat everything up to 	 the end of the current statement.  */
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .LABEL pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_label
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|colon
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Missing label name on .LABEL"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"extra .LABEL arguments ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .LEAVE pseudo-op.  This is not supported yet.  */
end_comment

begin_function
specifier|static
name|void
name|pa_leave
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The .LEAVE pseudo-op is not supported"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .LEVEL pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_level
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|level
decl_stmt|;
name|level
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|level
argument_list|,
literal|"1.0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|10
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|level
argument_list|,
literal|"1.1"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|11
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|level
argument_list|,
literal|"2.0w"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|25
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|level
argument_list|,
literal|"2.0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|20
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized .LEVEL argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .ORIGIN pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_origin
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|s_org
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .PARAM pseudo-op.  This is much like a .EXPORT, except it    is for static functions.  FIXME.  Should share more code with .EXPORT.  */
end_comment

begin_function
specifier|static
name|void
name|pa_param
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cannot define static symbol: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|pa_type_args
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .PROC pseudo-op.  It is used to mark the beginning    of a procedure from a syntactical point of view.  */
end_comment

begin_function
specifier|static
name|void
name|pa_proc
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
name|call_info
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|within_procedure
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Nested procedures"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset global variables for new procedure.  */
name|callinfo_found
operator|=
name|FALSE
expr_stmt|;
name|within_procedure
operator|=
name|TRUE
expr_stmt|;
comment|/* Create another call_info structure.  */
name|call_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|call_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call_info
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Cannot allocate unwind descriptor\n"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|call_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|call_info
argument_list|)
argument_list|)
expr_stmt|;
name|call_info
operator|->
name|ci_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|call_info_root
operator|==
name|NULL
condition|)
block|{
name|call_info_root
operator|=
name|call_info
expr_stmt|;
name|last_call_info
operator|=
name|call_info
expr_stmt|;
block|}
else|else
block|{
name|last_call_info
operator|->
name|ci_next
operator|=
name|call_info
expr_stmt|;
name|last_call_info
operator|=
name|call_info
expr_stmt|;
block|}
comment|/* set up defaults on call_info structure */
name|call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|cannot_unwind
operator|=
literal|0
expr_stmt|;
name|call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|region_desc
operator|=
literal|1
expr_stmt|;
name|call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
operator|.
name|hpux_interrupt_marker
operator|=
literal|0
expr_stmt|;
comment|/* If we got a .PROC pseudo-op, we know that the function is defined      locally.  Make sure it gets into the symbol table.  */
block|{
name|label_symbol_struct
modifier|*
name|label_symbol
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|label_symbol
condition|)
block|{
if|if
condition|(
name|label_symbol
operator|->
name|lss_label
condition|)
block|{
name|last_call_info
operator|->
name|start_symbol
operator|=
name|label_symbol
operator|->
name|lss_label
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|label_symbol
operator|->
name|lss_label
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing function name for .PROC (corrupted label chain)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|last_call_info
operator|->
name|start_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the syntactical end of a procedure.  Make sure all the    appropriate pseudo-ops were found within the procedure.  */
end_comment

begin_function
specifier|static
name|void
name|pa_procend
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If we are within a procedure definition, make sure we've      defined a label for the procedure; handle case where the      label was defined after the .PROC directive.       Note there's not need to diddle with the segment or fragment      for the label symbol in this case.  We have already switched      into the new $CODE$ subspace at this point.  */
if|if
condition|(
name|within_procedure
operator|&&
name|last_call_info
operator|->
name|start_symbol
operator|==
name|NULL
condition|)
block|{
name|label_symbol_struct
modifier|*
name|label_symbol
init|=
name|pa_get_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|label_symbol
condition|)
block|{
if|if
condition|(
name|label_symbol
operator|->
name|lss_label
condition|)
block|{
name|last_call_info
operator|->
name|start_symbol
operator|=
name|label_symbol
operator|->
name|lss_label
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|label_symbol
operator|->
name|lss_label
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* Also handle allocation of a fixup to hold the unwind 		 information when the label appears after the proc/procend.  */
if|if
condition|(
name|within_entry_exit
condition|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|u
operator|=
name|UNWIND_LOW32
argument_list|(
operator|&
name|last_call_info
operator|->
name|ci_unwind
operator|.
name|descriptor
argument_list|)
expr_stmt|;
name|fix_new_hppa
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_HPPA_ENTRY
argument_list|,
name|e_fsel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing function name for .PROC (corrupted label chain)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing function name for .PROC"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|within_procedure
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"misplaced .procend"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callinfo_found
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing .callinfo for this procedure"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_entry_exit
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing .EXIT for a .ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* ELF needs to mark the end of each function so that it can compute      the size of the function (apparently its needed in the symbol table).  */
name|hppa_elf_mark_end_of_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|within_procedure
operator|=
name|FALSE
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* If VALUE is an exact power of two between zero and 2^31, then    return log2 (VALUE).  Else return -1.  */
end_comment

begin_function
specifier|static
name|int
name|exact_log2
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|int
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|!=
name|value
operator|&&
name|shift
operator|<
literal|32
condition|)
name|shift
operator|++
expr_stmt|;
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/* Check to make sure we have a valid space and subspace.  */
end_comment

begin_function
specifier|static
name|void
name|pa_check_current_space_and_subspace
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_space
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Not in a space.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_subspace
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Not in a subspace.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the parameters to a .SPACE directive; if CREATE_FLAG is nonzero,    then create a new space entry to hold the information specified    by the parameters to the .SPACE directive.  */
end_comment

begin_function
specifier|static
name|sd_chain_struct
modifier|*
name|pa_parse_space_stmt
parameter_list|(
name|char
modifier|*
name|space_name
parameter_list|,
name|int
name|create_flag
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|ptemp
decl_stmt|,
name|c
decl_stmt|;
name|char
name|loadable
decl_stmt|,
name|defined
decl_stmt|,
name|private
decl_stmt|,
name|sort
decl_stmt|;
name|int
name|spnum
decl_stmt|;
name|asection
modifier|*
name|seg
init|=
name|NULL
decl_stmt|;
name|sd_chain_struct
modifier|*
name|space
decl_stmt|;
comment|/* Load default values.  */
name|spnum
operator|=
literal|0
expr_stmt|;
name|sort
operator|=
literal|0
expr_stmt|;
name|loadable
operator|=
name|TRUE
expr_stmt|;
name|defined
operator|=
name|TRUE
expr_stmt|;
name|private
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|space_name
argument_list|,
literal|"$TEXT$"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|seg
operator|=
name|pa_def_spaces
index|[
literal|0
index|]
operator|.
name|segment
expr_stmt|;
name|defined
operator|=
name|pa_def_spaces
index|[
literal|0
index|]
operator|.
name|defined
expr_stmt|;
name|private
operator|=
name|pa_def_spaces
index|[
literal|0
index|]
operator|.
name|private
expr_stmt|;
name|sort
operator|=
name|pa_def_spaces
index|[
literal|0
index|]
operator|.
name|sort
expr_stmt|;
name|spnum
operator|=
name|pa_def_spaces
index|[
literal|0
index|]
operator|.
name|spnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|space_name
argument_list|,
literal|"$PRIVATE$"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|seg
operator|=
name|pa_def_spaces
index|[
literal|1
index|]
operator|.
name|segment
expr_stmt|;
name|defined
operator|=
name|pa_def_spaces
index|[
literal|1
index|]
operator|.
name|defined
expr_stmt|;
name|private
operator|=
name|pa_def_spaces
index|[
literal|1
index|]
operator|.
name|private
expr_stmt|;
name|sort
operator|=
name|pa_def_spaces
index|[
literal|1
index|]
operator|.
name|sort
expr_stmt|;
name|spnum
operator|=
name|pa_def_spaces
index|[
literal|1
index|]
operator|.
name|spnum
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|print_errors
operator|=
name|FALSE
expr_stmt|;
name|ptemp
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
comment|/* First see if the space was specified as a number rather than          as a name.  According to the PA assembly manual the rest of          the line should be ignored.  */
name|strict
operator|=
literal|0
expr_stmt|;
name|pa_parse_number
argument_list|(
operator|&
name|ptemp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa_number
operator|>=
literal|0
condition|)
block|{
name|spnum
operator|=
name|pa_number
expr_stmt|;
name|input_line_pointer
operator|=
name|ptemp
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"spnum"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|spnum
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"sort"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|sort
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"unloadable"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|loadable
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"notdefined"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|defined
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"private"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|private
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .SPACE argument"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
name|print_errors
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|create_flag
operator|&&
name|seg
operator|==
name|NULL
condition|)
name|seg
operator|=
name|subseg_new
argument_list|(
name|space_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If create_flag is nonzero, then create the new space with      the attributes computed above.  Else set the values in      an already existing space -- this can only happen for      the first occurrence of a built-in space.  */
if|if
condition|(
name|create_flag
condition|)
name|space
operator|=
name|create_new_space
argument_list|(
name|space_name
argument_list|,
name|spnum
argument_list|,
name|loadable
argument_list|,
name|defined
argument_list|,
name|private
argument_list|,
name|sort
argument_list|,
name|seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|space
operator|=
name|is_defined_space
argument_list|(
name|space_name
argument_list|)
expr_stmt|;
name|SPACE_SPNUM
argument_list|(
name|space
argument_list|)
operator|=
name|spnum
expr_stmt|;
name|SPACE_DEFINED
argument_list|(
name|space
argument_list|)
operator|=
name|defined
operator|&
literal|1
expr_stmt|;
name|SPACE_USER_DEFINED
argument_list|(
name|space
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|obj_set_section_attributes
name|obj_set_section_attributes
argument_list|(
name|seg
argument_list|,
name|defined
argument_list|,
name|private
argument_list|,
name|sort
argument_list|,
name|spnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|space
return|;
block|}
end_function

begin_comment
comment|/* Handle a .SPACE pseudo-op; this switches the current space to the    given space, creating the new space if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|pa_space
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|space_name
decl_stmt|,
modifier|*
name|save_s
decl_stmt|;
name|sd_chain_struct
modifier|*
name|sd_chain
decl_stmt|;
if|if
condition|(
name|within_procedure
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can\'t change spaces within a procedure definition. Ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Check for some of the predefined spaces.   FIXME: most of the code          below is repeated several times, can we extract the common parts          and place them into a subroutine or something similar?  */
comment|/* FIXME Is this (and the next IF stmt) really right? 	 What if INPUT_LINE_POINTER points to "$TEXT$FOO"?  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"$TEXT$"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|sd_chain
operator|=
name|is_defined_space
argument_list|(
literal|"$TEXT$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_chain
operator|==
name|NULL
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
literal|"$TEXT$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SPACE_USER_DEFINED
argument_list|(
name|sd_chain
argument_list|)
operator|==
literal|0
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
literal|"$TEXT$"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_space
operator|=
name|sd_chain
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|text_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"$PRIVATE$"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|9
expr_stmt|;
name|sd_chain
operator|=
name|is_defined_space
argument_list|(
literal|"$PRIVATE$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_chain
operator|==
name|NULL
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
literal|"$PRIVATE$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SPACE_USER_DEFINED
argument_list|(
name|sd_chain
argument_list|)
operator|==
literal|0
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
literal|"$PRIVATE$"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_space
operator|=
name|sd_chain
expr_stmt|;
name|subseg_set
argument_list|(
name|data_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|data_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
name|GDB_DEBUG_SPACE_NAME
argument_list|,
name|strlen
argument_list|(
name|GDB_DEBUG_SPACE_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
name|strlen
argument_list|(
name|GDB_DEBUG_SPACE_NAME
argument_list|)
expr_stmt|;
name|sd_chain
operator|=
name|is_defined_space
argument_list|(
name|GDB_DEBUG_SPACE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_chain
operator|==
name|NULL
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
name|GDB_DEBUG_SPACE_NAME
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SPACE_USER_DEFINED
argument_list|(
name|sd_chain
argument_list|)
operator|==
literal|0
condition|)
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
name|GDB_DEBUG_SPACE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_space
operator|=
name|sd_chain
expr_stmt|;
block|{
name|asection
modifier|*
name|gdb_section
init|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|GDB_DEBUG_SPACE_NAME
argument_list|)
decl_stmt|;
name|subseg_set
argument_list|(
name|gdb_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|gdb_section
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* It could be a space specified by number.  */
name|print_errors
operator|=
literal|0
expr_stmt|;
name|save_s
operator|=
name|input_line_pointer
expr_stmt|;
name|strict
operator|=
literal|0
expr_stmt|;
name|pa_parse_number
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa_number
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sd_chain
operator|=
name|pa_find_space_by_number
argument_list|(
name|pa_number
argument_list|)
operator|)
condition|)
block|{
name|current_space
operator|=
name|sd_chain
expr_stmt|;
name|subseg_set
argument_list|(
name|sd_chain
operator|->
name|sd_seg
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|sd_chain
operator|->
name|sd_seg
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* Not a number, attempt to create a new space.  */
name|print_errors
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|=
name|save_s
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|space_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|space_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|sd_chain
operator|=
name|pa_parse_space_stmt
argument_list|(
name|space_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|current_space
operator|=
name|sd_chain
expr_stmt|;
name|subseg_set
argument_list|(
name|sd_chain
operator|->
name|sd_seg
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|pa_subsegment_to_subspace
argument_list|(
name|sd_chain
operator|->
name|sd_seg
argument_list|,
name|sd_chain
operator|->
name|sd_last_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Switch to a new space.  (I think).  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|pa_spnum
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sd_chain_struct
modifier|*
name|space
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|space
operator|=
name|is_defined_space
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|SPACE_SPNUM
argument_list|(
name|space
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Undefined space: '%s' Assuming space number = 0."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .SUBSPACE pseudo-op; this switches the current subspace to the    given subspace, creating the new subspace if necessary.     FIXME.  Should mirror pa_space more closely, in particular how    they're broken up into subroutines.  */
end_comment

begin_function
specifier|static
name|void
name|pa_subspace
parameter_list|(
name|int
name|create_new
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|ss_name
decl_stmt|,
name|c
decl_stmt|;
name|char
name|loadable
decl_stmt|,
name|code_only
decl_stmt|,
name|comdat
decl_stmt|,
name|common
decl_stmt|,
name|dup_common
decl_stmt|,
name|zero
decl_stmt|,
name|sort
decl_stmt|;
name|int
name|i
decl_stmt|,
name|access
decl_stmt|,
name|space_index
decl_stmt|,
name|alignment
decl_stmt|,
name|quadrant
decl_stmt|,
name|applicable
decl_stmt|,
name|flags
decl_stmt|;
name|sd_chain_struct
modifier|*
name|space
decl_stmt|;
name|ssd_chain_struct
modifier|*
name|ssd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|current_space
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Must be in a space before changing or declaring subspaces.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_procedure
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can\'t change subspaces within a procedure definition. Ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|ss_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ss_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Load default values.  */
name|sort
operator|=
literal|0
expr_stmt|;
name|access
operator|=
literal|0x7f
expr_stmt|;
name|loadable
operator|=
literal|1
expr_stmt|;
name|comdat
operator|=
literal|0
expr_stmt|;
name|common
operator|=
literal|0
expr_stmt|;
name|dup_common
operator|=
literal|0
expr_stmt|;
name|code_only
operator|=
literal|0
expr_stmt|;
name|zero
operator|=
literal|0
expr_stmt|;
name|space_index
operator|=
operator|~
literal|0
expr_stmt|;
name|alignment
operator|=
literal|1
expr_stmt|;
name|quadrant
operator|=
literal|0
expr_stmt|;
name|space
operator|=
name|current_space
expr_stmt|;
if|if
condition|(
name|create_new
condition|)
name|ssd
operator|=
name|NULL
expr_stmt|;
else|else
name|ssd
operator|=
name|is_defined_subspace
argument_list|(
name|ss_name
argument_list|)
expr_stmt|;
comment|/* Allow user to override the builtin attributes of subspaces.  But          only allow the attributes to be changed once!  */
if|if
condition|(
name|ssd
operator|&&
name|SUBSPACE_DEFINED
argument_list|(
name|ssd
argument_list|)
condition|)
block|{
name|subseg_set
argument_list|(
name|ssd
operator|->
name|ssd_seg
argument_list|,
name|ssd
operator|->
name|ssd_subseg
argument_list|)
expr_stmt|;
name|current_subspace
operator|=
name|ssd
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Parameters of an existing subspace can\'t be modified"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* A new subspace.  Load default values if it matches one of 	     the builtin subspaces.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ss_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|loadable
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|loadable
expr_stmt|;
name|comdat
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|comdat
expr_stmt|;
name|common
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|common
expr_stmt|;
name|dup_common
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|dup_common
expr_stmt|;
name|code_only
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|code_only
expr_stmt|;
name|zero
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|zero
expr_stmt|;
name|space_index
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|space_index
expr_stmt|;
name|alignment
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|alignment
expr_stmt|;
name|quadrant
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|quadrant
expr_stmt|;
name|access
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|access
expr_stmt|;
name|sort
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|sort
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* We should be working with a new subspace now.  Fill in          any information as specified by the user.  */
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"quad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|quadrant
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"align"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|alignment
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|exact_log2
argument_list|(
name|alignment
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Alignment must be a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|alignment
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"access"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|access
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"sort"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|sort
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"code_only"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|code_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"unloadable"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|loadable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"comdat"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|comdat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"common"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"dup_comm"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|dup_common
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"zero"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|zero
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"first"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"FIRST not supported as a .SUBSPACE argument"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .SUBSPACE argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_statement
argument_list|()
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
comment|/* Compute a reasonable set of BFD flags based on the information          in the .subspace directive.  */
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loadable
condition|)
name|flags
operator||=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
expr_stmt|;
if|if
condition|(
name|code_only
condition|)
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
comment|/* These flags are used to implement various flavors of initialized 	 common.  The SOM linker discards duplicate subspaces when they 	 have the same "key" symbol name.  This support is more like 	 GNU linkonce than BFD common.  Further, pc-relative relocations 	 are converted to section relative relocations in BFD common 	 sections.  This complicates the handling of relocations in 	 common sections containing text and isn't currently supported 	 correctly in the SOM BFD backend.  */
if|if
condition|(
name|comdat
operator|||
name|common
operator|||
name|dup_common
condition|)
name|flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
name|flags
operator||=
name|SEC_RELOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
comment|/* This is a zero-filled subspace (eg BSS).  */
if|if
condition|(
name|zero
condition|)
name|flags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
name|applicable
operator|&=
name|flags
expr_stmt|;
comment|/* If this is an existing subspace, then we want to use the          segment already associated with the subspace.           FIXME NOW!  ELF BFD doesn't appear to be ready to deal with          lots of sections.  It might be a problem in the PA ELF          code, I do not know yet.  For now avoid creating anything          but the "standard" sections for ELF.  */
if|if
condition|(
name|create_new
condition|)
name|section
operator|=
name|subseg_force_new
argument_list|(
name|ss_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ssd
condition|)
name|section
operator|=
name|ssd
operator|->
name|ssd_seg
expr_stmt|;
else|else
name|section
operator|=
name|subseg_new
argument_list|(
name|ss_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
condition|)
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
comment|/* Now set the flags.  */
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|section
argument_list|,
name|applicable
argument_list|)
expr_stmt|;
comment|/* Record any alignment request for this section.  */
name|record_alignment
argument_list|(
name|section
argument_list|,
name|exact_log2
argument_list|(
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the starting offset for this section.  */
name|bfd_set_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|section
argument_list|,
name|pa_subspace_start
argument_list|(
name|space
argument_list|,
name|quadrant
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that all the flags are set, update an existing subspace,          or create a new one.  */
if|if
condition|(
name|ssd
condition|)
name|current_subspace
operator|=
name|update_subspace
argument_list|(
name|space
argument_list|,
name|ss_name
argument_list|,
name|loadable
argument_list|,
name|code_only
argument_list|,
name|comdat
argument_list|,
name|common
argument_list|,
name|dup_common
argument_list|,
name|sort
argument_list|,
name|zero
argument_list|,
name|access
argument_list|,
name|space_index
argument_list|,
name|alignment
argument_list|,
name|quadrant
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|current_subspace
operator|=
name|create_new_subspace
argument_list|(
name|space
argument_list|,
name|ss_name
argument_list|,
name|loadable
argument_list|,
name|code_only
argument_list|,
name|comdat
argument_list|,
name|common
argument_list|,
name|dup_common
argument_list|,
name|zero
argument_list|,
name|sort
argument_list|,
name|access
argument_list|,
name|space_index
argument_list|,
name|alignment
argument_list|,
name|quadrant
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|current_subspace
operator|->
name|ssd_seg
operator|=
name|section
expr_stmt|;
name|subseg_set
argument_list|(
name|current_subspace
operator|->
name|ssd_seg
argument_list|,
name|current_subspace
operator|->
name|ssd_subseg
argument_list|)
expr_stmt|;
block|}
name|SUBSPACE_DEFINED
argument_list|(
name|current_subspace
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create default space and subspace dictionaries.  */
end_comment

begin_function
specifier|static
name|void
name|pa_spaces_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|space_dict_root
operator|=
name|NULL
expr_stmt|;
name|space_dict_last
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Pick the right name to use for the new section.  */
name|name
operator|=
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|segment
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|create_new_space
argument_list|(
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|spnum
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|loadable
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|defined
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|private
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|sort
argument_list|,
name|pa_def_spaces
index|[
name|i
index|]
operator|.
name|segment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|applicable
decl_stmt|,
name|subsegment
decl_stmt|;
name|asection
modifier|*
name|segment
init|=
name|NULL
decl_stmt|;
name|sd_chain_struct
modifier|*
name|space
decl_stmt|;
comment|/* Pick the right name for the new section and pick the right          subsegment number.  */
name|name
operator|=
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|subsegment
operator|=
literal|0
expr_stmt|;
comment|/* Create the new section.  */
name|segment
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
name|subsegment
argument_list|)
expr_stmt|;
comment|/* For SOM we want to replace the standard .text, .data, and .bss          sections with our own.   We also want to set BFD flags for 	 all the built-in subspaces.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$CODE$"
argument_list|)
condition|)
block|{
name|text_section
operator|=
name|segment
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$DATA$"
argument_list|)
condition|)
block|{
name|data_section
operator|=
name|segment
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$BSS$"
argument_list|)
condition|)
block|{
name|bss_section
operator|=
name|segment
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
name|SEC_ALLOC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$LIT$"
argument_list|)
condition|)
block|{
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$MILLICODE$"
argument_list|)
condition|)
block|{
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"$UNWIND$"
argument_list|)
condition|)
block|{
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|,
name|applicable
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the space associated with this subspace.  */
name|space
operator|=
name|pa_segment_to_space
argument_list|(
name|pa_def_spaces
index|[
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|def_space_index
index|]
operator|.
name|segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error: Unable to find containing space for %s."
argument_list|)
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|create_new_subspace
argument_list|(
name|space
argument_list|,
name|name
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|loadable
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|code_only
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|comdat
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|common
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|dup_common
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|zero
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|sort
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|access
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|space_index
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|alignment
argument_list|,
name|pa_def_subspaces
index|[
name|i
index|]
operator|.
name|quadrant
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new space NAME, with the appropriate flags as defined    by the given parameters.  */
end_comment

begin_function
specifier|static
name|sd_chain_struct
modifier|*
name|create_new_space
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|spnum
parameter_list|,
name|int
name|loadable
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|defined
parameter_list|,
name|int
name|private
parameter_list|,
name|int
name|sort
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|,
name|int
name|user_defined
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|chain_entry
decl_stmt|;
name|chain_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sd_chain_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain_entry
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Out of memory: could not allocate new space chain entry: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SPACE_NAME
argument_list|(
name|chain_entry
argument_list|)
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SPACE_NAME
argument_list|(
name|chain_entry
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SPACE_DEFINED
argument_list|(
name|chain_entry
argument_list|)
operator|=
name|defined
expr_stmt|;
name|SPACE_USER_DEFINED
argument_list|(
name|chain_entry
argument_list|)
operator|=
name|user_defined
expr_stmt|;
name|SPACE_SPNUM
argument_list|(
name|chain_entry
argument_list|)
operator|=
name|spnum
expr_stmt|;
name|chain_entry
operator|->
name|sd_seg
operator|=
name|seg
expr_stmt|;
name|chain_entry
operator|->
name|sd_last_subseg
operator|=
operator|-
literal|1
expr_stmt|;
name|chain_entry
operator|->
name|sd_subspaces
operator|=
name|NULL
expr_stmt|;
name|chain_entry
operator|->
name|sd_next
operator|=
name|NULL
expr_stmt|;
comment|/* Find spot for the new space based on its sort key.  */
if|if
condition|(
operator|!
name|space_dict_last
condition|)
name|space_dict_last
operator|=
name|chain_entry
expr_stmt|;
if|if
condition|(
name|space_dict_root
operator|==
name|NULL
condition|)
name|space_dict_root
operator|=
name|chain_entry
expr_stmt|;
else|else
block|{
name|sd_chain_struct
modifier|*
name|chain_pointer
decl_stmt|;
name|sd_chain_struct
modifier|*
name|prev_chain_pointer
decl_stmt|;
name|chain_pointer
operator|=
name|space_dict_root
expr_stmt|;
name|prev_chain_pointer
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|chain_pointer
condition|)
block|{
name|prev_chain_pointer
operator|=
name|chain_pointer
expr_stmt|;
name|chain_pointer
operator|=
name|chain_pointer
operator|->
name|sd_next
expr_stmt|;
block|}
comment|/* At this point we've found the correct place to add the new          entry.  So add it and update the linked lists as appropriate.  */
if|if
condition|(
name|prev_chain_pointer
condition|)
block|{
name|chain_entry
operator|->
name|sd_next
operator|=
name|chain_pointer
expr_stmt|;
name|prev_chain_pointer
operator|->
name|sd_next
operator|=
name|chain_entry
expr_stmt|;
block|}
else|else
block|{
name|space_dict_root
operator|=
name|chain_entry
expr_stmt|;
name|chain_entry
operator|->
name|sd_next
operator|=
name|chain_pointer
expr_stmt|;
block|}
if|if
condition|(
name|chain_entry
operator|->
name|sd_next
operator|==
name|NULL
condition|)
name|space_dict_last
operator|=
name|chain_entry
expr_stmt|;
block|}
comment|/* This is here to catch predefined spaces which do not get      modified by the user's input.  Another call is found at      the bottom of pa_parse_space_stmt to handle cases where      the user modifies a predefined space.  */
ifdef|#
directive|ifdef
name|obj_set_section_attributes
name|obj_set_section_attributes
argument_list|(
name|seg
argument_list|,
name|defined
argument_list|,
name|private
argument_list|,
name|sort
argument_list|,
name|spnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|chain_entry
return|;
block|}
end_function

begin_comment
comment|/* Create a new subspace NAME, with the appropriate flags as defined    by the given parameters.     Add the new subspace to the subspace dictionary chain in numerical    order as defined by the SORT entries.  */
end_comment

begin_function
specifier|static
name|ssd_chain_struct
modifier|*
name|create_new_subspace
parameter_list|(
name|sd_chain_struct
modifier|*
name|space
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|loadable
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|code_only
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|comdat
parameter_list|,
name|int
name|common
parameter_list|,
name|int
name|dup_common
parameter_list|,
name|int
name|is_zero
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sort
parameter_list|,
name|int
name|access
parameter_list|,
name|int
name|space_index
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|alignment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|quadrant
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|)
block|{
name|ssd_chain_struct
modifier|*
name|chain_entry
decl_stmt|;
name|chain_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ssd_chain_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain_entry
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Out of memory: could not allocate new subspace chain entry: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SUBSPACE_NAME
argument_list|(
name|chain_entry
argument_list|)
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SUBSPACE_NAME
argument_list|(
name|chain_entry
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Initialize subspace_defined.  When we hit a .subspace directive      we'll set it to 1 which "locks-in" the subspace attributes.  */
name|SUBSPACE_DEFINED
argument_list|(
name|chain_entry
argument_list|)
operator|=
literal|0
expr_stmt|;
name|chain_entry
operator|->
name|ssd_subseg
operator|=
literal|0
expr_stmt|;
name|chain_entry
operator|->
name|ssd_seg
operator|=
name|seg
expr_stmt|;
name|chain_entry
operator|->
name|ssd_next
operator|=
name|NULL
expr_stmt|;
comment|/* Find spot for the new subspace based on its sort key.  */
if|if
condition|(
name|space
operator|->
name|sd_subspaces
operator|==
name|NULL
condition|)
name|space
operator|->
name|sd_subspaces
operator|=
name|chain_entry
expr_stmt|;
else|else
block|{
name|ssd_chain_struct
modifier|*
name|chain_pointer
decl_stmt|;
name|ssd_chain_struct
modifier|*
name|prev_chain_pointer
decl_stmt|;
name|chain_pointer
operator|=
name|space
operator|->
name|sd_subspaces
expr_stmt|;
name|prev_chain_pointer
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|chain_pointer
condition|)
block|{
name|prev_chain_pointer
operator|=
name|chain_pointer
expr_stmt|;
name|chain_pointer
operator|=
name|chain_pointer
operator|->
name|ssd_next
expr_stmt|;
block|}
comment|/* Now we have somewhere to put the new entry.  Insert it and update          the links.  */
if|if
condition|(
name|prev_chain_pointer
condition|)
block|{
name|chain_entry
operator|->
name|ssd_next
operator|=
name|chain_pointer
expr_stmt|;
name|prev_chain_pointer
operator|->
name|ssd_next
operator|=
name|chain_entry
expr_stmt|;
block|}
else|else
block|{
name|space
operator|->
name|sd_subspaces
operator|=
name|chain_entry
expr_stmt|;
name|chain_entry
operator|->
name|ssd_next
operator|=
name|chain_pointer
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|obj_set_subsection_attributes
name|obj_set_subsection_attributes
argument_list|(
name|seg
argument_list|,
name|space
operator|->
name|sd_seg
argument_list|,
name|access
argument_list|,
name|sort
argument_list|,
name|quadrant
argument_list|,
name|comdat
argument_list|,
name|common
argument_list|,
name|dup_common
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|chain_entry
return|;
block|}
end_function

begin_comment
comment|/* Update the information for the given subspace based upon the    various arguments.   Return the modified subspace chain entry.  */
end_comment

begin_function
specifier|static
name|ssd_chain_struct
modifier|*
name|update_subspace
parameter_list|(
name|sd_chain_struct
modifier|*
name|space
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|loadable
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|code_only
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|comdat
parameter_list|,
name|int
name|common
parameter_list|,
name|int
name|dup_common
parameter_list|,
name|int
name|sort
parameter_list|,
name|int
name|zero
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|access
parameter_list|,
name|int
name|space_index
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|alignment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|quadrant
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|ssd_chain_struct
modifier|*
name|chain_entry
decl_stmt|;
name|chain_entry
operator|=
name|is_defined_subspace
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obj_set_subsection_attributes
name|obj_set_subsection_attributes
argument_list|(
name|section
argument_list|,
name|space
operator|->
name|sd_seg
argument_list|,
name|access
argument_list|,
name|sort
argument_list|,
name|quadrant
argument_list|,
name|comdat
argument_list|,
name|common
argument_list|,
name|dup_common
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|chain_entry
return|;
block|}
end_function

begin_comment
comment|/* Return the space chain entry for the space with the name NAME or    NULL if no such space exists.  */
end_comment

begin_function
specifier|static
name|sd_chain_struct
modifier|*
name|is_defined_space
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|chain_pointer
decl_stmt|;
for|for
control|(
name|chain_pointer
operator|=
name|space_dict_root
init|;
name|chain_pointer
condition|;
name|chain_pointer
operator|=
name|chain_pointer
operator|->
name|sd_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|SPACE_NAME
argument_list|(
name|chain_pointer
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|chain_pointer
return|;
comment|/* No mapping from segment to space was found.  Return NULL.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find and return the space associated with the given seg.  If no mapping    from the given seg to a space is found, then return NULL.     Unlike subspaces, the number of spaces is not expected to grow much,    so a linear exhaustive search is OK here.  */
end_comment

begin_function
specifier|static
name|sd_chain_struct
modifier|*
name|pa_segment_to_space
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|space_chain
decl_stmt|;
comment|/* Walk through each space looking for the correct mapping.  */
for|for
control|(
name|space_chain
operator|=
name|space_dict_root
init|;
name|space_chain
condition|;
name|space_chain
operator|=
name|space_chain
operator|->
name|sd_next
control|)
if|if
condition|(
name|space_chain
operator|->
name|sd_seg
operator|==
name|seg
condition|)
return|return
name|space_chain
return|;
comment|/* Mapping was not found.  Return NULL.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the first space chain entry for the subspace with the name    NAME or NULL if no such subspace exists.     When there are multiple subspaces with the same name, switching to    the first (i.e., default) subspace is preferable in most situations.    For example, it wouldn't be desirable to merge COMDAT data with non    COMDAT data.     Uses a linear search through all the spaces and subspaces, this may    not be appropriate if we ever being placing each function in its    own subspace.  */
end_comment

begin_function
specifier|static
name|ssd_chain_struct
modifier|*
name|is_defined_subspace
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|space_chain
decl_stmt|;
name|ssd_chain_struct
modifier|*
name|subspace_chain
decl_stmt|;
comment|/* Walk through each space.  */
for|for
control|(
name|space_chain
operator|=
name|space_dict_root
init|;
name|space_chain
condition|;
name|space_chain
operator|=
name|space_chain
operator|->
name|sd_next
control|)
block|{
comment|/* Walk through each subspace looking for a name which matches.  */
for|for
control|(
name|subspace_chain
operator|=
name|space_chain
operator|->
name|sd_subspaces
init|;
name|subspace_chain
condition|;
name|subspace_chain
operator|=
name|subspace_chain
operator|->
name|ssd_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|SUBSPACE_NAME
argument_list|(
name|subspace_chain
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|subspace_chain
return|;
block|}
comment|/* Subspace wasn't found.  Return NULL.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find and return the subspace associated with the given seg.  If no    mapping from the given seg to a subspace is found, then return NULL.     If we ever put each procedure/function within its own subspace    (to make life easier on the compiler and linker), then this will have    to become more efficient.  */
end_comment

begin_function
specifier|static
name|ssd_chain_struct
modifier|*
name|pa_subsegment_to_subspace
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|space_chain
decl_stmt|;
name|ssd_chain_struct
modifier|*
name|subspace_chain
decl_stmt|;
comment|/* Walk through each space.  */
for|for
control|(
name|space_chain
operator|=
name|space_dict_root
init|;
name|space_chain
condition|;
name|space_chain
operator|=
name|space_chain
operator|->
name|sd_next
control|)
block|{
if|if
condition|(
name|space_chain
operator|->
name|sd_seg
operator|==
name|seg
condition|)
block|{
comment|/* Walk through each subspace within each space looking for 	     the correct mapping.  */
for|for
control|(
name|subspace_chain
operator|=
name|space_chain
operator|->
name|sd_subspaces
init|;
name|subspace_chain
condition|;
name|subspace_chain
operator|=
name|subspace_chain
operator|->
name|ssd_next
control|)
if|if
condition|(
name|subspace_chain
operator|->
name|ssd_subseg
operator|==
operator|(
name|int
operator|)
name|subseg
condition|)
return|return
name|subspace_chain
return|;
block|}
block|}
comment|/* No mapping from subsegment to subspace found.  Return NULL.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given a number, try and find a space with the name number.     Return a pointer to a space dictionary chain entry for the space    that was found or NULL on failure.  */
end_comment

begin_function
specifier|static
name|sd_chain_struct
modifier|*
name|pa_find_space_by_number
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|sd_chain_struct
modifier|*
name|space_chain
decl_stmt|;
for|for
control|(
name|space_chain
operator|=
name|space_dict_root
init|;
name|space_chain
condition|;
name|space_chain
operator|=
name|space_chain
operator|->
name|sd_next
control|)
block|{
if|if
condition|(
name|SPACE_SPNUM
argument_list|(
name|space_chain
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|number
condition|)
return|return
name|space_chain
return|;
block|}
comment|/* No appropriate space found.  Return NULL.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the starting address for the given subspace.  If the starting    address is unknown then return zero.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pa_subspace_start
parameter_list|(
name|sd_chain_struct
modifier|*
name|space
parameter_list|,
name|int
name|quadrant
parameter_list|)
block|{
comment|/* FIXME.  Assumes everyone puts read/write data at 0x4000000, this      is not correct for the PA OSF1 port.  */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|SPACE_NAME
argument_list|(
name|space
argument_list|)
argument_list|,
literal|"$PRIVATE$"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|quadrant
operator|==
literal|1
condition|)
return|return
literal|0x40000000
return|;
elseif|else
if|if
condition|(
name|space
operator|->
name|sd_seg
operator|==
name|data_section
operator|&&
name|quadrant
operator|==
literal|1
condition|)
return|return
literal|0x40000000
return|;
else|else
return|return
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Helper function for pa_stringer.  Used to find the end of    a string.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pa_stringer_aux
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|s
operator|&
name|CHAR_MASK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
name|NOT_A_CHAR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Handle a .STRING type pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_stringer
parameter_list|(
name|int
name|append_zero
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|num_buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Preprocess the string to handle PA-specific escape sequences.      For example, \xDD where DD is a hexadecimal number should be      changed to \OOO where OOO is an octal number.  */
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Skip the opening quote.  */
name|s
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|pa_stringer_aux
argument_list|(
name|s
operator|++
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|s
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Handle \x<num>.  */
case|case
literal|'x'
case|:
block|{
name|unsigned
name|int
name|number
decl_stmt|;
name|int
name|num_digit
decl_stmt|;
name|char
name|dg
decl_stmt|;
name|char
modifier|*
name|s_start
init|=
name|s
decl_stmt|;
comment|/* Get past the 'x'.  */
name|s
operator|++
expr_stmt|;
for|for
control|(
name|num_digit
operator|=
literal|0
operator|,
name|number
operator|=
literal|0
operator|,
name|dg
operator|=
operator|*
name|s
init|;
name|num_digit
operator|<
literal|2
operator|&&
operator|(
name|ISDIGIT
argument_list|(
name|dg
argument_list|)
operator|||
operator|(
name|dg
operator|>=
literal|'a'
operator|&&
name|dg
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|dg
operator|>=
literal|'A'
operator|&&
name|dg
operator|<=
literal|'F'
operator|)
operator|)
condition|;
name|num_digit
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|dg
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|dg
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|dg
operator|>=
literal|'a'
operator|&&
name|dg
operator|<=
literal|'f'
condition|)
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|dg
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
name|number
operator|=
name|number
operator|*
literal|16
operator|+
name|dg
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|dg
operator|=
operator|*
name|s
expr_stmt|;
block|}
if|if
condition|(
name|num_digit
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|num_digit
condition|)
block|{
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|num_buf
argument_list|,
literal|"%02o"
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|num_buf
argument_list|,
literal|"%03o"
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_digit
condition|;
name|i
operator|++
control|)
name|s_start
index|[
name|i
index|]
operator|=
name|num_buf
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
block|}
comment|/* This might be a "\"", skip over the escaped char.  */
default|default:
name|s
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|stringer
argument_list|(
name|append_zero
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .VERSION pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_version
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|obj_version
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SOM
end_ifdef

begin_comment
comment|/* Handle a .COMPILER pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_compiler
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|obj_som_compiler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a .COPYRIGHT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|pa_copyright
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|obj_copyright
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like a normal cons, but when finished we have to undefine    the latest space label.  */
end_comment

begin_function
specifier|static
name|void
name|pa_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|cons
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like float_cons, but we need to undefine our label.  */
end_comment

begin_function
specifier|static
name|void
name|pa_float_cons
parameter_list|(
name|int
name|float_type
parameter_list|)
block|{
name|float_cons
argument_list|(
name|float_type
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like s_fill, but delete our label when finished.  */
end_comment

begin_function
specifier|static
name|void
name|pa_fill
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|s_fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like lcomm, but delete our label when finished.  */
end_comment

begin_function
specifier|static
name|void
name|pa_lcomm
parameter_list|(
name|int
name|needs_align
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|s_lcomm
argument_list|(
name|needs_align
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like lsym, but delete our label when finished.  */
end_comment

begin_function
specifier|static
name|void
name|pa_lsym
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* We must have a valid space and subspace.  */
name|pa_check_current_space_and_subspace
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|s_lsym
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pa_undefine_label
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|last_call_info
operator|=
name|NULL
expr_stmt|;
name|call_info_root
operator|=
name|NULL
expr_stmt|;
comment|/* Set the default machine type.  */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_hppa
argument_list|,
name|DEFAULT_LEVEL
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Folding of text and data segments fails miserably on the PA.      Warn user and disable "-R" option.  */
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-R option not supported on this target."
argument_list|)
argument_list|)
expr_stmt|;
name|flag_readonly_data_in_text
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_SOM
name|pa_spaces_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NUMOPCODES
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
expr|struct
name|pa_opcode
operator|*
operator|)
operator|&
name|pa_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
operator|*
name|retval
operator|!=
literal|'\0'
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|(
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|match
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: losing opcode: `%s' \"%s\"\n"
argument_list|)
argument_list|,
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|NUMOPCODES
operator|&&
operator|!
name|strcmp
argument_list|(
name|pa_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
comment|/* SOM will change text_section.  To make sure we never put      anything into the old one switch to the new one now.  */
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_SOM
name|dummy_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"L$dummy"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|dummy_symbol
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
comment|/* Force the symbol to be converted to a real symbol.  */
operator|(
name|void
operator|)
name|symbol_get_bfdsym
argument_list|(
name|dummy_symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* On the PA relocations which involve function symbols must not be    adjusted.  This so that the linker can know when/how to create argument    relocation stubs for indirect calls and calls to static functions.     "T" field selectors create DLT relative fixups for accessing    globals and statics in PIC code; each DLT relative fixup creates    an entry in the DLT table.  The entries contain the address of    the final target (eg accessing "foo" would create a DLT entry    with the address of "foo").     Unfortunately, the HP linker doesn't take into account any addend    when generating the DLT; so accessing $LIT$+8 puts the address of    $LIT$ into the DLT rather than the address of $LIT$+8.     The end result is we can't perform relocation symbol reductions for    any fixup which creates entries in the DLT (eg they use "T" field    selectors).     ??? Reject reductions involving symbols with external scope; such    reductions make life a living hell for object file editors.  */
end_comment

begin_function
name|int
name|hppa_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
name|reloc_type
name|code
decl_stmt|;
endif|#
directive|endif
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fix
decl_stmt|;
name|hppa_fix
operator|=
operator|(
expr|struct
name|hppa_fix_struct
operator|*
operator|)
name|fixp
operator|->
name|tc_fix_data
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* LR/RR selectors are implicitly used for a number of different relocation      types.  We must ensure that none of these types are adjusted (see below)      even if they occur with a different selector.  */
name|code
operator|=
name|elf_hppa_reloc_final_type
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|,
name|hppa_fix
operator|->
name|fx_r_format
argument_list|,
name|hppa_fix
operator|->
name|fx_r_field
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Relocation types which use e_lrsel.  */
case|case
name|R_PARISC_DIR21L
case|:
case|case
name|R_PARISC_DLTREL21L
case|:
case|case
name|R_PARISC_DPREL21L
case|:
case|case
name|R_PARISC_PLTOFF21L
case|:
comment|/* Relocation types which use e_rrsel.  */
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DIR14DR
case|:
case|case
name|R_PARISC_DIR14WR
case|:
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DLTREL14R
case|:
case|case
name|R_PARISC_DLTREL14DR
case|:
case|case
name|R_PARISC_DLTREL14WR
case|:
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL14DR
case|:
case|case
name|R_PARISC_DPREL14WR
case|:
case|case
name|R_PARISC_PLTOFF14R
case|:
case|case
name|R_PARISC_PLTOFF14DR
case|:
case|case
name|R_PARISC_PLTOFF14WR
case|:
comment|/* Other types that we reject for reduction.  */
case|case
name|R_PARISC_GNU_VTENTRY
case|:
case|case
name|R_PARISC_GNU_VTINHERIT
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* Reject reductions of symbols in sym1-sym2 expressions when      the fixup will occur in a CODE subspace.       XXX FIXME: Long term we probably want to reject all of these;      for example reducing in the debug section would lose if we ever      supported using the optimizing hp linker.  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|&&
operator|(
name|hppa_fix
operator|->
name|segment
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We can't adjust any relocs that use LR% and RR% field selectors.       If a symbol is reduced to a section symbol, the assembler will      adjust the addend unless the symbol happens to reside right at      the start of the section.  Additionally, the linker has no choice      but to manipulate the addends when coalescing input sections for      "ld -r".  Since an LR% field selector is defined to round the      addend, we can't change the addend without risking that a LR% and      it's corresponding (possible multiple) RR% field will no longer      sum to the right value.       eg. Suppose we have      .		ldil	LR%foo+0,%r21      .		ldw	RR%foo+0(%r21),%r26      .		ldw	RR%foo+4(%r21),%r25       If foo is at address 4092 (decimal) in section `sect', then after      reducing to the section symbol we get      .			LR%sect+4092 == (L%sect)+0      .			RR%sect+4092 == (R%sect)+4092      .			RR%sect+4096 == (R%sect)-4096      and the last address loses because rounding the addend to 8k      multiples takes us up to 8192 with an offset of -4096.       In cases where the LR% expression is identical to the RR% one we      will never have a problem, but is so happens that gcc rounds      addends involved in LR% field selectors to work around a HP      linker bug.  ie. We often have addresses like the last case      above where the LR% expression is offset from the RR% one.  */
if|if
condition|(
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_lrsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_rrsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_nlrsel
condition|)
return|return
literal|0
return|;
comment|/* Reject reductions of symbols in DLT relative relocs,      relocations with plabels.  */
if|if
condition|(
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_tsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_ltsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_rtsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_psel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_rpsel
operator|||
name|hppa_fix
operator|->
name|fx_r_field
operator|==
name|e_lpsel
condition|)
return|return
literal|0
return|;
comment|/* Reject absolute calls (jumps).  */
if|if
condition|(
name|hppa_fix
operator|->
name|fx_r_type
operator|==
name|R_HPPA_ABS_CALL
condition|)
return|return
literal|0
return|;
comment|/* Reject reductions of function symbols.  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
literal|0
operator|&&
name|S_IS_FUNCTION
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the fixup in FIXP will require a relocation,    even it if appears that the fixup could be completely handled    within GAS.  */
end_comment

begin_function
name|int
name|hppa_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixp
parameter_list|)
block|{
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fixp
decl_stmt|;
name|hppa_fixp
operator|=
operator|(
expr|struct
name|hppa_fix_struct
operator|*
operator|)
name|fixp
operator|->
name|tc_fix_data
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_ENTRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_EXIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_BEGIN_BRTAB
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_END_BRTAB
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_BEGIN_TRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_END_TRY
operator|||
operator|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|&&
operator|(
name|hppa_fixp
operator|->
name|segment
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTINHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTENTRY
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
name|assert
argument_list|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Ensure we emit a relocation for global symbols so that dynamic      linking works.  */
if|if
condition|(
name|S_FORCE_RELOC
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* It is necessary to force PC-relative calls/jumps to have a relocation      entry if they're going to need either an argument relocation or long      call stub.  */
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
operator|&&
name|arg_reloc_stub_needed
argument_list|(
name|symbol_arg_reloc_info
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|hppa_fixp
operator|->
name|fx_arg_reloc
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now check to see if we're going to need a long-branch stub.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_PCREL_CALL
condition|)
block|{
name|long
name|pc
init|=
name|md_pcrel_from
argument_list|(
name|fixp
argument_list|)
decl_stmt|;
name|valueT
name|distance
decl_stmt|,
name|min_stub_distance
decl_stmt|;
name|distance
operator|=
name|fixp
operator|->
name|fx_offset
operator|+
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|-
name|pc
operator|-
literal|8
expr_stmt|;
comment|/* Distance to the closest possible stub.  This will detect most 	 but not all circumstances where a stub will not work.  */
name|min_stub_distance
operator|=
name|pc
operator|+
literal|16
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_SOM
if|if
condition|(
name|last_call_info
operator|!=
name|NULL
condition|)
name|min_stub_distance
operator|-=
name|S_GET_VALUE
argument_list|(
name|last_call_info
operator|->
name|start_symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|distance
operator|+
literal|8388608
operator|>=
literal|16777216
operator|&&
name|min_stub_distance
operator|<=
literal|8388608
operator|)
operator|||
operator|(
name|hppa_fixp
operator|->
name|fx_r_format
operator|==
literal|17
operator|&&
name|distance
operator|+
literal|262144
operator|>=
literal|524288
operator|&&
name|min_stub_distance
operator|<=
literal|262144
operator|)
operator|||
operator|(
name|hppa_fixp
operator|->
name|fx_r_format
operator|==
literal|12
operator|&&
name|distance
operator|+
literal|8192
operator|>=
literal|16384
operator|&&
name|min_stub_distance
operator|<=
literal|8192
operator|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
operator|(
name|int
operator|)
name|R_HPPA_ABS_CALL
condition|)
return|return
literal|1
return|;
comment|/* No need (yet) to force another relocations to be emitted.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Now for some ELF specific code.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* For ELF, this function serves one purpose:  to setup the st_size    field of STT_FUNC symbols.  To do this, we need to scan the    call_info structure list, determining st_size in by taking the    difference in the address of the beginning/end marker symbols.  */
end_comment

begin_function
name|void
name|elf_hppa_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|call_info
modifier|*
name|call_info_pointer
decl_stmt|;
for|for
control|(
name|call_info_pointer
operator|=
name|call_info_root
init|;
name|call_info_pointer
condition|;
name|call_info_pointer
operator|=
name|call_info_pointer
operator|->
name|ci_next
control|)
block|{
name|elf_symbol_type
modifier|*
name|esym
init|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol_get_bfdsym
argument_list|(
name|call_info_pointer
operator|->
name|start_symbol
argument_list|)
operator|)
decl_stmt|;
name|esym
operator|->
name|internal_elf_sym
operator|.
name|st_size
operator|=
name|S_GET_VALUE
argument_list|(
name|call_info_pointer
operator|->
name|end_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|call_info_pointer
operator|->
name|start_symbol
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pa_vtable_entry
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|fix
modifier|*
name|new_fix
decl_stmt|;
name|new_fix
operator|=
name|obj_elf_vtable_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fix
condition|)
block|{
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fix
init|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hppa_fix_struct
argument_list|)
argument_list|)
decl_stmt|;
name|hppa_fix
operator|->
name|fx_r_type
operator|=
name|R_HPPA
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_field
operator|=
name|e_fsel
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_format
operator|=
literal|32
expr_stmt|;
name|hppa_fix
operator|->
name|fx_arg_reloc
operator|=
literal|0
expr_stmt|;
name|hppa_fix
operator|->
name|segment
operator|=
name|now_seg
expr_stmt|;
name|new_fix
operator|->
name|tc_fix_data
operator|=
operator|(
name|void
operator|*
operator|)
name|hppa_fix
expr_stmt|;
name|new_fix
operator|->
name|fx_r_type
operator|=
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTENTRY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pa_vtable_inherit
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|fix
modifier|*
name|new_fix
decl_stmt|;
name|new_fix
operator|=
name|obj_elf_vtable_inherit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fix
condition|)
block|{
name|struct
name|hppa_fix_struct
modifier|*
name|hppa_fix
init|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hppa_fix_struct
argument_list|)
argument_list|)
decl_stmt|;
name|hppa_fix
operator|->
name|fx_r_type
operator|=
name|R_HPPA
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_field
operator|=
name|e_fsel
expr_stmt|;
name|hppa_fix
operator|->
name|fx_r_format
operator|=
literal|32
expr_stmt|;
name|hppa_fix
operator|->
name|fx_arg_reloc
operator|=
literal|0
expr_stmt|;
name|hppa_fix
operator|->
name|segment
operator|=
name|now_seg
expr_stmt|;
name|new_fix
operator|->
name|tc_fix_data
operator|=
operator|(
name|void
operator|*
operator|)
name|hppa_fix
expr_stmt|;
name|new_fix
operator|->
name|fx_r_type
operator|=
operator|(
name|int
operator|)
name|R_PARISC_GNU_VTINHERIT
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of pseudo ops for the PA.  FIXME -- how many of these    are now redundant with the overall GAS and the object file    dependent tables?  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* align pseudo-ops on the PA specify the actual alignment requested,      not the log2 of the requested alignment.  */
ifdef|#
directive|ifdef
name|OBJ_SOM
block|{
literal|"align"
block|,
name|pa_align
block|,
literal|8
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|8
block|}
block|,
endif|#
directive|endif
block|{
literal|"begin_brtab"
block|,
name|pa_brtab
block|,
literal|1
block|}
block|,
block|{
literal|"begin_try"
block|,
name|pa_try
block|,
literal|1
block|}
block|,
block|{
literal|"block"
block|,
name|pa_block
block|,
literal|1
block|}
block|,
block|{
literal|"blockz"
block|,
name|pa_block
block|,
literal|0
block|}
block|,
block|{
literal|"byte"
block|,
name|pa_cons
block|,
literal|1
block|}
block|,
block|{
literal|"call"
block|,
name|pa_call
block|,
literal|0
block|}
block|,
block|{
literal|"callinfo"
block|,
name|pa_callinfo
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
block|{
literal|"code"
block|,
name|obj_elf_text
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"code"
block|,
name|pa_text
block|,
literal|0
block|}
block|,
block|{
literal|"comm"
block|,
name|pa_comm
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_SOM
block|{
literal|"compiler"
block|,
name|pa_compiler
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"copyright"
block|,
name|pa_copyright
block|,
literal|0
block|}
block|,
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
block|{
literal|"data"
block|,
name|pa_data
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"double"
block|,
name|pa_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"dword"
block|,
name|pa_cons
block|,
literal|8
block|}
block|,
block|{
literal|"end"
block|,
name|pa_end
block|,
literal|0
block|}
block|,
block|{
literal|"end_brtab"
block|,
name|pa_brtab
block|,
literal|0
block|}
block|,
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
block|{
literal|"end_try"
block|,
name|pa_try
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"enter"
block|,
name|pa_enter
block|,
literal|0
block|}
block|,
block|{
literal|"entry"
block|,
name|pa_entry
block|,
literal|0
block|}
block|,
block|{
literal|"equ"
block|,
name|pa_equ
block|,
literal|0
block|}
block|,
block|{
literal|"exit"
block|,
name|pa_exit
block|,
literal|0
block|}
block|,
block|{
literal|"export"
block|,
name|pa_export
block|,
literal|0
block|}
block|,
block|{
literal|"fill"
block|,
name|pa_fill
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|pa_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"half"
block|,
name|pa_cons
block|,
literal|2
block|}
block|,
block|{
literal|"import"
block|,
name|pa_import
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|pa_cons
block|,
literal|4
block|}
block|,
block|{
literal|"label"
block|,
name|pa_label
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|pa_lcomm
block|,
literal|0
block|}
block|,
block|{
literal|"leave"
block|,
name|pa_leave
block|,
literal|0
block|}
block|,
block|{
literal|"level"
block|,
name|pa_level
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|pa_cons
block|,
literal|4
block|}
block|,
block|{
literal|"lsym"
block|,
name|pa_lsym
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_SOM
block|{
literal|"nsubspa"
block|,
name|pa_subspace
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
literal|"octa"
block|,
name|pa_cons
block|,
literal|16
block|}
block|,
block|{
literal|"org"
block|,
name|pa_origin
block|,
literal|0
block|}
block|,
block|{
literal|"origin"
block|,
name|pa_origin
block|,
literal|0
block|}
block|,
block|{
literal|"param"
block|,
name|pa_param
block|,
literal|0
block|}
block|,
block|{
literal|"proc"
block|,
name|pa_proc
block|,
literal|0
block|}
block|,
block|{
literal|"procend"
block|,
name|pa_procend
block|,
literal|0
block|}
block|,
block|{
literal|"quad"
block|,
name|pa_cons
block|,
literal|8
block|}
block|,
block|{
literal|"reg"
block|,
name|pa_equ
block|,
literal|1
block|}
block|,
block|{
literal|"short"
block|,
name|pa_cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|pa_float_cons
block|,
literal|'f'
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_SOM
block|{
literal|"space"
block|,
name|pa_space
block|,
literal|0
block|}
block|,
block|{
literal|"spnum"
block|,
name|pa_spnum
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"string"
block|,
name|pa_stringer
block|,
literal|0
block|}
block|,
block|{
literal|"stringz"
block|,
name|pa_stringer
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_SOM
block|{
literal|"subspa"
block|,
name|pa_subspace
block|,
literal|0
block|}
block|,
endif|#
directive|endif
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|)
operator|)
block|{
literal|"text"
block|,
name|pa_text
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"version"
block|,
name|pa_version
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"vtable_entry"
block|,
name|pa_vtable_entry
block|,
literal|0
block|}
block|,
block|{
literal|"vtable_inherit"
block|,
name|pa_vtable_inherit
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"word"
block|,
name|pa_cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
name|void
name|hppa_cfi_frame_initial_instructions
parameter_list|(
name|void
parameter_list|)
block|{
name|cfi_add_CFA_def_cfa
argument_list|(
literal|30
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hppa_regname_to_dw2regnum
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|unsigned
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|dw2regnum
decl_stmt|;
block|}
name|regnames
index|[]
init|=
block|{
block|{
literal|"sp"
block|,
literal|30
block|}
block|,
block|{
literal|"rp"
block|,
literal|2
block|}
block|,     }
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|regnames
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|regnames
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|regname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|regnames
index|[
name|i
index|]
operator|.
name|dw2regnum
return|;
if|if
condition|(
name|regname
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
name|p
operator|=
name|regname
operator|+
literal|1
expr_stmt|;
name|regnum
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
operator|||
operator|*
name|q
operator|||
name|regnum
operator|>=
literal|32
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|regname
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|regname
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
name|p
operator|=
name|regname
operator|+
literal|2
expr_stmt|;
name|regnum
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
operator|||
operator|*
name|q
operator|||
name|regnum
operator|<=
literal|4
operator|||
name|regnum
operator|>=
literal|32
condition|)
return|return
operator|-
literal|1
return|;
name|regnum
operator|+=
literal|32
operator|-
literal|4
expr_stmt|;
block|}
return|return
name|regnum
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

