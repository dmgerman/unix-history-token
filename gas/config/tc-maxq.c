begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-maxq.c -- assembler code for a MAXQ chip.     Copyright 2004, 2005 Free Software Foundation, Inc.     Contributed by HCL Technologies Pvt. Ltd.     Author: Vineet Sharma(vineets@noida.hcltech.com) Inderpreet    S.(inderpreetb@noida.hcltech.com)     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GAS is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GAS; see the file COPYING.  If not, write to the Free Software    Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"tc-maxq.h"
end_include

begin_include
include|#
directive|include
file|"opcode/maxq.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXQ10S
end_ifndef

begin_define
define|#
directive|define
name|MAXQ10S
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_STRING_H
end_ifndef

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|"MAXQ20"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_OPERANDS
end_ifndef

begin_define
define|#
directive|define
name|MAX_OPERANDS
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MNEM_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_MNEM_SIZE
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|END_OF_INSN
end_ifndef

begin_define
define|#
directive|define
name|END_OF_INSN
value|'\0'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IMMEDIATE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|IMMEDIATE_PREFIX
value|'#'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_REG_NAME_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_REG_NAME_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MEM_NAME_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_MEM_NAME_SIZE
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* opcode for PFX[0].  */
end_comment

begin_define
define|#
directive|define
name|PFX0
value|0x0b
end_define

begin_comment
comment|/* Set default to MAXQ20.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|max_version
init|=
name|bfd_mach_maxq20
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|default_arch
init|=
name|DEFAULT_ARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of the operand: Register,Immediate,Memory access,flag or bit.  */
end_comment

begin_union
union|union
name|_maxq20_op
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|char
name|imms
decl_stmt|;
comment|/* This is to store the immediate value operand.  */
name|expressionS
modifier|*
name|disps
decl_stmt|;
name|symbolS
modifier|*
name|data
decl_stmt|;
specifier|const
name|mem_access
modifier|*
name|mem
decl_stmt|;
name|int
name|flag
decl_stmt|;
specifier|const
name|reg_bit
modifier|*
name|r_bit
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|_maxq20_op
name|maxq20_opcode
typedef|;
end_typedef

begin_comment
comment|/* For handling optional L/S in Maxq20.  */
end_comment

begin_comment
comment|/* Exposed For Linker - maps indirectly to the liker relocations.  */
end_comment

begin_define
define|#
directive|define
name|LONG_PREFIX
value|MAXQ_LONGJUMP
end_define

begin_comment
comment|/* BFD_RELOC_16 */
end_comment

begin_define
define|#
directive|define
name|SHORT_PREFIX
value|MAXQ_SHORTJUMP
end_define

begin_comment
comment|/* BFD_RELOC_16_PCREL_S2 */
end_comment

begin_define
define|#
directive|define
name|ABSOLUTE_ADDR_FOR_DATA
value|MAXQ_INTERSEGMENT
end_define

begin_define
define|#
directive|define
name|NO_PREFIX
value|0
end_define

begin_define
define|#
directive|define
name|EXPLICT_LONG_PREFIX
value|14
end_define

begin_comment
comment|/* The main instruction structure containing fields to describe instrn */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_maxq20_insn
block|{
comment|/* The opcode information for the MAXQ20 */
name|MAXQ20_OPCODE_INFO
name|op
decl_stmt|;
comment|/* The number of operands */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* Number of different types of operands - Comments can be removed if reqd.     */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|data_operands
decl_stmt|;
name|unsigned
name|int
name|imm_operands
decl_stmt|,
name|imm_bit_operands
decl_stmt|,
name|bit_operands
decl_stmt|,
name|flag_operands
decl_stmt|;
comment|/* Types of the individual operands */
name|UNKNOWN_OP
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Relocation type for operand : to be investigated into */
name|int
name|reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Complete information of the Operands */
name|maxq20_opcode
name|maxq20_op
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Choice of prefix register whenever needed */
name|int
name|prefix
decl_stmt|;
comment|/* Optional Prefix for Instructions like LJUMP, SJUMP etc */
name|unsigned
name|char
name|Instr_Prefix
decl_stmt|;
comment|/* 16 bit Instruction word */
name|unsigned
name|char
name|instr
index|[
literal|2
index|]
decl_stmt|;
block|}
name|maxq20_insn
typedef|;
end_typedef

begin_comment
comment|/* Definitions of all possible characters that can start an operand.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|extra_symbol_chars
init|=
literal|"@(#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special Character that would start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Starts a comment when it appears at the start of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* originally may b by sudeep "\n".  */
end_comment

begin_comment
comment|/*  The following are used for option processing.  */
end_comment

begin_comment
comment|/* This is added to the mach independent string passed to getopt.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"q"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters for exponent and floating point.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is for the machine dependent option handling.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|MAXQ_10
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|MAXQ_20
value|(OPTION_MD_BASE + 3)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"MAXQ10"
block|,
name|no_argument
block|,
name|NULL
block|,
name|MAXQ_10
block|}
block|,
block|{
literal|"MAXQ20"
block|,
name|no_argument
block|,
name|NULL
block|,
name|MAXQ_20
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* md_undefined_symbol We have no need for this function.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|maxq_target
parameter_list|(
name|int
name|target
parameter_list|)
block|{
name|max_version
operator|=
name|target
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_maxq
argument_list|,
name|max_version
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Any options support will be added onto this switch case.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|MAXQ_10
case|:
name|max_version
operator|=
name|bfd_mach_maxq10
expr_stmt|;
break|break;
case|case
name|MAXQ_20
case|:
name|max_version
operator|=
name|bfd_mach_maxq20
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* When a usage message is printed, this function is called and    it prints a description of the machine specific options.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
comment|/* Over here we will fill the description of the machine specific options.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" MAXQ-specific assembler options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ 	-MAXQ20		       generate obj for MAXQ20(default)\n\ 	-MAXQ10		       generate obj for MAXQ10\n\ 	"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|maxq20_mach
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"MAXQ20"
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown architecture"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|MAXQ_INTERSEGMENT
case|:
case|case
name|MAXQ_LONGJUMP
case|:
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
switch|switch
condition|(
name|fixp
operator|->
name|fx_size
condition|)
block|{
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can not do %d byte relocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
block|}
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax()     Called just before relax() for rs_machine_dependent frags.  The MAXQ    assembler uses these frags to handle 16 bit absolute jumps which require a     prefix instruction to be inserted. Any symbol that is now undefined will    not become defined. Return the correct fr_subtype in the frag. Return the    initial "guess for variable size of frag"(This will be eiter 2 or 0) to    caller. The guess is actually the growth beyond the fixed part.  Whatever    we do to grow the fixed or variable part contributes to our returned    value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
parameter_list|)
block|{
comment|/* Check whether the symbol has been resolved or not.      Otherwise we will have to generate a fixup.  */
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
operator|)
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|EXPLICT_LONG_PREFIX
condition|)
block|{
name|RELOC_ENUM
name|reloc_type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|int
name|old_fr_fix
decl_stmt|;
comment|/* Now this symbol has not been defined in this file. 	 Hence we will have to create a fixup.  */
name|int
name|size
init|=
literal|2
decl_stmt|;
comment|/* This is for the prefix instruction.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|EXPLICT_LONG_PREFIX
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|LONG_PREFIX
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
operator|&&
operator|(
operator|(
operator|!
operator|(
name|fragP
operator|->
name|fr_subtype
operator|)
operator|==
name|EXPLICT_LONG_PREFIX
operator|)
operator|)
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|ABSOLUTE_ADDR_FOR_DATA
expr_stmt|;
name|reloc_type
operator|=
operator|(
name|fragP
operator|->
name|fr_subtype
condition|?
name|fragP
operator|->
name|fr_subtype
else|:
name|ABSOLUTE_ADDR_FOR_DATA
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|reloc_type
expr_stmt|;
if|if
condition|(
name|reloc_type
operator|==
name|SHORT_PREFIX
condition|)
name|size
operator|=
literal|0
expr_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
operator|(
name|size
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|-
literal|2
argument_list|,
name|size
operator|+
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
return|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|SHORT_PREFIX
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|SHORT_PREFIX
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|NO_PREFIX
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|LONG_PREFIX
condition|)
block|{
name|unsigned
name|long
name|instr
decl_stmt|;
name|unsigned
name|long
name|call_addr
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
name|diff
operator|=
name|diff
operator|^
name|diff
expr_stmt|;
empty_stmt|;
name|call_addr
operator|=
name|call_addr
operator|^
name|call_addr
expr_stmt|;
name|instr
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* segment_info_type *seginfo = seg_info (segment);  */
name|instr
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
literal|2
expr_stmt|;
comment|/* This is the offset if it is a PC relative jump.  */
name|call_addr
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* PC stores the value of the next instruction.  */
name|diff
operator|=
operator|(
name|call_addr
operator|-
name|instr
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
operator|(
operator|-
literal|128
operator|*
literal|2
operator|)
operator|&&
name|diff
operator|<=
operator|(
literal|2
operator|*
literal|127
operator|)
condition|)
block|{
comment|/* Now as offset is an 8 bit value, we will pass 	     that to the jump instruction directly.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|NO_PREFIX
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|->
name|fr_subtype
operator|=
name|LONG_PREFIX
expr_stmt|;
return|return
literal|2
return|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Illegal Reloc type in md_estimate_size_before_relax for line : %d"
argument_list|)
argument_list|,
name|frag_now
operator|->
name|fr_line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type     TYPE, and store the appropriate bytes in *LITP.  The number of LITTLENUMS    emitted is stored in *SIZEP.  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
comment|/* The size of Double has been changed to 2 words ie 32 bits.  */
comment|/* prec = 4; */
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|maxq20_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|unsigned
name|int
name|off
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
name|r
operator|=
name|MAXQ_WORDDATA
expr_stmt|;
comment|/* Word+n */
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|MAXQ_LONGDATA
expr_stmt|;
comment|/* Long+n */
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* GAS will call this for every rs_machine_dependent fragment. The    instruction is compleated using the data from the relaxation pass. It may    also create any necessary relocations.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|char
modifier|*
name|opcode
decl_stmt|;
name|offsetT
name|target_address
decl_stmt|;
name|offsetT
name|opcode_address
decl_stmt|;
name|offsetT
name|displacement_from_opcode_start
decl_stmt|;
name|int
name|address
decl_stmt|;
name|opcode
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|address
operator|=
literal|0
expr_stmt|;
name|target_address
operator|=
name|opcode_address
operator|=
name|displacement_from_opcode_start
operator|=
literal|0
expr_stmt|;
name|target_address
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|/
name|MAXQ_OCTETS_PER_BYTE
operator|)
operator|+
operator|(
name|fragP
operator|->
name|fr_offset
operator|/
name|MAXQ_OCTETS_PER_BYTE
operator|)
expr_stmt|;
name|opcode_address
operator|=
operator|(
name|fragP
operator|->
name|fr_address
operator|/
name|MAXQ_OCTETS_PER_BYTE
operator|)
operator|+
operator|(
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
literal|2
operator|)
operator|/
name|MAXQ_OCTETS_PER_BYTE
operator|)
expr_stmt|;
comment|/* PC points to the next Instruction.  */
name|displacement_from_opcode_start
operator|=
operator|(
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|displacement_from_opcode_start
operator|>=
operator|-
literal|128
operator|&&
name|displacement_from_opcode_start
operator|<=
literal|127
operator|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|SHORT_PREFIX
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|NO_PREFIX
operator|)
condition|)
block|{
comment|/* Its a displacement.  */
operator|*
name|opcode
operator|=
operator|(
name|char
operator|)
name|displacement_from_opcode_start
expr_stmt|;
block|}
else|else
block|{
comment|/* Its an absolute 16 bit jump. Now we have to 	 load the prefix operator with the upper 8 bits.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|SHORT_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cant make long jump/call into short jump/call : %d"
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check whether the symbol has been resolved or not. 	 Otherwise we will have to generate a fixup.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
name|SHORT_PREFIX
condition|)
block|{
name|RELOC_ENUM
name|reloc_type
decl_stmt|;
name|int
name|old_fr_fix
decl_stmt|;
name|int
name|size
init|=
literal|2
decl_stmt|;
comment|/* Now this is a basolute jump/call. 	     Hence we will have to create a fixup.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|NO_PREFIX
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|LONG_PREFIX
expr_stmt|;
name|reloc_type
operator|=
operator|(
name|fragP
operator|->
name|fr_subtype
condition|?
name|fragP
operator|->
name|fr_subtype
else|:
name|LONG_PREFIX
operator|)
expr_stmt|;
if|if
condition|(
name|reloc_type
operator|==
literal|1
condition|)
name|size
operator|=
literal|0
expr_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
operator|(
name|size
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|-
literal|2
argument_list|,
name|size
operator|+
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Writes the val to the buf, where n is the nuumber of bytes to write.  */
end_comment

begin_function
name|void
name|maxq_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GAS will call this for each fixup. It's main objective is to store the    correct value in the object file. 'fixup_segment' performs the generic    overflow check on the 'valueT *val' argument after md_apply_fix returns.    If the overflow check is relevant for the target machine, then    'md_apply_fix' should modify 'valueT *val', typically to the value stored     in the object file (not to be done in MAXQ).  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valT
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|char
modifier|*
name|frag_to_fix_at
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_fix
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|fixP
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|&&
name|valT
condition|)
block|{
comment|/* If the relaxation substate is not defined we make it equal 	     to the kind of relocation the fixup is generated for.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_subtype
condition|)
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_subtype
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
comment|/* For any instruction in which either we have specified an 	     absolute address or it is a long jump we need to add a PFX0 	     instruction to it. In this case as the instruction has already 	     being written at 'fx_where' in the frag we copy it at the end of  	     the frag(which is where the relocation was generated) as when 	     the relocation is generated the frag is grown by 2 type, this is  	     where we copy the contents of fx_where and add a pfx0 at 	     fx_where.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_subtype
operator|==
name|ABSOLUTE_ADDR_FOR_DATA
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_subtype
operator|==
name|LONG_PREFIX
operator|)
condition|)
block|{
operator|*
operator|(
name|frag_to_fix_at
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|maxq_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|PFX0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Remember value for tc_gen_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
operator|*
name|valT
expr_stmt|;
block|}
comment|/* Some fixups generated by GAS which gets resovled before this this          func. is called need to be wriiten to the frag as here we are going          to go away with the relocations fx_done=1.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
block|{
name|maxq_number_to_chars
argument_list|(
name|p
argument_list|,
operator|*
name|valT
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
operator|*
name|valT
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Tables for lexical analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mnemonic_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lexical Macros.  */
end_comment

begin_define
define|#
directive|define
name|is_mnemonic_char
parameter_list|(
name|x
parameter_list|)
value|(mnemonic_chars[(unsigned char)(x)])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char)(x)])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char)(x)])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|(x==' ')
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char)(x)])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char)(x)])
end_define

begin_comment
comment|/* Special characters for operands.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"[]@.-+"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* md_assemble() will always leave the instruction passed to it unaltered.    To do this we store the instruction in a special stack.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
define|\
value|do				\     {				\       *save_stack_p++ = *(s);	\       *s = '\0';		\     }				\   while (0)
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do				\     {				\       *(s) = *(--save_stack_p);	\     }				\   while (0)
end_define

begin_comment
comment|/* The instruction we are assembling.  */
end_comment

begin_decl_stmt
specifier|static
name|maxq20_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current template.  */
end_comment

begin_decl_stmt
specifier|static
name|MAXQ20_OPCODES
modifier|*
name|current_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The displacement operand if any.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current Operand we are working on (0:1st operand,1:2nd operand).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The prefix instruction if used.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|PFX_INSN
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|INSERT_BUFFER
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For interface with expression() ????? */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The HASH Tables:  */
end_comment

begin_comment
comment|/* Operand Hash Table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register Hash Table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Memory reference Hash Table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mem_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|bit_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Memory Access syntax table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mem_syntax_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a mapping from pseudo-op names to functions.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|cons
block|,
literal|2
block|}
block|,
comment|/* size of 'int' has been changed to 1 word 				   (i.e) 16 bits.  */
block|{
literal|"maxq10"
block|,
name|maxq_target
block|,
name|bfd_mach_maxq10
block|}
block|,
block|{
literal|"maxq20"
block|,
name|maxq_target
block|,
name|bfd_mach_maxq20
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_PFX_ARG
parameter_list|(
name|x
parameter_list|)
value|(PFX_INSN[1] = x)
end_define

begin_comment
comment|/* This function sets the PFX value coresponding to the specs. Source    Destination Index Selection ---------------------------------- Write To|    SourceRegRange | Dest Addr Range    ------------------------------------------------------ PFX[0] | 0h-Fh |    0h-7h PFX[1] | 10h-1Fh | 0h-7h PFX[2] | 0h-Fh | 8h-Fh PFX[3] | 10h-1Fh |    8h-Fh PFX[4] | 0h-Fh | 10h-17h PFX[5] | 10h-1Fh | 10h-17h PFX[6] | 0h-Fh |     18h-1Fh PFX[7] | 0h-Fh | 18h-1Fh */
end_comment

begin_function
specifier|static
name|void
name|set_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|short
name|int
name|src_index
init|=
literal|0
decl_stmt|,
name|dst_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|1
condition|)
comment|/* Only SRC is Present */
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
condition|)
block|{
name|dst_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
name|src_index
operator|=
literal|0x00
expr_stmt|;
block|}
else|else
block|{
name|src_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
name|dst_index
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|REG
condition|)
block|{
name|dst_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
name|src_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|REG
operator|&&
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|REG
condition|)
comment|/* DST is Absent */
block|{
name|src_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
name|dst_index
operator|=
literal|0x00
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|!=
name|REG
condition|)
comment|/* Id SRC is Absent */
block|{
name|dst_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|Mod_index
expr_stmt|;
name|src_index
operator|=
literal|0x00
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
condition|)
block|{
name|dst_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|Mod_index
expr_stmt|;
name|src_index
operator|=
literal|0x00
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|BIT
operator|&&
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
condition|)
block|{
name|dst_index
operator|=
literal|0x00
expr_stmt|;
name|src_index
operator|=
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|Mod_index
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_index
operator|>=
literal|0x00
operator|&&
name|src_index
operator|<=
literal|0xF
condition|)
block|{
if|if
condition|(
name|dst_index
operator|>=
literal|0x00
operator|&&
name|dst_index
operator|<=
literal|0x07
condition|)
comment|/* Set PFX[0] */
name|i
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x08
operator|&&
name|dst_index
operator|<=
literal|0x0F
condition|)
comment|/* Set PFX[2] */
name|i
operator|.
name|prefix
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x10
operator|&&
name|dst_index
operator|<=
literal|0x17
condition|)
comment|/* Set PFX[4] */
name|i
operator|.
name|prefix
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x18
operator|&&
name|dst_index
operator|<=
literal|0x1F
condition|)
comment|/* Set PFX[6] */
name|i
operator|.
name|prefix
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_index
operator|>=
literal|0x10
operator|&&
name|src_index
operator|<=
literal|0x1F
condition|)
block|{
if|if
condition|(
name|dst_index
operator|>=
literal|0x00
operator|&&
name|dst_index
operator|<=
literal|0x07
condition|)
comment|/* Set PFX[1] */
name|i
operator|.
name|prefix
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x08
operator|&&
name|dst_index
operator|<=
literal|0x0F
condition|)
comment|/* Set PFX[3] */
name|i
operator|.
name|prefix
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x10
operator|&&
name|dst_index
operator|<=
literal|0x17
condition|)
comment|/* Set PFX[5] */
name|i
operator|.
name|prefix
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|dst_index
operator|>=
literal|0x18
operator|&&
name|dst_index
operator|<=
literal|0x1F
condition|)
comment|/* Set PFX[7] */
name|i
operator|.
name|prefix
operator|=
literal|7
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|is_a_LSinstr
parameter_list|(
specifier|const
name|char
modifier|*
name|ln_pointer
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|LSInstr
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|LSInstr
index|[
name|i
index|]
argument_list|,
name|ln_pointer
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|LS_processing
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|is_a_LSinstr
argument_list|(
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
condition|)
block|{
name|i
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
name|INSERT_BUFFER
index|[
literal|0
index|]
operator|=
name|PFX0
expr_stmt|;
name|i
operator|.
name|Instr_Prefix
operator|=
name|LONG_PREFIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
condition|)
name|i
operator|.
name|Instr_Prefix
operator|=
name|SHORT_PREFIX
expr_stmt|;
else|else
name|i
operator|.
name|Instr_Prefix
operator|=
name|NO_PREFIX
expr_stmt|;
block|}
else|else
name|i
operator|.
name|Instr_Prefix
operator|=
name|LONG_PREFIX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Separate mnemonics and the operands.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_insn
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|mnemonic
parameter_list|)
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
name|char
modifier|*
name|mnem_p
decl_stmt|;
name|char
name|temp
index|[
name|MAX_MNEM_SIZE
index|]
decl_stmt|;
name|int
name|ii
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|temp
argument_list|,
name|END_OF_INSN
argument_list|,
name|MAX_MNEM_SIZE
argument_list|)
expr_stmt|;
name|mnem_p
operator|=
name|mnemonic
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|mnem_p
operator|=
name|mnemonic_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|ii
operator|++
expr_stmt|;
name|mnem_p
operator|++
expr_stmt|;
if|if
condition|(
name|mnem_p
operator|>=
name|mnemonic
operator|+
name|MAX_MNEM_SIZE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %s in mnemonic"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|ii
condition|)
block|{
name|temp
index|[
name|ii
operator|-
literal|1
index|]
operator|=
name|toupper
argument_list|(
operator|(
name|char
operator|)
name|mnemonic
index|[
name|ii
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ii
operator|--
expr_stmt|;
block|}
name|LS_processing
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|Instr_Prefix
operator|!=
literal|0
operator|&&
name|is_a_LSinstr
argument_list|(
name|temp
argument_list|)
condition|)
comment|/* Skip the optional L-S.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|temp
operator|+
literal|1
argument_list|,
name|MAX_MNEM_SIZE
argument_list|)
expr_stmt|;
comment|/* Look up instruction (or prefix) via hash table.  */
name|current_templates
operator|=
operator|(
name|MAXQ20_OPCODES
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_templates
operator|!=
name|NULL
condition|)
return|return
name|l
return|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such instruction: `%s'"
argument_list|)
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function to calculate x to the power of y.    Just to avoid including the math libraries.  */
end_comment

begin_function
specifier|static
name|int
name|pwr
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|k
decl_stmt|,
name|ans
init|=
literal|1
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|y
condition|;
name|k
operator|++
control|)
name|ans
operator|*=
name|x
expr_stmt|;
return|return
name|ans
return|;
block|}
end_function

begin_function
specifier|static
name|reg_entry
modifier|*
name|parse_reg_by_index
parameter_list|(
name|char
modifier|*
name|imm_start
parameter_list|)
block|{
name|int
name|k
init|=
literal|0
decl_stmt|,
name|mid
init|=
literal|0
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|char
name|temp
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|reg_entry
modifier|*
name|reg
init|=
name|NULL
decl_stmt|;
do|do
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
condition|)
name|temp
index|[
name|k
index|]
operator|=
name|imm_start
index|[
name|k
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|&&
operator|(
name|imm_start
index|[
name|k
index|]
operator|=
name|tolower
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|)
operator|<
literal|'g'
condition|)
name|temp
index|[
name|k
index|]
operator|=
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
name|imm_start
index|[
name|k
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'h'
condition|)
break|break;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
name|END_OF_INSN
condition|)
block|{
name|imm_start
index|[
name|k
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
block|}
else|else
return|return
name|NULL
return|;
comment|/* not a hex digit */
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|imm_start
index|[
name|k
index|]
operator|!=
literal|'\n'
condition|)
do|;
switch|switch
condition|(
name|imm_start
index|[
name|k
index|]
condition|)
block|{
case|case
literal|'h'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|16
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|>
literal|9
condition|)
return|return
name|NULL
return|;
comment|/* not a number */
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|10
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get the module and register id's.  */
name|mid
operator|=
name|val
operator|&
literal|0x0f
expr_stmt|;
name|rid
operator|=
operator|(
name|val
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|6
condition|)
block|{
comment|/* Search the pheripheral reg table.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_of_reg
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|new_reg_table
index|[
name|j
index|]
operator|.
name|opcode
operator|==
name|val
condition|)
block|{
name|reg
operator|=
operator|(
name|reg_entry
operator|*
operator|)
operator|&
name|new_reg_table
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Search the system register table.  */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|system_reg_table
index|[
name|j
index|]
operator|.
name|reg_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|system_reg_table
index|[
name|j
index|]
operator|.
name|opcode
operator|==
name|val
condition|)
block|{
name|reg
operator|=
operator|(
name|reg_entry
operator|*
operator|)
operator|&
name|system_reg_table
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register value %s"
argument_list|)
argument_list|,
name|imm_start
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
if|#
directive|if
name|CHANGE_PFX
if|if
condition|(
name|this_operand
operator|==
literal|0
operator|&&
name|reg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|Mod_index
operator|>
literal|7
condition|)
name|i
operator|.
name|prefix
operator|=
literal|2
expr_stmt|;
else|else
name|i
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|reg_entry
operator|*
operator|)
name|reg
return|;
block|}
end_function

begin_comment
comment|/* REG_STRING starts *before* REGISTER_PREFIX.  */
end_comment

begin_function
specifier|static
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|char
modifier|*
name|reg_string
parameter_list|,
name|char
modifier|*
modifier|*
name|end_op
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|reg_entry
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Skip possible REGISTER_PREFIX and possible whitespace.  */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|reg_name_given
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
name|reg_entry
operator|*
operator|)
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|end_op
operator|=
name|s
expr_stmt|;
name|r
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
expr_stmt|;
if|#
directive|if
name|CHANGE_PFX
if|if
condition|(
name|this_operand
operator|==
literal|0
operator|&&
name|r
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|Mod_index
operator|>
literal|7
condition|)
name|i
operator|.
name|prefix
operator|=
literal|2
expr_stmt|;
else|else
name|i
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|reg_bit
modifier|*
name|parse_register_bit
parameter_list|(
name|char
modifier|*
name|reg_string
parameter_list|,
name|char
modifier|*
modifier|*
name|end_op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
name|short
name|k
init|=
literal|0
decl_stmt|;
name|char
name|diff
init|=
literal|0
decl_stmt|;
name|reg_bit
modifier|*
name|rb
init|=
name|NULL
decl_stmt|;
name|reg_entry
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|bit_name
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|char
name|temp_bitname
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|temp
index|[
name|MAX_REG_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|temp
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|MAX_REG_NAME_SIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|temp_bitname
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|MAX_REG_NAME_SIZE
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
name|rb
operator|=
name|NULL
expr_stmt|;
name|rb
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reg_bit
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|reg
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reg_entry
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
comment|/* For supporting bit names.  */
name|b
operator|=
operator|(
name|bit_name
operator|*
operator|)
name|hash_find
argument_list|(
name|bit_hash
argument_list|,
name|reg_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
operator|*
name|end_op
operator|=
name|reg_string
operator|+
name|strlen
argument_list|(
name|reg_string
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_bitname
argument_list|,
name|b
operator|->
name|reg_bit
argument_list|)
expr_stmt|;
name|s
operator|=
name|temp_bitname
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|temp
index|[
name|k
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|temp
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|temp
argument_list|,
name|end_op
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|rb
operator|->
name|reg
operator|=
name|r
expr_stmt|;
comment|/* Skip the "."  */
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|rb
operator|->
name|bit
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
block|{
name|rb
operator|->
name|bit
operator|=
operator|(
name|char
operator|)
operator|*
name|s
operator|-
literal|'a'
expr_stmt|;
name|rb
operator|->
name|bit
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|bit
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid bit number : '%c'"
argument_list|)
argument_list|,
operator|(
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|diff
operator|=
name|strlen
argument_list|(
name|temp_bitname
argument_list|)
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|diff
operator|=
name|strlen
argument_list|(
name|reg_string
argument_list|)
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|+
name|diff
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal character after operand '%s'"
argument_list|)
argument_list|,
name|reg_string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|rb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfx_for_imm_val
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|i
operator|.
name|prefix
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|i
operator|.
name|prefix
operator|==
literal|0
operator|&&
name|arg
operator|==
literal|0
operator|&&
name|PFX_INSN
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|!
operator|(
name|i
operator|.
name|data_operands
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|prefix
operator|<
literal|0
operator|)
operator|&&
operator|!
operator|(
name|i
operator|.
name|prefix
operator|>
literal|7
operator|)
condition|)
name|PFX_INSN
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|.
name|prefix
operator|<<
literal|4
operator|)
operator||
name|PFX0
expr_stmt|;
if|if
condition|(
operator|!
name|PFX_INSN
index|[
literal|1
index|]
condition|)
name|PFX_INSN
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|maxq20_immediate
parameter_list|(
name|char
modifier|*
name|imm_start
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|,
name|val_pfx
init|=
literal|0
decl_stmt|;
name|char
name|sign_val
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|int
name|temp
index|[
literal|4
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|imm_start
operator|++
expr_stmt|;
if|if
condition|(
name|imm_start
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|imm_start
index|[
literal|0
index|]
operator|==
literal|'0'
operator|||
name|imm_start
index|[
literal|0
index|]
operator|==
literal|'1'
operator|)
operator|&&
operator|(
name|this_operand
operator|==
literal|1
operator|&&
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|||
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|FLAG
operator|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|imm_start
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|i
operator|.
name|imm_bit_operands
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|IMMBIT
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
if|#
directive|if
name|CHANGE_PFX
if|if
condition|(
name|i
operator|.
name|prefix
operator|==
literal|2
condition|)
name|pfx_for_imm_val
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* Check For Sign Charcater.  */
name|sign_val
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'-'
operator|&&
name|k
operator|==
literal|0
condition|)
name|sign_val
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'+'
operator|&&
name|k
operator|==
literal|0
condition|)
name|sign_val
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
condition|)
name|temp
index|[
name|k
index|]
operator|=
name|imm_start
index|[
name|k
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|&&
operator|(
name|imm_start
index|[
name|k
index|]
operator|=
name|tolower
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|)
operator|<
literal|'g'
condition|)
name|temp
index|[
name|k
index|]
operator|=
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
name|imm_start
index|[
name|k
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'h'
condition|)
break|break;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'\0'
condition|)
block|{
name|imm_start
index|[
name|k
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Character in immediate Value : %c"
argument_list|)
argument_list|,
name|imm_start
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|imm_start
index|[
name|k
index|]
operator|!=
literal|'\n'
condition|)
do|;
switch|switch
condition|(
name|imm_start
index|[
name|k
index|]
condition|)
block|{
case|case
literal|'h'
case|:
for|for
control|(
name|j
operator|=
operator|(
name|sign_val
condition|?
literal|1
else|:
literal|0
operator|)
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|16
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
for|for
control|(
name|j
operator|=
operator|(
name|sign_val
condition|?
literal|1
else|:
literal|0
operator|)
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|>
literal|9
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Character in immediate value : %c"
argument_list|)
argument_list|,
name|imm_start
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|10
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sign_val
condition|)
name|sign_val
operator|=
literal|1
expr_stmt|;
comment|/* Now over here the value val stores the 8 bit/16 bit value. We will put a       check if we are moving a 16 bit immediate value into an 8 bit register.       In that case we will generate a warning and move only the lower 8 bits */
if|if
condition|(
name|val
operator|>
literal|65535
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value greater than 16 bits"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|=
name|val
operator|*
name|sign_val
expr_stmt|;
comment|/* If it is a stack pointer and the value is greater than the maximum      permissible size */
if|if
condition|(
name|this_operand
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|*
name|sign_val
operator|)
operator|>
name|MAX_STACK
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"SP"
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Attempt to move a value in the stack pointer greater than the size of the stack"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|&
name|MAX_STACK
expr_stmt|;
block|}
comment|/* Check the range for 8 bit registers.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|val
operator|*
name|sign_val
operator|)
operator|>
literal|0xFF
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|)
operator|&&
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_8W
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Attempt to move 16 bit value into an 8 bit register.Truncating..\n"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|&
literal|0xfe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|sign_val
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|val
operator|>
literal|0xFF
operator|)
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|)
operator|&&
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_8W
operator|)
condition|)
block|{
name|val_pfx
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|SET_PFX_ARG
argument_list|(
name|val_pfx
argument_list|)
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|<=
literal|0xff
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|)
operator|&&
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_8W
operator|)
condition|)
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
comment|/* Check for 16 bit registers.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|sign_val
operator|==
operator|-
literal|1
operator|)
operator|||
name|val
operator|>
literal|0xFE
operator|)
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_16W
condition|)
block|{
comment|/* Add PFX for any negative value -> 16bit register.  */
name|val_pfx
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|SET_PFX_ARG
argument_list|(
name|val_pfx
argument_list|)
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|<
literal|0xFF
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_16W
condition|)
block|{
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
comment|/* All the immediate memory access - no PFX.  */
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|(
name|sign_val
operator|==
operator|-
literal|1
operator|)
operator|||
name|val
operator|>
literal|0xFE
condition|)
block|{
name|val_pfx
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|SET_PFX_ARG
argument_list|(
name|val_pfx
argument_list|)
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
else|else
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
comment|/* Special handling for immediate jumps like jump nz, #03h etc.  */
elseif|else
if|if
condition|(
name|val
operator|<
literal|0xFF
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|FLAG
condition|)
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|sign_val
operator|==
operator|-
literal|1
operator|)
operator|||
name|val
operator|>
literal|0xFE
operator|)
operator|)
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|FLAG
condition|)
block|{
name|val_pfx
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|SET_PFX_ARG
argument_list|(
name|val_pfx
argument_list|)
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid immediate move operation"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* All the instruction with operation on ACC: like ADD src, etc.  */
if|if
condition|(
operator|(
name|sign_val
operator|==
operator|-
literal|1
operator|)
operator|||
name|val
operator|>
literal|0xFE
condition|)
block|{
name|val_pfx
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|SET_PFX_ARG
argument_list|(
name|val_pfx
argument_list|)
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
else|else
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
name|i
operator|.
name|imm_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_int_val
parameter_list|(
specifier|const
name|char
modifier|*
name|imm_start
parameter_list|)
block|{
name|int
name|k
decl_stmt|,
name|j
decl_stmt|,
name|val
decl_stmt|;
name|char
name|sign_val
decl_stmt|;
name|int
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|sign_val
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'-'
operator|&&
name|k
operator|==
literal|0
condition|)
name|sign_val
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'+'
operator|&&
name|k
operator|==
literal|0
condition|)
name|sign_val
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
condition|)
name|temp
index|[
name|k
index|]
operator|=
name|imm_start
index|[
name|k
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|&&
operator|(
name|tolower
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|)
operator|<
literal|'g'
condition|)
name|temp
index|[
name|k
index|]
operator|=
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
name|tolower
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tolower
argument_list|(
name|imm_start
index|[
name|k
index|]
argument_list|)
operator|==
literal|'h'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|imm_start
index|[
name|k
index|]
operator|==
literal|']'
operator|)
condition|)
comment|/* imm_start[k]='d'; */
break|break;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Character in immediate Value : %c"
argument_list|)
argument_list|,
name|imm_start
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|imm_start
index|[
name|k
index|]
operator|!=
literal|'\n'
condition|)
do|;
switch|switch
condition|(
name|imm_start
index|[
name|k
index|]
condition|)
block|{
case|case
literal|'h'
case|:
for|for
control|(
name|j
operator|=
operator|(
name|sign_val
condition|?
literal|1
else|:
literal|0
operator|)
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|16
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|j
operator|=
operator|(
name|sign_val
condition|?
literal|1
else|:
literal|0
operator|)
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|>
literal|9
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Character in immediate value : %c"
argument_list|)
argument_list|,
name|imm_start
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|+=
name|temp
index|[
name|j
index|]
operator|*
name|pwr
argument_list|(
literal|10
argument_list|,
name|k
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sign_val
condition|)
name|sign_val
operator|=
literal|1
expr_stmt|;
return|return
name|val
operator|*
name|sign_val
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|check_for_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|line
operator|+
literal|1
operator|)
operator|==
literal|'['
condition|)
block|{
do|do
block|{
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'+'
operator|)
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|line
argument_list|)
condition|)
do|;
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'+'
operator|)
condition|)
name|val
operator|=
name|extract_int_val
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|extract_int_val
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INSERT_BUFFER
index|[
literal|0
index|]
operator|=
literal|0x3E
expr_stmt|;
name|INSERT_BUFFER
index|[
literal|1
index|]
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|mem_access
modifier|*
name|maxq20_mem_access
parameter_list|(
name|char
modifier|*
name|mem_string
parameter_list|,
name|char
modifier|*
modifier|*
name|end_op
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|mem_string
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|mem_name_given
index|[
name|MAX_MEM_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|mem_access
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* Skip possible whitespace.  */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|mem_name_given
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|register_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|mem_name_given
operator|+
name|MAX_MEM_NAME_SIZE
condition|)
return|return
operator|(
name|mem_access
operator|*
operator|)
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|end_op
operator|=
name|s
expr_stmt|;
name|m
operator|=
operator|(
name|mem_access
operator|*
operator|)
name|hash_find
argument_list|(
name|mem_hash
argument_list|,
name|mem_name_given
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function checks whether the operand is a variable in the data segment     and if so, it returns its symbol entry from the symbol table.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|maxq20_data
parameter_list|(
name|char
modifier|*
name|op_string
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|now_seg
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|bfd_und_section_ptr
condition|)
block|{
comment|/* In case we do not want to always include the prefix instruction and          let the loader handle the job or in case of a 8 bit addressing mode,           we will just check for val_pfx to be equal to zero and then load the           prefix instruction. Otherwise no prefix instruction needs to be          loaded.  */
comment|/* The prefix register will have to be loaded automatically as we have  	 a 16 bit addressing field.  */
name|pfx_for_imm_val
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|maxq20_displacement
parameter_list|(
name|char
modifier|*
name|disp_start
parameter_list|,
name|char
modifier|*
name|disp_end
parameter_list|)
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
name|char
modifier|*
name|gotfree_input_line
decl_stmt|;
endif|#
directive|endif
name|gotfree_input_line
operator|=
name|NULL
expr_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|disp_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
comment|/* gotfree_input_line = lex_got (&i.reloc[this_operand], NULL); if      (gotfree_input_line) input_line_pointer = gotfree_input_line; */
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk `%s' after expression"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
if|#
directive|if
name|GCC_ASM_O_HACK
name|RESTORE_END_STRING
argument_list|(
name|disp_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RESTORE_END_STRING
argument_list|(
name|disp_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
ifndef|#
directive|ifndef
name|LEX_AT
if|if
condition|(
name|gotfree_input_line
condition|)
name|free
argument_list|(
name|gotfree_input_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Missing or bad expr becomes absolute 0.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing or invalid displacement expression `%s' taken as 0"
argument_list|)
argument_list|,
name|disp_start
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
operator|&&
name|exp_seg
operator|!=
name|absolute_section
operator|&&
name|exp_seg
operator|!=
name|text_section
operator|&&
name|exp_seg
operator|!=
name|data_section
operator|&&
name|exp_seg
operator|!=
name|bss_section
operator|&&
name|exp_seg
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|exp_seg
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented segment %s in operand"
argument_list|)
argument_list|,
name|exp_seg
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|=
name|exp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse OPERAND_STRING into the maxq20_insn structure I.    Returns non-zero on error.  */
end_comment

begin_function
specifier|static
name|int
name|maxq20_operand
parameter_list|(
name|char
modifier|*
name|operand_string
parameter_list|)
block|{
name|reg_entry
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|reg_bit
modifier|*
name|rb
init|=
name|NULL
decl_stmt|;
name|mem_access
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end_op
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|base_string
init|=
name|NULL
decl_stmt|;
name|int
name|ii
init|=
literal|0
decl_stmt|;
comment|/* Start and end of displacement string expression (if found).  */
name|char
modifier|*
name|displacement_string_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
init|=
name|NULL
decl_stmt|;
comment|/* This maintains the  case sentivness.  */
name|char
name|case_str_op_string
index|[
name|MAX_OPERAND_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|str_op_string
index|[
name|MAX_OPERAND_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|org_case_op_string
init|=
name|case_str_op_string
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|str_op_string
decl_stmt|;
name|memset
argument_list|(
name|op_string
argument_list|,
name|END_OF_INSN
argument_list|,
operator|(
name|MAX_OPERAND_SIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|org_case_op_string
argument_list|,
name|END_OF_INSN
argument_list|,
operator|(
name|MAX_OPERAND_SIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op_string
argument_list|,
name|operand_string
argument_list|,
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|org_case_op_string
argument_list|,
name|operand_string
argument_list|,
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ii
operator|=
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ii
operator|>
name|MAX_OPERAND_SIZE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Size of Operand '%s' greater than %d"
argument_list|)
argument_list|,
name|op_string
argument_list|,
name|MAX_OPERAND_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|ii
condition|)
block|{
name|op_string
index|[
name|ii
operator|-
literal|1
index|]
operator|=
name|toupper
argument_list|(
operator|(
name|char
operator|)
name|op_string
index|[
name|ii
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ii
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
if|if
condition|(
name|isxdigit
argument_list|(
name|operand_string
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Now the operands can start with an Integer.  */
name|r
operator|=
name|parse_reg_by_index
argument_list|(
name|op_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|REG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|reg
operator|=
name|r
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Get the origanal string.  */
name|memcpy
argument_list|(
name|op_string
argument_list|,
name|operand_string
argument_list|,
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ii
operator|=
name|strlen
argument_list|(
name|operand_string
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ii
condition|)
block|{
name|op_string
index|[
name|ii
operator|-
literal|1
index|]
operator|=
name|toupper
argument_list|(
operator|(
name|char
operator|)
name|op_string
index|[
name|ii
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ii
operator|--
expr_stmt|;
block|}
block|}
comment|/* Check for flags.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"Z"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_Z
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"NZ"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_NZ
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"NC"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_NC
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"E"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_E
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"S"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_S
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"C"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_C
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"NE"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|FLAG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|flag
operator|=
name|FLAG_NE
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|flag_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* CHECK FOR REGISTER BIT */
elseif|else
if|if
condition|(
operator|(
name|rb
operator|=
name|parse_register_bit
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|BIT
expr_stmt|;
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|r_bit
operator|=
name|rb
expr_stmt|;
name|i
operator|.
name|bit_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
comment|/* FOR IMMEDITE.  */
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|IMM
expr_stmt|;
if|if
condition|(
operator|!
name|maxq20_immediate
argument_list|(
name|op_string
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal immediate operand '%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
operator|||
operator|!
name|strcmp
argument_list|(
name|op_string
argument_list|,
literal|"NUL"
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* For new requiremnt of copiler of for, @(BP,cons).  */
if|if
condition|(
name|check_for_parse
argument_list|(
name|op_string
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|op_string
argument_list|,
literal|'\0'
argument_list|,
name|strlen
argument_list|(
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op_string
argument_list|,
literal|"@BP[OFFS]\0"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|MEM
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|maxq20_mem_access
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operand for memory access '%s'"
argument_list|)
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|mem
operator|=
name|m
expr_stmt|;
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|,
operator|&
name|end_op
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Check for register.  */
block|{
name|op_string
operator|=
name|end_op
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|REG
expr_stmt|;
comment|/* Set the type.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|reg
operator|=
name|r
expr_stmt|;
comment|/* Set the Register value.  */
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|this_operand
operator|==
literal|1
condition|)
block|{
comment|/* Changed for orginal case of data refrence on 30 Nov 2003.  */
comment|/* The operand can either be a data reference or a symbol reference.  */
if|if
condition|(
operator|(
name|sym
operator|=
name|maxq20_data
argument_list|(
name|org_case_op_string
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Check for data memory.  */
block|{
while|while
condition|(
name|is_space_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
operator|++
name|op_string
expr_stmt|;
comment|/* Set the type of the operand.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|DATA
expr_stmt|;
comment|/* Set the value of the data.  */
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|data
operator|=
name|sym
expr_stmt|;
name|i
operator|.
name|data_operands
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
block|{
comment|/* This is a memory reference of some sort. char *base_string; 	     Start and end of displacement string expression (if found). char  	     *displacement_string_start; char *displacement_string_end.  */
name|base_string
operator|=
name|org_case_op_string
operator|+
name|strlen
argument_list|(
name|org_case_op_string
argument_list|)
expr_stmt|;
operator|--
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|--
name|base_string
expr_stmt|;
comment|/* If we only have a displacement, set-up for it to be parsed 	     later.  */
name|displacement_string_start
operator|=
name|org_case_op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|displacement_string_start
operator|!=
name|displacement_string_end
condition|)
block|{
if|if
condition|(
operator|!
name|maxq20_displacement
argument_list|(
name|displacement_string_start
argument_list|,
name|displacement_string_end
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal displacement operand "
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* A displacement operand found.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|DISP
expr_stmt|;
comment|/* Set the type.  */
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Check for displacement.  */
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
condition|)
block|{
comment|/* This is a memory reference of some sort. char *base_string;          Start and end of displacement string expression (if found). char          *displacement_string_start; char *displacement_string_end;  */
name|base_string
operator|=
name|org_case_op_string
operator|+
name|strlen
argument_list|(
name|org_case_op_string
argument_list|)
expr_stmt|;
operator|--
name|base_string
expr_stmt|;
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
operator|--
name|base_string
expr_stmt|;
comment|/* If we only have a displacement, set-up for it to be parsed later.  */
name|displacement_string_start
operator|=
name|org_case_op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|displacement_string_start
operator|!=
name|displacement_string_end
condition|)
block|{
if|if
condition|(
operator|!
name|maxq20_displacement
argument_list|(
name|displacement_string_start
argument_list|,
name|displacement_string_end
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A displacement operand found.  */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|=
name|DISP
expr_stmt|;
comment|/* Set the type.  */
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse_operand takes as input instruction and operands and Parse operands    and makes entry in the template.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_operands
parameter_list|(
name|char
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|mnemonic
parameter_list|)
block|{
name|char
modifier|*
name|token_start
decl_stmt|;
comment|/* 1 if operand is pending after ','.  */
name|short
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balanced.  */
name|short
name|int
name|paren_not_balanced
decl_stmt|;
name|int
name|operand_ok
decl_stmt|;
comment|/* For Overcoming Warning of unused variable.  */
if|if
condition|(
name|mnemonic
condition|)
name|operand_ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
comment|/* Skip optional white space before operand.  */
if|if
condition|(
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
operator|++
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %c before operand %d"
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unbalanced brackets in operand %d."
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid character %c in operand %d"
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|i
operator|.
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'['
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|']'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* Yes, we've read in another operand.  */
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|)
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now parse operand adding info to 'i' as we go along.  */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|operand_ok
operator|=
name|maxq20_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|l
operator|)
operator|==
name|END_OF_INSN
condition|)
comment|/* Just skip it, if it's \n complain.  */
goto|goto
name|expecting_operand_after_comma
goto|;
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_operands
parameter_list|(
name|int
name|type
parameter_list|,
name|MAX_ARG_TYPE
name|flag_type
parameter_list|,
name|MAX_ARG_TYPE
name|arg_type
parameter_list|,
name|int
name|op_num
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_REG
operator|)
operator|==
name|A_REG
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|IMM
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_IMM
operator|)
operator|==
name|A_IMM
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|IMMBIT
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_BIT_0
operator|)
operator|==
name|A_BIT_0
operator|&&
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|op_num
index|]
operator|.
name|imms
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_BIT_1
operator|)
operator|==
name|A_BIT_1
operator|&&
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|op_num
index|]
operator|.
name|imms
operator|==
literal|1
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_MEM
operator|)
operator|==
name|A_MEM
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|FLAG
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|flag_type
operator|)
operator|==
name|flag_type
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|BIT
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|ACC_BIT
operator|)
operator|==
name|ACC_BIT
operator|&&
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|op_num
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|reg_name
argument_list|,
literal|"ACC"
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|arg_type
operator|&
name|SRC_BIT
operator|)
operator|==
name|SRC_BIT
operator|&&
operator|(
name|op_num
operator|==
literal|1
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|op_num
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arg_type
operator|&
name|DST_BIT
operator|)
operator|==
name|DST_BIT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|DISP
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_DISP
operator|)
operator|==
name|A_DISP
condition|)
return|return
literal|1
return|;
case|case
name|DATA
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_DATA
operator|)
operator|==
name|A_DATA
condition|)
return|return
literal|1
return|;
case|case
name|BIT_BUCKET
case|:
if|if
condition|(
operator|(
name|arg_type
operator|&
name|A_BIT_BUCKET
operator|)
operator|==
name|A_BIT_BUCKET
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_template
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Points to template once we've found it.  */
specifier|const
name|MAXQ20_OPCODE_INFO
modifier|*
name|t
decl_stmt|;
name|char
name|inv_oper
decl_stmt|;
name|inv_oper
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* Must have right number of operands.  */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|op_number
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|op_number
condition|)
break|break;
switch|switch
condition|(
name|i
operator|.
name|operands
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|match_operands
argument_list|(
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|flag
argument_list|,
name|t
operator|->
name|arg
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|inv_oper
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|match_operands
argument_list|(
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|flag
argument_list|,
name|t
operator|->
name|arg
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|inv_oper
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* We found no match.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand %d is invalid for `%s'"
argument_list|)
argument_list|,
name|inv_oper
argument_list|,
name|current_templates
operator|->
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Copy the template we have found.  */
name|i
operator|.
name|op
operator|=
operator|*
name|t
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function filters out the various combinations of operands which are    not allowed for a particular instruction.  */
end_comment

begin_function
specifier|static
name|int
name|match_filters
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Now we have at our disposal the instruction i. We will be using the      following fields i.op.name : This is the mnemonic name. i.types[2] :      These are the types of the operands (REG/IMM/DISP/MEM/BIT/FLAG/IMMBIT)      i.maxq20_op[2] : This contains the specific info of the operands.  */
comment|/* Our first filter : NO ALU OPERATIONS CAN HAVE THE ACTIVE ACCUMULATOR AS      SOURCE.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"AND"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"OR"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"XOR"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"ADD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"ADDC"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"SUB"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"SUBB"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|Mod_name
operator|==
literal|0xa
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The Accumulator cannot be used as a source in ALU instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"MOVE"
argument_list|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|||
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|MEM
operator|)
operator|&&
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
name|mem_access_syntax
modifier|*
name|mem_op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
condition|)
block|{
name|mem_op
operator|=
operator|(
name|mem_access_syntax
operator|*
operator|)
name|hash_find
argument_list|(
name|mem_syntax_hash
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mem_op
operator|->
name|type
operator|==
name|SRC
operator|)
operator|&&
name|mem_op
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' operand cant be used as destination in %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mem_op
operator|->
name|invalid_op
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|MEM
operator|)
operator|&&
name|mem_op
condition|)
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|5
operator|||
operator|!
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Instruction '%s' operand cant be used with %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|MEM
condition|)
block|{
name|mem_op
operator|=
name|NULL
expr_stmt|;
name|mem_op
operator|=
operator|(
name|mem_access_syntax
operator|*
operator|)
name|hash_find
argument_list|(
name|mem_syntax_hash
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_op
operator|->
name|type
operator|==
name|DST
operator|&&
name|mem_op
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' operand cant be used as source in %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|mem_op
operator|->
name|invalid_op
operator|!=
name|NULL
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|&&
name|mem_op
condition|)
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|5
operator|||
operator|!
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mem_op
operator|->
name|invalid_op
index|[
name|k
index|]
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Instruction '%s' operand cant be used with %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"OFFS"
argument_list|)
operator|&&
name|mem_op
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mem_op
operator|->
name|name
argument_list|,
literal|"@BP[OFFS--]"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mem_op
operator|->
name|name
argument_list|,
literal|"@BP[OFFS++]"
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Instruction '%s' operand cant be used with %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/* Added for SRC and DST in one operand instructioni i.e OR @--DP[1] added      on 10-March-2004.  */
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|i
operator|.
name|operands
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
operator|)
condition|)
block|{
name|mem_access_syntax
modifier|*
name|mem_op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
condition|)
block|{
name|mem_op
operator|=
operator|(
name|mem_access_syntax
operator|*
operator|)
name|hash_find
argument_list|(
name|mem_syntax_hash
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_op
operator|->
name|type
operator|==
name|DST
operator|&&
name|mem_op
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' operand cant be used as source in %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|2
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|IMM
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' instruction cant have first operand as Immediate vale"
argument_list|)
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Our second filter : SP or @SP-- cannot be used with PUSH or POP */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"PUSH"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"SP"
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"SP cannot be used with %s\n"
argument_list|)
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|&&
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"@SP--"
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"@SP-- cannot be used with PUSH\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* This filter checks that two memory references using DP's cannot be used      together in an instruction */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"MOVE"
argument_list|)
operator|&&
name|i
operator|.
name|mem_operands
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
operator|!=
literal|6
operator|||
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"@DP"
argument_list|,
literal|3
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"@DP"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operands either contradictory or use the data bus in read/write state together"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"@SP"
argument_list|,
literal|3
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"@SP"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operands either contradictory or use the data bus in read/write state together"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|mem
operator|->
name|name
argument_list|,
literal|"NUL"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MOVE Cant Use NUL as SRC"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* This filter checks that contradictory movement between DP register and      Memory access using DP followed by increment or decrement.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"MOVE"
argument_list|)
operator|&&
name|i
operator|.
name|mem_operands
operator|==
literal|1
operator|&&
name|i
operator|.
name|reg_operands
operator|==
literal|1
condition|)
block|{
name|int
name|memnum
decl_stmt|,
name|regnum
decl_stmt|;
name|memnum
operator|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|regnum
operator|=
operator|(
name|memnum
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"DP"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|memnum
index|]
operator|.
name|mem
operator|->
name|name
operator|)
operator|+
literal|1
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|5
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|memnum
index|]
operator|.
name|mem
operator|->
name|name
operator|)
operator|+
literal|1
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Contradictory movement between DP register and memory access using DP"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"SP"
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|memnum
index|]
operator|.
name|mem
operator|->
name|name
operator|)
operator|+
literal|1
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"SP and @SP-- cannot be used together in a move instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* This filter restricts the instructions containing source and destination       bits to only CTRL module of the serial registers. Peripheral registers      yet to be defined.  */
if|if
condition|(
name|i
operator|.
name|bit_operands
operator|==
literal|1
operator|&&
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
name|int
name|bitnum
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|reg_name
argument_list|,
literal|"ACC"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|Mod_name
operator|>=
literal|0x7
operator|&&
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|Mod_name
operator|!=
name|CTRL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Only Module 8 system registers allowed in this operation"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* This filter is for checking the register bits.  */
if|if
condition|(
name|i
operator|.
name|bit_operands
operator|==
literal|1
operator|||
name|i
operator|.
name|operands
operator|==
literal|2
condition|)
block|{
name|int
name|bitnum
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|bitnum
operator|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|bit_operands
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|rtype
condition|)
block|{
case|case
name|Reg_8W
case|:
name|size
operator|=
literal|7
expr_stmt|;
comment|/* 8 bit register, both read and write.  */
break|break;
case|case
name|Reg_16W
case|:
name|size
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|Reg_8R
case|:
name|size
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|bitnum
operator|==
literal|0
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Read only Register used as destination"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|Reg_16R
case|:
name|size
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|bitnum
operator|==
literal|0
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Read only Register used as destination"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
if|if
condition|(
name|size
operator|<
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bit No '%d'exceeds register size in this operation"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|bitnum
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|bit_operands
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|reg
operator|->
name|rtype
condition|)
block|{
case|case
name|Reg_8W
case|:
name|size
operator|=
literal|7
expr_stmt|;
comment|/* 8 bit register, both read and write.  */
break|break;
case|case
name|Reg_16W
case|:
name|size
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|Reg_8R
case|:
case|case
name|Reg_16R
case|:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Read only Register used as destination"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|size
operator|<
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bit No '%d' exceeds register size in this operation"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|reg
operator|->
name|rtype
condition|)
block|{
case|case
name|Reg_8R
case|:
case|case
name|Reg_8W
case|:
name|size
operator|=
literal|7
expr_stmt|;
comment|/* 8 bit register, both read and write.  */
break|break;
case|case
name|Reg_16R
case|:
case|case
name|Reg_16W
case|:
name|size
operator|=
literal|15
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|<
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bit No '%d' exceeds register size in this operation"
argument_list|)
argument_list|,
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* No branch operations should occur into the data memory. Hence any memory       references have to be filtered out when used with instructions like      jump, djnz[] and call.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"JUMP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"CALL"
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"DJNZ"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Memory References cannot be used with branching operations\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"DJNZ"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[0]"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[1]"
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DJNZ uses only LC[n] register \n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* No destination register used should be read only!  */
if|if
condition|(
operator|(
name|i
operator|.
name|operands
operator|==
literal|2
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
condition|)
block|{
comment|/* The destination is a register */
name|int
name|regnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
condition|)
block|{
name|regnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|regnum
index|]
operator|==
name|MEM
condition|)
block|{
name|mem_access_syntax
modifier|*
name|mem_op
init|=
name|NULL
decl_stmt|;
name|mem_op
operator|=
operator|(
name|mem_access_syntax
operator|*
operator|)
name|hash_find
argument_list|(
name|mem_syntax_hash
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|mem
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_op
operator|->
name|type
operator|==
name|SRC
operator|&&
name|mem_op
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'%s' operand cant be used as destination  in %s"
argument_list|)
argument_list|,
name|mem_op
operator|->
name|name
argument_list|,
name|i
operator|.
name|op
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_8R
operator|||
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_16R
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Read only register used for writing purposes '%s'"
argument_list|)
argument_list|,
name|i
operator|.
name|maxq20_op
index|[
name|regnum
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* While moving the address of a data in the data section, the destination      should be either data pointers only.  */
if|if
condition|(
operator|(
name|i
operator|.
name|data_operands
operator|)
operator|&&
operator|(
name|i
operator|.
name|operands
operator|==
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|REG
operator|)
operator|&&
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|MEM
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid destination for this kind of source."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|rtype
operator|==
name|Reg_8W
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register as destination for this kind of source.Only data pointers can be used."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_insn
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Check for the format Bit if defined.  */
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|format
operator|==
literal|0
operator|||
name|i
operator|.
name|op
operator|.
name|format
operator|==
literal|1
condition|)
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|op
operator|.
name|format
operator|<<
literal|7
expr_stmt|;
else|else
block|{
comment|/* Format bit not defined. We will have to be find it out ourselves.  */
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
literal|1
operator|||
name|i
operator|.
name|data_operands
operator|==
literal|1
operator|||
name|i
operator|.
name|disp_operands
operator|==
literal|1
condition|)
name|i
operator|.
name|op
operator|.
name|format
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|.
name|op
operator|.
name|format
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator|=
name|i
operator|.
name|op
operator|.
name|format
operator|<<
literal|7
expr_stmt|;
block|}
comment|/* Now for the destination register.  */
comment|/* If destination register is already defined . The conditions are the      following: (1) The second entry in the destination array should be 0 (2)       If there are two operands then the first entry should not be a register,      memory or a register bit (3) If there are less than two operands and the      it is not a pop operation (4) The second argument is the carry      flag(applicable to move Acc.<b>,C.  */
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|REG
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|MEM
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|!=
name|BIT
operator|&&
name|i
operator|.
name|operands
operator|==
literal|2
operator|)
operator|||
operator|(
name|i
operator|.
name|operands
operator|<
literal|2
operator|&&
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
operator|)
operator|||
operator|(
name|i
operator|.
name|op
operator|.
name|arg
index|[
literal|1
index|]
operator|==
name|FLAG_C
operator|)
operator|)
condition|)
block|{
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"DJNZ"
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[0]"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[1]"
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[0]"
argument_list|)
condition|)
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
literal|0x4D
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|->
name|reg_name
argument_list|,
literal|"LC[1]"
argument_list|)
condition|)
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
literal|0x5D
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|temp
decl_stmt|;
comment|/* Target register will have to be specified.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|REG
operator|&&
operator|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|==
name|REG
operator|||
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|==
operator|(
name|REG
operator||
name|MEM
operator|)
operator|)
condition|)
block|{
name|temp
operator|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|->
name|opcode
expr_stmt|;
name|temp
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|MEM
operator|&&
operator|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|==
operator|(
name|REG
operator||
name|MEM
operator|)
operator|)
condition|)
block|{
name|temp
operator|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|mem
operator|)
operator|->
name|opcode
expr_stmt|;
name|temp
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
operator|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|==
name|REG
operator|)
condition|)
block|{
name|temp
operator|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|reg
operator|->
name|opcode
expr_stmt|;
name|temp
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|BIT
operator|&&
operator|(
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|0
index|]
operator|==
name|BIT
operator|)
condition|)
block|{
name|temp
operator|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
expr_stmt|;
name|temp
operator|=
name|temp
operator|<<
literal|4
expr_stmt|;
name|temp
operator||=
name|i
operator|.
name|op
operator|.
name|dst
index|[
literal|1
index|]
expr_stmt|;
name|temp
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|0
index|]
operator||=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Now for the source register.  */
comment|/* If Source register is already known. The following conditions are      checked: (1) There are no operands (2) If there is only one operand and      it is a flag (3) If the operation is MOVE C,#0/#1 (4) If it is a POP      operation.  */
if|if
condition|(
name|i
operator|.
name|operands
operator|==
literal|0
operator|||
operator|(
name|i
operator|.
name|operands
operator|==
literal|1
operator|&&
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|FLAG
operator|)
operator|||
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|FLAG
operator|&&
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|IMMBIT
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|i
operator|.
name|op
operator|.
name|name
argument_list|,
literal|"POPI"
argument_list|)
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
literal|1
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|IMM
operator|)
operator|==
name|IMM
operator|)
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|imms
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|==
name|REG
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|REG
operator|)
operator|==
name|REG
operator|)
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|reg
operator|)
operator|->
name|opcode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|==
name|BIT
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|REG
operator|)
operator|==
name|REG
operator|)
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|r_bit
operator|->
name|reg
operator|->
name|opcode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|MEM
operator|)
operator|==
name|MEM
operator|)
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|mem
operator|)
operator|->
name|opcode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator|==
name|DATA
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|DATA
operator|)
operator|==
name|DATA
operator|)
condition|)
comment|/* This will copy only the lower order bytes into the instruction. The        higher order bytes have already been copied into the prefix register.  */
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Decoding the source in the case when the second array entry is not 0.      This means that the source register has been divided into two nibbles.  */
elseif|else
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* If the first operand is a accumulator bit then 	 the first 4 bits will be filled with the bit number.  */
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|BIT
operator|)
operator|==
name|BIT
operator|)
condition|)
block|{
name|unsigned
name|char
name|temp
init|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
decl_stmt|;
name|temp
operator|=
name|temp
operator|<<
literal|4
expr_stmt|;
name|temp
operator||=
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* In case of MOVE dst.<b>,#1 The first nibble in the source register          has to start with a zero. This is called a ZEROBIT */
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|ZEROBIT
operator|)
operator|==
name|ZEROBIT
operator|)
condition|)
block|{
name|char
name|temp
init|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
decl_stmt|;
name|temp
operator|=
name|temp
operator|<<
literal|4
expr_stmt|;
name|temp
operator||=
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
expr_stmt|;
name|temp
operator|&=
literal|0x7f
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Similarly for a ONEBIT */
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
operator|(
operator|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|&
name|ONEBIT
operator|)
operator|==
name|ONEBIT
operator|)
condition|)
block|{
name|char
name|temp
init|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|0
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
decl_stmt|;
name|temp
operator|=
name|temp
operator|<<
literal|4
expr_stmt|;
name|temp
operator||=
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
expr_stmt|;
name|temp
operator||=
literal|0x80
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* In case the second operand is a register bit (MOVE C,Acc.<b> or MOVE           C,src.<b> */
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|BIT
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
operator|==
name|REG
condition|)
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|reg
operator|->
name|opcode
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|0
index|]
operator|==
name|BIT
operator|&&
name|i
operator|.
name|op
operator|.
name|src
condition|)
block|{
name|char
name|temp
init|=
operator|(
name|i
operator|.
name|maxq20_op
index|[
literal|1
index|]
operator|.
name|r_bit
operator|)
operator|->
name|bit
decl_stmt|;
name|temp
operator|=
name|temp
operator|<<
literal|4
expr_stmt|;
name|temp
operator||=
name|i
operator|.
name|op
operator|.
name|src
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid Instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is a function for outputting displacement operands.  */
end_comment

begin_function
specifier|static
name|void
name|output_disp
parameter_list|(
name|fragS
modifier|*
name|insn_start_frag
parameter_list|,
name|offsetT
name|insn_start_off
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|insn_start_frag
operator|=
name|frag_now
expr_stmt|;
name|insn_start_off
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|Instr_Prefix
condition|)
block|{
case|case
name|LONG_PREFIX
case|:
name|subtype
operator|=
name|EXPLICT_LONG_PREFIX
expr_stmt|;
break|break;
case|case
name|SHORT_PREFIX
case|:
name|subtype
operator|=
name|SHORT_PREFIX
expr_stmt|;
break|break;
default|default:
name|subtype
operator|=
name|NO_PREFIX
expr_stmt|;
break|break;
block|}
comment|/* Its a symbol. Here we end the frag and start the relaxation. Now in our      case there is no need for relaxation. But we do need support for a      prefix operator. Hence we will check whethere is room for 4 bytes ( 2      for prefix + 2 for the current instruction ) Hence if at a particular      time we find out whether the prefix operator is reqd , we shift the      current instruction two places ahead and insert the prefix instruction.  */
name|frag_grow
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sym
operator|=
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|sym
operator|&&
name|frag_now
operator|&&
operator|(
name|subtype
operator|!=
name|EXPLICT_LONG_PREFIX
operator|)
condition|)
block|{
comment|/* If in the same frag.  */
if|if
condition|(
name|frag_now
operator|==
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|diff
operator|=
operator|(
operator|(
operator|(
operator|(
name|expressionS
operator|*
operator|)
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|)
operator|->
name|X_add_number
operator|)
operator|-
name|insn_start_off
operator|)
expr_stmt|;
comment|/* PC points to the next instruction.  */
name|diff
operator|=
operator|(
name|diff
operator|/
name|MAXQ_OCTETS_PER_BYTE
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
operator|-
literal|128
operator|&&
name|diff
operator|<=
literal|127
condition|)
block|{
name|i
operator|.
name|instr
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|diff
expr_stmt|;
comment|/* This will be overwritten later when the symbol is resolved.  */
operator|*
name|p
operator|=
name|i
operator|.
name|instr
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|i
operator|.
name|instr
index|[
literal|0
index|]
expr_stmt|;
comment|/* No Need to create a FIXUP.  */
return|return;
block|}
block|}
block|}
comment|/* This will be overwritten later when the symbol is resolved.  */
operator|*
name|p
operator|=
name|i
operator|.
name|instr
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|i
operator|.
name|instr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
comment|/* Handle complex expressions.  */
name|sym
operator|=
name|make_expr_symbol
argument_list|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Vineet : This has been added for md_estimate_size_before_relax to      estimate the correct size.  */
if|if
condition|(
name|subtype
operator|!=
name|SHORT_PREFIX
condition|)
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
operator|=
name|LONG_PREFIX
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|2
argument_list|,
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|subtype
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a function for outputting displacement operands.  */
end_comment

begin_function
specifier|static
name|void
name|output_data
parameter_list|(
name|fragS
modifier|*
name|insn_start_frag
parameter_list|,
name|offsetT
name|insn_start_off
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|insn_start_frag
operator|=
name|frag_now
expr_stmt|;
name|insn_start_off
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|subtype
operator|=
name|EXPLICT_LONG_PREFIX
expr_stmt|;
name|frag_grow
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sym
operator|=
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|data
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
comment|/* This will be overwritten later when the symbol is resolved.  */
operator|*
name|p
operator|=
name|i
operator|.
name|instr
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|i
operator|.
name|instr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|i
operator|.
name|maxq20_op
index|[
name|this_operand
index|]
operator|.
name|disps
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
comment|/* Handle complex expressions.  */
comment|/* Because data is already in terms of symbol so no        need to convert it from expression to symbol.  */
name|off
operator|=
literal|0
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|2
argument_list|,
name|i
operator|.
name|reloc
index|[
name|this_operand
index|]
argument_list|,
name|subtype
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|fragS
modifier|*
name|insn_start_frag
decl_stmt|;
name|offsetT
name|insn_start_off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Tie dwarf2 debug info to the address at the start of the insn. We can't      do this after the insn has been output as the current frag may have been       closed off.  eg. by frag_var.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* To ALign the text section on word.  */
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We initialise the frags for this particular instruction.  */
name|insn_start_frag
operator|=
name|frag_now
expr_stmt|;
name|insn_start_off
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* If there are displacement operators(unresolved) present, then handle      them separately.  */
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
name|output_disp
argument_list|(
name|insn_start_frag
argument_list|,
name|insn_start_off
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|data_operands
condition|)
block|{
name|output_data
argument_list|(
name|insn_start_frag
argument_list|,
name|insn_start_off
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check whether the INSERT_BUFFER has to be written.  */
if|if
condition|(
name|strcmp
argument_list|(
name|INSERT_BUFFER
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|INSERT_BUFFER
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|INSERT_BUFFER
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Check whether the prefix instruction has to be written.  */
if|if
condition|(
name|strcmp
argument_list|(
name|PFX_INSN
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PFX_INSN
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|PFX_INSN
index|[
literal|0
index|]
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* For Little endian.  */
operator|*
name|p
operator|++
operator|=
name|i
operator|.
name|instr
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|=
name|i
operator|.
name|instr
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_new_reg_table
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|size_pm
init|=
sizeof|sizeof
argument_list|(
name|peripheral_reg_table
argument_list|)
decl_stmt|;
name|num_of_reg
operator|=
name|ARRAY_SIZE
argument_list|(
name|peripheral_reg_table
argument_list|)
expr_stmt|;
name|new_reg_table
operator|=
name|xmalloc
argument_list|(
name|size_pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_reg_table
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cannot allocate memory"
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_reg_table
argument_list|,
name|peripheral_reg_table
argument_list|,
name|size_pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pmmain performs the initilizations for the pheripheral modules. */
end_comment

begin_function
specifier|static
name|void
name|pmmain
parameter_list|(
name|void
parameter_list|)
block|{
name|make_new_reg_table
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hash_err
init|=
name|NULL
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|MAXQ20_OPCODE_INFO
modifier|*
name|optab
decl_stmt|;
name|MAXQ20_OPCODES
modifier|*
name|core_optab
decl_stmt|;
comment|/* For opcodes of the same name. This will 				   be inserted into the hash table.  */
name|struct
name|reg
modifier|*
name|reg_tab
decl_stmt|;
name|struct
name|mem_access_syntax
specifier|const
modifier|*
name|memsyntab
decl_stmt|;
name|struct
name|mem_access
modifier|*
name|memtab
decl_stmt|;
name|struct
name|bit_name
modifier|*
name|bittab
decl_stmt|;
comment|/* Initilize pherioipheral modules.  */
name|pmmain
argument_list|()
expr_stmt|;
comment|/* Initialise the opcode hash table.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|optab
operator|=
name|op_table
expr_stmt|;
comment|/* Initialise it to the first entry of the 				   maxq20 operand table.  */
comment|/* Setup for loop.  */
name|core_optab
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MAXQ20_OPCODES
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|optab
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* different name --> ship out current template list; add to hash 	     table;& begin anew.  */
name|core_optab
operator|->
name|end
operator|=
name|optab
expr_stmt|;
ifdef|#
directive|ifdef
name|MAXQ10S
if|if
condition|(
name|max_version
operator|==
name|bfd_mach_maxq10
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|arch
operator|==
name|MAXQ10
operator|)
operator|||
operator|(
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|arch
operator|==
name|MAX
operator|)
condition|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|core_optab
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|max_version
operator|==
name|bfd_mach_maxq20
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|arch
operator|==
name|MAXQ20
operator|)
operator|||
operator|(
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|arch
operator|==
name|MAX
operator|)
condition|)
block|{
endif|#
directive|endif
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAXQ10S
block|}
block|}
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error: Illegal Architecure specified"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
operator|(
name|optab
operator|-
literal|1
operator|)
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
name|core_optab
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MAXQ20_OPCODES
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
name|optab
expr_stmt|;
block|}
block|}
comment|/* Initialise a new register table.  */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|reg_tab
operator|=
name|system_reg_table
init|;
name|reg_tab
operator|<
operator|(
name|system_reg_table
operator|+
name|ARRAY_SIZE
argument_list|(
name|system_reg_table
argument_list|)
operator|)
condition|;
name|reg_tab
operator|++
control|)
block|{
if|#
directive|if
name|MAXQ10S
switch|switch
condition|(
name|max_version
condition|)
block|{
case|case
name|bfd_mach_maxq10
case|:
if|if
condition|(
operator|(
name|reg_tab
operator|->
name|arch
operator|==
name|MAXQ10
operator|)
operator|||
operator|(
name|reg_tab
operator|->
name|arch
operator|==
name|MAX
operator|)
condition|)
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|reg_tab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|reg_tab
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_mach_maxq20
case|:
if|if
condition|(
operator|(
name|reg_tab
operator|->
name|arch
operator|==
name|MAXQ20
operator|)
operator|||
operator|(
name|reg_tab
operator|->
name|arch
operator|==
name|MAX
operator|)
condition|)
block|{
endif|#
directive|endif
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|reg_tab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|reg_tab
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAXQ10S
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error : Can't Hash %s : %s"
argument_list|)
argument_list|,
name|reg_tab
operator|->
name|reg_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
comment|/* Pheripheral Registers Entry.  */
for|for
control|(
name|reg_tab
operator|=
name|new_reg_table
init|;
name|reg_tab
operator|<
operator|(
name|new_reg_table
operator|+
name|num_of_reg
operator|-
literal|1
operator|)
condition|;
name|reg_tab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|reg_tab
operator|->
name|reg_name
argument_list|,
operator|(
name|PTR
operator|)
name|reg_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error : Can't Hash %s : %s"
argument_list|)
argument_list|,
name|reg_tab
operator|->
name|reg_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise a new memory operand table.  */
name|mem_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|memtab
operator|=
name|mem_table
init|;
name|memtab
operator|<
name|mem_table
operator|+
name|ARRAY_SIZE
argument_list|(
name|mem_table
argument_list|)
condition|;
name|memtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|mem_hash
argument_list|,
name|memtab
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|memtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error : Can't Hash %s : %s"
argument_list|)
argument_list|,
name|memtab
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|bit_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|bittab
operator|=
name|bit_table
init|;
name|bittab
operator|<
name|bit_table
operator|+
name|ARRAY_SIZE
argument_list|(
name|bit_table
argument_list|)
condition|;
name|bittab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|bit_hash
argument_list|,
name|bittab
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|bittab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error : Can't Hash %s : %s"
argument_list|)
argument_list|,
name|bittab
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|mem_syntax_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|memsyntab
operator|=
name|mem_access_syntax_table
init|;
name|memsyntab
operator|<
name|mem_access_syntax_table
operator|+
name|ARRAY_SIZE
argument_list|(
name|mem_access_syntax_table
argument_list|)
condition|;
name|memsyntab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|mem_syntax_hash
argument_list|,
name|memsyntab
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|memsyntab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error : Can't Hash %s : %s"
argument_list|)
argument_list|,
name|memsyntab
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise the lexical tables,mnemonic chars,operand chars.  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mnemonic_chars
index|[
name|c
index|]
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|128
condition|)
block|{
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* All the special characters.  */
name|register_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
name|register_chars
index|[
literal|'+'
index|]
operator|=
literal|'+'
expr_stmt|;
name|register_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|digit_chars
index|[
literal|'-'
index|]
operator|=
literal|'-'
expr_stmt|;
name|identifier_chars
index|[
literal|'_'
index|]
operator|=
literal|'_'
expr_stmt|;
name|identifier_chars
index|[
literal|'.'
index|]
operator|=
literal|'.'
expr_stmt|;
name|register_chars
index|[
literal|'['
index|]
operator|=
literal|'['
expr_stmt|;
name|register_chars
index|[
literal|']'
index|]
operator|=
literal|']'
expr_stmt|;
name|operand_chars
index|[
literal|'_'
index|]
operator|=
literal|'_'
expr_stmt|;
name|operand_chars
index|[
literal|'#'
index|]
operator|=
literal|'#'
expr_stmt|;
name|mnemonic_chars
index|[
literal|'['
index|]
operator|=
literal|'['
expr_stmt|;
name|mnemonic_chars
index|[
literal|']'
index|]
operator|=
literal|']'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
expr_stmt|;
comment|/* Set the maxq arch type.  */
name|maxq_target
argument_list|(
name|max_version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_assemble - Parse Instr - Seprate menmonics and operands - lookup the    menmunonic in the operand table - Parse operands and populate the    structure/template - Match the operand with opcode and its validity -    Output Instr.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|char
name|mnemonic
index|[
name|MAX_MNEM_SIZE
index|]
decl_stmt|;
name|char
name|temp4prev
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|char
name|prev_insn
index|[
literal|256
index|]
decl_stmt|;
comment|/* Initialize globals.  */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_OPERANDS
condition|;
name|j
operator|++
control|)
name|i
operator|.
name|reloc
index|[
name|j
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|i
operator|.
name|prefix
operator|=
operator|-
literal|1
expr_stmt|;
name|PFX_INSN
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|PFX_INSN
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|INSERT_BUFFER
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|INSERT_BUFFER
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|temp4prev
argument_list|,
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|parse_insn
argument_list|(
name|line
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|parse_operands
argument_list|(
name|line
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
comment|/* Next, we find a template that matches the given insn, making sure the      overlap of the given operands types is consistent with the template      operand types.  */
if|if
condition|(
operator|!
name|match_template
argument_list|()
condition|)
return|return;
comment|/* In the MAXQ20, there are certain register combinations, and other      restrictions which are not allowed. We will try to resolve these right      now.  */
if|if
condition|(
operator|!
name|match_filters
argument_list|()
condition|)
return|return;
comment|/* Check for the approprate PFX register.  */
name|set_prefix
argument_list|()
expr_stmt|;
name|pfx_for_imm_val
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decode_insn
argument_list|()
condition|)
comment|/* decode insn. */
name|need_pass_2
operator|=
literal|1
expr_stmt|;
comment|/* Check for Exlipct PFX instruction.  */
if|if
condition|(
name|PFX_INSN
index|[
literal|0
index|]
operator|&&
operator|(
name|strstr
argument_list|(
name|prev_insn
argument_list|,
literal|"PFX"
argument_list|)
operator|||
name|strstr
argument_list|(
name|prev_insn
argument_list|,
literal|"pfx"
argument_list|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Ineffective insntruction %s \n"
argument_list|)
argument_list|,
name|prev_insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prev_insn
argument_list|,
name|temp4prev
argument_list|,
name|strlen
argument_list|(
name|temp4prev
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* We are ready to output the insn.  */
name|output_insn
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

