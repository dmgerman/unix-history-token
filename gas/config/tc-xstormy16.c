begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-xstormy16.c -- Assembler for the Sanyo XSTORMY16.    Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/xstormy16-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/xstormy16-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|xstormy16_insn
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|O_fptr_symbol
value|(O_max + 1)
end_define

begin_escape
end_escape

begin_define
define|#
directive|define
name|XSTORMY16_SHORTOPTS
value|""
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|XSTORMY16_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" XSTORMY16 specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|xstormy16_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_LITTLE
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|xstormy16_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_boolean
name|skipping_fptr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|xstormy16_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Make sure that if we had an erroneous input line which triggered      the skipping_fptr boolean that it does not affect following lines.  */
name|skipping_fptr
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|xstormy16_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'@'
condition|)
return|return;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|,
literal|"fptr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected '('"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing ')'"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
name|as_bad
argument_list|(
literal|"Not a symbolic expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
comment|/* We are computing the difference of two function pointers 	   like this:  	    .hword  @fptr (foo) - @fptr (bar)  	  In this situation we do not want to generate O_fptr_symbol 	  operands because the result is an absolute value, not a 	  function pointer.  	  We need to make the check here, rather than when the fixup 	  is generated as the function names (foo& bar in the above 	  example) might be local symbols and we want the expression 	  to be evaluated now.  This kind of thing can happen when 	  gcc is generating computed gotos.  */
name|skipping_fptr
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|skipping_fptr
condition|)
name|skipping_fptr
operator|=
name|FALSE
expr_stmt|;
else|else
name|e
operator|->
name|X_op
operator|=
name|O_fptr_symbol
expr_stmt|;
block|}
return|return;
name|err
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called while parsing data to create a fixup.    Create BFD_RELOC_XSTORMY16_FPTR16 relocations.  */
end_comment

begin_function
name|void
name|xstormy16_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|f
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_fptr_symbol
condition|)
block|{
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|4
case|:
comment|/* This can happen when gcc is generating debug output.  	     For example it can create a stab with the address of  	     a function:  	       	     	.stabs	"foo:F(0,21)",36,0,0,@fptr(foo)    	     Since this does not involve switching code pages, we  	     just allow the reloc to be generated without any  	     @fptr behaviour.  */
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|code
operator|=
name|BFD_RELOC_XSTORMY16_FPTR16
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unsupported fptr fixup size %d"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|1
condition|)
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"unsupported fixup size %d"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return;
block|}
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|f
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called while parsing an instruction to create a fixup.    Create BFD_RELOC_XSTORMY16_FPTR16 relocations.  */
end_comment

begin_function
name|fixS
modifier|*
name|xstormy16_cgen_record_fixup_exp
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|int
name|opinfo
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|operatorT
name|op
init|=
name|exp
operator|->
name|X_op
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|O_fptr_symbol
condition|)
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|fixP
operator|=
name|gas_cgen_record_fixup_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|opinfo
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_fptr_symbol
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|type
operator|!=
name|XSTORMY16_OPERAND_IMM16
condition|)
name|as_bad
argument_list|(
literal|"unsupported fptr fixup"
argument_list|)
expr_stmt|;
else|else
block|{
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_XSTORMY16_FPTR16
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|fixP
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* No assembler relaxation is defined (or necessary) for this port.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* No assembler relaxation is defined (or necessary) for this port.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
operator|||
name|xstormy16_force_relocation
argument_list|(
name|fixP
argument_list|)
condition|)
comment|/* The symbol is undefined,        or it is defined but not in this section,        or the relocation will be relative to this symbol not the section symbol.	         Let the linker figure it out.  */
return|return
literal|0
return|;
return|return
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|XSTORMY16_OPERAND_IMM2
case|:
case|case
name|XSTORMY16_OPERAND_IMM3
case|:
case|case
name|XSTORMY16_OPERAND_IMM3B
case|:
case|case
name|XSTORMY16_OPERAND_IMM4
case|:
case|case
name|XSTORMY16_OPERAND_HMEM8
case|:
return|return
name|BFD_RELOC_NONE
return|;
case|case
name|XSTORMY16_OPERAND_IMM12
case|:
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
return|return
name|BFD_RELOC_XSTORMY16_12
return|;
case|case
name|XSTORMY16_OPERAND_IMM8
case|:
case|case
name|XSTORMY16_OPERAND_LMEM8
case|:
return|return
name|fixP
operator|->
name|fx_pcrel
condition|?
name|BFD_RELOC_8_PCREL
else|:
name|BFD_RELOC_8
return|;
case|case
name|XSTORMY16_OPERAND_IMM16
case|:
comment|/* This might have been processed at parse time.  */
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|&&
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
name|BFD_RELOC_NONE
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
return|return
name|fixP
operator|->
name|fx_pcrel
condition|?
name|BFD_RELOC_16_PCREL
else|:
name|BFD_RELOC_16
return|;
case|case
name|XSTORMY16_OPERAND_ABS24
case|:
return|return
name|BFD_RELOC_XSTORMY16_24
return|;
case|case
name|XSTORMY16_OPERAND_REL8_4
case|:
name|fixP
operator|->
name|fx_addnumber
operator|-=
literal|2
expr_stmt|;
case|case
name|XSTORMY16_OPERAND_REL8_2
case|:
name|fixP
operator|->
name|fx_addnumber
operator|-=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
name|XSTORMY16_OPERAND_REL12
case|:
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
comment|/* Fall through...  */
case|case
name|XSTORMY16_OPERAND_REL12A
case|:
name|fixP
operator|->
name|fx_addnumber
operator|-=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
return|return
name|BFD_RELOC_XSTORMY16_REL_12
return|;
default|default :
comment|/* avoid -Wall warning */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|xstormy16_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_XSTORMY16_FPTR16
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a relocation against a symbol may be replaced with    a relocation against section+offset.  */
end_comment

begin_function
name|bfd_boolean
name|xstormy16_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_XSTORMY16_FPTR16
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is a copy of gas_cgen_md_apply_fix, with some enhancements to    do various things that would not be valid for all ports.  */
end_comment

begin_function
name|void
name|xstormy16_md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valueP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valueP
decl_stmt|;
comment|/* Canonical name, since used a lot.  */
name|CGEN_CPU_DESC
name|cd
init|=
name|gas_cgen_cpu_desc
decl_stmt|;
comment|/* md_cgen_lookup_reloc() will adjust this to compensate for where      in the opcode the relocation happens, for pcrel relocations.  We      have no other way of keeping track of what this offset needs to      be.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
literal|0
expr_stmt|;
comment|/* This port has pc-relative relocs and DIFF_EXPR_OK defined, so      it must deal with turning a BFD_RELOC_{8,16,32,64} into a      BFD_RELOC_*_PCREL for the case of  	.word something-.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* We don't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
name|CGEN_FIELDS
modifier|*
name|fields
init|=
name|alloca
argument_list|(
name|CGEN_CPU_SIZEOF_FIELDS
argument_list|(
name|cd
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
decl_stmt|;
comment|/* If the reloc has been fully resolved finish the operand here.  */
comment|/* FIXME: This duplicates the capabilities of code in BFD.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
name|CGEN_CPU_SET_FIELDS_BITSIZE
argument_list|(
name|cd
argument_list|)
argument_list|(
name|fields
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|CGEN_CPU_SET_VMA_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|(
name|bfd_vma
operator|)
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
block|{
name|CGEN_INSN_INT
name|insn_value
init|=
name|cgen_get_insn_value
argument_list|(
name|cd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ??? 0 is passed for `pc'.  */
name|errmsg
operator|=
name|CGEN_CPU_INSERT_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|&
name|insn_value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cgen_put_insn_value
argument_list|(
name|cd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn_value
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ??? 0 is passed for `pc'.  */
name|errmsg
operator|=
name|CGEN_CPU_INSERT_OPERAND
argument_list|(
name|cd
argument_list|)
argument_list|(
name|cd
argument_list|,
name|opindex
argument_list|,
name|fields
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errmsg
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
return|return;
comment|/* The operand isn't fully resolved.  Determine a BFD reloc value 	 based on the operand information and leave it to 	 bfd_install_relocation.  Note that this doesn't work when 	 !partial_inplace.  */
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|reloc_type
expr_stmt|;
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* We're finished with this fixup.  Install it because 	 bfd_install_relocation won't be called to do it.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: can't install fix for reloc type %d (`%s')"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* bfd_install_relocation will be called to finish things up.  */
block|}
comment|/* This is a RELA port.  Thus, it does not need to store a      value if it is going to make a reloc.  What's more, when      assembling a line like       .byte global-0x7f00       we'll get a spurious error message if we try to stuff 0x7f00 into      the byte.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
operator|*
name|valueP
operator|=
literal|0
expr_stmt|;
comment|/* Tuck `value' away for use by tc_gen_reloc.      See the comment describing fx_addnumber in write.h.      This field is misnamed (or misused :-).  */
name|fixP
operator|->
name|fx_addnumber
operator|+=
name|value
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK. */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the littleendianness of the processor.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

