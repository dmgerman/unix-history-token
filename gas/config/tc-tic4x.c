begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-tic4x.c -- Assemble for the Texas Instruments TMS320C[34]x.    Copyright (C) 1997,1998, 2002, 2003, 2005, 2006 Free Software Foundation.     Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,     Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*   TODOs:   ------      o .align cannot handle fill-data-width larger than 0xFF/8-bits. It     should be possible to define a 32-bits pattern.    o .align fills all section with NOP's when used regardless if has     been used in .text or .data. (However the .align is primarily     intended used in .text sections. If you require something else,     use .align<size>,0x00)    o .align: Implement a 'bu' insn if the number of nop's exceeds 4     within the align frag. if(fragsize>4words) insert bu fragend+1     first.    o .usect if has symbol on previous line not implemented    o .sym, .eos, .stag, .etag, .member not implemented    o Evaluation of constant floating point expressions (expr.c needs     work!)    o Support 'abc' constants (that is 0x616263) */
end_comment

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic4x.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* OK, we accept a syntax similar to the other well known C30    assembly tools.  With TIC4X_ALT_SYNTAX defined we are more    flexible, allowing a more Unix-like syntax:  `%' in front of    register names, `#' in front of immediate constants, and    not requiring `@' in front of direct addresses.  */
end_comment

begin_define
define|#
directive|define
name|TIC4X_ALT_SYNTAX
end_define

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* (12 bytes) */
end_comment

begin_comment
comment|/* Handle of the inst mnemonic hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tic4x_op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle asg pseudo.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tic4x_asg_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_cpu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to TMS320C40.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_revision
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU revision */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_idle2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Idle2 support */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_lowpower
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowpower support */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_enhanced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enhanced opcode support */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_big_model
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to small memory model.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tic4x_reg_args
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to args passed on stack.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|tic4x_oplevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode level */
end_comment

begin_define
define|#
directive|define
name|OPTION_CPU
value|'m'
end_define

begin_define
define|#
directive|define
name|OPTION_BIG
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SMALL
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_MEMPARM
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_REGPARM
value|(OPTION_MD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|OPTION_IDLE2
value|(OPTION_MD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|OPTION_LOWPOWER
value|(OPTION_MD_BASE + 6)
end_define

begin_define
define|#
directive|define
name|OPTION_ENHANCED
value|(OPTION_MD_BASE + 7)
end_define

begin_define
define|#
directive|define
name|OPTION_REV
value|(OPTION_MD_BASE + 8)
end_define

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"bm:prs"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mcpu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU
block|}
block|,
block|{
literal|"mdsp"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU
block|}
block|,
block|{
literal|"mbig"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG
block|}
block|,
block|{
literal|"msmall"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SMALL
block|}
block|,
block|{
literal|"mmemparm"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MEMPARM
block|}
block|,
block|{
literal|"mregparm"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_REGPARM
block|}
block|,
block|{
literal|"midle2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IDLE2
block|}
block|,
block|{
literal|"mlowpower"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LOWPOWER
block|}
block|,
block|{
literal|"menhanced"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ENHANCED
block|}
block|,
block|{
literal|"mrev"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_REV
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|M_UNKNOWN
block|,
name|M_IMMED
block|,
name|M_DIRECT
block|,
name|M_REGISTER
block|,
name|M_INDIRECT
block|,
name|M_IMMED_F
block|,
name|M_PARALLEL
block|,
name|M_HI
block|}
name|tic4x_addr_mode_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tic4x_operand
block|{
name|tic4x_addr_mode_t
name|mode
decl_stmt|;
comment|/* Addressing mode.  */
name|expressionS
name|expr
decl_stmt|;
comment|/* Expression.  */
name|int
name|disp
decl_stmt|;
comment|/* Displacement for indirect addressing.  */
name|int
name|aregno
decl_stmt|;
comment|/* Aux. register number.  */
name|LITTLENUM_TYPE
name|fwords
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
comment|/* Float immed. number.  */
block|}
name|tic4x_operand_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tic4x_insn
block|{
name|char
name|name
index|[
name|TIC4X_NAME_MAX
index|]
decl_stmt|;
comment|/* Mnemonic of instruction.  */
name|unsigned
name|int
name|in_use
decl_stmt|;
comment|/* True if in_use.  */
name|unsigned
name|int
name|parallel
decl_stmt|;
comment|/* True if parallel instruction.  */
name|unsigned
name|int
name|nchars
decl_stmt|;
comment|/* This is always 4 for the C30.  */
name|unsigned
name|long
name|opcode
decl_stmt|;
comment|/* Opcode number.  */
name|expressionS
name|exp
decl_stmt|;
comment|/* Expression required for relocation.  */
name|int
name|reloc
decl_stmt|;
comment|/* Relocation type required.  */
name|int
name|pcrel
decl_stmt|;
comment|/* True if relocation PC relative.  */
name|char
modifier|*
name|pname
decl_stmt|;
comment|/* Name of instruction in parallel.  */
name|unsigned
name|int
name|num_operands
decl_stmt|;
comment|/* Number of operands in total.  */
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
comment|/* Pointer to first template.  */
name|tic4x_operand_t
name|operands
index|[
name|TIC4X_OPERANDS_MAX
index|]
decl_stmt|;
block|}
name|tic4x_insn_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|tic4x_insn_t
name|the_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info about our instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|tic4x_insn_t
modifier|*
name|insn
init|=
operator|&
name|the_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_gen_to_words
name|PARAMS
argument_list|(
operator|(
name|FLONUM_TYPE
operator|,
name|LITTLENUM_TYPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tic4x_atof
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|,
name|LITTLENUM_TYPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_insert_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_insert_sym
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tic4x_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tic4x_expression_abs
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|offsetT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_emit_char
name|PARAMS
argument_list|(
operator|(
name|char
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_seg_alloc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|segT
operator|,
name|int
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_asg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_globl
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_stringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_eval
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_newblock
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_sect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_usect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_version
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_init_regtable
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_init_symbols
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_inst_insert
name|PARAMS
argument_list|(
operator|(
name|tic4x_inst_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tic4x_inst_t
modifier|*
name|tic4x_inst_make
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_inst_add
name|PARAMS
argument_list|(
operator|(
name|tic4x_inst_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tic4x_end
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_indirect_parse
name|PARAMS
argument_list|(
operator|(
name|tic4x_operand_t
operator|*
operator|,
specifier|const
name|tic4x_indirect_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tic4x_operand_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tic4x_operand_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_operands_match
name|PARAMS
argument_list|(
operator|(
name|tic4x_inst_t
operator|*
operator|,
name|tic4x_insn_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_insn_check
name|PARAMS
argument_list|(
operator|(
name|tic4x_insn_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_insn_output
name|PARAMS
argument_list|(
operator|(
name|tic4x_insn_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_operands_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tic4x_operand_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tic4x_cleanup
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tic4x_unrecognized_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_pc_offset
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tic4x_do_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tic4x_start_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|tc_gen_reloc
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|fixS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|32
block|}
block|,
block|{
literal|"ascii"
block|,
name|tic4x_stringer
block|,
literal|1
block|}
block|,
block|{
literal|"asciz"
block|,
name|tic4x_stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asg"
block|,
name|tic4x_asg
block|,
literal|0
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"byte"
block|,
name|tic4x_cons
block|,
literal|1
block|}
block|,
block|{
literal|"bss"
block|,
name|tic4x_bss
block|,
literal|0
block|}
block|,
block|{
literal|"copy"
block|,
name|s_include
block|,
literal|0
block|}
block|,
block|{
literal|"def"
block|,
name|tic4x_globl
block|,
literal|0
block|}
block|,
block|{
literal|"equ"
block|,
name|tic4x_set
block|,
literal|0
block|}
block|,
block|{
literal|"eval"
block|,
name|tic4x_eval
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|tic4x_globl
block|,
literal|0
block|}
block|,
block|{
literal|"globl"
block|,
name|tic4x_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|tic4x_cons
block|,
literal|2
block|}
block|,
block|{
literal|"ieee"
block|,
name|float_cons
block|,
literal|'i'
block|}
block|,
block|{
literal|"int"
block|,
name|tic4x_cons
block|,
literal|4
block|}
block|,
comment|/* .int allocates 4 bytes.  */
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'e'
block|}
block|,
block|{
literal|"newblock"
block|,
name|tic4x_newblock
block|,
literal|0
block|}
block|,
block|{
literal|"ref"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* All undefined treated as external.  */
block|{
literal|"set"
block|,
name|tic4x_set
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|tic4x_sect
block|,
literal|1
block|}
block|,
comment|/* Define named section.  */
block|{
literal|"space"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"string"
block|,
name|tic4x_stringer
block|,
literal|0
block|}
block|,
block|{
literal|"usect"
block|,
name|tic4x_usect
block|,
literal|0
block|}
block|,
comment|/* Reserve space in uninit. named sect.  */
block|{
literal|"version"
block|,
name|tic4x_version
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|tic4x_cons
block|,
literal|4
block|}
block|,
comment|/* .word allocates 4 bytes.  */
block|{
literal|"xdef"
block|,
name|tic4x_globl
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
end_ifdef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";!"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.     Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.     Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We needed an unused char for line separation to work around the    lack of macros, using sed and such.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"&"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.  */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFilsS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c.  Ideally it shouldn't have to know about it at    all, but nothing is ideal around here.  */
end_comment

begin_comment
comment|/* Flonums returned here.  */
end_comment

begin_decl_stmt
specifier|extern
name|FLONUM_TYPE
name|generic_floating_point_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Precision in LittleNums.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PRECISION
value|(4)
end_define

begin_comment
comment|/* Its a bit overkill for us, but the code                                    requires it... */
end_comment

begin_define
define|#
directive|define
name|S_PRECISION
value|(1)
end_define

begin_comment
comment|/* Short float constants 16-bit.  */
end_comment

begin_define
define|#
directive|define
name|F_PRECISION
value|(2)
end_define

begin_comment
comment|/* Float and double types 32-bit.  */
end_comment

begin_define
define|#
directive|define
name|E_PRECISION
value|(4)
end_define

begin_comment
comment|/* Extended precision, 64-bit (real 40-bit). */
end_comment

begin_define
define|#
directive|define
name|GUARD
value|(2)
end_define

begin_comment
comment|/* Turn generic_floating_point_number into a real short/float/double.  */
end_comment

begin_function
specifier|static
name|int
name|tic4x_gen_to_words
parameter_list|(
name|flonum
parameter_list|,
name|words
parameter_list|,
name|precision
parameter_list|)
name|FLONUM_TYPE
name|flonum
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
name|int
name|precision
decl_stmt|;
block|{
name|int
name|return_value
init|=
literal|0
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|p
decl_stmt|;
comment|/* Littlenum pointer.  */
name|int
name|mantissa_bits
decl_stmt|;
comment|/* Bits in mantissa field.  */
name|int
name|exponent_bits
decl_stmt|;
comment|/* Bits in exponent field.  */
name|int
name|exponent
decl_stmt|;
name|unsigned
name|int
name|sone
decl_stmt|;
comment|/* Scaled one.  */
name|unsigned
name|int
name|sfract
decl_stmt|;
comment|/* Scaled fraction.  */
name|unsigned
name|int
name|smant
decl_stmt|;
comment|/* Scaled mantissa.  */
name|unsigned
name|int
name|tmp
decl_stmt|;
name|unsigned
name|int
name|mover
decl_stmt|;
comment|/* Mantissa overflow bits */
name|unsigned
name|int
name|rbit
decl_stmt|;
comment|/* Round bit. */
name|int
name|shift
decl_stmt|;
comment|/* Shift count.  */
comment|/* NOTE: Svein Seldal<Svein@dev.seldal.com>      The code in this function is altered slightly to support floats      with 31-bits mantissas, thus the documentation below may be a      little bit inaccurate.            By Michael P. Hayes<m.hayes@elec.canterbury.ac.nz>      Here is how a generic floating point number is stored using      flonums (an extension of bignums) where p is a pointer to an      array of LITTLENUMs.       For example 2e-3 is stored with exp = -4 and      bits[0] = 0x0000      bits[1] = 0x0000      bits[2] = 0x4fde      bits[3] = 0x978d      bits[4] = 0x126e      bits[5] = 0x0083      with low =&bits[2], high =&bits[5], and leader =&bits[5].       This number can be written as      0x0083126e978d4fde.00000000 * 65536**-4  or      0x0.0083126e978d4fde        * 65536**0   or      0x0.83126e978d4fde          * 2**-8   = 2e-3       Note that low points to the 65536**0 littlenum (bits[2]) and      leader points to the most significant non-zero littlenum      (bits[5]).       TMS320C3X floating point numbers are a bit of a strange beast.      The 32-bit flavour has the 8 MSBs representing the exponent in      twos complement format (-128 to +127).  There is then a sign bit      followed by 23 bits of mantissa.  The mantissa is expressed in      twos complement format with the binary point after the most      significant non sign bit.  The bit after the binary point is      suppressed since it is the complement of the sign bit.  The      effective mantissa is thus 24 bits.  Zero is represented by an      exponent of -128.       The 16-bit flavour has the 4 MSBs representing the exponent in      twos complement format (-8 to +7).  There is then a sign bit      followed by 11 bits of mantissa.  The mantissa is expressed in      twos complement format with the binary point after the most      significant non sign bit.  The bit after the binary point is      suppressed since it is the complement of the sign bit.  The      effective mantissa is thus 12 bits.  Zero is represented by an      exponent of -8.  For example,       number       norm mant m  x  e  s  i    fraction f      +0.500 =>  1.00000000000 -1 -1  0  1  .00000000000   (1 + 0) * 2^(-1)      +0.999 =>  1.11111111111 -1 -1  0  1  .11111111111   (1 + 0.99) * 2^(-1)      +1.000 =>  1.00000000000  0  0  0  1  .00000000000   (1 + 0) * 2^(0)      +1.500 =>  1.10000000000  0  0  0  1  .10000000000   (1 + 0.5) * 2^(0)      +1.999 =>  1.11111111111  0  0  0  1  .11111111111   (1 + 0.9) * 2^(0)      +2.000 =>  1.00000000000  1  1  0  1  .00000000000   (1 + 0) * 2^(1)      +4.000 =>  1.00000000000  2  2  0  1  .00000000000   (1 + 0) * 2^(2)      -0.500 =>  1.00000000000 -1 -1  1  0  .10000000000   (-2 + 0) * 2^(-2)      -1.000 =>  1.00000000000  0 -1  1  0  .00000000000   (-2 + 0) * 2^(-1)      -1.500 =>  1.10000000000  0  0  1  0  .10000000000   (-2 + 0.5) * 2^(0)      -1.999 =>  1.11111111111  0  0  1  0  .00000000001   (-2 + 0.11) * 2^(0)      -2.000 =>  1.00000000000  1  1  1  0  .00000000000   (-2 + 0) * 2^(0)      -4.000 =>  1.00000000000  2  1  1  0  .00000000000   (-2 + 0) * 2^(1)       where e is the exponent, s is the sign bit, i is the implied bit,      and f is the fraction stored in the mantissa field.       num = (1 + f) * 2^x   =  m * 2^e if s = 0      num = (-2 + f) * 2^x  = -m * 2^e if s = 1      where 0<= f< 1.0  and 1.0<= m< 2.0       The fraction (f) and exponent (e) fields for the TMS320C3X format      can be derived from the normalised mantissa (m) and exponent (x) using:       f = m - 1, e = x       if s = 0      f = 2 - m, e = x       if s = 1 and m != 1.0      f = 0,     e = x - 1   if s = 1 and m = 1.0      f = 0,     e = -8      if m = 0        OK, the other issue we have to consider is rounding since the      mantissa has a much higher potential precision than what we can      represent.  To do this we add half the smallest storable fraction.      We then have to renormalise the number to allow for overflow.       To convert a generic flonum into a TMS320C3X floating point      number, here's what we try to do....       The first thing is to generate a normalised mantissa (m) where      1.0<= m< 2 and to convert the exponent from base 16 to base 2.      We desire the binary point to be placed after the most significant      non zero bit.  This process is done in two steps: firstly, the      littlenum with the most significant non zero bit is located (this      is done for us since leader points to this littlenum) and the      binary point (which is currently after the LSB of the littlenum      pointed to by low) is moved to before the MSB of the littlenum      pointed to by leader.  This requires the exponent to be adjusted      by leader - low + 1.  In the earlier example, the new exponent is      thus -4 + (5 - 2 + 1) = 0 (base 65536).  We now need to convert      the exponent to base 2 by multiplying the exponent by 16 (log2      65536).  The exponent base 2 is thus also zero.       The second step is to hunt for the most significant non zero bit      in the leader littlenum.  We do this by left shifting a copy of      the leader littlenum until bit 16 is set (0x10000) and counting      the number of shifts, S, required.  The number of shifts then has to      be added to correct the exponent (base 2).  For our example, this      will require 9 shifts and thus our normalised exponent (base 2) is      0 + 9 = 9.  Note that the worst case scenario is when the leader      littlenum is 1, thus requiring 16 shifts.       We now have to left shift the other littlenums by the same amount,      propagating the shifted bits into the more significant littlenums.      To save a lot of unnecessary shifting we only have to consider      two or three littlenums, since the greatest number of mantissa      bits required is 24 + 1 rounding bit.  While two littlenums      provide 32 bits of precision, the most significant littlenum      may only contain a single significant bit  and thus an extra      littlenum is required.       Denoting the number of bits in the fraction field as F, we require      G = F + 2 bits (one extra bit is for rounding, the other gets      suppressed).  Say we required S shifts to find the most      significant bit in the leader littlenum, the number of left shifts      required to move this bit into bit position G - 1 is L = G + S - 17.      Note that this shift count may be negative for the short floating      point flavour (where F = 11 and thus G = 13 and potentially S< 3).      If L> 0 we have to shunt the next littlenum into position.  Bit      15 (the MSB) of the next littlenum needs to get moved into position      L - 1 (If L> 15 we need all the bits of this littlenum and      some more from the next one.).  We subtract 16 from L and use this      as the left shift count;  the resultant value we or with the      previous result.  If L> 0, we repeat this operation.   */
if|if
condition|(
name|precision
operator|!=
name|S_PRECISION
condition|)
name|words
index|[
literal|1
index|]
operator|=
literal|0x0000
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|E_PRECISION
condition|)
name|words
index|[
literal|2
index|]
operator|=
name|words
index|[
literal|3
index|]
operator|=
literal|0x0000
expr_stmt|;
comment|/* 0.0e0 or NaN seen.  */
if|if
condition|(
name|flonum
operator|.
name|low
operator|>
name|flonum
operator|.
name|leader
comment|/* = 0.0e0 */
operator|||
name|flonum
operator|.
name|sign
operator|==
literal|0
condition|)
comment|/* = NaN */
block|{
if|if
condition|(
name|flonum
operator|.
name|sign
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Nan, using zero."
argument_list|)
expr_stmt|;
name|words
index|[
literal|0
index|]
operator|=
literal|0x8000
expr_stmt|;
return|return
name|return_value
return|;
block|}
if|if
condition|(
name|flonum
operator|.
name|sign
operator|==
literal|'P'
condition|)
block|{
comment|/* +INF:  Replace with maximum float.  */
if|if
condition|(
name|precision
operator|==
name|S_PRECISION
condition|)
name|words
index|[
literal|0
index|]
operator|=
literal|0x77ff
expr_stmt|;
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7f7f
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|precision
operator|==
name|E_PRECISION
condition|)
block|{
name|words
index|[
literal|2
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|flonum
operator|.
name|sign
operator|==
literal|'N'
condition|)
block|{
comment|/* -INF:  Replace with maximum float.  */
if|if
condition|(
name|precision
operator|==
name|S_PRECISION
condition|)
name|words
index|[
literal|0
index|]
operator|=
literal|0x7800
expr_stmt|;
else|else
name|words
index|[
literal|0
index|]
operator|=
literal|0x7f80
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|E_PRECISION
condition|)
name|words
index|[
literal|2
index|]
operator|=
literal|0x8000
expr_stmt|;
return|return
name|return_value
return|;
block|}
name|exponent
operator|=
operator|(
name|flonum
operator|.
name|exponent
operator|+
name|flonum
operator|.
name|leader
operator|-
name|flonum
operator|.
name|low
operator|+
literal|1
operator|)
operator|*
literal|16
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
operator|*
name|flonum
operator|.
name|leader
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Hmmm.  */
name|shift
operator|=
literal|0
expr_stmt|;
comment|/* Find position of first sig. bit.  */
while|while
condition|(
name|tmp
operator|>>=
literal|1
condition|)
name|shift
operator|++
expr_stmt|;
name|exponent
operator|-=
operator|(
literal|16
operator|-
name|shift
operator|)
expr_stmt|;
comment|/* Adjust exponent.  */
if|if
condition|(
name|precision
operator|==
name|S_PRECISION
condition|)
comment|/* Allow 1 rounding bit.  */
block|{
name|exponent_bits
operator|=
literal|4
expr_stmt|;
name|mantissa_bits
operator|=
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|exponent_bits
operator|=
literal|8
expr_stmt|;
name|mantissa_bits
operator|=
literal|23
expr_stmt|;
block|}
else|else
comment|/* E_PRECISION */
block|{
name|exponent_bits
operator|=
literal|8
expr_stmt|;
name|mantissa_bits
operator|=
literal|31
expr_stmt|;
block|}
name|shift
operator|=
name|mantissa_bits
operator|-
name|shift
expr_stmt|;
name|smant
operator|=
literal|0
expr_stmt|;
name|mover
operator|=
literal|0
expr_stmt|;
name|rbit
operator|=
literal|0
expr_stmt|;
comment|/* Store the mantissa data into smant and the roundbit into rbit */
for|for
control|(
name|p
operator|=
name|flonum
operator|.
name|leader
init|;
name|p
operator|>=
name|flonum
operator|.
name|low
operator|&&
name|shift
operator|>
operator|-
literal|16
condition|;
name|p
operator|--
control|)
block|{
name|tmp
operator|=
name|shift
operator|>=
literal|0
condition|?
operator|*
name|p
operator|<<
name|shift
else|:
operator|*
name|p
operator|>>
operator|-
name|shift
expr_stmt|;
name|rbit
operator|=
name|shift
operator|<
literal|0
condition|?
operator|(
operator|(
operator|*
name|p
operator|>>
operator|(
operator|-
name|shift
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0x1
operator|)
else|:
literal|0
expr_stmt|;
name|smant
operator||=
name|tmp
expr_stmt|;
name|shift
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* OK, we've got our scaled mantissa so let's round it up */
if|if
condition|(
name|rbit
condition|)
block|{
comment|/* If the mantissa is going to overflow when added, lets store          the extra bit in mover. -- A special case exists when          mantissa_bits is 31 (E_PRECISION). Then the first test cannot          be trusted, as result is host-dependent, thus the second          test. */
if|if
condition|(
name|smant
operator|==
operator|(
call|(
name|unsigned
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|mantissa_bits
operator|+
literal|1
operator|)
argument_list|)
operator|-
literal|1
operator|)
operator|||
name|smant
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
comment|/* This is to catch E_PRECISION cases */
name|mover
operator|=
literal|1
expr_stmt|;
name|smant
operator|++
expr_stmt|;
block|}
comment|/* Get the scaled one value */
name|sone
operator|=
operator|(
literal|1
operator|<<
operator|(
name|mantissa_bits
operator|)
operator|)
expr_stmt|;
comment|/* The number may be unnormalised so renormalise it...  */
if|if
condition|(
name|mover
condition|)
block|{
name|smant
operator|>>=
literal|1
expr_stmt|;
name|smant
operator||=
name|sone
expr_stmt|;
comment|/* Insert the bit from mover into smant */
name|exponent
operator|++
expr_stmt|;
block|}
comment|/* The binary point is now between bit positions 11 and 10 or 23 and 22,      i.e., between mantissa_bits - 1 and mantissa_bits - 2 and the      bit at mantissa_bits - 1 should be set.  */
if|if
condition|(
operator|!
operator|(
name|sone
operator|&
name|smant
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ooops.  */
if|if
condition|(
name|flonum
operator|.
name|sign
operator|==
literal|'+'
condition|)
name|sfract
operator|=
name|smant
operator|-
name|sone
expr_stmt|;
comment|/* smant - 1.0.  */
else|else
block|{
comment|/* This seems to work.  */
if|if
condition|(
name|smant
operator|==
name|sone
condition|)
block|{
name|exponent
operator|--
expr_stmt|;
name|sfract
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sfract
operator|=
operator|-
name|smant
operator|&
operator|(
name|sone
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 2.0 - smant.  */
block|}
name|sfract
operator||=
name|sone
expr_stmt|;
comment|/* Insert sign bit.  */
block|}
if|if
condition|(
name|abs
argument_list|(
name|exponent
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|exponent_bits
operator|-
literal|1
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
literal|"Cannot represent exponent in %d bits"
argument_list|,
name|exponent_bits
argument_list|)
expr_stmt|;
comment|/* Force exponent to fit in desired field width.  */
name|exponent
operator|&=
operator|(
literal|1
operator|<<
operator|(
name|exponent_bits
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|E_PRECISION
condition|)
block|{
comment|/* Map the float part first (100% equal format as F_PRECISION) */
name|words
index|[
literal|0
index|]
operator|=
name|exponent
operator|<<
operator|(
name|mantissa_bits
operator|+
literal|1
operator|-
literal|24
operator|)
expr_stmt|;
name|words
index|[
literal|0
index|]
operator||=
name|sfract
operator|>>
literal|24
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
name|sfract
operator|>>
literal|8
expr_stmt|;
comment|/* Map the mantissa in the next */
name|words
index|[
literal|2
index|]
operator|=
name|sfract
operator|>>
literal|16
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
name|sfract
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert the exponent data into the word */
name|sfract
operator||=
name|exponent
operator|<<
operator|(
name|mantissa_bits
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|S_PRECISION
condition|)
name|words
index|[
literal|0
index|]
operator|=
name|sfract
expr_stmt|;
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
name|sfract
operator|>>
literal|16
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
name|sfract
operator|&
literal|0xffff
expr_stmt|;
block|}
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Returns pointer past text consumed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tic4x_atof
parameter_list|(
name|str
parameter_list|,
name|what_kind
parameter_list|,
name|words
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|what_kind
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
block|{
comment|/* Extra bits for zeroed low-order bits.  The 1st MAX_PRECISION are      zeroed, the last contain flonum bits.  */
specifier|static
name|LITTLENUM_TYPE
name|bits
index|[
name|MAX_PRECISION
operator|+
name|MAX_PRECISION
operator|+
name|GUARD
index|]
decl_stmt|;
name|char
modifier|*
name|return_value
decl_stmt|;
comment|/* Number of 16-bit words in the format.  */
name|int
name|precision
decl_stmt|;
name|FLONUM_TYPE
name|save_gen_flonum
decl_stmt|;
comment|/* We have to save the generic_floating_point_number because it      contains storage allocation about the array of LITTLENUMs where      the value is actually stored.  We will allocate our own array of      littlenums below, but have to restore the global one on exit.  */
name|save_gen_flonum
operator|=
name|generic_floating_point_number
expr_stmt|;
name|return_value
operator|=
name|str
expr_stmt|;
name|generic_floating_point_number
operator|.
name|low
operator|=
name|bits
operator|+
name|MAX_PRECISION
expr_stmt|;
name|generic_floating_point_number
operator|.
name|high
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|leader
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|generic_floating_point_number
operator|.
name|sign
operator|=
literal|'\0'
expr_stmt|;
comment|/* Use more LittleNums than seems necessary: the highest flonum may      have 15 leading 0 bits, so could be useless.  */
name|memset
argument_list|(
name|bits
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
name|MAX_PRECISION
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what_kind
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|precision
operator|=
name|S_PRECISION
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|precision
operator|=
name|F_PRECISION
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|precision
operator|=
name|E_PRECISION
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Invalid floating point number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|generic_floating_point_number
operator|.
name|high
operator|=
name|generic_floating_point_number
operator|.
name|low
operator|+
name|precision
operator|-
literal|1
operator|+
name|GUARD
expr_stmt|;
if|if
condition|(
name|atof_generic
argument_list|(
operator|&
name|return_value
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid floating point number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tic4x_gen_to_words
argument_list|(
name|generic_floating_point_number
argument_list|,
name|words
argument_list|,
name|precision
argument_list|)
expr_stmt|;
comment|/* Restore the generic_floating_point_number's storage alloc (and      everything else).  */
name|generic_floating_point_number
operator|=
name|save_gen_flonum
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_insert_reg
parameter_list|(
name|regname
parameter_list|,
name|regnum
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|regname
argument_list|,
name|reg_section
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|ISLOWER
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
condition|?
name|TOUPPER
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
else|:
name|regname
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|reg_section
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_insert_sym
parameter_list|(
name|symname
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|symname
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|symname
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tic4x_expression
parameter_list|(
name|str
parameter_list|,
name|exp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Save line pointer.  */
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|t
expr_stmt|;
comment|/* Restore line pointer.  */
return|return
name|s
return|;
comment|/* Return pointer to where parsing stopped.  */
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tic4x_expression_abs
parameter_list|(
name|str
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|offsetT
modifier|*
name|value
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Save line pointer.  */
name|input_line_pointer
operator|=
name|str
expr_stmt|;
operator|*
name|value
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|t
expr_stmt|;
comment|/* Restore line pointer.  */
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_emit_char
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|c
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_seg_alloc
parameter_list|(
name|name
parameter_list|,
name|seg
parameter_list|,
name|size
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
comment|/* Note that the size is in words      so we multiply it by 4 to get the number of bytes to allocate.  */
comment|/* If we have symbol:  .usect  ".fred", size etc.,      the symbol needs to point to the first location reserved      by the pseudo op.  */
if|if
condition|(
name|size
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|symbolP
argument_list|,
name|size
operator|*
name|OCTETS_PER_BYTE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .asg ["]character-string["], symbol */
end_comment

begin_function
specifier|static
name|void
name|tic4x_asg
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Skip string expression.  */
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|*
name|input_line_pointer
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Comma expected\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|hash_find
argument_list|(
name|tic4x_asg_hash
argument_list|,
name|name
argument_list|)
condition|)
name|hash_replace
argument_list|(
name|tic4x_asg_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|str
argument_list|)
expr_stmt|;
else|else
name|hash_insert
argument_list|(
name|tic4x_asg_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|str
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .bss symbol, size  */
end_comment

begin_function
specifier|static
name|void
name|tic4x_bss
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
name|segT
name|current_seg
decl_stmt|;
name|subsegT
name|current_subseg
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|current_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* Save current seg.  */
name|current_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* Save current subseg.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|".bss size argument missing\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|".bss size %ld< 0!"
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
name|size
operator|*
name|OCTETS_PER_BYTE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Fill char.  */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
comment|/* The symbol may already have been created with a preceding      ".globl" directive -- be careful not to step on storage class      in that case.  Otherwise, set it to static.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* Restore current seg.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_globl
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .byte, .word. .int, .long */
end_comment

begin_function
specifier|static
name|void
name|tic4x_cons
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
do|do
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
name|tic4x_emit_char
argument_list|(
name|c
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
name|exp
operator|.
name|X_add_number
operator|&=
literal|255
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|exp
operator|.
name|X_add_number
operator|&=
literal|65535
expr_stmt|;
break|break;
block|}
block|}
comment|/* Perhaps we should disallow .byte and .hword with 	     a non constant expression that will require relocation.  */
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .ascii, .asciz, .string */
end_comment

begin_function
specifier|static
name|void
name|tic4x_stringer
parameter_list|(
name|append_zero
parameter_list|)
name|int
name|append_zero
decl_stmt|;
comment|/*ex: bytes */
block|{
name|int
name|bytes
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|tic4x_emit_char
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
name|tic4x_emit_char
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
literal|"Non-constant symbols not allowed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|exp
operator|.
name|X_add_number
operator|&=
literal|255
expr_stmt|;
comment|/* Limit numeber to 8-bit */
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Fill out the rest of the expression with 0's to fill up a full word */
if|if
condition|(
name|bytes
operator|&
literal|0x3
condition|)
name|tic4x_emit_char
argument_list|(
literal|0
argument_list|,
literal|4
operator|-
operator|(
name|bytes
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .eval expression, symbol */
end_comment

begin_function
specifier|static
name|void
name|tic4x_eval
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|offsetT
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Symbol missing\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset local labels.  */
end_comment

begin_function
specifier|static
name|void
name|tic4x_newblock
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|dollar_label_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .sect "section-name" [, value] */
end_comment

begin_comment
comment|/* .sect ["]section-name[:subsection-name]["] [, value] */
end_comment

begin_function
specifier|static
name|void
name|tic4x_sect
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
modifier|*
name|subsection_name
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|offsetT
name|num
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip null symbol terminator.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
comment|/* TI C from version 5.0 allows a section name to contain a      subsection name as well. The subsection name is separated by a      ':' from the section name.  Currently we scan the subsection      name and discard it.      Volker Kuhlmann<v.kuhlmann@elec.canterbury.ac.nz>.  */
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|subsection_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip null symbol terminator.  */
name|as_warn
argument_list|(
literal|".sect: subsection name ignored"
argument_list|)
expr_stmt|;
block|}
comment|/* We might still have a '"' to discard, but the character after a      symbol name will be overwritten with a \0 by get_symbol_end()      [VK].  */
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
block|}
else|else
name|num
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|==
name|SEC_NO_FLAGS
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_DATA
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Error setting flags for \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the last character overwritten by get_symbol_end() was an      end-of-line, we must restore it or the end of the line will not be      recognised and scanning extends into the next line, stopping with      an error (blame Volker Kuhlmann<v.kuhlmann@elec.canterbury.ac.nz>      if this is not true).  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
operator|*
operator|(
operator|--
name|input_line_pointer
operator|)
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* symbol[:] .set value  or  .set symbol, value */
end_comment

begin_function
specifier|static
name|void
name|tic4x_set
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|line_label
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|".set syntax invalid\n"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [symbol] .usect ["]section-name["], size-in-words [, alignment-flag] */
end_comment

begin_function
specifier|static
name|void
name|tic4x_usect
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|section_name
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|offsetT
name|size
decl_stmt|,
name|alignment_flag
decl_stmt|;
name|segT
name|current_seg
decl_stmt|;
name|subsegT
name|current_subseg
decl_stmt|;
name|current_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* save current seg.  */
name|current_subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* save current subseg.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip null symbol terminator.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Read a possibly present third argument (alignment flag) [VK].  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
operator|&
name|alignment_flag
argument_list|)
expr_stmt|;
block|}
else|else
name|alignment_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alignment_flag
condition|)
name|as_warn
argument_list|(
literal|".usect: non-zero alignment flag ignored"
argument_list|)
expr_stmt|;
name|seg
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_label
operator|!=
name|NULL
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
comment|/* Uninitialised data.  */
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Error setting flags for \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tic4x_seg_alloc
argument_list|(
name|name
argument_list|,
name|seg
argument_list|,
name|size
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|)
operator|!=
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|line_label
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* Restore current seg.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .version cpu-version.  */
end_comment

begin_function
specifier|static
name|void
name|tic4x_version
parameter_list|(
name|x
parameter_list|)
name|int
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|offsetT
name|temp
decl_stmt|;
name|input_line_pointer
operator|=
name|tic4x_expression_abs
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CPU_TIC3X
argument_list|(
name|temp
argument_list|)
operator|&&
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|temp
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"This assembler does not support processor generation %ld"
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tic4x_cpu
operator|&&
name|temp
operator|!=
operator|(
name|offsetT
operator|)
name|tic4x_cpu
condition|)
name|as_warn
argument_list|(
literal|"Changing processor generation on fly not supported..."
argument_list|)
expr_stmt|;
name|tic4x_cpu
operator|=
name|temp
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_init_regtable
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic3x_num_registers
condition|;
name|i
operator|++
control|)
name|tic4x_insert_reg
argument_list|(
name|tic3x_registers
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tic3x_registers
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
block|{
comment|/* Add additional Tic4x registers, overriding some C3x ones.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_registers
condition|;
name|i
operator|++
control|)
name|tic4x_insert_reg
argument_list|(
name|tic4x_registers
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tic4x_registers
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_init_symbols
parameter_list|()
block|{
comment|/* The TI tools accept case insensitive versions of these symbols,      we don't !       For TI C/Asm 5.0       .TMS320xx       30,31,32,40,or 44       set according to -v flag      .C3X or .C3x    1 or 0                  1 if -v30,-v31,or -v32      .C30            1 or 0                  1 if -v30      .C31            1 or 0                  1 if -v31      .C32            1 or 0                  1 if -v32      .C4X or .C4x    1 or 0                  1 if -v40, or -v44      .C40            1 or 0                  1 if -v40      .C44            1 or 0                  1 if -v44       .REGPARM 1 or 0                  1 if -mr option used      .BIGMODEL        1 or 0                  1 if -mb option used       These symbols are currently supported but will be removed in a      later version:      .TMS320C30      1 or 0                  1 if -v30,-v31,or -v32      .TMS320C31      1 or 0                  1 if -v31      .TMS320C32      1 or 0                  1 if -v32      .TMS320C40      1 or 0                  1 if -v40, or -v44      .TMS320C44      1 or 0                  1 if -v44       Source: TI: TMS320C3x/C4x Assembly Language Tools User's Guide,      1997, SPRU035C, p. 3-17/3-18.  */
name|tic4x_insert_sym
argument_list|(
literal|".REGPARM"
argument_list|,
name|tic4x_reg_args
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".MEMPARM"
argument_list|,
operator|!
name|tic4x_reg_args
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".BIGMODEL"
argument_list|,
name|tic4x_big_model
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".C30INTERRUPT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320xx"
argument_list|,
name|tic4x_cpu
operator|==
literal|0
condition|?
literal|40
else|:
name|tic4x_cpu
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".C3X"
argument_list|,
name|tic4x_cpu
operator|==
literal|30
operator|||
name|tic4x_cpu
operator|==
literal|31
operator|||
name|tic4x_cpu
operator|==
literal|32
operator|||
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".C3x"
argument_list|,
name|tic4x_cpu
operator|==
literal|30
operator|||
name|tic4x_cpu
operator|==
literal|31
operator|||
name|tic4x_cpu
operator|==
literal|32
operator|||
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".C4X"
argument_list|,
name|tic4x_cpu
operator|==
literal|0
operator|||
name|tic4x_cpu
operator|==
literal|40
operator|||
name|tic4x_cpu
operator|==
literal|44
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".C4x"
argument_list|,
name|tic4x_cpu
operator|==
literal|0
operator|||
name|tic4x_cpu
operator|==
literal|40
operator|||
name|tic4x_cpu
operator|==
literal|44
argument_list|)
expr_stmt|;
comment|/* Do we need to have the following symbols also in lower case?  */
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C30"
argument_list|,
name|tic4x_cpu
operator|==
literal|30
operator|||
name|tic4x_cpu
operator|==
literal|31
operator|||
name|tic4x_cpu
operator|==
literal|32
operator|||
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C30"
argument_list|,
name|tic4x_cpu
operator|==
literal|30
operator|||
name|tic4x_cpu
operator|==
literal|31
operator|||
name|tic4x_cpu
operator|==
literal|32
operator|||
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C31"
argument_list|,
name|tic4x_cpu
operator|==
literal|31
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C31"
argument_list|,
name|tic4x_cpu
operator|==
literal|31
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C32"
argument_list|,
name|tic4x_cpu
operator|==
literal|32
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C32"
argument_list|,
name|tic4x_cpu
operator|==
literal|32
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C33"
argument_list|,
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C33"
argument_list|,
name|tic4x_cpu
operator|==
literal|33
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C40"
argument_list|,
name|tic4x_cpu
operator|==
literal|40
operator|||
name|tic4x_cpu
operator|==
literal|44
operator|||
name|tic4x_cpu
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C40"
argument_list|,
name|tic4x_cpu
operator|==
literal|40
operator|||
name|tic4x_cpu
operator|==
literal|44
operator|||
name|tic4x_cpu
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMS320C44"
argument_list|,
name|tic4x_cpu
operator|==
literal|44
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".tms320C44"
argument_list|,
name|tic4x_cpu
operator|==
literal|44
argument_list|)
expr_stmt|;
name|tic4x_insert_sym
argument_list|(
literal|".TMX320C40"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* C40 first pass silicon ?  */
name|tic4x_insert_sym
argument_list|(
literal|".tmx320C40"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a new instruction template into hash table.  */
end_comment

begin_function
specifier|static
name|int
name|tic4x_inst_insert
parameter_list|(
name|inst
parameter_list|)
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
block|{
specifier|static
name|char
name|prev_name
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
comment|/* Only insert the first name if have several similar entries.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|inst
operator|->
name|name
argument_list|,
name|prev_name
argument_list|)
operator|||
name|inst
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|tic4x_op_hash
argument_list|,
name|inst
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't hash `%s': %s\n"
argument_list|,
name|inst
operator|->
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|prev_name
argument_list|,
name|inst
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|retval
operator|==
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Make a new instruction template.  */
end_comment

begin_function
specifier|static
name|tic4x_inst_t
modifier|*
name|tic4x_inst_make
parameter_list|(
name|name
parameter_list|,
name|opcode
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|static
name|tic4x_inst_t
modifier|*
name|insts
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|names
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insts
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate memory to store name strings.  */
name|names
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|8192
argument_list|)
expr_stmt|;
comment|/* Allocate memory for additional insts.  */
name|insts
operator|=
operator|(
name|tic4x_inst_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tic4x_inst_t
argument_list|)
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
name|insts
index|[
name|index
index|]
operator|.
name|name
operator|=
name|names
expr_stmt|;
name|insts
index|[
name|index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|insts
index|[
name|index
index|]
operator|.
name|opmask
operator|=
literal|0xffffffff
expr_stmt|;
name|insts
index|[
name|index
index|]
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|index
operator|++
expr_stmt|;
do|do
operator|*
name|names
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|name
condition|)
do|;
operator|*
name|names
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|&
name|insts
index|[
name|index
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Add instruction template, creating dynamic templates as required.  */
end_comment

begin_function
specifier|static
name|int
name|tic4x_inst_add
parameter_list|(
name|insts
parameter_list|)
name|tic4x_inst_t
modifier|*
name|insts
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|insts
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|d
operator|=
name|name
expr_stmt|;
comment|/* We do not care about INSNs that is not a part of our      oplevel setting */
if|if
condition|(
operator|!
name|insts
operator|->
name|oplevel
operator|&
name|tic4x_oplevel
condition|)
return|return
name|ok
return|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
comment|/* Dynamically create all the conditional insts.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_conds
condition|;
name|i
operator|++
control|)
block|{
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|tic4x_conds
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|char
modifier|*
name|e
init|=
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|c
condition|)
operator|*
name|e
operator|++
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|c
operator|=
name|s
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|c
condition|)
operator|*
name|e
operator|++
operator|=
operator|*
name|c
operator|++
expr_stmt|;
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
comment|/* If instruction found then have already processed it.  */
if|if
condition|(
name|hash_find
argument_list|(
name|tic4x_op_hash
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
do|do
block|{
name|inst
operator|=
name|tic4x_inst_make
argument_list|(
name|name
argument_list|,
name|insts
index|[
name|k
index|]
operator|.
name|opcode
operator|+
operator|(
name|tic4x_conds
index|[
name|i
index|]
operator|.
name|cond
operator|<<
operator|(
operator|*
name|s
operator|==
literal|'B'
condition|?
literal|16
else|:
literal|23
operator|)
operator|)
argument_list|,
name|insts
index|[
name|k
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
comment|/* Save strcmp() with following func.  */
name|ok
operator|&=
name|tic4x_inst_insert
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|strcmp
argument_list|(
name|insts
operator|->
name|name
argument_list|,
name|insts
index|[
name|k
index|]
operator|.
name|name
argument_list|)
condition|)
do|;
block|}
return|return
name|ok
return|;
break|break;
case|case
literal|'\0'
case|:
return|return
name|tic4x_inst_insert
argument_list|(
name|insts
argument_list|)
return|;
break|break;
default|default:
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc., that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Setup the proper opcode level according to the      commandline parameters */
name|tic4x_oplevel
operator|=
name|OP_C3X
expr_stmt|;
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
name|tic4x_oplevel
operator||=
name|OP_C4X
expr_stmt|;
if|if
condition|(
operator|(
name|tic4x_cpu
operator|==
literal|31
operator|&&
name|tic4x_revision
operator|>=
literal|6
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|32
operator|&&
name|tic4x_revision
operator|>=
literal|2
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|33
operator|)
operator|||
name|tic4x_enhanced
condition|)
name|tic4x_oplevel
operator||=
name|OP_ENH
expr_stmt|;
if|if
condition|(
operator|(
name|tic4x_cpu
operator|==
literal|30
operator|&&
name|tic4x_revision
operator|>=
literal|7
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|31
operator|&&
name|tic4x_revision
operator|>=
literal|5
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|32
operator|)
operator|||
name|tic4x_lowpower
condition|)
name|tic4x_oplevel
operator||=
name|OP_LPWR
expr_stmt|;
if|if
condition|(
operator|(
name|tic4x_cpu
operator|==
literal|30
operator|&&
name|tic4x_revision
operator|>=
literal|7
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|31
operator|&&
name|tic4x_revision
operator|>=
literal|5
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|32
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|33
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|40
operator|&&
name|tic4x_revision
operator|>=
literal|5
operator|)
operator|||
operator|(
name|tic4x_cpu
operator|==
literal|44
operator|)
operator|||
name|tic4x_idle2
condition|)
name|tic4x_oplevel
operator||=
name|OP_IDLE2
expr_stmt|;
comment|/* Create hash table for mnemonics.  */
name|tic4x_op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Create hash table for asg pseudo.  */
name|tic4x_asg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Add mnemonics to hash table, expanding conditional mnemonics on fly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_insts
condition|;
name|i
operator|++
control|)
name|ok
operator|&=
name|tic4x_inst_add
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tic4x_insts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Create dummy inst to avoid errors accessing end of table.  */
name|tic4x_inst_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|as_fatal
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
expr_stmt|;
comment|/* Add registers to symbol table.  */
name|tic4x_init_regtable
argument_list|()
expr_stmt|;
comment|/* Add predefined symbols to symbol table.  */
name|tic4x_init_symbols
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tic4x_end
parameter_list|()
block|{
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_tic4x
argument_list|,
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|?
name|bfd_mach_tic4x
else|:
name|bfd_mach_tic3x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_indirect_parse
parameter_list|(
name|operand
parameter_list|,
name|indirect
parameter_list|)
name|tic4x_operand_t
modifier|*
name|operand
decl_stmt|;
specifier|const
name|tic4x_indirect_t
modifier|*
name|indirect
decl_stmt|;
block|{
name|char
modifier|*
name|n
init|=
name|indirect
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|operand
operator|->
name|disp
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|n
condition|;
name|n
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|n
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Need to match aux register.  */
name|b
operator|=
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|b
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
return|return
literal|0
return|;
name|operand
operator|->
name|aregno
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|aregno
operator|>=
name|REG_AR0
operator|&&
name|operand
operator|->
name|aregno
operator|<=
name|REG_AR7
condition|)
break|break;
name|as_bad
argument_list|(
literal|"Auxiliary register AR0--AR7 required for indirect"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'d'
case|:
comment|/* Need to match constant for disp.  */
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
comment|/* expr() will die if we don't skip this.  */
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|tic4x_expression
argument_list|(
name|s
argument_list|,
operator|&
name|operand
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
return|return
literal|0
return|;
name|operand
operator|->
name|disp
operator|=
name|operand
operator|->
name|expr
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|disp
operator|<
literal|0
operator|||
name|operand
operator|->
name|disp
operator|>
literal|255
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad displacement %d (require 0--255)\n"
argument_list|,
name|operand
operator|->
name|disp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'y'
case|:
comment|/* Need to match IR0.  */
case|case
literal|'z'
case|:
comment|/* Need to match IR1.  */
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|tic4x_expression
argument_list|(
name|s
argument_list|,
operator|&
name|operand
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_op
operator|!=
name|O_register
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
name|REG_IR0
operator|&&
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
name|REG_IR1
condition|)
block|{
name|as_bad
argument_list|(
literal|"Index register IR0,IR1 required for displacement"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|n
operator|==
literal|'y'
operator|&&
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|==
name|REG_IR0
condition|)
break|break;
if|if
condition|(
operator|*
name|n
operator|==
literal|'z'
operator|&&
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|==
name|REG_IR1
condition|)
break|break;
return|return
literal|0
return|;
case|case
literal|'('
case|:
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
comment|/* No displacement, assume to be 1.  */
block|{
name|operand
operator|->
name|disp
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|n
operator|!=
literal|')'
condition|)
name|n
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|!=
operator|*
name|n
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tic4x_operand_parse
parameter_list|(
name|s
parameter_list|,
name|operand
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|tic4x_operand_t
modifier|*
name|operand
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|operand
operator|->
name|expr
decl_stmt|;
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Get terminator.  */
name|new
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|&&
operator|(
name|entry
operator|=
name|hash_find
argument_list|(
name|tic4x_asg_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|entry
expr_stmt|;
block|}
else|else
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
block|}
name|operand
operator|->
name|mode
operator|=
name|M_UNKNOWN
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
case|case
literal|'%'
case|:
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|as_bad
argument_list|(
literal|"Expecting a register name"
argument_list|)
expr_stmt|;
name|operand
operator|->
name|mode
operator|=
name|M_REGISTER
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
comment|/* Denotes high 16 bits.  */
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|operand
operator|->
name|mode
operator|=
name|M_IMMED
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
condition|)
name|as_bad
argument_list|(
literal|"Number too large"
argument_list|)
expr_stmt|;
comment|/* bignum required */
else|else
block|{
name|tic4x_gen_to_words
argument_list|(
name|generic_floating_point_number
argument_list|,
name|operand
operator|->
name|fwords
argument_list|,
name|S_PRECISION
argument_list|)
expr_stmt|;
name|operand
operator|->
name|mode
operator|=
name|M_IMMED_F
expr_stmt|;
block|}
block|}
comment|/* Allow ori ^foo, ar0 to be equivalent to ldi .hi.foo, ar0  */
comment|/* WARNING : The TI C40 assembler cannot do this.  */
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|operand
operator|->
name|mode
operator|=
name|M_HI
expr_stmt|;
break|break;
block|}
case|case
literal|'#'
case|:
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|operand
operator|->
name|mode
operator|=
name|M_IMMED
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Number too large"
argument_list|)
expr_stmt|;
comment|/* bignum required.  */
else|else
block|{
name|tic4x_gen_to_words
argument_list|(
name|generic_floating_point_number
argument_list|,
name|operand
operator|->
name|fwords
argument_list|,
name|S_PRECISION
argument_list|)
expr_stmt|;
name|operand
operator|->
name|mode
operator|=
name|M_IMMED_F
expr_stmt|;
block|}
block|}
comment|/* Allow ori foo, ar0 to be equivalent to ldi .lo.foo, ar0  */
comment|/* WARNING : The TI C40 assembler cannot do this.  */
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|operand
operator|->
name|mode
operator|=
name|M_IMMED
expr_stmt|;
break|break;
block|}
else|else
name|as_bad
argument_list|(
literal|"Expecting a constant value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
endif|#
directive|endif
case|case
literal|'@'
case|:
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
operator|++
name|input_line_pointer
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|exp
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
name|as_bad
argument_list|(
literal|"Bad direct addressing construct %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Direct value of %ld is not suitable"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|operand
operator|->
name|mode
operator|=
name|M_DIRECT
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_indirects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|tic4x_indirect_parse
argument_list|(
name|operand
argument_list|,
operator|&
name|tic4x_indirects
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|tic4x_num_indirects
condition|)
block|{
name|operand
operator|->
name|mode
operator|=
name|M_INDIRECT
expr_stmt|;
comment|/* Indirect addressing mode number.  */
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|=
name|tic4x_indirects
index|[
name|i
index|]
operator|.
name|modn
expr_stmt|;
comment|/* Convert *+ARn(0) to *ARn etc.  Maybe we should 	     squeal about silly ones?  */
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|<
literal|0x08
operator|&&
operator|!
name|operand
operator|->
name|disp
condition|)
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|=
literal|0x18
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Unknown indirect addressing mode"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|operand
operator|->
name|mode
operator|=
name|M_IMMED
expr_stmt|;
comment|/* Assume immediate.  */
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|tic4x_expression
argument_list|(
name|input_line_pointer
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|know
argument_list|(
name|exp
operator|->
name|X_add_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|exp
operator|->
name|X_op_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|operand
operator|->
name|mode
operator|=
name|M_REGISTER
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"Number too large"
argument_list|)
expr_stmt|;
comment|/* bignum required.  */
else|else
block|{
name|tic4x_gen_to_words
argument_list|(
name|generic_floating_point_number
argument_list|,
name|operand
operator|->
name|fwords
argument_list|,
name|S_PRECISION
argument_list|)
expr_stmt|;
name|operand
operator|->
name|mode
operator|=
name|M_IMMED_F
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|TIC4X_ALT_SYNTAX
comment|/* Allow ldi foo, ar0 to be equivalent to ldi @foo, ar0.  */
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|operand
operator|->
name|mode
operator|=
name|M_DIRECT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_operands_match
parameter_list|(
name|inst
parameter_list|,
name|insn
parameter_list|,
name|check
parameter_list|)
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
name|tic4x_insn_t
modifier|*
name|insn
decl_stmt|;
name|int
name|check
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|args
init|=
name|inst
operator|->
name|args
decl_stmt|;
name|unsigned
name|long
name|opcode
init|=
name|inst
operator|->
name|opcode
decl_stmt|;
name|int
name|num_operands
init|=
name|insn
operator|->
name|num_operands
decl_stmt|;
name|tic4x_operand_t
modifier|*
name|operand
init|=
name|insn
operator|->
name|operands
decl_stmt|;
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|operand
operator|->
name|expr
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the      operands match.       If an operand matches, we modify insn or opcode appropriately,      and do a "continue".  If an operand fails to match, we "break".  */
name|insn
operator|->
name|nchars
operator|=
literal|4
expr_stmt|;
comment|/* Instructions always 4 bytes.  */
name|insn
operator|->
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
name|insn
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'\0'
condition|)
block|{
name|insn
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
return|return
name|num_operands
operator|==
literal|0
return|;
block|}
for|for
control|(
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* End of args.  */
if|if
condition|(
name|num_operands
operator|==
literal|1
condition|)
block|{
name|insn
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
comment|/* Too many operands.  */
case|case
literal|'#'
case|:
comment|/* This is only used for ldp.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_DIRECT
operator|&&
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
condition|)
break|break;
comment|/* While this looks like a direct addressing mode, we actually 	     use an immediate mode form of ldiu or ldpk instruction.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|65535
operator|)
operator|||
operator|(
name|IS_CPU_TIC3X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|255
operator|)
condition|)
block|{
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Immediate value of %ld is too large for ldf"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Not direct (dp) addressing.  */
case|case
literal|'@'
case|:
comment|/* direct.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_DIRECT
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Store only the 16 LSBs of the number.  */
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Not direct addressing.  */
case|case
literal|'A'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_AR0
operator|&&
name|reg
operator|<=
name|REG_AR7
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_AR0
argument_list|,
literal|24
argument_list|,
literal|22
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Destination register must be ARn"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'B'
case|:
comment|/* Unsigned integer immediate.  */
comment|/* Allow br label or br @label.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
operator|&&
name|operand
operator|->
name|mode
operator|!=
name|M_DIRECT
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
block|{
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Immediate value of %ld is too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
name|insn
operator|->
name|pcrel
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_24
expr_stmt|;
name|insn
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
block|}
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_INDIRECT
condition|)
break|break;
comment|/* Require either *+ARn(disp) or *ARn.  */
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
literal|0x18
condition|)
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Invalid indirect addressing mode"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|aregno
operator|-
name|REG_AR0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|disp
argument_list|,
literal|7
argument_list|,
literal|3
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|mode
operator|==
name|M_REGISTER
operator|)
condition|)
break|break;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|mode
operator|==
name|M_REGISTER
operator|)
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
operator|)
operator|||
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|reg
operator|>=
name|REG_R8
operator|&&
name|reg
operator|<=
name|REG_R11
operator|)
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be Rn"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'F'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED_F
operator|&&
operator|!
operator|(
name|operand
operator|->
name|mode
operator|==
name|M_IMMED
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|)
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED_F
condition|)
block|{
comment|/* OK, we 've got something like cmpf 0, r0 	         Why can't they stick in a bloody decimal point ?!  */
name|char
name|string
index|[
literal|16
index|]
decl_stmt|;
comment|/* Create floating point number string.  */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d.0"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|tic4x_atof
argument_list|(
name|string
argument_list|,
literal|'s'
argument_list|,
name|operand
operator|->
name|fwords
argument_list|)
expr_stmt|;
block|}
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|fwords
index|[
literal|0
index|]
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|8
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
operator|)
operator|||
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|reg
operator|>=
name|REG_R8
operator|&&
name|reg
operator|<=
name|REG_R11
operator|)
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|15
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be Rn"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'H'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_R0
argument_list|,
literal|18
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be R0--R7"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'i'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|==
name|M_REGISTER
operator|&&
name|tic4x_oplevel
operator|&
name|OP_ENH
condition|)
block|{
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
literal|7
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fallthrough */
case|case
literal|'I'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_INDIRECT
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|disp
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|disp
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Invalid indirect addressing mode displacement %d"
argument_list|,
name|operand
operator|->
name|disp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|aregno
operator|-
name|REG_AR0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|expr
operator|.
name|X_add_number
argument_list|,
literal|7
argument_list|,
literal|3
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'j'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|==
name|M_REGISTER
operator|&&
name|tic4x_oplevel
operator|&
name|OP_ENH
condition|)
block|{
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|12
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
literal|7
argument_list|,
literal|15
argument_list|,
literal|13
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fallthrough */
case|case
literal|'J'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_INDIRECT
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|disp
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|disp
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Invalid indirect addressing mode displacement %d"
argument_list|,
name|operand
operator|->
name|disp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|aregno
operator|-
name|REG_AR0
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|expr
operator|.
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|11
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'K'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_R0
argument_list|,
literal|21
argument_list|,
literal|19
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be R0--R7"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'L'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_R0
argument_list|,
literal|24
argument_list|,
literal|22
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be R0--R7"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'M'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_R2
operator|||
name|reg
operator|==
name|REG_R3
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_R2
argument_list|,
literal|22
argument_list|,
literal|22
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Destination register must be R2 or R3"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'N'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_R0
operator|||
name|reg
operator|==
name|REG_R1
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_R0
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Destination register must be R0 or R1"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'O'
case|:
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_INDIRECT
condition|)
break|break;
comment|/* Require either *+ARn(disp) or *ARn.  */
if|if
condition|(
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|expr
operator|.
name|X_add_number
operator|!=
literal|0x18
condition|)
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Invalid indirect addressing mode"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|aregno
operator|-
name|REG_AR0
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|disp
argument_list|,
literal|15
argument_list|,
literal|11
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
comment|/* PC relative displacement.  */
comment|/* Allow br label or br @label.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
operator|&&
name|operand
operator|->
name|mode
operator|!=
name|M_DIRECT
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|>=
operator|-
literal|32768
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|32767
condition|)
block|{
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Displacement value of %ld is too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
name|insn
operator|->
name|pcrel
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
operator|)
operator|||
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|reg
operator|>=
name|REG_R8
operator|&&
name|reg
operator|<=
name|REG_R11
operator|)
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be Rn"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'R'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>=
name|REG_R0
operator|&&
name|reg
operator|<=
name|REG_R7
operator|)
operator|||
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
name|reg
operator|>=
name|REG_R8
operator|&&
name|reg
operator|<=
name|REG_R11
operator|)
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be Rn"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'S'
case|:
comment|/* Short immediate int.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
operator|&&
name|operand
operator|->
name|mode
operator|!=
name|M_HI
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Floating point number not valid in expression"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|>=
operator|-
literal|32768
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|65535
condition|)
block|{
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Signed immediate value %ld too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|mode
operator|==
name|M_HI
condition|)
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
block|}
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
block|}
comment|/* Handle cases like ldi foo - $, ar0  where foo 	     is a forward reference.  Perhaps we should check 	     for X_op == O_symbol and disallow things like 	     ldi foo, ar0.  */
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* 5-bit immediate value for tic4x stik.  */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|16
operator|&&
name|exp
operator|->
name|X_add_number
operator|>=
operator|-
literal|16
condition|)
block|{
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Immediate value of %ld is too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
comment|/* No relocations allowed.  */
case|case
literal|'U'
case|:
comment|/* Unsigned integer immediate.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
operator|&&
name|operand
operator|->
name|mode
operator|!=
name|M_HI
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|&&
name|exp
operator|->
name|X_add_number
operator|>=
literal|0
condition|)
block|{
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Unsigned immediate value %ld too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|mode
operator|==
name|M_HI
condition|)
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
else|else
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
block|}
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
case|case
literal|'V'
case|:
comment|/* Trap numbers (immediate field).  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|512
operator|&&
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
block|{
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|32
operator|&&
name|IS_CPU_TIC3X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
block|{
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
operator||
literal|0x20
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Immediate value of %ld is too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
comment|/* No relocations allowed.  */
case|case
literal|'W'
case|:
comment|/* Short immediate int (0--7).  */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
break|break;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_IMMED
condition|)
break|break;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Floating point number not valid in expression"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|>=
operator|-
literal|256
operator|&&
name|exp
operator|->
name|X_add_number
operator|<=
literal|127
condition|)
block|{
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|exp
operator|->
name|X_add_number
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Immediate value %ld too large"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|insn
operator|->
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
name|insn
operator|->
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
comment|/* Expansion register for tic4x.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_IVTP
operator|&&
name|reg
operator|<=
name|REG_TVTP
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_IVTP
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be ivtp or tvtp"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'Y'
case|:
comment|/* Address register for tic4x lda.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_AR0
operator|&&
name|reg
operator|<=
name|REG_SP
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be address register"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'Z'
case|:
comment|/* Expansion register for tic4x.  */
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_REGISTER
condition|)
break|break;
name|reg
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|REG_IVTP
operator|&&
name|reg
operator|<=
name|REG_TVTP
condition|)
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|reg
operator|-
name|REG_IVTP
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|check
condition|)
name|as_bad
argument_list|(
literal|"Register must be ivtp or tvtp"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_INDIRECT
condition|)
break|break;
name|INSERTS
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|disp
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|aregno
operator|-
name|REG_AR0
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|INSERTU
argument_list|(
name|opcode
argument_list|,
name|operand
operator|->
name|expr
operator|.
name|X_add_number
argument_list|,
literal|15
argument_list|,
literal|11
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'|'
case|:
comment|/* treat as `,' if have ldi_ldi form.  */
if|if
condition|(
name|insn
operator|->
name|parallel
condition|)
block|{
if|if
condition|(
operator|--
name|num_operands
operator|<
literal|0
condition|)
break|break;
comment|/* Too few operands.  */
name|operand
operator|++
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|mode
operator|!=
name|M_PARALLEL
condition|)
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|','
case|:
comment|/* Another operand.  */
if|if
condition|(
operator|--
name|num_operands
operator|<
literal|0
condition|)
break|break;
comment|/* Too few operands.  */
name|operand
operator|++
expr_stmt|;
name|exp
operator|=
operator|&
name|operand
operator|->
name|expr
expr_stmt|;
continue|continue;
case|case
literal|';'
case|:
comment|/* Another optional operand.  */
if|if
condition|(
name|num_operands
operator|==
literal|1
operator|||
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|==
name|M_PARALLEL
condition|)
continue|continue;
if|if
condition|(
operator|--
name|num_operands
operator|<
literal|0
condition|)
break|break;
comment|/* Too few operands.  */
name|operand
operator|++
expr_stmt|;
name|exp
operator|=
operator|&
name|operand
operator|->
name|expr
expr_stmt|;
continue|continue;
default|default:
name|BAD_CASE
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_insn_check
parameter_list|(
name|insn
parameter_list|)
name|tic4x_insn_t
modifier|*
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"lda"
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|num_operands
operator|<
literal|2
operator|||
name|insn
operator|->
name|num_operands
operator|>
literal|2
condition|)
name|as_fatal
argument_list|(
literal|"Illegal internal LDA insn definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|mode
operator|==
name|M_REGISTER
operator|&&
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|mode
operator|==
name|M_REGISTER
operator|&&
name|insn
operator|->
name|operands
index|[
literal|0
index|]
operator|.
name|expr
operator|.
name|X_add_number
operator|==
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|expr
operator|.
name|X_add_number
condition|)
name|as_bad
argument_list|(
literal|"Source and destination register should not be equal"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldi_ldi"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldi1_ldi2"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldi2_ldi1"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldf_ldf"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldf1_ldf2"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldf2_ldf1"
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|num_operands
operator|<
literal|4
operator|&&
name|insn
operator|->
name|num_operands
operator|>
literal|5
condition|)
name|as_fatal
argument_list|(
literal|"Illegal internal %s insn definition"
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|mode
operator|==
name|M_REGISTER
operator|&&
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|num_operands
operator|-
literal|1
index|]
operator|.
name|mode
operator|==
name|M_REGISTER
operator|&&
name|insn
operator|->
name|operands
index|[
literal|1
index|]
operator|.
name|expr
operator|.
name|X_add_number
operator|==
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|num_operands
operator|-
literal|1
index|]
operator|.
name|expr
operator|.
name|X_add_number
condition|)
name|as_warn
argument_list|(
literal|"Equal parallell destination registers, one result will be discarded"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_insn_output
parameter_list|(
name|insn
parameter_list|)
name|tic4x_insn_t
modifier|*
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Grab another fragment for opcode.  */
name|dst
operator|=
name|frag_more
argument_list|(
name|insn
operator|->
name|nchars
argument_list|)
expr_stmt|;
comment|/* Put out opcode word as a series of bytes in little endian order.  */
name|md_number_to_chars
argument_list|(
name|dst
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|insn
operator|->
name|nchars
argument_list|)
expr_stmt|;
comment|/* Put out the symbol-dependent stuff.  */
if|if
condition|(
name|insn
operator|->
name|reloc
operator|!=
name|NO_RELOC
condition|)
block|{
comment|/* Where is the offset into the fragment for this instruction.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|dst
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
comment|/* where */
name|insn
operator|->
name|nchars
argument_list|,
comment|/* size */
operator|&
name|insn
operator|->
name|exp
argument_list|,
name|insn
operator|->
name|pcrel
argument_list|,
name|insn
operator|->
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the operands.  */
end_comment

begin_function
name|int
name|tic4x_operands_parse
parameter_list|(
name|s
parameter_list|,
name|operands
parameter_list|,
name|num_operands
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|tic4x_operand_t
modifier|*
name|operands
decl_stmt|;
name|int
name|num_operands
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
name|num_operands
return|;
do|do
name|s
operator|=
name|tic4x_operand_parse
argument_list|(
name|s
argument_list|,
operator|&
name|operands
index|[
name|num_operands
operator|++
index|]
argument_list|)
expr_stmt|;
do|while
condition|(
name|num_operands
operator|<
name|TIC4X_OPERANDS_MAX
operator|&&
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
do|;
if|if
condition|(
name|num_operands
operator|>
name|TIC4X_OPERANDS_MAX
condition|)
block|{
name|as_bad
argument_list|(
literal|"Too many operands scanned"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|num_operands
return|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction.  Its label has already been handled    by the generic front end.  We just parse mnemonic and operands, and    produce the bytes of data and relocation.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|parsed
init|=
literal|0
decl_stmt|;
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
comment|/* Instruction template.  */
name|tic4x_inst_t
modifier|*
name|first_inst
decl_stmt|;
comment|/* Scan for parallel operators */
if|if
condition|(
name|str
condition|)
block|{
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'|'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|parallel
condition|)
block|{
name|as_bad
argument_list|(
literal|"Parallel opcode cannot contain more than two instructions"
argument_list|)
expr_stmt|;
name|insn
operator|->
name|parallel
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Lets take care of the first part of the parallel insn */
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
name|md_assemble
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|insn
operator|->
name|parallel
operator|=
literal|1
expr_stmt|;
name|str
operator|=
operator|++
name|s
expr_stmt|;
comment|/* .. and let the second run though here */
block|}
block|}
if|if
condition|(
name|str
operator|&&
name|insn
operator|->
name|parallel
condition|)
block|{
comment|/* Find mnemonic (second part of parallel instruction).  */
name|s
operator|=
name|str
expr_stmt|;
comment|/* Skip past instruction mnemonic.  */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
comment|/* Null terminate for hash_find.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* and skip past null.  */
name|strcat
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|TIC4X_NAME_MAX
operator|-
name|strlen
argument_list|(
name|insn
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|->
name|operands
index|[
name|insn
operator|->
name|num_operands
operator|++
index|]
operator|.
name|mode
operator|=
name|M_PARALLEL
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|tic4x_operands_parse
argument_list|(
name|s
argument_list|,
name|insn
operator|->
name|operands
argument_list|,
name|insn
operator|->
name|num_operands
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|insn
operator|->
name|parallel
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|insn
operator|->
name|num_operands
operator|=
name|i
expr_stmt|;
name|parsed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|->
name|in_use
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|->
name|inst
operator|=
operator|(
expr|struct
name|tic4x_inst
operator|*
operator|)
name|hash_find
argument_list|(
name|tic4x_op_hash
argument_list|,
name|insn
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode `%s'."
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn
operator|->
name|parallel
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|inst
operator|=
name|insn
operator|->
name|inst
expr_stmt|;
name|first_inst
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|ok
operator|=
name|tic4x_operands_match
argument_list|(
name|inst
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|first_inst
condition|)
name|first_inst
operator|=
name|inst
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|ok
operator|&&
operator|!
name|strcmp
argument_list|(
name|inst
operator|->
name|name
argument_list|,
name|inst
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|&&
name|inst
operator|++
condition|)
do|;
if|if
condition|(
name|ok
operator|>
literal|0
condition|)
block|{
name|tic4x_insn_check
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tic4x_insn_output
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|first_inst
condition|)
name|tic4x_operands_match
argument_list|(
name|first_inst
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
literal|"Invalid operands for %s"
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Invalid instruction %s"
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|&&
operator|!
name|parsed
condition|)
block|{
comment|/* Find mnemonic.  */
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
comment|/* Skip past instruction mnemonic.  */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
comment|/* Null terminate for hash_find.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* and skip past null.  */
name|strncpy
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|TIC4X_NAME_MAX
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|tic4x_operands_parse
argument_list|(
name|s
argument_list|,
name|insn
operator|->
name|operands
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|insn
operator|->
name|inst
operator|=
name|NULL
expr_stmt|;
comment|/* Flag that error occurred.  */
name|insn
operator|->
name|parallel
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|insn
operator|->
name|num_operands
operator|=
name|i
expr_stmt|;
name|insn
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|insn
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|parallel
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tic4x_cleanup
parameter_list|()
block|{
if|if
condition|(
name|insn
operator|->
name|in_use
condition|)
name|md_assemble
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|int
name|ieee
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* .single */
case|case
literal|'S'
case|:
name|ieee
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* .double */
case|case
literal|'D'
case|:
case|case
literal|'f'
case|:
comment|/* .float or .single */
case|case
literal|'F'
case|:
name|ieee
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|2
expr_stmt|;
comment|/* 1 32-bit word */
break|break;
case|case
literal|'i'
case|:
comment|/* .ieee */
case|case
literal|'I'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
name|ieee
operator|=
literal|1
expr_stmt|;
name|type
operator|=
literal|'f'
expr_stmt|;
comment|/* Rewrite type to be usable by atof_ieee() */
break|break;
case|case
literal|'e'
case|:
comment|/* .ldouble */
case|case
literal|'E'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
comment|/* 2 32-bit words */
name|ieee
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to md_atof()"
return|;
block|}
if|if
condition|(
name|ieee
condition|)
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|tic4x_atof
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      little endian byte order.  */
comment|/* SES: However it is required to put the words (32-bits) out in the      correct order, hence we write 2 and 2 littlenums in little endian      order, while we keep the original order on successive words. */
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|wordP
operator|<
operator|(
name|words
operator|+
name|prec
operator|)
condition|;
name|wordP
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|wordP
operator|<
operator|(
name|words
operator|+
name|prec
operator|-
literal|1
operator|)
condition|)
comment|/* Dump wordP[1] (if we have one) */
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|wordP
index|[
literal|1
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
comment|/* Dump wordP[0] */
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|wordP
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|value
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|value
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|valueT
name|val
init|=
operator|*
name|value
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_HI16
case|:
name|val
operator|>>=
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|val
operator|&=
literal|0xffff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
case|case
name|BFD_RELOC_24
case|:
case|case
name|BFD_RELOC_24_PCREL
case|:
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_HI16
case|:
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|NO_RELOC
case|:
default|default:
name|as_bad
argument_list|(
literal|"Bad relocation type: 0x%02x"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for tic4x.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"md_convert_frag"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for tic4x.  */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"md_create_short_jmp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for tic4x.  */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"md_create_long_jump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should never be called for tic4x.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"md_estimate_size_before_relax\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CPU
case|:
comment|/* cpu brand */
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
literal|'c'
condition|)
name|arg
operator|++
expr_stmt|;
name|tic4x_cpu
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CPU_TIC3X
argument_list|(
name|tic4x_cpu
argument_list|)
operator|&&
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_cpu
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"Unsupported processor generation %d"
argument_list|,
name|tic4x_cpu
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_REV
case|:
comment|/* cpu revision */
name|tic4x_revision
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|as_warn
argument_list|(
literal|"Option -b is depreciated, please use -mbig"
argument_list|)
expr_stmt|;
case|case
name|OPTION_BIG
case|:
comment|/* big model */
name|tic4x_big_model
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|as_warn
argument_list|(
literal|"Option -p is depreciated, please use -mmemparm"
argument_list|)
expr_stmt|;
case|case
name|OPTION_MEMPARM
case|:
comment|/* push args */
name|tic4x_reg_args
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|as_warn
argument_list|(
literal|"Option -r is depreciated, please use -mregparm"
argument_list|)
expr_stmt|;
case|case
name|OPTION_REGPARM
case|:
comment|/* register args */
name|tic4x_reg_args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|as_warn
argument_list|(
literal|"Option -s is depreciated, please use -msmall"
argument_list|)
expr_stmt|;
case|case
name|OPTION_SMALL
case|:
comment|/* small model */
name|tic4x_big_model
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_IDLE2
case|:
name|tic4x_idle2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LOWPOWER
case|:
name|tic4x_lowpower
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_ENHANCED
case|:
name|tic4x_enhanced
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\nTIC4X options:\n"
literal|"  -mcpu=CPU  -mCPU        select architecture variant. CPU can be:\n"
literal|"                            30 - TMS320C30\n"
literal|"                            31 - TMS320C31, TMS320LC31\n"
literal|"                            32 - TMS320C32\n"
literal|"                            33 - TMS320VC33\n"
literal|"                            40 - TMS320C40\n"
literal|"                            44 - TMS320C44\n"
literal|"  -mrev=REV               set cpu hardware revision (integer numbers).\n"
literal|"                          Combinations of -mcpu and -mrev will enable/disable\n"
literal|"                          the appropriate options (-midle2, -mlowpower and\n"
literal|"                          -menhanced) according to the selected type\n"
literal|"  -mbig                   select big memory model\n"
literal|"  -msmall                 select small memory model (default)\n"
literal|"  -mregparm               select register parameters (default)\n"
literal|"  -mmemparm               select memory parameters\n"
literal|"  -midle2                 enable IDLE2 support\n"
literal|"  -mlowpower              enable LOPOWER and MAXSPEED support\n"
literal|"  -menhanced              enable enhanced opcode support\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when a line is unrecognized.  This is used to handle    definitions of TI C3x tools style local labels $n where n is a single    decimal digit.  */
end_comment

begin_function
name|int
name|tic4x_unrecognized_line
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|lab
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'$'
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Let's allow multiple digit local labels.  */
name|lab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|lab
operator|=
name|lab
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Label \"$%d\" redefined"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|define_dollar_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle local labels peculiar to us referred to in an expression.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Look for local labels of the form $n.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|ISDIGIT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|name
operator|+
literal|1
decl_stmt|;
name|int
name|lab
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
block|{
name|lab
operator|=
name|lab
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|symbolP
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary---do we need this?  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte (i.e., 32-bit) alignment is fine?  */
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_pc_offset
parameter_list|(
name|op
parameter_list|)
name|unsigned
name|int
name|op
decl_stmt|;
block|{
comment|/* Determine the PC offset for a C[34]x instruction.      This could be simplified using some boolean algebra      but at the expense of readability.  */
switch|switch
condition|(
name|op
operator|>>
literal|24
condition|)
block|{
case|case
literal|0x60
case|:
comment|/* br */
case|case
literal|0x62
case|:
comment|/* call  (C4x) */
case|case
literal|0x64
case|:
comment|/* rptb  (C4x) */
return|return
literal|1
return|;
case|case
literal|0x61
case|:
comment|/* brd */
case|case
literal|0x63
case|:
comment|/* laj */
case|case
literal|0x65
case|:
comment|/* rptbd (C4x) */
return|return
literal|3
return|;
case|case
literal|0x66
case|:
comment|/* swi */
case|case
literal|0x67
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|op
operator|&
literal|0xffe00000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x6a0
case|:
comment|/* bB */
case|case
literal|0x720
case|:
comment|/* callB */
case|case
literal|0x740
case|:
comment|/* trapB */
return|return
literal|1
return|;
case|case
literal|0x6a2
case|:
comment|/* bBd */
case|case
literal|0x6a6
case|:
comment|/* bBat */
case|case
literal|0x6aa
case|:
comment|/* bBaf */
case|case
literal|0x722
case|:
comment|/* lajB */
case|case
literal|0x748
case|:
comment|/* latB */
case|case
literal|0x798
case|:
comment|/* rptbd */
return|return
literal|3
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|op
operator|&
literal|0xfe200000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x6e0
case|:
comment|/* dbB */
return|return
literal|1
return|;
case|case
literal|0x6e2
case|:
comment|/* dbBd */
return|return
literal|3
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    With the C3x we have the following:    DBcond,  Bcond   disp + PC + 1 => PC    DBcondD, BcondD  disp + PC + 3 => PC  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|op
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|op
operator|=
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
operator|>>
literal|2
operator|)
operator|+
name|tic4x_pc_offset
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fill the alignment area with NOP's on .text, unless fill-data    was specified. */
end_comment

begin_function
name|int
name|tic4x_do_align
parameter_list|(
name|alignment
parameter_list|,
name|fill
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|int
name|alignment
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|fill
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|len
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|nop
init|=
name|TIC_NOP_OPCODE
decl_stmt|;
comment|/* Because we are talking lwords, not bytes, adjust alignment to do words */
name|alignment
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|alignment
operator|!=
literal|0
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|fill
operator|==
name|NULL
condition|)
block|{
comment|/*if (subseg_text_p (now_seg))*/
comment|/* FIXME: doesn't work for .text for some reason */
name|frag_align_pattern
argument_list|(
name|alignment
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|nop
argument_list|,
sizeof|sizeof
argument_list|(
name|nop
argument_list|)
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/*else             frag_align (alignment, 0, max);*/
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|frag_align
argument_list|(
name|alignment
argument_list|,
operator|*
name|fill
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align_pattern
argument_list|(
name|alignment
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Return 1 to skip the default alignment function */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look for and remove parallel instruction operator ||.  */
end_comment

begin_function
name|void
name|tic4x_start_line
parameter_list|()
block|{
name|char
modifier|*
name|s
init|=
name|input_line_pointer
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* If parallel instruction prefix found at start of line, skip it.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'|'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|in_use
condition|)
block|{
name|insn
operator|->
name|parallel
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|' '
expr_stmt|;
comment|/* So line counters get bumped.  */
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Write out the previous insn here */
if|if
condition|(
name|insn
operator|->
name|in_use
condition|)
name|md_assemble
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|address
operator|/=
name|OCTETS_PER_BYTE
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Reloc %d not supported by object file format"
argument_list|,
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_HI16
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

