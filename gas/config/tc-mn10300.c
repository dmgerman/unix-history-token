begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mn10300.c -- Assembler code for the Matsushita 10300    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006, 2007 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mn10300.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|reg_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The plus values for the bCC and fBCC instructions in the table below      are because the branch instruction is translated into a jump      instruction that is now +2 or +3 bytes further on in memory, and the      correct size of jump instruction must be selected.  */
comment|/* bCC relaxing  */
block|{
literal|0x7f
block|,
operator|-
literal|0x80
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|0x7fff
operator|+
literal|2
block|,
operator|-
literal|0x8000
operator|+
literal|2
block|,
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* bCC relaxing (uncommon cases for 3byte length instructions)  */
block|{
literal|0x7f
block|,
operator|-
literal|0x80
block|,
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0x7fff
operator|+
literal|3
block|,
operator|-
literal|0x8000
operator|+
literal|3
block|,
literal|6
block|,
literal|5
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|8
block|,
literal|0
block|}
block|,
comment|/* call relaxing  */
block|{
literal|0x7fff
block|,
operator|-
literal|0x8000
block|,
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* calls relaxing  */
block|{
literal|0x7fff
block|,
operator|-
literal|0x8000
block|,
literal|4
block|,
literal|9
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* jmp relaxing  */
block|{
literal|0x7f
block|,
operator|-
literal|0x80
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|0x7fff
block|,
operator|-
literal|0x8000
block|,
literal|3
block|,
literal|12
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* fbCC relaxing  */
block|{
literal|0x7f
block|,
operator|-
literal|0x80
block|,
literal|3
block|,
literal|14
block|}
block|,
block|{
literal|0x7fff
operator|+
literal|3
block|,
operator|-
literal|0x8000
operator|+
literal|3
block|,
literal|6
block|,
literal|15
block|}
block|,
block|{
literal|0x7fffffff
block|,
operator|-
literal|0x80000000
block|,
literal|8
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mn10300_insert_operand
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|,
specifier|const
expr|struct
name|mn10300_operand
operator|*
operator|,
name|offsetT
operator|,
name|char
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|check_operand
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
expr|struct
name|mn10300_operand
operator|*
operator|,
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_name_search
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|reg_name
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|data_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|address_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|other_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|r_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xr_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Set linkrelax here to avoid fixups in most sections.  */
end_comment

begin_decl_stmt
name|int
name|linkrelax
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_machine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fixups.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|(5)
end_define

begin_struct
struct|struct
name|mn10300_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mn10300_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We must store the value of each register operand so that we can    verify that certain registers do not match.  */
end_comment

begin_decl_stmt
name|int
name|mn10300_reg_operands
index|[
name|MN10300_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"am30"
block|,
name|set_arch_mach
block|,
name|AM30
block|}
block|,
block|{
literal|"am33"
block|,
name|set_arch_mach
block|,
name|AM33
block|}
block|,
block|{
literal|"am33_2"
block|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|set_arch_mach
block|,
name|AM33_2
block|}
block|,
block|{
literal|"mn10300"
block|,
name|set_arch_mach
block|,
name|MN103
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAVE_AM33_2
value|(current_machine == AM33_2)
end_define

begin_define
define|#
directive|define
name|HAVE_AM33
value|(current_machine == AM33 || HAVE_AM33_2)
end_define

begin_define
define|#
directive|define
name|HAVE_AM30
value|(current_machine == AM30)
end_define

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mn10300_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|data_registers
index|[]
init|=
block|{
block|{
literal|"d0"
block|,
literal|0
block|}
block|,
block|{
literal|"d1"
block|,
literal|1
block|}
block|,
block|{
literal|"d2"
block|,
literal|2
block|}
block|,
block|{
literal|"d3"
block|,
literal|3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DATA_REG_NAME_CNT
define|\
value|(sizeof (data_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|address_registers
index|[]
init|=
block|{
block|{
literal|"a0"
block|,
literal|0
block|}
block|,
block|{
literal|"a1"
block|,
literal|1
block|}
block|,
block|{
literal|"a2"
block|,
literal|2
block|}
block|,
block|{
literal|"a3"
block|,
literal|3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDRESS_REG_NAME_CNT
define|\
value|(sizeof (address_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|r_registers
index|[]
init|=
block|{
block|{
literal|"a0"
block|,
literal|8
block|}
block|,
block|{
literal|"a1"
block|,
literal|9
block|}
block|,
block|{
literal|"a2"
block|,
literal|10
block|}
block|,
block|{
literal|"a3"
block|,
literal|11
block|}
block|,
block|{
literal|"d0"
block|,
literal|12
block|}
block|,
block|{
literal|"d1"
block|,
literal|13
block|}
block|,
block|{
literal|"d2"
block|,
literal|14
block|}
block|,
block|{
literal|"d3"
block|,
literal|15
block|}
block|,
block|{
literal|"e0"
block|,
literal|0
block|}
block|,
block|{
literal|"e1"
block|,
literal|1
block|}
block|,
block|{
literal|"e10"
block|,
literal|10
block|}
block|,
block|{
literal|"e11"
block|,
literal|11
block|}
block|,
block|{
literal|"e12"
block|,
literal|12
block|}
block|,
block|{
literal|"e13"
block|,
literal|13
block|}
block|,
block|{
literal|"e14"
block|,
literal|14
block|}
block|,
block|{
literal|"e15"
block|,
literal|15
block|}
block|,
block|{
literal|"e2"
block|,
literal|2
block|}
block|,
block|{
literal|"e3"
block|,
literal|3
block|}
block|,
block|{
literal|"e4"
block|,
literal|4
block|}
block|,
block|{
literal|"e5"
block|,
literal|5
block|}
block|,
block|{
literal|"e6"
block|,
literal|6
block|}
block|,
block|{
literal|"e7"
block|,
literal|7
block|}
block|,
block|{
literal|"e8"
block|,
literal|8
block|}
block|,
block|{
literal|"e9"
block|,
literal|9
block|}
block|,
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|R_REG_NAME_CNT
define|\
value|(sizeof (r_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|xr_registers
index|[]
init|=
block|{
block|{
literal|"mcrh"
block|,
literal|2
block|}
block|,
block|{
literal|"mcrl"
block|,
literal|3
block|}
block|,
block|{
literal|"mcvf"
block|,
literal|4
block|}
block|,
block|{
literal|"mdrq"
block|,
literal|1
block|}
block|,
block|{
literal|"sp"
block|,
literal|0
block|}
block|,
block|{
literal|"xr0"
block|,
literal|0
block|}
block|,
block|{
literal|"xr1"
block|,
literal|1
block|}
block|,
block|{
literal|"xr10"
block|,
literal|10
block|}
block|,
block|{
literal|"xr11"
block|,
literal|11
block|}
block|,
block|{
literal|"xr12"
block|,
literal|12
block|}
block|,
block|{
literal|"xr13"
block|,
literal|13
block|}
block|,
block|{
literal|"xr14"
block|,
literal|14
block|}
block|,
block|{
literal|"xr15"
block|,
literal|15
block|}
block|,
block|{
literal|"xr2"
block|,
literal|2
block|}
block|,
block|{
literal|"xr3"
block|,
literal|3
block|}
block|,
block|{
literal|"xr4"
block|,
literal|4
block|}
block|,
block|{
literal|"xr5"
block|,
literal|5
block|}
block|,
block|{
literal|"xr6"
block|,
literal|6
block|}
block|,
block|{
literal|"xr7"
block|,
literal|7
block|}
block|,
block|{
literal|"xr8"
block|,
literal|8
block|}
block|,
block|{
literal|"xr9"
block|,
literal|9
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XR_REG_NAME_CNT
define|\
value|(sizeof (xr_registers) / sizeof (struct reg_name))
end_define

begin_comment
comment|/* We abuse the `value' field, that would be otherwise unused, to    encode the architecture on which (access to) the register was    introduced.  FIXME: we should probably warn when we encounter a    register name when assembling for an architecture that doesn't    support it, before parsing it as a symbol name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|other_registers
index|[]
init|=
block|{
block|{
literal|"epsw"
block|,
name|AM33
block|}
block|,
block|{
literal|"mdr"
block|,
literal|0
block|}
block|,
block|{
literal|"pc"
block|,
name|AM33
block|}
block|,
block|{
literal|"psw"
block|,
literal|0
block|}
block|,
block|{
literal|"sp"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OTHER_REG_NAME_CNT
define|\
value|(sizeof (other_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|float_registers
index|[]
init|=
block|{
block|{
literal|"fs0"
block|,
literal|0
block|}
block|,
block|{
literal|"fs1"
block|,
literal|1
block|}
block|,
block|{
literal|"fs10"
block|,
literal|10
block|}
block|,
block|{
literal|"fs11"
block|,
literal|11
block|}
block|,
block|{
literal|"fs12"
block|,
literal|12
block|}
block|,
block|{
literal|"fs13"
block|,
literal|13
block|}
block|,
block|{
literal|"fs14"
block|,
literal|14
block|}
block|,
block|{
literal|"fs15"
block|,
literal|15
block|}
block|,
block|{
literal|"fs16"
block|,
literal|16
block|}
block|,
block|{
literal|"fs17"
block|,
literal|17
block|}
block|,
block|{
literal|"fs18"
block|,
literal|18
block|}
block|,
block|{
literal|"fs19"
block|,
literal|19
block|}
block|,
block|{
literal|"fs2"
block|,
literal|2
block|}
block|,
block|{
literal|"fs20"
block|,
literal|20
block|}
block|,
block|{
literal|"fs21"
block|,
literal|21
block|}
block|,
block|{
literal|"fs22"
block|,
literal|22
block|}
block|,
block|{
literal|"fs23"
block|,
literal|23
block|}
block|,
block|{
literal|"fs24"
block|,
literal|24
block|}
block|,
block|{
literal|"fs25"
block|,
literal|25
block|}
block|,
block|{
literal|"fs26"
block|,
literal|26
block|}
block|,
block|{
literal|"fs27"
block|,
literal|27
block|}
block|,
block|{
literal|"fs28"
block|,
literal|28
block|}
block|,
block|{
literal|"fs29"
block|,
literal|29
block|}
block|,
block|{
literal|"fs3"
block|,
literal|3
block|}
block|,
block|{
literal|"fs30"
block|,
literal|30
block|}
block|,
block|{
literal|"fs31"
block|,
literal|31
block|}
block|,
block|{
literal|"fs4"
block|,
literal|4
block|}
block|,
block|{
literal|"fs5"
block|,
literal|5
block|}
block|,
block|{
literal|"fs6"
block|,
literal|6
block|}
block|,
block|{
literal|"fs7"
block|,
literal|7
block|}
block|,
block|{
literal|"fs8"
block|,
literal|8
block|}
block|,
block|{
literal|"fs9"
block|,
literal|9
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FLOAT_REG_NAME_CNT
define|\
value|(sizeof (float_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|double_registers
index|[]
init|=
block|{
block|{
literal|"fd0"
block|,
literal|0
block|}
block|,
block|{
literal|"fd10"
block|,
literal|10
block|}
block|,
block|{
literal|"fd12"
block|,
literal|12
block|}
block|,
block|{
literal|"fd14"
block|,
literal|14
block|}
block|,
block|{
literal|"fd16"
block|,
literal|16
block|}
block|,
block|{
literal|"fd18"
block|,
literal|18
block|}
block|,
block|{
literal|"fd2"
block|,
literal|2
block|}
block|,
block|{
literal|"fd20"
block|,
literal|20
block|}
block|,
block|{
literal|"fd22"
block|,
literal|22
block|}
block|,
block|{
literal|"fd24"
block|,
literal|24
block|}
block|,
block|{
literal|"fd26"
block|,
literal|26
block|}
block|,
block|{
literal|"fd28"
block|,
literal|28
block|}
block|,
block|{
literal|"fd30"
block|,
literal|30
block|}
block|,
block|{
literal|"fd4"
block|,
literal|4
block|}
block|,
block|{
literal|"fd6"
block|,
literal|6
block|}
block|,
block|{
literal|"fd8"
block|,
literal|8
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DOUBLE_REG_NAME_CNT
define|\
value|(sizeof (double_registers) / sizeof (struct reg_name))
end_define

begin_comment
comment|/* reg_name_search does a binary search of the given register table    to see if "name" is a valid regiter name.  Returns the register    number from the array on success, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|regs
parameter_list|,
name|regcount
parameter_list|,
name|name
parameter_list|)
specifier|const
name|struct
name|reg_name
modifier|*
name|regs
decl_stmt|;
name|int
name|regcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: An expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|r_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|r_registers
argument_list|,
name|R_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: An expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xr_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|xr_registers
argument_list|,
name|XR_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: An expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|data_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|data_registers
argument_list|,
name|DATA_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: An expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|address_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|address_registers
argument_list|,
name|ADDRESS_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().  *  * in: Input_line_pointer points to 1st char of operand.  *  * out: An expressionS.  *	The operand may have been a register: in this case, X_op == O_register,  *	X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in  *	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|other_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|other_registers
argument_list|,
name|OTHER_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|==
literal|0
operator|||
operator|(
name|reg_number
operator|==
name|AM33
operator|&&
name|HAVE_AM33
operator|)
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_boolean
name|double_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|float_register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Summary of float_register_name:     in: Input_line_pointer points to 1st char of operand.     out: A expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|float_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|float_registers
argument_list|,
name|FLOAT_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of double_register_name:     in: Input_line_pointer points to 1st char of operand.     out: A expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|double_register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|double_registers
argument_list|,
name|DOUBLE_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"MN10300 assembler options:\n\ none yet\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litp
parameter_list|,
name|sizep
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litp
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|static
name|unsigned
name|long
name|label_count
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xc8
case|:
name|opcode
operator|=
literal|0xc9
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|opcode
operator|=
literal|0xc8
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|opcode
operator|=
literal|0xc2
expr_stmt|;
break|break;
case|case
literal|0xc2
case|:
name|opcode
operator|=
literal|0xc0
expr_stmt|;
break|break;
case|case
literal|0xc3
case|:
name|opcode
operator|=
literal|0xc1
expr_stmt|;
break|break;
case|case
literal|0xc1
case|:
name|opcode
operator|=
literal|0xc3
expr_stmt|;
break|break;
case|case
literal|0xc4
case|:
name|opcode
operator|=
literal|0xc6
expr_stmt|;
break|break;
case|case
literal|0xc6
case|:
name|opcode
operator|=
literal|0xc4
expr_stmt|;
break|break;
case|case
literal|0xc7
case|:
name|opcode
operator|=
literal|0xc5
expr_stmt|;
break|break;
case|case
literal|0xc5
case|:
name|opcode
operator|=
literal|0xc7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|0xcc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|3
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xc8
case|:
name|opcode
operator|=
literal|0xc9
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|opcode
operator|=
literal|0xc8
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|opcode
operator|=
literal|0xc2
expr_stmt|;
break|break;
case|case
literal|0xc2
case|:
name|opcode
operator|=
literal|0xc0
expr_stmt|;
break|break;
case|case
literal|0xc3
case|:
name|opcode
operator|=
literal|0xc1
expr_stmt|;
break|break;
case|case
literal|0xc1
case|:
name|opcode
operator|=
literal|0xc3
expr_stmt|;
break|break;
case|case
literal|0xc4
case|:
name|opcode
operator|=
literal|0xc6
expr_stmt|;
break|break;
case|case
literal|0xc6
case|:
name|opcode
operator|=
literal|0xc4
expr_stmt|;
break|break;
case|case
literal|0xc7
case|:
name|opcode
operator|=
literal|0xc5
expr_stmt|;
break|break;
case|case
literal|0xc5
case|:
name|opcode
operator|=
literal|0xc7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|0xdc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|3
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|4
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|opcode
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xea
case|:
name|opcode
operator|=
literal|0xeb
expr_stmt|;
break|break;
case|case
literal|0xeb
case|:
name|opcode
operator|=
literal|0xea
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xcc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|5
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xea
case|:
name|opcode
operator|=
literal|0xeb
expr_stmt|;
break|break;
case|case
literal|0xeb
case|:
name|opcode
operator|=
literal|0xea
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xdc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|6
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xcd
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|7
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xdd
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|5
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|6
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|4
index|]
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|8
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xfa
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|9
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xfc
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|10
condition|)
block|{
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
index|]
operator|=
literal|0xca
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|11
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xcc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|12
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xdc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|13
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|14
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xd0
case|:
name|opcode
operator|=
literal|0xd1
expr_stmt|;
break|break;
case|case
literal|0xd1
case|:
name|opcode
operator|=
literal|0xd0
expr_stmt|;
break|break;
case|case
literal|0xd2
case|:
name|opcode
operator|=
literal|0xdc
expr_stmt|;
break|break;
case|case
literal|0xd3
case|:
name|opcode
operator|=
literal|0xdb
expr_stmt|;
break|break;
case|case
literal|0xd4
case|:
name|opcode
operator|=
literal|0xda
expr_stmt|;
break|break;
case|case
literal|0xd5
case|:
name|opcode
operator|=
literal|0xd9
expr_stmt|;
break|break;
case|case
literal|0xd6
case|:
name|opcode
operator|=
literal|0xd8
expr_stmt|;
break|break;
case|case
literal|0xd7
case|:
name|opcode
operator|=
literal|0xdd
expr_stmt|;
break|break;
case|case
literal|0xd8
case|:
name|opcode
operator|=
literal|0xd6
expr_stmt|;
break|break;
case|case
literal|0xd9
case|:
name|opcode
operator|=
literal|0xd5
expr_stmt|;
break|break;
case|case
literal|0xda
case|:
name|opcode
operator|=
literal|0xd4
expr_stmt|;
break|break;
case|case
literal|0xdb
case|:
name|opcode
operator|=
literal|0xd3
expr_stmt|;
break|break;
case|case
literal|0xdc
case|:
name|opcode
operator|=
literal|0xd2
expr_stmt|;
break|break;
case|case
literal|0xdd
case|:
name|opcode
operator|=
literal|0xd7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xcc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|15
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xd0
case|:
name|opcode
operator|=
literal|0xd1
expr_stmt|;
break|break;
case|case
literal|0xd1
case|:
name|opcode
operator|=
literal|0xd0
expr_stmt|;
break|break;
case|case
literal|0xd2
case|:
name|opcode
operator|=
literal|0xdc
expr_stmt|;
break|break;
case|case
literal|0xd3
case|:
name|opcode
operator|=
literal|0xdb
expr_stmt|;
break|break;
case|case
literal|0xd4
case|:
name|opcode
operator|=
literal|0xda
expr_stmt|;
break|break;
case|case
literal|0xd5
case|:
name|opcode
operator|=
literal|0xd9
expr_stmt|;
break|break;
case|case
literal|0xd6
case|:
name|opcode
operator|=
literal|0xd8
expr_stmt|;
break|break;
case|case
literal|0xd7
case|:
name|opcode
operator|=
literal|0xdd
expr_stmt|;
break|break;
case|case
literal|0xd8
case|:
name|opcode
operator|=
literal|0xd6
expr_stmt|;
break|break;
case|case
literal|0xd9
case|:
name|opcode
operator|=
literal|0xd5
expr_stmt|;
break|break;
case|case
literal|0xda
case|:
name|opcode
operator|=
literal|0xd4
expr_stmt|;
break|break;
case|case
literal|0xdb
case|:
name|opcode
operator|=
literal|0xd3
expr_stmt|;
break|break;
case|case
literal|0xdc
case|:
name|opcode
operator|=
literal|0xd2
expr_stmt|;
break|break;
case|case
literal|0xdd
case|:
name|opcode
operator|=
literal|0xd7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xdc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|8
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
specifier|register
specifier|const
name|struct
name|mn10300_opcode
modifier|*
name|op
decl_stmt|;
name|mn10300_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  The MN10300 instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
name|op
operator|=
name|mn10300_opcodes
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|op
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|mn10300_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
name|op
operator|++
expr_stmt|;
block|}
comment|/* Set the default machine type.  */
ifdef|#
directive|ifdef
name|TE_LINUX
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mn10300
argument_list|,
name|AM33_2
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|current_machine
operator|=
name|AM33_2
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mn10300
argument_list|,
name|MN103
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|current_machine
operator|=
name|MN103
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|mn10300_check_fixup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mn10300_fixup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|mn10300_PIC_related_p
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|mn10300_PIC_related_p
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sym
operator|==
name|GOT_symbol
condition|)
return|return
literal|1
return|;
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp
operator|->
name|X_op
operator|==
name|O_PIC_reloc
operator|||
name|mn10300_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|mn10300_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mn10300_check_fixup
parameter_list|(
name|fixup
parameter_list|)
name|struct
name|mn10300_fixup
modifier|*
name|fixup
decl_stmt|;
block|{
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|fixup
operator|->
name|exp
decl_stmt|;
name|repeat
label|:
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
comment|/* If we're sufficiently unlucky that the label 			and the expression that references it happen 			to end up in different frags, the subtract 			won't be simplified within expression().  */
comment|/* The PIC-related operand must be the first operand of a sum.  */
if|if
condition|(
name|exp
operator|!=
operator|&
name|fixup
operator|->
name|exp
operator|||
name|mn10300_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|==
name|GOT_symbol
condition|)
name|fixup
operator|->
name|reloc
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|O_symbol
case|:
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|==
name|GOT_symbol
condition|)
name|fixup
operator|->
name|reloc
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
break|break;
case|case
name|O_PIC_reloc
case|:
name|fixup
operator|->
name|reloc
operator|=
name|exp
operator|->
name|X_md
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
if|if
condition|(
name|fixup
operator|->
name|reloc
operator|==
name|BFD_RELOC_32_PLT_PCREL
operator|&&
name|fixup
operator|->
name|opindex
operator|>=
literal|0
operator|&&
operator|(
name|mn10300_operands
index|[
name|fixup
operator|->
name|opindex
index|]
operator|.
name|flags
operator|&
name|MN10300_OPERAND_RELAX
operator|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
return|return
operator|(
name|mn10300_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|mn10300_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mn10300_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|off
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|off
decl_stmt|,
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|mn10300_fixup
name|fixup
decl_stmt|;
name|fixup
operator|.
name|opindex
operator|=
operator|-
literal|1
expr_stmt|;
name|fixup
operator|.
name|exp
operator|=
operator|*
name|exp
expr_stmt|;
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|mn10300_check_fixup
argument_list|(
operator|&
name|fixup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|.
name|reloc
operator|==
name|BFD_RELOC_MN10300_GOT32
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_MN10300_GOT16
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_MN10300_GOT24
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|fixup
operator|.
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_24
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|error
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fixup
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
operator|&
name|fixup
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|fixup
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|mn10300_opcode
modifier|*
name|opcode
decl_stmt|;
name|struct
name|mn10300_opcode
modifier|*
name|next_opcode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|next_opindex
decl_stmt|,
name|relaxable
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|,
name|extension
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
decl_stmt|;
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the first opcode with the proper name.  */
name|opcode
operator|=
operator|(
expr|struct
name|mn10300_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mn10300_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|op_idx
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|int
name|extra_shift
init|=
literal|0
decl_stmt|;
name|errmsg
operator|=
name|_
argument_list|(
literal|"Invalid opcode/operands"
argument_list|)
expr_stmt|;
comment|/* Reset the array of register operands.  */
name|memset
argument_list|(
name|mn10300_reg_operands
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mn10300_reg_operands
argument_list|)
argument_list|)
expr_stmt|;
name|relaxable
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|extension
operator|=
literal|0
expr_stmt|;
comment|/* If the instruction is not available on the current machine 	 then it can not possibly match.  */
if|if
condition|(
name|opcode
operator|->
name|machine
operator|&&
operator|!
operator|(
name|opcode
operator|->
name|machine
operator|==
name|AM33_2
operator|&&
name|HAVE_AM33_2
operator|)
operator|&&
operator|!
operator|(
name|opcode
operator|->
name|machine
operator|==
name|AM33
operator|&&
name|HAVE_AM33
operator|)
operator|&&
operator|!
operator|(
name|opcode
operator|->
name|machine
operator|==
name|AM30
operator|&&
name|HAVE_AM30
operator|)
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|op_idx
operator|=
literal|1
operator|,
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
operator|,
name|op_idx
operator|++
control|)
block|{
specifier|const
name|struct
name|mn10300_operand
modifier|*
name|operand
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
if|if
condition|(
name|next_opindex
operator|==
literal|0
condition|)
block|{
name|operand
operator|=
operator|&
name|mn10300_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|=
operator|&
name|mn10300_operands
index|[
name|next_opindex
index|]
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_RELAX
condition|)
name|relaxable
operator|=
literal|1
expr_stmt|;
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PAREN
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
comment|/* See if we can match the operands.  */
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_DREG
condition|)
block|{
if|if
condition|(
operator|!
name|data_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_AREG
condition|)
block|{
if|if
condition|(
operator|!
name|address_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SP
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"sp"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_RREG
condition|)
block|{
if|if
condition|(
operator|!
name|r_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_XRREG
condition|)
block|{
if|if
condition|(
operator|!
name|xr_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_FSREG
condition|)
block|{
if|if
condition|(
operator|!
name|float_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_FDREG
condition|)
block|{
if|if
condition|(
operator|!
name|double_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_FPCR
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"fpcr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_USP
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"usp"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SSP
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"ssp"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_MSP
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"msp"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PC
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"pc"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_EPSW
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"epsw"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PLUS
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'+'
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PSW
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"psw"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_MDR
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"mdr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_REG_LIST
condition|)
block|{
name|unsigned
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'['
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Eat the '['.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* We used to reject a null register list here; however, 		 we accept it now so the compiler can emit "call" 		 instructions for all calls to named functions.  		 The linker can then fill in the appropriate bits for the 		 register list and stack size or change the instruction 		 into a "calls" if using "call" is not profitable.  */
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|']'
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|start
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"d2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x80
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"d3"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x40
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"a2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x20
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"a3"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x10
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"other"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x08
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"exreg0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x04
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"exreg1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x02
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"exother"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0x01
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|strcasecmp
argument_list|(
name|start
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
literal|0xff
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|mn10300_insert_operand
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|extension
argument_list|,
name|operand
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|data_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|address_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|other_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|r_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33
operator|&&
name|xr_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33_2
operator|&&
name|float_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|HAVE_AM33_2
operator|&&
name|double_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|')'
operator|||
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ex
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_absent
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_register
case|:
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|MN10300_OPERAND_DREG
operator||
name|MN10300_OPERAND_AREG
expr_stmt|;
if|if
condition|(
name|HAVE_AM33
condition|)
name|mask
operator||=
name|MN10300_OPERAND_RREG
operator||
name|MN10300_OPERAND_XRREG
expr_stmt|;
if|if
condition|(
name|HAVE_AM33_2
condition|)
name|mask
operator||=
name|MN10300_OPERAND_FSREG
operator||
name|MN10300_OPERAND_FDREG
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D1
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_S1
condition|)
name|extra_shift
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D2
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D4
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_S2
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_S4
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_S6
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D5
condition|)
name|extra_shift
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D7
condition|)
name|extra_shift
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D8
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D9
condition|)
name|extra_shift
operator|=
literal|8
expr_stmt|;
else|else
name|extra_shift
operator|=
literal|0
expr_stmt|;
name|mn10300_insert_operand
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|extension
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|extra_shift
argument_list|)
expr_stmt|;
comment|/* And note the register number in the register array.  */
name|mn10300_reg_operands
index|[
name|op_idx
operator|-
literal|1
index|]
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
break|break;
block|}
case|case
name|O_constant
case|:
comment|/* If this operand can be promoted, and it doesn't 		 fit into the allocated bitfield for this insn, 		 then promote it (ie this opcode does not match).  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|MN10300_OPERAND_PROMOTE
operator||
name|MN10300_OPERAND_RELAX
operator|)
operator|&&
operator|!
name|check_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mn10300_insert_operand
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|extension
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If this operand can be promoted, then this opcode didn't 		 match since we can't know if it needed promotion!  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PROMOTE
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|mn10300_check_fixup
argument_list|(
operator|&
name|fixups
index|[
name|fc
index|]
argument_list|)
condition|)
goto|goto
name|error
goto|;
operator|++
name|fc
expr_stmt|;
break|break;
block|}
name|keep_going
label|:
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
condition|)
operator|++
name|str
expr_stmt|;
block|}
comment|/* Make sure we used all the operands!  */
if|if
condition|(
operator|*
name|str
operator|!=
literal|','
condition|)
name|match
operator|=
literal|1
expr_stmt|;
comment|/* If this instruction has registers that must not match, verify 	 that they do indeed not match.  */
if|if
condition|(
name|opcode
operator|->
name|no_match_operands
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Look at each operand to see if it's marked.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MN10300_MAX_OPERANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|opcode
operator|->
name|no_match_operands
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* operand I is marked.  Check that it does not match any 		     operands> I which are marked.  */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|MN10300_MAX_OPERANDS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|j
operator|)
operator|&
name|opcode
operator|->
name|no_match_operands
operator|)
operator|&&
name|mn10300_reg_operands
index|[
name|i
index|]
operator|==
name|mn10300_reg_operands
index|[
name|j
index|]
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"Invalid register specification."
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
block|}
block|}
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|next_opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|next_opcode
expr_stmt|;
continue|continue;
block|}
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* Determine the size of the instruction.  */
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S1
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D0
condition|)
name|size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S2
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D1
condition|)
name|size
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D6
condition|)
name|size
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D7
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D10
condition|)
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D8
condition|)
name|size
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D9
condition|)
name|size
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S4
condition|)
name|size
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S6
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D5
condition|)
name|size
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D2
condition|)
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D3
condition|)
name|size
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D4
condition|)
name|size
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|relaxable
operator|&&
name|fc
operator|>
literal|0
condition|)
block|{
comment|/* On a 64-bit host the size of an 'int' is not the same 	 as the size of a pointer, so we need a union to convert 	 the opindex field of the fr_cgen structure into a char * 	 so that it can be stored in the frag.  We do not have 	 to worry about loosing accuracy as we are not going to 	 be even close to the 32bit limit of the int.  */
union|union
block|{
name|int
name|opindex
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
name|opindex_converter
union|;
name|int
name|type
decl_stmt|;
comment|/* We want to anchor the line info to the previous frag (if 	 there isn't one, create it), so that, when the insn is 	 resized, we still get the right address for the beginning of 	 the region.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* bCC  */
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
comment|/* Handle bra specially.  Basically treat it like jmp so 	     that we automatically handle 8, 16 and 32 bit offsets 	     correctly as well as jumps to an undefined address.  	     It is also important to not treat it like other bCC 	     instructions since the long forms of bra is different 	     from other bCC instructions.  */
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|==
literal|0xca00
condition|)
name|type
operator|=
literal|10
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
block|}
comment|/* call  */
elseif|else
if|if
condition|(
name|size
operator|==
literal|5
condition|)
name|type
operator|=
literal|6
expr_stmt|;
comment|/* calls  */
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|type
operator|=
literal|8
expr_stmt|;
comment|/* jmp  */
elseif|else
if|if
condition|(
name|size
operator|==
literal|3
operator|&&
name|opcode
operator|->
name|opcode
operator|==
literal|0xcc0000
condition|)
name|type
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|3
operator|&&
operator|(
name|opcode
operator|->
name|opcode
operator|&
literal|0xfff000
operator|)
operator|==
literal|0xf8d000
condition|)
name|type
operator|=
literal|13
expr_stmt|;
comment|/* bCC (uncommon cases)  */
else|else
name|type
operator|=
literal|3
expr_stmt|;
name|opindex_converter
operator|.
name|opindex
operator|=
name|fixups
index|[
literal|0
index|]
operator|.
name|opindex
expr_stmt|;
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|8
operator|-
name|size
argument_list|,
name|type
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|opindex_converter
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* This is pretty hokey.  We basically just care about the 	 opcode, so we have to write out the first word big endian.  	 The exception is "call", which has two operands that we 	 care about.  	 The first operand (the register list) happens to be in the 	 first instruction word, and will be in the right place if 	 we output the first word in big endian mode.  	 The second operand (stack size) is in the extension word, 	 and we want it to appear as the first character in the extension 	 word (as it appears in memory).  Luckily, writing the extension 	 word in big endian format will do what we want.  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|size
operator|>
literal|4
condition|?
literal|4
else|:
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|extension
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
name|size
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|4
condition|)
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|extension
argument_list|,
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate space for the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Fill in bytes for the instruction.  Note that opcode fields 	 are written big-endian, 16& 32bit immediates are written 	 little endian.  Egad.  */
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S0
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_S1
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D0
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D6
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D7
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D10
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_D1
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S2
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xdf0000
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xde0000
condition|)
block|{
comment|/* A format S2 instruction that is _not_ "ret" and "retf".  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S2
condition|)
block|{
comment|/* This must be a ret or retf, which is written entirely in 	     big-endian format.  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S4
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xdc000000
condition|)
block|{
comment|/* This must be a format S4 "call" instruction.  What a pain.  */
name|unsigned
name|long
name|temp
init|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|temp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|3
argument_list|,
name|insn
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|extension
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S4
condition|)
block|{
comment|/* This must be a format S4 "jmp" instruction.  */
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xffffff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|extension
operator|&
literal|0xff
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_S6
condition|)
block|{
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xffffff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|extension
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|5
argument_list|,
operator|(
name|extension
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|6
argument_list|,
name|extension
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D2
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xfaf80000
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xfaf00000
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xfaf40000
condition|)
block|{
comment|/* A format D2 instruction where the 16bit immediate is 	     really a single 16bit value, not two 8bit values.  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D2
condition|)
block|{
comment|/* A format D2 instruction where the 16bit immediate 	     is really two 8bit immediates.  */
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D3
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|extension
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D4
condition|)
block|{
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|extension
operator|&
literal|0xffff
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D5
condition|)
block|{
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|extension
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
operator|)
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|6
argument_list|,
name|extension
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D8
condition|)
block|{
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|extension
operator|&
literal|0xffff
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|3
argument_list|,
operator|(
name|temp
operator|&
literal|0xff
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|temp
operator|>>
literal|8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_D9
condition|)
block|{
name|unsigned
name|long
name|temp
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|extension
operator|&
literal|0xffffff
operator|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|3
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|mn10300_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|mn10300_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
operator|&&
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_32_GOT_PCREL
operator|&&
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_32_GOTOFF
operator|&&
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_32_PLT_PCREL
operator|&&
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_MN10300_GOT32
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|4
operator|-
name|size
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|reloc
decl_stmt|,
name|pcrel
decl_stmt|,
name|reloc_size
decl_stmt|,
name|offset
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
name|reloc
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
comment|/* How big is the reloc?  Remember SPLIT relocs are 		 implicitly 32bits.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SPLIT
operator|)
operator|!=
literal|0
condition|)
name|reloc_size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_24BIT
operator|)
operator|!=
literal|0
condition|)
name|reloc_size
operator|=
literal|24
expr_stmt|;
else|else
name|reloc_size
operator|=
name|operand
operator|->
name|bits
expr_stmt|;
comment|/* Is the reloc pc-relative?  */
name|pcrel
operator|=
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_PCREL
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
name|pcrel
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
operator|->
name|pc_relative
expr_stmt|;
name|offset
operator|=
name|size
operator|-
operator|(
name|reloc_size
operator|+
name|operand
operator|->
name|shift
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* Choose a proper BFD relocation type.  */
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|pcrel
condition|)
block|{
if|if
condition|(
name|reloc_size
operator|==
literal|32
condition|)
name|reloc
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|16
condition|)
name|reloc
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reloc_size
operator|==
literal|32
condition|)
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|16
condition|)
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|reloc_size
operator|/
literal|8
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|pcrel
argument_list|,
operator|(
operator|(
name|bfd_reloc_code_real_type
operator|)
name|reloc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|fixP
operator|->
name|fx_offset
operator|+=
name|offset
expr_stmt|;
block|}
block|}
name|dwarf2_emit_insn
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|fixp
operator|->
name|fx_offset
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* If we got a difference between two symbols, and the 	 subtracted symbol is in the current section, use a 	 PC-relative relocation.  If both symbols are in the same 	 section, the difference would have already been simplified 	 to a constant.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|seg
condition|)
block|{
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
operator|(
name|reloc
operator|->
name|address
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|+
name|fixp
operator|->
name|fx_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
case|case
name|BFD_RELOC_16
case|:
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
case|case
name|BFD_RELOC_24
case|:
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_24_PCREL
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
case|case
name|BFD_RELOC_32
case|:
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
default|default:
comment|/* Try to compute the absolute value below.  */
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Difference of symbols in different sections is not supported"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|fixpos
init|=
name|fixp
operator|->
name|fx_where
operator|+
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|reloc
operator|->
name|addend
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|+
name|fixp
operator|->
name|fx_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
return|return
name|reloc
return|;
block|}
block|}
if|if
condition|(
name|reloc
operator|->
name|sym_ptr_ptr
condition|)
name|free
argument_list|(
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|asection
modifier|*
name|seg
decl_stmt|;
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|6
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|8
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|10
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|13
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|md_relax_table
index|[
name|fragp
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* The symbol is undefined.  Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|char
modifier|*
name|fixpos
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
operator|(
name|int
operator|)
operator|*
name|valP
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
comment|/* This should never happen.  */
if|if
condition|(
name|seg
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The value we are passed in *valuep includes the symbol values.      If we are doing this relocation the code in write.c is going to      call bfd_install_relocation, which is also going to use the symbol      value.  That means that if the reloc is fully resolved we want to      use *valuep since bfd_install_relocation is not being used.       However, if the reloc is not fully resolved we do not want to use      *valuep, and must use fx_offset instead.  However, if the reloc      is PC relative, we do want to use *valuep since it includes the      result of md_pcrel_from.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
comment|/* If the fix is relative to a symbol which is not defined, or not      in the same segment as the fix, we cannot resolve it here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|)
operator|)
condition|)
block|{
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Bad relocation fixup type (%d)"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* If a symbol remains, pass the fixup, as a reloc, onto the linker.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return zero if the fixup in fixp should be left alone and not    adjusted.  */
end_comment

begin_function
name|bfd_boolean
name|mn10300_fix_adjustable
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|TC_FORCE_RELOCATION_LOCAL
argument_list|(
name|fixp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
comment|/* Do not adjust relocations involving symbols in code sections,      because it breaks linker relaxations.  This could be fixed in the      linker, but this fix is simpler, and it pretty much only affects      object size a little bit.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
return|return
literal|0
return|;
comment|/* Likewise, do not adjust symbols that won't be merged, or debug      symbols, because they too break relaxation.  We do want to adjust      other mergable symbols, like .rodata, because code relaxations      need section-relative symbols to properly relax them.  */
if|if
condition|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|name
argument_list|,
literal|".debug"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mn10300_insert_operand
parameter_list|(
name|insnp
parameter_list|,
name|extensionp
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|shift
parameter_list|)
name|unsigned
name|long
modifier|*
name|insnp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|extensionp
decl_stmt|;
specifier|const
name|struct
name|mn10300_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
block|{
comment|/* No need to check 32bit operands for a bit.  Note that      MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SPLIT
operator|)
operator|==
literal|0
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|bits
operator|=
name|operand
operator|->
name|bits
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_24BIT
condition|)
name|bits
operator|=
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
name|as_warn_value_out_of_range
argument_list|(
name|_
argument_list|(
literal|"operand"
argument_list|)
argument_list|,
name|test
argument_list|,
operator|(
name|offsetT
operator|)
name|min
argument_list|,
operator|(
name|offsetT
operator|)
name|max
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SPLIT
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|insnp
operator||=
operator|(
name|val
operator|>>
operator|(
literal|32
operator|-
name|operand
operator|->
name|bits
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|extensionp
operator||=
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|operand
operator|->
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_24BIT
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|insnp
operator||=
operator|(
name|val
operator|>>
operator|(
literal|24
operator|-
name|operand
operator|->
name|bits
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|extensionp
operator||=
operator|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|24
operator|-
name|operand
operator|->
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|MN10300_OPERAND_FSREG
operator||
name|MN10300_OPERAND_FDREG
operator|)
operator|)
condition|)
block|{
comment|/* See devo/opcodes/m10300-opc.c just before #define FSM0 for an          explanation of these variables.  Note that FMT-implied shifts         are not taken into account for FP registers.  */
name|unsigned
name|long
name|mask_low
decl_stmt|,
name|mask_high
decl_stmt|;
name|int
name|shl_low
decl_stmt|,
name|shr_high
decl_stmt|,
name|shl_high
decl_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|bits
condition|)
block|{
case|case
literal|5
case|:
comment|/* Handle regular FP registers.  */
if|if
condition|(
name|operand
operator|->
name|shift
operator|>=
literal|0
condition|)
block|{
comment|/* This is an `m' register.  */
name|shl_low
operator|=
name|operand
operator|->
name|shift
expr_stmt|;
name|shl_high
operator|=
literal|8
operator|+
operator|(
literal|8
operator|&
name|shl_low
operator|)
operator|+
operator|(
name|shl_low
operator|&
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an `n' register.  */
name|shl_low
operator|=
operator|-
name|operand
operator|->
name|shift
expr_stmt|;
name|shl_high
operator|=
name|shl_low
operator|/
literal|4
expr_stmt|;
block|}
name|mask_low
operator|=
literal|0x0f
expr_stmt|;
name|mask_high
operator|=
literal|0x10
expr_stmt|;
name|shr_high
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Handle accumulators.  */
name|shl_low
operator|=
operator|-
name|operand
operator|->
name|shift
expr_stmt|;
name|shl_high
operator|=
literal|0
expr_stmt|;
name|mask_low
operator|=
literal|0x03
expr_stmt|;
name|mask_high
operator|=
literal|0x04
expr_stmt|;
name|shr_high
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|insnp
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|&
name|mask_high
operator|)
operator|>>
name|shr_high
operator|)
operator|<<
name|shl_high
operator|)
operator||
operator|(
operator|(
name|val
operator|&
name|mask_low
operator|)
operator|<<
name|shl_low
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_EXTENDED
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|insnp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_REPEATED
operator|)
operator|!=
literal|0
condition|)
operator|*
name|insnp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|+
name|operand
operator|->
name|bits
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|extensionp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_REPEATED
operator|)
operator|!=
literal|0
condition|)
operator|*
name|extensionp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|+
name|operand
operator|->
name|bits
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|check_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|)
name|unsigned
name|long
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|mn10300_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
block|{
comment|/* No need to check 32bit operands for a bit.  Note that      MN10300_OPERAND_SPLIT is an implicit 32bit operand.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SPLIT
operator|)
operator|==
literal|0
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|bits
operator|=
name|operand
operator|->
name|bits
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_24BIT
condition|)
name|bits
operator|=
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10300_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_arch_mach
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mn10300
argument_list|,
name|mach
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|current_machine
operator|=
name|mach
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|char
modifier|*
name|mn10300_end_of_match
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|mn10300_end_of_match
parameter_list|(
name|cont
parameter_list|,
name|what
parameter_list|)
name|char
modifier|*
name|cont
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|what
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cont
argument_list|,
name|what
argument_list|,
name|strlen
argument_list|(
name|what
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|cont
index|[
name|len
index|]
argument_list|)
condition|)
return|return
name|cont
operator|+
name|len
return|;
return|return
name|NULL
return|;
block|}
end_block

begin_function
name|int
name|mn10300_parse_name
parameter_list|(
name|name
parameter_list|,
name|exprP
parameter_list|,
name|mode
parameter_list|,
name|nextcharP
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|exprP
decl_stmt|;
name|enum
name|expr_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|nextcharP
decl_stmt|;
block|{
name|char
modifier|*
name|next
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|next_end
decl_stmt|;
name|int
name|reloc_type
decl_stmt|;
name|segT
name|segment
decl_stmt|;
name|exprP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|GOT_symbol
expr_stmt|;
name|no_suffix
label|:
comment|/* If we have an absolute symbol or a reg, 	 then we know its value now.  */
name|segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|expr_defer
operator|&&
name|segment
operator|==
name|absolute_section
condition|)
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|expr_defer
operator|&&
name|segment
operator|==
name|reg_section
condition|)
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|exprP
operator|->
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nextcharP
operator|!=
literal|'@'
condition|)
goto|goto
name|no_suffix
goto|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|mn10300_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|mn10300_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_MN10300_GOT32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|mn10300_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
else|else
goto|goto
name|no_suffix
goto|;
operator|*
name|input_line_pointer
operator|=
operator|*
name|nextcharP
expr_stmt|;
name|input_line_pointer
operator|=
name|next_end
expr_stmt|;
operator|*
name|nextcharP
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|exprP
operator|->
name|X_op
operator|=
name|O_PIC_reloc
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exprP
operator|->
name|X_md
operator|=
name|reloc_type
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

