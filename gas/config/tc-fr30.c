begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-fr30.c -- Assembler for the Fujitsu FR30.    Copyright 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/fr30-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/fr30-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|fr30_insn
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|FR30_SHORTOPTS
value|""
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|FR30_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" FR30 specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|fr30_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|fr30_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|static
name|int
name|last_insn_had_delay_slot
init|=
literal|0
decl_stmt|;
name|fr30_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|fr30_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Warn about invalid insns in delay slots.  */
if|if
condition|(
name|last_insn_had_delay_slot
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_NOT_IN_DELAY_SLOT
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction %s not allowed in a delay slot."
argument_list|)
argument_list|,
name|CGEN_INSN_NAME
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|last_insn_had_delay_slot
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_DELAY_SLOT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The syntax in the manual says constants begin with '#'.    We just ignore it.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_comment
comment|/* FIXME: Build table by hand, get it working, then machine generate.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:    1) most positive reach of this state,    2) most negative reach of this state,    3) how many bytes this mode will add to the size of the current frag    4) which index into the table to try if we can't fit into this one.  */
comment|/* The first entry must be unused because an `rlx_more' value of zero ends      each list.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* The displacement used by GAS is from the end of the 2 byte insn,      so we subtract 2 from the following.  */
comment|/* 16 bit insn, 8 bit disp -> 10 bit range.      This doesn't handle a branch in the right slot at the border:      the "& -4" isn't taken into account.  It's not important enough to      complicate things over it, so we subtract an extra 2 (or + 2 in -ve      case).  */
block|{
literal|511
operator|-
literal|2
operator|-
literal|2
block|,
operator|-
literal|512
operator|-
literal|2
operator|+
literal|2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* 32 bit insn, 24 bit disp -> 26 bit range.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* Same thing, but with leading nop for alignment.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|long fr30_relax_frag (segment, fragP, stretch)      segT    segment;      fragS * fragP;      long    stretch; {
comment|/* Address of branch insn.  */
end_comment

begin_comment
unit|long address = fragP->fr_address + fragP->fr_fix - 2;   long growth = 0;
comment|/* Keep 32 bit insns aligned on 32 bit boundaries.  */
end_comment

begin_comment
unit|if (fragP->fr_subtype == 2)     {       if ((address& 3) != 0) 	{ 	  fragP->fr_subtype = 3; 	  growth = 2; 	}     }   else if (fragP->fr_subtype == 3)     {       if ((address& 3) == 0) 	{ 	  fragP->fr_subtype = 2; 	  growth = -2; 	}     }   else     {       growth = relax_frag (segment, fragP, stretch);
comment|/* Long jump on odd halfword boundary?  */
end_comment

begin_endif
unit|if (fragP->fr_subtype == 2&& (address& 3) != 0) 	{ 	  fragP->fr_subtype = 3; 	  growth += 2; 	}     }    return growth; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
comment|/* The only thing we have to handle here are symbols outside of the      current segment.  They may be undefined or in a different segment in      which case linker scripts may place them anywhere.      However, we can't finish the fragment here and emit the reloc as insn      alignment requirements may move the insn about.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
if|#
directive|if
literal|0
block|int    old_fr_fix = fragP->fr_fix;
endif|#
directive|endif
comment|/* The symbol is undefined in this segment. 	 Change the relaxation subtype to the max allowable and leave 	 all further handling to md_convert_frag.  */
name|fragP
operator|->
name|fr_subtype
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Can't use this, but leave in for illustration.  */
comment|/* Change 16 bit insn to 32 bit insn.  */
block|fragP->fr_opcode[0] |= 0x80;
comment|/* Increase known (fixed) size of fragment.  */
block|fragP->fr_fix += 2;
comment|/* Create a relocation for it.  */
block|fix_new (fragP, old_fr_fix, 4, 	       fragP->fr_symbol, 	       fragP->fr_offset, 1
comment|/* pcrel */
block|,
comment|/* FIXME: Can't use a real BFD reloc here. 		  gas_cgen_md_apply_fix3 can't handle it.  */
block|BFD_RELOC_FR30_26_PCREL);
comment|/* Mark this fragment as finished.  */
block|frag_wane (fragP);       return fragP->fr_fix - old_fr_fix;
else|#
directive|else
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update the recorded insn. 	   Fortunately we don't have to look very far. 	   FIXME: Change this to record in the instruction the next higher 	   relaxable insn to use.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|insn
operator|=
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|insn
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
argument_list|)
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXED
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
return|return
literal|2
return|;
block|}
endif|#
directive|endif
block|}
comment|/* Return the size of the variable part of the frag.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|char * opcode;   char * displacement;   int    target_address;   int    opcode_address;   int    extension;   int    addend;    opcode = fragP->fr_opcode;
comment|/* Address opcode resides at in file space.  */
block|opcode_address = fragP->fr_address + fragP->fr_fix - 2;    switch (fragP->fr_subtype)     {     case 1 :       extension = 0;       displacement =& opcode[1];       break;     case 2 :       opcode[0] |= 0x80;       extension = 2;       displacement =& opcode[1];       break;     case 3 :       opcode[2] = opcode[0] | 0x80;       md_number_to_chars (opcode, PAR_NOP_INSN, 2);       opcode_address += 2;       extension = 4;       displacement =& opcode[3];       break;     default :       abort ();     }    if (S_GET_SEGMENT (fragP->fr_symbol) != sec)     {
comment|/* symbol must be resolved by linker */
block|if (fragP->fr_offset& 3) 	as_warn (_("Addend to unresolved symbol not on word boundary."));       addend = fragP->fr_offset>> 2;     }   else     {
comment|/* Address we want to reach in file space.  */
block|target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;       addend = (target_address - (opcode_address& -4))>> 2;     }
comment|/* Create a relocation for symbols that must be resolved by the linker.      Otherwise output the completed insn.  */
block|if (S_GET_SEGMENT (fragP->fr_symbol) != sec)     {       assert (fragP->fr_subtype != 1);       assert (fragP->fr_cgen.insn != 0);       gas_cgen_record_fixup (fragP,
comment|/* Offset of branch insn in frag.  */
block|fragP->fr_fix + extension - 4, 			     fragP->fr_cgen.insn, 			     4
comment|/*length*/
block|,
comment|/* FIXME: quick hack */
if|#
directive|if
literal|0
block|CGEN_OPERAND_ENTRY (fragP->fr_cgen.opindex),
else|#
directive|else
block|CGEN_OPERAND_ENTRY (FR30_OPERAND_DISP24),
endif|#
directive|endif
block|fragP->fr_cgen.opinfo, 			     fragP->fr_symbol, fragP->fr_offset);     }
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|n
parameter_list|)
value|((n) == 1 ? 1 : 3)
block|md_number_to_chars (displacement, (valueT) addend, 		      SIZE_FROM_RELAX_STATE (fragP->fr_subtype));    fragP->fr_fix += extension;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section). 	 Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|fixP
parameter_list|)
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|FR30_OPERAND_LABEL9
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
return|return
name|BFD_RELOC_FR30_9_PCREL
return|;
case|case
name|FR30_OPERAND_LABEL12
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
return|return
name|BFD_RELOC_FR30_12_PCREL
return|;
case|case
name|FR30_OPERAND_DISP10
case|:
return|return
name|BFD_RELOC_FR30_10_IN_8
return|;
case|case
name|FR30_OPERAND_DISP9
case|:
return|return
name|BFD_RELOC_FR30_9_IN_8
return|;
case|case
name|FR30_OPERAND_DISP8
case|:
return|return
name|BFD_RELOC_FR30_8_IN_8
return|;
case|case
name|FR30_OPERAND_UDISP6
case|:
return|return
name|BFD_RELOC_FR30_6_IN_4
return|;
case|case
name|FR30_OPERAND_I8
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
name|FR30_OPERAND_I32
case|:
return|return
name|BFD_RELOC_FR30_48
return|;
case|case
name|FR30_OPERAND_I20
case|:
return|return
name|BFD_RELOC_FR30_20
return|;
default|default :
comment|/* avoid -Wall warning */
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK. */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Worker function for fr30_is_colon_insn().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|restore_colon
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
name|restore_colon
parameter_list|(
name|advance_i_l_p_by
parameter_list|)
name|int
name|advance_i_l_p_by
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
comment|/* Restore the colon, and advance input_line_pointer to      the end of the new symbol.  */
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|input_line_pointer
operator|+=
name|advance_i_l_p_by
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Determines if the symbol starting at START and ending in    a colon that was at the location pointed to by INPUT_LINE_POINTER    (but which has now been replaced bu a NUL) is in fact an    LDI:8, LDI:20, LDI:32, CALL:D. JMP:D, RET:D or Bcc:D instruction.    If it is, then it restores the colon, advances INPUT_LINE_POINTER    to the real end of the instruction/symbol, and returns the character    that really terminated the symbol.  Otherwise it returns 0.  */
end_comment

begin_function
name|char
name|fr30_is_colon_insn
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
name|char
modifier|*
name|i_l_p
init|=
name|input_line_pointer
decl_stmt|;
comment|/* Check to see if the symbol parsed so far is 'ldi'  */
if|if
condition|(
operator|(
name|start
index|[
literal|0
index|]
operator|!=
literal|'l'
operator|&&
name|start
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
operator|||
operator|(
name|start
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|&&
name|start
index|[
literal|1
index|]
operator|!=
literal|'D'
operator|)
operator|||
operator|(
name|start
index|[
literal|2
index|]
operator|!=
literal|'i'
operator|&&
name|start
index|[
literal|2
index|]
operator|!=
literal|'I'
operator|)
operator|||
name|start
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Nope - check to see a 'd' follows the colon.  */
if|if
condition|(
operator|(
name|i_l_p
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|i_l_p
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* Yup - it might be delay slot instruction.  */
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|delay_insns
index|[]
init|=
block|{
literal|"call"
block|,
literal|"jmp"
block|,
literal|"ret"
block|,
literal|"bra"
block|,
literal|"bno"
block|,
literal|"beq"
block|,
literal|"bne"
block|,
literal|"bc"
block|,
literal|"bnc"
block|,
literal|"bn"
block|,
literal|"bp"
block|,
literal|"bv"
block|,
literal|"bnv"
block|,
literal|"blt"
block|,
literal|"bge"
block|,
literal|"ble"
block|,
literal|"bgt"
block|,
literal|"bls"
block|,
literal|"bhi"
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|delay_insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|delay_insns
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|char
modifier|*
name|insn
init|=
name|delay_insns
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
index|[
name|len
index|]
operator|!=
literal|0
condition|)
continue|continue;
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
name|TOLOWER
argument_list|(
name|start
index|[
name|len
index|]
argument_list|)
operator|!=
name|insn
index|[
name|len
index|]
condition|)
break|break;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
name|restore_colon
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
comment|/* Nope - it is a normal label.  */
return|return
literal|0
return|;
block|}
comment|/* Check to see if the text following the colon is '8' */
if|if
condition|(
name|i_l_p
index|[
literal|1
index|]
operator|==
literal|'8'
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|2
argument_list|)
return|;
comment|/* Check to see if the text following the colon is '20' */
elseif|else
if|if
condition|(
name|i_l_p
index|[
literal|1
index|]
operator|==
literal|'2'
operator|&&
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|i_l_p
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|3
argument_list|)
return|;
comment|/* Check to see if the text following the colon is '32' */
elseif|else
if|if
condition|(
name|i_l_p
index|[
literal|1
index|]
operator|==
literal|'3'
operator|&&
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'2'
operator|&&
operator|(
name|i_l_p
index|[
literal|3
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|3
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|3
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|fr30_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* We need the symbol name for the VTABLE entries */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

