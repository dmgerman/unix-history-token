begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-avr.c -- Assembler code for the ATMEL AVR     Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Denis Chertykov<denisc@overta.ru>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_struct
struct|struct
name|avr_opcodes_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|constraints
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
comment|/* In words.  */
name|int
name|isa
decl_stmt|;
name|unsigned
name|int
name|bin_opcode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AVR_INSN
parameter_list|(
name|NAME
parameter_list|,
name|CONSTR
parameter_list|,
name|OPCODE
parameter_list|,
name|SIZE
parameter_list|,
name|ISA
parameter_list|,
name|BIN
parameter_list|)
define|\
value|{#NAME, CONSTR, SIZE, ISA, BIN},
end_define

begin_decl_stmt
name|struct
name|avr_opcodes_s
name|avr_opcodes
index|[]
init|=
block|{
include|#
directive|include
file|"opcode/avr.h"
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"$"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mcu_type_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|isa
decl_stmt|;
name|int
name|mach
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* XXX - devices that don't seem to exist (renamed, replaced with larger    ones, or planned but never produced), left here for compatibility.    TODO: hide them in show_mcu_list output?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|mcu_types
index|[]
init|=
block|{
block|{
literal|"avr1"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"avr2"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"avr3"
block|,
name|AVR_ISA_M103
block|,
name|bfd_mach_avr3
block|}
block|,
block|{
literal|"avr4"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"avr5"
block|,
name|AVR_ISA_ALL
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90s1200"
block|,
name|AVR_ISA_1200
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"attiny10"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
comment|/* XXX -> tn11 */
block|{
literal|"attiny11"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"attiny12"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"attiny15"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"attiny28"
block|,
name|AVR_ISA_TINY1
block|,
name|bfd_mach_avr1
block|}
block|,
block|{
literal|"at90s2313"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90s2323"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90s2333"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
comment|/* XXX -> 4433 */
block|{
literal|"at90s2343"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny22"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
comment|/* XXX -> 2343 */
block|{
literal|"attiny26"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90s4433"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90s4414"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
comment|/* XXX -> 8515 */
block|{
literal|"at90s4434"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
comment|/* XXX -> 8535 */
block|{
literal|"at90s8515"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90s8535"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at90c8534"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"at86rf401"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny13"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny2313"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny261"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny461"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny861"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny24"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny44"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny84"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny25"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny45"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"attiny85"
block|,
name|AVR_ISA_TINY2
block|,
name|bfd_mach_avr2
block|}
block|,
block|{
literal|"atmega603"
block|,
name|AVR_ISA_M603
block|,
name|bfd_mach_avr3
block|}
block|,
comment|/* XXX -> m103 */
block|{
literal|"atmega103"
block|,
name|AVR_ISA_M103
block|,
name|bfd_mach_avr3
block|}
block|,
block|{
literal|"at43usb320"
block|,
name|AVR_ISA_M103
block|,
name|bfd_mach_avr3
block|}
block|,
block|{
literal|"at43usb355"
block|,
name|AVR_ISA_M603
block|,
name|bfd_mach_avr3
block|}
block|,
block|{
literal|"at76c711"
block|,
name|AVR_ISA_M603
block|,
name|bfd_mach_avr3
block|}
block|,
block|{
literal|"atmega48"
block|,
name|AVR_ISA_PWMx
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"atmega8"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"atmega83"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
comment|/* XXX -> m8535 */
block|{
literal|"atmega85"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
comment|/* XXX -> m8 */
block|{
literal|"atmega88"
block|,
name|AVR_ISA_PWMx
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"atmega8515"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"atmega8535"
block|,
name|AVR_ISA_M8
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"at90pwm2"
block|,
name|AVR_ISA_PWMx
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"at90pwm3"
block|,
name|AVR_ISA_PWMx
block|,
name|bfd_mach_avr4
block|}
block|,
block|{
literal|"atmega16"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega161"
block|,
name|AVR_ISA_M161
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega162"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega163"
block|,
name|AVR_ISA_M161
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega164"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega165"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega168"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega169"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega32"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega323"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega324"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega325"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega329"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega3250"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega3290"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega406"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega64"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega640"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega644"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega128"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega1280"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega1281"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega645"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega649"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega6450"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"atmega6490"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90can32"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90can64"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90can128"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90usb646"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90usb647"
block|,
name|AVR_ISA_M323
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90usb1286"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at90usb1287"
block|,
name|AVR_ISA_M128
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
literal|"at94k"
block|,
name|AVR_ISA_94K
block|,
name|bfd_mach_avr5
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current MCU type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
name|default_mcu
init|=
block|{
literal|"avr2"
block|,
name|AVR_ISA_2xxx
block|,
name|bfd_mach_avr2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcu_type_s
modifier|*
name|avr_mcu
init|=
operator|&
name|default_mcu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AVR target-specific switches.  */
end_comment

begin_struct
struct|struct
name|avr_opt_s
block|{
name|int
name|all_opcodes
decl_stmt|;
comment|/* -mall-opcodes: accept all known AVR opcodes.  */
name|int
name|no_skip_bug
decl_stmt|;
comment|/* -mno-skip-bug: no warnings for skipping 2-word insns.  */
name|int
name|no_wrap
decl_stmt|;
comment|/* -mno-wrap: reject rjmp/rcall with 8K wrap-around.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|avr_opt_s
name|avr_opt
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|avr_set_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"arch"
block|,
name|avr_set_arch
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LDI_IMMEDIATE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xf) | (((x)<< 4)& 0xf00))
end_define

begin_define
define|#
directive|define
name|EXP_MOD_NAME
parameter_list|(
name|i
parameter_list|)
value|exp_mod[i].name
end_define

begin_define
define|#
directive|define
name|EXP_MOD_RELOC
parameter_list|(
name|i
parameter_list|)
value|exp_mod[i].reloc
end_define

begin_define
define|#
directive|define
name|EXP_MOD_NEG_RELOC
parameter_list|(
name|i
parameter_list|)
value|exp_mod[i].neg_reloc
end_define

begin_define
define|#
directive|define
name|HAVE_PM_P
parameter_list|(
name|i
parameter_list|)
value|exp_mod[i].have_pm
end_define

begin_struct
struct|struct
name|exp_mod_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|neg_reloc
decl_stmt|;
name|int
name|have_pm
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|exp_mod_s
name|exp_mod
index|[]
init|=
block|{
block|{
literal|"hh8"
block|,
name|BFD_RELOC_AVR_HH8_LDI
block|,
name|BFD_RELOC_AVR_HH8_LDI_NEG
block|,
literal|1
block|}
block|,
block|{
literal|"pm_hh8"
block|,
name|BFD_RELOC_AVR_HH8_LDI_PM
block|,
name|BFD_RELOC_AVR_HH8_LDI_PM_NEG
block|,
literal|0
block|}
block|,
block|{
literal|"hi8"
block|,
name|BFD_RELOC_AVR_HI8_LDI
block|,
name|BFD_RELOC_AVR_HI8_LDI_NEG
block|,
literal|1
block|}
block|,
block|{
literal|"pm_hi8"
block|,
name|BFD_RELOC_AVR_HI8_LDI_PM
block|,
name|BFD_RELOC_AVR_HI8_LDI_PM_NEG
block|,
literal|0
block|}
block|,
block|{
literal|"lo8"
block|,
name|BFD_RELOC_AVR_LO8_LDI
block|,
name|BFD_RELOC_AVR_LO8_LDI_NEG
block|,
literal|1
block|}
block|,
block|{
literal|"pm_lo8"
block|,
name|BFD_RELOC_AVR_LO8_LDI_PM
block|,
name|BFD_RELOC_AVR_LO8_LDI_PM_NEG
block|,
literal|0
block|}
block|,
block|{
literal|"hlo8"
block|,
name|BFD_RELOC_AVR_HH8_LDI
block|,
name|BFD_RELOC_AVR_HH8_LDI_NEG
block|,
literal|0
block|}
block|,
block|{
literal|"hhi8"
block|,
name|BFD_RELOC_AVR_MS8_LDI
block|,
name|BFD_RELOC_AVR_MS8_LDI_NEG
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A union used to store indicies into the exp_mod[] array    in a hash table which expects void * data types.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|index
decl_stmt|;
block|}
name|mod_index
typedef|;
end_typedef

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|avr_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reloc modifiers hash control (hh8,hi8,lo8,pm_xx).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|avr_mod_hash
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_MMCU
value|'m'
end_define

begin_enum
enum|enum
name|options
block|{
name|OPTION_ALL_OPCODES
init|=
name|OPTION_MD_BASE
operator|+
literal|1
block|,
name|OPTION_NO_SKIP_BUG
block|,
name|OPTION_NO_WRAP
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mmcu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MMCU
block|}
block|,
block|{
literal|"mall-opcodes"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ALL_OPCODES
block|}
block|,
block|{
literal|"mno-skip-bug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_SKIP_BUG
block|}
block|,
block|{
literal|"mno-wrap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WRAP
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display nicely formatted list of known MCU names.  */
end_comment

begin_function
specifier|static
name|void
name|show_mcu_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Known MCU names:"
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
name|x
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|75
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n  %s"
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|len
operator|+
literal|2
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|skip_space
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Extract one word from FROM and copy it to TO.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_word
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
name|from
operator|=
name|skip_space
argument_list|(
name|from
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
literal|0
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|from
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
name|is_part_of_name
argument_list|(
operator|*
name|op_end
argument_list|)
condition|;
control|)
block|{
name|to
index|[
name|size
operator|++
index|]
operator|=
operator|*
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
block|}
name|to
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|op_end
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"AVR options:\n"
literal|"  -mmcu=[avr-name] select microcontroller variant\n"
literal|"                   [avr-name] can be:\n"
literal|"                   avr1 - AT90S1200, ATtiny1x, ATtiny28\n"
literal|"                   avr2 - AT90S2xxx, AT90S4xxx, AT90S8xxx, ATtiny22\n"
literal|"                   avr3 - ATmega103, ATmega603\n"
literal|"                   avr4 - ATmega83, ATmega85\n"
literal|"                   avr5 - ATmega161, ATmega163, ATmega32, AT94K\n"
literal|"                   or immediate microcontroller name.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
literal|"  -mno-skip-bug    disable warnings for skipping two-word instructions\n"
literal|"                   (default for avr4, avr5)\n"
literal|"  -mno-wrap        reject rjmp/rcall instructions with 8K wrap-around\n"
literal|"                   (default for avr3, avr5)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|show_mcu_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avr_set_arch
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|input_line_pointer
operator|=
name|extract_word
argument_list|(
name|input_line_pointer
argument_list|,
name|str
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|md_parse_option
argument_list|(
name|OPTION_MMCU
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|avr_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_MMCU
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
block|{
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
name|char
modifier|*
name|arg1
init|=
name|arg
decl_stmt|;
do|do
operator|*
name|t
operator|=
name|TOLOWER
argument_list|(
operator|*
name|arg1
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|t
operator|++
condition|)
do|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|show_mcu_list
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown MCU: %s\n"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* It is OK to redefine mcu type within the same avr[1-5] bfd machine 	   type - this for allows passing -mmcu=... via gcc ASM_SPEC as well 	   as .arch ... in the asm output at the same time.  */
if|if
condition|(
name|avr_mcu
operator|==
operator|&
name|default_mcu
operator|||
name|avr_mcu
operator|->
name|mach
operator|==
name|mcu_types
index|[
name|i
index|]
operator|.
name|mach
condition|)
name|avr_mcu
operator|=
operator|&
name|mcu_types
index|[
name|i
index|]
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"redefinition of mcu type `%s' to `%s'"
argument_list|)
argument_list|,
name|avr_mcu
operator|->
name|name
argument_list|,
name|mcu_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|OPTION_ALL_OPCODES
case|:
name|avr_opt
operator|.
name|all_opcodes
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|OPTION_NO_SKIP_BUG
case|:
name|avr_opt
operator|.
name|no_skip_bug
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|OPTION_NO_WRAP
case|:
name|avr_opt
operator|.
name|no_wrap
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loop outputs the LITTLENUMs in REVERSE order.  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|avr_opcodes_s
modifier|*
name|opcode
decl_stmt|;
name|avr_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  This hash table then provides a      quick index to the first opcode with a particular name in the opcode      table.  */
for|for
control|(
name|opcode
operator|=
name|avr_opcodes
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|avr_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|avr_mod_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|exp_mod
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|mod_index
name|m
decl_stmt|;
name|m
operator|.
name|index
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|hash_insert
argument_list|(
name|avr_mod_hash
argument_list|,
name|EXP_MOD_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|m
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|avr_mcu
operator|->
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve STR as a constant expression and return the result.    If result greater than MAX then error.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|avr_get_constant
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"constant value required"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|>
name|max
operator|||
name|ex
operator|.
name|X_add_number
operator|<
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"number must be less than %d"
argument_list|)
argument_list|,
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ex
operator|.
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Parse for ldd/std offset.  */
end_comment

begin_function
specifier|static
name|void
name|avr_offset_expression
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
name|op
index|[
literal|8
index|]
decl_stmt|;
name|tmp
operator|=
name|str
expr_stmt|;
name|str
operator|=
name|extract_word
argument_list|(
name|str
argument_list|,
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmp
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Warn about expressions that fail to use lo8 ().  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|exp
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
literal|255
operator|||
name|x
operator|>
literal|255
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"constant out of 8-bit range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse ordinary expression.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|input_line_pointer
return|;
block|}
end_function

begin_comment
comment|/* Parse special expressions (needed for LDI command):    xx8 (address)    xx8 (-address)    pm_xx8 (address)    pm_xx8 (-address)    where xx is: hh, hi, lo.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|avr_ldi_expression
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
name|op
index|[
literal|8
index|]
decl_stmt|;
name|int
name|mod
decl_stmt|;
name|tmp
operator|=
name|str
expr_stmt|;
name|str
operator|=
name|extract_word
argument_list|(
name|str
argument_list|,
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
literal|0
index|]
condition|)
block|{
name|mod_index
name|m
decl_stmt|;
name|m
operator|.
name|ptr
operator|=
name|hash_find
argument_list|(
name|avr_mod_hash
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|mod
operator|=
name|m
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|mod
condition|)
block|{
name|int
name|closes
init|=
literal|0
decl_stmt|;
name|mod
operator|-=
literal|10
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
name|int
name|neg_p
init|=
literal|0
decl_stmt|;
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"pm("
argument_list|,
name|str
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
literal|"-(pm("
argument_list|,
name|str
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|HAVE_PM_P
argument_list|(
name|mod
argument_list|)
condition|)
block|{
operator|++
name|mod
expr_stmt|;
operator|++
name|closes
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal expression"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|neg_p
operator|=
literal|1
expr_stmt|;
operator|++
name|closes
expr_stmt|;
name|str
operator|+=
literal|5
expr_stmt|;
block|}
else|else
name|str
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'('
condition|)
block|{
name|neg_p
operator|^=
literal|1
expr_stmt|;
operator|++
name|closes
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`)' required"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|closes
operator|--
condition|)
do|;
return|return
name|neg_p
condition|?
name|EXP_MOD_NEG_RELOC
argument_list|(
name|mod
argument_list|)
else|:
name|EXP_MOD_RELOC
argument_list|(
name|mod
argument_list|)
return|;
block|}
block|}
block|}
name|input_line_pointer
operator|=
name|tmp
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Warn about expressions that fail to use lo8 ().  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|x
init|=
name|exp
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
literal|255
operator|||
name|x
operator|>
literal|255
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"constant out of 8-bit range: %d"
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|BFD_RELOC_AVR_LDI
return|;
block|}
end_function

begin_comment
comment|/* Parse one instruction operand.    Return operand bitmask.  Also fixups can be generated.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|avr_operand
parameter_list|(
name|struct
name|avr_opcodes_s
modifier|*
name|opcode
parameter_list|,
name|int
name|where
parameter_list|,
name|char
modifier|*
name|op
parameter_list|,
name|char
modifier|*
modifier|*
name|line
parameter_list|)
block|{
name|expressionS
name|op_expr
decl_stmt|;
name|unsigned
name|int
name|op_mask
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|skip_space
argument_list|(
operator|*
name|line
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|*
name|op
condition|)
block|{
comment|/* Any register operand.  */
case|case
literal|'w'
case|:
case|case
literal|'d'
case|:
case|case
literal|'r'
case|:
case|case
literal|'a'
case|:
case|case
literal|'v'
case|:
if|if
condition|(
operator|*
name|str
operator|==
literal|'r'
operator|||
operator|*
name|str
operator|==
literal|'R'
condition|)
block|{
name|char
name|r_name
index|[
literal|20
index|]
decl_stmt|;
name|str
operator|=
name|extract_word
argument_list|(
name|str
argument_list|,
name|r_name
argument_list|,
sizeof|sizeof
argument_list|(
name|r_name
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|r_name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|r_name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|op_mask
operator|=
name|r_name
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|r_name
index|[
literal|1
index|]
operator|!=
literal|'0'
operator|&&
name|ISDIGIT
argument_list|(
name|r_name
index|[
literal|2
index|]
argument_list|)
operator|&&
name|r_name
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
name|op_mask
operator|=
operator|(
name|r_name
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|r_name
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|op_mask
operator|=
name|avr_get_constant
argument_list|(
name|str
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|op_mask
operator|<=
literal|31
condition|)
block|{
switch|switch
condition|(
operator|*
name|op
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|op_mask
operator|<
literal|16
operator|||
name|op_mask
operator|>
literal|23
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register r16-r23 required"
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator|-=
literal|16
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|op_mask
operator|<
literal|16
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register number above 15 required"
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator|-=
literal|16
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|op_mask
operator|&
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"even register number required"
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|op_mask
operator|&
literal|1
operator|)
operator|||
name|op_mask
operator|<
literal|24
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register r24, r26, r28 or r30 required"
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator|=
operator|(
name|op_mask
operator|-
literal|24
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register name or number from 0 to 31 required"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|str
operator|=
name|skip_space
argument_list|(
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|op_mask
operator|=
literal|0x1002
expr_stmt|;
block|}
name|c
operator|=
name|TOLOWER
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
name|op_mask
operator||=
literal|0x100c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
name|op_mask
operator||=
literal|0x8
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'z'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"pointer register (X, Y or Z) required"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|op_mask
operator|&
literal|2
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot both predecrement and postincrement"
argument_list|)
argument_list|)
expr_stmt|;
name|op_mask
operator||=
literal|0x1001
expr_stmt|;
block|}
comment|/* avr1 can do "ld r,Z" and "st Z,r" but no other pointer 	   registers, no predecrement, no postincrement.  */
if|if
condition|(
operator|!
name|avr_opt
operator|.
name|all_opcodes
operator|&&
operator|(
name|op_mask
operator|&
literal|0x100F
operator|)
operator|&&
operator|!
operator|(
name|avr_mcu
operator|->
name|isa
operator|&
name|AVR_ISA_SRAM
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"addressing mode not supported"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't predecrement"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|str
operator|==
literal|'z'
operator|||
operator|*
name|str
operator|==
literal|'Z'
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"pointer register Z required"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
operator|++
name|str
expr_stmt|;
name|op_mask
operator||=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
block|{
name|char
name|c
init|=
name|TOLOWER
argument_list|(
operator|*
name|str
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
name|op_mask
operator||=
literal|0x8
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'z'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"pointer register (Y or Z) required"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'+'
condition|)
block|{
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|avr_offset_expression
argument_list|(
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|3
argument_list|,
operator|&
name|op_expr
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_AVR_6
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
name|str
operator|=
name|parse_exp
argument_list|(
name|str
argument_list|,
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|opcode
operator|->
name|insn_size
operator|*
literal|2
argument_list|,
operator|&
name|op_expr
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_AVR_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|str
operator|=
name|parse_exp
argument_list|(
name|str
argument_list|,
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|opcode
operator|->
name|insn_size
operator|*
literal|2
argument_list|,
operator|&
name|op_expr
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_AVR_13_PCREL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|str
operator|=
name|parse_exp
argument_list|(
name|str
argument_list|,
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|opcode
operator|->
name|insn_size
operator|*
literal|2
argument_list|,
operator|&
name|op_expr
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_AVR_7_PCREL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|str
operator|=
name|parse_exp
argument_list|(
name|str
argument_list|,
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|2
argument_list|,
name|opcode
operator|->
name|insn_size
operator|*
literal|2
argument_list|,
operator|&
name|op_expr
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
block|{
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|r_type
operator|=
name|avr_ldi_expression
argument_list|(
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|3
argument_list|,
operator|&
name|op_expr
argument_list|,
name|FALSE
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
operator|~
name|avr_get_constant
argument_list|(
name|str
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|op_mask
operator||=
operator|(
name|x
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'K'
case|:
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|avr_offset_expression
argument_list|(
operator|&
name|op_expr
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|3
argument_list|,
operator|&
name|op_expr
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_AVR_6_ADIW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
name|avr_get_constant
argument_list|(
name|str
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|==
literal|'S'
condition|)
name|x
operator|<<=
literal|4
expr_stmt|;
name|op_mask
operator||=
name|x
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
name|avr_get_constant
argument_list|(
name|str
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|op_mask
operator||=
operator|(
name|x
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x30
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
name|avr_get_constant
argument_list|(
name|str
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|op_mask
operator||=
name|x
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown constraint `%c'"
argument_list|)
argument_list|,
operator|*
name|op
argument_list|)
expr_stmt|;
block|}
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|op_mask
return|;
block|}
end_function

begin_comment
comment|/* Parse instruction operands.    Return binary opcode.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|avr_operands
parameter_list|(
name|struct
name|avr_opcodes_s
modifier|*
name|opcode
parameter_list|,
name|char
modifier|*
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|op
init|=
name|opcode
operator|->
name|constraints
decl_stmt|;
name|unsigned
name|int
name|bin
init|=
name|opcode
operator|->
name|bin_opcode
decl_stmt|;
name|char
modifier|*
name|frag
init|=
name|frag_more
argument_list|(
name|opcode
operator|->
name|insn_size
operator|*
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|line
decl_stmt|;
name|int
name|where
init|=
name|frag
operator|-
name|frag_now
operator|->
name|fr_literal
decl_stmt|;
specifier|static
name|unsigned
name|int
name|prev
init|=
literal|0
decl_stmt|;
comment|/* Previous opcode.  */
comment|/* Opcode have operands.  */
if|if
condition|(
operator|*
name|op
condition|)
block|{
name|unsigned
name|int
name|reg1
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|reg2
init|=
literal|0
decl_stmt|;
name|int
name|reg1_present
init|=
literal|0
decl_stmt|;
name|int
name|reg2_present
init|=
literal|0
decl_stmt|;
comment|/* Parse first operand.  */
if|if
condition|(
name|REGISTER_P
argument_list|(
operator|*
name|op
argument_list|)
condition|)
name|reg1_present
operator|=
literal|1
expr_stmt|;
name|reg1
operator|=
name|avr_operand
argument_list|(
name|opcode
argument_list|,
name|where
argument_list|,
name|op
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
operator|++
name|op
expr_stmt|;
comment|/* Parse second operand.  */
if|if
condition|(
operator|*
name|op
condition|)
block|{
if|if
condition|(
operator|*
name|op
operator|==
literal|','
condition|)
operator|++
name|op
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|==
literal|'='
condition|)
block|{
name|reg2
operator|=
name|reg1
expr_stmt|;
name|reg2_present
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REGISTER_P
argument_list|(
operator|*
name|op
argument_list|)
condition|)
name|reg2_present
operator|=
literal|1
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`,' required"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|avr_operand
argument_list|(
name|opcode
argument_list|,
name|where
argument_list|,
name|op
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg1_present
operator|&&
name|reg2_present
condition|)
name|reg2
operator|=
operator|(
name|reg2
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|reg2
operator|<<
literal|5
operator|)
operator|&
literal|0x200
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2_present
condition|)
name|reg2
operator|<<=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|reg1_present
condition|)
name|reg1
operator|<<=
literal|4
expr_stmt|;
name|bin
operator||=
name|reg1
operator||
name|reg2
expr_stmt|;
block|}
comment|/* Detect undefined combinations (like ld r31,Z+).  */
if|if
condition|(
operator|!
name|avr_opt
operator|.
name|all_opcodes
operator|&&
name|AVR_UNDEF_P
argument_list|(
name|bin
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"undefined combination of operands"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|insn_size
operator|==
literal|2
condition|)
block|{
comment|/* Warn if the previous opcode was cpse/sbic/sbis/sbrc/sbrs          (AVR core bug, fixed in the newer devices).  */
if|if
condition|(
operator|!
operator|(
name|avr_opt
operator|.
name|no_skip_bug
operator|||
operator|(
name|avr_mcu
operator|->
name|isa
operator|&
operator|(
name|AVR_ISA_MUL
operator||
name|AVR_ISA_MOVW
operator|)
operator|)
operator|)
operator|&&
name|AVR_SKIP_P
argument_list|(
name|prev
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"skipping two-word instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bin
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|prev
operator|=
name|bin
expr_stmt|;
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|bin
return|;
block|}
end_function

begin_comment
comment|/* GAS will call this function for each section at the end of the assembly,    to permit the CPU backend to adjust the alignment of a section.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If you define this macro, it should return the offset between the    address of a PC relative fixup and the position from which the PC    relative adjustment should be made.  On many processors, the base    of a PC relative instruction is the next instruction, so this    macro would return the length of an instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* GAS will call this for each fixup.  It should store the correct    value in the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|long
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|segT
name|s
init|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|seg
operator|||
name|s
operator|==
name|absolute_section
condition|)
block|{
name|value
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We don't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_7_PCREL
case|:
case|case
name|BFD_RELOC_AVR_13_PCREL
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_AVR_CALL
case|:
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_AVR_7_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Instruction addresses are always right-shifted by 1.  */
name|value
operator|>>=
literal|1
expr_stmt|;
operator|--
name|value
expr_stmt|;
comment|/* Correct PC.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|64
operator|||
name|value
operator|>
literal|63
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|3
operator|)
operator|&
literal|0x3f8
expr_stmt|;
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator||
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_13_PCREL
case|:
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Instruction addresses are always right-shifted by 1.  */
name|value
operator|>>=
literal|1
expr_stmt|;
operator|--
name|value
expr_stmt|;
comment|/* Correct PC.  */
if|if
condition|(
name|value
operator|<
operator|-
literal|2048
operator|||
name|value
operator|>
literal|2047
condition|)
block|{
comment|/* No wrap for devices with>8K of program memory.  */
if|if
condition|(
operator|(
name|avr_mcu
operator|->
name|isa
operator|&
name|AVR_ISA_MEGA
operator|)
operator|||
name|avr_opt
operator|.
name|no_wrap
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|&=
literal|0xfff
expr_stmt|;
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator||
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_16_PM
case|:
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator|>>
literal|1
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_LDI
case|:
if|if
condition|(
name|value
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_6
case|:
if|if
condition|(
operator|(
name|value
operator|>
literal|63
operator|)
operator|||
operator|(
name|value
operator|<
literal|0
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
operator|(
operator|(
name|value
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
literal|3
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_6_ADIW
case|:
if|if
condition|(
operator|(
name|value
operator|>
literal|63
operator|)
operator|||
operator|(
name|value
operator|<
literal|0
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
operator|(
name|value
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x30
operator|)
operator|<<
literal|2
operator|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_LO8_LDI
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HI8_LDI
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_MS8_LDI
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HH8_LDI
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_LO8_LDI_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HI8_LDI_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|8
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_MS8_LDI_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|24
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HH8_LDI_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|16
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_LO8_LDI_PM
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|1
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HI8_LDI_PM
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|9
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HH8_LDI_PM
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
name|value
operator|>>
literal|17
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_LO8_LDI_PM_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|1
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HI8_LDI_PM_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|9
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_HH8_LDI_PM_NEG
case|:
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator||
name|LDI_IMMEDIATE
argument_list|(
operator|-
name|value
operator|>>
literal|17
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_AVR_CALL
case|:
block|{
name|unsigned
name|long
name|x
decl_stmt|;
name|x
operator|=
name|bfd_getl16
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd address operand: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|>>=
literal|1
expr_stmt|;
name|x
operator||=
operator|(
operator|(
name|value
operator|&
literal|0x10000
operator|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|3
operator|)
operator|&
literal|0x1f00000
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|bfd_putl16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|)
argument_list|,
name|where
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"line %d: unknown relocation type: 0x%x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
operator|-
name|BFD_RELOC_AVR_HI8_LDI_NEG
case|:
case|case
operator|-
name|BFD_RELOC_AVR_HI8_LDI
case|:
case|case
operator|-
name|BFD_RELOC_AVR_LO8_LDI_NEG
case|:
case|case
operator|-
name|BFD_RELOC_AVR_LO8_LDI
case|:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"only constant expression allowed"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* GAS will call this to generate a reloc, passing the resulting reloc    to `bfd_install_relocation'.  This currently works poorly, as    `bfd_install_relocation' often does the wrong thing, and instances of    `tc_gen_reloc' have been written to work around the problems, which    in turns makes it difficult to fix `bfd_install_relocation'.  */
end_comment

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
name|long
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Difference of symbols in different sections is not supported"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We are dealing with two symbols defined in the same section.           Let us fix-up them here.  */
name|value
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
comment|/* When fx_addsy and fx_subsy both are zero, md_apply_fix          only takes it's second operands for the fixup value.  */
name|fixp
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
name|md_apply_fix
argument_list|(
name|fixp
argument_list|,
operator|(
name|valueT
operator|*
operator|)
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|avr_opcodes_s
modifier|*
name|opcode
decl_stmt|;
name|char
name|op
index|[
literal|11
index|]
decl_stmt|;
name|str
operator|=
name|skip_space
argument_list|(
name|extract_word
argument_list|(
name|str
argument_list|,
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
index|[
literal|0
index|]
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|(
expr|struct
name|avr_opcodes_s
operator|*
operator|)
name|hash_find
argument_list|(
name|avr_hash
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode `%s'"
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Special case for opcodes with optional operands (lpm, elpm) -      version with operands exists in avr_opcodes[] in the next entry.  */
if|if
condition|(
operator|*
name|str
operator|&&
operator|*
name|opcode
operator|->
name|constraints
operator|==
literal|'?'
condition|)
operator|++
name|opcode
expr_stmt|;
if|if
condition|(
operator|!
name|avr_opt
operator|.
name|all_opcodes
operator|&&
operator|(
name|opcode
operator|->
name|isa
operator|&
name|avr_mcu
operator|->
name|isa
operator|)
operator|!=
name|opcode
operator|->
name|isa
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal opcode %s for mcu %s"
argument_list|)
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
name|avr_mcu
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* We used to set input_line_pointer to the result of get_operands,      but that is wrong.  Our caller assumes we don't change it.  */
block|{
name|char
modifier|*
name|t
init|=
name|input_line_pointer
decl_stmt|;
name|avr_operands
argument_list|(
name|opcode
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|skip_space
argument_list|(
name|str
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"garbage at end of line"
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Flag to pass `pm' mode between `avr_parse_cons_expression' and    `avr_cons_fix_new'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exp_mod_pm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse special CONS expression: pm (expression)    which is used for addressing to a program memory.    Relocation: BFD_RELOC_AVR_16_PM.  */
end_comment

begin_function
name|void
name|avr_parse_cons_expression
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|exp_mod_pm
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|input_line_pointer
operator|=
name|skip_space
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|pm_name
init|=
literal|"pm"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|pm_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
name|pm_name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|=
name|skip_space
argument_list|(
name|input_line_pointer
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'('
condition|)
block|{
name|input_line_pointer
operator|=
name|skip_space
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exp_mod_pm
operator|=
literal|1
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|')'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`)' required"
argument_list|)
argument_list|)
expr_stmt|;
name|exp_mod_pm
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|input_line_pointer
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|avr_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
if|if
condition|(
name|exp_mod_pm
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal %srelocation size: %d"
argument_list|)
argument_list|,
literal|""
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_AVR_16_PM
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal %srelocation size: %d"
argument_list|)
argument_list|,
literal|"`pm' "
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|exp_mod_pm
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

