begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-i960.c - All the i80960-specific stuff    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2005, 2006    Free Software Foundation, Inc.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* See comment on md_parse_option for 80960-specific invocation options.  */
end_comment

begin_comment
comment|/* There are 4 different lengths of (potentially) symbol-based displacements    in the 80960 instruction set, each of which could require address fix-ups    and (in the case of external symbols) emission of relocation directives:     32-bit (MEMB)         This is a standard length for the base assembler and requires no         special action.     13-bit (COBR)         This is a non-standard length, but the base assembler has a         hook for bit field address fixups: the fixS structure can         point to a descriptor of the field, in which case our         md_number_to_field() routine gets called to process it.          I made the hook a little cleaner by having fix_new() (in the base         assembler) return a pointer to the fixS in question.  And I made it a         little simpler by storing the field size (in this case 13) instead of         of a pointer to another structure:  80960 displacements are ALWAYS         stored in the low-order bits of a 4-byte word.          Since the target of a COBR cannot be external, no relocation         directives for this size displacement have to be generated.         But the base assembler had to be modified to issue error         messages if the symbol did turn out to be external.     24-bit (CTRL)         Fixups are handled as for the 13-bit case (except that 24 is stored         in the fixS).          The relocation directive generated is the same as that for the 32-bit         displacement, except that it's PC-relative (the 32-bit displacement         never is).   The i80960 version of the linker needs a mod to         distinguish and handle the 24-bit case.     12-bit (MEMA)         MEMA formats are always promoted to MEMB (32-bit) if the displacement         is based on a symbol, because it could be relocated at link time.         The only time we use the 12-bit format is if an absolute value of         less than 4096 is specified, in which case we need neither a fixup nor         a relocation directive.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i960.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TC_S_IS_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|((1<= S_GET_OTHER (s))&& (S_GET_OTHER (s)<= 32))
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BALNAME
parameter_list|(
name|s
parameter_list|)
value|(S_GET_OTHER (s) == N_BALNAME)
end_define

begin_define
define|#
directive|define
name|TC_S_IS_CALLNAME
parameter_list|(
name|s
parameter_list|)
value|(S_GET_OTHER (s) == N_CALLNAME)
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BADPROC
parameter_list|(
name|s
parameter_list|)
value|((S_GET_OTHER (s) != 0)&& !TC_S_IS_CALLNAME (s)&& !TC_S_IS_BALNAME (s)&& !TC_S_IS_SYSPROC (s))
end_define

begin_define
define|#
directive|define
name|TC_S_SET_SYSPROC
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(S_SET_OTHER ((s), (p) + 1))
end_define

begin_define
define|#
directive|define
name|TC_S_GET_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|(S_GET_OTHER (s) - 1)
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_BALNAME
parameter_list|(
name|s
parameter_list|)
value|(S_SET_OTHER ((s), N_BALNAME))
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_CALLNAME
parameter_list|(
name|s
parameter_list|)
value|(S_SET_OTHER ((s), N_CALLNAME))
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|{;}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! OBJ_A/BOUT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_define
define|#
directive|define
name|TC_S_IS_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|(S_GET_STORAGE_CLASS (s) == C_SCALL)
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BALNAME
parameter_list|(
name|s
parameter_list|)
value|(SF_GET_BALNAME (s))
end_define

begin_define
define|#
directive|define
name|TC_S_IS_CALLNAME
parameter_list|(
name|s
parameter_list|)
value|(SF_GET_CALLNAME (s))
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BADPROC
parameter_list|(
name|s
parameter_list|)
value|(TC_S_IS_SYSPROC (s)&& TC_S_GET_SYSPROC (s)< 0&& 31< TC_S_GET_SYSPROC (s))
end_define

begin_define
define|#
directive|define
name|TC_S_SET_SYSPROC
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|((s)->sy_symbol.ost_auxent[1].x_sc.x_stindx = (p))
end_define

begin_define
define|#
directive|define
name|TC_S_GET_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|((s)->sy_symbol.ost_auxent[1].x_sc.x_stindx)
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_BALNAME
parameter_list|(
name|s
parameter_list|)
value|(SF_SET_BALNAME (s))
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_CALLNAME
parameter_list|(
name|s
parameter_list|)
value|(SF_SET_CALLNAME (s))
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|(S_SET_STORAGE_CLASS ((s), C_SCALL))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! OBJ_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_define
define|#
directive|define
name|TC_S_IS_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BALNAME
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TC_S_IS_CALLNAME
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TC_S_IS_BADPROC
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TC_S_SET_SYSPROC
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TC_S_GET_SYSPROC
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_BALNAME
parameter_list|(
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_CALLNAME
parameter_list|(
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TC_S_FORCE_TO_SYSPROC
parameter_list|(
name|s
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|COFF, a.out, b.out, and ELF are the only supported formats.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! OBJ_ELF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! OBJ_COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! OBJ_A/BOUT */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local i80960 routines.  */
end_comment

begin_struct_decl
struct_decl|struct
name|memS
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|regop
struct_decl|;
end_struct_decl

begin_comment
comment|/* See md_parse_option() for meanings of these options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|norelax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -norelax switch seen.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|instrument_branches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -b switch seen.  */
end_comment

begin_comment
comment|/* Characters that always start a comment.    If the pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.     Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant,    as in 0f12.456 or 0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDtT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table used by base assembler to relax addresses based on varying length    instructions.  The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will add to the size of the current frag      4) which index into the table to try if we can't fit into this one.     For i80960, the only application is the (de-)optimization of cobr    instructions into separate compare and branch instructions when a 13-bit    displacement won't hack it.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* State 0 => no more relaxation possible.  */
block|{
literal|4088
block|,
operator|-
literal|4096
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* State 1: conditional branch (cobr).  */
block|{
literal|0x800000
operator|-
literal|8
block|,
operator|-
literal|0x800000
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* State 2: compare (reg)& branch (ctrl).  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the machine dependent pseudo-ops.     This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:         pseudo-op name without dot         function to call to execute this pseudo-op         integer arg to pass to the function.  */
end_comment

begin_define
define|#
directive|define
name|S_LEAFPROC
value|1
end_define

begin_define
define|#
directive|define
name|S_SYSPROC
value|2
end_define

begin_comment
comment|/* Macros to extract info from an 'expressionS' structure 'e'.  */
end_comment

begin_define
define|#
directive|define
name|adds
parameter_list|(
name|e
parameter_list|)
value|e.X_add_symbol
end_define

begin_define
define|#
directive|define
name|offs
parameter_list|(
name|e
parameter_list|)
value|e.X_add_number
end_define

begin_comment
comment|/* Branch-prediction bits for CTRL/COBR format opcodes.  */
end_comment

begin_define
define|#
directive|define
name|BP_MASK
value|0x00000002
end_define

begin_comment
comment|/* Mask for branch-prediction bit.  */
end_comment

begin_define
define|#
directive|define
name|BP_TAKEN
value|0x00000000
end_define

begin_comment
comment|/* Value to OR in to predict branch.  */
end_comment

begin_define
define|#
directive|define
name|BP_NOT_TAKEN
value|0x00000002
end_define

begin_comment
comment|/* Value to OR in to predict no branch.  */
end_comment

begin_comment
comment|/* Some instruction opcodes that we need explicitly.  */
end_comment

begin_define
define|#
directive|define
name|BE
value|0x12000000
end_define

begin_define
define|#
directive|define
name|BG
value|0x11000000
end_define

begin_define
define|#
directive|define
name|BGE
value|0x13000000
end_define

begin_define
define|#
directive|define
name|BL
value|0x14000000
end_define

begin_define
define|#
directive|define
name|BLE
value|0x16000000
end_define

begin_define
define|#
directive|define
name|BNE
value|0x15000000
end_define

begin_define
define|#
directive|define
name|BNO
value|0x10000000
end_define

begin_define
define|#
directive|define
name|BO
value|0x17000000
end_define

begin_define
define|#
directive|define
name|CHKBIT
value|0x5a002700
end_define

begin_define
define|#
directive|define
name|CMPI
value|0x5a002080
end_define

begin_define
define|#
directive|define
name|CMPO
value|0x5a002000
end_define

begin_define
define|#
directive|define
name|B
value|0x08000000
end_define

begin_define
define|#
directive|define
name|BAL
value|0x0b000000
end_define

begin_define
define|#
directive|define
name|CALL
value|0x09000000
end_define

begin_define
define|#
directive|define
name|CALLS
value|0x66003800
end_define

begin_define
define|#
directive|define
name|RET
value|0x0a000000
end_define

begin_comment
comment|/* These masks are used to build up a set of MEMB mode bits.  */
end_comment

begin_define
define|#
directive|define
name|A_BIT
value|0x0400
end_define

begin_define
define|#
directive|define
name|I_BIT
value|0x0800
end_define

begin_define
define|#
directive|define
name|MEMB_BIT
value|0x1000
end_define

begin_define
define|#
directive|define
name|D_BIT
value|0x2000
end_define

begin_comment
comment|/* Mask for the only mode bit in a MEMA instruction (if set, abase reg is    used).  */
end_comment

begin_define
define|#
directive|define
name|MEMA_ABASE
value|0x2000
end_define

begin_comment
comment|/* Info from which a MEMA or MEMB format instruction can be generated.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|memS
block|{
comment|/* (First) 32 bits of instruction.  */
name|long
name|opcode
decl_stmt|;
comment|/* 0-(none), 12- or, 32-bit displacement needed.  */
name|int
name|disp
decl_stmt|;
comment|/* The expression in the source instruction from which the        displacement should be determined.  */
name|char
modifier|*
name|e
decl_stmt|;
block|}
name|memS
typedef|;
end_typedef

begin_comment
comment|/* The two pieces of info we need to generate a register operand.  */
end_comment

begin_struct
struct|struct
name|regop
block|{
name|int
name|mode
decl_stmt|;
comment|/* 0 =>local/global/spec reg; 1=> literal or fp reg.  */
name|int
name|special
decl_stmt|;
comment|/* 0 =>not a sfr;  1=> is a sfr (not valid w/mode=0).  */
name|int
name|n
decl_stmt|;
comment|/* Register number or literal value.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Number and assembler mnemonic for all registers that can appear in    operands.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|reg_num
decl_stmt|;
block|}
name|regnames
index|[]
init|=
block|{
block|{
literal|"pfp"
block|,
literal|0
block|}
block|,
block|{
literal|"sp"
block|,
literal|1
block|}
block|,
block|{
literal|"rip"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"g0"
block|,
literal|16
block|}
block|,
block|{
literal|"g1"
block|,
literal|17
block|}
block|,
block|{
literal|"g2"
block|,
literal|18
block|}
block|,
block|{
literal|"g3"
block|,
literal|19
block|}
block|,
block|{
literal|"g4"
block|,
literal|20
block|}
block|,
block|{
literal|"g5"
block|,
literal|21
block|}
block|,
block|{
literal|"g6"
block|,
literal|22
block|}
block|,
block|{
literal|"g7"
block|,
literal|23
block|}
block|,
block|{
literal|"g8"
block|,
literal|24
block|}
block|,
block|{
literal|"g9"
block|,
literal|25
block|}
block|,
block|{
literal|"g10"
block|,
literal|26
block|}
block|,
block|{
literal|"g11"
block|,
literal|27
block|}
block|,
block|{
literal|"g12"
block|,
literal|28
block|}
block|,
block|{
literal|"g13"
block|,
literal|29
block|}
block|,
block|{
literal|"g14"
block|,
literal|30
block|}
block|,
block|{
literal|"fp"
block|,
literal|31
block|}
block|,
comment|/* Numbers for special-function registers are for assembler internal      use only: they are scaled back to range [0-31] for binary output.  */
define|#
directive|define
name|SF0
value|32
block|{
literal|"sf0"
block|,
literal|32
block|}
block|,
block|{
literal|"sf1"
block|,
literal|33
block|}
block|,
block|{
literal|"sf2"
block|,
literal|34
block|}
block|,
block|{
literal|"sf3"
block|,
literal|35
block|}
block|,
block|{
literal|"sf4"
block|,
literal|36
block|}
block|,
block|{
literal|"sf5"
block|,
literal|37
block|}
block|,
block|{
literal|"sf6"
block|,
literal|38
block|}
block|,
block|{
literal|"sf7"
block|,
literal|39
block|}
block|,
block|{
literal|"sf8"
block|,
literal|40
block|}
block|,
block|{
literal|"sf9"
block|,
literal|41
block|}
block|,
block|{
literal|"sf10"
block|,
literal|42
block|}
block|,
block|{
literal|"sf11"
block|,
literal|43
block|}
block|,
block|{
literal|"sf12"
block|,
literal|44
block|}
block|,
block|{
literal|"sf13"
block|,
literal|45
block|}
block|,
block|{
literal|"sf14"
block|,
literal|46
block|}
block|,
block|{
literal|"sf15"
block|,
literal|47
block|}
block|,
block|{
literal|"sf16"
block|,
literal|48
block|}
block|,
block|{
literal|"sf17"
block|,
literal|49
block|}
block|,
block|{
literal|"sf18"
block|,
literal|50
block|}
block|,
block|{
literal|"sf19"
block|,
literal|51
block|}
block|,
block|{
literal|"sf20"
block|,
literal|52
block|}
block|,
block|{
literal|"sf21"
block|,
literal|53
block|}
block|,
block|{
literal|"sf22"
block|,
literal|54
block|}
block|,
block|{
literal|"sf23"
block|,
literal|55
block|}
block|,
block|{
literal|"sf24"
block|,
literal|56
block|}
block|,
block|{
literal|"sf25"
block|,
literal|57
block|}
block|,
block|{
literal|"sf26"
block|,
literal|58
block|}
block|,
block|{
literal|"sf27"
block|,
literal|59
block|}
block|,
block|{
literal|"sf28"
block|,
literal|60
block|}
block|,
block|{
literal|"sf29"
block|,
literal|61
block|}
block|,
block|{
literal|"sf30"
block|,
literal|62
block|}
block|,
block|{
literal|"sf31"
block|,
literal|63
block|}
block|,
comment|/* Numbers for floating point registers are for assembler internal      use only: they are scaled back to [0-3] for binary output.  */
define|#
directive|define
name|FP0
value|64
block|{
literal|"fp0"
block|,
literal|64
block|}
block|,
block|{
literal|"fp1"
block|,
literal|65
block|}
block|,
block|{
literal|"fp2"
block|,
literal|66
block|}
block|,
block|{
literal|"fp3"
block|,
literal|67
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* END OF LIST */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_RG_REG
parameter_list|(
name|n
parameter_list|)
value|((0<= (n))&& ((n)< SF0))
end_define

begin_define
define|#
directive|define
name|IS_SF_REG
parameter_list|(
name|n
parameter_list|)
value|((SF0<= (n))&& ((n)< FP0))
end_define

begin_define
define|#
directive|define
name|IS_FP_REG
parameter_list|(
name|n
parameter_list|)
value|((n)>= FP0)
end_define

begin_comment
comment|/* Number and assembler mnemonic for all registers that can appear as    'abase' (indirect addressing) registers.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|areg_name
decl_stmt|;
name|int
name|areg_num
decl_stmt|;
block|}
name|aregs
index|[]
init|=
block|{
block|{
literal|"(pfp)"
block|,
literal|0
block|}
block|,
block|{
literal|"(sp)"
block|,
literal|1
block|}
block|,
block|{
literal|"(rip)"
block|,
literal|2
block|}
block|,
block|{
literal|"(r3)"
block|,
literal|3
block|}
block|,
block|{
literal|"(r4)"
block|,
literal|4
block|}
block|,
block|{
literal|"(r5)"
block|,
literal|5
block|}
block|,
block|{
literal|"(r6)"
block|,
literal|6
block|}
block|,
block|{
literal|"(r7)"
block|,
literal|7
block|}
block|,
block|{
literal|"(r8)"
block|,
literal|8
block|}
block|,
block|{
literal|"(r9)"
block|,
literal|9
block|}
block|,
block|{
literal|"(r10)"
block|,
literal|10
block|}
block|,
block|{
literal|"(r11)"
block|,
literal|11
block|}
block|,
block|{
literal|"(r12)"
block|,
literal|12
block|}
block|,
block|{
literal|"(r13)"
block|,
literal|13
block|}
block|,
block|{
literal|"(r14)"
block|,
literal|14
block|}
block|,
block|{
literal|"(r15)"
block|,
literal|15
block|}
block|,
block|{
literal|"(g0)"
block|,
literal|16
block|}
block|,
block|{
literal|"(g1)"
block|,
literal|17
block|}
block|,
block|{
literal|"(g2)"
block|,
literal|18
block|}
block|,
block|{
literal|"(g3)"
block|,
literal|19
block|}
block|,
block|{
literal|"(g4)"
block|,
literal|20
block|}
block|,
block|{
literal|"(g5)"
block|,
literal|21
block|}
block|,
block|{
literal|"(g6)"
block|,
literal|22
block|}
block|,
block|{
literal|"(g7)"
block|,
literal|23
block|}
block|,
block|{
literal|"(g8)"
block|,
literal|24
block|}
block|,
block|{
literal|"(g9)"
block|,
literal|25
block|}
block|,
block|{
literal|"(g10)"
block|,
literal|26
block|}
block|,
block|{
literal|"(g11)"
block|,
literal|27
block|}
block|,
block|{
literal|"(g12)"
block|,
literal|28
block|}
block|,
block|{
literal|"(g13)"
block|,
literal|29
block|}
block|,
block|{
literal|"(g14)"
block|,
literal|30
block|}
block|,
block|{
literal|"(fp)"
block|,
literal|31
block|}
block|,
define|#
directive|define
name|IPREL
value|32
comment|/* For assembler internal use only: this number never appears in binary      output.  */
block|{
literal|"(ip)"
block|,
name|IPREL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* END OF LIST */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash tables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register name hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|areg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abase register hash table.  */
end_comment

begin_comment
comment|/* Architecture for which we are assembling.  */
end_comment

begin_define
define|#
directive|define
name|ARCH_ANY
value|0
end_define

begin_comment
comment|/* Default: no architecture checking done.  */
end_comment

begin_define
define|#
directive|define
name|ARCH_KA
value|1
end_define

begin_define
define|#
directive|define
name|ARCH_KB
value|2
end_define

begin_define
define|#
directive|define
name|ARCH_MC
value|3
end_define

begin_define
define|#
directive|define
name|ARCH_CA
value|4
end_define

begin_define
define|#
directive|define
name|ARCH_JX
value|5
end_define

begin_define
define|#
directive|define
name|ARCH_HX
value|6
end_define

begin_decl_stmt
name|int
name|architecture
init|=
name|ARCH_ANY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Architecture requested on invocation line.  */
end_comment

begin_decl_stmt
name|int
name|iclasses_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OR of instruction classes (I_* constants) 				      for which we've actually assembled 				        instructions.  */
end_comment

begin_comment
comment|/* BRANCH-PREDICTION INSTRUMENTATION          The following supports generation of branch-prediction instrumentation         (turned on by -b switch).  The instrumentation collects counts         of branches taken/not-taken for later input to a utility that will         set the branch prediction bits of the instructions in accordance with         the behavior observed.  (Note that the KX series does not have         brach-prediction.)          The instrumentation consists of:          (1) before and after each conditional branch, a call to an external             routine that increments and steps over an inline counter.  The             counter itself, initialized to 0, immediately follows the call             instruction.  For each branch, the counter following the branch             is the number of times the branch was not taken, and the difference             between the counters is the number of times it was taken.  An             example of an instrumented conditional branch:                                  call    BR_CNT_FUNC                                 .word   0                 LBRANCH23:      be      label                                 call    BR_CNT_FUNC                                 .word   0          (2) a table of pointers to the instrumented branches, so that an             external postprocessing routine can locate all of the counters.             the table begins with a 2-word header: a pointer to the next in             a linked list of such tables (initialized to 0);  and a count             of the number of entries in the table (exclusive of the header.              Note that input source code is expected to already contain calls             an external routine that will link the branch local table into a             list of such tables.  */
end_comment

begin_comment
comment|/* Number of branches instrumented so far.  Also used to generate    unique local labels for each instrumented branch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|br_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BR_LABEL_BASE
value|"LBRANCH"
end_define

begin_comment
comment|/* Basename of local labels on instrumented branches, to avoid    conflict with compiler- generated local labels.  */
end_comment

begin_define
define|#
directive|define
name|BR_CNT_FUNC
value|"__inc_branch"
end_define

begin_comment
comment|/* Name of the external routine that will increment (and step over) an    inline counter.  */
end_comment

begin_define
define|#
directive|define
name|BR_TAB_NAME
value|"__BRANCH_TABLE__"
end_define

begin_comment
comment|/* Name of the table of pointers to branches.  A local (i.e.,    non-external) symbol.  */
end_comment

begin_function_decl
specifier|static
name|void
name|ctrl_fmt
parameter_list|(
name|char
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter.  */
specifier|const
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* Pointer into opcode table.  */
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* Value returned by hash functions.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|areg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* For some reason, the base assembler uses an empty string for "no      error message", instead of a NULL pointer.  */
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|oP
operator|=
name|i960_opcodes
init|;
name|oP
operator|->
name|name
operator|&&
operator|!
name|retval
condition|;
name|oP
operator|++
control|)
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|oP
operator|->
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|oP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regnames
index|[
name|i
index|]
operator|.
name|reg_name
operator|&&
operator|!
name|retval
condition|;
name|i
operator|++
control|)
name|retval
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regnames
index|[
name|i
index|]
operator|.
name|reg_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regnames
index|[
name|i
index|]
operator|.
name|reg_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aregs
index|[
name|i
index|]
operator|.
name|areg_name
operator|&&
operator|!
name|retval
condition|;
name|i
operator|++
control|)
name|retval
operator|=
name|hash_insert
argument_list|(
name|areg_hash
argument_list|,
name|aregs
index|[
name|i
index|]
operator|.
name|areg_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aregs
index|[
name|i
index|]
operator|.
name|areg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Hashing returned \"%s\"."
argument_list|)
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse_expr:		parse an expression     Use base assembler's expression parser to parse an expression.    It, unfortunately, runs off a global which we have to save/restore    in order to make it work for us.     An empty expression string is treated as an absolute 0.     Sets O_illegal regardless of expression evaluation if entire input    string is not consumed in the evaluation -- tolerate no dangling junk!  */
end_comment

begin_function
specifier|static
name|void
name|parse_expr
parameter_list|(
name|char
modifier|*
name|textP
parameter_list|,
comment|/* Text of expression to be parsed.  */
name|expressionS
modifier|*
name|expP
parameter_list|)
comment|/* Where to put the results of parsing.  */
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
comment|/* Save global here.  */
name|symbolS
modifier|*
name|symP
decl_stmt|;
name|know
argument_list|(
name|textP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|textP
operator|==
literal|'\0'
condition|)
block|{
comment|/* Treat empty string as absolute 0.  */
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
else|else
block|{
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Save global.  */
name|input_line_pointer
operator|=
name|textP
expr_stmt|;
comment|/* Make parser work for us.  */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|input_line_pointer
operator|-
name|textP
argument_list|)
operator|!=
name|strlen
argument_list|(
name|textP
argument_list|)
condition|)
comment|/* Did not consume all of the input.  */
name|expP
operator|->
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|symP
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|symP
operator|&&
operator|(
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symP
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* Register name in an expression.  */
comment|/* FIXME: this isn't much of a check any more.  */
name|expP
operator|->
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
comment|/* Restore global.  */
block|}
block|}
end_function

begin_comment
comment|/* emit:	output instruction binary     Output instruction binary, in target byte order, 4 bytes at a time.    Return pointer to where it was placed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|emit
parameter_list|(
name|long
name|instr
parameter_list|)
comment|/* Word to be output, host byte order.  */
block|{
name|char
modifier|*
name|toP
decl_stmt|;
comment|/* Where to output it.  */
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Allocate storage.  */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Convert to target byte order.  */
return|return
name|toP
return|;
block|}
end_function

begin_comment
comment|/* get_cdisp:	handle displacement for a COBR or CTRL instruction.     Parse displacement for a COBR or CTRL instruction.     If successful, output the instruction opcode and set up for it,    depending on the arg 'var_frag', either:   	    o an address fixup to be done when all symbol values are known, or   	    o a varying length code fragment, with address fixup info.  This   		will be done for cobr instructions that may have to be relaxed   		in to compare/branch instructions (8 bytes) if the final   		address displacement is greater than 13 bits.  */
end_comment

begin_function
specifier|static
name|void
name|get_cdisp
parameter_list|(
name|char
modifier|*
name|dispP
parameter_list|,
comment|/* Displacement as specified in source instruction.  */
name|char
modifier|*
name|ifmtP
parameter_list|,
comment|/* "COBR" or "CTRL" (for use in error message).  */
name|long
name|instr
parameter_list|,
comment|/* Instruction needing the displacement.  */
name|int
name|numbits
parameter_list|,
comment|/* # bits of displacement (13 for COBR, 24 for CTRL).  */
name|int
name|var_frag
parameter_list|,
comment|/* 1 if varying length code fragment should be emitted; 			   0 if an address fix should be emitted.  */
name|int
name|callj
parameter_list|)
comment|/* 1 if callj relocation should be done; else 0.  */
block|{
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Structure describing needed address fix.  */
name|char
modifier|*
name|outP
decl_stmt|;
comment|/* Where instruction binary is output to.  */
name|fixP
operator|=
name|NULL
expr_stmt|;
name|parse_expr
argument_list|(
name|dispP
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression syntax error"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|O_symbol
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|e
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|||
name|S_GET_SEGMENT
argument_list|(
name|e
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
if|if
condition|(
name|var_frag
condition|)
block|{
name|outP
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Allocate worst-case storage.  */
name|md_number_to_chars
argument_list|(
name|outP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|adds
argument_list|(
name|e
argument_list|)
argument_list|,
name|offs
argument_list|(
name|e
argument_list|)
argument_list|,
name|outP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set up a new fix structure, so address can be updated 	         when all symbol values are known.  */
name|outP
operator|=
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|outP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|adds
argument_list|(
name|e
argument_list|)
argument_list|,
name|offs
argument_list|(
name|e
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_tcbit
operator|=
name|callj
expr_stmt|;
comment|/* We want to modify a bit field when the address is 	         known.  But we don't need all the garbage in the 	         bit_fix structure.  So we're going to lie and store 	         the number of bits affected instead of a pointer.  */
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
operator|(
name|size_t
operator|)
name|numbits
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to branch into different segment"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"target of %s instruction must be a label"
argument_list|)
argument_list|,
name|ifmtP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|md_chars_to_number
parameter_list|(
name|char
modifier|*
name|val
parameter_list|,
comment|/* Value in target byte order.  */
name|int
name|n
parameter_list|)
comment|/* Number of bytes in the input.  */
block|{
name|int
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
init|;
name|n
operator|--
condition|;
control|)
block|{
name|retval
operator|<<=
literal|8
expr_stmt|;
name|retval
operator||=
operator|(
name|unsigned
name|char
operator|)
name|val
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* mema_to_memb:	convert a MEMA-format opcode to a MEMB-format opcode.     There are 2 possible MEMA formats:   	- displacement only   	- displacement + abase     They are distinguished by the setting of the MEMA_ABASE bit.  */
end_comment

begin_function
specifier|static
name|void
name|mema_to_memb
parameter_list|(
name|char
modifier|*
name|opcodeP
parameter_list|)
comment|/* Where to find the opcode, in target byte order.  */
block|{
name|long
name|opcode
decl_stmt|;
comment|/* Opcode in host byte order.  */
name|long
name|mode
decl_stmt|;
comment|/* Mode bits for MEMB instruction.  */
name|opcode
operator|=
name|md_chars_to_number
argument_list|(
name|opcodeP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|opcode
operator|&
name|MEMB_BIT
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MEMB_BIT
operator||
name|D_BIT
expr_stmt|;
if|if
condition|(
name|opcode
operator|&
name|MEMA_ABASE
condition|)
name|mode
operator||=
name|A_BIT
expr_stmt|;
name|opcode
operator|&=
literal|0xffffc000
expr_stmt|;
comment|/* Clear MEMA offset and mode bits.  */
name|opcode
operator||=
name|mode
expr_stmt|;
comment|/* Set MEMB mode bits.  */
name|md_number_to_chars
argument_list|(
name|opcodeP
argument_list|,
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* targ_has_sfr:     Return TRUE iff the target architecture supports the specified    special-function register (sfr).  */
end_comment

begin_function
specifier|static
name|int
name|targ_has_sfr
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* Number (0-31) of sfr.  */
block|{
switch|switch
condition|(
name|architecture
condition|)
block|{
case|case
name|ARCH_KA
case|:
case|case
name|ARCH_KB
case|:
case|case
name|ARCH_MC
case|:
case|case
name|ARCH_JX
case|:
return|return
literal|0
return|;
case|case
name|ARCH_HX
case|:
return|return
operator|(
operator|(
literal|0
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|4
operator|)
operator|)
return|;
case|case
name|ARCH_CA
case|:
default|default:
return|return
operator|(
operator|(
literal|0
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|2
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Look up a (suspected) register name in the register table and return the    associated register number (or -1 if not found).  */
end_comment

begin_function
specifier|static
name|int
name|get_regnum
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|)
comment|/* Suspected register name.  */
block|{
name|int
modifier|*
name|rP
decl_stmt|;
name|rP
operator|=
operator|(
name|int
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|regname
argument_list|)
expr_stmt|;
return|return
operator|(
name|rP
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
operator|*
name|rP
return|;
block|}
end_function

begin_comment
comment|/* syntax: Issue a syntax error.  */
end_comment

begin_function
specifier|static
name|void
name|syntax
parameter_list|(
name|void
parameter_list|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse_regop: parse a register operand.     In case of illegal operand, issue a message and return some valid    information so instruction processing can continue.  */
end_comment

begin_function
specifier|static
name|void
name|parse_regop
parameter_list|(
name|struct
name|regop
modifier|*
name|regopP
parameter_list|,
comment|/* Where to put description of register operand.  */
name|char
modifier|*
name|optext
parameter_list|,
comment|/* Text of operand.  */
name|char
name|opdesc
parameter_list|)
comment|/* Descriptor byte:  what's legal for this operand.  */
block|{
name|int
name|n
decl_stmt|;
comment|/* Register number.  */
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression.  */
comment|/* See if operand is a register.  */
name|n
operator|=
name|get_regnum
argument_list|(
name|optext
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|IS_RG_REG
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|/* Global or local register.  */
if|if
condition|(
operator|!
name|REG_ALIGN
argument_list|(
name|opdesc
argument_list|,
name|n
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unaligned register"
argument_list|)
argument_list|)
expr_stmt|;
name|regopP
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|IS_FP_REG
argument_list|(
name|n
argument_list|)
operator|&&
name|FP_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* Floating point register, and it's allowed.  */
name|regopP
operator|->
name|n
operator|=
name|n
operator|-
name|FP0
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|1
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|IS_SF_REG
argument_list|(
name|n
argument_list|)
operator|&&
name|SFR_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* Special-function register, and it's allowed.  */
name|regopP
operator|->
name|n
operator|=
name|n
operator|-
name|SF0
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|targ_has_sfr
argument_list|(
name|regopP
operator|->
name|n
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no such sfr in this architecture"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|LIT_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* How about a literal?  */
name|regopP
operator|->
name|mode
operator|=
literal|1
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FP_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* Floating point literal acceptable.  */
comment|/* Skip over 0f, 0d, or 0e prefix.  */
if|if
condition|(
operator|(
name|optext
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|optext
index|[
literal|1
index|]
operator|>=
literal|'d'
operator|)
operator|&&
operator|(
name|optext
index|[
literal|1
index|]
operator|<=
literal|'f'
operator|)
condition|)
name|optext
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"0.0"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"0"
argument_list|)
condition|)
block|{
name|regopP
operator|->
name|n
operator|=
literal|0x10
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"1.0"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"1"
argument_list|)
condition|)
block|{
name|regopP
operator|->
name|n
operator|=
literal|0x16
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Fixed point literal acceptable.  */
name|parse_expr
argument_list|(
name|optext
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|offs
argument_list|(
name|e
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|e
argument_list|)
operator|>
literal|31
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal literal"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|e
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|regopP
operator|->
name|n
operator|=
name|offs
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Nothing worked.  */
name|syntax
argument_list|()
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* Register r0 is always a good one.  */
name|regopP
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_ispec:	parse a memory operand for an index specification        Here, an "index specification" is taken to be anything surrounded    by square brackets and NOT followed by anything else.     If it's found, detach it from the input string, remove the surrounding    square brackets, and return a pointer to it.  Otherwise, return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_ispec
parameter_list|(
name|char
modifier|*
name|textP
parameter_list|)
comment|/* Pointer to memory operand from source instruction, no white space.  */
block|{
comment|/* Points to start of index specification.  */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Points to end of index specification.  */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Find opening square bracket, if any.  */
name|start
operator|=
name|strchr
argument_list|(
name|textP
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|NULL
condition|)
block|{
comment|/* Eliminate '[', detach from rest of operand.  */
operator|*
name|start
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unmatched '['"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Eliminate ']' and make sure it was the last thing 	     in the string.  */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|end
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"garbage after index spec ignored"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* parse_memop:	parse a memory operand    	This routine is based on the observation that the 4 mode bits of the   	MEMB format, taken individually, have fairly consistent meaning:    		 M3 (bit 13): 1 if displacement is present (D_BIT)   		 M2 (bit 12): 1 for MEMB instructions (MEMB_BIT)   		 M1 (bit 11): 1 if index is present (I_BIT)   		 M0 (bit 10): 1 if abase is present (A_BIT)    	So we parse the memory operand and set bits in the mode as we find   	things.  Then at the end, if we go to MEMB format, we need only set   	the MEMB bit (M2) and our mode is built for us.    	Unfortunately, I said "fairly consistent".  The exceptions:    		 DBIA   		 0100	Would seem illegal, but means "abase-only".    		 0101	Would seem to mean "abase-only" -- it means IP-relative.   			Must be converted to 0100.    		 0110	Would seem to mean "index-only", but is reserved.   			We turn on the D bit and provide a 0 displacement.    	The other thing to observe is that we parse from the right, peeling   	things * off as we go:  first any index spec, then any abase, then   	the displacement.  */
end_comment

begin_function
specifier|static
name|void
name|parse_memop
parameter_list|(
name|memS
modifier|*
name|memP
parameter_list|,
comment|/* Where to put the results.  */
name|char
modifier|*
name|argP
parameter_list|,
comment|/* Text of the operand to be parsed.  */
name|int
name|optype
parameter_list|)
comment|/* MEM1, MEM2, MEM4, MEM8, MEM12, or MEM16.  */
block|{
name|char
modifier|*
name|indexP
decl_stmt|;
comment|/* Pointer to index specification with "[]" removed.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Temp char pointer.  */
name|char
name|iprel_flag
decl_stmt|;
comment|/* True if this is an IP-relative operand.  */
name|int
name|regnum
decl_stmt|;
comment|/* Register number.  */
comment|/* Scale factor: 1,2,4,8, or 16.  Later converted to internal format      (0,1,2,3,4 respectively).  */
name|int
name|scale
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* MEMB mode bits.  */
name|int
modifier|*
name|intP
decl_stmt|;
comment|/* Pointer to register number.  */
comment|/* The following table contains the default scale factors for each      type of memory instruction.  It is accessed using (optype-MEM1)      as an index -- thus it assumes the 'optype' constants are      assigned consecutive values, in the order they appear in this      table.  */
specifier|static
specifier|const
name|int
name|def_scale
index|[]
init|=
block|{
literal|1
block|,
comment|/* MEM1 */
literal|2
block|,
comment|/* MEM2 */
literal|4
block|,
comment|/* MEM4 */
literal|8
block|,
comment|/* MEM8 */
operator|-
literal|1
block|,
comment|/* MEM12 -- no valid default */
literal|16
comment|/* MEM16 */
block|}
decl_stmt|;
name|iprel_flag
operator|=
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* Any index present? */
name|indexP
operator|=
name|get_ispec
argument_list|(
name|argP
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexP
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|indexP
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* No explicit scale -- use default for this instruction 	     type and assembler mode.  */
if|if
condition|(
name|flag_mri
condition|)
name|scale
operator|=
literal|1
expr_stmt|;
else|else
comment|/* GNU960 compatibility */
name|scale
operator|=
name|def_scale
index|[
name|optype
operator|-
name|MEM1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Eliminate '*' */
comment|/* Now indexP->a '\0'-terminated register name, 	     and p->a scale factor.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"16"
argument_list|)
condition|)
name|scale
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"1248"
argument_list|,
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|scale
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
name|scale
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|regnum
operator|=
name|get_regnum
argument_list|(
name|indexP
argument_list|)
expr_stmt|;
comment|/* Get index reg. # */
if|if
condition|(
operator|!
name|IS_RG_REG
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid index register"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert scale to its binary encoding.  */
switch|switch
condition|(
name|scale
condition|)
block|{
case|case
literal|1
case|:
name|scale
operator|=
literal|0
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scale
operator|=
literal|1
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|scale
operator|=
literal|2
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|scale
operator|=
literal|3
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|scale
operator|=
literal|4
operator|<<
literal|7
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid scale factor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|memP
operator|->
name|opcode
operator||=
name|scale
operator||
name|regnum
expr_stmt|;
comment|/* Set index bits in opcode.  */
name|mode
operator||=
name|I_BIT
expr_stmt|;
comment|/* Found a valid index spec.  */
block|}
comment|/* Any abase (Register Indirect) specification present?  */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|argP
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* "(" is there -- does it start a legal abase spec?  If not, it          could be part of a displacement expression.  */
name|intP
operator|=
operator|(
name|int
operator|*
operator|)
name|hash_find
argument_list|(
name|areg_hash
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|intP
operator|!=
name|NULL
condition|)
block|{
comment|/* Got an abase here.  */
name|regnum
operator|=
operator|*
name|intP
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Discard register spec.  */
if|if
condition|(
name|regnum
operator|==
name|IPREL
condition|)
comment|/* We have to specialcase ip-rel mode.  */
name|iprel_flag
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|memP
operator|->
name|opcode
operator||=
name|regnum
operator|<<
literal|14
expr_stmt|;
name|mode
operator||=
name|A_BIT
expr_stmt|;
block|}
block|}
block|}
comment|/* Any expression present?  */
name|memP
operator|->
name|e
operator|=
name|argP
expr_stmt|;
if|if
condition|(
operator|*
name|argP
operator|!=
literal|'\0'
condition|)
name|mode
operator||=
name|D_BIT
expr_stmt|;
comment|/* Special-case ip-relative addressing.  */
if|if
condition|(
name|iprel_flag
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|I_BIT
condition|)
name|syntax
argument_list|()
expr_stmt|;
else|else
block|{
name|memP
operator|->
name|opcode
operator||=
literal|5
operator|<<
literal|10
expr_stmt|;
comment|/* IP-relative mode.  */
name|memP
operator|->
name|disp
operator|=
literal|32
expr_stmt|;
block|}
return|return;
block|}
comment|/* Handle all other modes.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|D_BIT
operator||
name|A_BIT
case|:
comment|/* Go with MEMA instruction format for now (grow to MEMB later          if 12 bits is not enough for the displacement).  MEMA format          has a single mode bit: set it to indicate that abase is          present.  */
name|memP
operator|->
name|opcode
operator||=
name|MEMA_ABASE
expr_stmt|;
name|memP
operator|->
name|disp
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|D_BIT
case|:
comment|/* Go with MEMA instruction format for now (grow to MEMB later          if 12 bits is not enough for the displacement).  */
name|memP
operator|->
name|disp
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|A_BIT
case|:
comment|/* For some reason, the bit string for this mode is not          consistent: it should be 0 (exclusive of the MEMB bit), so we          set it "by hand" here.  */
name|memP
operator|->
name|opcode
operator||=
name|MEMB_BIT
expr_stmt|;
break|break;
case|case
name|A_BIT
operator||
name|I_BIT
case|:
comment|/* set MEMB bit in mode, and OR in mode bits.  */
name|memP
operator|->
name|opcode
operator||=
name|mode
operator||
name|MEMB_BIT
expr_stmt|;
break|break;
case|case
name|I_BIT
case|:
comment|/* Treat missing displacement as displacement of 0.  */
name|mode
operator||=
name|D_BIT
expr_stmt|;
comment|/* Fall into next case.  */
case|case
name|D_BIT
operator||
name|A_BIT
operator||
name|I_BIT
case|:
case|case
name|D_BIT
operator||
name|I_BIT
case|:
comment|/* Set MEMB bit in mode, and OR in mode bits.  */
name|memP
operator|->
name|opcode
operator||=
name|mode
operator||
name|MEMB_BIT
expr_stmt|;
name|memP
operator|->
name|disp
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
name|syntax
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Generate a MEMA- or MEMB-format instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mem_fmt
parameter_list|(
name|char
modifier|*
name|args
index|[]
parameter_list|,
comment|/* args[0]->opcode mnemonic, args[1-3]->operands.  */
name|struct
name|i960_opcode
modifier|*
name|oP
parameter_list|,
comment|/* Pointer to description of instruction.  */
name|int
name|callx
parameter_list|)
comment|/* Is this a callx opcode.  */
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter.  */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand.  */
name|char
name|opdesc
decl_stmt|;
comment|/* Operand descriptor byte.  */
name|memS
name|instr
decl_stmt|;
comment|/* Description of binary to be output.  */
name|char
modifier|*
name|outP
decl_stmt|;
comment|/* Where the binary was output to.  */
name|expressionS
name|expr
decl_stmt|;
comment|/* Parsed expression.  */
comment|/* ->description of deferred address fixup.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* COFF support isn't in place yet for callx relaxing.  */
name|callx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|instr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|memS
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|.
name|opcode
operator|=
name|oP
operator|->
name|opcode
expr_stmt|;
comment|/* Process operands.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|oP
operator|->
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|opdesc
operator|=
name|oP
operator|->
name|operand
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|MEMOP
argument_list|(
name|opdesc
argument_list|)
condition|)
name|parse_memop
argument_list|(
operator|&
name|instr
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|oP
operator|->
name|format
argument_list|)
expr_stmt|;
else|else
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|opdesc
argument_list|)
expr_stmt|;
name|instr
operator|.
name|opcode
operator||=
name|regop
operator|.
name|n
operator|<<
literal|19
expr_stmt|;
block|}
block|}
comment|/* Parse the displacement; this must be done before emitting the      opcode, in case it is an expression using `.'.  */
name|parse_expr
argument_list|(
name|instr
operator|.
name|e
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
comment|/* Output opcode.  */
name|outP
operator|=
name|emit
argument_list|(
name|instr
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|0
condition|)
return|return;
comment|/* Process the displacement.  */
switch|switch
condition|(
name|expr
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression syntax error"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|32
condition|)
operator|(
name|void
operator|)
name|emit
argument_list|(
name|offs
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output displacement.  */
else|else
block|{
comment|/* 12-bit displacement.  */
if|if
condition|(
name|offs
argument_list|(
name|expr
argument_list|)
operator|&
operator|~
literal|0xfff
condition|)
block|{
comment|/* Won't fit in 12 bits: convert already-output 	         instruction to MEMB format, output 	         displacement.  */
name|mema_to_memb
argument_list|(
name|outP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emit
argument_list|(
name|offs
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* WILL fit in 12 bits:  OR into opcode and 	         overwrite the binary we already put out.  */
name|instr
operator|.
name|opcode
operator||=
name|offs
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|outP
argument_list|,
name|instr
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|12
condition|)
comment|/* Displacement is dependent on a symbol, whose value 	   may change at link time.  We HAVE to reserve 32 bits. 	   Convert already-output opcode to MEMB format.  */
name|mema_to_memb
argument_list|(
name|outP
argument_list|)
expr_stmt|;
comment|/* Output 0 displacement and set up address fixup for when          this symbol's value becomes known.  */
name|outP
operator|=
name|emit
argument_list|(
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|outP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|expr
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Steve's linker relaxing hack.  Mark this 32-bit relocation as          being in the instruction stream, specifically as part of a callx          instruction.  */
name|fixP
operator|->
name|fx_bsr
operator|=
name|callx
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* targ_has_iclass:     Return TRUE iff the target architecture supports the indicated    class of instructions.  */
end_comment

begin_function
specifier|static
name|int
name|targ_has_iclass
parameter_list|(
name|int
name|ic
parameter_list|)
comment|/* Instruction class;  one of: 			    I_BASE, I_CX, I_DEC, I_KX, I_FP, I_MIL, I_CASIM, I_CX2, I_HX, I_HX2.  */
block|{
name|iclasses_seen
operator||=
name|ic
expr_stmt|;
switch|switch
condition|(
name|architecture
condition|)
block|{
case|case
name|ARCH_KA
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator|)
return|;
case|case
name|ARCH_KB
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator|)
return|;
case|case
name|ARCH_MC
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator||
name|I_MIL
operator|)
return|;
case|case
name|ARCH_CA
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_CX
operator||
name|I_CX2
operator||
name|I_CASIM
operator|)
return|;
case|case
name|ARCH_JX
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_CX2
operator||
name|I_JX
operator|)
return|;
case|case
name|ARCH_HX
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_CX2
operator||
name|I_JX
operator||
name|I_HX
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|iclasses_seen
operator|&
operator|(
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator||
name|I_MIL
operator|)
operator|)
operator|&&
operator|(
name|iclasses_seen
operator|&
operator|(
name|I_CX
operator||
name|I_CX2
operator|)
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"architecture of opcode conflicts with that of earlier instruction(s)"
argument_list|)
argument_list|)
expr_stmt|;
name|iclasses_seen
operator|&=
operator|~
name|ic
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* shift_ok:    Determine if a "shlo" instruction can be used to implement a "ldconst".    This means that some number X< 32 can be shifted left to produce the    constant of interest.     Return the shift count, or 0 if we can't do it.    Caller calculates X by shifting original constant right 'shift' places.  */
end_comment

begin_function
specifier|static
name|int
name|shift_ok
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* The constant of interest.  */
block|{
name|int
name|shift
decl_stmt|;
comment|/* The shift count.  */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
comment|/* Can't do it for negative numbers.  */
return|return
literal|0
return|;
comment|/* Shift 'n' right until a 1 is about to be lost.  */
for|for
control|(
name|shift
operator|=
literal|0
init|;
operator|(
name|n
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|shift
operator|++
control|)
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|32
condition|)
return|return
literal|0
return|;
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/* parse_ldcont:    Parse and replace a 'ldconst' pseudo-instruction with an appropriate    i80960 instruction.     Assumes the input consists of:   		arg[0]	opcode mnemonic ('ldconst')   		arg[1]  first operand (constant)   		arg[2]	name of register to be loaded     Replaces opcode and/or operands as appropriate.     Returns the new number of arguments, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|parse_ldconst
parameter_list|(
name|char
modifier|*
name|arg
index|[]
parameter_list|)
comment|/* See above.  */
block|{
name|int
name|n
decl_stmt|;
comment|/* Constant to be loaded.  */
name|int
name|shift
decl_stmt|;
comment|/* Shift count for "shlo" instruction.  */
specifier|static
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* Literal for first operand.  */
specifier|static
name|char
name|buf2
index|[
literal|5
index|]
decl_stmt|;
comment|/* Literal for second operand.  */
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression.  */
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* So we can tell at the end if it got used or not.  */
name|parse_expr
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|.
name|X_op
condition|)
block|{
default|default:
comment|/* We're dependent on one or more symbols -- use "lda".  */
name|arg
index|[
literal|0
index|]
operator|=
literal|"lda"
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
comment|/* Try the following mappings:               ldconst   0,<reg>  -> mov  0,<reg>               ldconst  31,<reg>  -> mov  31,<reg>               ldconst  32,<reg>  -> addo 1,31,<reg>               ldconst  62,<reg>  -> addo 31,31,<reg>               ldconst  64,<reg>  -> shlo 8,3,<reg>               ldconst  -1,<reg>  -> subo 1,0,<reg>               ldconst -31,<reg>  -> subo 31,0,<reg>                   Anything else becomes:                 lda xxx,<reg>.  */
name|n
operator|=
name|offs
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|31
operator|)
condition|)
name|arg
index|[
literal|0
index|]
operator|=
literal|"mov"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|-
literal|31
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
operator|-
literal|1
operator|)
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"subo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
literal|32
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|62
operator|)
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"addo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
literal|"31"
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|-
literal|31
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|shift
operator|=
name|shift_ok
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"shlo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|>>
name|shift
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|buf2
expr_stmt|;
block|}
else|else
name|arg
index|[
literal|0
index|]
operator|=
literal|"lda"
expr_stmt|;
break|break;
case|case
name|O_illegal
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
return|return
operator|(
name|arg
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
literal|3
return|;
block|}
end_function

begin_comment
comment|/* reg_fmt:	generate a REG-format instruction.  */
end_comment

begin_function
specifier|static
name|void
name|reg_fmt
parameter_list|(
name|char
modifier|*
name|args
index|[]
parameter_list|,
comment|/* args[0]->opcode mnemonic, args[1-3]->operands.  */
name|struct
name|i960_opcode
modifier|*
name|oP
parameter_list|)
comment|/* Pointer to description of instruction.  */
block|{
name|long
name|instr
decl_stmt|;
comment|/* Binary to be output.  */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand.  */
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands.  */
name|instr
operator|=
name|oP
operator|->
name|opcode
expr_stmt|;
name|n_ops
operator|=
name|oP
operator|->
name|num_ops
expr_stmt|;
if|if
condition|(
name|n_ops
operator|>=
literal|1
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|instr
operator|&
name|M3
operator|)
condition|)
block|{
comment|/* 1-operand instruction in which the dst field should 	     be used (instead of src1).  */
name|regop
operator|.
name|n
operator|<<=
literal|19
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
name|regop
operator|.
name|mode
operator|<<=
literal|13
expr_stmt|;
name|regop
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regop.n goes in bit 0, needs no shifting.  */
name|regop
operator|.
name|mode
operator|<<=
literal|11
expr_stmt|;
name|regop
operator|.
name|special
operator|<<=
literal|5
expr_stmt|;
block|}
name|instr
operator||=
name|regop
operator|.
name|n
operator||
name|regop
operator|.
name|mode
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n_ops
operator|>=
literal|2
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|2
operator|)
operator|&&
operator|!
operator|(
name|instr
operator|&
name|M3
operator|)
condition|)
block|{
comment|/* 2-operand instruction in which the dst field should 	     be used instead of src2).  */
name|regop
operator|.
name|n
operator|<<=
literal|19
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
name|regop
operator|.
name|mode
operator|<<=
literal|13
expr_stmt|;
name|regop
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|regop
operator|.
name|n
operator|<<=
literal|14
expr_stmt|;
name|regop
operator|.
name|mode
operator|<<=
literal|12
expr_stmt|;
name|regop
operator|.
name|special
operator|<<=
literal|6
expr_stmt|;
block|}
name|instr
operator||=
name|regop
operator|.
name|n
operator||
name|regop
operator|.
name|mode
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n_ops
operator|==
literal|3
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<=
literal|19
operator|)
operator||
operator|(
name|regop
operator|.
name|mode
operator|<<=
literal|13
operator|)
expr_stmt|;
block|}
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_args:	break individual arguments out of comma-separated list     Input assumptions:   	- all comments and labels have been removed   	- all strings of whitespace have been collapsed to a single blank.   	- all character constants ('x') have been replaced with decimal     Output:   	args[0] is untouched. args[1] points to first operand, etc. All args:   	- are NULL-terminated   	- contain no whitespace     Return value:    Number of operands (0,1,2, or 3) or -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|get_args
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
comment|/* Pointer to comma-separated operands; Mucked by us.  */
name|char
modifier|*
name|args
index|[]
parameter_list|)
comment|/* Output arg: pointers to operands placed in args[1-3]. 			   Must accommodate 4 entries (args[0-3]).  */
block|{
name|int
name|n
decl_stmt|;
comment|/* Number of operands.  */
name|char
modifier|*
name|to
decl_stmt|;
comment|/* Skip lead white space.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
comment|/* Squeze blanks out by moving non-blanks toward start of string.      Isolate operands, whenever comma is found.  */
name|to
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
operator|(
operator|!
name|ISALNUM
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISALNUM
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
comment|/* Start of operand.  */
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|to
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate argument.  */
name|args
index|[
operator|++
name|n
index|]
operator|=
name|to
expr_stmt|;
comment|/* Start next argument.  */
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* i_scan:	perform lexical scan of ascii assembler instruction.     Input assumptions:   	- input string is an i80960 instruction (not a pseudo-op)   	- all comments and labels have been removed   	- all strings of whitespace have been collapsed to a single blank.     Output:   	args[0] points to opcode, other entries point to operands. All strings:   	- are NULL-terminated   	- contain no whitespace   	- have character constants ('x') replaced with a decimal number     Return value:      Number of operands (0,1,2, or 3) or -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|i_scan
parameter_list|(
name|char
modifier|*
name|iP
parameter_list|,
comment|/* Pointer to ascii instruction;  Mucked by us.  */
name|char
modifier|*
name|args
index|[]
parameter_list|)
comment|/* Output arg: pointers to opcode and operands placed here. 			 Must accommodate 4 entries.  */
block|{
comment|/* Isolate opcode.  */
if|if
condition|(
operator|*
operator|(
name|iP
operator|)
operator|==
literal|' '
condition|)
name|iP
operator|++
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|iP
expr_stmt|;
for|for
control|(
init|;
operator|*
name|iP
operator|!=
literal|' '
condition|;
name|iP
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|iP
operator|==
literal|'\0'
condition|)
block|{
comment|/* There are no operands.  */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
name|iP
condition|)
block|{
comment|/* We never moved: there was no opcode either!  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
operator|*
name|iP
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|get_args
argument_list|(
name|iP
argument_list|,
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|brcnt_emit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Emit call to "increment" routine.  */
name|ctrl_fmt
argument_list|(
name|BR_CNT_FUNC
argument_list|,
name|CALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit inline counter to be incremented.  */
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|brlab_next
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BR_LABEL_BASE
argument_list|,
name|br_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctrl_fmt
parameter_list|(
name|char
modifier|*
name|targP
parameter_list|,
comment|/* Pointer to text of lone operand (if any).  */
name|long
name|opcode
parameter_list|,
comment|/* Template of instruction.  */
name|int
name|num_ops
parameter_list|)
comment|/* Number of operands.  */
block|{
name|int
name|instrument
decl_stmt|;
comment|/* TRUE iff we should add instrumentation to track 				   how often the branch is taken.  */
if|if
condition|(
name|num_ops
operator|==
literal|0
condition|)
name|emit
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* Output opcode.  */
else|else
block|{
name|instrument
operator|=
name|instrument_branches
operator|&&
operator|(
name|opcode
operator|!=
name|CALL
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|B
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|RET
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|BAL
operator|)
expr_stmt|;
if|if
condition|(
name|instrument
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
name|colon
argument_list|(
name|brlab_next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* The operand MUST be an ip-relative displacement. Parse it          and set up address fix for the instruction we just output.  */
name|get_cdisp
argument_list|(
name|targP
argument_list|,
literal|"CTRL"
argument_list|,
name|opcode
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instrument
condition|)
name|brcnt_emit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cobr_fmt
parameter_list|(
comment|/* arg[0]->opcode mnemonic, arg[1-3]->operands (ascii) */
name|char
modifier|*
name|arg
index|[]
parameter_list|,
comment|/* Opcode, with branch-prediction bits already set if necessary.  */
name|long
name|opcode
parameter_list|,
comment|/* Pointer to description of instruction.  */
name|struct
name|i960_opcode
modifier|*
name|oP
parameter_list|)
block|{
name|long
name|instr
decl_stmt|;
comment|/* 32-bit instruction.  */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand.  */
name|int
name|n
decl_stmt|;
comment|/* Number of operands.  */
name|int
name|var_frag
decl_stmt|;
comment|/* 1 if varying length code fragment should 				     be emitted;  0 if an address fix 				        should be emitted.  */
name|instr
operator|=
name|opcode
expr_stmt|;
name|n
operator|=
name|oP
operator|->
name|num_ops
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1
condition|)
block|{
comment|/* First operand (if any) of a COBR is always a register 	 operand.  Parse it.  */
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<
literal|19
operator|)
operator||
operator|(
name|regop
operator|.
name|mode
operator|<<
literal|13
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
block|{
comment|/* Second operand (if any) of a COBR is always a register 	 operand.  Parse it.  */
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<
literal|14
operator|)
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|3
condition|)
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|instrument_branches
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
name|colon
argument_list|(
name|brlab_next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* A third operand to a COBR is always a displacement.  Parse          it; if it's relaxable (a cobr "j" directive, or any cobr          other than bbs/bbc when the "-norelax" option is not in use)          set up a variable code fragment; otherwise set up an address          fix.  */
name|var_frag
operator|=
operator|!
name|norelax
operator|||
operator|(
name|oP
operator|->
name|format
operator|==
name|COJ
operator|)
expr_stmt|;
comment|/* TRUE or FALSE */
name|get_cdisp
argument_list|(
name|arg
index|[
literal|3
index|]
argument_list|,
literal|"COBR"
argument_list|,
name|instr
argument_list|,
literal|13
argument_list|,
name|var_frag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instrument_branches
condition|)
name|brcnt_emit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assumptions about the passed-in text:   	- all comments, labels removed   	- text is an instruction   	- all white space compressed to single blanks   	- all character constants have been replaced with decimal.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|textP
parameter_list|)
block|{
comment|/* Parsed instruction text, containing NO whitespace: arg[0]->opcode      mnemonic arg[1-3]->operands, with char constants replaced by      decimal numbers.  */
name|char
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
comment|/* Number of instruction operands.  */
name|int
name|n_ops
decl_stmt|;
comment|/* Pointer to instruction description.  */
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* TRUE iff opcode mnemonic included branch-prediction suffix (".f"      or ".t").  */
name|int
name|branch_predict
decl_stmt|;
comment|/* Setting of branch-prediction bit(s) to be OR'd into instruction      opcode of CTRL/COBR format instructions.  */
name|long
name|bp_bits
decl_stmt|;
comment|/* Offset of last character in opcode mnemonic.  */
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|bp_error_msg
init|=
name|_
argument_list|(
literal|"branch prediction invalid on this opcode"
argument_list|)
decl_stmt|;
comment|/* Parse instruction into opcode and operands.  */
name|memset
argument_list|(
name|args
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|n_ops
operator|=
name|i_scan
argument_list|(
name|textP
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Error message already issued.  */
comment|/* Do "macro substitution" (sort of) on 'ldconst' pseudo-instruction.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"ldconst"
argument_list|)
condition|)
block|{
name|n_ops
operator|=
name|parse_ldconst
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
comment|/* Check for branch-prediction suffix on opcode mnemonic, strip it off.  */
name|n
operator|=
name|strlen
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|branch_predict
operator|=
literal|0
expr_stmt|;
name|bp_bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'t'
operator|||
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
comment|/* We could check here to see if the target architecture 	 supports branch prediction, but why bother?  The bit will 	 just be ignored by processors that don't use it.  */
name|branch_predict
operator|=
literal|1
expr_stmt|;
name|bp_bits
operator|=
operator|(
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'t'
operator|)
condition|?
name|BP_TAKEN
else|:
name|BP_NOT_TAKEN
expr_stmt|;
name|args
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip suffix from opcode mnemonic */
block|}
comment|/* Look up opcode mnemonic in table and check number of operands.      Check that opcode is legal for the target architecture.  If all      looks good, assemble instruction.  */
name|oP
operator|=
operator|(
expr|struct
name|i960_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oP
operator|||
operator|!
name|targ_has_iclass
argument_list|(
name|oP
operator|->
name|iclass
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid opcode, \"%s\"."
argument_list|)
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_ops
operator|!=
name|oP
operator|->
name|num_ops
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"improper number of operands.  expecting %d, got %d"
argument_list|)
argument_list|,
name|oP
operator|->
name|num_ops
argument_list|,
name|n_ops
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|oP
operator|->
name|format
condition|)
block|{
case|case
name|FBRA
case|:
case|case
name|CTRL
case|:
name|ctrl_fmt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|opcode
operator||
name|bp_bits
argument_list|,
name|oP
operator|->
name|num_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|oP
operator|->
name|format
operator|==
name|FBRA
condition|)
comment|/* Now generate a 'bno' to same arg */
name|ctrl_fmt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|BNO
operator||
name|bp_bits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COBR
case|:
case|case
name|COJ
case|:
name|cobr_fmt
argument_list|(
name|args
argument_list|,
name|oP
operator|->
name|opcode
operator||
name|bp_bits
argument_list|,
name|oP
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|branch_predict
condition|)
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
name|reg_fmt
argument_list|(
name|args
argument_list|,
name|oP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM1
case|:
if|if
condition|(
name|args
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|args
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|branch_predict
condition|)
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
name|mem_fmt
argument_list|(
name|args
argument_list|,
name|oP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MEM2
case|:
case|case
name|MEM4
case|:
case|case
name|MEM8
case|:
case|case
name|MEM12
case|:
case|case
name|MEM16
case|:
if|if
condition|(
name|branch_predict
condition|)
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
name|mem_fmt
argument_list|(
name|args
argument_list|,
name|oP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLJ
case|:
if|if
condition|(
name|branch_predict
condition|)
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
comment|/* Output opcode& set up "fixup" (relocation); flag 	     relocation as 'callj' type.  */
name|know
argument_list|(
name|oP
operator|->
name|num_ops
operator|==
literal|1
argument_list|)
expr_stmt|;
name|get_cdisp
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|"CTRL"
argument_list|,
name|oP
operator|->
name|opcode
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|oP
operator|->
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|value
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_define
define|#
directive|define
name|LNUM_SIZE
value|sizeof (LITTLENUM_TYPE)
end_define

begin_comment
comment|/* md_atof:	convert ascii to floating point     Turn a string at input_line_pointer into a floating point constant of type    'type', and store the appropriate bytes at *litP.  The number of LITTLENUMS    emitted is returned at 'sizeP'.  An error message is returned, or a pointer    to an empty message if OK.     Note we call the i386 floating point routine, rather than complicating    things with more files or symbolic links.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
name|type
operator|=
literal|'x'
expr_stmt|;
comment|/* That's what atof_ieee() understands.  */
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
name|LNUM_SIZE
expr_stmt|;
comment|/* Output the LITTLENUMs in REVERSE order in accord with i80960      word-order.  (Dunno why atof_ieee doesn't do it in the right      order in the first place -- probably because it's a hack of      atof_m68k.)  */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
name|LNUM_SIZE
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|md_number_to_imm
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|md_number_to_field
parameter_list|(
name|char
modifier|*
name|instrP
parameter_list|,
comment|/* Pointer to instruction to be fixed.  */
name|long
name|val
parameter_list|,
comment|/* Address fixup value.  */
name|bit_fixS
modifier|*
name|bfixP
parameter_list|)
comment|/* Description of bit field to be fixed up.  */
block|{
name|int
name|numbits
decl_stmt|;
comment|/* Length of bit field to be fixed.  */
name|long
name|instr
decl_stmt|;
comment|/* 32-bit instruction to be fixed-up.  */
name|long
name|sign
decl_stmt|;
comment|/* 0 or -1, according to sign bit of 'val'.  */
comment|/* Convert instruction back to host byte order.  */
name|instr
operator|=
name|md_chars_to_number
argument_list|(
name|instrP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Surprise! -- we stored the number of bits to be modified rather      than a pointer to a structure.  */
name|numbits
operator|=
operator|(
name|int
operator|)
operator|(
name|size_t
operator|)
name|bfixP
expr_stmt|;
if|if
condition|(
name|numbits
operator|==
literal|1
condition|)
comment|/* This is a no-op, stuck here by reloc_callj().  */
return|return;
name|know
argument_list|(
operator|(
name|numbits
operator|==
literal|13
operator|)
operator|||
operator|(
name|numbits
operator|==
literal|24
operator|)
argument_list|)
expr_stmt|;
comment|/* Propagate sign bit of 'val' for the given number of bits.  Result      should be all 0 or all 1.  */
name|sign
operator|=
name|val
operator|>>
operator|(
operator|(
name|int
operator|)
name|numbits
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
name|sign
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|val
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sign
operator|!=
literal|0
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Fixup of %ld too large for field width of %d"
argument_list|)
argument_list|,
name|val
argument_list|,
name|numbits
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Put bit field into instruction and write back in target          * byte order.  */
name|val
operator|&=
operator|~
operator|(
operator|-
literal|1
operator|<<
operator|(
name|int
operator|)
name|numbits
operator|)
expr_stmt|;
comment|/* Clear unused sign bits.  */
name|instr
operator||=
name|val
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|instrP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_parse_option   	Invocation line includes a switch not recognized by the base assembler.   	See if it's a processor-specific option.  For the 960, these are:    	-norelax:   		Conditional branch instructions that require displacements   		greater than 13 bits (or that have external targets) should   		generate errors.  The default is to replace each such   		instruction with the corresponding compare (or chkbit) and   		branch instructions.  Note that the Intel "j" cobr directives   		are ALWAYS "de-optimized" in this way when necessary,   		regardless of the setting of this option.    	-b:   		Add code to collect information about branches taken, for   		later optimization of branch prediction bits by a separate   		tool.  COBR and CNTL format instructions have branch   		prediction bits (in the CX architecture);  if "BR" represents   		an instruction in one of these classes, the following rep-   		resents the code generated by the assembler:    			call<increment routine>   			.word	0	# pre-counter   		Label:  BR   			call<increment routine>   			.word	0	# post-counter    		A table of all such "Labels" is also generated.    	-AKA, -AKB, -AKC, -ASA, -ASB, -AMC, -ACA:   		Select the 80960 architecture.  Instructions or features not   		supported by the selected architecture cause fatal errors.   		The default is to generate code for any instruction or feature   		that is supported by SOME version of the 960 (even if this   		means mixing architectures!).  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"A:b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_LINKRELAX
value|(OPTION_MD_BASE)
block|{
literal|"linkrelax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LINKRELAX
block|}
block|,
block|{
literal|"link-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LINKRELAX
block|}
block|,
define|#
directive|define
name|OPTION_NORELAX
value|(OPTION_MD_BASE + 1)
block|{
literal|"norelax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NORELAX
block|}
block|,
block|{
literal|"no-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NORELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tabentry
block|{
name|char
modifier|*
name|flag
decl_stmt|;
name|int
name|arch
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tabentry
name|arch_tab
index|[]
init|=
block|{
block|{
literal|"KA"
block|,
name|ARCH_KA
block|}
block|,
block|{
literal|"KB"
block|,
name|ARCH_KB
block|}
block|,
block|{
literal|"SA"
block|,
name|ARCH_KA
block|}
block|,
comment|/* Synonym for KA.  */
block|{
literal|"SB"
block|,
name|ARCH_KB
block|}
block|,
comment|/* Synonym for KB.  */
block|{
literal|"KC"
block|,
name|ARCH_MC
block|}
block|,
comment|/* Synonym for MC.  */
block|{
literal|"MC"
block|,
name|ARCH_MC
block|}
block|,
block|{
literal|"CA"
block|,
name|ARCH_CA
block|}
block|,
block|{
literal|"JX"
block|,
name|ARCH_JX
block|}
block|,
block|{
literal|"HX"
block|,
name|ARCH_HX
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_LINKRELAX
case|:
name|linkrelax
operator|=
literal|1
expr_stmt|;
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NORELAX
case|:
name|norelax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|instrument_branches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
block|{
specifier|const
name|struct
name|tabentry
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|arch_tab
init|;
name|tp
operator|->
name|flag
operator|!=
name|NULL
condition|;
name|tp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|tp
operator|->
name|flag
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tp
operator|->
name|flag
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architecture %s"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|architecture
operator|=
name|tp
operator|->
name|arch
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"I960 options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arch_tab
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s-A%s"
argument_list|,
name|i
condition|?
literal|" | "
else|:
literal|""
argument_list|,
name|arch_tab
index|[
name|i
index|]
operator|.
name|flag
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\ 			specify variant of 960 architecture\n\ -b			add code to collect statistics about branches taken\n\ -link-relax		preserve individual alignment directives so linker\n\ 			can do relaxing (b.out format only)\n\ -no-relax		don't alter compare-and-branch instructions for\n\ 			long displacements\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* relax_cobr:    Replace cobr instruction in a code fragment with equivalent branch and    compare instructions, so it can reach beyond a 13-bit displacement.    Set up an address fix/relocation for the new branch instruction.  */
end_comment

begin_comment
comment|/* This "conditional jump" table maps cobr instructions into    equivalent compare and branch opcodes.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|long
name|compare
decl_stmt|;
name|long
name|branch
decl_stmt|;
block|}
name|coj
index|[]
init|=
block|{
comment|/* COBR OPCODE: */
block|{
name|CHKBIT
block|,
name|BNO
block|}
block|,
comment|/*      0x30 - bbc */
block|{
name|CMPO
block|,
name|BG
block|}
block|,
comment|/*      0x31 - cmpobg */
block|{
name|CMPO
block|,
name|BE
block|}
block|,
comment|/*      0x32 - cmpobe */
block|{
name|CMPO
block|,
name|BGE
block|}
block|,
comment|/*      0x33 - cmpobge */
block|{
name|CMPO
block|,
name|BL
block|}
block|,
comment|/*      0x34 - cmpobl */
block|{
name|CMPO
block|,
name|BNE
block|}
block|,
comment|/*      0x35 - cmpobne */
block|{
name|CMPO
block|,
name|BLE
block|}
block|,
comment|/*      0x36 - cmpoble */
block|{
name|CHKBIT
block|,
name|BO
block|}
block|,
comment|/*      0x37 - bbs */
block|{
name|CMPI
block|,
name|BNO
block|}
block|,
comment|/*      0x38 - cmpibno */
block|{
name|CMPI
block|,
name|BG
block|}
block|,
comment|/*      0x39 - cmpibg */
block|{
name|CMPI
block|,
name|BE
block|}
block|,
comment|/*      0x3a - cmpibe */
block|{
name|CMPI
block|,
name|BGE
block|}
block|,
comment|/*      0x3b - cmpibge */
block|{
name|CMPI
block|,
name|BL
block|}
block|,
comment|/*      0x3c - cmpibl */
block|{
name|CMPI
block|,
name|BNE
block|}
block|,
comment|/*      0x3d - cmpibne */
block|{
name|CMPI
block|,
name|BLE
block|}
block|,
comment|/*      0x3e - cmpible */
block|{
name|CMPI
block|,
name|BO
block|}
block|,
comment|/*      0x3f - cmpibo */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|relax_cobr
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
comment|/* fragP->fr_opcode is assumed to point to 				   the cobr instruction, which comes at the 				   end of the code fragment.  */
block|{
name|int
name|opcode
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|m1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* Bit fields from cobr instruction.  */
name|long
name|bp_bits
decl_stmt|;
comment|/* Branch prediction bits from cobr instruction.  */
name|long
name|instr
decl_stmt|;
comment|/* A single i960 instruction.  */
comment|/* ->instruction to be replaced.  */
name|char
modifier|*
name|iP
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Relocation that can be done at assembly time.  */
comment|/* Pick up& parse cobr instruction.  */
name|iP
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|instr
operator|=
name|md_chars_to_number
argument_list|(
name|iP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|(
operator|(
name|instr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
comment|/* "-0x30" for table index.  */
name|src1
operator|=
operator|(
name|instr
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|m1
operator|=
operator|(
name|instr
operator|>>
literal|13
operator|)
operator|&
literal|1
expr_stmt|;
name|s2
operator|=
name|instr
operator|&
literal|1
expr_stmt|;
name|src2
operator|=
operator|(
name|instr
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bp_bits
operator|=
name|instr
operator|&
name|BP_MASK
expr_stmt|;
comment|/* Generate and output compare instruction.  */
name|instr
operator|=
name|coj
index|[
name|opcode
index|]
operator|.
name|compare
operator||
name|src1
operator||
operator|(
name|m1
operator|<<
literal|11
operator|)
operator||
operator|(
name|s2
operator|<<
literal|6
operator|)
operator||
operator|(
name|src2
operator|<<
literal|14
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|iP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Output branch instruction.  */
name|md_number_to_chars
argument_list|(
name|iP
operator|+
literal|4
argument_list|,
name|coj
index|[
name|opcode
index|]
operator|.
name|branch
operator||
name|bp_bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set up address fixup/relocation.  */
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|iP
operator|+
literal|4
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|24
expr_stmt|;
comment|/* Store size of bit field.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_convert_frag:     Called by base assembler after address relaxation is finished:  modify    variable fragments according to how much relaxation was done.     If the fragment substate is still 1, a 13-bit displacement was enough    to reach the symbol in question.  Set up an address fixup, but otherwise    leave the cobr instruction alone.     If the fragment substate is 2, a 13-bit displacement was not enough.    Replace the cobr with a two instructions (a compare and a branch).  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* Structure describing needed address fix.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
literal|1
case|:
comment|/* Leave single cobr instruction.  */
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|13
expr_stmt|;
comment|/* Size of bit field.  */
break|break;
case|case
literal|2
case|:
comment|/* Replace cobr with compare/branch instructions.  */
name|relax_cobr
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax:  How much does it look like *fragP will grow?     Called by base assembler just before address relaxation.    Return the amount by which the fragment will grow.     Any symbol that is now undefined will not become defined; cobr's    based on undefined symbols will have to be replaced with a compare    instruction and a branch instruction, and the code fragment will grow    by 4 bytes.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment_type
parameter_list|)
block|{
comment|/* If symbol is undefined in this segment, go to "relaxed" state      (compare and branch instructions instead of cobr) right now.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment_type
condition|)
block|{
name|relax_cobr
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_comment
comment|/* md_ri_to_chars:    This routine exists in order to overcome machine byte-order problems    when dealing with bit-field entries in the relocation_info struct.     But relocation info will be used on the host machine only (only    executable code is actually downloaded to the i80960).  Therefore,    we leave it in host byte order.  */
end_comment

begin_function
specifier|static
name|void
name|md_ri_to_chars
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|relocation_info
modifier|*
name|ri
parameter_list|)
block|{
name|host_number_to_chars
argument_list|(
name|where
argument_list|,
name|ri
operator|->
name|r_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|host_number_to_chars
argument_list|(
name|where
operator|+
literal|4
argument_list|,
name|ri
operator|->
name|r_index
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIGENDIAN
name|where
index|[
literal|7
index|]
operator|=
operator|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|7
operator||
name|ri
operator|->
name|r_length
operator|<<
literal|5
operator||
name|ri
operator|->
name|r_extern
operator|<<
literal|4
operator||
name|ri
operator|->
name|r_bsr
operator|<<
literal|3
operator||
name|ri
operator|->
name|r_disp
operator|<<
literal|2
operator||
name|ri
operator|->
name|r_callj
operator|<<
literal|1
operator||
name|ri
operator|->
name|nuthin
operator|<<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|where
index|[
literal|7
index|]
operator|=
operator|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|0
operator||
name|ri
operator|->
name|r_length
operator|<<
literal|1
operator||
name|ri
operator|->
name|r_extern
operator|<<
literal|3
operator||
name|ri
operator|->
name|r_bsr
operator|<<
literal|4
operator||
name|ri
operator|->
name|r_disp
operator|<<
literal|5
operator||
name|ri
operator|->
name|r_callj
operator|<<
literal|6
operator||
name|ri
operator|->
name|nuthin
operator|<<
literal|7
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OBJ_AOUT) | defined(OBJ_BOUT) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* brtab_emit:	generate the fetch-prediction branch table.     See the comments above the declaration of 'br_cnt' for details on    branch-prediction instrumentation.     The code emitted here would be functionally equivalent to the following    example assembler source.    			.data   			.align	2   	   BR_TAB_NAME:   			.word	0		# link to next table   			.word	3		# length of table   			.word	LBRANCH0	# 1st entry in table proper   			.word	LBRANCH1   			.word	LBRANCH2  */
end_comment

begin_function
name|void
name|brtab_emit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* Where the binary was output to.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to description of deferred address fixup.  */
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|instrument_branches
condition|)
return|return;
name|subseg_set
argument_list|(
name|data_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      .data */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      .align 2 */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|BR_TAB_NAME
argument_list|)
expr_stmt|;
comment|/* BR_TAB_NAME: */
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*      .word 0 #link to next table */
name|emit
argument_list|(
name|br_cnt
argument_list|)
expr_stmt|;
comment|/*      .word n #length of table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|br_cnt
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BR_LABEL_BASE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|symbol_find
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* s_leafproc:	process .leafproc pseudo-op    	.leafproc takes two arguments, the second one is optional:   		arg[1]: name of 'call' entry point to leaf procedure   		arg[2]: name of 'bal' entry point to leaf procedure    	If the two arguments are identical, or if the second one is missing,   	the first argument is taken to be the 'bal' entry point.    	If there are 2 distinct arguments, we must make sure that the 'bal'   	entry point immediately follows the 'call' entry point in the linked   	list of symbols.  */
end_comment

begin_function
specifier|static
name|void
name|s_leafproc
parameter_list|(
name|int
name|n_ops
parameter_list|,
comment|/* Number of operands.  */
name|char
modifier|*
name|args
index|[]
parameter_list|)
comment|/* args[1]->1st operand, args[2]->2nd operand.  */
block|{
name|symbolS
modifier|*
name|callP
decl_stmt|;
comment|/* Pointer to leafproc 'call' entry point symbol.  */
name|symbolS
modifier|*
name|balP
decl_stmt|;
comment|/* Pointer to leafproc 'bal' entry point symbol.  */
if|if
condition|(
operator|(
name|n_ops
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|n_ops
operator|!=
literal|2
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"should have 1 or 2 operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find or create symbol for 'call' entry point.  */
name|callP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Redefining leafproc %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that was the only argument, use it as the 'bal' entry point.      Otherwise, mark it as the 'call' entry point and find or create      another symbol for the 'bal' entry point.  */
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|1
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|TC_S_FORCE_TO_BALNAME
argument_list|(
name|callP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TC_S_FORCE_TO_CALLNAME
argument_list|(
name|callP
argument_list|)
expr_stmt|;
name|balP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|balP
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Redefining leafproc %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|balP
argument_list|)
argument_list|)
expr_stmt|;
name|TC_S_FORCE_TO_BALNAME
argument_list|(
name|balP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
name|tc_set_bal_of_call
argument_list|(
name|callP
argument_list|,
name|balP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* s_sysproc: process .sysproc pseudo-op     .sysproc takes two arguments:      arg[1]: name of entry point to system procedure      arg[2]: 'entry_num' (index) of system procedure in the range      [0,31] inclusive.     For [ab].out, we store the 'entrynum' in the 'n_other' field of    the symbol.  Since that entry is normally 0, we bias 'entrynum'    by adding 1 to it.  It must be unbiased before it is used.  */
end_comment

begin_function
specifier|static
name|void
name|s_sysproc
parameter_list|(
name|int
name|n_ops
parameter_list|,
comment|/* Number of operands.  */
name|char
modifier|*
name|args
index|[]
parameter_list|)
comment|/* args[1]->1st operand, args[2]->2nd operand.  */
block|{
name|expressionS
name|exp
decl_stmt|;
name|symbolS
modifier|*
name|symP
decl_stmt|;
if|if
condition|(
name|n_ops
operator|!=
literal|2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"should have two operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse "entry_num" argument and check it for validity.  */
name|parse_expr
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|31
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'entry_num' must be absolute number in [0,31]"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find/make symbol and stick entry number (biased by +1) into it.  */
name|symP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_SYSPROC
argument_list|(
name|symP
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Redefining entrynum for sysproc %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symP
argument_list|)
argument_list|)
expr_stmt|;
name|TC_S_SET_SYSPROC
argument_list|(
name|symP
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode entry number.  */
name|TC_S_FORCE_TO_SYSPROC
argument_list|(
name|symP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse_po:	parse machine-dependent pseudo-op     This is a top-level routine for machine-dependent pseudo-ops.  It slurps    up the rest of the input line, breaks out the individual arguments,    and dispatches them to the correct handler.  */
end_comment

begin_function
specifier|static
name|void
name|parse_po
parameter_list|(
name|int
name|po_num
parameter_list|)
comment|/* Pseudo-op number:  currently S_LEAFPROC or S_SYSPROC.  */
block|{
comment|/* Pointers operands, with no embedded whitespace.      arg[0] unused, arg[1-3]->operands.  */
name|char
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to beginning of unparsed argument string.  */
name|char
name|eol
decl_stmt|;
comment|/* Character that indicated end of line.  */
specifier|extern
name|char
name|is_end_of_line
index|[]
decl_stmt|;
comment|/* Advance input pointer to end of line.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|eol
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* Save end-of-line char.  */
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate argument list.  */
comment|/* Parse out operands.  */
name|n_ops
operator|=
name|get_args
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Dispatch to correct handler.  */
switch|switch
condition|(
name|po_num
condition|)
block|{
case|case
name|S_SYSPROC
case|:
name|s_sysproc
argument_list|(
name|n_ops
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_LEAFPROC
case|:
name|s_leafproc
argument_list|(
name|n_ops
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|po_num
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restore eol, so line numbers get updated correctly.  Base      assembler assumes we leave input pointer pointing at char      following the eol.  */
operator|*
name|input_line_pointer
operator|++
operator|=
name|eol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reloc_callj:	Relocate a 'callj' instruction    	This is a "non-(GNU)-standard" machine-dependent hook.  The base   	assembler calls it when it decides it can relocate an address at   	assembly time instead of emitting a relocation directive.    	Check to see if the relocation involves a 'callj' instruction to a:   	    sysproc:	Replace the default 'call' instruction with a 'calls'   	    leafproc:	Replace the default 'call' instruction with a 'bal'.   	    other proc:	Do nothing.    	See b.out.h for details on the 'n_other' field in a symbol structure.     IMPORTANT!:   	Assumes the caller has already figured out, in the case of a leafproc,   	to use the 'bal' entry point, and has substituted that symbol into the   	passed fixup structure.  */
end_comment

begin_function
name|int
name|reloc_callj
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
comment|/* Relocation that can be done at assembly time.  */
block|{
comment|/* Points to the binary for the instruction being relocated.  */
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_tcbit
condition|)
comment|/* This wasn't a callj instruction in the first place.  */
return|return
literal|0
return|;
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|TC_S_IS_SYSPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Symbol is a .sysproc: replace 'call' with 'calls'.  System          procedure number is (other-1).  */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|CALLS
operator||
name|TC_S_GET_SYSPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Nothing else needs to be done for this instruction.  Make          sure 'md_number_to_field()' will perform a no-op.  */
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Should not happen: see block comment above.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Trying to 'bal' to %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_BALNAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Replace 'call' with 'bal'; both instructions have the same          format, so calling code should complete relocation as if          nothing happened here.  */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|BAL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_BADPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Looks like a proc, but can't tell what kind.\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise Symbol is neither a sysproc nor a leafproc.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle the MRI .endian pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_endian
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"little"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"big"
argument_list|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"big endian mode is not supported"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring unrecognized .endian type `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the i960, they're relative to the address of the instruction,    which we have set up as the address of the fixup too.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|place
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
name|md_number_to_imm
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
operator|(
name|size_t
operator|)
name|fixP
operator|->
name|fx_bit_fixP
operator|==
literal|13
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
comment|/* This is a COBR instruction.  They have only a 	 13-bit displacement and are only to be used 	 for local branches: flag as error, don't generate 	 relocation.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't use COBR format with external label"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|md_number_to_field
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_bit_fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_function
name|void
name|tc_bout_fix_to_chars
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|,
name|relax_addressT
name|segment_address_in_file
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|struct
name|relocation_info
name|ri
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|!=
literal|0
operator|||
name|fixP
operator|->
name|fx_r_type
operator|!=
name|NO_RELOC
argument_list|)
expr_stmt|;
name|ri
operator|.
name|r_bsr
operator|=
name|fixP
operator|->
name|fx_bsr
expr_stmt|;
comment|/*SAC LD RELAX HACK */
comment|/* These two 'cuz of NS32K */
name|ri
operator|.
name|r_callj
operator|=
name|fixP
operator|->
name|fx_tcbit
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_bit_fixP
condition|)
name|ri
operator|.
name|r_length
operator|=
literal|2
expr_stmt|;
else|else
name|ri
operator|.
name|r_length
operator|=
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
expr_stmt|;
name|ri
operator|.
name|r_pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
name|ri
operator|.
name|r_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|NO_RELOC
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|rs_align
case|:
name|ri
operator|.
name|r_index
operator|=
operator|-
literal|2
expr_stmt|;
name|ri
operator|.
name|r_pcrel
operator|=
literal|1
expr_stmt|;
name|ri
operator|.
name|r_length
operator|=
name|fixP
operator|->
name|fx_size
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
name|ri
operator|.
name|r_index
operator|=
operator|-
literal|2
expr_stmt|;
name|ri
operator|.
name|r_pcrel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rs_fill
case|:
name|ri
operator|.
name|r_index
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|ri
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linkrelax
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|fixP
operator|->
name|fx_bsr
condition|)
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|symbolP
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* Output the relocation information in machine-dependent form.  */
name|md_ri_to_chars
argument_list|(
name|where
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_comment
comment|/* Align an address by rounding it up to the specified boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
comment|/* Address to be rounded up.  */
block|{
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|coff_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For aout or bout, the bal immediately follows the call.     For coff, we cheat and store a pointer to the bal symbol in the    second aux entry of the call.  */
end_comment

begin_undef
undef|#
directive|undef
name|OBJ_ABOUT
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_define
define|#
directive|define
name|OBJ_ABOUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_BOUT
end_ifdef

begin_define
define|#
directive|define
name|OBJ_ABOUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|tc_set_bal_of_call
parameter_list|(
name|symbolS
modifier|*
name|callP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|symbolS
modifier|*
name|balP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|know
argument_list|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|TC_S_IS_BALNAME
argument_list|(
name|balP
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
name|callP
operator|->
name|sy_tc
operator|=
name|balP
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|callP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! OBJ_COFF */
ifdef|#
directive|ifdef
name|OBJ_ABOUT
comment|/* If the 'bal' entry doesn't immediately follow the 'call'      symbol, unlink it from the symbol list and re-insert it.  */
if|if
condition|(
name|symbol_next
argument_list|(
name|callP
argument_list|)
operator|!=
name|balP
condition|)
block|{
name|symbol_remove
argument_list|(
name|balP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|balP
argument_list|,
name|callP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not in order */
else|#
directive|else
comment|/* ! OBJ_ABOUT */
name|as_fatal
argument_list|(
literal|"Only supported for a.out, b.out, or COFF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! OBJ_ABOUT */
endif|#
directive|endif
comment|/* ! OBJ_COFF */
block|}
end_function

begin_function
name|symbolS
modifier|*
name|tc_get_bal_of_call
parameter_list|(
name|symbolS
modifier|*
name|callP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|retval
decl_stmt|;
name|know
argument_list|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
name|retval
operator|=
name|callP
operator|->
name|sy_tc
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OBJ_ABOUT
name|retval
operator|=
name|symbol_next
argument_list|(
name|callP
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_fatal
argument_list|(
literal|"Only supported for a.out, b.out, or COFF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! OBJ_ABOUT */
endif|#
directive|endif
comment|/* ! OBJ_COFF */
name|know
argument_list|(
name|TC_S_IS_BALNAME
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|void
name|tc_coff_symbol_emit_hook
parameter_list|(
name|symbolS
modifier|*
name|symbolP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|balP
init|=
name|tc_get_bal_of_call
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|1
index|]
operator|.
name|x_bal
operator|.
name|x_balntry
operator|=
name|S_GET_VALUE
argument_list|(
name|balP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_LEAFEXT
argument_list|)
expr_stmt|;
else|else
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_LEAFSTAT
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
operator||
operator|(
name|DT_FCN
operator|<<
name|N_BTSHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Fix up the bal symbol.  */
name|S_SET_STORAGE_CLASS
argument_list|(
name|balP
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_function
name|void
name|i960_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkrelax
condition|)
return|return;
ifndef|#
directive|ifndef
name|OBJ_BOUT
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"option --link-relax is only supported in b.out format"
argument_list|)
argument_list|)
expr_stmt|;
name|linkrelax
operator|=
literal|0
expr_stmt|;
return|return;
else|#
directive|else
comment|/* The text section "ends" with another alignment reloc, to which we      aren't adding padding.  */
if|if
condition|(
name|fragp
operator|->
name|fr_next
operator|==
name|text_last_frag
operator|||
name|fragp
operator|->
name|fr_next
operator|==
name|data_last_frag
condition|)
return|return;
comment|/* alignment directive */
name|fix_new
argument_list|(
name|fragp
argument_list|,
name|fragp
operator|->
name|fr_fix
argument_list|,
name|fragp
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|fragp
operator|->
name|fr_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_BOUT */
block|}
end_function

begin_function
name|int
name|i960_validate_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|this_segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_tcbit
operator|&&
name|TC_S_IS_CALLNAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Relocation should be done via the associated 'bal'          entry point symbol.  */
if|if
condition|(
operator|!
name|TC_S_IS_BALNAME
argument_list|(
name|tc_get_bal_of_call
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"No 'bal' entry point for leafproc %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|tc_get_bal_of_call
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* From cgen.c:  */
end_comment

begin_function
specifier|static
name|short
name|tc_bfd_fix2rtype
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
return|return
name|BFD_RELOC_32
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|!=
literal|0
operator|&&
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
return|return
name|BFD_RELOC_24_PCREL
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.     FIXME: To what extent can we get all relevant targets to use this?  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* HACK: Is this right?  */
name|fixP
operator|->
name|fx_r_type
operator|=
name|tc_bfd_fix2rtype
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* end from cgen.c */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|s_lcomm
block|,
literal|1
block|}
block|,
block|{
literal|"endian"
block|,
name|s_endian
block|,
literal|0
block|}
block|,
block|{
literal|"extended"
block|,
name|float_cons
block|,
literal|'t'
block|}
block|,
block|{
literal|"leafproc"
block|,
name|parse_po
block|,
name|S_LEAFPROC
block|}
block|,
block|{
literal|"sysproc"
block|,
name|parse_po
block|,
name|S_SYSPROC
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|cons
block|,
literal|16
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

