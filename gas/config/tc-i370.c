begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-i370.c -- Assembler for the IBM 360/370/390 instruction set.    Loosely based on the ppc files by Linas Vepstas<linas@linas.org> 1998, 99    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This assembler implements a very hacked version of an elf-like thing    that gcc emits (when gcc is suitably hacked).  To make it behave more    HLASM-like, try turning on the -M or --mri flag (as there are various    similarities between HLASM and the MRI assemblers, such as section    names, lack of leading . in pseudo-ops, DC and DS, etc.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i370.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/i370.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the assembler for the System/390 Architecture.  */
end_comment

begin_comment
comment|/* Tell the main code what the endianness is.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This string holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  The macro    tc_comment_chars points to this.  We use this, rather than the    usual comment_chars, so that we can switch for Solaris conventions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|i370_eabi_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|i370_comment_chars
init|=
name|i370_eabi_comment_chars
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ S/370 options: (these have not yet been tested and may not work) \n\ -u        		ignored\n\ -mregnames        	Allow symbolic names for registers\n\ -mno-regnames        	Do not allow symbolic names for registers\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ -mrelocatable        	support for GCC's -mrelocatble option\n\ -mrelocatable-lib       support for GCC's -mrelocatble-lib option\n\ -V        		print assembler version number\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Whether to use user friendly register names.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_REG_NAMES_P
value|TRUE
end_define

begin_decl_stmt
specifier|static
name|bfd_boolean
name|reg_names_p
init|=
name|TARGET_REG_NAMES_P
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Predefined register names if -mregnames    In general, there are lots of them, in an attempt to be compatible    with a number of assemblers.  */
end_comment

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|pd_reg
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of registers that are pre-defined:     Each general register has predefined names of the form:    1. r<reg_num> which has the value<reg_num>.    2. r.<reg_num> which has the value<reg_num>.     Each floating point register has predefined names of the form:    1. f<reg_num> which has the value<reg_num>.    2. f.<reg_num> which has the value<reg_num>.     There are only four floating point registers, and these are    commonly labelled 0,2,4 and 6.  Thus, there is no f1, f3, etc.     There are individual registers as well:    rbase or r.base has the value  3  (base register)    rpgt or r.pgt   has the value  4  (page origin table pointer)    rarg or r.arg   has the value 11  (argument pointer)    rtca or r.tca   has the value 12  (table of contents pointer)    rtoc or r.toc   has the value 12  (table of contents pointer)    sp or r.sp      has the value 13  (stack pointer)    dsa or r.dsa    has the value 13  (stack pointer)    lr              has the value 14  (link reg)     The table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pd_reg
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"arg"
block|,
literal|11
block|}
block|,
comment|/* Argument Pointer.  */
block|{
literal|"base"
block|,
literal|3
block|}
block|,
comment|/* Base Reg.  */
block|{
literal|"f.0"
block|,
literal|0
block|}
block|,
comment|/* Floating point registers.  */
block|{
literal|"f.2"
block|,
literal|2
block|}
block|,
block|{
literal|"f.4"
block|,
literal|4
block|}
block|,
block|{
literal|"f.6"
block|,
literal|6
block|}
block|,
block|{
literal|"f0"
block|,
literal|0
block|}
block|,
block|{
literal|"f2"
block|,
literal|2
block|}
block|,
block|{
literal|"f4"
block|,
literal|4
block|}
block|,
block|{
literal|"f6"
block|,
literal|6
block|}
block|,
block|{
literal|"dsa"
block|,
literal|13
block|}
block|,
comment|/* Stack pointer.  */
block|{
literal|"lr"
block|,
literal|14
block|}
block|,
comment|/* Link Register.  */
block|{
literal|"pgt"
block|,
literal|4
block|}
block|,
comment|/* Page Origin Table Pointer.  */
block|{
literal|"r.0"
block|,
literal|0
block|}
block|,
comment|/* General Purpose Registers.  */
block|{
literal|"r.1"
block|,
literal|1
block|}
block|,
block|{
literal|"r.10"
block|,
literal|10
block|}
block|,
block|{
literal|"r.11"
block|,
literal|11
block|}
block|,
block|{
literal|"r.12"
block|,
literal|12
block|}
block|,
block|{
literal|"r.13"
block|,
literal|13
block|}
block|,
block|{
literal|"r.14"
block|,
literal|14
block|}
block|,
block|{
literal|"r.15"
block|,
literal|15
block|}
block|,
block|{
literal|"r.2"
block|,
literal|2
block|}
block|,
block|{
literal|"r.3"
block|,
literal|3
block|}
block|,
block|{
literal|"r.4"
block|,
literal|4
block|}
block|,
block|{
literal|"r.5"
block|,
literal|5
block|}
block|,
block|{
literal|"r.6"
block|,
literal|6
block|}
block|,
block|{
literal|"r.7"
block|,
literal|7
block|}
block|,
block|{
literal|"r.8"
block|,
literal|8
block|}
block|,
block|{
literal|"r.9"
block|,
literal|9
block|}
block|,
block|{
literal|"r.arg"
block|,
literal|11
block|}
block|,
comment|/* Argument Pointer.  */
block|{
literal|"r.base"
block|,
literal|3
block|}
block|,
comment|/* Base Reg.  */
block|{
literal|"r.dsa"
block|,
literal|13
block|}
block|,
comment|/* Stack Pointer.  */
block|{
literal|"r.pgt"
block|,
literal|4
block|}
block|,
comment|/* Page Origin Table Pointer.  */
block|{
literal|"r.sp"
block|,
literal|13
block|}
block|,
comment|/* Stack Pointer.  */
block|{
literal|"r.tca"
block|,
literal|12
block|}
block|,
comment|/* Pointer to the table of contents.  */
block|{
literal|"r.toc"
block|,
literal|12
block|}
block|,
comment|/* Pointer to the table of contents.  */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
comment|/* More general purpose registers.  */
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"rbase"
block|,
literal|3
block|}
block|,
comment|/* Base Reg.  */
block|{
literal|"rtca"
block|,
literal|12
block|}
block|,
comment|/* Pointer to the table of contents.  */
block|{
literal|"rtoc"
block|,
literal|12
block|}
block|,
comment|/* Pointer to the table of contents.  */
block|{
literal|"sp"
block|,
literal|13
block|}
block|,
comment|/* Stack Pointer.  */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_NAME_CNT
value|(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
end_define

begin_comment
comment|/* Given NAME, find the register number associated with that name, return    the integer value associated with the given name or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
specifier|const
name|struct
name|pd_reg
modifier|*
name|regs
parameter_list|,
name|int
name|regcount
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().     in:        Input_line_pointer points to 1st char of operand.     out:        An expressionS.         The operand may have been a register: in this case, X_op == O_register,         X_add_number is set to the register number, and truth is returned.           Input_line_pointer->(next non-blank) char after operand, or is in its         original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|ISALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reg_names_p
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|name
condition|)
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* If it's a number, treat it as a number.  If it's alpha, look to      see if it's in the register table.  */
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
name|reg_number
operator|=
name|get_single_number
argument_list|()
expr_stmt|;
else|else
block|{
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
comment|/* If numeric, make sure its not out of bounds.  */
if|if
condition|(
operator|(
literal|0
operator|<=
name|reg_number
operator|)
operator|&&
operator|(
literal|16
operator|>=
name|reg_number
operator|)
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* The type of processor we are assembling for.  This is one or more    of the I370_OPCODE flags defined in opcode/i370.h.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i370_cpu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The base register to use for opcode with optional operands.    We define two of these: "text" and "other".  Normally, "text"    would get used in the .text section for branches, while "other"    gets used in the .data section for address constants.     The idea of a second base register in a different section    is foreign to the usual HLASM-style semantics; however, it    allows us to provide support for dynamically loaded libraries,    by allowing us to place address constants in a section other    than the text section. The "other" section need not be the    .data section, it can be any section that isn't the .text section.     Note that HLASM defines a multiple, concurrent .using semantic    that we do not: in calculating offsets, it uses either the most    recent .using directive, or the one with the smallest displacement.    This allows HLASM to support a quasi-block-scope-like behaviour.    Handy for people writing assembly by hand ... but not supported    by us.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i370_using_text_regno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i370_using_other_regno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The base address for address literals.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|i370_using_text_baseaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|i370_using_other_baseaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the "other" section, used only for syntax error detection.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|i370_other_section
init|=
name|undefined_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|i370_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|i370_macro_hash
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* What type of shared library support to use.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|SHLIB_NONE
block|,
name|SHLIB_PIC
block|,
name|SHILB_MRELOCATABLE
block|}
name|shlib
init|=
name|SHLIB_NONE
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flags to set in the elf header.  */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|i370_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"l:um:K:VQ:"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"um:"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'u'
case|:
comment|/* -u means that any undefined symbols should be treated as          external, which is the default for gas anyhow.  */
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
literal|'K'
case|:
comment|/* Recognize -K PIC */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"PIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHLIB_PIC
expr_stmt|;
name|i370_flags
operator||=
name|EF_I370_RELOCATABLE_LIB
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
endif|#
directive|endif
case|case
literal|'m'
case|:
comment|/* -m360 mean to assemble for the ancient 360 architecture.  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"360"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"i360"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_360
expr_stmt|;
comment|/* -mxa means to assemble for the IBM 370 XA.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"xa"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_370_XA
expr_stmt|;
comment|/* -many means to assemble for any architecture (370/XA).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_370
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* -mrelocatable/-mrelocatable-lib -- warn about 	 initializations that require relocation.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"relocatable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHILB_MRELOCATABLE
expr_stmt|;
name|i370_flags
operator||=
name|EF_I370_RELOCATABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"relocatable-lib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHILB_MRELOCATABLE
expr_stmt|;
name|i370_flags
operator||=
name|EF_I370_RELOCATABLE_LIB
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|as_bad
argument_list|(
literal|"invalid switch -m%s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section          should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set i370_cpu if it is not already set.    Currently defaults to the reasonable superset;    but can be made more fine grained if desred.  */
end_comment

begin_function
specifier|static
name|void
name|i370_set_cpu
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|default_os
init|=
name|TARGET_OS
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU
decl_stmt|;
comment|/* Override with the superset for the moment.  */
name|i370_cpu
operator|=
name|I370_OPCODE_ESA390_SUPERSET
expr_stmt|;
if|if
condition|(
name|i370_cpu
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"i360"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_360
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"i370"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_370
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"XA"
argument_list|)
operator|==
literal|0
condition|)
name|i370_cpu
operator|=
name|I370_OPCODE_370_XA
expr_stmt|;
else|else
name|as_fatal
argument_list|(
literal|"Unknown default cpu = %s, os = %s"
argument_list|,
name|default_cpu
argument_list|,
name|default_os
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Figure out the BFD architecture to use.    FIXME: specify the different 370 architectures.  */
end_comment

begin_function
name|enum
name|bfd_architecture
name|i370_arch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|bfd_arch_i370
return|;
block|}
end_function

begin_comment
comment|/* This function is called when the assembler starts up.  It is called    after the options have been parsed and the output file has been    opened.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|i370_opcode
modifier|*
name|op
decl_stmt|;
specifier|const
name|struct
name|i370_opcode
modifier|*
name|op_end
decl_stmt|;
specifier|const
name|struct
name|i370_macro
modifier|*
name|macro
decl_stmt|;
specifier|const
name|struct
name|i370_macro
modifier|*
name|macro_end
decl_stmt|;
name|bfd_boolean
name|dup_insn
init|=
name|FALSE
decl_stmt|;
name|i370_set_cpu
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Set the ELF flags if desired.  */
if|if
condition|(
name|i370_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|i370_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Insert the opcodes into a hash table.  */
name|i370_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|i370_opcodes
operator|+
name|i370_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
name|i370_opcodes
init|;
name|op
operator|<
name|op_end
condition|;
name|op
operator|++
control|)
block|{
name|know
argument_list|(
operator|(
name|op
operator|->
name|opcode
operator|.
name|i
index|[
literal|0
index|]
operator|&
name|op
operator|->
name|mask
operator|.
name|i
index|[
literal|0
index|]
operator|)
operator|==
name|op
operator|->
name|opcode
operator|.
name|i
index|[
literal|0
index|]
operator|&&
operator|(
name|op
operator|->
name|opcode
operator|.
name|i
index|[
literal|1
index|]
operator|&
name|op
operator|->
name|mask
operator|.
name|i
index|[
literal|1
index|]
operator|)
operator|==
name|op
operator|->
name|opcode
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|->
name|flags
operator|&
name|i370_cpu
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|i370_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Internal assembler error for instruction %s"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* Insert the macros into a hash table.  */
name|i370_macro_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|macro_end
operator|=
name|i370_macros
operator|+
name|i370_num_macros
expr_stmt|;
for|for
control|(
name|macro
operator|=
name|i370_macros
init|;
name|macro
operator|<
name|macro_end
condition|;
name|macro
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|macro
operator|->
name|flags
operator|&
name|i370_cpu
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|i370_macro_hash
argument_list|,
name|macro
operator|->
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Internal assembler error for macro %s"
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dup_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|i370_insn_t
name|i370_insert_operand
parameter_list|(
name|i370_insn_t
name|insn
parameter_list|,
specifier|const
name|struct
name|i370_operand
modifier|*
name|operand
parameter_list|,
name|offsetT
name|val
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Used for 48-bit insn's.  */
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This is used only for 16, 32 bit insn's.  */
name|insn
operator|.
name|i
index|[
literal|0
index|]
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Parse @got, etc. and return the desired relocation.    Currently, i370 does not support (don't really need to support) any    of these fancier markups ... for example, no one is going to    write 'L 6,=V(bogus)@got' it just doesn't make sense (at least to me).    So basically, we could get away with this routine returning    BFD_RELOC_UNUSED in all circumstances.  However, I'll leave    in for now in case someone ambitious finds a good use for this stuff ...    this routine was pretty much just copied from the powerpc code ...  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|i370_elf_suffix
parameter_list|(
name|char
modifier|*
modifier|*
name|str_p
parameter_list|,
name|expressionS
modifier|*
name|exp_p
parameter_list|)
block|{
struct|struct
name|map_bfd
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
name|char
name|ident
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|map_bfd
modifier|*
name|ptr
decl_stmt|;
define|#
directive|define
name|MAP
parameter_list|(
name|str
parameter_list|,
name|reloc
parameter_list|)
value|{ str, sizeof (str) - 1, reloc }
specifier|static
name|struct
name|map_bfd
name|mapping
index|[]
init|=
block|{
comment|/* warnings with -mrelocatable.  */
name|MAP
argument_list|(
literal|"fixup"
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|}
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'@'
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
for|for
control|(
name|ch
operator|=
operator|*
name|str
operator|,
name|str2
operator|=
name|ident
init|;
operator|(
name|str2
operator|<
name|ident
operator|+
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
operator|-
literal|1
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'@'
operator|)
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|str
control|)
operator|*
name|str2
operator|++
operator|=
name|TOLOWER
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
name|str2
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|str2
operator|-
name|ident
expr_stmt|;
name|ch
operator|=
name|ident
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|mapping
index|[
literal|0
index|]
init|;
name|ptr
operator|->
name|length
operator|>
literal|0
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|ch
operator|==
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|&&
name|len
operator|==
name|ptr
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|ident
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|!=
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_LO16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_HI16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_HI16_S_GOTOFF
operator|)
condition|)
name|as_warn
argument_list|(
literal|"identifier+constant@got means identifier@got+constant"
argument_list|)
expr_stmt|;
comment|/* Now check for identifier@suffix+constant */
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|char
modifier|*
name|orig_line
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|new_exp
decl_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|&
name|input_line_pointer
operator|!=
name|str_p
condition|)
name|input_line_pointer
operator|=
name|orig_line
expr_stmt|;
block|}
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
return|return
name|ptr
operator|->
name|reloc
return|;
block|}
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Like normal .long/.short/.word, except support @got, etc.    Clobbers input_line_pointer, checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|i370_elf_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
comment|/* 1=.byte, 2=.word, 4=.long.  */
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'@'
operator|&&
operator|(
name|reloc
operator|=
name|i370_elf_suffix
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
literal|"%s relocations do not fit in %d bytes\n"
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|nbytes
operator|-
name|size
decl_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ASCII to EBCDIC conversion table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ascebc
index|[
literal|256
index|]
init|=
block|{
comment|/*00  NL    SH    SX    EX    ET    NQ    AK    BL */
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x37
block|,
literal|0x2D
block|,
literal|0x2E
block|,
literal|0x2F
block|,
comment|/*08  BS    HT    LF    VT    FF    CR    SO    SI */
literal|0x16
block|,
literal|0x05
block|,
literal|0x15
block|,
literal|0x0B
block|,
literal|0x0C
block|,
literal|0x0D
block|,
literal|0x0E
block|,
literal|0x0F
block|,
comment|/*10  DL    D1    D2    D3    D4    NK    SN    EB */
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x3C
block|,
literal|0x3D
block|,
literal|0x32
block|,
literal|0x26
block|,
comment|/*18  CN    EM    SB    EC    FS    GS    RS    US */
literal|0x18
block|,
literal|0x19
block|,
literal|0x3F
block|,
literal|0x27
block|,
literal|0x1C
block|,
literal|0x1D
block|,
literal|0x1E
block|,
literal|0x1F
block|,
comment|/*20  SP     !     "     #     $     %&     ' */
literal|0x40
block|,
literal|0x5A
block|,
literal|0x7F
block|,
literal|0x7B
block|,
literal|0x5B
block|,
literal|0x6C
block|,
literal|0x50
block|,
literal|0x7D
block|,
comment|/*28   (     )     *     +     ,     -    .      / */
literal|0x4D
block|,
literal|0x5D
block|,
literal|0x5C
block|,
literal|0x4E
block|,
literal|0x6B
block|,
literal|0x60
block|,
literal|0x4B
block|,
literal|0x61
block|,
comment|/*30   0     1     2     3     4     5     6     7 */
literal|0xF0
block|,
literal|0xF1
block|,
literal|0xF2
block|,
literal|0xF3
block|,
literal|0xF4
block|,
literal|0xF5
block|,
literal|0xF6
block|,
literal|0xF7
block|,
comment|/*38   8     9     :     ;<     =>     ? */
literal|0xF8
block|,
literal|0xF9
block|,
literal|0x7A
block|,
literal|0x5E
block|,
literal|0x4C
block|,
literal|0x7E
block|,
literal|0x6E
block|,
literal|0x6F
block|,
comment|/*40   @     A     B     C     D     E     F     G */
literal|0x7C
block|,
literal|0xC1
block|,
literal|0xC2
block|,
literal|0xC3
block|,
literal|0xC4
block|,
literal|0xC5
block|,
literal|0xC6
block|,
literal|0xC7
block|,
comment|/*48   H     I     J     K     L     M     N     O */
literal|0xC8
block|,
literal|0xC9
block|,
literal|0xD1
block|,
literal|0xD2
block|,
literal|0xD3
block|,
literal|0xD4
block|,
literal|0xD5
block|,
literal|0xD6
block|,
comment|/*50   P     Q     R     S     T     U     V     W */
literal|0xD7
block|,
literal|0xD8
block|,
literal|0xD9
block|,
literal|0xE2
block|,
literal|0xE3
block|,
literal|0xE4
block|,
literal|0xE5
block|,
literal|0xE6
block|,
comment|/*58   X     Y     Z     [     \     ]     ^     _ */
literal|0xE7
block|,
literal|0xE8
block|,
literal|0xE9
block|,
literal|0xAD
block|,
literal|0xE0
block|,
literal|0xBD
block|,
literal|0x5F
block|,
literal|0x6D
block|,
comment|/*60   `     a     b     c     d     e     f     g */
literal|0x79
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
comment|/*68   h     i     j     k     l     m     n     o */
literal|0x88
block|,
literal|0x89
block|,
literal|0x91
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
comment|/*70   p     q     r     s     t     u     v     w */
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0xA2
block|,
literal|0xA3
block|,
literal|0xA4
block|,
literal|0xA5
block|,
literal|0xA6
block|,
comment|/*78   x     y     z     {     |     }     ~    DL */
literal|0xA7
block|,
literal|0xA8
block|,
literal|0xA9
block|,
literal|0xC0
block|,
literal|0x4F
block|,
literal|0xD0
block|,
literal|0xA1
block|,
literal|0x07
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0x3F
block|,
literal|0xFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EBCDIC to ASCII conversion table.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|ebcasc
index|[
literal|256
index|]
init|=
block|{
comment|/*00  NU    SH    SX    EX    PF    HT    LC    DL */
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x7F
block|,
comment|/*08              SM    VT    FF    CR    SO    SI */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0B
block|,
literal|0x0C
block|,
literal|0x0D
block|,
literal|0x0E
block|,
literal|0x0F
block|,
comment|/*10  DE    D1    D2    TM    RS    NL    BS    IL */
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x0A
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/*18  CN    EM    CC    C1    FS    GS    RS    US */
literal|0x18
block|,
literal|0x19
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x1C
block|,
literal|0x1D
block|,
literal|0x1E
block|,
literal|0x1F
block|,
comment|/*20  DS    SS    FS          BP    LF    EB    EC */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0A
block|,
literal|0x17
block|,
literal|0x1B
block|,
comment|/*28              SM    C2    EQ    AK    BL       */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x00
block|,
comment|/*30              SY          PN    RS    UC    ET */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
comment|/*38                    C3    D4    NK          SU */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x00
block|,
literal|0x1A
block|,
comment|/*40  SP                                           */
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*48                     .<     (     +     | */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x2E
block|,
literal|0x3C
block|,
literal|0x28
block|,
literal|0x2B
block|,
literal|0x7C
block|,
comment|/*50&                                           */
literal|0x26
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*58               !     $     *     )     ;     ^ */
literal|0x00
block|,
literal|0x00
block|,
literal|0x21
block|,
literal|0x24
block|,
literal|0x2A
block|,
literal|0x29
block|,
literal|0x3B
block|,
literal|0x5E
block|,
comment|/*60   -     /                                     */
literal|0x2D
block|,
literal|0x2F
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*68                     ,     %     _>     ? */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x2C
block|,
literal|0x25
block|,
literal|0x5F
block|,
literal|0x3E
block|,
literal|0x3F
block|,
comment|/*70                                               */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*78         `     :     #     @     '     =     " */
literal|0x00
block|,
literal|0x60
block|,
literal|0x3A
block|,
literal|0x23
block|,
literal|0x40
block|,
literal|0x27
block|,
literal|0x3D
block|,
literal|0x22
block|,
comment|/*80         a     b     c     d     e     f     g */
literal|0x00
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
comment|/*88   h     i           {                         */
literal|0x68
block|,
literal|0x69
block|,
literal|0x00
block|,
literal|0x7B
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*90         j     k     l     m     n     o     p */
literal|0x00
block|,
literal|0x6A
block|,
literal|0x6B
block|,
literal|0x6C
block|,
literal|0x6D
block|,
literal|0x6E
block|,
literal|0x6F
block|,
literal|0x70
block|,
comment|/*98   q     r           }                         */
literal|0x71
block|,
literal|0x72
block|,
literal|0x00
block|,
literal|0x7D
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*A0         ~     s     t     u     v     w     x */
literal|0x00
block|,
literal|0x7E
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
comment|/*A8   y     z                       [             */
literal|0x79
block|,
literal|0x7A
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x5B
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*B0                                               */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*B8                                 ]             */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x5D
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*C0   {     A     B     C     D     E     F     G */
literal|0x7B
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
comment|/*C8   H     I                                     */
literal|0x48
block|,
literal|0x49
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*D0   }     J     K     L     M     N     O     P */
literal|0x7D
block|,
literal|0x4A
block|,
literal|0x4B
block|,
literal|0x4C
block|,
literal|0x4D
block|,
literal|0x4E
block|,
literal|0x4F
block|,
literal|0x50
block|,
comment|/*D8   Q     R                                     */
literal|0x51
block|,
literal|0x52
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*E0   \           S     T     U     V     W     X */
literal|0x5C
block|,
literal|0x00
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x58
block|,
comment|/*E8   Y     Z                                     */
literal|0x59
block|,
literal|0x5A
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*F0   0     1     2     3     4     5     6     7 */
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
comment|/*F8   8     9                                     */
literal|0x38
block|,
literal|0x39
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EBCDIC translation tables needed for 3270 support.  */
end_comment

begin_function
specifier|static
name|void
name|i370_ebcdic
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|delim
init|=
literal|0
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|strlen
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
name|end
operator|=
name|input_line_pointer
operator|+
name|nbytes
expr_stmt|;
while|while
condition|(
literal|'\r'
operator|==
operator|*
name|end
condition|)
name|end
operator|--
expr_stmt|;
while|while
condition|(
literal|'\n'
operator|==
operator|*
name|end
condition|)
name|end
operator|--
expr_stmt|;
name|delim
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|(
literal|'\''
operator|==
name|delim
operator|)
operator|||
operator|(
literal|'\"'
operator|==
name|delim
operator|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|end
operator|=
name|rindex
argument_list|(
name|input_line_pointer
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|>
name|input_line_pointer
condition|)
block|{
name|nbytes
operator|=
name|end
operator|-
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
while|while
condition|(
name|end
operator|>
name|input_line_pointer
condition|)
block|{
operator|*
name|p
operator|=
name|ascebc
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
index|]
expr_stmt|;
operator|++
name|p
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|==
operator|*
name|input_line_pointer
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stub out a couple of routines.  */
end_comment

begin_function
specifier|static
name|void
name|i370_rmode
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_tsktsk
argument_list|(
literal|"rmode ignored"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i370_dsect
parameter_list|(
name|int
name|sect
parameter_list|)
block|{
name|char
modifier|*
name|save_line
init|=
name|input_line_pointer
decl_stmt|;
specifier|static
name|char
name|section
index|[]
init|=
literal|".data\n"
decl_stmt|;
comment|/* Just pretend this is .section .data.  */
name|input_line_pointer
operator|=
name|section
expr_stmt|;
name|obj_elf_section
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_line
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i370_csect
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_tsktsk
argument_list|(
literal|"csect not supported"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DC Define Const  is only partially supported.    For samplecode on what to do, look at i370_elf_cons() above.    This code handles pseudoops of the style    DC   D'3.141592653'   # in sysv4, .double 3.14159265    DC   F'1'             # in sysv4, .long   1.  */
end_comment

begin_function
specifier|static
name|void
name|i370_dc
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|tmp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
name|type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Figure out the size.  */
name|type
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* 16-bit */
name|nbytes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* 32-bit */
case|case
literal|'F'
case|:
comment|/* 32-bit */
name|nbytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* 64-bit */
name|nbytes
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unsupported DC type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get rid of pesky quotes.  */
if|if
condition|(
literal|'\''
operator|==
operator|*
name|input_line_pointer
condition|)
block|{
name|char
modifier|*
name|close
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|close
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
operator|*
name|close
operator|=
literal|' '
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing end-quote"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|'\"'
operator|==
operator|*
name|input_line_pointer
condition|)
block|{
name|char
modifier|*
name|close
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|close
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
operator|*
name|close
operator|=
literal|' '
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing end-quote"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* 16-bit */
case|case
literal|'F'
case|:
comment|/* 32-bit */
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* 32-bit */
case|case
literal|'D'
case|:
comment|/* 64-bit */
name|md_atof
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|tmp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unsupported DC type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide minimal support for DS Define Storage.  */
end_comment

begin_function
specifier|static
name|void
name|i370_ds
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* DS 0H or DS 0F or DS 0D.  */
if|if
condition|(
literal|'0'
operator|==
operator|*
name|input_line_pointer
condition|)
block|{
name|int
name|alignment
init|=
literal|0
decl_stmt|;
comment|/* Left shift 1<< align.  */
name|input_line_pointer
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
operator|++
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* 16-bit */
name|alignment
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* 32-bit */
name|alignment
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* 64-bit */
name|alignment
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unsupported alignment"
argument_list|)
expr_stmt|;
return|return;
block|}
name|frag_align
argument_list|(
name|alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"this DS form not yet supported"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Solaris pseudo op to change to the .rodata section.  */
end_comment

begin_function
specifier|static
name|void
name|i370_elf_rdata
parameter_list|(
name|int
name|sect
parameter_list|)
block|{
name|char
modifier|*
name|save_line
init|=
name|input_line_pointer
decl_stmt|;
specifier|static
name|char
name|section
index|[]
init|=
literal|".rodata\n"
decl_stmt|;
comment|/* Just pretend this is .section .rodata.  */
name|input_line_pointer
operator|=
name|section
expr_stmt|;
name|obj_elf_section
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pseudo op to make file scope bss items.  */
end_comment

begin_function
specifier|static
name|void
name|i370_elf_lcomm
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|align2
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip ','.  */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".COMMon length (%ld.)<0! Ignored."
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* The third argument to .lcomm is the alignment.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|8
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"ignoring bad alignment"
argument_list|)
expr_stmt|;
name|align
operator|=
literal|8
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|size
condition|)
block|{
name|as_bad
argument_list|(
literal|"Length of .lcomm \"%s\" is already %ld. Not changed to %ld."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Allocate_bss:  */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
comment|/* Convert to a power of 2 alignment.  */
for|for
control|(
name|align2
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|align2
control|)
empty_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"Common alignment not a power of 2"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align2
operator|=
literal|0
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align2
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align2
condition|)
name|frag_align
argument_list|(
name|align2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validate any relocations emitted for -mrelocatable, possibly adding    fixups for word relocations in writable segments, so we can adjust    them at runtime.  */
end_comment

begin_function
specifier|static
name|void
name|i370_elf_validate_fix
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_done
operator|||
name|fixp
operator|->
name|fx_pcrel
condition|)
return|return;
switch|switch
condition|(
name|shlib
condition|)
block|{
case|case
name|SHLIB_NONE
case|:
case|case
name|SHLIB_PIC
case|:
return|return;
case|case
name|SHILB_MRELOCATABLE
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|<=
name|BFD_RELOC_UNUSED
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_LO16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_S_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_LO16_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_S_BASEREL
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".got2"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".dtors"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".ctors"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".fixup"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".stab"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".gcc_except_table"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".ex_shared"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|seg
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
operator|)
operator|!=
literal|0
operator|||
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_CTOR
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Relocation cannot be done when using -mrelocatable"
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|LITERAL_POOL_SUPPORT
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LITERAL_POOL_SUPPORT
end_ifdef

begin_comment
comment|/* Provide support for literal pools within the text section.    Loosely based on similar code from tc-arm.c.    We will use four symbols to locate four parts of the literal pool.    These four sections contain 64,32,16 and 8-bit constants; we use    four sections so that all memory access can be appropriately aligned.    That is, we want to avoid mixing these together so that we don't    waste space padding out to alignments.  The four pointers    longlong_poolP, word_poolP, etc. point to a symbol labeling the    start of each pool part.      lit_pool_num increments from zero to infinity and uniquely id's      -- its used to generate the *_poolP symbol name.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITERAL_POOL_SIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|literalS
block|{
name|struct
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
name|size
decl_stmt|;
comment|/* 1,2,4 or 8 */
name|short
name|offset
decl_stmt|;
block|}
name|literalT
typedef|;
end_typedef

begin_decl_stmt
name|literalT
name|literals
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|next_literal_pool_place
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free entry in the pool.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|longlong_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 64-bit pool entries.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|word_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 32-bit pool entries.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|short_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 16-bit pool entries.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|byte_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8-bit  pool entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lit_pool_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new, empty symbol.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|symbol_make_empty
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|symbol_create
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make the first argument an address-relative expression    by subtracting the second argument.  */
end_comment

begin_function
specifier|static
name|void
name|i370_make_relative
parameter_list|(
name|expressionS
modifier|*
name|exx
parameter_list|,
name|expressionS
modifier|*
name|baseaddr
parameter_list|)
block|{
if|if
condition|(
name|O_constant
operator|==
name|baseaddr
operator|->
name|X_op
condition|)
block|{
name|exx
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exx
operator|->
name|X_add_number
operator|-=
name|baseaddr
operator|->
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|O_symbol
operator|==
name|baseaddr
operator|->
name|X_op
condition|)
block|{
name|exx
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exx
operator|->
name|X_op_symbol
operator|=
name|baseaddr
operator|->
name|X_add_symbol
expr_stmt|;
name|exx
operator|->
name|X_add_number
operator|-=
name|baseaddr
operator|->
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|O_uminus
operator|==
name|baseaddr
operator|->
name|X_op
condition|)
block|{
name|exx
operator|->
name|X_op
operator|=
name|O_add
expr_stmt|;
name|exx
operator|->
name|X_op_symbol
operator|=
name|baseaddr
operator|->
name|X_add_symbol
expr_stmt|;
name|exx
operator|->
name|X_add_number
operator|+=
name|baseaddr
operator|->
name|X_add_number
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Missing or bad .using directive"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an expression to the literal pool.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_lit_pool
parameter_list|(
name|expressionS
modifier|*
name|exx
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
name|int
name|offset_in_pool
init|=
literal|0
decl_stmt|;
comment|/* Start a new pool, if necessary.  */
if|if
condition|(
literal|8
operator|==
name|sz
operator|&&
name|NULL
operator|==
name|longlong_poolP
condition|)
name|longlong_poolP
operator|=
name|symbol_make_empty
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
literal|4
operator|==
name|sz
operator|&&
name|NULL
operator|==
name|word_poolP
condition|)
name|word_poolP
operator|=
name|symbol_make_empty
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
literal|2
operator|==
name|sz
operator|&&
name|NULL
operator|==
name|short_poolP
condition|)
name|short_poolP
operator|=
name|symbol_make_empty
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|sz
operator|&&
name|NULL
operator|==
name|byte_poolP
condition|)
name|byte_poolP
operator|=
name|symbol_make_empty
argument_list|()
expr_stmt|;
comment|/* Check if this literal value is already in the pool.      FIXME: We should probably be checking expressions             of type O_symbol as well.      FIXME: This is probably(certainly?) broken for O_big,             which includes 64-bit long-longs.  */
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
block|{
if|if
condition|(
name|exx
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|exx
operator|->
name|X_op
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|==
name|exx
operator|->
name|X_add_number
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_unsigned
operator|==
name|exx
operator|->
name|X_unsigned
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
operator|==
name|sz
condition|)
break|break;
elseif|else
if|if
condition|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|sym_name
operator|&&
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|literals
index|[
name|lit_count
index|]
operator|.
name|sym_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sz
operator|==
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
condition|)
name|offset_in_pool
operator|+=
name|sz
expr_stmt|;
name|lit_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lit_count
operator|==
name|next_literal_pool_place
condition|)
comment|/* new entry */
block|{
if|if
condition|(
name|next_literal_pool_place
operator|>
name|MAX_LITERAL_POOL_SIZE
condition|)
name|as_bad
argument_list|(
literal|"Literal Pool Overflow"
argument_list|)
expr_stmt|;
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|exp
operator|=
operator|*
name|exx
expr_stmt|;
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|size
operator|=
name|sz
expr_stmt|;
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|offset
operator|=
name|offset_in_pool
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|sym_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|sym_name
operator|=
name|NULL
expr_stmt|;
name|next_literal_pool_place
operator|++
expr_stmt|;
block|}
comment|/* ???_poolP points to the beginning of the literal pool.      X_add_number is the offset from the beginning of the      literal pool to this expr minus the location of the most      recent .using directive.  Thus, the grand total value of the      expression is the distance from .using to the literal.  */
if|if
condition|(
literal|8
operator|==
name|sz
condition|)
name|exx
operator|->
name|X_add_symbol
operator|=
name|longlong_poolP
expr_stmt|;
elseif|else
if|if
condition|(
literal|4
operator|==
name|sz
condition|)
name|exx
operator|->
name|X_add_symbol
operator|=
name|word_poolP
expr_stmt|;
elseif|else
if|if
condition|(
literal|2
operator|==
name|sz
condition|)
name|exx
operator|->
name|X_add_symbol
operator|=
name|short_poolP
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|sz
condition|)
name|exx
operator|->
name|X_add_symbol
operator|=
name|byte_poolP
expr_stmt|;
name|exx
operator|->
name|X_add_number
operator|=
name|offset_in_pool
expr_stmt|;
name|exx
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* If the user has set up a base reg in another section,      use that; otherwise use the text section.  */
if|if
condition|(
literal|0
operator|<
name|i370_using_other_regno
condition|)
name|i370_make_relative
argument_list|(
name|exx
argument_list|,
operator|&
name|i370_using_other_baseaddr
argument_list|)
expr_stmt|;
else|else
name|i370_make_relative
argument_list|(
name|exx
argument_list|,
operator|&
name|i370_using_text_baseaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The symbol setup for the literal pool is done in two steps.  First,    a symbol that represents the start of the literal pool is created,    above, in the add_to_pool() routine. This sym ???_poolP.    However, we don't know what fragment its in until a bit later.    So we defer the frag_now thing, and the symbol name, until .ltorg time.  */
end_comment

begin_comment
comment|/* Can't use symbol_new here, so have to create a symbol and then at    a later date assign it a value. Thats what these functions do.  */
end_comment

begin_function
specifier|static
name|void
name|symbol_locate
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
comment|/* It is copied, the caller can modify.  */
name|segT
name|segment
parameter_list|,
comment|/* Segment identifier (SEG_<something>).  */
name|valueT
name|valu
parameter_list|,
comment|/* Symbol value.  */
name|fragS
modifier|*
name|frag
parameter_list|)
comment|/* Associated fragment.  */
block|{
name|size_t
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0 */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag
argument_list|)
expr_stmt|;
comment|/* Link to end of symbol chain.  */
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|DEBUG_SYMS
ifdef|#
directive|ifdef
name|DEBUG_SYMS
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMS */
block|}
end_function

begin_comment
comment|/* i370_addr_offset() will convert operand expressions    that appear to be absolute into thier base-register    relative form.  These expressions come in two types:     (1) of the form "* + const" * where "*" means    relative offset since the last using    i.e. "*" means ".-using_baseaddr"     (2) labels, which are never absolute, but are always    relative to the last "using".  Anything with an alpha    character is considered to be a label (since symbols    can never be operands), and since we've already handled    register operands. For example, "BL .L33" branch low    to .L33 RX form insn frequently terminates for-loops.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|i370_addr_offset
parameter_list|(
name|expressionS
modifier|*
name|exx
parameter_list|)
block|{
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|lab
decl_stmt|;
name|int
name|islabel
init|=
literal|0
decl_stmt|;
name|int
name|all_digits
init|=
literal|0
decl_stmt|;
comment|/* Search for a label; anything with an alpha char will do.      Local labels consist of N digits followed by either b or f.  */
name|lab
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|lab
operator|&&
operator|(
literal|','
operator|!=
operator|*
name|lab
operator|)
operator|&&
operator|(
literal|'('
operator|!=
operator|*
name|lab
operator|)
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|lab
argument_list|)
condition|)
name|all_digits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
name|lab
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|all_digits
condition|)
block|{
name|islabel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
literal|'f'
operator|==
operator|*
name|lab
operator|)
operator|||
operator|(
literal|'b'
operator|==
operator|*
name|lab
operator|)
condition|)
block|{
name|islabel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|all_digits
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
literal|'.'
operator|!=
operator|*
name|lab
condition|)
break|break;
operator|++
name|lab
expr_stmt|;
block|}
comment|/* See if operand has a * in it.  */
name|dot
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dot
operator|&&
operator|!
name|islabel
condition|)
return|return
name|FALSE
return|;
comment|/* Replace * with . and let expr munch on it.  */
if|if
condition|(
name|dot
condition|)
operator|*
name|dot
operator|=
literal|'.'
expr_stmt|;
name|expression
argument_list|(
name|exx
argument_list|)
expr_stmt|;
comment|/* OK, now we have to subtract the "using" location.      Normally branches appear in the text section only.  */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|now_seg
operator|->
name|name
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
operator|||
literal|0
operator|>
name|i370_using_other_regno
condition|)
name|i370_make_relative
argument_list|(
name|exx
argument_list|,
operator|&
name|i370_using_text_baseaddr
argument_list|)
expr_stmt|;
else|else
name|i370_make_relative
argument_list|(
name|exx
argument_list|,
operator|&
name|i370_using_other_baseaddr
argument_list|)
expr_stmt|;
comment|/* Put the * back.  */
if|if
condition|(
name|dot
condition|)
operator|*
name|dot
operator|=
literal|'*'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle address constants of various sorts.  */
end_comment

begin_comment
comment|/* The currently supported types are       =A(some_symb)       =V(some_extern)       =X'deadbeef'    hexadecimal       =F'1234'        32-bit const int       =H'1234'        16-bit const int.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|i370_addr_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|,
name|delim
decl_stmt|;
name|int
name|name_len
decl_stmt|;
name|int
name|hex_len
init|=
literal|0
decl_stmt|;
name|int
name|cons_len
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|sym_name
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Find the spelling of the operand.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
name|ISALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
else|else
return|return
name|FALSE
return|;
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* A == address-of.  */
case|case
literal|'V'
case|:
comment|/* V == extern.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We use a simple string name to collapse together          multiple refrences to the same address literal.  */
name|name_len
operator|=
name|strcspn
argument_list|(
name|sym_name
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|delim
operator|=
operator|*
operator|(
name|sym_name
operator|+
name|name_len
operator|)
expr_stmt|;
operator|*
operator|(
name|sym_name
operator|+
name|name_len
operator|)
operator|=
literal|0x0
expr_stmt|;
name|add_to_lit_pool
argument_list|(
name|exp
argument_list|,
name|sym_name
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sym_name
operator|+
name|name_len
operator|)
operator|=
name|delim
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'F'
case|:
case|case
literal|'X'
case|:
case|case
literal|'E'
case|:
comment|/* Single-precision float point.  */
case|case
literal|'D'
case|:
comment|/* Double-precision float point.  */
comment|/* H == 16-bit fixed-point const; expression must be const.  */
comment|/* F == fixed-point const; expression must be const.  */
comment|/* X == fixed-point const; expression must be const.  */
if|if
condition|(
literal|'H'
operator|==
name|name
index|[
literal|0
index|]
condition|)
name|cons_len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|'F'
operator|==
name|name
index|[
literal|0
index|]
condition|)
name|cons_len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|'X'
operator|==
name|name
index|[
literal|0
index|]
condition|)
name|cons_len
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
literal|'E'
operator|==
name|name
index|[
literal|0
index|]
condition|)
name|cons_len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|'D'
operator|==
name|name
index|[
literal|0
index|]
condition|)
name|cons_len
operator|=
literal|8
expr_stmt|;
comment|/* Extract length, if it is present; 	 FIXME: assume single-digit length.  */
if|if
condition|(
literal|'L'
operator|==
name|name
index|[
literal|1
index|]
condition|)
block|{
comment|/* Should work for ASCII and EBCDIC.  */
name|cons_len
operator|=
name|name
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Get rid of pesky quotes.  */
if|if
condition|(
literal|'\''
operator|==
operator|*
name|input_line_pointer
condition|)
block|{
name|char
modifier|*
name|close
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|close
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
operator|*
name|close
operator|=
literal|' '
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing end-quote"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|'\"'
operator|==
operator|*
name|input_line_pointer
condition|)
block|{
name|char
modifier|*
name|close
decl_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|close
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
operator|*
name|close
operator|=
literal|' '
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"missing end-quote"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|'X'
operator|==
name|name
index|[
literal|0
index|]
operator|)
operator|||
operator|(
literal|'E'
operator|==
name|name
index|[
literal|0
index|]
operator|)
operator|||
operator|(
literal|'D'
operator|==
name|name
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|char
name|tmp
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* The length of hex constants is specified directly with L, 	     or implied through the number of hex digits. For example: 	     =X'AB'       one byte 	     =X'abcd'     two bytes 	     =X'000000AB' four bytes 	     =XL4'AB'     four bytes, left-padded withn zero.  */
if|if
condition|(
operator|(
literal|'X'
operator|==
name|name
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
literal|0
operator|>
name|cons_len
operator|)
condition|)
block|{
name|save
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|save
condition|)
block|{
if|if
condition|(
name|ISXDIGIT
argument_list|(
operator|*
name|save
argument_list|)
condition|)
name|hex_len
operator|++
expr_stmt|;
name|save
operator|++
expr_stmt|;
block|}
name|cons_len
operator|=
operator|(
name|hex_len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* I believe this works even for =XL8'dada0000beeebaaa' 	     which should parse out to X_op == O_big 	     Note that floats and doubles get represented as 	     0d3.14159265358979  or 0f 2.7.  */
name|tmp
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|tmp
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save
operator|+
operator|(
name|input_line_pointer
operator|-
name|tmp
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Fix up lengths for floats and doubles.  */
if|if
condition|(
name|O_big
operator|==
name|exp
operator|->
name|X_op
condition|)
name|exp
operator|->
name|X_add_number
operator|=
name|cons_len
operator|/
name|CHARS_PER_LITTLENUM
expr_stmt|;
block|}
else|else
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* O_big occurs when more than 4 bytes worth gets parsed.  */
if|if
condition|(
operator|(
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
operator|)
operator|&&
operator|(
name|exp
operator|->
name|X_op
operator|!=
name|O_big
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"expression not a constant"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|add_to_lit_pool
argument_list|(
name|exp
argument_list|,
literal|0x0
argument_list|,
name|cons_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Unknown/unsupported address literal type"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump the contents of the literal pool that we've accumulated so far.    This aligns the pool to the size of the largest literal in the pool.  */
end_comment

begin_function
specifier|static
name|void
name|i370_ltorg
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|litsize
decl_stmt|;
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
name|int
name|biggest_literal_size
init|=
literal|0
decl_stmt|;
name|int
name|biggest_align
init|=
literal|0
decl_stmt|;
name|char
name|pool_name
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|now_seg
operator|->
name|name
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|i370_other_section
operator|==
name|undefined_section
condition|)
name|as_bad
argument_list|(
literal|".ltorg without prior .using in section %s"
argument_list|,
name|now_seg
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i370_other_section
operator|!=
name|now_seg
condition|)
name|as_bad
argument_list|(
literal|".ltorg in section %s paired to .using in section %s"
argument_list|,
name|now_seg
operator|->
name|name
argument_list|,
name|i370_other_section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|longlong_poolP
operator|&&
operator|!
name|word_poolP
operator|&&
operator|!
name|short_poolP
operator|&&
operator|!
name|byte_poolP
condition|)
comment|/* Nothing to do.  */
return|return;
comment|/* Find largest literal .. 2 4 or 8.  */
name|lit_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
block|{
if|if
condition|(
name|biggest_literal_size
operator|<
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
condition|)
name|biggest_literal_size
operator|=
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
expr_stmt|;
name|lit_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|==
name|biggest_literal_size
condition|)
name|biggest_align
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
literal|2
operator|==
name|biggest_literal_size
condition|)
name|biggest_align
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
literal|4
operator|==
name|biggest_literal_size
condition|)
name|biggest_align
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|8
operator|==
name|biggest_literal_size
condition|)
name|biggest_align
operator|=
literal|3
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"bad alignment of %d bytes in literal pool"
argument_list|,
name|biggest_literal_size
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|biggest_align
condition|)
name|biggest_align
operator|=
literal|1
expr_stmt|;
comment|/* Align pool for short, word, double word accesses.  */
name|frag_align
argument_list|(
name|biggest_align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|biggest_align
argument_list|)
expr_stmt|;
comment|/* Note that the gas listing will print only the first five      entries in the pool .... wonder how to make it print more.  */
comment|/* Output largest literals first, then the smaller ones.  */
for|for
control|(
name|litsize
operator|=
literal|8
init|;
name|litsize
condition|;
name|litsize
operator|/=
literal|2
control|)
block|{
name|symbolS
modifier|*
name|current_poolP
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|litsize
condition|)
block|{
case|case
literal|8
case|:
name|current_poolP
operator|=
name|longlong_poolP
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|current_poolP
operator|=
name|word_poolP
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|current_poolP
operator|=
name|short_poolP
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|current_poolP
operator|=
name|byte_poolP
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"bad literal size\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|current_poolP
condition|)
continue|continue;
name|sprintf
argument_list|(
name|pool_name
argument_list|,
literal|".LITP%01d%06d"
argument_list|,
name|litsize
argument_list|,
name|lit_pool_num
argument_list|)
expr_stmt|;
name|symbol_locate
argument_list|(
name|current_poolP
argument_list|,
name|pool_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|current_poolP
argument_list|)
expr_stmt|;
name|lit_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
block|{
if|if
condition|(
name|litsize
operator|==
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
condition|)
block|{
define|#
directive|define
name|EMIT_ADDR_CONS_SYMBOLS
ifdef|#
directive|ifdef
name|EMIT_ADDR_CONS_SYMBOLS
comment|/* Create a bogus symbol, add it to the pool ... 	         For the most part, I think this is a useless exercise, 	         except that having these symbol names in the objects 	         is vaguely useful for debugging.  */
if|if
condition|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|sym_name
condition|)
block|{
name|symbolS
modifier|*
name|symP
init|=
name|symbol_make_empty
argument_list|()
decl_stmt|;
name|symbol_locate
argument_list|(
name|symP
argument_list|,
name|literals
index|[
name|lit_count
index|]
operator|.
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EMIT_ADDR_CONS_SYMBOLS */
name|emit_expr
argument_list|(
operator|&
operator|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|)
argument_list|,
name|literals
index|[
name|lit_count
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|lit_count
operator|++
expr_stmt|;
block|}
block|}
name|next_literal_pool_place
operator|=
literal|0
expr_stmt|;
name|longlong_poolP
operator|=
name|NULL
expr_stmt|;
name|word_poolP
operator|=
name|NULL
expr_stmt|;
name|short_poolP
operator|=
name|NULL
expr_stmt|;
name|byte_poolP
operator|=
name|NULL
expr_stmt|;
name|lit_pool_num
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LITERAL_POOL_SUPPORT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Add support for the HLASM-like USING directive to indicate    the base register to use ...  we don't support the full    hlasm semantics for this ... we merely pluck a base address    and a register number out.  We print a warning if using is    called multiple times.  I suppose we should check to see    if the regno is valid.  */
end_comment

begin_function
specifier|static
name|void
name|i370_using
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|,
name|baseaddr
decl_stmt|;
name|int
name|iregno
decl_stmt|;
name|char
modifier|*
name|star
decl_stmt|;
comment|/* If "*" appears in a using, it means "."      replace it with "." so that expr doesn't get confused.  */
name|star
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|star
condition|)
operator|*
name|star
operator|=
literal|'.'
expr_stmt|;
comment|/* The first arg to using will usually be ".", but it can      be a more complex expression too.  */
name|expression
argument_list|(
operator|&
name|baseaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|star
condition|)
operator|*
name|star
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
name|O_constant
operator|!=
name|baseaddr
operator|.
name|X_op
operator|&&
name|O_symbol
operator|!=
name|baseaddr
operator|.
name|X_op
operator|&&
name|O_uminus
operator|!=
name|baseaddr
operator|.
name|X_op
condition|)
name|as_bad
argument_list|(
literal|".using: base address expression illegal or too complex"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\0'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* The second arg to using had better be a register.  */
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|iregno
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|now_seg
operator|->
name|name
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|i370_using_text_baseaddr
operator|=
name|baseaddr
expr_stmt|;
name|i370_using_text_regno
operator|=
name|iregno
expr_stmt|;
block|}
else|else
block|{
name|i370_using_other_baseaddr
operator|=
name|baseaddr
expr_stmt|;
name|i370_using_other_regno
operator|=
name|iregno
expr_stmt|;
name|i370_other_section
operator|=
name|now_seg
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i370_drop
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|int
name|iregno
decl_stmt|;
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|iregno
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|now_seg
operator|->
name|name
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|iregno
operator|!=
name|i370_using_text_regno
condition|)
name|as_bad
argument_list|(
literal|"droping register %d in section %s does not match using register %d"
argument_list|,
name|iregno
argument_list|,
name|now_seg
operator|->
name|name
argument_list|,
name|i370_using_text_regno
argument_list|)
expr_stmt|;
name|i370_using_text_regno
operator|=
operator|-
literal|1
expr_stmt|;
name|i370_using_text_baseaddr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iregno
operator|!=
name|i370_using_other_regno
condition|)
name|as_bad
argument_list|(
literal|"droping register %d in section %s does not match using register %d"
argument_list|,
name|iregno
argument_list|,
name|now_seg
operator|->
name|name
argument_list|,
name|i370_using_other_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i370_other_section
operator|!=
name|now_seg
condition|)
name|as_bad
argument_list|(
literal|"droping register %d in section %s previously used in section %s"
argument_list|,
name|iregno
argument_list|,
name|now_seg
operator|->
name|name
argument_list|,
name|i370_other_section
operator|->
name|name
argument_list|)
expr_stmt|;
name|i370_using_other_regno
operator|=
operator|-
literal|1
expr_stmt|;
name|i370_using_other_baseaddr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|i370_other_section
operator|=
name|undefined_section
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.  */
end_comment

begin_struct
struct|struct
name|i370_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|5
end_define

begin_comment
comment|/* Handle a macro.  Gather all the operands, transform them as    described by the macro, and call md_assemble recursively.  All the    operands are separated by commas; we don't accept parentheses    around operands here.  */
end_comment

begin_function
specifier|static
name|void
name|i370_macro
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|struct
name|i370_macro
modifier|*
name|macro
parameter_list|)
block|{
name|char
modifier|*
name|operands
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|char
modifier|*
name|send
decl_stmt|;
name|char
modifier|*
name|complete
decl_stmt|;
comment|/* Gather the users operands into the operands array.  */
name|count
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|>=
sizeof|sizeof
name|operands
operator|/
sizeof|sizeof
name|operands
index|[
literal|0
index|]
condition|)
break|break;
name|operands
index|[
name|count
operator|++
index|]
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|macro
operator|->
name|operands
condition|)
block|{
name|as_bad
argument_list|(
literal|"wrong number of operands"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Work out how large the string must be (the size is unbounded      because it includes user input).  */
name|len
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|macro
operator|->
name|format
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
block|{
operator|++
name|len
expr_stmt|;
operator|++
name|format
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|strtol
argument_list|(
name|format
operator|+
literal|1
argument_list|,
operator|&
name|send
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|send
operator|!=
name|format
operator|&&
name|arg
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|arg
operator|<
name|count
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|operands
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|format
operator|=
name|send
expr_stmt|;
block|}
block|}
comment|/* Put the string together.  */
name|complete
operator|=
name|s
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|format
operator|=
name|macro
operator|->
name|format
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|format
operator|++
expr_stmt|;
else|else
block|{
name|arg
operator|=
name|strtol
argument_list|(
name|format
operator|+
literal|1
argument_list|,
operator|&
name|send
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|operands
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|format
operator|=
name|send
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assemble the constructed instruction.  */
name|md_assemble
argument_list|(
name|complete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|opcode_str
decl_stmt|;
specifier|const
name|struct
name|i370_opcode
modifier|*
name|opcode
decl_stmt|;
name|i370_insn_t
name|insn
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|have_optional_index
decl_stmt|,
name|have_optional_basereg
decl_stmt|,
name|have_optional_reg
decl_stmt|;
name|int
name|skip_optional_index
decl_stmt|,
name|skip_optional_basereg
decl_stmt|,
name|skip_optional_reg
decl_stmt|;
name|int
name|use_text
init|=
literal|0
decl_stmt|,
name|use_other
init|=
literal|0
decl_stmt|;
name|int
name|off_by_one
decl_stmt|;
name|struct
name|i370_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
name|int
name|fc
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
endif|#
directive|endif
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|opcode_str
operator|=
name|str
expr_stmt|;
comment|/* Look up the opcode in the hash table.  */
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|i370_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|i370_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
operator|(
specifier|const
expr|struct
name|i370_opcode
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|const
name|struct
name|i370_macro
modifier|*
name|macro
decl_stmt|;
name|assert
argument_list|(
name|i370_macro_hash
argument_list|)
expr_stmt|;
name|macro
operator|=
operator|(
specifier|const
expr|struct
name|i370_macro
operator|*
operator|)
name|hash_find
argument_list|(
name|i370_macro_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|==
operator|(
specifier|const
expr|struct
name|i370_macro
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|i370_macro
argument_list|(
name|s
argument_list|,
name|macro
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
comment|/* I370 operands are either expressions or address constants.      Many operand types are optional.  The optional operands      are always surrounded by parens, and are used to denote the base      register ... e.g. "A R1, D2" or "A R1, D2(,B2) as opposed to      the fully-formed "A R1, D2(X2,B2)".  Note also the = sign,      such as A R1,=A(i) where the address-of operator =A implies      use of both a base register, and a missing index register.       So, before we start seriously parsing the operands, we check      to see if we have an optional operand, and, if we do, we count      the number of commas to see which operand should be omitted.  */
name|have_optional_index
operator|=
name|have_optional_basereg
operator|=
name|have_optional_reg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|i370_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|i370_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_INDEX
operator|)
operator|!=
literal|0
condition|)
name|have_optional_index
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_BASE
operator|)
operator|!=
literal|0
condition|)
name|have_optional_basereg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_OPTIONAL
operator|)
operator|!=
literal|0
condition|)
name|have_optional_reg
operator|=
literal|1
expr_stmt|;
block|}
name|skip_optional_index
operator|=
name|skip_optional_basereg
operator|=
name|skip_optional_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|have_optional_index
operator|||
name|have_optional_basereg
condition|)
block|{
name|unsigned
name|int
name|opcount
decl_stmt|,
name|nwanted
decl_stmt|;
comment|/* There is an optional operand.  Count the number of 	 commas and open-parens in the input line.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
name|opcount
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|opcount
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strpbrk
argument_list|(
name|s
argument_list|,
literal|",(="
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|++
name|opcount
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
literal|','
operator|==
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
comment|/* avoid counting things like (, */
if|if
condition|(
literal|'='
operator|==
operator|*
name|s
condition|)
block|{
operator|++
name|s
expr_stmt|;
operator|--
name|opcount
expr_stmt|;
block|}
block|}
block|}
comment|/* If there are fewer operands in the line then are called 	 for by the instruction, we want to skip the optional 	 operand.  */
name|nwanted
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opcode
operator|->
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_optional_index
condition|)
block|{
if|if
condition|(
name|opcount
operator|<
name|nwanted
condition|)
name|skip_optional_index
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|have_optional_basereg
operator|&&
operator|(
operator|(
name|opcount
operator|+
literal|1
operator|)
operator|<
name|nwanted
operator|)
condition|)
name|skip_optional_basereg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|have_optional_reg
operator|&&
operator|(
operator|(
name|opcount
operator|+
literal|1
operator|)
operator|<
name|nwanted
operator|)
condition|)
name|skip_optional_reg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|have_optional_basereg
operator|&&
operator|(
name|opcount
operator|<
name|nwanted
operator|)
condition|)
name|skip_optional_basereg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|have_optional_reg
operator|&&
operator|(
name|opcount
operator|<
name|nwanted
operator|)
condition|)
name|skip_optional_reg
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Perform some off-by-one hacks on the length field of certain instructions.      Its such a shame to have to do this, but the problem is that HLASM got      defined so that the lengths differ by one from the actual machine instructions.      this code should probably be moved to a special inster-operand routine.      Sigh. Affected instructions are Compare Logical, Move and Exclusive OR      hack alert -- aren't *all* SS instructions affected ??  */
name|off_by_one
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"CLC"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"ED"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"EDMK"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"MVC"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"MVCIN"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"MVN"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"MVZ"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"NC"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"OC"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|||
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"XC"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
name|off_by_one
operator|=
literal|1
expr_stmt|;
comment|/* Gather the operands.  */
name|fc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|i370_operand
modifier|*
name|operand
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|operand
operator|=
operator|&
name|i370_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
comment|/* If this is an index operand, and we are skipping it, 	 just insert a zero.  */
if|if
condition|(
name|skip_optional_index
operator|&&
operator|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_INDEX
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is the base operand, and we are skipping it, 	 just insert the current using basreg.  */
if|if
condition|(
name|skip_optional_basereg
operator|&&
operator|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_BASE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|basereg
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|use_text
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|now_seg
operator|->
name|name
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
operator|||
literal|0
operator|>
name|i370_using_other_regno
condition|)
name|basereg
operator|=
name|i370_using_text_regno
expr_stmt|;
else|else
name|basereg
operator|=
name|i370_using_other_regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_other
condition|)
block|{
if|if
condition|(
literal|0
operator|>
name|i370_using_other_regno
condition|)
name|basereg
operator|=
name|i370_using_text_regno
expr_stmt|;
else|else
name|basereg
operator|=
name|i370_using_other_regno
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|>
name|basereg
condition|)
name|as_bad
argument_list|(
literal|"not using any base register"
argument_list|)
expr_stmt|;
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is an optional operand, and we are skipping it, 	 Use zero (since a non-zero value would denote a register)  */
if|if
condition|(
name|skip_optional_reg
operator|&&
operator|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_OPTIONAL
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* Register names are only allowed where there are registers.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_GPR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Quickie hack to get past things like (,r13).  */
if|if
condition|(
name|skip_optional_index
operator|&&
operator|(
literal|','
operator|==
operator|*
name|input_line_pointer
operator|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|' '
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"expecting a register for operand %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|opindex_ptr
operator|-
name|opcode
operator|->
name|operands
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an address constant expression.  */
comment|/* We will put PSW-relative addresses in the text section,          and address literals in the .data (or other) section.  */
elseif|else
if|if
condition|(
name|i370_addr_cons
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|use_other
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i370_addr_offset
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|use_text
operator|=
literal|1
expr_stmt|;
else|else
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
comment|/* Perform some off-by-one hacks on the length field of certain instructions.          Its such a shame to have to do this, but the problem is that HLASM got          defined so that the programmer specifies a length that is one greater          than what the machine instruction wants.  Sigh.  */
if|if
condition|(
name|off_by_one
operator|&&
operator|(
literal|0
operator|==
name|strcasecmp
argument_list|(
literal|"SS L"
argument_list|,
name|operand
operator|->
name|name
argument_list|)
operator|)
condition|)
name|ex
operator|.
name|X_add_number
operator|--
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_register
condition|)
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Allow @HA, @L, @H on constants.              Well actually, no we don't; there really don't make sense              (at least not to me) for the i370.  However, this code is              left here for any dubious future expansion reasons.  */
name|char
modifier|*
name|orig_str
init|=
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reloc
operator|=
name|i370_elf_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
switch|switch
condition|(
name|reloc
condition|)
block|{
default|default:
name|str
operator|=
name|orig_str
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
comment|/* X_unsigned is the default, so if the user has done                    something which cleared it, we always produce a                    signed value.  */
name|ex
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ex
operator|.
name|X_add_number
operator|=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ex
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|+
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|(
name|reloc
operator|=
name|i370_elf_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|as_tsktsk
argument_list|(
literal|"md_assemble(): suffixed relocations not supported\n"
argument_list|)
expr_stmt|;
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
literal|0
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
else|else
block|{
comment|/* We need to generate a fixup for this expression.  */
comment|/* Typically, the expression will just be a symbol ...                printf ("insn %s needs fixup for %s \n",                     opcode->name, ex.X_add_symbol->bsym->name);  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
comment|/* Skip over delimiter (close paren, or comma).  */
if|if
condition|(
operator|(
literal|')'
operator|==
operator|*
name|str
operator|)
operator|&&
operator|(
literal|','
operator|==
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
operator|++
name|str
expr_stmt|;
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Write out the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
name|opcode
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
literal|4
operator|>=
name|opcode
operator|->
name|len
condition|)
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|opcode
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
literal|6
operator|==
name|opcode
operator|->
name|len
condition|)
name|md_number_to_chars
argument_list|(
operator|(
name|f
operator|+
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|insn
operator|.
name|i
index|[
literal|1
index|]
operator|)
operator|>>
literal|16
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Not used --- don't have any 8 byte instructions.  */
name|as_bad
argument_list|(
literal|"Internal Error: bad instruction length"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|f
operator|+
literal|4
operator|)
argument_list|,
name|insn
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|opcode
operator|->
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create any fixups.  At this point we do not use a      bfd_reloc_code_real_type, but instead just use the      BFD_RELOC_UNUSED plus the operand index.  This lets us easily      handle fixups for any operand type, although that is admittedly      not a very exciting feature.  We pick a BFD reloc type in      md_apply_fix.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|i370_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|i370_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" gwana doo fixup %d \n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
comment|/* Turn off complaints that the addend is too large for things like 	     foo+100000@ha.  */
switch|switch
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_16_GOTOFF
case|:
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|opcode
operator|->
name|len
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|I370_OPERAND_RELATIVE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pseudo-op handling.  */
end_comment

begin_comment
comment|/* The .byte pseudo-op.  This is similar to the normal .byte    pseudo-op, but it can also take a single ASCII string.  */
end_comment

begin_function
specifier|static
name|void
name|i370_byte
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
block|{
name|cons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gather characters.  A real double quote is doubled.  Unusual      characters are not permitted.  */
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The .tc pseudo-op.  This is used when generating XCOFF and ELF.    This takes two or more arguments.     When generating XCOFF output, the first argument is the name to    give to this location in the toc; this will be a symbol with class    TC.  The rest of the arguments are 4 byte values to actually put at    this location in the TOC; often there is just one more argument, a    relocatable symbol reference.     When not generating XCOFF output, the arguments are the same, but    the first argument is simply ignored.  */
end_comment

begin_function
specifier|static
name|void
name|i370_tc
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Skip the TOC symbol name.  */
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'['
operator|||
operator|*
name|input_line_pointer
operator|==
literal|']'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'{'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'}'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Align to a four byte boundary.  */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litp
parameter_list|,
name|int
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'E'
case|:
name|type
operator|=
literal|'f'
expr_stmt|;
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|type
operator|=
literal|'d'
expr_stmt|;
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
comment|/* 360/370/390 have two float formats: an old, funky 360 single-precision    * format, and the ieee format.  Support only the ieee format.  */
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate    endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Align a section (I don't know why this is machine dependent).  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We don't have any form of relaxing.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  We never generate these.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the    fixup.     See gas/cgen.c for more sample code and explanations of what's    going on here.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\nmd_apply_fix: symbol %s at 0x%x (%s:%d) val=0x%x addend=0x%x\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* Apply fixups to operands.  Note that there should be no relocations      for any operands, since no instruction ever takes an operand      that requires reloc.  */
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|i370_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|i370_insn_t
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|i370_operands
index|[
name|opindex
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\nmd_apply_fix: fixup operand %s at 0x%x in %s:%d addend=0x%x\n"
argument_list|,
name|operand
operator|->
name|name
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fetch the instruction, insert the fully resolved operand          value, and stuff the instruction back again.          fisxp->fx_size is the length of the instruction.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
literal|6
operator|<=
name|fixP
operator|->
name|fx_size
condition|)
comment|/* Deal with 48-bit insn's.  */
name|insn
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|bfd_getb32
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insn
operator|=
name|i370_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
literal|6
operator|<=
name|fixP
operator|->
name|fx_size
condition|)
comment|/* Deal with 48-bit insn's.  */
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|)
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* We are done, right? right !!  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
comment|/* Nothing else to do here.  */
return|return;
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into 	 relocs.  In fact, we support *zero* operand relocations ... 	 Why?  Because we are not expecting the compiler to generate 	 any operands that need relocation.  Due to the 12-bit naturew of 	 i370 addressing, this would be unusual.  */
block|{
name|char
modifier|*
name|sfile
decl_stmt|;
name|unsigned
name|int
name|sline
decl_stmt|;
comment|/* Use expr_symbol_where to see if this is an expression              symbol.  */
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
operator|&
name|sfile
argument_list|,
operator|&
name|sline
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"unresolved expression that must be resolved"
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"unsupported relocation type"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* We branch to here if the fixup is not to a symbol that          appears in an instruction operand, but is rather some          declared storage.  */
ifdef|#
directive|ifdef
name|OBJ_ELF
name|i370_elf_validate_fix
argument_list|(
name|fixP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"md_apply_fix: reloc case %d in segment  %s %s:%d\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcurrent fixup value is 0x%x \n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_32_BASEREL
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\t32 bit relocation at 0x%x\n"
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"cannot emit PC relative %s relocation%s%s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|?
literal|" against "
else|:
literal|""
argument_list|,
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* This case happens when you write, for example,              lis %r3,(L1-L2)@ha              where L1 and L2 are defined later.  */
case|case
name|BFD_RELOC_HI16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
operator|(
name|value
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gas failure, reloc value %d\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a reloc for a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"reloc %d not supported by object file format"
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\ngen_reloc(): sym %s (%s:%d) at addr 0x%x addend=0x%x\n"
argument_list|,
name|fixp
operator|->
name|fx_addsy
operator|->
name|bsym
operator|->
name|name
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|reloc
operator|->
name|address
argument_list|,
name|reloc
operator|->
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* Pseudo-ops which must be overridden.  */
block|{
literal|"byte"
block|,
name|i370_byte
block|,
literal|0
block|}
block|,
block|{
literal|"dc"
block|,
name|i370_dc
block|,
literal|0
block|}
block|,
block|{
literal|"ds"
block|,
name|i370_ds
block|,
literal|0
block|}
block|,
block|{
literal|"rmode"
block|,
name|i370_rmode
block|,
literal|0
block|}
block|,
block|{
literal|"csect"
block|,
name|i370_csect
block|,
literal|0
block|}
block|,
block|{
literal|"dsect"
block|,
name|i370_dsect
block|,
literal|0
block|}
block|,
comment|/* enable ebcdic strings e.g. for 3270 support */
block|{
literal|"ebcdic"
block|,
name|i370_ebcdic
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"long"
block|,
name|i370_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|i370_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"short"
block|,
name|i370_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"rdata"
block|,
name|i370_elf_rdata
block|,
literal|0
block|}
block|,
block|{
literal|"rodata"
block|,
name|i370_elf_rdata
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|i370_elf_lcomm
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* This pseudo-op is used even when not generating XCOFF output.  */
block|{
literal|"tc"
block|,
name|i370_tc
block|,
literal|0
block|}
block|,
comment|/* dump the literal pool */
block|{
literal|"ltorg"
block|,
name|i370_ltorg
block|,
literal|0
block|}
block|,
comment|/* support the hlasm-style USING directive */
block|{
literal|"using"
block|,
name|i370_using
block|,
literal|0
block|}
block|,
block|{
literal|"drop"
block|,
name|i370_drop
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

