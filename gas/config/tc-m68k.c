begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-m68k.c -- Assemble for the m68k family    Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_include
include|#
directive|include
file|"m68k-parse.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
end_if

begin_include
include|#
directive|include
file|"elf/m68k.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|M68KCOFF
end_ifdef

begin_include
include|#
directive|include
file|"obj-coff.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This string holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  The macro    tc_comment_chars points to this.  We use this, rather than the    usual comment_chars, so that the --bitwise-or option will work.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TE_SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_DELTA
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|char
modifier|*
name|m68k_comment_chars
init|=
literal|"|#"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|m68k_comment_chars
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#*"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant, as    in "0f12.456" or "0d1.2345e12".  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c .  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.  */
end_comment

begin_comment
comment|/* Are we trying to generate PIC code?  If so, absolute references    ought to be made into linkage table references or pc-relative    references.  Not implemented.  For ELF there are other means    to denote pic relocations.  */
end_comment

begin_decl_stmt
name|int
name|flag_want_pic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flag_short_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_long_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_keep_pcrel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --pcrel option.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_PREFIX_OPTIONAL
end_ifdef

begin_decl_stmt
name|int
name|flag_reg_prefix_optional
init|=
name|REGISTER_PREFIX_OPTIONAL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_reg_prefix_optional
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether --register-prefix-optional was used on the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_prefix_optional_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The floating point coprocessor to use by default.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|m68k_register
name|m68k_float_copnum
init|=
name|COP1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is non-zero, then references to number(%pc) will be taken    to refer to number, rather than to %pc + number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m68k_abspcadd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is non-zero, then the quick forms of the move, add, and sub    instructions are used when possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m68k_quick
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is non-zero, then if the size is not specified for a base    or outer displacement, the assembler assumes that the size should    be 32 bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m68k_rel32
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is non-zero if m68k_rel32 was set from the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m68k_rel32_from_cmdline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default width to use for an index register when using a base    displacement.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|m68k_size
name|m68k_index_width_default
init|=
name|SIZE_LONG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We want to warn if any text labels are misaligned.  In order to get    the right line number, we need to record the line number for each    label.  */
end_comment

begin_struct
struct|struct
name|label_line
block|{
name|struct
name|label_line
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|int
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of labels.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|label_line
modifier|*
name|labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current label.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|label_line
modifier|*
name|current_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to list holding the opcodes sorted by name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m68k_opcode
specifier|const
modifier|*
modifier|*
name|m68k_sorted_opcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Its an arbitrary name:  This means I don't approve of it.    See flames below.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|robyn
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|m68k_incant
block|{
specifier|const
name|char
modifier|*
name|m_operands
decl_stmt|;
name|unsigned
name|long
name|m_opcode
decl_stmt|;
name|short
name|m_opnum
decl_stmt|;
name|short
name|m_codenum
decl_stmt|;
name|int
name|m_arch
decl_stmt|;
name|struct
name|m68k_incant
modifier|*
name|m_next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|getone
parameter_list|(
name|x
parameter_list|)
value|((((x)->m_opcode)>>16)&0xffff)
end_define

begin_define
define|#
directive|define
name|gettwo
parameter_list|(
name|x
parameter_list|)
value|(((x)->m_opcode)&0xffff)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|m68000_ctrl
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|m68010_ctrl
index|[]
init|=
block|{
name|SFC
block|,
name|DFC
block|,
name|USP
block|,
name|VBR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|m68020_ctrl
index|[]
init|=
block|{
name|SFC
block|,
name|DFC
block|,
name|USP
block|,
name|VBR
block|,
name|CACR
block|,
name|CAAR
block|,
name|MSP
block|,
name|ISP
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|m68040_ctrl
index|[]
init|=
block|{
name|SFC
block|,
name|DFC
block|,
name|CACR
block|,
name|TC
block|,
name|ITT0
block|,
name|ITT1
block|,
name|DTT0
block|,
name|DTT1
block|,
name|USP
block|,
name|VBR
block|,
name|MSP
block|,
name|ISP
block|,
name|MMUSR
block|,
name|URP
block|,
name|SRP
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|m68060_ctrl
index|[]
init|=
block|{
name|SFC
block|,
name|DFC
block|,
name|CACR
block|,
name|TC
block|,
name|ITT0
block|,
name|ITT1
block|,
name|DTT0
block|,
name|DTT1
block|,
name|BUSCR
block|,
name|USP
block|,
name|VBR
block|,
name|URP
block|,
name|SRP
block|,
name|PCR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf_ctrl
index|[]
init|=
block|{
name|CACR
block|,
name|TC
block|,
name|ACR0
block|,
name|ACR1
block|,
name|ACR2
block|,
name|ACR3
block|,
name|VBR
block|,
name|ROMBAR
block|,
name|RAMBAR0
block|,
name|RAMBAR1
block|,
name|MBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5208_ctrl
index|[]
init|=
block|{
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|VBR
block|,
name|RAMBAR1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5213_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|RAMBAR
block|,
name|FLASHBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5216_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|FLASHBAR
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5235_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5249_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR0
block|,
name|RAMBAR1
block|,
name|MBAR
block|,
name|MBAR2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5250_ctrl
index|[]
init|=
block|{
name|VBR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5271_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5272_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|ROMBAR
block|,
name|RAMBAR
block|,
name|MBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5275_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5282_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|FLASHBAR
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5329_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcf5373_ctrl
index|[]
init|=
block|{
name|VBR
block|,
name|CACR
block|,
name|ACR0
block|,
name|ACR1
block|,
name|RAMBAR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
name|mcfv4e_ctrl
index|[]
init|=
block|{
name|CACR
block|,
name|TC
block|,
name|ITT0
block|,
name|ITT1
block|,
name|DTT0
block|,
name|DTT1
block|,
name|BUSCR
block|,
name|VBR
block|,
name|PC
block|,
name|ROMBAR
block|,
name|ROMBAR1
block|,
name|RAMBAR0
block|,
name|RAMBAR1
block|,
name|MPCR
block|,
name|EDRAMBAR
block|,
name|SECMBAR
block|,
name|MBAR
block|,
name|MBAR0
block|,
name|MBAR1
block|,
name|PCR1U0
block|,
name|PCR1L0
block|,
name|PCR1U1
block|,
name|PCR1L1
block|,
name|PCR2U0
block|,
name|PCR2L0
block|,
name|PCR2U1
block|,
name|PCR2L1
block|,
name|PCR3U0
block|,
name|PCR3L0
block|,
name|PCR3U1
block|,
name|PCR3L1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cpu32_ctrl
value|m68010_ctrl
end_define

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|m68k_register
modifier|*
name|control_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal form of a 68020 instruction.  */
end_comment

begin_struct
struct|struct
name|m68k_it
block|{
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
comment|/* List of opcode info.  */
name|int
name|numargs
decl_stmt|;
name|int
name|numo
decl_stmt|;
comment|/* Number of shorts in opcode.  */
name|short
name|opcode
index|[
literal|11
index|]
decl_stmt|;
name|struct
name|m68k_op
name|operands
index|[
literal|6
index|]
decl_stmt|;
name|int
name|nexp
decl_stmt|;
comment|/* Number of exprs in use.  */
name|struct
name|m68k_exp
name|exprs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|nfrag
decl_stmt|;
comment|/* Number of frags we have to produce.  */
struct|struct
block|{
name|int
name|fragoff
decl_stmt|;
comment|/* Where in the current opcode the frag ends.  */
name|symbolS
modifier|*
name|fadd
decl_stmt|;
name|offsetT
name|foff
decl_stmt|;
name|int
name|fragty
decl_stmt|;
block|}
name|fragb
index|[
literal|4
index|]
struct|;
name|int
name|nrel
decl_stmt|;
comment|/* Num of reloc strucs in use.  */
struct|struct
block|{
name|int
name|n
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
name|wid
decl_stmt|;
name|char
name|pcrel
decl_stmt|;
comment|/* In a pc relative address the difference between the address 	 of the offset and the address that the offset is relative 	 to.  This depends on the addressing mode.  Basically this 	 is the value to put in the offset field to address the 	 first byte of the offset, without regarding the special 	 significance of some values (in the branch instruction, for 	 example).  */
name|int
name|pcrel_fix
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Whether this expression needs special pic relocation, and if 	 so, which.  */
name|enum
name|pic_relocation
name|pic_reloc
decl_stmt|;
endif|#
directive|endif
block|}
name|reloc
index|[
literal|5
index|]
struct|;
comment|/* Five is enough???  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|cpu_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& (m68000up | mcfisa_a))
end_define

begin_define
define|#
directive|define
name|float_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& mfloat)
end_define

begin_define
define|#
directive|define
name|mmu_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& mmmu)
end_define

begin_define
define|#
directive|define
name|arch_coldfire_p
parameter_list|(
name|x
parameter_list|)
value|((x)& mcfisa_a)
end_define

begin_define
define|#
directive|define
name|arch_coldfire_fpu
parameter_list|(
name|x
parameter_list|)
value|((x)& cfloat)
end_define

begin_comment
comment|/* Macros for determining if cpu supports a specific addressing mode.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_LONG_BRANCH
parameter_list|(
name|x
parameter_list|)
value|((x)& (m68020|m68030|m68040|m68060|cpu32|mcfisa_b))
end_define

begin_decl_stmt
specifier|static
name|struct
name|m68k_it
name|the_ins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instruction being assembled.  */
end_comment

begin_define
define|#
directive|define
name|op
parameter_list|(
name|ex
parameter_list|)
value|((ex)->exp.X_op)
end_define

begin_define
define|#
directive|define
name|adds
parameter_list|(
name|ex
parameter_list|)
value|((ex)->exp.X_add_symbol)
end_define

begin_define
define|#
directive|define
name|subs
parameter_list|(
name|ex
parameter_list|)
value|((ex)->exp.X_op_symbol)
end_define

begin_define
define|#
directive|define
name|offs
parameter_list|(
name|ex
parameter_list|)
value|((ex)->exp.X_add_number)
end_define

begin_comment
comment|/* Macros for adding things to the m68k_it struct.  */
end_comment

begin_define
define|#
directive|define
name|addword
parameter_list|(
name|w
parameter_list|)
value|(the_ins.opcode[the_ins.numo++] = (w))
end_define

begin_comment
comment|/* Like addword, but goes BEFORE general operands.  */
end_comment

begin_function
specifier|static
name|void
name|insop
parameter_list|(
name|int
name|w
parameter_list|,
specifier|const
name|struct
name|m68k_incant
modifier|*
name|opcode
parameter_list|)
block|{
name|int
name|z
decl_stmt|;
for|for
control|(
name|z
operator|=
name|the_ins
operator|.
name|numo
init|;
name|z
operator|>
name|opcode
operator|->
name|m_codenum
condition|;
operator|--
name|z
control|)
name|the_ins
operator|.
name|opcode
index|[
name|z
index|]
operator|=
name|the_ins
operator|.
name|opcode
index|[
name|z
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|z
operator|++
control|)
name|the_ins
operator|.
name|reloc
index|[
name|z
index|]
operator|.
name|n
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|the_ins
operator|.
name|nfrag
condition|;
name|z
operator|++
control|)
name|the_ins
operator|.
name|fragb
index|[
name|z
index|]
operator|.
name|fragoff
operator|++
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
name|opcode
operator|->
name|m_codenum
index|]
operator|=
name|w
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The numo+1 kludge is so we can hit the low order byte of the prev word.    Blecch.  */
end_comment

begin_function
specifier|static
name|void
name|add_fix
parameter_list|(
name|int
name|width
parameter_list|,
name|struct
name|m68k_exp
modifier|*
name|exp
parameter_list|,
name|int
name|pc_rel
parameter_list|,
name|int
name|pc_fix
parameter_list|)
block|{
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
index|]
operator|.
name|n
operator|=
operator|(
name|width
operator|==
literal|'B'
operator|||
name|width
operator|==
literal|'3'
condition|?
name|the_ins
operator|.
name|numo
operator|*
literal|2
operator|-
literal|1
else|:
operator|(
name|width
operator|==
literal|'b'
condition|?
name|the_ins
operator|.
name|numo
operator|*
literal|2
operator|+
literal|1
else|:
name|the_ins
operator|.
name|numo
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
index|]
operator|.
name|exp
operator|=
name|exp
operator|->
name|exp
expr_stmt|;
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
index|]
operator|.
name|wid
operator|=
name|width
expr_stmt|;
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
index|]
operator|.
name|pcrel_fix
operator|=
name|pc_fix
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
index|]
operator|.
name|pic_reloc
operator|=
name|exp
operator|->
name|pic_reloc
expr_stmt|;
endif|#
directive|endif
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|++
index|]
operator|.
name|pcrel
operator|=
name|pc_rel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cause an extra frag to be generated here, inserting up to 10 bytes    (that value is chosen in the frag_var call in md_assemble).  TYPE    is the subtype of the frag to be generated; its primary type is    rs_machine_dependent.     The TYPE parameter is also used by md_convert_frag_1 and    md_estimate_size_before_relax.  The appropriate type of fixup will    be emitted by md_convert_frag_1.     ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|add_frag
parameter_list|(
name|symbolS
modifier|*
name|add
parameter_list|,
name|offsetT
name|off
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|the_ins
operator|.
name|fragb
index|[
name|the_ins
operator|.
name|nfrag
index|]
operator|.
name|fragoff
operator|=
name|the_ins
operator|.
name|numo
expr_stmt|;
name|the_ins
operator|.
name|fragb
index|[
name|the_ins
operator|.
name|nfrag
index|]
operator|.
name|fadd
operator|=
name|add
expr_stmt|;
name|the_ins
operator|.
name|fragb
index|[
name|the_ins
operator|.
name|nfrag
index|]
operator|.
name|foff
operator|=
name|off
expr_stmt|;
name|the_ins
operator|.
name|fragb
index|[
name|the_ins
operator|.
name|nfrag
operator|++
index|]
operator|.
name|fragty
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|isvar
parameter_list|(
name|ex
parameter_list|)
define|\
value|(op (ex) != O_constant&& op (ex) != O_big)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|crack_operand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|m68k_op
modifier|*
name|opP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_num
parameter_list|(
name|struct
name|m68k_exp
modifier|*
name|exp
parameter_list|,
name|int
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_16_bits
parameter_list|(
name|int
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_8_bits
parameter_list|(
name|int
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_gen_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data1
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data2
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_even
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_proc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_chip
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_fopt
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_opt
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_reg
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_restore
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_save
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_if
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_else
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_endi
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_break
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_next
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_for
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_endf
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_repeat
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_until
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_while
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mri_endw
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_m68k_cpu
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_m68k_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|m68k_cpu
block|{
name|unsigned
name|long
name|arch
decl_stmt|;
comment|/* Architecture features.  */
specifier|const
name|enum
name|m68k_register
modifier|*
name|control_regs
decl_stmt|;
comment|/* Control regs on chip */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name */
name|int
name|alias
decl_stmt|;
comment|/* Alias for a cannonical name.  If 1, then 			   succeeds canonical name, if -1 then 			   succeeds canonical name, if<-1 ||>1 this is a 			   deprecated name, and the next/previous name 			   should be used. */
block|}
struct|;
end_struct

begin_comment
comment|/* We hold flags for features explicitly enabled and explicitly    disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|not_current_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|selected_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|selected_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Architecture models.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68k_cpu
name|m68k_archs
index|[]
init|=
block|{
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68000"
block|,
literal|0
block|}
block|,
block|{
name|m68010
block|,
name|m68010_ctrl
block|,
literal|"68010"
block|,
literal|0
block|}
block|,
block|{
name|m68020
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68020"
block|,
literal|0
block|}
block|,
block|{
name|m68030
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68030"
block|,
literal|0
block|}
block|,
block|{
name|m68040
block|,
name|m68040_ctrl
block|,
literal|"68040"
block|,
literal|0
block|}
block|,
block|{
name|m68060
block|,
name|m68060_ctrl
block|,
literal|"68060"
block|,
literal|0
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"cpu32"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
block|,
name|NULL
block|,
literal|"isaa"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfisa_aa
operator||
name|mcfusp
block|,
name|NULL
block|,
literal|"isaaplus"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfisa_b
operator||
name|mcfusp
block|,
name|NULL
block|,
literal|"isab"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfisa_b
operator||
name|mcfmac
operator||
name|mcfusp
block|,
name|mcf_ctrl
block|,
literal|"cfv4"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfisa_b
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"cfv4e"
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Architecture extensions, here 'alias' -1 for m68k, +1 for cf and 0    for either.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68k_cpu
name|m68k_extensions
index|[]
init|=
block|{
block|{
name|m68851
block|,
name|NULL
block|,
literal|"68851"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|m68881
block|,
name|NULL
block|,
literal|"68881"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|m68881
block|,
name|NULL
block|,
literal|"68882"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|cfloat
operator||
name|m68881
block|,
name|NULL
block|,
literal|"float"
block|,
literal|0
block|}
block|,
block|{
name|mcfhwdiv
block|,
name|NULL
block|,
literal|"div"
block|,
literal|1
block|}
block|,
block|{
name|mcfusp
block|,
name|NULL
block|,
literal|"usp"
block|,
literal|1
block|}
block|,
block|{
name|mcfmac
block|,
name|NULL
block|,
literal|"mac"
block|,
literal|1
block|}
block|,
block|{
name|mcfemac
block|,
name|NULL
block|,
literal|"emac"
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor list */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68k_cpu
name|m68k_cpus
index|[]
init|=
block|{
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68000"
block|,
literal|0
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68ec000"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68hc000"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68hc001"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68008"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68302"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68306"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68307"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68322"
block|,
literal|1
block|}
block|,
block|{
name|m68000
block|,
name|m68000_ctrl
block|,
literal|"68356"
block|,
literal|1
block|}
block|,
block|{
name|m68010
block|,
name|m68010_ctrl
block|,
literal|"68010"
block|,
literal|0
block|}
block|,
block|{
name|m68020
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68020"
block|,
literal|0
block|}
block|,
block|{
name|m68020
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68k"
block|,
literal|1
block|}
block|,
block|{
name|m68020
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68ec020"
block|,
literal|1
block|}
block|,
block|{
name|m68030
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68030"
block|,
literal|0
block|}
block|,
block|{
name|m68030
operator||
name|m68881
operator||
name|m68851
block|,
name|m68020_ctrl
block|,
literal|"68ec030"
block|,
literal|1
block|}
block|,
block|{
name|m68040
block|,
name|m68040_ctrl
block|,
literal|"68040"
block|,
literal|0
block|}
block|,
block|{
name|m68040
block|,
name|m68040_ctrl
block|,
literal|"68ec040"
block|,
literal|1
block|}
block|,
block|{
name|m68060
block|,
name|m68060_ctrl
block|,
literal|"68060"
block|,
literal|0
block|}
block|,
block|{
name|m68060
block|,
name|m68060_ctrl
block|,
literal|"68ec060"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"cpu32"
block|,
literal|0
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68330"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68331"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68332"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68333"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68334"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68336"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68340"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68341"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68349"
block|,
literal|1
block|}
block|,
block|{
name|cpu32
operator||
name|m68881
block|,
name|cpu32_ctrl
block|,
literal|"68360"
block|,
literal|1
block|}
block|,
block|{
name|mcfisa_a
block|,
name|mcf_ctrl
block|,
literal|"5200"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
block|,
name|mcf_ctrl
block|,
literal|"5202"
block|,
literal|1
block|}
block|,
block|{
name|mcfisa_a
block|,
name|mcf_ctrl
block|,
literal|"5204"
block|,
literal|1
block|}
block|,
block|{
name|mcfisa_a
block|,
name|mcf_ctrl
block|,
literal|"5206"
block|,
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfmac
block|,
name|mcf_ctrl
block|,
literal|"5206e"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5208_ctrl
block|,
literal|"5207"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5208_ctrl
block|,
literal|"5208"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfmac
operator||
name|mcfusp
block|,
name|mcf5213_ctrl
block|,
literal|"5211"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfmac
operator||
name|mcfusp
block|,
name|mcf5213_ctrl
block|,
literal|"5212"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfmac
operator||
name|mcfusp
block|,
name|mcf5213_ctrl
block|,
literal|"5213"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5216_ctrl
block|,
literal|"5214"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5216_ctrl
block|,
literal|"5216"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5216_ctrl
block|,
literal|"521x"
block|,
literal|2
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5235_ctrl
block|,
literal|"5232"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5235_ctrl
block|,
literal|"5233"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5235_ctrl
block|,
literal|"5234"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5235_ctrl
block|,
literal|"5235"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5235_ctrl
block|,
literal|"523x"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfemac
block|,
name|mcf5249_ctrl
block|,
literal|"5249"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfemac
block|,
name|mcf5250_ctrl
block|,
literal|"5250"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5271_ctrl
block|,
literal|"5270"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5271_ctrl
block|,
literal|"5271"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfmac
block|,
name|mcf5272_ctrl
block|,
literal|"5272"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5275_ctrl
block|,
literal|"5274"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5275_ctrl
block|,
literal|"5275"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5282_ctrl
block|,
literal|"5280"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5282_ctrl
block|,
literal|"5281"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5282_ctrl
block|,
literal|"5282"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5282_ctrl
block|,
literal|"528x"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfhwdiv
operator||
name|mcfmac
block|,
name|mcf_ctrl
block|,
literal|"5307"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5329_ctrl
block|,
literal|"5327"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5329_ctrl
block|,
literal|"5328"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5329_ctrl
block|,
literal|"5329"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5329_ctrl
block|,
literal|"532x"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5373_ctrl
block|,
literal|"5372"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5373_ctrl
block|,
literal|"5373"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
block|,
name|mcf5373_ctrl
block|,
literal|"537x"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfmac
block|,
name|mcf_ctrl
block|,
literal|"5407"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5470"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5471"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5472"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5473"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5474"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5475"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"547x"
block|,
literal|0
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5480"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5481"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5482"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5483"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5484"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"5485"
block|,
operator|-
literal|1
block|}
block|,
block|{
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfemac
operator||
name|mcfusp
operator||
name|cfloat
block|,
name|mcfv4e_ctrl
block|,
literal|"548x"
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|m68k_lookup_cpu
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|m68k_cpu
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|m68k_set_arch
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|m68k_set_cpu
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|m68k_set_extension
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m68k_init_arch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is the assembler relaxation table for m68k. m68k is a rich CISC    architecture and we have a lot of relaxation modes.  */
end_comment

begin_comment
comment|/* Macros used in the relaxation code.  */
end_comment

begin_define
define|#
directive|define
name|TAB
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<< 2) + (y))
end_define

begin_define
define|#
directive|define
name|TABTYPE
parameter_list|(
name|x
parameter_list|)
value|((x)>> 2)
end_define

begin_comment
comment|/* Relaxation states.  */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|SHORT
value|1
end_define

begin_define
define|#
directive|define
name|LONG
value|2
end_define

begin_define
define|#
directive|define
name|SZ_UNDEF
value|3
end_define

begin_comment
comment|/* Here are all the relaxation modes we support.  First we can relax ordinary    branches.  On 68020 and higher and on CPU32 all branch instructions take    three forms, so on these CPUs all branches always remain as such.  When we    have to expand to the LONG form on a 68000, though, we substitute an    absolute jump instead.  This is a direct replacement for unconditional    branches and a branch over a jump for conditional branches.  However, if the    user requires PIC and disables this with --pcrel, we can only relax between    BYTE and SHORT forms, punting if that isn't enough.  This gives us four    different relaxation modes for branches:  */
end_comment

begin_define
define|#
directive|define
name|BRANCHBWL
value|0
end_define

begin_comment
comment|/* Branch byte, word, or long.  */
end_comment

begin_define
define|#
directive|define
name|BRABSJUNC
value|1
end_define

begin_comment
comment|/* Absolute jump for LONG, unconditional.  */
end_comment

begin_define
define|#
directive|define
name|BRABSJCOND
value|2
end_define

begin_comment
comment|/* Absolute jump for LONG, conditional.  */
end_comment

begin_define
define|#
directive|define
name|BRANCHBW
value|3
end_define

begin_comment
comment|/* Branch byte or word.  */
end_comment

begin_comment
comment|/* We also relax coprocessor branches and DBcc's.  All CPUs that support    coprocessor branches support them in word and long forms, so we have only    one relaxation mode for them.  DBcc's are word only on all CPUs.  We can    relax them to the LONG form with a branch-around sequence.  This sequence    can use a long branch (if available) or an absolute jump (if acceptable).    This gives us two relaxation modes.  If long branches are not available and    absolute jumps are not acceptable, we don't relax DBcc's.  */
end_comment

begin_define
define|#
directive|define
name|FBRANCH
value|4
end_define

begin_comment
comment|/* Coprocessor branch.  */
end_comment

begin_define
define|#
directive|define
name|DBCCLBR
value|5
end_define

begin_comment
comment|/* DBcc relaxable with a long branch.  */
end_comment

begin_define
define|#
directive|define
name|DBCCABSJ
value|6
end_define

begin_comment
comment|/* DBcc relaxable with an absolute jump.  */
end_comment

begin_comment
comment|/* That's all for instruction relaxation.  However, we also relax PC-relative    operands.  Specifically, we have three operand relaxation modes.  On the    68000 PC-relative operands can only be 16-bit, but on 68020 and higher and    on CPU32 they may be 16-bit or 32-bit.  For the latter we relax between the    two.  Also PC+displacement+index operands in their simple form (with a non-    suppressed index without memory indirection) are supported on all CPUs, but    on the 68000 the displacement can be 8-bit only, whereas on 68020 and higher    and on CPU32 we relax it to SHORT and LONG forms as well using the extended    form of the PC+displacement+index operand.  Finally, some absolute operands    can be relaxed down to 16-bit PC-relative.  */
end_comment

begin_define
define|#
directive|define
name|PCREL1632
value|7
end_define

begin_comment
comment|/* 16-bit or 32-bit PC-relative.  */
end_comment

begin_define
define|#
directive|define
name|PCINDEX
value|8
end_define

begin_comment
comment|/* PC + displacement + index. */
end_comment

begin_define
define|#
directive|define
name|ABSTOPCREL
value|9
end_define

begin_comment
comment|/* Absolute relax down to 16-bit PC-relative.  */
end_comment

begin_comment
comment|/* Note that calls to frag_var need to specify the maximum expansion    needed; this is currently 10 bytes for DBCC.  */
end_comment

begin_comment
comment|/* The fields are:    How far Forward this mode will reach:    How far Backward this mode will reach:    How many bytes this mode will add to the size of the frag    Which mode to go to if the offset won't fit in this one     Please check tc-m68k.h:md_prepare_relax_scan if changing this table.  */
end_comment

begin_decl_stmt
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BRANCHBWL
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|BRANCHBWL
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BRABSJUNC
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|BRABSJUNC
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BRABSJCOND
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|BRABSJCOND
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BRANCHBW
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FBRANCH doesn't come BYTE.  */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|FBRANCH
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBCC doesn't come BYTE.  */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|DBCCLBR
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBCC doesn't come BYTE.  */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|DBCCABSJ
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PCREL1632 doesn't come BYTE.  */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|PCREL1632
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|125
block|,
operator|-
literal|130
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|PCINDEX
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
literal|32765
block|,
operator|-
literal|32770
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|PCINDEX
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ABSTOPCREL doesn't come BYTE.  */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|ABSTOPCREL
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the machine dependent pseudo-ops.  These are included so    the assembler can work on the output from the SUN C compiler, which    generates these.  */
end_comment

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"data1"
block|,
name|s_data1
block|,
literal|0
block|}
block|,
block|{
literal|"data2"
block|,
name|s_data2
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|s_even
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"proc"
block|,
name|s_proc
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|TE_SUN3
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"swbeg"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"extend"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"arch"
block|,
name|s_m68k_arch
block|,
literal|0
block|}
block|,
block|{
literal|"cpu"
block|,
name|s_m68k_cpu
block|,
literal|0
block|}
block|,
comment|/* The following pseudo-ops are supported for MRI compatibility.  */
block|{
literal|"chip"
block|,
name|s_chip
block|,
literal|0
block|}
block|,
block|{
literal|"comline"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"fopt"
block|,
name|s_fopt
block|,
literal|0
block|}
block|,
block|{
literal|"mask2"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"opt"
block|,
name|s_opt
block|,
literal|0
block|}
block|,
block|{
literal|"reg"
block|,
name|s_reg
block|,
literal|0
block|}
block|,
block|{
literal|"restore"
block|,
name|s_restore
block|,
literal|0
block|}
block|,
block|{
literal|"save"
block|,
name|s_save
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|s_mri_if
block|,
literal|0
block|}
block|,
block|{
literal|"if.b"
block|,
name|s_mri_if
block|,
literal|'b'
block|}
block|,
block|{
literal|"if.w"
block|,
name|s_mri_if
block|,
literal|'w'
block|}
block|,
block|{
literal|"if.l"
block|,
name|s_mri_if
block|,
literal|'l'
block|}
block|,
block|{
literal|"else"
block|,
name|s_mri_else
block|,
literal|0
block|}
block|,
block|{
literal|"else.s"
block|,
name|s_mri_else
block|,
literal|'s'
block|}
block|,
block|{
literal|"else.l"
block|,
name|s_mri_else
block|,
literal|'l'
block|}
block|,
block|{
literal|"endi"
block|,
name|s_mri_endi
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|s_mri_break
block|,
literal|0
block|}
block|,
block|{
literal|"break.s"
block|,
name|s_mri_break
block|,
literal|'s'
block|}
block|,
block|{
literal|"break.l"
block|,
name|s_mri_break
block|,
literal|'l'
block|}
block|,
block|{
literal|"next"
block|,
name|s_mri_next
block|,
literal|0
block|}
block|,
block|{
literal|"next.s"
block|,
name|s_mri_next
block|,
literal|'s'
block|}
block|,
block|{
literal|"next.l"
block|,
name|s_mri_next
block|,
literal|'l'
block|}
block|,
block|{
literal|"for"
block|,
name|s_mri_for
block|,
literal|0
block|}
block|,
block|{
literal|"for.b"
block|,
name|s_mri_for
block|,
literal|'b'
block|}
block|,
block|{
literal|"for.w"
block|,
name|s_mri_for
block|,
literal|'w'
block|}
block|,
block|{
literal|"for.l"
block|,
name|s_mri_for
block|,
literal|'l'
block|}
block|,
block|{
literal|"endf"
block|,
name|s_mri_endf
block|,
literal|0
block|}
block|,
block|{
literal|"repeat"
block|,
name|s_mri_repeat
block|,
literal|0
block|}
block|,
block|{
literal|"until"
block|,
name|s_mri_until
block|,
literal|0
block|}
block|,
block|{
literal|"until.b"
block|,
name|s_mri_until
block|,
literal|'b'
block|}
block|,
block|{
literal|"until.w"
block|,
name|s_mri_until
block|,
literal|'w'
block|}
block|,
block|{
literal|"until.l"
block|,
name|s_mri_until
block|,
literal|'l'
block|}
block|,
block|{
literal|"while"
block|,
name|s_mri_while
block|,
literal|0
block|}
block|,
block|{
literal|"while.b"
block|,
name|s_mri_while
block|,
literal|'b'
block|}
block|,
block|{
literal|"while.w"
block|,
name|s_mri_while
block|,
literal|'w'
block|}
block|,
block|{
literal|"while.l"
block|,
name|s_mri_while
block|,
literal|'l'
block|}
block|,
block|{
literal|"endw"
block|,
name|s_mri_endw
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mote pseudo ops are put into the opcode table, since they    don't start with a . they look like opcodes to gas.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|mote_pseudo_table
index|[]
init|=
block|{
block|{
literal|"dcl"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"dc"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"dcw"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"dcb"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"dsl"
block|,
name|s_space
block|,
literal|4
block|}
block|,
block|{
literal|"ds"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dsw"
block|,
name|s_space
block|,
literal|2
block|}
block|,
block|{
literal|"dsb"
block|,
name|s_space
block|,
literal|1
block|}
block|,
block|{
literal|"xdef"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|M68KCOFF
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Truncate and sign-extend at 32 bits, so that building on a 64-bit host    gives identical results to a 32-bit host.  */
end_comment

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|X
parameter_list|)
value|((valueT) (X)& 0xffffffff)
end_define

begin_define
define|#
directive|define
name|SEXT
parameter_list|(
name|X
parameter_list|)
value|((TRUNC (X) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|issbyte
parameter_list|(
name|x
parameter_list|)
value|((valueT) SEXT (x) + 0x80< 0x100)
end_define

begin_define
define|#
directive|define
name|isubyte
parameter_list|(
name|x
parameter_list|)
value|((valueT) TRUNC (x)< 0x100)
end_define

begin_define
define|#
directive|define
name|issword
parameter_list|(
name|x
parameter_list|)
value|((valueT) SEXT (x) + 0x8000< 0x10000)
end_define

begin_define
define|#
directive|define
name|isuword
parameter_list|(
name|x
parameter_list|)
value|((valueT) TRUNC (x)< 0x10000)
end_define

begin_define
define|#
directive|define
name|isbyte
parameter_list|(
name|x
parameter_list|)
value|((valueT) SEXT (x) + 0xff< 0x1ff)
end_define

begin_define
define|#
directive|define
name|isword
parameter_list|(
name|x
parameter_list|)
value|((valueT) SEXT (x) + 0xffff< 0x1ffff)
end_define

begin_define
define|#
directive|define
name|islong
parameter_list|(
name|x
parameter_list|)
value|(1)
end_define

begin_decl_stmt
specifier|static
name|char
name|notend_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|alt_notend_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|notend
parameter_list|(
name|s
parameter_list|)
define|\
value|(! (notend_table[(unsigned char) *s]				\       || (*s == ':'						\&& alt_notend_table[(unsigned char) s[1]])))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Return zero if the reference to SYMBOL from within the same segment may    be relaxed.  */
end_comment

begin_comment
comment|/* On an ELF system, we can't relax an externally visible symbol,    because it may be overridden by a shared library.  However, if    TARGET_OS is "elf", then we presume that we are assembling for an    embedded system, in which case we don't have to worry about shared    libraries, and we can relax any external sym.  */
end_comment

begin_define
define|#
directive|define
name|relaxable_symbol
parameter_list|(
name|symbol
parameter_list|)
define|\
value|(!((S_IS_EXTERNAL (symbol)&& EXTERN_FORCE_RELOC) \      || S_IS_WEAK (symbol)))
end_define

begin_comment
comment|/* Compute the relocation code for a fixup of SIZE bytes, using pc    relative relocation if PCREL is non-zero.  PIC says whether a special    pic relocation was requested.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|get_reloc_code
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|enum
name|pic_relocation
name|pic
parameter_list|)
block|{
switch|switch
condition|(
name|pic
condition|)
block|{
case|case
name|pic_got_pcrel
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_GOT_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_GOT_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_GOT_PCREL
return|;
block|}
break|break;
case|case
name|pic_got_off
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_GOTOFF
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_GOTOFF
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_GOTOFF
return|;
block|}
break|break;
case|case
name|pic_plt_pcrel
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PLT_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PLT_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PLT_PCREL
return|;
block|}
break|break;
case|case
name|pic_plt_off
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PLTOFF
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PLTOFF
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PLTOFF
return|;
block|}
break|break;
case|case
name|pic_none
case|:
if|if
condition|(
name|pcrel
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16_PCREL
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32_PCREL
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_16
return|;
case|case
literal|4
case|:
return|return
name|BFD_RELOC_32
return|;
block|}
block|}
block|}
if|if
condition|(
name|pcrel
condition|)
block|{
if|if
condition|(
name|pic
operator|==
name|pic_none
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte pc-relative relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte pc-relative pic relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pic
operator|==
name|pic_none
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte pic relocation"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Here we decide which fixups can be adjusted to make them relative    to the beginning of the section instead of the symbol.  Basically    we need to make sure that the dynamic relocations are done    correctly, so in some cases we force the original symbol to be    used.  */
end_comment

begin_function
name|int
name|tc_m68k_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* Adjust_reloc_syms doesn't know about the GOT.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8_GOT_PCREL
case|:
case|case
name|BFD_RELOC_16_GOT_PCREL
case|:
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_8_GOTOFF
case|:
case|case
name|BFD_RELOC_16_GOTOFF
case|:
case|case
name|BFD_RELOC_32_GOTOFF
case|:
case|case
name|BFD_RELOC_8_PLT_PCREL
case|:
case|case
name|BFD_RELOC_16_PLT_PCREL
case|:
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
case|case
name|BFD_RELOC_8_PLTOFF
case|:
case|case
name|BFD_RELOC_16_PLTOFF
case|:
case|case
name|BFD_RELOC_32_PLTOFF
case|:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !OBJ_ELF */
end_comment

begin_define
define|#
directive|define
name|get_reloc_code
parameter_list|(
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|OTHER
parameter_list|)
value|NO_RELOC
end_define

begin_define
define|#
directive|define
name|relaxable_symbol
parameter_list|(
name|symbol
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
comment|/* If the tcbit is set, then this was a fixup of a negative value      that was never resolved.  We do not have a reloc to handle this,      so just return.  We assume that other code will have detected this      situation and produced a helpful error message, so we just tell the      user that the reloc cannot be produced.  */
if|if
condition|(
name|fixp
operator|->
name|fx_tcbit
condition|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unable to produce reloc against symbol '%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
comment|/* Since DIFF_EXPR_OK is defined in tc-m68k.h, it is possible          that fixup_segment converted a non-PC relative reloc into a          PC relative reloc.  In such a case, we need to convert the          reloc code.  */
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_8_GOT_PCREL
case|:
case|case
name|BFD_RELOC_16_GOT_PCREL
case|:
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_8_GOTOFF
case|:
case|case
name|BFD_RELOC_16_GOTOFF
case|:
case|case
name|BFD_RELOC_32_GOTOFF
case|:
case|case
name|BFD_RELOC_8_PLT_PCREL
case|:
case|case
name|BFD_RELOC_16_PLT_PCREL
case|:
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
case|case
name|BFD_RELOC_8_PLTOFF
case|:
case|case
name|BFD_RELOC_16_PLTOFF
case|:
case|case
name|BFD_RELOC_32_PLTOFF
case|:
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot make %s relocation PC relative"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
define|#
directive|define
name|F
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|)
value|(((SZ)<< 1) + (PCREL))
switch|switch
condition|(
name|F
argument_list|(
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|)
condition|)
block|{
define|#
directive|define
name|MAP
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|,
name|TYPE
parameter_list|)
value|case F(SZ,PCREL): code = (TYPE); break
name|MAP
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|F
undef|#
directive|undef
name|MAP
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
operator|(
name|section
operator|->
name|vma
comment|/* Explicit sign extension in case char is 			unsigned.  */
operator|+
operator|(
operator|(
name|fixp
operator|->
name|fx_pcrel_adjust
operator|&
literal|0xff
operator|)
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
operator|+
name|fixp
operator|->
name|fx_addnumber
operator|+
name|md_pcrel_from
argument_list|(
name|fixp
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reloc
operator|->
name|howto
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Handle of the OPCODE hash table.  NULL means any use before    m68k_ip_begin() will crash.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Assemble an m68k instruction.  */
end_comment

begin_function
specifier|static
name|void
name|m68k_ip
parameter_list|(
name|char
modifier|*
name|instring
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
specifier|register
specifier|const
name|struct
name|m68k_incant
modifier|*
name|opcode
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|tmpreg
init|=
literal|0
decl_stmt|,
name|baseo
init|=
literal|0
decl_stmt|,
name|outro
init|=
literal|0
decl_stmt|,
name|nextword
decl_stmt|;
name|char
modifier|*
name|pdot
decl_stmt|,
modifier|*
name|pdotmove
decl_stmt|;
name|enum
name|m68k_size
name|siz1
decl_stmt|,
name|siz2
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|losing
decl_stmt|;
name|int
name|opsfound
decl_stmt|;
name|struct
name|m68k_op
name|operands_backup
index|[
literal|6
index|]
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|6
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordp
decl_stmt|;
name|unsigned
name|long
name|ok_arch
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
name|instring
operator|++
expr_stmt|;
comment|/* Skip leading whitespace.  */
comment|/* Scan up to end of operation-code, which MUST end in end-of-string      or exactly 1 space.  */
name|pdot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|instring
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|pdot
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|instring
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"No operator"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* p now points to the end of the opcode name, probably whitespace.      Make sure the name is null terminated by clobbering the      whitespace, look it up in the hash table, then fix it back.      Remove a dot, first, since the opcode tables have none.  */
if|if
condition|(
name|pdot
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|pdotmove
operator|=
name|pdot
init|;
name|pdotmove
operator|<
name|p
condition|;
name|pdotmove
operator|++
control|)
operator|*
name|pdotmove
operator|=
name|pdotmove
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|m68k_incant
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|instring
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|pdot
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|pdotmove
operator|=
name|p
init|;
name|pdotmove
operator|>
name|pdot
condition|;
name|pdotmove
operator|--
control|)
operator|*
name|pdotmove
operator|=
name|pdotmove
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|pdot
operator|=
literal|'.'
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Unknown operator"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Found a legitimate opcode, start matching operands.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|m_operands
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|input_line_pointer
decl_stmt|;
operator|*
name|old
operator|=
literal|'\n'
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
comment|/* Ahh - it's a motorola style psuedo op.  */
name|mote_pseudo_table
index|[
name|opcode
operator|->
name|m_opnum
index|]
operator|.
name|poc_handler
argument_list|(
name|mote_pseudo_table
index|[
name|opcode
operator|->
name|m_opnum
index|]
operator|.
name|poc_val
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|old
expr_stmt|;
operator|*
name|old
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flag_mri
operator|&&
name|opcode
operator|->
name|m_opnum
operator|==
literal|0
condition|)
block|{
comment|/* In MRI mode, random garbage is allowed after an instruction          which accepts no operands.  */
name|the_ins
operator|.
name|args
operator|=
name|opcode
operator|->
name|m_operands
expr_stmt|;
name|the_ins
operator|.
name|numargs
operator|=
name|opcode
operator|->
name|m_opnum
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|=
name|opcode
operator|->
name|m_codenum
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
name|getone
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator|=
name|gettwo
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|opP
operator|=
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
init|;
operator|*
name|p
condition|;
name|opP
operator|++
control|)
block|{
name|p
operator|=
name|crack_operand
argument_list|(
name|p
argument_list|,
name|opP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|error
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
name|opP
operator|->
name|error
expr_stmt|;
return|return;
block|}
block|}
name|opsfound
operator|=
name|opP
operator|-
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
comment|/* This ugly hack is to support the floating pt opcodes in their      standard form.  Essentially, we fake a first enty of type COP#1 */
if|if
condition|(
name|opcode
operator|->
name|m_operands
index|[
literal|0
index|]
operator|==
literal|'I'
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|opsfound
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|=
name|the_ins
operator|.
name|operands
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|CONTROL
expr_stmt|;
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|m68k_float_copnum
expr_stmt|;
name|opsfound
operator|++
expr_stmt|;
block|}
comment|/* We've got the operands.  Find an opcode that'll accept them.  */
for|for
control|(
name|losing
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* If we didn't get the right number of ops, or we have no 	 common model with this pattern then reject this pattern.  */
name|ok_arch
operator||=
name|opcode
operator|->
name|m_arch
expr_stmt|;
if|if
condition|(
name|opsfound
operator|!=
name|opcode
operator|->
name|m_opnum
operator|||
operator|(
operator|(
name|opcode
operator|->
name|m_arch
operator|&
name|current_architecture
operator|)
operator|==
literal|0
operator|)
condition|)
operator|++
name|losing
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Make a copy of the operands of this insn so that 	     we can modify them safely, should we want to.  */
name|assert
argument_list|(
name|opsfound
operator|<=
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|operands_backup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opsfound
condition|;
name|i
operator|++
control|)
name|operands_backup
index|[
name|i
index|]
operator|=
name|the_ins
operator|.
name|operands
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|m_operands
operator|,
name|opP
operator|=
operator|&
name|operands_backup
index|[
literal|0
index|]
init|;
operator|*
name|s
operator|&&
operator|!
name|losing
condition|;
name|s
operator|+=
literal|2
operator|,
name|opP
operator|++
control|)
block|{
comment|/* Warning: this switch is huge! */
comment|/* I've tried to organize the cases into this order: 		 non-alpha first, then alpha by letter.  Lower-case 		 goes directly before uppercase counterpart.  */
comment|/* Code with multiple case ...: gets sorted by the lowest 		 case ... it belongs to.  I hope this makes sense.  */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'!'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|IMMED
case|:
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|IMMED
case|:
case|case
name|ADEC
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|IMMED
case|:
case|case
name|AINC
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
break|break;
default|default:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'m'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|AINDR
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DISP
case|:
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|BASE
case|:
case|case
name|ABSL
case|:
case|case
name|IMMED
case|:
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|AINDR
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
break|break;
case|case
name|DISP
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AINDR
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
break|break;
case|case
name|DISP
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'v'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AINDR
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
case|case
name|ABSL
case|:
break|break;
case|case
name|DISP
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|isbyte
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'B'
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|issbyte
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|isword
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'W'
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|issword
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
case|case
literal|'T'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|CONTROL
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
operator|||
operator|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
operator|&&
operator|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|CONTROL
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
operator|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
operator|&&
operator|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|IMMED
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
break|break;
default|default:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|CONTROL
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ADEC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|AREG
case|:
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
case|case
name|IMMED
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|';'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|AREG
case|:
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'?'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|AREG
case|:
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
case|case
name|AINC
case|:
case|case
name|ADEC
case|:
case|case
name|IMMED
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
break|break;
default|default:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'@'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|AREG
case|:
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
case|case
name|IMMED
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'~'
case|:
comment|/* For now! (JF FOO is this right?) */
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
case|case
name|AREG
case|:
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
case|case
name|IMMED
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
break|break;
default|default:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'3'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|TT0
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|TT1
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINDR
condition|)
operator|++
name|losing
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINDR
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|AINC
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|ADEC
operator|&&
operator|(
name|opP
operator|->
name|mode
operator|!=
name|DISP
operator|||
name|opP
operator|->
name|reg
operator|<
name|ADDR0
operator|||
name|opP
operator|->
name|reg
operator|>
name|ADDR7
operator|)
condition|)
operator|++
name|losing
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* FOO */
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
operator|||
operator|(
name|flag_long_jumps
operator|&&
name|strncmp
argument_list|(
name|instring
argument_list|,
literal|"jbsr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|IMMED
case|:
case|case
name|ABSL
case|:
case|case
name|AREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|POST
case|:
case|case
name|PRE
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|CCR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DISP
operator|||
name|opP
operator|->
name|reg
operator|<
name|ADDR0
operator|||
name|opP
operator|->
name|reg
operator|>
name|ADDR7
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|ACC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|ACC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ACC1
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ACC2
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ACC3
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|FPREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|MACSR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|ACCEXT01
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ACCEXT23
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|MASK
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|<
name|COP0
operator|||
name|opP
operator|->
name|reg
operator|>
name|COP7
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|LSH
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|RSH
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|<
name|USP
operator|||
name|opP
operator|->
name|reg
operator|>
name|last_movec_reg
operator|||
operator|!
name|control_regs
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
specifier|const
name|enum
name|m68k_register
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|control_regs
init|;
operator|*
name|rp
condition|;
name|rp
operator|++
control|)
if|if
condition|(
operator|*
name|rp
operator|==
name|opP
operator|->
name|reg
condition|)
break|break;
if|if
condition|(
operator|*
name|rp
operator|==
literal|0
condition|)
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|DREG
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
operator|(
name|opP
operator|->
name|reg
operator|-
name|DATA0
operator|)
expr_stmt|;
break|break;
case|case
name|AREG
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
operator|(
name|opP
operator|->
name|reg
operator|-
name|ADDR0
operator|+
literal|8
operator|)
expr_stmt|;
break|break;
case|case
name|FPREG
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
operator|(
name|opP
operator|->
name|reg
operator|-
name|FP0
operator|+
literal|16
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|opP
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|CONTROL
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'8'
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|FPI
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
name|FPS
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
break|break;
case|case
name|FPC
case|:
name|opP
operator|->
name|mask
operator|=
literal|1
operator|<<
literal|26
expr_stmt|;
break|break;
default|default:
name|losing
operator|++
expr_stmt|;
break|break;
block|}
name|opP
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
operator|&&
operator|(
name|opP
operator|->
name|mask
operator|&
literal|0x0ffffff
operator|)
operator|!=
literal|0
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'3'
operator|&&
operator|(
name|opP
operator|->
name|mask
operator|&
literal|0x7000000
operator|)
operator|!=
literal|0
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|!
name|issbyte
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m68k_quick
operator|&&
name|instring
index|[
literal|3
index|]
operator|!=
literal|'q'
operator|&&
name|instring
index|[
literal|4
index|]
operator|!=
literal|'q'
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|IMMED
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|ABSL
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|TRUNC
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|-
literal|1
operator|>
literal|7
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m68k_quick
operator|&&
operator|(
name|strncmp
argument_list|(
name|instring
argument_list|,
literal|"add"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|instring
argument_list|,
literal|"sub"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|instring
index|[
literal|3
index|]
operator|!=
literal|'q'
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|AREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINDR
operator|&&
operator|(
name|opP
operator|->
name|mode
operator|!=
name|BASE
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
literal|0
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ZADDR0
operator|)
operator|||
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_absent
operator|||
operator|(
operator|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|<
name|DATA0
operator|||
name|opP
operator|->
name|index
operator|.
name|reg
operator|>
name|DATA7
operator|)
operator|&&
operator|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|<
name|ADDR0
operator|||
name|opP
operator|->
name|index
operator|.
name|reg
operator|>
name|ADDR7
operator|)
operator|)
operator|||
name|opP
operator|->
name|index
operator|.
name|size
operator|!=
name|SIZE_UNSPEC
operator|||
name|opP
operator|->
name|index
operator|.
name|scale
operator|!=
literal|1
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|!
operator|(
name|opP
operator|->
name|reg
operator|==
name|FPI
operator|||
name|opP
operator|->
name|reg
operator|==
name|FPS
operator|||
name|opP
operator|->
name|reg
operator|==
name|FPC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|SR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|TRUNC
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|>
literal|7
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|USP
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|TRUNC
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|!=
literal|0xffffffff
operator|&&
name|TRUNC
argument_list|(
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|-
literal|1
operator|>
literal|6
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
comment|/* JF these are out of order.  We could put them 		     in order if we were willing to put up with 		     bunches of #ifdef m68851s in the code.  		     Don't forget that you need these operands 		     to use 68030 MMU instructions.  */
ifndef|#
directive|ifndef
name|NO_68851
comment|/* Memory addressing mode used by pflushr.  */
case|case
literal|'|'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|CONTROL
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
comment|/* We should accept immediate operands, but they                      supposedly have to be quad word, and we don't                      handle that.  I would like to see what a Motorola                      assembler does before doing something here.  */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|SFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DFC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|TC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|AC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|CAL
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|VAL
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SCC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|VAL
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|DRP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SRP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|CRP
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|IMMED
case|:
case|case
name|ABSL
case|:
case|case
name|AREG
case|:
case|case
name|DREG
case|:
case|case
name|FPREG
case|:
case|case
name|CONTROL
case|:
case|case
name|POST
case|:
case|case
name|PRE
case|:
case|case
name|REGLST
case|:
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
operator|!
operator|(
name|opP
operator|->
name|reg
operator|>=
name|BAD
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|BAD
operator|+
literal|7
operator|)
operator|&&
operator|!
operator|(
name|opP
operator|->
name|reg
operator|>=
name|BAC
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|BAC
operator|+
literal|7
operator|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|PSR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
name|opP
operator|->
name|reg
operator|!=
name|PCSR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|CONTROL
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|NC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|IC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|BC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
condition|)
operator|++
name|losing
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|<
name|DATA0L
operator|||
name|opP
operator|->
name|reg
operator|>
name|ADDR7U
condition|)
name|losing
operator|++
expr_stmt|;
comment|/* FIXME: kludge instead of fixing parser:                      upper/lower registers are *not* CONTROL                      registers, but ordinary ones.  */
if|if
condition|(
operator|(
name|opP
operator|->
name|reg
operator|>=
name|DATA0L
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|DATA7L
operator|)
operator|||
operator|(
name|opP
operator|->
name|reg
operator|>=
name|DATA0U
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|DATA7U
operator|)
condition|)
name|opP
operator|->
name|mode
operator|=
name|DREG
expr_stmt|;
else|else
name|opP
operator|->
name|mode
operator|=
name|AREG
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
operator|!
operator|(
name|opP
operator|->
name|mode
operator|==
name|AINDR
operator|||
operator|(
name|opP
operator|->
name|mode
operator|==
name|DISP
operator|&&
operator|!
operator|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|)
operator|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
operator|!
operator|(
name|opP
operator|->
name|mode
operator|==
name|AINDR
operator|||
name|opP
operator|->
name|mode
operator|==
name|DISP
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|losing
condition|)
break|break;
block|}
comment|/* Since we have found the correct instruction, copy 	     in the modifications that we may have made.  */
if|if
condition|(
operator|!
name|losing
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opsfound
condition|;
name|i
operator|++
control|)
name|the_ins
operator|.
name|operands
index|[
name|i
index|]
operator|=
name|operands_backup
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|losing
condition|)
break|break;
name|opcode
operator|=
name|opcode
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|!
name|opcode
condition|)
block|{
if|if
condition|(
name|ok_arch
operator|&&
operator|!
operator|(
name|ok_arch
operator|&
name|current_architecture
operator|)
condition|)
block|{
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|cpu
decl_stmt|;
name|int
name|any
init|=
literal|0
decl_stmt|;
name|size_t
name|space
init|=
literal|400
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|space
operator|+
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|paren
init|=
literal|1
decl_stmt|;
name|the_ins
operator|.
name|error
operator|=
name|buf
expr_stmt|;
comment|/* Make sure there's a NUL at the end of the buffer -- strncpy 		 won't write one when it runs out of buffer */
name|buf
index|[
name|space
index|]
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|APPEND
parameter_list|(
name|STRING
parameter_list|)
define|\
value|(strncpy (buf, STRING, space), len = strlen (buf), buf += len, space -= len)
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"invalid instruction for this architecture; needs "
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ok_arch
condition|)
block|{
case|case
name|mcfisa_a
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"ColdFire ISA_A"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcfhwdiv
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"ColdFire hardware divide"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcfisa_aa
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"ColdFire ISA_A+"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcfisa_b
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"ColdFire ISA_B"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cfloat
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"ColdFire fpu"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|mfloat
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"M68K fpu"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|mmmu
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"M68K mmu"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|m68020up
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"68020 or higher"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|m68000up
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"68000 or higher"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|m68010up
case|:
name|APPEND
argument_list|(
name|_
argument_list|(
literal|"68010 or higher"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|paren
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|paren
condition|)
name|APPEND
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
name|m68k_cpus
init|;
name|cpu
operator|->
name|name
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
operator|!
name|cpu
operator|->
name|alias
operator|&&
operator|(
name|cpu
operator|->
name|arch
operator|&
name|ok_arch
operator|)
condition|)
block|{
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|alias
decl_stmt|;
if|if
condition|(
name|any
condition|)
name|APPEND
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|any
operator|=
literal|0
expr_stmt|;
name|APPEND
argument_list|(
name|cpu
operator|->
name|name
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|!=
name|m68k_cpus
condition|)
for|for
control|(
name|alias
operator|=
name|cpu
operator|-
literal|1
init|;
name|alias
operator|->
name|alias
condition|;
name|alias
operator|--
control|)
block|{
if|if
condition|(
name|any
condition|)
name|APPEND
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|alias
operator|=
name|cpu
operator|+
literal|1
init|;
name|alias
operator|->
name|alias
condition|;
name|alias
operator|++
control|)
block|{
if|if
condition|(
name|any
condition|)
name|APPEND
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
block|}
name|APPEND
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|paren
condition|)
name|APPEND
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|APPEND
if|if
condition|(
operator|!
name|space
condition|)
block|{
comment|/* we ran out of space, so replace the end of the list 		     with ellipsis.  */
name|buf
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
operator|*
name|buf
operator|!=
literal|' '
condition|)
name|buf
operator|--
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|the_ins
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"operands mismatch"
argument_list|)
expr_stmt|;
return|return;
block|}
name|losing
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now assemble it.  */
name|the_ins
operator|.
name|args
operator|=
name|opcode
operator|->
name|m_operands
expr_stmt|;
name|the_ins
operator|.
name|numargs
operator|=
name|opcode
operator|->
name|m_opnum
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|=
name|opcode
operator|->
name|m_codenum
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
name|getone
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator|=
name|gettwo
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|the_ins
operator|.
name|args
operator|,
name|opP
operator|=
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|+=
literal|2
operator|,
name|opP
operator|++
control|)
block|{
comment|/* This switch is a doozy. 	 Watch the first step; its a big one! */
switch|switch
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'~'
case|:
case|case
literal|'%'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|'!'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'b'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'4'
case|:
ifndef|#
directive|ifndef
name|NO_68851
case|case
literal|'|'
case|:
endif|#
directive|endif
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
case|case
name|IMMED
case|:
name|tmpreg
operator|=
literal|0x3c
expr_stmt|;
comment|/* 7.4 */
if|if
condition|(
name|strchr
argument_list|(
literal|"bwl"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|nextword
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
else|else
name|nextword
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|add_fix
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|nextword
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"operand out of range"
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|nextword
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"operand out of range"
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|issword
argument_list|(
name|nextword
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"operand out of range"
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|baseo
operator|=
literal|2
expr_stmt|;
name|outro
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|baseo
operator|=
literal|4
expr_stmt|;
name|outro
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|baseo
operator|=
literal|6
expr_stmt|;
name|outro
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|baseo
operator|=
literal|6
expr_stmt|;
name|outro
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|baseo
condition|)
break|break;
comment|/* We gotta put out some float.  */
if|if
condition|(
name|op
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|!=
name|O_big
condition|)
block|{
name|valueT
name|val
decl_stmt|;
name|int
name|gencnt
decl_stmt|;
comment|/* Can other cases happen here?  */
if|if
condition|(
name|op
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|!=
name|O_constant
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
operator|(
name|valueT
operator|)
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
expr_stmt|;
name|gencnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|generic_bignum
index|[
name|gencnt
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
name|val
expr_stmt|;
name|val
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
operator|++
name|gencnt
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|!=
literal|0
condition|)
do|;
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|=
name|gencnt
expr_stmt|;
block|}
if|if
condition|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|>
name|baseo
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bignum too big for %c format; truncated"
argument_list|)
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|=
name|baseo
expr_stmt|;
block|}
name|baseo
operator|-=
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
expr_stmt|;
while|while
condition|(
name|baseo
operator|--
condition|)
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|wordp
operator|=
name|generic_bignum
operator|+
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|-
literal|1
init|;
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|--
condition|;
operator|--
name|wordp
control|)
name|addword
argument_list|(
operator|*
name|wordp
argument_list|)
expr_stmt|;
break|break;
block|}
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|baseo
argument_list|,
operator|(
name|long
operator|)
name|outro
argument_list|)
expr_stmt|;
for|for
control|(
name|wordp
operator|=
name|words
init|;
name|baseo
operator|--
condition|;
name|wordp
operator|++
control|)
name|addword
argument_list|(
operator|*
name|wordp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DREG
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|reg
operator|-
name|DATA
expr_stmt|;
comment|/* 0.dreg */
break|break;
case|case
name|AREG
case|:
name|tmpreg
operator|=
literal|0x08
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 1.areg */
break|break;
case|case
name|AINDR
case|:
name|tmpreg
operator|=
literal|0x10
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 2.areg */
break|break;
case|case
name|ADEC
case|:
name|tmpreg
operator|=
literal|0x20
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 4.areg */
break|break;
case|case
name|AINC
case|:
name|tmpreg
operator|=
literal|0x18
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 3.areg */
break|break;
case|case
name|DISP
case|:
name|nextword
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
comment|/* Convert mode 5 addressing with a zero offset into 		 mode 2 addressing to reduce the instruction size by a 		 word.  */
if|if
condition|(
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
name|nextword
operator|==
literal|0
operator|)
operator|&&
operator|(
name|opP
operator|->
name|disp
operator|.
name|size
operator|==
name|SIZE_UNSPEC
operator|)
operator|&&
operator|(
name|opP
operator|->
name|reg
operator|>=
name|ADDR0
operator|)
operator|&&
operator|(
name|opP
operator|->
name|reg
operator|<=
name|ADDR7
operator|)
condition|)
block|{
name|tmpreg
operator|=
literal|0x10
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 2.areg */
break|break;
block|}
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|m68k_abspcadd
condition|)
block|{
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|opP
operator|->
name|disp
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
block|}
comment|/* Force into index mode.  Hope this works.  */
comment|/* We do the first bit for 32-bit displacements, and the 		 second bit for 16 bit ones.  It is possible that we 		 should make the default be WORD instead of LONG, but 		 I think that'd break GCC, so we put up with a little 		 inefficiency for the sake of working output.  */
if|if
condition|(
operator|!
name|issword
argument_list|(
name|nextword
argument_list|)
operator|||
operator|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|(
operator|(
name|opP
operator|->
name|disp
operator|.
name|size
operator|==
name|SIZE_UNSPEC
operator|&&
name|flag_short_refs
operator|==
literal|0
operator|&&
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|>=
name|m68020
operator|&&
operator|!
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
operator|)
operator|||
name|opP
operator|->
name|disp
operator|.
name|size
operator|==
name|SIZE_LONG
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|||
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"displacement too large for this architecture; needs 68020 or higher"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
name|tmpreg
operator|=
literal|0x3B
expr_stmt|;
comment|/* 7.3 */
else|else
name|tmpreg
operator|=
literal|0x30
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 6.areg */
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|size
operator|==
name|SIZE_LONG
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If the displacement needs pic 				 relocation it cannot be relaxed.  */
operator|||
name|opP
operator|->
name|disp
operator|.
name|pic_reloc
operator|!=
name|pic_none
endif|#
directive|endif
condition|)
block|{
name|addword
argument_list|(
literal|0x0170
argument_list|)
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|PCREL1632
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|addword
argument_list|(
literal|0x0170
argument_list|)
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|addword
argument_list|(
literal|0x0170
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
name|tmpreg
operator|=
literal|0x3A
expr_stmt|;
comment|/* 7.2 */
else|else
name|tmpreg
operator|=
literal|0x28
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 5.areg */
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
block|{
name|add_fix
argument_list|(
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|add_fix
argument_list|(
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST
case|:
case|case
name|PRE
case|:
case|case
name|BASE
case|:
name|nextword
operator|=
literal|0
expr_stmt|;
name|baseo
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|POST
operator|||
name|opP
operator|->
name|mode
operator|==
name|PRE
condition|)
name|outro
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|odisp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
comment|/* Figure out the `addressing mode'. 		 Also turn on the BASE_DISABLE bit, if needed.  */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
block|{
name|tmpreg
operator|=
literal|0x3b
expr_stmt|;
comment|/* 7.3 */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|nextword
operator||=
literal|0x80
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
literal|0
condition|)
block|{
name|nextword
operator||=
literal|0x80
expr_stmt|;
name|tmpreg
operator|=
literal|0x30
expr_stmt|;
comment|/* 6.garbage */
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|>=
name|ZADDR0
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|ZADDR7
condition|)
block|{
name|nextword
operator||=
literal|0x80
expr_stmt|;
name|tmpreg
operator|=
literal|0x30
operator|+
name|opP
operator|->
name|reg
operator|-
name|ZADDR0
expr_stmt|;
block|}
else|else
name|tmpreg
operator|=
literal|0x30
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 6.areg */
name|siz1
operator|=
name|opP
operator|->
name|disp
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|POST
operator|||
name|opP
operator|->
name|mode
operator|==
name|PRE
condition|)
name|siz2
operator|=
name|opP
operator|->
name|odisp
operator|.
name|size
expr_stmt|;
else|else
name|siz2
operator|=
name|SIZE_UNSPEC
expr_stmt|;
comment|/* Index register stuff.  */
if|if
condition|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|!=
literal|0
operator|&&
name|opP
operator|->
name|index
operator|.
name|reg
operator|>=
name|DATA
operator|&&
name|opP
operator|->
name|index
operator|.
name|reg
operator|<=
name|ADDR7
condition|)
block|{
name|nextword
operator||=
operator|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|-
name|DATA
operator|)
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|index
operator|.
name|size
operator|==
name|SIZE_LONG
operator|||
operator|(
name|opP
operator|->
name|index
operator|.
name|size
operator|==
name|SIZE_UNSPEC
operator|&&
name|m68k_index_width_default
operator|==
name|SIZE_LONG
operator|)
condition|)
name|nextword
operator||=
literal|0x800
expr_stmt|;
if|if
condition|(
operator|(
name|opP
operator|->
name|index
operator|.
name|scale
operator|!=
literal|1
operator|&&
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|)
operator|||
operator|(
name|opP
operator|->
name|index
operator|.
name|scale
operator|==
literal|8
operator|&&
operator|(
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
operator|&&
operator|!
name|arch_coldfire_fpu
argument_list|(
name|current_architecture
argument_list|)
operator|)
operator|)
condition|)
block|{
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"scale factor invalid on this architecture; needs cpu32 or 68020 or higher"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
operator|&&
name|opP
operator|->
name|index
operator|.
name|size
operator|==
name|SIZE_WORD
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"invalid index size for coldfire"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opP
operator|->
name|index
operator|.
name|scale
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|nextword
operator||=
literal|0x200
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|nextword
operator||=
literal|0x400
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|nextword
operator||=
literal|0x600
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* IF its simple, 		     GET US OUT OF HERE! */
comment|/* Must be INDEX, with an index register.  Address 		     register cannot be ZERO-PC, and either :b was 		     forced, or we know it will fit.  For a 68000 or 		     68010, force this mode anyways, because the 		     larger modes aren't supported.  */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|BASE
operator|&&
operator|(
operator|(
name|opP
operator|->
name|reg
operator|>=
name|ADDR0
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|ADDR7
operator|)
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|)
condition|)
block|{
if|if
condition|(
name|siz1
operator|==
name|SIZE_BYTE
operator|||
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|||
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
operator|||
operator|(
name|siz1
operator|==
name|SIZE_UNSPEC
operator|&&
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|issbyte
argument_list|(
name|baseo
argument_list|)
operator|)
condition|)
block|{
name|nextword
operator|+=
name|baseo
operator|&
literal|0xff
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
block|{
comment|/* Do a byte relocation.  If it doesn't 				 fit (possible on m68000) let the 				 fixup processing complain later.  */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
name|add_fix
argument_list|(
literal|'B'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|add_fix
argument_list|(
literal|'B'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|siz1
operator|!=
name|SIZE_BYTE
condition|)
block|{
if|if
condition|(
name|siz1
operator|!=
name|SIZE_UNSPEC
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Forcing byte displacement"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issbyte
argument_list|(
name|baseo
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"byte displacement out of range"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|siz1
operator|==
name|SIZE_UNSPEC
operator|&&
name|opP
operator|->
name|reg
operator|==
name|PC
operator|&&
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|subs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If the displacement needs pic 				  relocation it cannot be relaxed.  */
operator|&&
name|opP
operator|->
name|disp
operator|.
name|pic_reloc
operator|==
name|pic_none
endif|#
directive|endif
condition|)
block|{
comment|/* The code in md_convert_frag_1 needs to be                              able to adjust nextword.  Call frag_grow                              to ensure that we have enough space in                              the frag obstack to make all the bytes                              contiguous.  */
name|frag_grow
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|nextword
operator|+=
name|baseo
operator|&
literal|0xff
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|nextword
operator||=
literal|0x40
expr_stmt|;
comment|/* No index reg.  */
if|if
condition|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|>=
name|ZDATA0
operator|&&
name|opP
operator|->
name|index
operator|.
name|reg
operator|<=
name|ZDATA7
condition|)
name|nextword
operator||=
operator|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|-
name|ZDATA0
operator|)
operator|<<
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|>=
name|ZADDR0
operator|||
name|opP
operator|->
name|index
operator|.
name|reg
operator|<=
name|ZADDR7
condition|)
name|nextword
operator||=
operator|(
name|opP
operator|->
name|index
operator|.
name|reg
operator|-
name|ZADDR0
operator|+
literal|8
operator|)
operator|<<
literal|12
expr_stmt|;
block|}
comment|/* It isn't simple.  */
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|||
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"invalid operand mode for this architecture; needs 68020 or higher"
argument_list|)
expr_stmt|;
name|nextword
operator||=
literal|0x100
expr_stmt|;
comment|/* If the guy specified a width, we assume that it is 		 wide enough.  Maybe it isn't.  If so, we lose.  */
switch|switch
condition|(
name|siz1
condition|)
block|{
case|case
name|SIZE_UNSPEC
case|:
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|?
name|m68k_rel32
else|:
operator|!
name|issword
argument_list|(
name|baseo
argument_list|)
condition|)
block|{
name|siz1
operator|=
name|SIZE_LONG
expr_stmt|;
name|nextword
operator||=
literal|0x30
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|baseo
operator|==
literal|0
condition|)
name|nextword
operator||=
literal|0x10
expr_stmt|;
else|else
block|{
name|nextword
operator||=
literal|0x20
expr_stmt|;
name|siz1
operator|=
name|SIZE_WORD
expr_stmt|;
block|}
break|break;
case|case
name|SIZE_BYTE
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|":b not permitted; defaulting to :w"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|SIZE_WORD
case|:
name|nextword
operator||=
literal|0x20
expr_stmt|;
break|break;
case|case
name|SIZE_LONG
case|:
name|nextword
operator||=
literal|0x30
expr_stmt|;
break|break;
block|}
comment|/* Figure out inner displacement stuff.  */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|POST
operator|||
name|opP
operator|->
name|mode
operator|==
name|PRE
condition|)
block|{
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|&
name|cpu32
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"invalid operand mode for this architecture; needs 68020 or higher"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|siz2
condition|)
block|{
case|case
name|SIZE_UNSPEC
case|:
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|odisp
argument_list|)
condition|?
name|m68k_rel32
else|:
operator|!
name|issword
argument_list|(
name|outro
argument_list|)
condition|)
block|{
name|siz2
operator|=
name|SIZE_LONG
expr_stmt|;
name|nextword
operator||=
literal|0x3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|odisp
argument_list|)
operator|&&
name|outro
operator|==
literal|0
condition|)
name|nextword
operator||=
literal|0x1
expr_stmt|;
else|else
block|{
name|nextword
operator||=
literal|0x2
expr_stmt|;
name|siz2
operator|=
name|SIZE_WORD
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|":b not permitted; defaulting to :w"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
name|nextword
operator||=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|nextword
operator||=
literal|0x3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|POST
operator|&&
operator|(
name|nextword
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
name|nextword
operator||=
literal|0x04
expr_stmt|;
block|}
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz1
operator|!=
name|SIZE_UNSPEC
operator|&&
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|add_fix
argument_list|(
name|siz1
operator|==
name|SIZE_LONG
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|add_fix
argument_list|(
name|siz1
operator|==
name|SIZE_LONG
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siz1
operator|==
name|SIZE_LONG
condition|)
name|addword
argument_list|(
name|baseo
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz1
operator|!=
name|SIZE_UNSPEC
condition|)
name|addword
argument_list|(
name|baseo
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz2
operator|!=
name|SIZE_UNSPEC
operator|&&
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|odisp
argument_list|)
condition|)
name|add_fix
argument_list|(
name|siz2
operator|==
name|SIZE_LONG
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|odisp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz2
operator|==
name|SIZE_LONG
condition|)
name|addword
argument_list|(
name|outro
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz2
operator|!=
name|SIZE_UNSPEC
condition|)
name|addword
argument_list|(
name|outro
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
name|nextword
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opP
operator|->
name|disp
operator|.
name|size
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SIZE_UNSPEC
case|:
if|if
condition|(
operator|!
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|issword
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
condition|)
block|{
name|tmpreg
operator|=
literal|0x38
expr_stmt|;
comment|/* 7.0 */
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
operator|!
name|subs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|&&
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If the displacement needs pic relocation it 			 cannot be relaxed.  */
operator|&&
name|opP
operator|->
name|disp
operator|.
name|pic_reloc
operator|==
name|pic_none
endif|#
directive|endif
operator|&&
operator|!
name|flag_long_jumps
operator|&&
operator|!
name|strchr
argument_list|(
literal|"~%&$?"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|tmpreg
operator|=
literal|0x3A
expr_stmt|;
comment|/* 7.2 */
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through into long.  */
case|case
name|SIZE_LONG
case|:
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0x39
expr_stmt|;
comment|/* 7.1 mode */
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZE_BYTE
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported byte value; use a different suffix"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|SIZE_WORD
case|:
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0x38
expr_stmt|;
comment|/* 7.0 mode */
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONTROL
case|:
case|case
name|FPREG
case|:
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown/incorrect operand"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* abort (); */
block|}
comment|/* If s[0] is '4', then this is for the mac instructions 	     that can have a trailing_ampersand set.  If so, set 0x100 	     bit on tmpreg so install_gen_operand can check for it and 	     set the appropriate bit (word2, bit 5).  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|trailing_ampersand
condition|)
name|tmpreg
operator||=
literal|0x100
expr_stmt|;
block|}
name|install_gen_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'^'
case|:
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
comment|/* JF: I hate floating point! */
case|case
literal|'j'
case|:
name|tmpreg
operator|=
literal|70
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|tmpreg
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|tmpreg
operator|=
literal|50
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
default|default:
name|tmpreg
operator|=
literal|90
expr_stmt|;
break|break;
block|}
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|add_fix
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Danger:  These do no check for 				   certain types of overflow. 				   user beware! */
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"out of range"
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|issbyte
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"out of range"
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
name|tmpreg
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
name|opcode
operator|->
name|m_codenum
operator|*
literal|2
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"out of range"
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|issword
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"out of range"
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Because of the way insop works, we put these two out 		 backwards.  */
name|insop
argument_list|(
name|tmpreg
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
operator|>>
literal|16
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|tmpreg
operator|&=
literal|0xFF
expr_stmt|;
case|case
literal|'8'
case|:
case|case
literal|'C'
case|:
case|case
literal|'j'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'B'
case|:
name|add_fix
argument_list|(
literal|'B'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|add_fix
argument_list|(
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|long_branch
label|:
if|if
condition|(
operator|!
name|HAVE_LONG_BRANCH
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't use long branches on 68000/68010/5200"
argument_list|)
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
literal|0xff
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|subs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
comment|/* We can't relax it.  */
goto|goto
name|long_branch
goto|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If the displacement needs pic relocation it cannot be 		 relaxed.  */
if|if
condition|(
name|opP
operator|->
name|disp
operator|.
name|pic_reloc
operator|!=
name|pic_none
condition|)
goto|goto
name|long_branch
goto|;
endif|#
directive|endif
comment|/* This could either be a symbol, or an absolute 		 address.  If it's an absolute address, turn it into 		 an absolute jump right here and keep it out of the 		 relaxer.  */
if|if
condition|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|==
literal|0x6000
condition|)
comment|/* jbra */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
literal|0x4EF9
expr_stmt|;
elseif|else
if|if
condition|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|==
literal|0x6100
condition|)
comment|/* jbsr */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
literal|0x4EB9
expr_stmt|;
else|else
comment|/* jCC */
block|{
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|^=
literal|0x0100
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
literal|0x0006
expr_stmt|;
name|addword
argument_list|(
literal|0x4EF9
argument_list|)
expr_stmt|;
block|}
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now we know it's going into the relaxer.  Now figure 		 out which mode.  We try in this order of preference: 		 long branch, absolute jump, byte/word branches only.  */
if|if
condition|(
name|HAVE_LONG_BRANCH
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_keep_pcrel
condition|)
block|{
if|if
condition|(
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|==
literal|0x6000
operator|)
operator|||
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|==
literal|0x6100
operator|)
condition|)
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BRANCHBW
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
block|{
comment|/* Check for DBcc instructions.  We can relax them, 		     but only if we have long branches and/or absolute 		     jumps.  */
if|if
condition|(
operator|(
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|&
literal|0xf0f8
operator|)
operator|==
literal|0x50c8
operator|)
operator|&&
operator|(
name|HAVE_LONG_BRANCH
argument_list|(
name|current_architecture
argument_list|)
operator|||
operator|(
operator|!
name|flag_keep_pcrel
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|HAVE_LONG_BRANCH
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|DBCCLBR
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|DBCCABSJ
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_fix
argument_list|(
literal|'w'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Fixed size LONG coproc branches.  */
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Var size Coprocesssor branches.  */
if|if
condition|(
name|subs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|||
operator|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|add_frag
argument_list|(
name|adds
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|,
name|SEXT
argument_list|(
name|offs
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Ignore it.  */
break|break;
case|case
literal|'d'
case|:
comment|/* JF this is a kludge.  */
name|install_operand
argument_list|(
literal|'s'
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ADDR
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issword
argument_list|(
name|tmpreg
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expression out of range, using 0"
argument_list|)
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0
expr_stmt|;
block|}
name|addword
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* EMAC ACCx, reg/reg.  */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ACC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Ignore it.  */
break|break;
case|case
literal|'F'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|FP0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* EMAC ACCEXTx.  */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ACCEXT01
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* Ignore it.  */
case|case
literal|'H'
case|:
break|break;
case|case
literal|'I'
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|reg
operator|-
name|COP0
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* MAC/EMAC scale factor.  */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|mode
operator|==
name|LSH
condition|?
literal|0x1
else|:
literal|0x3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* JF foo.  */
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|SFC
case|:
name|tmpreg
operator|=
literal|0x000
expr_stmt|;
break|break;
case|case
name|DFC
case|:
name|tmpreg
operator|=
literal|0x001
expr_stmt|;
break|break;
case|case
name|CACR
case|:
name|tmpreg
operator|=
literal|0x002
expr_stmt|;
break|break;
case|case
name|TC
case|:
name|tmpreg
operator|=
literal|0x003
expr_stmt|;
break|break;
case|case
name|ACR0
case|:
case|case
name|ITT0
case|:
name|tmpreg
operator|=
literal|0x004
expr_stmt|;
break|break;
case|case
name|ACR1
case|:
case|case
name|ITT1
case|:
name|tmpreg
operator|=
literal|0x005
expr_stmt|;
break|break;
case|case
name|ACR2
case|:
case|case
name|DTT0
case|:
name|tmpreg
operator|=
literal|0x006
expr_stmt|;
break|break;
case|case
name|ACR3
case|:
case|case
name|DTT1
case|:
name|tmpreg
operator|=
literal|0x007
expr_stmt|;
break|break;
case|case
name|BUSCR
case|:
name|tmpreg
operator|=
literal|0x008
expr_stmt|;
break|break;
case|case
name|USP
case|:
name|tmpreg
operator|=
literal|0x800
expr_stmt|;
break|break;
case|case
name|VBR
case|:
name|tmpreg
operator|=
literal|0x801
expr_stmt|;
break|break;
case|case
name|CAAR
case|:
name|tmpreg
operator|=
literal|0x802
expr_stmt|;
break|break;
case|case
name|MSP
case|:
name|tmpreg
operator|=
literal|0x803
expr_stmt|;
break|break;
case|case
name|ISP
case|:
name|tmpreg
operator|=
literal|0x804
expr_stmt|;
break|break;
case|case
name|MMUSR
case|:
name|tmpreg
operator|=
literal|0x805
expr_stmt|;
break|break;
case|case
name|URP
case|:
name|tmpreg
operator|=
literal|0x806
expr_stmt|;
break|break;
case|case
name|SRP
case|:
name|tmpreg
operator|=
literal|0x807
expr_stmt|;
break|break;
case|case
name|PCR
case|:
name|tmpreg
operator|=
literal|0x808
expr_stmt|;
break|break;
case|case
name|ROMBAR
case|:
name|tmpreg
operator|=
literal|0xC00
expr_stmt|;
break|break;
case|case
name|ROMBAR1
case|:
name|tmpreg
operator|=
literal|0xC01
expr_stmt|;
break|break;
case|case
name|FLASHBAR
case|:
case|case
name|RAMBAR0
case|:
name|tmpreg
operator|=
literal|0xC04
expr_stmt|;
break|break;
case|case
name|RAMBAR
case|:
case|case
name|RAMBAR1
case|:
name|tmpreg
operator|=
literal|0xC05
expr_stmt|;
break|break;
case|case
name|MPCR
case|:
name|tmpreg
operator|=
literal|0xC0C
expr_stmt|;
break|break;
case|case
name|EDRAMBAR
case|:
name|tmpreg
operator|=
literal|0xC0D
expr_stmt|;
break|break;
case|case
name|MBAR0
case|:
case|case
name|MBAR2
case|:
case|case
name|SECMBAR
case|:
name|tmpreg
operator|=
literal|0xC0E
expr_stmt|;
break|break;
case|case
name|MBAR1
case|:
case|case
name|MBAR
case|:
name|tmpreg
operator|=
literal|0xC0F
expr_stmt|;
break|break;
case|case
name|PCR1U0
case|:
name|tmpreg
operator|=
literal|0xD02
expr_stmt|;
break|break;
case|case
name|PCR1L0
case|:
name|tmpreg
operator|=
literal|0xD03
expr_stmt|;
break|break;
case|case
name|PCR2U0
case|:
name|tmpreg
operator|=
literal|0xD04
expr_stmt|;
break|break;
case|case
name|PCR2L0
case|:
name|tmpreg
operator|=
literal|0xD05
expr_stmt|;
break|break;
case|case
name|PCR3U0
case|:
name|tmpreg
operator|=
literal|0xD06
expr_stmt|;
break|break;
case|case
name|PCR3L0
case|:
name|tmpreg
operator|=
literal|0xD07
expr_stmt|;
break|break;
case|case
name|PCR1L1
case|:
name|tmpreg
operator|=
literal|0xD0A
expr_stmt|;
break|break;
case|case
name|PCR1U1
case|:
name|tmpreg
operator|=
literal|0xD0B
expr_stmt|;
break|break;
case|case
name|PCR2L1
case|:
name|tmpreg
operator|=
literal|0xD0C
expr_stmt|;
break|break;
case|case
name|PCR2U1
case|:
name|tmpreg
operator|=
literal|0xD0D
expr_stmt|;
break|break;
case|case
name|PCR3L1
case|:
name|tmpreg
operator|=
literal|0xD0E
expr_stmt|;
break|break;
case|case
name|PCR3U1
case|:
name|tmpreg
operator|=
literal|0xD0F
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x7FF0000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Floating point register in register list"
argument_list|)
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|reverse_16_bits
argument_list|(
name|tmpreg
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x700FFFF
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong register in floating-point reglist"
argument_list|)
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|reverse_8_bits
argument_list|(
name|tmpreg
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x7FF0000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Floating point register in register list"
argument_list|)
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x0FFFFFF
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"incorrect register in reglist"
argument_list|)
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x700FFFF
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"wrong register in floating-point reglist"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|tmpreg
operator|=
operator|(
operator|(
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|)
condition|?
literal|0x20
operator|+
call|(
name|int
call|)
argument_list|(
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
else|:
operator|(
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|40
argument_list|)
operator|&
literal|0x1F
operator|)
operator|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpreg
operator|==
literal|8
condition|)
name|tmpreg
operator|=
literal|0
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* This depends on the fact that ADDR registers are eight 	     more than their corresponding DATA regs, so the result 	     will have the ADDR_REG bit set.  */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|AINDR
condition|)
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
else|else
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|index
operator|.
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPI
condition|)
name|tmpreg
operator|=
literal|0x1
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPS
condition|)
name|tmpreg
operator|=
literal|0x2
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPC
condition|)
name|tmpreg
operator|=
literal|0x4
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Ignore it.  */
break|break;
case|case
literal|'T'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|30
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Ignore it.  */
break|break;
case|case
literal|'c'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|NC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DC
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IC
case|:
name|tmpreg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BC
case|:
name|tmpreg
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* switch on cache token.  */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_68851
comment|/* JF: These are out of order, I fear.  */
case|case
literal|'f'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|SFC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DFC
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|TC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAL
case|:
name|tmpreg
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|VAL
case|:
name|tmpreg
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|SCC
case|:
name|tmpreg
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|AC
case|:
name|tmpreg
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|VAL
condition|)
break|break;
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'W'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|DRP
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SRP
case|:
name|tmpreg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CRP
case|:
name|tmpreg
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|BAD
case|:
case|case
name|BAD
operator|+
literal|1
case|:
case|case
name|BAD
operator|+
literal|2
case|:
case|case
name|BAD
operator|+
literal|3
case|:
case|case
name|BAD
operator|+
literal|4
case|:
case|case
name|BAD
operator|+
literal|5
case|:
case|case
name|BAD
operator|+
literal|6
case|:
case|case
name|BAD
operator|+
literal|7
case|:
name|tmpreg
operator|=
operator|(
literal|4
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|opP
operator|->
name|reg
operator|-
name|BAD
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|BAC
case|:
case|case
name|BAC
operator|+
literal|1
case|:
case|case
name|BAC
operator|+
literal|2
case|:
case|case
name|BAC
operator|+
literal|3
case|:
case|case
name|BAC
operator|+
literal|4
case|:
case|case
name|BAC
operator|+
literal|5
case|:
case|case
name|BAC
operator|+
literal|6
case|:
case|case
name|BAC
operator|+
literal|7
case|:
name|tmpreg
operator|=
operator|(
literal|5
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|opP
operator|->
name|reg
operator|-
name|BAC
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|know
argument_list|(
name|opP
operator|->
name|reg
operator|==
name|PSR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|know
argument_list|(
name|opP
operator|->
name|reg
operator|==
name|PCSR
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* m68851 */
case|case
literal|'3'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|TT0
case|:
name|tmpreg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TT1
case|:
name|tmpreg
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* used only for move16 absolute 32-bit address.  */
if|if
condition|(
name|isvar
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'l'
argument_list|,
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|tmpreg
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|tmpreg
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA0L
argument_list|)
expr_stmt|;
name|opP
operator|->
name|reg
operator|-=
operator|(
name|DATA0L
operator|)
expr_stmt|;
name|opP
operator|->
name|reg
operator|&=
literal|0x0F
expr_stmt|;
comment|/* remove upper/lower bit.  */
break|break;
case|case
literal|'x'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
operator|&
name|opP
operator|->
name|disp
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpreg
operator|==
operator|-
literal|1
condition|)
name|tmpreg
operator|=
literal|0
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* By the time whe get here (FINALLY) the_ins contains the complete      instruction, ready to be emitted. . .  */
block|}
end_function

begin_function
specifier|static
name|int
name|reverse_16_bits
parameter_list|(
name|int
name|in
parameter_list|)
block|{
name|int
name|out
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0008
block|,
literal|0x0010
block|,
literal|0x0020
block|,
literal|0x0040
block|,
literal|0x0080
block|,
literal|0x0100
block|,
literal|0x0200
block|,
literal|0x0400
block|,
literal|0x0800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|}
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|in
operator|&
name|mask
index|[
name|n
index|]
condition|)
name|out
operator||=
name|mask
index|[
literal|15
operator|-
name|n
index|]
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* reverse_16_bits() */
end_comment

begin_function
specifier|static
name|int
name|reverse_8_bits
parameter_list|(
name|int
name|in
parameter_list|)
block|{
name|int
name|out
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|mask
index|[
literal|8
index|]
init|=
block|{
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0008
block|,
literal|0x0010
block|,
literal|0x0020
block|,
literal|0x0040
block|,
literal|0x0080
block|,   }
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|in
operator|&
name|mask
index|[
name|n
index|]
condition|)
name|out
operator||=
name|mask
index|[
literal|7
operator|-
name|n
index|]
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* reverse_8_bits() */
end_comment

begin_comment
comment|/* Cause an extra frag to be generated here, inserting up to 10 bytes    (that value is chosen in the frag_var call in md_assemble).  TYPE    is the subtype of the frag to be generated; its primary type is    rs_machine_dependent.     The TYPE parameter is also used by md_convert_frag_1 and    md_estimate_size_before_relax.  The appropriate type of fixup will    be emitted by md_convert_frag_1.     ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|install_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'s'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0xFF
expr_stmt|;
comment|/* JF FF is for M kludge.  */
break|break;
case|case
literal|'d'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|<<
literal|9
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* DANGER!  This is a hack to force cas2l and cas2w cmds to be 	 three words long! */
name|the_ins
operator|.
name|numo
operator|++
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|10
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_68851
case|case
literal|'9'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|5
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|<<
literal|10
operator|)
operator||
operator|(
name|val
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|<<
literal|12
operator|)
operator||
name|val
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|<<
literal|9
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|++
expr_stmt|;
comment|/* What a hack.  */
break|break;
case|case
literal|'k'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'l'
case|:
break|break;
case|case
literal|'e'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x8
operator|)
operator|<<
operator|(
literal|6
operator|-
literal|3
operator|)
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x7
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|<<
operator|(
literal|7
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* MAC/EMAC Rx on !load.  */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x8
operator|)
operator|<<
operator|(
literal|6
operator|-
literal|3
operator|)
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x7
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|<<
operator|(
literal|7
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* MAC/EMAC Rx on load.  */
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|12
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|<<
operator|(
literal|7
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAC/EMAC Ry on !load.  */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0xF
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|<<
operator|(
literal|6
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* MAC/EMAC Ry on load.  */
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|&
literal|0xF
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|<<
operator|(
literal|6
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|!=
literal|1
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x3
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x3
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* EMAC accumulator in a EMAC load instruction.  */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
operator|~
name|val
operator|&
literal|0x1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x2
operator|)
operator|<<
operator|(
literal|4
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* EMAC accumulator in a EMAC non-load instruction.  */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x2
operator|)
operator|<<
operator|(
literal|4
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|&
literal|0x3
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0x1
operator|)
operator|<<
literal|10
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|install_gen_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* Special for mask loads for mac/msac insns with 		  possible mask; trailing_ampersend set in bit 8.  */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
operator|(
operator|(
name|val
operator|&
literal|0x100
operator|)
operator|>>
literal|8
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* This is a kludge!!! */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0x07
operator|)
operator|<<
literal|9
operator||
operator|(
name|val
operator|&
literal|0x38
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'l'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'x'
case|:
case|case
literal|'p'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
expr_stmt|;
break|break;
comment|/* more stuff goes here.  */
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Verify that we have some number of paren pairs, do m68k_ip_op(), and    then deal with the bitfield hack.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|crack_operand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|m68k_op
modifier|*
name|opP
parameter_list|)
block|{
specifier|register
name|int
name|parens
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|beg_str
decl_stmt|;
name|int
name|inquote
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
return|return
name|str
return|;
block|}
name|beg_str
operator|=
name|str
expr_stmt|;
for|for
control|(
name|parens
operator|=
literal|0
init|;
operator|*
name|str
operator|&&
operator|(
name|parens
operator|>
literal|0
operator|||
name|inquote
operator|||
name|notend
argument_list|(
name|str
argument_list|)
operator|)
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|inquote
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
name|parens
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|parens
condition|)
block|{
comment|/* ERROR.  */
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"Extra )"
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
operator|--
name|parens
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_mri
operator|&&
operator|*
name|str
operator|==
literal|'\''
condition|)
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|str
operator|&&
name|parens
condition|)
block|{
comment|/* ERROR.  */
name|opP
operator|->
name|error
operator|=
name|_
argument_list|(
literal|"Missing )"
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
name|c
operator|=
operator|*
name|str
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|m68k_ip_op
argument_list|(
name|beg_str
argument_list|,
name|opP
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|str
operator|=
name|c
expr_stmt|;
return|return
name|str
return|;
block|}
operator|*
name|str
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
comment|/* JF bitfield hack.  */
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Detect MRI REG symbols and convert them to REGLSTs.  */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|CONTROL
operator|&&
operator|(
name|int
operator|)
name|opP
operator|->
name|reg
operator|<
literal|0
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
name|opP
operator|->
name|mask
operator|=
operator|~
operator|(
name|int
operator|)
name|opP
operator|->
name|reg
expr_stmt|;
name|opP
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.    */
end_comment

begin_function
specifier|static
name|void
name|insert_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|flag_reg_prefix_optional
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|REGISTER_PREFIX
expr_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|regname
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|regname
argument_list|,
name|reg_section
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|reg_section
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|init_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|init_entry
name|init_table
index|[]
init|=
block|{
block|{
literal|"d0"
block|,
name|DATA0
block|}
block|,
block|{
literal|"d1"
block|,
name|DATA1
block|}
block|,
block|{
literal|"d2"
block|,
name|DATA2
block|}
block|,
block|{
literal|"d3"
block|,
name|DATA3
block|}
block|,
block|{
literal|"d4"
block|,
name|DATA4
block|}
block|,
block|{
literal|"d5"
block|,
name|DATA5
block|}
block|,
block|{
literal|"d6"
block|,
name|DATA6
block|}
block|,
block|{
literal|"d7"
block|,
name|DATA7
block|}
block|,
block|{
literal|"a0"
block|,
name|ADDR0
block|}
block|,
block|{
literal|"a1"
block|,
name|ADDR1
block|}
block|,
block|{
literal|"a2"
block|,
name|ADDR2
block|}
block|,
block|{
literal|"a3"
block|,
name|ADDR3
block|}
block|,
block|{
literal|"a4"
block|,
name|ADDR4
block|}
block|,
block|{
literal|"a5"
block|,
name|ADDR5
block|}
block|,
block|{
literal|"a6"
block|,
name|ADDR6
block|}
block|,
block|{
literal|"fp"
block|,
name|ADDR6
block|}
block|,
block|{
literal|"a7"
block|,
name|ADDR7
block|}
block|,
block|{
literal|"sp"
block|,
name|ADDR7
block|}
block|,
block|{
literal|"ssp"
block|,
name|ADDR7
block|}
block|,
block|{
literal|"fp0"
block|,
name|FP0
block|}
block|,
block|{
literal|"fp1"
block|,
name|FP1
block|}
block|,
block|{
literal|"fp2"
block|,
name|FP2
block|}
block|,
block|{
literal|"fp3"
block|,
name|FP3
block|}
block|,
block|{
literal|"fp4"
block|,
name|FP4
block|}
block|,
block|{
literal|"fp5"
block|,
name|FP5
block|}
block|,
block|{
literal|"fp6"
block|,
name|FP6
block|}
block|,
block|{
literal|"fp7"
block|,
name|FP7
block|}
block|,
block|{
literal|"fpi"
block|,
name|FPI
block|}
block|,
block|{
literal|"fpiar"
block|,
name|FPI
block|}
block|,
block|{
literal|"fpc"
block|,
name|FPI
block|}
block|,
block|{
literal|"fps"
block|,
name|FPS
block|}
block|,
block|{
literal|"fpsr"
block|,
name|FPS
block|}
block|,
block|{
literal|"fpc"
block|,
name|FPC
block|}
block|,
block|{
literal|"fpcr"
block|,
name|FPC
block|}
block|,
block|{
literal|"control"
block|,
name|FPC
block|}
block|,
block|{
literal|"status"
block|,
name|FPS
block|}
block|,
block|{
literal|"iaddr"
block|,
name|FPI
block|}
block|,
block|{
literal|"cop0"
block|,
name|COP0
block|}
block|,
block|{
literal|"cop1"
block|,
name|COP1
block|}
block|,
block|{
literal|"cop2"
block|,
name|COP2
block|}
block|,
block|{
literal|"cop3"
block|,
name|COP3
block|}
block|,
block|{
literal|"cop4"
block|,
name|COP4
block|}
block|,
block|{
literal|"cop5"
block|,
name|COP5
block|}
block|,
block|{
literal|"cop6"
block|,
name|COP6
block|}
block|,
block|{
literal|"cop7"
block|,
name|COP7
block|}
block|,
block|{
literal|"pc"
block|,
name|PC
block|}
block|,
block|{
literal|"zpc"
block|,
name|ZPC
block|}
block|,
block|{
literal|"sr"
block|,
name|SR
block|}
block|,
block|{
literal|"ccr"
block|,
name|CCR
block|}
block|,
block|{
literal|"cc"
block|,
name|CCR
block|}
block|,
block|{
literal|"acc"
block|,
name|ACC
block|}
block|,
block|{
literal|"acc0"
block|,
name|ACC
block|}
block|,
block|{
literal|"acc1"
block|,
name|ACC1
block|}
block|,
block|{
literal|"acc2"
block|,
name|ACC2
block|}
block|,
block|{
literal|"acc3"
block|,
name|ACC3
block|}
block|,
block|{
literal|"accext01"
block|,
name|ACCEXT01
block|}
block|,
block|{
literal|"accext23"
block|,
name|ACCEXT23
block|}
block|,
block|{
literal|"macsr"
block|,
name|MACSR
block|}
block|,
block|{
literal|"mask"
block|,
name|MASK
block|}
block|,
comment|/* Control registers.  */
block|{
literal|"sfc"
block|,
name|SFC
block|}
block|,
comment|/* Source Function Code.  */
block|{
literal|"sfcr"
block|,
name|SFC
block|}
block|,
block|{
literal|"dfc"
block|,
name|DFC
block|}
block|,
comment|/* Destination Function Code.  */
block|{
literal|"dfcr"
block|,
name|DFC
block|}
block|,
block|{
literal|"cacr"
block|,
name|CACR
block|}
block|,
comment|/* Cache Control Register.  */
block|{
literal|"caar"
block|,
name|CAAR
block|}
block|,
comment|/* Cache Address Register.  */
block|{
literal|"usp"
block|,
name|USP
block|}
block|,
comment|/* User Stack Pointer.  */
block|{
literal|"vbr"
block|,
name|VBR
block|}
block|,
comment|/* Vector Base Register.  */
block|{
literal|"msp"
block|,
name|MSP
block|}
block|,
comment|/* Master Stack Pointer.  */
block|{
literal|"isp"
block|,
name|ISP
block|}
block|,
comment|/* Interrupt Stack Pointer.  */
block|{
literal|"itt0"
block|,
name|ITT0
block|}
block|,
comment|/* Instruction Transparent Translation Reg 0.  */
block|{
literal|"itt1"
block|,
name|ITT1
block|}
block|,
comment|/* Instruction Transparent Translation Reg 1.  */
block|{
literal|"dtt0"
block|,
name|DTT0
block|}
block|,
comment|/* Data Transparent Translation Register 0.  */
block|{
literal|"dtt1"
block|,
name|DTT1
block|}
block|,
comment|/* Data Transparent Translation Register 1.  */
comment|/* 68ec040 versions of same */
block|{
literal|"iacr0"
block|,
name|ITT0
block|}
block|,
comment|/* Instruction Access Control Register 0.  */
block|{
literal|"iacr1"
block|,
name|ITT1
block|}
block|,
comment|/* Instruction Access Control Register 0.  */
block|{
literal|"dacr0"
block|,
name|DTT0
block|}
block|,
comment|/* Data Access Control Register 0.  */
block|{
literal|"dacr1"
block|,
name|DTT1
block|}
block|,
comment|/* Data Access Control Register 0.  */
comment|/* mcf5200 versions of same.  The ColdFire programmer's reference      manual indicated that the order is 2,3,0,1, but Ken Rose<rose@netcom.com> says that 0,1,2,3 is the correct order.  */
block|{
literal|"acr0"
block|,
name|ACR0
block|}
block|,
comment|/* Access Control Unit 0.  */
block|{
literal|"acr1"
block|,
name|ACR1
block|}
block|,
comment|/* Access Control Unit 1.  */
block|{
literal|"acr2"
block|,
name|ACR2
block|}
block|,
comment|/* Access Control Unit 2.  */
block|{
literal|"acr3"
block|,
name|ACR3
block|}
block|,
comment|/* Access Control Unit 3.  */
block|{
literal|"tc"
block|,
name|TC
block|}
block|,
comment|/* MMU Translation Control Register.  */
block|{
literal|"tcr"
block|,
name|TC
block|}
block|,
block|{
literal|"mmusr"
block|,
name|MMUSR
block|}
block|,
comment|/* MMU Status Register.  */
block|{
literal|"srp"
block|,
name|SRP
block|}
block|,
comment|/* User Root Pointer.  */
block|{
literal|"urp"
block|,
name|URP
block|}
block|,
comment|/* Supervisor Root Pointer.  */
block|{
literal|"buscr"
block|,
name|BUSCR
block|}
block|,
block|{
literal|"pcr"
block|,
name|PCR
block|}
block|,
block|{
literal|"rombar"
block|,
name|ROMBAR
block|}
block|,
comment|/* ROM Base Address Register.  */
block|{
literal|"rambar0"
block|,
name|RAMBAR0
block|}
block|,
comment|/* ROM Base Address Register.  */
block|{
literal|"rambar1"
block|,
name|RAMBAR1
block|}
block|,
comment|/* ROM Base Address Register.  */
block|{
literal|"mbar"
block|,
name|MBAR
block|}
block|,
comment|/* Module Base Address Register.  */
block|{
literal|"mbar0"
block|,
name|MBAR0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"mbar1"
block|,
name|MBAR1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"rombar0"
block|,
name|ROMBAR
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"rombar1"
block|,
name|ROMBAR1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"mpcr"
block|,
name|MPCR
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"edrambar"
block|,
name|EDRAMBAR
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"secmbar"
block|,
name|SECMBAR
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"asid"
block|,
name|TC
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"mmubar"
block|,
name|BUSCR
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr1u0"
block|,
name|PCR1U0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr1l0"
block|,
name|PCR1L0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr2u0"
block|,
name|PCR2U0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr2l0"
block|,
name|PCR2L0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr3u0"
block|,
name|PCR3U0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr3l0"
block|,
name|PCR3L0
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr1u1"
block|,
name|PCR1U1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr1l1"
block|,
name|PCR1L1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr2u1"
block|,
name|PCR2U1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr2l1"
block|,
name|PCR2L1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr3u1"
block|,
name|PCR3U1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"pcr3l1"
block|,
name|PCR3L1
block|}
block|,
comment|/* mcfv4e registers.  */
block|{
literal|"flashbar"
block|,
name|FLASHBAR
block|}
block|,
comment|/* mcf528x registers.  */
block|{
literal|"rambar"
block|,
name|RAMBAR
block|}
block|,
comment|/* mcf528x registers.  */
block|{
literal|"mbar2"
block|,
name|MBAR2
block|}
block|,
comment|/* mcf5249 registers.  */
comment|/* End of control registers.  */
block|{
literal|"ac"
block|,
name|AC
block|}
block|,
block|{
literal|"bc"
block|,
name|BC
block|}
block|,
block|{
literal|"cal"
block|,
name|CAL
block|}
block|,
block|{
literal|"crp"
block|,
name|CRP
block|}
block|,
block|{
literal|"drp"
block|,
name|DRP
block|}
block|,
block|{
literal|"pcsr"
block|,
name|PCSR
block|}
block|,
block|{
literal|"psr"
block|,
name|PSR
block|}
block|,
block|{
literal|"scc"
block|,
name|SCC
block|}
block|,
block|{
literal|"val"
block|,
name|VAL
block|}
block|,
block|{
literal|"bad0"
block|,
name|BAD0
block|}
block|,
block|{
literal|"bad1"
block|,
name|BAD1
block|}
block|,
block|{
literal|"bad2"
block|,
name|BAD2
block|}
block|,
block|{
literal|"bad3"
block|,
name|BAD3
block|}
block|,
block|{
literal|"bad4"
block|,
name|BAD4
block|}
block|,
block|{
literal|"bad5"
block|,
name|BAD5
block|}
block|,
block|{
literal|"bad6"
block|,
name|BAD6
block|}
block|,
block|{
literal|"bad7"
block|,
name|BAD7
block|}
block|,
block|{
literal|"bac0"
block|,
name|BAC0
block|}
block|,
block|{
literal|"bac1"
block|,
name|BAC1
block|}
block|,
block|{
literal|"bac2"
block|,
name|BAC2
block|}
block|,
block|{
literal|"bac3"
block|,
name|BAC3
block|}
block|,
block|{
literal|"bac4"
block|,
name|BAC4
block|}
block|,
block|{
literal|"bac5"
block|,
name|BAC5
block|}
block|,
block|{
literal|"bac6"
block|,
name|BAC6
block|}
block|,
block|{
literal|"bac7"
block|,
name|BAC7
block|}
block|,
block|{
literal|"ic"
block|,
name|IC
block|}
block|,
block|{
literal|"dc"
block|,
name|DC
block|}
block|,
block|{
literal|"nc"
block|,
name|NC
block|}
block|,
block|{
literal|"tt0"
block|,
name|TT0
block|}
block|,
block|{
literal|"tt1"
block|,
name|TT1
block|}
block|,
comment|/* 68ec030 versions of same.  */
block|{
literal|"ac0"
block|,
name|TT0
block|}
block|,
block|{
literal|"ac1"
block|,
name|TT1
block|}
block|,
comment|/* 68ec030 access control unit, identical to 030 MMU status reg.  */
block|{
literal|"acusr"
block|,
name|PSR
block|}
block|,
comment|/* Suppressed data and address registers.  */
block|{
literal|"zd0"
block|,
name|ZDATA0
block|}
block|,
block|{
literal|"zd1"
block|,
name|ZDATA1
block|}
block|,
block|{
literal|"zd2"
block|,
name|ZDATA2
block|}
block|,
block|{
literal|"zd3"
block|,
name|ZDATA3
block|}
block|,
block|{
literal|"zd4"
block|,
name|ZDATA4
block|}
block|,
block|{
literal|"zd5"
block|,
name|ZDATA5
block|}
block|,
block|{
literal|"zd6"
block|,
name|ZDATA6
block|}
block|,
block|{
literal|"zd7"
block|,
name|ZDATA7
block|}
block|,
block|{
literal|"za0"
block|,
name|ZADDR0
block|}
block|,
block|{
literal|"za1"
block|,
name|ZADDR1
block|}
block|,
block|{
literal|"za2"
block|,
name|ZADDR2
block|}
block|,
block|{
literal|"za3"
block|,
name|ZADDR3
block|}
block|,
block|{
literal|"za4"
block|,
name|ZADDR4
block|}
block|,
block|{
literal|"za5"
block|,
name|ZADDR5
block|}
block|,
block|{
literal|"za6"
block|,
name|ZADDR6
block|}
block|,
block|{
literal|"za7"
block|,
name|ZADDR7
block|}
block|,
comment|/* Upper and lower data and address registers, used by macw and msacw.  */
block|{
literal|"d0l"
block|,
name|DATA0L
block|}
block|,
block|{
literal|"d1l"
block|,
name|DATA1L
block|}
block|,
block|{
literal|"d2l"
block|,
name|DATA2L
block|}
block|,
block|{
literal|"d3l"
block|,
name|DATA3L
block|}
block|,
block|{
literal|"d4l"
block|,
name|DATA4L
block|}
block|,
block|{
literal|"d5l"
block|,
name|DATA5L
block|}
block|,
block|{
literal|"d6l"
block|,
name|DATA6L
block|}
block|,
block|{
literal|"d7l"
block|,
name|DATA7L
block|}
block|,
block|{
literal|"a0l"
block|,
name|ADDR0L
block|}
block|,
block|{
literal|"a1l"
block|,
name|ADDR1L
block|}
block|,
block|{
literal|"a2l"
block|,
name|ADDR2L
block|}
block|,
block|{
literal|"a3l"
block|,
name|ADDR3L
block|}
block|,
block|{
literal|"a4l"
block|,
name|ADDR4L
block|}
block|,
block|{
literal|"a5l"
block|,
name|ADDR5L
block|}
block|,
block|{
literal|"a6l"
block|,
name|ADDR6L
block|}
block|,
block|{
literal|"a7l"
block|,
name|ADDR7L
block|}
block|,
block|{
literal|"d0u"
block|,
name|DATA0U
block|}
block|,
block|{
literal|"d1u"
block|,
name|DATA1U
block|}
block|,
block|{
literal|"d2u"
block|,
name|DATA2U
block|}
block|,
block|{
literal|"d3u"
block|,
name|DATA3U
block|}
block|,
block|{
literal|"d4u"
block|,
name|DATA4U
block|}
block|,
block|{
literal|"d5u"
block|,
name|DATA5U
block|}
block|,
block|{
literal|"d6u"
block|,
name|DATA6U
block|}
block|,
block|{
literal|"d7u"
block|,
name|DATA7U
block|}
block|,
block|{
literal|"a0u"
block|,
name|ADDR0U
block|}
block|,
block|{
literal|"a1u"
block|,
name|ADDR1U
block|}
block|,
block|{
literal|"a2u"
block|,
name|ADDR2U
block|}
block|,
block|{
literal|"a3u"
block|,
name|ADDR3U
block|}
block|,
block|{
literal|"a4u"
block|,
name|ADDR4U
block|}
block|,
block|{
literal|"a5u"
block|,
name|ADDR5U
block|}
block|,
block|{
literal|"a6u"
block|,
name|ADDR6U
block|}
block|,
block|{
literal|"a7u"
block|,
name|ADDR7U
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_regtable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|init_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|insert_reg
argument_list|(
name|init_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|init_table
index|[
name|i
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|er
decl_stmt|;
name|short
modifier|*
name|fromP
decl_stmt|;
name|char
modifier|*
name|toP
init|=
name|NULL
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|to_beg_P
decl_stmt|;
name|int
name|shorts_this_frag
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|selected_cpu
operator|&&
operator|!
name|selected_arch
condition|)
block|{
comment|/* We've not selected an architecture yet.  Set the default 	 now.  We do this lazily so that an initial .cpu or .arch directive 	 can specify.  */
if|if
condition|(
operator|!
name|m68k_set_cpu
argument_list|(
name|TARGET_CPU
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized default cpu `%s'"
argument_list|)
argument_list|,
name|TARGET_CPU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
name|m68k_init_arch
argument_list|()
expr_stmt|;
comment|/* In MRI mode, the instruction and operands are separated by a      space.  Anything following the operands is a comment.  The label      has already been removed.  */
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|fields
init|=
literal|0
decl_stmt|;
name|int
name|infield
init|=
literal|0
decl_stmt|;
name|int
name|inquote
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
operator|&&
operator|!
name|inquote
condition|)
block|{
if|if
condition|(
name|infield
condition|)
block|{
operator|++
name|fields
expr_stmt|;
if|if
condition|(
name|fields
operator|>=
literal|2
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|infield
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|infield
condition|)
name|infield
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
block|}
block|}
name|memset
argument_list|(
operator|&
name|the_ins
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
argument_list|)
argument_list|)
expr_stmt|;
name|m68k_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|er
operator|=
name|the_ins
operator|.
name|error
expr_stmt|;
if|if
condition|(
operator|!
name|er
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|the_ins
operator|.
name|numargs
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
condition|)
block|{
name|er
operator|=
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|er
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s -- statement `%s' ignored"
argument_list|)
argument_list|,
name|er
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is a current label, record that it marks an instruction.  */
if|if
condition|(
name|current_label
operator|!=
name|NULL
condition|)
block|{
name|current_label
operator|->
name|text
operator|=
literal|1
expr_stmt|;
name|current_label
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Tie dwarf2 debug info to the address at the start of the insn.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|the_ins
operator|.
name|nfrag
operator|==
literal|0
condition|)
block|{
comment|/* No frag hacking involved; just put it out.  */
name|toP
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|the_ins
operator|.
name|numo
argument_list|)
expr_stmt|;
name|fromP
operator|=
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|m
operator|=
name|the_ins
operator|.
name|numo
init|;
name|m
condition|;
operator|--
name|m
control|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
block|}
comment|/* Put out symbol-dependent info.  */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
switch|switch
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
condition|)
block|{
case|case
literal|'B'
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|n
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|n
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Don't know how to figure width of %c in md_assemble()"
argument_list|)
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
argument_list|)
expr_stmt|;
block|}
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|-
name|the_ins
operator|.
name|numo
operator|*
literal|2
operator|+
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|)
argument_list|,
name|n
argument_list|,
operator|&
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|exp
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|get_reloc_code
argument_list|(
name|n
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pic_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel_fix
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|==
literal|'B'
condition|)
name|fixP
operator|->
name|fx_signed
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* There's some frag hacking.  */
block|{
comment|/* Calculate the max frag size.  */
name|int
name|wid
decl_stmt|;
name|wid
operator|=
literal|2
operator|*
name|the_ins
operator|.
name|fragb
index|[
literal|0
index|]
operator|.
name|fragoff
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|the_ins
operator|.
name|nfrag
condition|;
name|n
operator|++
control|)
name|wid
operator|+=
literal|2
operator|*
operator|(
name|the_ins
operator|.
name|numo
operator|-
name|the_ins
operator|.
name|fragb
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|fragoff
operator|)
expr_stmt|;
comment|/* frag_var part.  */
name|wid
operator|+=
literal|10
expr_stmt|;
comment|/* Make sure the whole insn fits in one chunk, in particular that        the var part is attached, as we access one byte before the        variable frag for byte branches.  */
name|frag_grow
argument_list|(
name|wid
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|fromP
operator|=
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
init|;
name|n
operator|<
name|the_ins
operator|.
name|nfrag
condition|;
name|n
operator|++
control|)
block|{
name|int
name|wid
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|wid
operator|=
literal|2
operator|*
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fragoff
expr_stmt|;
else|else
name|wid
operator|=
literal|2
operator|*
operator|(
name|the_ins
operator|.
name|numo
operator|-
name|the_ins
operator|.
name|fragb
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|fragoff
operator|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
name|wid
argument_list|)
expr_stmt|;
name|to_beg_P
operator|=
name|toP
expr_stmt|;
name|shorts_this_frag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|wid
operator|/
literal|2
init|;
name|m
condition|;
operator|--
name|m
control|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
name|shorts_this_frag
operator|++
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|)
operator|>=
literal|2
operator|*
name|shorts_this_frag
condition|)
block|{
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|-=
literal|2
operator|*
name|shorts_this_frag
expr_stmt|;
break|break;
block|}
name|wid
operator|=
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
expr_stmt|;
if|if
condition|(
name|wid
operator|==
literal|0
condition|)
continue|continue;
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|=
literal|0
expr_stmt|;
name|wid
operator|=
operator|(
name|wid
operator|==
literal|'b'
operator|)
condition|?
literal|1
else|:
operator|(
name|wid
operator|==
literal|'w'
operator|)
condition|?
literal|2
else|:
operator|(
name|wid
operator|==
literal|'l'
operator|)
condition|?
literal|4
else|:
literal|4000
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|-
name|the_ins
operator|.
name|numo
operator|*
literal|2
operator|+
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|)
argument_list|,
name|wid
argument_list|,
operator|&
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|exp
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|get_reloc_code
argument_list|(
name|wid
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pic_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel_fix
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
call|(
name|relax_substateT
call|)
argument_list|(
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fragty
argument_list|)
argument_list|,
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fadd
argument_list|,
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|foff
argument_list|,
name|to_beg_P
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|the_ins
operator|.
name|numo
operator|-
name|the_ins
operator|.
name|fragb
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|fragoff
operator|)
expr_stmt|;
name|shorts_this_frag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|toP
operator|=
name|frag_more
argument_list|(
name|n
operator|*
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
name|shorts_this_frag
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
name|int
name|wid
decl_stmt|;
name|wid
operator|=
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
expr_stmt|;
if|if
condition|(
name|wid
operator|==
literal|0
condition|)
continue|continue;
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|=
literal|0
expr_stmt|;
name|wid
operator|=
operator|(
name|wid
operator|==
literal|'b'
operator|)
condition|?
literal|1
else|:
operator|(
name|wid
operator|==
literal|'w'
operator|)
condition|?
literal|2
else|:
operator|(
name|wid
operator|==
literal|'l'
operator|)
condition|?
literal|4
else|:
literal|4000
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|+
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|-
name|shorts_this_frag
operator|*
literal|2
operator|)
argument_list|,
name|wid
argument_list|,
operator|&
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|exp
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|get_reloc_code
argument_list|(
name|wid
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pic_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel_fix
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Comparison function used by qsort to rank the opcode entries by name.  */
end_comment

begin_function
specifier|static
name|int
name|m68k_compare_opcode
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|struct
name|m68k_opcode
modifier|*
name|op1
decl_stmt|,
modifier|*
name|op2
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
literal|0
return|;
name|op1
operator|=
operator|*
operator|(
expr|struct
name|m68k_opcode
operator|*
operator|*
operator|)
name|v1
expr_stmt|;
name|op2
operator|=
operator|*
operator|(
expr|struct
name|m68k_opcode
operator|*
operator|*
operator|)
name|v2
expr_stmt|;
comment|/* Compare the two names.  If different, return the comparison.      If the same, return the order they are in the opcode table.  */
name|ret
operator|=
name|strcmp
argument_list|(
name|op1
operator|->
name|name
argument_list|,
name|op2
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|op1
operator|<
name|op2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|ins
decl_stmt|;
name|struct
name|m68k_incant
modifier|*
name|hack
decl_stmt|,
modifier|*
name|slak
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Empty string, or error msg text.  */
name|int
name|i
decl_stmt|;
comment|/* Set up hash tables with 68000 instructions.      similar to what the vax assembler does.  */
comment|/* RMS claims the thing to do is take the m68k-opcode.h table, and make      a copy of it at runtime, adding in the information we want but isn't      there.  I think it'd be better to have an awk script hack the table      at compile time.  Or even just xstr the table and use it as-is.  But      my lord ghod hath spoken, so we do it this way.  Excuse the ugly var      names.  */
if|if
condition|(
name|flag_mri
condition|)
block|{
name|flag_reg_prefix_optional
operator|=
literal|1
expr_stmt|;
name|m68k_abspcadd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_rel32_from_cmdline
condition|)
name|m68k_rel32
operator|=
literal|0
expr_stmt|;
block|}
comment|/* First sort the opcode table into alphabetical order to seperate      the order that the assembler wants to see the opcodes from the      order that the disassembler wants to see them.  */
name|m68k_sorted_opcodes
operator|=
name|xmalloc
argument_list|(
name|m68k_numopcodes
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|m68k_sorted_opcodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_sorted_opcodes
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't allocate m68k_sorted_opcodes of size %d"
argument_list|)
argument_list|,
name|m68k_numopcodes
operator|*
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|m68k_sorted_opcodes
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m68k_numopcodes
init|;
name|i
operator|--
condition|;
control|)
name|m68k_sorted_opcodes
index|[
name|i
index|]
operator|=
name|m68k_opcodes
operator|+
name|i
expr_stmt|;
name|qsort
argument_list|(
name|m68k_sorted_opcodes
argument_list|,
name|m68k_numopcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|m68k_sorted_opcodes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|m68k_compare_opcode
argument_list|)
expr_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|robyn
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numopcodes
condition|;
name|i
operator|++
control|)
block|{
name|hack
operator|=
name|slak
operator|=
operator|(
expr|struct
name|m68k_incant
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|robyn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_incant
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|ins
operator|=
name|m68k_sorted_opcodes
index|[
name|i
index|]
expr_stmt|;
comment|/* We *could* ignore insns that don't match our 	     arch here by just leaving them out of the hash.  */
name|slak
operator|->
name|m_operands
operator|=
name|ins
operator|->
name|args
expr_stmt|;
name|slak
operator|->
name|m_opnum
operator|=
name|strlen
argument_list|(
name|slak
operator|->
name|m_operands
argument_list|)
operator|/
literal|2
expr_stmt|;
name|slak
operator|->
name|m_arch
operator|=
name|ins
operator|->
name|arch
expr_stmt|;
name|slak
operator|->
name|m_opcode
operator|=
name|ins
operator|->
name|opcode
expr_stmt|;
comment|/* This is kludgey.  */
name|slak
operator|->
name|m_codenum
operator|=
operator|(
operator|(
name|ins
operator|->
name|match
operator|)
operator|&
literal|0xffffL
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|m68k_numopcodes
operator|&&
operator|!
name|strcmp
argument_list|(
name|ins
operator|->
name|name
argument_list|,
name|m68k_sorted_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
condition|)
block|{
name|slak
operator|->
name|m_next
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|robyn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_incant
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|slak
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|slak
operator|=
name|slak
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|slak
condition|)
do|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|ins
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hack
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|)
argument_list|,
name|ins
operator|->
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numaliases
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|m68k_opcode_aliases
index|[
name|i
index|]
operator|.
name|primary
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
init|=
name|m68k_opcode_aliases
index|[
name|i
index|]
operator|.
name|alias
decl_stmt|;
name|PTR
name|val
init|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error: Can't find %s in hash table"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|alias
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error: Can't hash %s: %s"
argument_list|)
argument_list|,
name|alias
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
comment|/* In MRI mode, all unsized branches are variable sized.  Normally,      they are word sized.  */
if|if
condition|(
name|flag_mri
condition|)
block|{
specifier|static
name|struct
name|m68k_opcode_alias
name|mri_aliases
index|[]
init|=
block|{
block|{
literal|"bhi"
block|,
literal|"jhi"
block|, }
block|,
block|{
literal|"bls"
block|,
literal|"jls"
block|, }
block|,
block|{
literal|"bcc"
block|,
literal|"jcc"
block|, }
block|,
block|{
literal|"bcs"
block|,
literal|"jcs"
block|, }
block|,
block|{
literal|"bne"
block|,
literal|"jne"
block|, }
block|,
block|{
literal|"beq"
block|,
literal|"jeq"
block|, }
block|,
block|{
literal|"bvc"
block|,
literal|"jvc"
block|, }
block|,
block|{
literal|"bvs"
block|,
literal|"jvs"
block|, }
block|,
block|{
literal|"bpl"
block|,
literal|"jpl"
block|, }
block|,
block|{
literal|"bmi"
block|,
literal|"jmi"
block|, }
block|,
block|{
literal|"bge"
block|,
literal|"jge"
block|, }
block|,
block|{
literal|"blt"
block|,
literal|"jlt"
block|, }
block|,
block|{
literal|"bgt"
block|,
literal|"jgt"
block|, }
block|,
block|{
literal|"ble"
block|,
literal|"jle"
block|, }
block|,
block|{
literal|"bra"
block|,
literal|"jra"
block|, }
block|,
block|{
literal|"bsr"
block|,
literal|"jbsr"
block|, }
block|, 	}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|mri_aliases
operator|/
sizeof|sizeof
name|mri_aliases
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mri_aliases
index|[
name|i
index|]
operator|.
name|primary
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
init|=
name|mri_aliases
index|[
name|i
index|]
operator|.
name|alias
decl_stmt|;
name|PTR
name|val
init|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error: Can't find %s in hash table"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|hash_jam
argument_list|(
name|op_hash
argument_list|,
name|alias
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal Error: Can't hash %s: %s"
argument_list|)
argument_list|,
name|alias
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|notend_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|notend_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alt_notend_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|notend_table
index|[
literal|','
index|]
operator|=
literal|1
expr_stmt|;
name|notend_table
index|[
literal|'{'
index|]
operator|=
literal|1
expr_stmt|;
name|notend_table
index|[
literal|'}'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'a'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'d'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'D'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'#'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'&'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'f'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'F'
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|alt_notend_table
index|[
name|REGISTER_PREFIX
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* We need to put '(' in alt_notend_table to handle        cas2 %d0:%d2,%d3:%d4,(%a0):(%a1)  */
name|alt_notend_table
index|[
literal|'('
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We need to put '@' in alt_notend_table to handle        cas2 %d0:%d2,%d3:%d4,@(%d0):@(%d1)  */
name|alt_notend_table
index|[
literal|'@'
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We need to put digits in alt_notend_table to handle        bfextu %d0{24:1},%d0  */
name|alt_notend_table
index|[
literal|'0'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'1'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'2'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'3'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'4'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'5'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'6'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'7'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'8'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'9'
index|]
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|MIT_SYNTAX_ONLY
comment|/* Insert pseudo ops, these have to go into the opcode table since      gas expects pseudo ops to start with a dot.  */
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|mote_pseudo_table
index|[
name|n
index|]
operator|.
name|poc_name
condition|)
block|{
name|hack
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|robyn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_incant
argument_list|)
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|mote_pseudo_table
index|[
name|n
index|]
operator|.
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hack
argument_list|)
expr_stmt|;
name|hack
operator|->
name|m_operands
operator|=
literal|0
expr_stmt|;
name|hack
operator|->
name|m_opnum
operator|=
name|n
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|init_regtable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called when a label is defined.  */
end_comment

begin_function
name|void
name|m68k_frob_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|label_line
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|label_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|labels
expr_stmt|;
name|n
operator|->
name|label
operator|=
name|sym
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|n
operator|->
name|file
argument_list|,
operator|&
name|n
operator|->
name|line
argument_list|)
expr_stmt|;
name|n
operator|->
name|text
operator|=
literal|0
expr_stmt|;
name|labels
operator|=
name|n
expr_stmt|;
name|current_label
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is called when a value that is not an instruction is emitted.  */
end_comment

begin_function
name|void
name|m68k_flush_pending_output
parameter_list|(
name|void
parameter_list|)
block|{
name|current_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called at the end of the assembly, when the final value of    the label is known.  We warn if this is a text symbol aligned at an    odd location.  */
end_comment

begin_function
name|void
name|m68k_frob_symbol
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|reg_section
operator|&&
operator|(
name|int
operator|)
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|<
literal|0
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|~
operator|(
name|int
operator|)
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|label_line
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|labels
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|label
operator|==
name|sym
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|text
condition|)
name|as_warn_where
argument_list|(
name|l
operator|->
name|file
argument_list|,
name|l
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"text label `%s' aligned to odd boundary"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called if we go in or out of MRI mode because of the .mri    pseudo-op.  */
end_comment

begin_function
name|void
name|m68k_mri_mode_change
parameter_list|(
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
operator|!
name|flag_reg_prefix_optional
condition|)
block|{
name|flag_reg_prefix_optional
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|init_regtable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|m68k_abspcadd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_rel32_from_cmdline
condition|)
name|m68k_rel32
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reg_prefix_optional_seen
condition|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX_OPTIONAL
name|flag_reg_prefix_optional
operator|=
name|REGISTER_PREFIX_OPTIONAL
expr_stmt|;
else|#
directive|else
name|flag_reg_prefix_optional
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|init_regtable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|m68k_abspcadd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_rel32_from_cmdline
condition|)
name|m68k_rel32
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|offsetT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|addressT
name|upper_limit
decl_stmt|;
name|offsetT
name|lower_limit
decl_stmt|;
comment|/* This is unnecessary but it convinces the native rs6000 compiler      to generate the code we want.  */
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|buf
operator|+=
name|fixP
operator|->
name|fx_where
expr_stmt|;
comment|/* End ibm compiler workaround.  */
name|val
operator|=
name|SEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return;
switch|switch
condition|(
name|fixP
operator|->
name|fx_size
condition|)
block|{
comment|/* The cast to offsetT below are necessary to make code 	 correct for machines where ints are smaller than offsetT.  */
case|case
literal|1
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|upper_limit
operator|=
literal|0x7f
expr_stmt|;
name|lower_limit
operator|=
operator|-
operator|(
name|offsetT
operator|)
literal|0x80
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|upper_limit
operator|=
literal|0x7fff
expr_stmt|;
name|lower_limit
operator|=
operator|-
operator|(
name|offsetT
operator|)
literal|0x8000
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|upper_limit
operator|=
literal|0x7fffffff
expr_stmt|;
name|lower_limit
operator|=
operator|-
operator|(
name|offsetT
operator|)
literal|0x7fffffff
operator|-
literal|1
expr_stmt|;
comment|/* Avoid constant overflow.  */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up a negative reloc.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* For non-pc-relative values, it's conceivable we might get something      like "0xff" for a byte field.  So extend the upper part of the range      to accept such numbers.  We arbitrarily disallow "-0xff" or "0xff+0xff",      so that we can do any range checking at all.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|!
name|fixP
operator|->
name|fx_signed
condition|)
name|upper_limit
operator|=
name|upper_limit
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|addressT
operator|)
name|val
operator|>
name|upper_limit
operator|&&
operator|(
name|val
operator|>
literal|0
operator|||
name|val
operator|<
name|lower_limit
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"value out of range"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A one byte PC-relative reloc means a short branch.  We can't use      a short branch with a value of 0 or -1, because those indicate      different opcodes (branches with longer offsets).  fixup_segment      in write.c may have clobbered fx_pcrel, so we need to examine the      reloc type.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
operator|&&
name|fixP
operator|->
name|fx_size
operator|==
literal|1
operator|&&
operator|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|||
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|&&
operator|(
name|val
operator|==
literal|0
operator|||
name|val
operator|==
operator|-
literal|1
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid byte branch offset"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size  There is UGLY    MAGIC here. ..    */
end_comment

begin_function
specifier|static
name|void
name|md_convert_frag_1
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|long
name|disp
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Address in object code of the displacement.  */
specifier|register
name|int
name|object_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
comment|/* Address in gas core of the place to store the displacement.  */
comment|/* This convinces the native rs6000 compiler to generate the code we      want.  */
specifier|register
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|buffer_address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* End ibm compiler workaround.  */
comment|/* The displacement of the address, from current location.  */
name|disp
operator|=
name|fragP
operator|->
name|fr_symbol
condition|?
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
else|:
literal|0
expr_stmt|;
name|disp
operator|=
operator|(
name|disp
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
operator|-
name|object_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCHBW
argument_list|,
name|BYTE
argument_list|)
case|:
name|know
argument_list|(
name|issbyte
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"short branch with zero offset: use :w"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC8
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|SHORT
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|SHORT
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|SHORT
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCHBW
argument_list|,
name|SHORT
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|LONG
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0xFF
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|LONG
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x61
condition|)
comment|/* jbsr */
block|{
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative BSR to absolute JSR"
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0xB9
expr_stmt|;
comment|/* JSR with ABSL LONG operand.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|RELAX_RELOC_ABS32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x60
condition|)
comment|/* jbra */
block|{
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative branch to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0xF9
expr_stmt|;
comment|/* JMP with ABSL LONG operand.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|RELAX_RELOC_ABS32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* This cannot happen, because jbsr and jbra are the only two 	     unconditional branches.  */
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|LONG
argument_list|)
case|:
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative conditional branch to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only Bcc 68000 instructions can come here 	 Change bcc into b!cc/jmp absl long.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|0x01
expr_stmt|;
comment|/* Invert bcc.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* Branch offset = 6.  */
comment|/* JF: these used to be fr_opcode[2,3], but they may be in a 	   different frag, in which case referring to them is a no-no. 	   Only fr_opcode[0,1] are guaranteed to work.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
operator|*
name|buffer_address
operator|++
operator|=
operator|(
name|char
operator|)
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
comment|/* Account for jmp instruction.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|RELAX_RELOC_ABS32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SHORT
argument_list|)
case|:
name|know
argument_list|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&
literal|0x40
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|LONG
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* Turn on LONG bit.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|DBCCLBR
argument_list|,
name|SHORT
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|DBCCABSJ
argument_list|,
name|SHORT
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|DBCCLBR
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* Only DBcc instructions can come here. 	 Change dbcc into dbcc/bral. 	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert DBcc to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* Branch offset = 4.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x04
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x60
expr_stmt|;
comment|/* Put in bra pc+6.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x06
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x60
expr_stmt|;
comment|/* Put in bral (0x60ff).  */
operator|*
name|buffer_address
operator|++
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* Account for bra/jmp instructions.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|DBCCABSJ
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* Only DBcc instructions can come here. 	 Change dbcc into dbcc/jmp. 	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative conditional branch to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* Branch offset = 4.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x04
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x60
expr_stmt|;
comment|/* Put in bra pc + 6.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x06
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x4e
expr_stmt|;
comment|/* Put in jmp long (0x4ef9).  */
operator|*
name|buffer_address
operator|++
operator|=
operator|(
name|char
operator|)
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* Account for bra/jmp instructions.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|RELAX_RELOC_ABS32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCREL1632
argument_list|,
name|SHORT
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x3F
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x3A
expr_stmt|;
comment|/* 072 - mode 7.2 */
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCREL1632
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* Already set to mode 7.3; this indicates: PC indirect with 	 suppressed index, 32-bit displacement.  */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x01
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x70
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|BYTE
argument_list|)
case|:
name|assert
argument_list|(
name|fragP
operator|->
name|fr_fix
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|buffer_address
index|[
operator|-
literal|2
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC8
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|SHORT
argument_list|)
case|:
name|assert
argument_list|(
name|fragP
operator|->
name|fr_fix
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|buffer_address
index|[
operator|-
literal|2
index|]
operator||=
literal|0x1
expr_stmt|;
name|buffer_address
index|[
operator|-
literal|1
index|]
operator|=
literal|0x20
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|LONG
argument_list|)
case|:
name|assert
argument_list|(
name|fragP
operator|->
name|fr_fix
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|buffer_address
index|[
operator|-
literal|2
index|]
operator||=
literal|0x1
expr_stmt|;
name|buffer_address
index|[
operator|-
literal|1
index|]
operator|=
literal|0x30
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|SHORT
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|RELAX_RELOC_PC16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|LONG
argument_list|)
case|:
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative conditional branch to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The thing to do here is force it to ABSOLUTE LONG, since 	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway.  */
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|!=
literal|0x3A
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x3F
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x39
expr_stmt|;
comment|/* Mode 7.1 */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|RELAX_RELOC_ABS32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|md_convert_frag_1
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force truly undefined symbols to their maximum size, and generally set up    the frag list to be relaxed    */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
parameter_list|)
block|{
comment|/* Handle SZ_UNDEF first, it can be changed to BYTE or SHORT.  */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_short_refs
condition|)
block|{
comment|/* Symbol is undefined and we want short ref.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Symbol is still undefined.  Make it LONG.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TAB
argument_list|(
name|BRANCHBW
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Symbol is undefined and we don't have long branches.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|DBCCLBR
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|DBCCABSJ
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|PCREL1632
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
operator|||
name|flag_short_refs
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|&&
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|ABSTOPCREL
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Now that SZ_UNDEF are taken care of, check others.  */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BRANCHBWL
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJUNC
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRABSJCOND
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCHBW
argument_list|,
name|BYTE
argument_list|)
case|:
comment|/* We can't do a short jump to the next instruction, so in that 	 case we force word mode.  If the symbol is at the start of a 	 frag, and it is the next frag with any data in it (usually 	 this is just the next frag, but assembler listings may 	 introduce empty frags), we must use word mode.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|sym_frag
operator|->
name|fr_address
condition|)
block|{
name|fragS
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|l
operator|&&
name|l
operator|!=
name|sym_frag
condition|;
name|l
operator|=
name|l
operator|->
name|fr_next
control|)
if|if
condition|(
name|l
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|l
operator|==
name|sym_frag
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_comment
comment|/* the bit-field entries in the relocation_info struct plays hell    with the byte-order problems of cross-assembly.  So as a hack,    I added this mach. dependent ri twiddler.  Ugly, but it gets    you there. -KWK  */
end_comment

begin_comment
comment|/* on m68k: first 4 bytes are normal unsigned long, next three bytes    are symbolnum, most sig. byte first.  Last byte is broken up with    bit 7 as pcrel, bits 6& 5 as length, bit 4 as pcrel, and the lower    nibble as nuthin. (on Sun 3 at least) */
end_comment

begin_comment
comment|/* Translate the internal relocation information into target-specific    format.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|char
modifier|*
name|the_bytes
parameter_list|,
name|struct
name|reloc_info_generic
modifier|*
name|ri
parameter_list|)
block|{
comment|/* This is easy.  */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|->
name|r_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now the fun stuff.  */
name|the_bytes
index|[
literal|4
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|6
index|]
operator|=
name|ri
operator|->
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_length
operator|<<
literal|5
operator|)
operator|&
literal|0x60
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_extern
operator|<<
literal|4
operator|)
operator|&
literal|0x10
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
parameter_list|,
name|addressT
name|to_addr
parameter_list|,
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|valueT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0x6000
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
parameter_list|,
name|addressT
name|to_addr
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
parameter_list|)
block|{
name|valueT
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_LONG_BRANCH
argument_list|(
name|current_architecture
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_keep_pcrel
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Tried to convert PC relative branch to absolute jump"
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0x4EF9
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0x60ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Different values of OK tell what its OK to return.  Things that    aren't OK are an error (what a shock, no?)     0:  Everything is OK    10:  Absolute 1:8	   only    20:  Absolute 0:7	   only    30:  absolute 0:15	   only    40:  Absolute 0:31	   only    50:  absolute 0:127	   only    55:  absolute -64:63    only    60:  absolute -128:127  only    70:  absolute 0:4095	   only    80:  absolute -1, 1:7   only    90:  No bignums.          */
end_comment

begin_function
specifier|static
name|int
name|get_num
parameter_list|(
name|struct
name|m68k_exp
modifier|*
name|exp
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
comment|/* Do the same thing the VAX asm does.  */
name|op
argument_list|(
name|exp
argument_list|)
operator|=
name|O_constant
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|10
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression out of range: defaulting to 1"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|ok
condition|)
block|{
case|case
literal|10
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|-
literal|1
operator|>
literal|7
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression out of range: defaulting to 1"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
literal|7
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|30
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
literal|15
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|40
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
literal|32
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|50
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
literal|127
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|55
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|SEXT
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|+
literal|64
operator|>
literal|127
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|60
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|SEXT
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|+
literal|128
operator|>
literal|255
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|70
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
literal|4095
condition|)
block|{
name|outrange
label|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression out of range: defaulting to 0"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|80
case|:
if|if
condition|(
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0xffffffff
operator|&&
operator|(
name|valueT
operator|)
name|TRUNC
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|-
literal|1
operator|>
literal|6
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression out of range: defaulting to 1"
argument_list|)
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<=
literal|0
comment|/* flonum.  */
operator|&&
operator|(
name|ok
operator|==
literal|90
comment|/* no bignums */
operator|||
operator|(
name|ok
operator|>
literal|10
comment|/* Small-int ranges including 0 ok.  */
comment|/* If we have a flonum zero, a zero integer should 		     do as well (e.g., in moveq).  */
operator|&&
name|generic_floating_point_number
operator|.
name|exponent
operator|==
literal|0
operator|&&
name|generic_floating_point_number
operator|.
name|low
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* HACK! Turn it into a long.  */
name|LITTLENUM_TYPE
name|words
index|[
literal|6
index|]
decl_stmt|;
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|2
argument_list|,
literal|8L
argument_list|)
expr_stmt|;
comment|/* These numbers are magic!  */
name|op
argument_list|(
name|exp
argument_list|)
operator|=
name|O_constant
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
name|words
index|[
literal|1
index|]
operator||
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
name|op
argument_list|(
name|exp
argument_list|)
operator|=
name|O_constant
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't deal with expression; defaulting to %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ok
operator|>=
literal|10
operator|&&
name|ok
operator|<=
literal|80
condition|)
block|{
name|op
argument_list|(
name|exp
argument_list|)
operator|=
name|O_constant
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't deal with expression; defaulting to %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exp
operator|->
name|size
operator|!=
name|SIZE_UNSPEC
condition|)
block|{
switch|switch
condition|(
name|exp
operator|->
name|size
condition|)
block|{
case|case
name|SIZE_UNSPEC
case|:
case|case
name|SIZE_LONG
case|:
break|break;
case|case
name|SIZE_BYTE
case|:
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression doesn't fit in BYTE"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZE_WORD
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expression doesn't fit in WORD"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|offs
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These are the back-ends for the various machine dependent pseudo-ops.  */
end_comment

begin_function
specifier|static
name|void
name|s_data1
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|subseg_set
argument_list|(
name|data_section
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_data2
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|subseg_set
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't support putting frags in the BSS segment, we fake it      by marking in_bss, then looking at s_skip for clues.  */
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_even
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
comment|/* JF should be 2? */
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
comment|/* Never make frag if expect extra pass.  */
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_proc
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pseudo-ops handled for MRI compatibility.  */
end_comment

begin_comment
comment|/* This function returns non-zero if the argument is a conditional    pseudo-op.  This is called when checking whether a pending    alignment is needed.  */
end_comment

begin_function
name|int
name|m68k_conditional_pseudoop
parameter_list|(
name|pseudo_typeS
modifier|*
name|pop
parameter_list|)
block|{
return|return
operator|(
name|pop
operator|->
name|poc_handler
operator|==
name|s_mri_if
operator|||
name|pop
operator|->
name|poc_handler
operator|==
name|s_mri_else
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle an MRI style chip specification.  */
end_comment

begin_function
specifier|static
name|void
name|mri_chip
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* We can't use get_symbol_end since the processor names are not proper      symbols.  */
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
condition|)
empty_stmt|;
operator|*
operator|--
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: unrecognized processor name"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'/'
condition|)
name|current_architecture
operator|=
literal|0
expr_stmt|;
else|else
name|current_architecture
operator|&=
name|m68881
operator||
name|m68851
expr_stmt|;
name|current_architecture
operator||=
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|arch
operator|&
operator|~
operator|(
name|m68881
operator||
name|m68851
operator|)
expr_stmt|;
name|control_regs
operator|=
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|control_regs
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'/'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* We can't use get_symbol_end since the processor names are not 	 proper symbols.  */
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
condition|)
empty_stmt|;
operator|*
operator|--
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"68881"
argument_list|)
operator|==
literal|0
condition|)
name|current_architecture
operator||=
name|m68881
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"68851"
argument_list|)
operator|==
literal|0
condition|)
name|current_architecture
operator||=
name|m68851
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The MRI CHIP pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_chip
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|mri_chip
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MRI FOPT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_fopt
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"ID="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
operator|||
name|temp
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad coprocessor id"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m68k_float_copnum
operator|=
name|COP0
operator|+
name|temp
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized fopt option"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The structure used to handle the MRI OPT pseudo-op.  */
end_comment

begin_struct
struct|struct
name|opt_action
block|{
comment|/* The name of the option.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If this is not NULL, just call this function.  The first argument      is the ARG field of this structure, the second argument is      whether the option was negated.  */
name|void
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|on
parameter_list|)
function_decl|;
comment|/* If this is not NULL, and the PFN field is NULL, set the variable      this points to.  Set it to the ARG field if the option was not      negated, and the NOTARG field otherwise.  */
name|int
modifier|*
name|pvar
decl_stmt|;
comment|/* The value to pass to PFN or to assign to *PVAR.  */
name|int
name|arg
decl_stmt|;
comment|/* The value to assign to *PVAR if the option is negated.  If PFN is      NULL, and PVAR is not NULL, and ARG and NOTARG are the same, then      the option may not be negated.  */
name|int
name|notarg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The table used to handle the MRI OPT pseudo-op.  */
end_comment

begin_function_decl
specifier|static
name|void
name|skip_to_comma
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_nest
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_chip
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_list
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_list_symbols
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|opt_action
name|opt_table
index|[]
init|=
block|{
block|{
literal|"abspcadd"
block|,
literal|0
block|,
operator|&
name|m68k_abspcadd
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* We do relaxing, so there is little use for these options.  */
block|{
literal|"b"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"brs"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"brb"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"brl"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"brw"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cex"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"case"
block|,
literal|0
block|,
operator|&
name|symbols_case_sensitive
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"cl"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cre"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"d"
block|,
literal|0
block|,
operator|&
name|flag_keep_locals
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"e"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"f"
block|,
literal|0
block|,
operator|&
name|flag_short_refs
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"frs"
block|,
literal|0
block|,
operator|&
name|flag_short_refs
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"frl"
block|,
literal|0
block|,
operator|&
name|flag_short_refs
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"g"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"i"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mex"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mc"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"md"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nest"
block|,
name|opt_nest
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"next"
block|,
name|skip_to_comma
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"o"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"old"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"op"
block|,
name|skip_to_comma
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"pco"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"p"
block|,
name|opt_chip
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"pcr"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"pcs"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"r"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"quick"
block|,
literal|0
block|,
operator|&
name|m68k_quick
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"rel32"
block|,
literal|0
block|,
operator|&
name|m68k_rel32
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"s"
block|,
name|opt_list
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|opt_list_symbols
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
literal|0
block|,
operator|&
name|flag_no_warnings
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"x"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTCOUNT
value|((int) (sizeof opt_table / sizeof opt_table[0]))
end_define

begin_comment
comment|/* The MRI OPT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_opt
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
do|do
block|{
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|opt_action
modifier|*
name|o
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|t
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"NO"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|o
operator|=
name|opt_table
init|;
name|i
operator|<
name|OPTCOUNT
condition|;
name|i
operator|++
operator|,
name|o
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|s
argument_list|,
name|o
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|pfn
condition|)
block|{
comment|/* Restore input_line_pointer now in case the option 		     takes arguments.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
call|(
modifier|*
name|o
operator|->
name|pfn
call|)
argument_list|(
name|o
operator|->
name|arg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|pvar
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|&&
name|o
operator|->
name|arg
operator|==
name|o
operator|->
name|notarg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"option `%s' may not be negated"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
operator|*
name|o
operator|->
name|pvar
operator|=
name|t
condition|?
name|o
operator|->
name|arg
else|:
name|o
operator|->
name|notarg
expr_stmt|;
block|}
else|else
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|OPTCOUNT
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"option `%s' not recognized"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Move back to terminating character.  */
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip ahead to a comma.  This is used for OPT options which we do    not support and which take arguments.  */
end_comment

begin_function
specifier|static
name|void
name|skip_to_comma
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|on
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the OPT NEST=depth option.  */
end_comment

begin_function
specifier|static
name|void
name|opt_nest
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|on
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'='
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad format of OPT NEST=depth"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|max_macro_nest
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the OPT P=chip option.  */
end_comment

begin_function
specifier|static
name|void
name|opt_chip
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|on
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'='
condition|)
block|{
comment|/* This is just OPT P, which we do not support.  */
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|mri_chip
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the OPT S option.  */
end_comment

begin_function
specifier|static
name|void
name|opt_list
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|listing_list
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the OPT T option.  */
end_comment

begin_function
specifier|static
name|void
name|opt_list_symbols
parameter_list|(
name|int
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
name|listing
operator||=
name|LISTING_SYMBOLS
expr_stmt|;
else|else
name|listing
operator|&=
operator|~
name|LISTING_SYMBOLS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI REG pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_reg
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|m68k_op
name|rop
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|stop
init|=
name|NULL
decl_stmt|;
name|char
name|stopc
decl_stmt|;
if|if
condition|(
name|line_label
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing label"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flag_mri
condition|)
name|stop
operator|=
name|mri_comment_field
argument_list|(
operator|&
name|stopc
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
operator|||
operator|*
name|input_line_pointer
operator|==
name|REGISTER_PREFIX
endif|#
directive|endif
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'/'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|m68k_ip_op
argument_list|(
name|s
argument_list|,
operator|&
name|rop
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rop
operator|.
name|error
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register list"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register list: %s"
argument_list|)
argument_list|,
name|rop
operator|.
name|error
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|REGLST
condition|)
name|mask
operator|=
name|rop
operator|.
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|DREG
condition|)
name|mask
operator|=
literal|1
operator|<<
operator|(
name|rop
operator|.
name|reg
operator|-
name|DATA0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|AREG
condition|)
name|mask
operator|=
literal|1
operator|<<
operator|(
name|rop
operator|.
name|reg
operator|-
name|ADDR0
operator|+
literal|8
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|FPREG
condition|)
name|mask
operator|=
literal|1
operator|<<
operator|(
name|rop
operator|.
name|reg
operator|-
name|FP0
operator|+
literal|16
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|CONTROL
operator|&&
name|rop
operator|.
name|reg
operator|==
name|FPI
condition|)
name|mask
operator|=
literal|1
operator|<<
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|CONTROL
operator|&&
name|rop
operator|.
name|reg
operator|==
name|FPS
condition|)
name|mask
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|.
name|mode
operator|==
name|CONTROL
operator|&&
name|rop
operator|.
name|reg
operator|==
name|FPC
condition|)
name|mask
operator|=
literal|1
operator|<<
literal|26
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register list"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_SEGMENT
argument_list|(
name|line_label
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|line_label
argument_list|,
operator|~
name|mask
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|line_label
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
name|mri_comment_end
argument_list|(
name|stop
argument_list|,
name|stopc
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure is used for the MRI SAVE and RESTORE pseudo-ops.  */
end_comment

begin_struct
struct|struct
name|save_opts
block|{
name|struct
name|save_opts
modifier|*
name|next
decl_stmt|;
name|int
name|abspcadd
decl_stmt|;
name|int
name|symbols_case_sensitive
decl_stmt|;
name|int
name|keep_locals
decl_stmt|;
name|int
name|short_refs
decl_stmt|;
name|int
name|architecture
decl_stmt|;
specifier|const
name|enum
name|m68k_register
modifier|*
name|control_regs
decl_stmt|;
name|int
name|quick
decl_stmt|;
name|int
name|rel32
decl_stmt|;
name|int
name|listing
decl_stmt|;
name|int
name|no_warnings
decl_stmt|;
comment|/* FIXME: We don't save OPT S.  */
block|}
struct|;
end_struct

begin_comment
comment|/* This variable holds the stack of saved options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|save_opts
modifier|*
name|save_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The MRI SAVE pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_save
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|save_opts
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|save_opts
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_opts
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|abspcadd
operator|=
name|m68k_abspcadd
expr_stmt|;
name|s
operator|->
name|symbols_case_sensitive
operator|=
name|symbols_case_sensitive
expr_stmt|;
name|s
operator|->
name|keep_locals
operator|=
name|flag_keep_locals
expr_stmt|;
name|s
operator|->
name|short_refs
operator|=
name|flag_short_refs
expr_stmt|;
name|s
operator|->
name|architecture
operator|=
name|current_architecture
expr_stmt|;
name|s
operator|->
name|control_regs
operator|=
name|control_regs
expr_stmt|;
name|s
operator|->
name|quick
operator|=
name|m68k_quick
expr_stmt|;
name|s
operator|->
name|rel32
operator|=
name|m68k_rel32
expr_stmt|;
name|s
operator|->
name|listing
operator|=
name|listing
expr_stmt|;
name|s
operator|->
name|no_warnings
operator|=
name|flag_no_warnings
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|save_stack
expr_stmt|;
name|save_stack
operator|=
name|s
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MRI RESTORE pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_restore
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|save_opts
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|save_stack
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"restore without save"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|save_stack
expr_stmt|;
name|save_stack
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|m68k_abspcadd
operator|=
name|s
operator|->
name|abspcadd
expr_stmt|;
name|symbols_case_sensitive
operator|=
name|s
operator|->
name|symbols_case_sensitive
expr_stmt|;
name|flag_keep_locals
operator|=
name|s
operator|->
name|keep_locals
expr_stmt|;
name|flag_short_refs
operator|=
name|s
operator|->
name|short_refs
expr_stmt|;
name|current_architecture
operator|=
name|s
operator|->
name|architecture
expr_stmt|;
name|control_regs
operator|=
name|s
operator|->
name|control_regs
expr_stmt|;
name|m68k_quick
operator|=
name|s
operator|->
name|quick
expr_stmt|;
name|m68k_rel32
operator|=
name|s
operator|->
name|rel32
expr_stmt|;
name|listing
operator|=
name|s
operator|->
name|listing
expr_stmt|;
name|flag_no_warnings
operator|=
name|s
operator|->
name|no_warnings
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Types of MRI structured control directives.  */
end_comment

begin_enum
enum|enum
name|mri_control_type
block|{
name|mri_for
block|,
name|mri_if
block|,
name|mri_repeat
block|,
name|mri_while
block|}
enum|;
end_enum

begin_comment
comment|/* This structure is used to stack the MRI structured control    directives.  */
end_comment

begin_struct
struct|struct
name|mri_control_info
block|{
comment|/* The directive within which this one is enclosed.  */
name|struct
name|mri_control_info
modifier|*
name|outer
decl_stmt|;
comment|/* The type of directive.  */
name|enum
name|mri_control_type
name|type
decl_stmt|;
comment|/* Whether an ELSE has been in an IF.  */
name|int
name|else_seen
decl_stmt|;
comment|/* The add or sub statement at the end of a FOR.  */
name|char
modifier|*
name|incr
decl_stmt|;
comment|/* The label of the top of a FOR or REPEAT loop.  */
name|char
modifier|*
name|top
decl_stmt|;
comment|/* The label to jump to for the next iteration, or the else      expression of a conditional.  */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* The label to jump to to break out of the loop, or the label past      the end of a conditional.  */
name|char
modifier|*
name|bottom
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The stack of MRI structured control directives.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mri_control_info
modifier|*
name|mri_control_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current MRI structured control directive index number, used to    generate label names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mri_control_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assemble an instruction for an MRI structured control directive.  */
end_comment

begin_function
specifier|static
name|void
name|mri_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* md_assemble expects the opcode to be in lower case.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|md_assemble
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a new MRI label structured control directive label name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mri_control_label
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%smc%d"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|mri_control_index
argument_list|)
expr_stmt|;
operator|++
name|mri_control_index
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Create a new MRI structured control directive.  */
end_comment

begin_function
specifier|static
name|struct
name|mri_control_info
modifier|*
name|push_mri_control
parameter_list|(
name|enum
name|mri_control_type
name|type
parameter_list|)
block|{
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|mri_control_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mri_control_info
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|n
operator|->
name|else_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|mri_if
operator|||
name|type
operator|==
name|mri_while
condition|)
name|n
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
else|else
name|n
operator|->
name|top
operator|=
name|mri_control_label
argument_list|()
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|mri_control_label
argument_list|()
expr_stmt|;
name|n
operator|->
name|bottom
operator|=
name|mri_control_label
argument_list|()
expr_stmt|;
name|n
operator|->
name|outer
operator|=
name|mri_control_stack
expr_stmt|;
name|mri_control_stack
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Pop off the stack of MRI structured control directives.  */
end_comment

begin_function
specifier|static
name|void
name|pop_mri_control
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|mri_control_stack
expr_stmt|;
name|mri_control_stack
operator|=
name|n
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|top
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recognize a condition code in an MRI structured control expression.  */
end_comment

begin_function
specifier|static
name|int
name|parse_mri_condition
parameter_list|(
name|int
modifier|*
name|pcc
parameter_list|)
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|==
literal|'<'
argument_list|)
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|c1
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'>'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in structured control directive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c1
operator|=
name|TOLOWER
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TOLOWER
argument_list|(
name|c2
argument_list|)
expr_stmt|;
operator|*
name|pcc
operator|=
operator|(
name|c1
operator|<<
literal|8
operator|)
operator||
name|c2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a single operand in an MRI structured control expression.  */
end_comment

begin_function
specifier|static
name|int
name|parse_mri_control_operand
parameter_list|(
name|int
modifier|*
name|pcc
parameter_list|,
name|char
modifier|*
modifier|*
name|leftstart
parameter_list|,
name|char
modifier|*
modifier|*
name|leftstop
parameter_list|,
name|char
modifier|*
modifier|*
name|rightstart
parameter_list|,
name|char
modifier|*
modifier|*
name|rightstop
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
operator|*
name|pcc
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|leftstart
operator|=
name|NULL
expr_stmt|;
operator|*
name|leftstop
operator|=
name|NULL
expr_stmt|;
operator|*
name|rightstart
operator|=
name|NULL
expr_stmt|;
operator|*
name|rightstop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'<'
condition|)
block|{
comment|/* It's just a condition code.  */
return|return
name|parse_mri_condition
argument_list|(
name|pcc
argument_list|)
return|;
block|}
comment|/* Look ahead for the condition code.  */
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'>'
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing condition code in structured control directive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|leftstart
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|leftstop
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|leftstop
operator|>
operator|*
name|leftstart
operator|&&
operator|(
operator|(
operator|*
name|leftstop
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
operator|(
operator|*
name|leftstop
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
operator|*
name|leftstop
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|parse_mri_condition
argument_list|(
name|pcc
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Look ahead for AND or OR or end of line.  */
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
comment|/* We must make sure we don't misinterpret AND/OR at the end of labels!          if d0<eq> #FOOAND and d1<ne> #BAROR then                         ^^^                 ^^ */
if|if
condition|(
operator|(
name|s
operator|==
name|input_line_pointer
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'\t'
operator|)
operator|&&
operator|(
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"AND"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|==
literal|'.'
operator|||
operator|!
name|is_part_of_name
argument_list|(
name|s
index|[
literal|3
index|]
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"OR"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'.'
operator|||
operator|!
name|is_part_of_name
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
operator|*
name|rightstart
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|rightstop
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|rightstop
operator|>
operator|*
name|rightstart
operator|&&
operator|(
operator|(
operator|*
name|rightstop
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
operator|(
operator|*
name|rightstop
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
operator|*
name|rightstop
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MCC
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
value|(((b1)<< 8) | (b2))
end_define

begin_comment
comment|/* Swap the sense of a condition.  This changes the condition so that    it generates the same result when the operands are swapped.  */
end_comment

begin_function
specifier|static
name|int
name|swap_mri_condition
parameter_list|(
name|int
name|cc
parameter_list|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'i'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'s'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|)
return|;
comment|/*<HS> is an alias for<CC>.  */
case|case
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'s'
argument_list|)
case|:
case|case
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'s'
argument_list|)
return|;
comment|/*<LO> is an alias for<CS>.  */
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'o'
argument_list|)
case|:
case|case
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'i'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'p'
argument_list|,
literal|'l'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'m'
argument_list|,
literal|'i'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'m'
argument_list|,
literal|'i'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'p'
argument_list|,
literal|'l'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'e'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'t'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'t'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'t'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'t'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'e'
argument_list|)
return|;
comment|/* Issue a warning for conditions we can not swap.  */
case|case
name|MCC
argument_list|(
literal|'n'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'n'
argument_list|,
literal|'e'
argument_list|)
return|;
comment|// no problem here
case|case
name|MCC
argument_list|(
literal|'e'
argument_list|,
literal|'q'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'e'
argument_list|,
literal|'q'
argument_list|)
return|;
comment|// also no problem
case|case
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'c'
argument_list|)
case|:
case|case
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'s'
argument_list|)
case|:
default|default :
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Condition<%c%c> in structured control directive can not be encoded correctly"
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
name|cc
operator|>>
literal|8
argument_list|)
argument_list|,
call|(
name|char
call|)
argument_list|(
name|cc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Reverse the sense of a condition.  */
end_comment

begin_function
specifier|static
name|int
name|reverse_mri_condition
parameter_list|(
name|int
name|cc
parameter_list|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'i'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'s'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'i'
argument_list|)
return|;
comment|/*<HS> is an alias for<CC> */
case|case
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'o'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'s'
argument_list|)
return|;
comment|/*<LO> is an alias for<CS> */
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'o'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'h'
argument_list|,
literal|'s'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'n'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'e'
argument_list|,
literal|'q'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'e'
argument_list|,
literal|'q'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'n'
argument_list|,
literal|'e'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'c'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'s'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'s'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'v'
argument_list|,
literal|'c'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'p'
argument_list|,
literal|'l'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'m'
argument_list|,
literal|'i'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'m'
argument_list|,
literal|'i'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'p'
argument_list|,
literal|'l'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'t'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'t'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'e'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'t'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'e'
argument_list|)
return|;
case|case
name|MCC
argument_list|(
literal|'l'
argument_list|,
literal|'e'
argument_list|)
case|:
return|return
name|MCC
argument_list|(
literal|'g'
argument_list|,
literal|'t'
argument_list|)
return|;
block|}
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Build an MRI structured control expression.  This generates test    and branch instructions.  It goes to TRUELAB if the condition is    true, and to FALSELAB if the condition is false.  Exactly one of    TRUELAB and FALSELAB will be NULL, meaning to fall through.  QUAL    is the size qualifier for the expression.  EXTENT is the size to    use for the branch.  */
end_comment

begin_function
specifier|static
name|void
name|build_mri_control_operand
parameter_list|(
name|int
name|qual
parameter_list|,
name|int
name|cc
parameter_list|,
name|char
modifier|*
name|leftstart
parameter_list|,
name|char
modifier|*
name|leftstop
parameter_list|,
name|char
modifier|*
name|rightstart
parameter_list|,
name|char
modifier|*
name|rightstop
parameter_list|,
specifier|const
name|char
modifier|*
name|truelab
parameter_list|,
specifier|const
name|char
modifier|*
name|falselab
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|leftstart
operator|!=
name|NULL
condition|)
block|{
name|struct
name|m68k_op
name|leftop
decl_stmt|,
name|rightop
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Swap the compare operands, if necessary, to produce a legal 	 m68k compare instruction.  Comparing a register operand with 	 a non-register operand requires the register to be on the 	 right (cmp, cmpa).  Comparing an immediate value with 	 anything requires the immediate value to be on the left 	 (cmpi).  */
name|c
operator|=
operator|*
name|leftstop
expr_stmt|;
operator|*
name|leftstop
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|m68k_ip_op
argument_list|(
name|leftstart
argument_list|,
operator|&
name|leftop
argument_list|)
expr_stmt|;
operator|*
name|leftstop
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|rightstop
expr_stmt|;
operator|*
name|rightstop
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|m68k_ip_op
argument_list|(
name|rightstart
argument_list|,
operator|&
name|rightop
argument_list|)
expr_stmt|;
operator|*
name|rightstop
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|rightop
operator|.
name|mode
operator|==
name|IMMED
operator|||
operator|(
operator|(
name|leftop
operator|.
name|mode
operator|==
name|DREG
operator|||
name|leftop
operator|.
name|mode
operator|==
name|AREG
operator|)
operator|&&
operator|(
name|rightop
operator|.
name|mode
operator|!=
name|DREG
operator|&&
name|rightop
operator|.
name|mode
operator|!=
name|AREG
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Correct conditional handling: 	     if #1<lt> d0 then  ;means if (1< d0) 		... 	     endi  	     should assemble to:  		cmp #1,d0        if we do *not* swap the operands 		bgt true         we need the swapped condition! 		ble false 	     true: 		... 	     false: 	  */
name|temp
operator|=
name|leftstart
expr_stmt|;
name|leftstart
operator|=
name|rightstart
expr_stmt|;
name|rightstart
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|leftstop
expr_stmt|;
name|leftstop
operator|=
name|rightstop
expr_stmt|;
name|rightstop
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|=
name|swap_mri_condition
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|truelab
operator|==
name|NULL
condition|)
block|{
name|cc
operator|=
name|reverse_mri_condition
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|truelab
operator|=
name|falselab
expr_stmt|;
block|}
if|if
condition|(
name|leftstart
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
operator|(
name|leftstop
operator|-
name|leftstart
operator|)
operator|+
operator|(
name|rightstop
operator|-
name|rightstart
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'c'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'p'
expr_stmt|;
if|if
condition|(
name|qual
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|TOLOWER
argument_list|(
name|qual
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|leftstart
argument_list|,
name|leftstop
operator|-
name|leftstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|leftstop
operator|-
name|leftstart
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|rightstart
argument_list|,
name|rightstop
operator|-
name|rightstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|rightstop
operator|-
name|rightstart
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|truelab
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'b'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|cc
operator|>>
literal|8
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|cc
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|extent
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|TOLOWER
argument_list|(
name|extent
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|truelab
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an MRI structured control expression.  This generates test    and branch instructions.  STOP is where the expression ends.  It    goes to TRUELAB if the condition is true, and to FALSELAB if the    condition is false.  Exactly one of TRUELAB and FALSELAB will be    NULL, meaning to fall through.  QUAL is the size qualifier for the    expression.  EXTENT is the size to use for the branch.  */
end_comment

begin_function
specifier|static
name|void
name|parse_mri_control_expression
parameter_list|(
name|char
modifier|*
name|stop
parameter_list|,
name|int
name|qual
parameter_list|,
specifier|const
name|char
modifier|*
name|truelab
parameter_list|,
specifier|const
name|char
modifier|*
name|falselab
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
modifier|*
name|leftstart
decl_stmt|;
name|char
modifier|*
name|leftstop
decl_stmt|;
name|char
modifier|*
name|rightstart
decl_stmt|;
name|char
modifier|*
name|rightstop
decl_stmt|;
name|c
operator|=
operator|*
name|stop
expr_stmt|;
operator|*
name|stop
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|parse_mri_control_operand
argument_list|(
operator|&
name|cc
argument_list|,
operator|&
name|leftstart
argument_list|,
operator|&
name|leftstop
argument_list|,
operator|&
name|rightstart
argument_list|,
operator|&
name|rightstop
argument_list|)
condition|)
block|{
operator|*
name|stop
operator|=
name|c
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"AND"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|flab
decl_stmt|;
if|if
condition|(
name|falselab
operator|!=
name|NULL
condition|)
name|flab
operator|=
name|falselab
expr_stmt|;
else|else
name|flab
operator|=
name|mri_control_label
argument_list|()
expr_stmt|;
name|build_mri_control_operand
argument_list|(
name|qual
argument_list|,
name|cc
argument_list|,
name|leftstart
argument_list|,
name|leftstop
argument_list|,
name|rightstart
argument_list|,
name|rightstop
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flab
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'.'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|qual
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|qual
operator|=
name|input_line_pointer
index|[
literal|1
index|]
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parse_mri_control_operand
argument_list|(
operator|&
name|cc
argument_list|,
operator|&
name|leftstart
argument_list|,
operator|&
name|leftstop
argument_list|,
operator|&
name|rightstart
argument_list|,
operator|&
name|rightstop
argument_list|)
condition|)
block|{
operator|*
name|stop
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|build_mri_control_operand
argument_list|(
name|qual
argument_list|,
name|cc
argument_list|,
name|leftstart
argument_list|,
name|leftstop
argument_list|,
name|rightstart
argument_list|,
name|rightstop
argument_list|,
name|truelab
argument_list|,
name|falselab
argument_list|,
name|extent
argument_list|)
expr_stmt|;
if|if
condition|(
name|falselab
operator|==
name|NULL
condition|)
name|colon
argument_list|(
name|flab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"OR"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|tlab
decl_stmt|;
if|if
condition|(
name|truelab
operator|!=
name|NULL
condition|)
name|tlab
operator|=
name|truelab
expr_stmt|;
else|else
name|tlab
operator|=
name|mri_control_label
argument_list|()
expr_stmt|;
name|build_mri_control_operand
argument_list|(
name|qual
argument_list|,
name|cc
argument_list|,
name|leftstart
argument_list|,
name|leftstop
argument_list|,
name|rightstart
argument_list|,
name|rightstop
argument_list|,
name|tlab
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'.'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|qual
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|qual
operator|=
name|input_line_pointer
index|[
literal|1
index|]
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parse_mri_control_operand
argument_list|(
operator|&
name|cc
argument_list|,
operator|&
name|leftstart
argument_list|,
operator|&
name|leftstop
argument_list|,
operator|&
name|rightstart
argument_list|,
operator|&
name|rightstop
argument_list|)
condition|)
block|{
operator|*
name|stop
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|build_mri_control_operand
argument_list|(
name|qual
argument_list|,
name|cc
argument_list|,
name|leftstart
argument_list|,
name|leftstop
argument_list|,
name|rightstart
argument_list|,
name|rightstop
argument_list|,
name|truelab
argument_list|,
name|falselab
argument_list|,
name|extent
argument_list|)
expr_stmt|;
if|if
condition|(
name|truelab
operator|==
name|NULL
condition|)
name|colon
argument_list|(
name|tlab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_mri_control_operand
argument_list|(
name|qual
argument_list|,
name|cc
argument_list|,
name|leftstart
argument_list|,
name|leftstop
argument_list|,
name|rightstart
argument_list|,
name|rightstop
argument_list|,
name|truelab
argument_list|,
name|falselab
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
operator|*
name|stop
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|!=
name|stop
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in structured control directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI IF pseudo-op.  This may be a structured control    directive, or it may be a regular assembler conditional, depending    on its operands.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_if
parameter_list|(
name|int
name|qual
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
comment|/* A structured control directive must end with THEN with an      optional qualifier.  */
name|s
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* We only accept '*' as introduction of comments if preceded by white space      or at first column of a line (I think this can't actually happen here?)      This is important when assembling:        if d0<ne> 12(a0,d0*2) then        if d0<ne> #CONST*20   then.  */
while|while
condition|(
operator|!
operator|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|||
operator|(
name|flag_mri
operator|&&
operator|*
name|s
operator|==
literal|'*'
operator|&&
operator|(
name|s
operator|==
name|input_line_pointer
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'\t'
operator|)
operator|)
operator|)
condition|)
operator|++
name|s
expr_stmt|;
operator|--
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|input_line_pointer
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|input_line_pointer
operator|>
literal|1
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|s
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|input_line_pointer
operator|<
literal|3
operator|||
name|strncasecmp
argument_list|(
name|s
operator|-
literal|3
argument_list|,
literal|"THEN"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|qual
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing then"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* It's a conditional.  */
name|s_if
argument_list|(
name|O_ne
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Since this might be a conditional if, this pseudo-op will be      called even if we are supported to be ignoring input.  Double      check now.  Clobber *input_line_pointer so that ignore_input      thinks that this is not a special pseudo-op.  */
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignore_input
argument_list|()
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|n
operator|=
name|push_mri_control
argument_list|(
name|mri_if
argument_list|)
expr_stmt|;
name|parse_mri_control_expression
argument_list|(
name|s
operator|-
literal|3
argument_list|,
name|qual
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|n
operator|->
name|next
argument_list|,
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|?
name|s
index|[
literal|2
index|]
else|:
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|=
name|s
operator|+
literal|3
expr_stmt|;
else|else
name|input_line_pointer
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI else pseudo-op.  If we are currently doing an MRI    structured IF, associate the ELSE with the IF.  Otherwise, assume    it is a conditional else.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_else
parameter_list|(
name|int
name|qual
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|q
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qual
operator|==
literal|'\0'
operator|&&
operator|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_if
operator|||
name|mri_control_stack
operator|->
name|else_seen
operator|)
condition|)
block|{
name|s_else
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignore_input
argument_list|()
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_if
operator|||
name|mri_control_stack
operator|->
name|else_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"else without matching if"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|mri_control_stack
operator|->
name|else_seen
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|mri_control_stack
operator|->
name|bottom
argument_list|)
argument_list|)
expr_stmt|;
name|q
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|qual
argument_list|)
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bra%s %s"
argument_list|,
name|q
argument_list|,
name|mri_control_stack
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI ENDI pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_endi
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_if
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"endi without matching if"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* ignore_input will not return true for ENDI, so we don't need to      worry about checking it again here.  */
if|if
condition|(
operator|!
name|mri_control_stack
operator|->
name|else_seen
condition|)
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|next
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|pop_mri_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI BREAK pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_break
parameter_list|(
name|int
name|extent
parameter_list|)
block|{
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|ex
index|[
literal|2
index|]
decl_stmt|;
name|n
operator|=
name|mri_control_stack
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_for
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_repeat
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_while
condition|)
name|n
operator|=
name|n
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"break outside of structured loop"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|n
operator|->
name|bottom
argument_list|)
argument_list|)
expr_stmt|;
name|ex
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|extent
argument_list|)
expr_stmt|;
name|ex
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bra%s %s"
argument_list|,
name|ex
argument_list|,
name|n
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI NEXT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_next
parameter_list|(
name|int
name|extent
parameter_list|)
block|{
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|ex
index|[
literal|2
index|]
decl_stmt|;
name|n
operator|=
name|mri_control_stack
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_for
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_repeat
operator|&&
name|n
operator|->
name|type
operator|!=
name|mri_while
condition|)
name|n
operator|=
name|n
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"next outside of structured loop"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|n
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|ex
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|extent
argument_list|)
expr_stmt|;
name|ex
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bra%s %s"
argument_list|,
name|ex
argument_list|,
name|n
operator|->
name|next
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI FOR pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_for
parameter_list|(
name|int
name|qual
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|varstart
decl_stmt|,
modifier|*
name|varstop
decl_stmt|;
specifier|const
name|char
modifier|*
name|initstart
decl_stmt|,
modifier|*
name|initstop
decl_stmt|;
specifier|const
name|char
modifier|*
name|endstart
decl_stmt|,
modifier|*
name|endstop
decl_stmt|;
specifier|const
name|char
modifier|*
name|bystart
decl_stmt|,
modifier|*
name|bystop
decl_stmt|;
name|int
name|up
decl_stmt|;
name|int
name|by
decl_stmt|;
name|int
name|extent
decl_stmt|;
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|ex
index|[
literal|2
index|]
decl_stmt|;
comment|/* The syntax is        FOR.q var = init { TO | DOWNTO } end [ BY by ] DO.e      */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|varstart
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Look for the '='.  */
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'='
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'='
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing ="
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|varstop
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|varstop
operator|>
name|varstart
operator|&&
operator|(
name|varstop
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|varstop
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|varstop
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
name|initstart
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Look for TO or DOWNTO.  */
name|up
operator|=
literal|1
expr_stmt|;
name|initstop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"TO"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|initstop
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"DOWNTO"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|initstop
operator|=
name|input_line_pointer
expr_stmt|;
name|up
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|initstop
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing to or downto"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|initstop
operator|>
name|initstart
operator|&&
operator|(
name|initstop
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|initstop
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|initstop
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|endstart
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Look for BY or DO.  */
name|by
operator|=
literal|0
expr_stmt|;
name|endstop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"BY"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|endstop
operator|=
name|input_line_pointer
expr_stmt|;
name|by
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"DO"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'.'
operator|||
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|endstop
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|endstop
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing do"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|endstop
operator|>
name|endstart
operator|&&
operator|(
name|endstop
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|endstop
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|endstop
expr_stmt|;
if|if
condition|(
operator|!
name|by
condition|)
block|{
name|bystart
operator|=
literal|"#1"
expr_stmt|;
name|bystop
operator|=
name|bystart
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|bystart
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Look for DO.  */
name|bystop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"DO"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'.'
operator|||
operator|!
name|is_part_of_name
argument_list|(
name|input_line_pointer
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|bystop
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|bystop
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing do"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bystop
operator|>
name|bystart
operator|&&
operator|(
name|bystop
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|bystop
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|bystop
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'.'
condition|)
name|extent
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|extent
operator|=
name|input_line_pointer
index|[
literal|1
index|]
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* We have fully parsed the FOR operands.  Now build the loop.  */
name|n
operator|=
name|push_mri_control
argument_list|(
name|mri_for
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|50
operator|+
operator|(
name|input_line_pointer
operator|-
name|varstart
operator|)
argument_list|)
expr_stmt|;
comment|/* Move init,var.  */
name|s
operator|=
name|buf
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'o'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'v'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'e'
expr_stmt|;
if|if
condition|(
name|qual
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|TOLOWER
argument_list|(
name|qual
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|initstart
argument_list|,
name|initstop
operator|-
name|initstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|initstop
operator|-
name|initstart
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|varstart
argument_list|,
name|varstop
operator|-
name|varstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|varstop
operator|-
name|varstart
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* cmp end,var.  */
name|s
operator|=
name|buf
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'c'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'p'
expr_stmt|;
if|if
condition|(
name|qual
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|TOLOWER
argument_list|(
name|qual
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|endstart
argument_list|,
name|endstop
operator|-
name|endstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|endstop
operator|-
name|endstart
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|varstart
argument_list|,
name|varstop
operator|-
name|varstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|varstop
operator|-
name|varstart
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* bcc bottom.  */
name|ex
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|extent
argument_list|)
expr_stmt|;
name|ex
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"blt%s %s"
argument_list|,
name|ex
argument_list|,
name|n
operator|->
name|bottom
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bgt%s %s"
argument_list|,
name|ex
argument_list|,
name|n
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Put together the add or sub instruction used by ENDF.  */
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|qual
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|TOLOWER
argument_list|(
name|qual
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|bystart
argument_list|,
name|bystop
operator|-
name|bystart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|bystop
operator|-
name|bystart
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|varstart
argument_list|,
name|varstop
operator|-
name|varstart
argument_list|)
expr_stmt|;
name|s
operator|+=
name|varstop
operator|-
name|varstart
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|->
name|incr
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI ENDF pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_endf
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_for
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"endf without for"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|next
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|mri_control_stack
operator|->
name|incr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mri_control_stack
operator|->
name|incr
argument_list|,
literal|"bra %s"
argument_list|,
name|mri_control_stack
operator|->
name|top
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|mri_control_stack
operator|->
name|incr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mri_control_stack
operator|->
name|incr
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|pop_mri_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI REPEAT pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_repeat
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|push_mri_control
argument_list|(
name|mri_repeat
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI UNTIL pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_until
parameter_list|(
name|int
name|qual
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_repeat
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"until without repeat"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|next
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|parse_mri_control_expression
argument_list|(
name|s
argument_list|,
name|qual
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|mri_control_stack
operator|->
name|top
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|pop_mri_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI WHILE pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_while
parameter_list|(
name|int
name|qual
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|mri_control_info
modifier|*
name|n
decl_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* We only accept '*' as introduction of comments if preceded by white space      or at first column of a line (I think this can't actually happen here?)      This is important when assembling:        while d0<ne> 12(a0,d0*2) do        while d0<ne> #CONST*20   do.  */
while|while
condition|(
operator|!
operator|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|||
operator|(
name|flag_mri
operator|&&
operator|*
name|s
operator|==
literal|'*'
operator|&&
operator|(
name|s
operator|==
name|input_line_pointer
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'\t'
operator|)
operator|)
operator|)
condition|)
name|s
operator|++
expr_stmt|;
operator|--
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|input_line_pointer
operator|>
literal|1
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|s
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|input_line_pointer
operator|<
literal|2
operator|||
name|strncasecmp
argument_list|(
name|s
operator|-
literal|1
argument_list|,
literal|"DO"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing do"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|push_mri_control
argument_list|(
name|mri_while
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|n
operator|->
name|next
argument_list|)
expr_stmt|;
name|parse_mri_control_expression
argument_list|(
name|s
operator|-
literal|1
argument_list|,
name|qual
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|n
operator|->
name|bottom
argument_list|,
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|?
name|s
index|[
literal|2
index|]
else|:
literal|'\0'
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI ENDW pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mri_endw
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|mri_control_stack
operator|==
name|NULL
operator|||
name|mri_control_stack
operator|->
name|type
operator|!=
name|mri_while
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"endw without while"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|mri_control_stack
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bra %s"
argument_list|,
name|mri_control_stack
operator|->
name|next
argument_list|)
expr_stmt|;
name|mri_assemble
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|mri_control_stack
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|pop_mri_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a .cpu directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_m68k_cpu
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|initialized
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"already assembled instructions"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
name|m68k_set_cpu
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse a .arch directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_m68k_arch
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|initialized
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"already assembled instructions"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m68k_set_arch
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Scan extensions. */
do|do
block|{
operator|*
name|input_line_pointer
operator|++
operator|=
name|saved_char
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|input_line_pointer
operator|||
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
break|break;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|m68k_set_extension
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
do|;
block|}
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup a cpu name in TABLE and return the slot found.  Return NULL    if none is found, the caller is responsible for emitting an error    message.  If ALLOW_M is non-zero, we allow an initial 'm' on the    cpu name, if it begins with a '6' (possibly skipping an intervening    'c'.  We also allow a 'c' in the same place.  if NEGATED is    non-zero, we accept a leading 'no-' and *NEGATED is set to true, if    the option is indeed negated.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|m68k_lookup_cpu
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|table
parameter_list|,
name|int
name|allow_m
parameter_list|,
name|int
modifier|*
name|negated
parameter_list|)
block|{
comment|/* allow negated value? */
if|if
condition|(
name|negated
condition|)
block|{
operator|*
name|negated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
block|{
name|arg
operator|+=
literal|3
expr_stmt|;
operator|*
name|negated
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Remove 'm' or 'mc' prefix from 68k variants.  */
if|if
condition|(
name|allow_m
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
name|arg
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
name|arg
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
name|arg
operator|+=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|table
operator|->
name|name
condition|;
name|table
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|table
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|alias
operator|<
operator|-
literal|1
operator|||
name|table
operator|->
name|alias
operator|>
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`%s' is deprecated, use `%s'"
argument_list|)
argument_list|,
name|table
operator|->
name|name
argument_list|,
name|table
index|[
name|table
operator|->
name|alias
operator|<
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the cpu, issuing errors if it is unrecognized, or invalid */
end_comment

begin_function
specifier|static
name|int
name|m68k_set_cpu
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|allow_m
parameter_list|,
name|int
name|silent
parameter_list|)
block|{
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|cpu
decl_stmt|;
name|cpu
operator|=
name|m68k_lookup_cpu
argument_list|(
name|name
argument_list|,
name|m68k_cpus
argument_list|,
name|allow_m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpu
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cpu `%s' unrecognized"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|selected_cpu
operator|&&
name|selected_cpu
operator|!=
name|cpu
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"already selected `%s' processor"
argument_list|)
argument_list|,
name|selected_cpu
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|selected_cpu
operator|=
name|cpu
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the architecture, issuing errors if it is unrecognized, or invalid */
end_comment

begin_function
specifier|static
name|int
name|m68k_set_arch
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|allow_m
parameter_list|,
name|int
name|silent
parameter_list|)
block|{
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|m68k_lookup_cpu
argument_list|(
name|name
argument_list|,
name|m68k_archs
argument_list|,
name|allow_m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arch
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"architecture `%s' unrecognized"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|selected_arch
operator|&&
name|selected_arch
operator|!=
name|arch
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"already selected `%s' architecture"
argument_list|)
argument_list|,
name|selected_arch
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|selected_arch
operator|=
name|arch
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the architecture extension, issuing errors if it is    unrecognized, or invalid */
end_comment

begin_function
specifier|static
name|int
name|m68k_set_extension
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|allow_m
parameter_list|,
name|int
name|silent
parameter_list|)
block|{
name|int
name|negated
decl_stmt|;
specifier|const
name|struct
name|m68k_cpu
modifier|*
name|ext
decl_stmt|;
name|ext
operator|=
name|m68k_lookup_cpu
argument_list|(
name|name
argument_list|,
name|m68k_extensions
argument_list|,
name|allow_m
argument_list|,
operator|&
name|negated
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ext
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"extension `%s' unrecognized"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|negated
condition|)
name|not_current_architecture
operator||=
name|ext
operator|->
name|arch
expr_stmt|;
else|else
name|current_architecture
operator||=
name|ext
operator|->
name|arch
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* md_parse_option    Invocation line includes a switch not recognized by the base assembler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"lSA:m:kQ:V"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"lSA:m:k"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_PIC
value|(OPTION_MD_BASE)
block|{
literal|"pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
define|#
directive|define
name|OPTION_REGISTER_PREFIX_OPTIONAL
value|(OPTION_MD_BASE + 1)
block|{
literal|"register-prefix-optional"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_REGISTER_PREFIX_OPTIONAL
block|}
block|,
define|#
directive|define
name|OPTION_BITWISE_OR
value|(OPTION_MD_BASE + 2)
block|{
literal|"bitwise-or"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BITWISE_OR
block|}
block|,
define|#
directive|define
name|OPTION_BASE_SIZE_DEFAULT_16
value|(OPTION_MD_BASE + 3)
block|{
literal|"base-size-default-16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BASE_SIZE_DEFAULT_16
block|}
block|,
define|#
directive|define
name|OPTION_BASE_SIZE_DEFAULT_32
value|(OPTION_MD_BASE + 4)
block|{
literal|"base-size-default-32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BASE_SIZE_DEFAULT_32
block|}
block|,
define|#
directive|define
name|OPTION_DISP_SIZE_DEFAULT_16
value|(OPTION_MD_BASE + 5)
block|{
literal|"disp-size-default-16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DISP_SIZE_DEFAULT_16
block|}
block|,
define|#
directive|define
name|OPTION_DISP_SIZE_DEFAULT_32
value|(OPTION_MD_BASE + 6)
block|{
literal|"disp-size-default-32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DISP_SIZE_DEFAULT_32
block|}
block|,
define|#
directive|define
name|OPTION_PCREL
value|(OPTION_MD_BASE + 7)
block|{
literal|"pcrel"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PCREL
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* -l means keep external to 2 bit offset 				   rather than 16 bit one.  */
name|flag_short_refs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* -S means that jbsr's always turn into 				   jsr's.  */
name|flag_long_jumps
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_PCREL
case|:
comment|/* --pcrel means never turn PC-relative 				   branches into absolute jumps.  */
name|flag_keep_pcrel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_PIC
case|:
case|case
literal|'k'
case|:
name|flag_want_pic
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* -pic, Position Independent Code.  */
case|case
name|OPTION_REGISTER_PREFIX_OPTIONAL
case|:
name|flag_reg_prefix_optional
operator|=
literal|1
expr_stmt|;
name|reg_prefix_optional_seen
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
case|case
name|OPTION_BITWISE_OR
case|:
block|{
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|m68k_comment_chars
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|n
expr_stmt|;
for|for
control|(
name|s
operator|=
name|m68k_comment_chars
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'|'
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|m68k_comment_chars
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_BASE_SIZE_DEFAULT_16
case|:
name|m68k_index_width_default
operator|=
name|SIZE_WORD
expr_stmt|;
break|break;
case|case
name|OPTION_BASE_SIZE_DEFAULT_32
case|:
name|m68k_index_width_default
operator|=
name|SIZE_LONG
expr_stmt|;
break|break;
case|case
name|OPTION_DISP_SIZE_DEFAULT_16
case|:
name|m68k_rel32
operator|=
literal|0
expr_stmt|;
name|m68k_rel32_from_cmdline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_DISP_SIZE_DEFAULT_32
case|:
name|m68k_rel32
operator|=
literal|1
expr_stmt|;
name|m68k_rel32_from_cmdline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|#
directive|if
name|WARN_DEPRECATED
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-A%s' is deprecated: use `-%s'"
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Intentional fall-through.  */
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
condition|)
name|m68k_set_arch
argument_list|(
name|arg
operator|+
literal|5
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"cpu="
argument_list|,
literal|4
argument_list|)
condition|)
name|m68k_set_cpu
argument_list|(
name|arg
operator|+
literal|4
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m68k_set_extension
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|m68k_set_arch
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|m68k_set_cpu
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Setup tables from the selected arch and/or cpu */
end_comment

begin_function
specifier|static
name|void
name|m68k_init_arch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|not_current_architecture
operator|&
name|current_architecture
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"architecture features both enabled and disabled"
argument_list|)
argument_list|)
expr_stmt|;
name|not_current_architecture
operator|&=
operator|~
name|current_architecture
expr_stmt|;
block|}
if|if
condition|(
name|selected_arch
condition|)
block|{
name|current_architecture
operator||=
name|selected_arch
operator|->
name|arch
expr_stmt|;
name|control_regs
operator|=
name|selected_arch
operator|->
name|control_regs
expr_stmt|;
block|}
else|else
name|current_architecture
operator||=
name|selected_cpu
operator|->
name|arch
expr_stmt|;
name|current_architecture
operator|&=
operator|~
name|not_current_architecture
expr_stmt|;
if|if
condition|(
operator|(
name|current_architecture
operator|&
operator|(
name|cfloat
operator||
name|m68881
operator|)
operator|)
operator|==
operator|(
name|cfloat
operator||
name|m68881
operator|)
condition|)
block|{
comment|/* Determine which float is really meant.  */
if|if
condition|(
name|current_architecture
operator|&
operator|(
name|m68k_mask
operator|&
operator|~
name|m68881
operator|)
condition|)
name|current_architecture
operator|^=
name|cfloat
expr_stmt|;
else|else
name|current_architecture
operator|^=
name|m68881
expr_stmt|;
block|}
if|if
condition|(
name|selected_cpu
condition|)
block|{
name|control_regs
operator|=
name|selected_cpu
operator|->
name|control_regs
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
operator|~
name|selected_cpu
operator|->
name|arch
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not have all features of selected architecture"
argument_list|)
argument_list|)
expr_stmt|;
name|current_architecture
operator|=
name|selected_cpu
operator|->
name|arch
operator|&
operator|~
name|not_current_architecture
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|current_architecture
operator|&
name|m68k_mask
operator|)
operator|&&
operator|(
name|current_architecture
operator|&
operator|~
name|m68k_mask
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"m68k and cf features both selected"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|m68k_mask
condition|)
name|current_architecture
operator|&=
name|m68k_mask
expr_stmt|;
else|else
name|current_architecture
operator|&=
operator|~
name|m68k_mask
expr_stmt|;
block|}
comment|/* Permit m68881 specification with all cpus; those that can't work      with a coprocessor could be doing emulation.  */
if|if
condition|(
name|current_architecture
operator|&
name|m68851
condition|)
block|{
if|if
condition|(
name|current_architecture
operator|&
name|m68040
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"68040 and 68851 specified; mmu instructions may assemble incorrectly"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* What other incompatibilities could we check for?  */
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|||
name|arch_coldfire_p
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|md_relax_table
index|[
name|TAB
argument_list|(
name|PCINDEX
argument_list|,
name|BYTE
argument_list|)
index|]
operator|.
name|rlx_more
operator|=
literal|0
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|default_arch
decl_stmt|;
comment|/* Get the canonical name for the default target CPU.  */
if|if
condition|(
operator|*
name|default_cpu
operator|==
literal|'m'
condition|)
name|default_cpu
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|default_cpu
argument_list|,
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|default_arch
operator|=
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|arch
expr_stmt|;
while|while
condition|(
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|alias
operator|>
literal|0
condition|)
name|i
operator|--
expr_stmt|;
while|while
condition|(
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|alias
operator|<
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|default_cpu
operator|=
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -march=<arch>		set architecture\n\ -mcpu=<cpu>		set cpu [default %s]\n\ "
argument_list|)
argument_list|,
name|default_cpu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68k_extensions
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -m[no-]%-16s enable/disable%s architecture extension\n\ "
argument_list|)
argument_list|,
name|m68k_extensions
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|m68k_extensions
index|[
name|i
index|]
operator|.
name|alias
operator|>
literal|0
condition|?
literal|" ColdFire"
else|:
name|m68k_extensions
index|[
name|i
index|]
operator|.
name|alias
operator|<
literal|0
condition|?
literal|" m68k"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -l			use 1 word for refs to undefined symbols [default 2]\n\ -pic, -k		generate position independent code\n\ -S			turn jbsr into jsr\n\ --pcrel                 never turn PC-relative branches into absolute jumps\n\ --register-prefix-optional\n\ 			recognize register names without prefix character\n\ --bitwise-or		do not treat `|' as a comment character\n\ --base-size-default-16	base reg without size is 16 bits\n\ --base-size-default-32	base reg without size is 32 bits (default)\n\ --disp-size-default-16	displacement with unknown size is 16 bits\n\ --disp-size-default-32	displacement with unknown size is 32 bits (default)\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Architecture variants are: "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68k_archs
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|m68k_archs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Processor variants are: "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|m68k_cpus
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST2
end_ifdef

begin_comment
comment|/* TEST2:  Test md_assemble() */
end_comment

begin_comment
comment|/* Warning, this routine probably doesn't work anymore.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|m68k_it
name|the_ins
decl_stmt|;
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|m68k_ip_begin
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|gets
argument_list|(
name|buf
argument_list|)
operator|||
operator|!
operator|*
name|buf
condition|)
break|break;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'|'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
continue|continue;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|is_label
argument_list|(
name|buf
argument_list|)
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|the_ins
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
argument_list|)
argument_list|)
expr_stmt|;
name|m68k_ip
argument_list|(
operator|&
name|the_ins
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Error %s in %s\n"
argument_list|)
argument_list|,
name|the_ins
operator|.
name|error
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Opcode(%d.%s): "
argument_list|)
argument_list|,
name|the_ins
operator|.
name|numo
argument_list|,
name|the_ins
operator|.
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|the_ins
operator|.
name|numo
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|the_ins
operator|.
name|opcode
index|[
name|n
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|print_the_insn
argument_list|(
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|strlen
argument_list|(
name|the_ins
operator|.
name|args
argument_list|)
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"op%d Error %s in %s\n"
argument_list|,
name|n
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"mode %d, reg %d, "
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|mode
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
condition|)
name|printf
argument_list|(
literal|"Constant: '%.*s', "
argument_list|,
literal|1
operator|+
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|e_const
operator|-
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ireg %d, isiz %d, imul %d, "
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|ireg
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|isiz
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|imul
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
condition|)
name|printf
argument_list|(
literal|"Iadd: '%.*s',"
argument_list|,
literal|1
operator|+
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|e_iadd
operator|-
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|m68k_ip_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_label
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Possible states for relaxation:     0 0	branch offset	byte	(bra, etc)    0 1			word    0 2			long     1 0	indexed offsets	byte	a0@(32,d4:w:1) etc    1 1			word    1 2			long     2 0	two-offset index word-word a0@(32,d4)@(45) etc    2 1			word-long    2 2			long-word    2 3			long-long     */
end_comment

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_AOUT
comment|/* For a.out, force the section size to be aligned.  If we don't do      this, BFD will align it for us, but it will not write out the      final bytes of the section.  This may be a bug in BFD, but it is      easier to fix it here since that is how the other a.out targets      work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the 68k, it is relative to the address of the first extension    word.  The difference between the addresses of the offset and the    first extension word is stored in fx_pcrel_adjust.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|int
name|adjust
decl_stmt|;
comment|/* Because fx_pcrel_adjust is a char, and may be unsigned, we explicitly      sign extend the value here.  */
name|adjust
operator|=
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel_adjust
operator|&
literal|0xff
operator|)
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
literal|64
condition|)
name|adjust
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|-
name|adjust
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
name|void
name|m68k_elf_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arch_coldfire_fpu
argument_list|(
name|current_architecture
argument_list|)
condition|)
name|flags
operator||=
name|EF_M68K_CFV4E
expr_stmt|;
comment|/* Set file-specific flags if this is a cpu32 processor.  */
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|&
name|cpu32
condition|)
name|flags
operator||=
name|EF_M68K_CPU32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|&
name|m68000up
operator|)
operator|&&
operator|!
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|&
name|m68020up
operator|)
condition|)
name|flags
operator||=
name|EF_M68K_M68000
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|mcfisa_a
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|isa_features
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
name|EF_M68K_ISA_A_NODIV
block|,
name|mcfisa_a
block|}
block|,
block|{
name|EF_M68K_ISA_A
block|,
name|mcfisa_a
operator||
name|mcfhwdiv
block|}
block|,
block|{
name|EF_M68K_ISA_A_PLUS
block|,
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfusp
block|}
block|,
block|{
name|EF_M68K_ISA_B_NOUSP
block|,
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
block|}
block|,
block|{
name|EF_M68K_ISA_B
block|,
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfusp
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,       }
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|mac_features
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
name|EF_M68K_MAC
block|,
name|mcfmac
block|}
block|,
block|{
name|EF_M68K_EMAC
block|,
name|mcfemac
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,       }
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|unsigned
name|pattern
decl_stmt|;
name|pattern
operator|=
operator|(
name|current_architecture
operator|&
operator|(
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfusp
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|isa_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|pattern
operator|==
name|isa_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|)
block|{
name|flags
operator||=
name|isa_features
index|[
name|ix
index|]
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isa_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|)
block|{
name|cf_bad
label|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Not a defined coldfire architecture"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current_architecture
operator|&
name|cfloat
condition|)
name|flags
operator||=
name|EF_M68K_FLOAT
operator||
name|EF_M68K_CFV4E
expr_stmt|;
name|pattern
operator|=
name|current_architecture
operator|&
operator|(
name|mcfmac
operator||
name|mcfemac
operator|)
expr_stmt|;
if|if
condition|(
name|pattern
condition|)
block|{
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|mac_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|pattern
operator|==
name|mac_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|)
block|{
name|flags
operator||=
name|mac_features
index|[
name|ix
index|]
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|mac_features
index|[
name|ix
index|]
index|[
literal|1
index|]
condition|)
goto|goto
name|cf_bad
goto|;
block|}
block|}
block|}
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|tc_m68k_regname_to_dw2regnum
parameter_list|(
specifier|const
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|unsigned
name|int
name|regnum
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|regnames
index|[]
init|=
block|{
literal|"d0"
block|,
literal|"d1"
block|,
literal|"d2"
block|,
literal|"d3"
block|,
literal|"d4"
block|,
literal|"d5"
block|,
literal|"d6"
block|,
literal|"d7"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"a6"
block|,
literal|"sp"
block|,
literal|"fp0"
block|,
literal|"fp1"
block|,
literal|"fp2"
block|,
literal|"fp3"
block|,
literal|"fp4"
block|,
literal|"fp5"
block|,
literal|"fp6"
block|,
literal|"fp7"
block|,
literal|"pc"
block|}
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|ARRAY_SIZE
argument_list|(
name|regnames
argument_list|)
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|regname
argument_list|,
name|regnames
index|[
name|regnum
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|regnum
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|tc_m68k_frame_initial_instructions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|sp_regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sp_regno
operator|<
literal|0
condition|)
name|sp_regno
operator|=
name|tc_m68k_regname_to_dw2regnum
argument_list|(
literal|"sp"
argument_list|)
expr_stmt|;
name|cfi_add_CFA_def_cfa
argument_list|(
name|sp_regno
argument_list|,
operator|-
name|DWARF2_CIE_DATA_ALIGNMENT
argument_list|)
expr_stmt|;
name|cfi_add_CFA_offset
argument_list|(
name|DWARF2_DEFAULT_RETURN_COLUMN
argument_list|,
name|DWARF2_CIE_DATA_ALIGNMENT
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

