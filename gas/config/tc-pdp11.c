begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-pdp11.c - pdp11-specific -    Copyright 2001, 2002 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*   Apparently unused functions:     md_convert_frag     md_estimate_size_before_relax     md_create_short_jump     md_create_long_jump */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/pdp11.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|set_option
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_cpu_model
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_machine_model
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flonum_gen2vax
name|PARAMS
argument_list|(
operator|(
name|char
name|format_letter
operator|,
name|FLONUM_TYPE
operator|*
name|f
operator|,
name|LITTLENUM_TYPE
operator|*
name|words
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * A representation for PDP-11 machine code.  */
end_comment

begin_struct
struct|struct
name|pdp11_code
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|additional
decl_stmt|;
comment|/* is there an additional word? */
name|int
name|word
decl_stmt|;
comment|/* additional word, if any */
struct|struct
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
block|}
name|reloc
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Instruction set extensions.  *  * If you change this from an array to something else, please update  * the "PDP-11 instruction set extensions" comment in pdp11.h.  */
end_comment

begin_decl_stmt
name|int
name|pdp11_extension
index|[
name|PDP11_EXT_NUM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Assembly options.  */
end_comment

begin_define
define|#
directive|define
name|ASM_OPT_PIC
value|1
end_define

begin_define
define|#
directive|define
name|ASM_OPT_NUM
value|2
end_define

begin_decl_stmt
name|int
name|asm_option
index|[
name|ASM_OPT_NUM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* as in 0f123.456 */
end_comment

begin_comment
comment|/* or    0H1.234E-12 (see exp chars above) */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dDfF"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|pseudo_even
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pseudo_bss
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|pseudo_bss
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|pseudo_even
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_defaults
parameter_list|()
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|set_option
argument_list|(
literal|"all-extensions"
argument_list|)
expr_stmt|;
name|set_option
argument_list|(
literal|"pic"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|insn_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|init_defaults
argument_list|()
expr_stmt|;
name|insn_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn_hash
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdp11_num_opcodes
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|insn_hash
argument_list|,
name|pdp11_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|pdp11_opcodes
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdp11_num_aliases
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|insn_hash
argument_list|,
name|pdp11_aliases
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|pdp11_aliases
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
name|valueT
name|value
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
comment|/* On a PDP-11, 0x1234 is stored as "\x12\x34", and    * 0x12345678 is stored as "\x56\x78\x12\x34". It's    * anyones guess what 0x123456 would be stored like.    */
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|con
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|con
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|con
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|con
index|[
literal|0
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|con
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|con
index|[
literal|2
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|con
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fix up some data or instructions after we find out the value of a symbol    that they reference.  Knows about order of bytes in address.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|valueT
name|code
decl_stmt|;
name|valueT
name|mask
decl_stmt|;
name|valueT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|size
decl_stmt|;
name|buf
operator|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|code
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
name|mask
operator|=
literal|0xffff
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PDP11_DISP_8_PCREL
case|:
name|mask
operator|=
literal|0x00ff
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PDP11_DISP_6_PCREL
case|:
name|mask
operator|=
literal|0x003f
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|val
operator|+=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|section
operator|->
name|vma
expr_stmt|;
comment|/* *value += fixP->fx_addsy->bsym->section->vma; */
name|code
operator|&=
operator|~
name|mask
expr_stmt|;
name|code
operator||=
operator|(
name|val
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|code
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_chars_to_number
parameter_list|(
name|con
parameter_list|,
name|nbytes
parameter_list|)
name|unsigned
name|char
name|con
index|[]
decl_stmt|;
comment|/* Low order byte 1st.  */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the input.  */
block|{
comment|/* On a PDP-11, 0x1234 is stored as "\x12\x34", and    * 0x12345678 is stored as "\x56\x78\x12\x34". It's    * anyones guess what 0x123456 would be stored like.    */
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
name|con
index|[
literal|0
index|]
return|;
case|case
literal|2
case|:
return|return
operator|(
name|con
index|[
literal|1
index|]
operator|<<
name|BITS_PER_CHAR
operator|)
operator||
name|con
index|[
literal|0
index|]
return|;
case|case
literal|4
case|:
return|return
operator|(
operator|(
operator|(
name|con
index|[
literal|1
index|]
operator|<<
name|BITS_PER_CHAR
operator|)
operator||
name|con
index|[
literal|0
index|]
operator|)
operator|<<
operator|(
literal|2
operator|*
name|BITS_PER_CHAR
operator|)
operator|)
operator||
operator|(
operator|(
name|con
index|[
literal|3
index|]
operator|<<
name|BITS_PER_CHAR
operator|)
operator||
name|con
index|[
literal|2
index|]
operator|)
return|;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|skip_whitespace
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|find_whitespace
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|!=
literal|' '
operator|&&
operator|*
name|str
operator|!=
literal|'\t'
operator|&&
operator|*
name|str
operator|!=
literal|0
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_reg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|str
argument_list|)
operator|==
literal|'r'
condition|)
block|{
name|str
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|operand
operator|->
name|code
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
name|str
operator|++
expr_stmt|;
break|break;
default|default:
name|operand
operator|->
name|error
operator|=
literal|"Bad register name"
expr_stmt|;
return|return
name|str
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"sp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"SP"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|operand
operator|->
name|code
operator|=
literal|6
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"pc"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"PC"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|operand
operator|->
name|code
operator|=
literal|7
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|->
name|error
operator|=
literal|"Bad register name"
expr_stmt|;
return|return
name|str
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_ac5
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"fr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"FR"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ac"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"AC"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
name|operand
operator|->
name|code
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
name|str
operator|++
expr_stmt|;
break|break;
default|default:
name|operand
operator|->
name|error
operator|=
literal|"Bad register name"
expr_stmt|;
return|return
name|str
operator|-
literal|2
return|;
block|}
block|}
else|else
block|{
name|operand
operator|->
name|error
operator|=
literal|"Bad register name"
expr_stmt|;
return|return
name|str
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_ac
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|parse_ac5
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
operator|->
name|error
operator|&&
name|operand
operator|->
name|code
operator|>
literal|3
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Bad register name"
expr_stmt|;
return|return
name|str
operator|-
literal|3
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_expression
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|operand
operator|->
name|reloc
operator|.
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
name|operand
operator|->
name|error
operator|=
literal|"Error in expression"
expr_stmt|;
return|return
name|str
return|;
block|}
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
name|operand
operator|->
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: what follows is broken badly.  You can't deal with differences      in radix conventions this way, because of symbolic constants, constant      expressions made up of pieces of differing radix, etc.  The only      choices are to change ../expr.c to know about pdp11 conventions, or      to accept the fact that gas will use consistent conventions that differ      from those of traditional pdp11 assemblers.  For now, I've      chosen the latter.   paul koning, 12/23/2001   */
block|if (operand->reloc.exp.X_op == O_constant)     {       if (*str == '.') 	str++;       else 	{
comment|/* FIXME: buffer overflow! */
block|char buf[100]; 	  char *end;  	  sprintf (buf, "%ld", operand->reloc.exp.X_add_number); 	  operand->reloc.exp.X_add_number = strtol (buf,&end, 8); 	}     }
endif|#
directive|endif
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_op_no_deferred
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|LITTLENUM_TYPE
name|literal_float
index|[
literal|2
index|]
decl_stmt|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'('
case|:
comment|/* (rn) and (rn)+ */
name|str
operator|=
name|parse_reg
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|')'
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Missing ')'"
expr_stmt|;
return|return
name|str
return|;
block|}
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|operand
operator|->
name|code
operator||=
literal|020
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|->
name|code
operator||=
literal|010
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* immediate */
case|case
literal|'$'
case|:
name|str
operator|=
name|parse_expression
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|operand
operator|->
name|additional
operator|=
name|TRUE
expr_stmt|;
name|operand
operator|->
name|word
operator|=
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
break|break;
case|case
name|O_symbol
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
name|operand
operator|->
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_16
expr_stmt|;
name|operand
operator|->
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|O_big
case|:
if|if
condition|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Error in expression"
expr_stmt|;
break|break;
block|}
comment|/* it's a floating literal...  */
name|know
argument_list|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
argument_list|)
expr_stmt|;
name|flonum_gen2vax
argument_list|(
literal|'f'
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|,
name|literal_float
argument_list|)
expr_stmt|;
name|operand
operator|->
name|word
operator|=
name|literal_float
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|literal_float
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Low order bits truncated in immediate float operand"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|operand
operator|->
name|error
operator|=
literal|"Error in expression"
expr_stmt|;
break|break;
block|}
name|operand
operator|->
name|code
operator|=
literal|027
expr_stmt|;
break|break;
default|default:
comment|/* label, d(rn), -(rn) */
block|{
name|char
modifier|*
name|old
init|=
name|str
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"-("
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* -(rn) */
block|{
name|str
operator|=
name|parse_reg
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|')'
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Missing ')'"
expr_stmt|;
return|return
name|str
return|;
block|}
name|operand
operator|->
name|code
operator||=
literal|040
expr_stmt|;
name|str
operator|++
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_expression
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'('
condition|)
comment|/* label */
block|{
if|if
condition|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Label expected"
expr_stmt|;
return|return
name|old
return|;
block|}
name|operand
operator|->
name|code
operator|=
literal|067
expr_stmt|;
name|operand
operator|->
name|additional
operator|=
literal|1
expr_stmt|;
name|operand
operator|->
name|word
operator|=
literal|0
expr_stmt|;
name|operand
operator|->
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
name|operand
operator|->
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|str
operator|++
expr_stmt|;
comment|/* d(rn) */
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|')'
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Missing ')'"
expr_stmt|;
return|return
name|str
return|;
block|}
name|str
operator|++
expr_stmt|;
name|operand
operator|->
name|additional
operator|=
name|TRUE
expr_stmt|;
name|operand
operator|->
name|code
operator||=
literal|060
expr_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_symbol
case|:
name|operand
operator|->
name|word
operator|=
literal|0
expr_stmt|;
name|operand
operator|->
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
operator|(
name|operand
operator|->
name|code
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
name|operand
operator|->
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|operand
operator|->
name|word
operator|=
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|->
name|word
operator|=
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|operand
operator|->
name|reloc
operator|.
name|exp
operator|.
name|X_op
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_op_noreg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|operand
operator|->
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'@'
operator|||
operator|*
name|str
operator|==
literal|'*'
condition|)
block|{
name|str
operator|=
name|parse_op_no_deferred
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|operand
operator|->
name|code
operator||=
literal|010
expr_stmt|;
block|}
else|else
name|str
operator|=
name|parse_op_no_deferred
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_op
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|operand
operator|->
name|error
operator|=
name|NULL
expr_stmt|;
name|parse_ac5
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
operator|->
name|error
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"Float AC not legal as integer operand"
expr_stmt|;
return|return
name|str
return|;
block|}
return|return
name|parse_op_noreg
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_fop
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|pdp11_code
modifier|*
name|operand
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|parse_ac5
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
operator|->
name|error
condition|)
return|return
name|str
return|;
name|operand
operator|->
name|error
operator|=
name|NULL
expr_stmt|;
name|parse_reg
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
operator|->
name|error
condition|)
block|{
name|operand
operator|->
name|error
operator|=
literal|"General register not legal as float operand"
expr_stmt|;
return|return
name|str
return|;
block|}
return|return
name|parse_op_noreg
argument_list|(
name|str
argument_list|,
name|operand
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_separator
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
operator|(
operator|*
name|str
operator|!=
literal|','
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|error
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|instruction_string
parameter_list|)
name|char
modifier|*
name|instruction_string
decl_stmt|;
block|{
specifier|const
name|struct
name|pdp11_opcode
modifier|*
name|op
decl_stmt|;
name|struct
name|pdp11_code
name|insn
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|str
operator|=
name|skip_whitespace
argument_list|(
name|instruction_string
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|str
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"No instruction found"
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|op
operator|=
operator|(
expr|struct
name|pdp11_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|insn_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|op1.error = NULL;       op1.additional = FALSE;       op1.reloc.type = BFD_RELOC_NONE;       op1.code = 0;       op1.word = 0;       str = parse_expression (str,&op1);       if (op1.error) 	{ 	  as_bad (op1.error); 	  return; 	}        { 	char *to = frag_more (2);  	md_number_to_chars (to, op1.code, 2); 	if (insn.reloc.type != BFD_RELOC_NONE) 	  fix_new_exp (frag_now, to - frag_now->fr_literal, 2,&insn.reloc.exp, insn.reloc.pc_rel, insn.reloc.type);       }
else|#
directive|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown instruction '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|!
name|pdp11_extension
index|[
name|op
operator|->
name|extension
index|]
condition|)
block|{
name|as_warn
argument_list|(
literal|"Unsupported instruction set extension: %s"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|insn
operator|.
name|code
operator|=
name|op
operator|->
name|opcode
expr_stmt|;
name|insn
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|op1
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|op1
operator|.
name|additional
operator|=
name|FALSE
expr_stmt|;
name|op1
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|op2
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|op2
operator|.
name|additional
operator|=
name|FALSE
expr_stmt|;
name|op2
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|str
operator|=
name|p
expr_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
case|case
name|PDP11_OPCODE_NO_OPS
case|:
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
name|str
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_IMM3
case|:
case|case
name|PDP11_OPCODE_IMM6
case|:
case|case
name|PDP11_OPCODE_IMM8
case|:
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'#'
operator|||
operator|*
name|str
operator|==
literal|'$'
condition|)
name|str
operator|++
expr_stmt|;
name|str
operator|=
name|parse_expression
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|op1
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"operand is not an absolute constant"
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
case|case
name|PDP11_OPCODE_IMM3
case|:
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|7
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"3-bit immediate out of range"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PDP11_OPCODE_IMM6
case|:
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0x3f
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"6-bit immediate out of range"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PDP11_OPCODE_IMM8
case|:
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xff
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"8-bit immediate out of range"
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_DISPL
case|:
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|parse_expression
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|op1
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|op1
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_PDP11_DISP_8_PCREL
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Symbol expected"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op1
operator|.
name|code
operator|&
operator|~
literal|0xff
condition|)
block|{
name|err
operator|=
literal|"8-bit displacement out of range"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|new
expr_stmt|;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
name|insn
operator|.
name|reloc
operator|=
name|op1
operator|.
name|reloc
expr_stmt|;
block|}
break|break;
case|case
name|PDP11_OPCODE_REG
case|:
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_OP
case|:
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_FOP
case|:
name|str
operator|=
name|parse_fop
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_REG_OP
case|:
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op2
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_REG_OP_REV
case|:
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op2
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_AC_FOP
case|:
name|str
operator|=
name|parse_ac
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_fop
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_FOP_AC
case|:
name|str
operator|=
name|parse_fop
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_ac
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_AC_OP
case|:
name|str
operator|=
name|parse_ac
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_OP_AC
case|:
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_ac
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_OP_OP
case|:
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op2
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|parse_op
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|additional
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|PDP11_OPCODE_REG_DISPL
case|:
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|str
operator|=
name|parse_reg
argument_list|(
name|str
argument_list|,
operator|&
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|error
condition|)
break|break;
name|insn
operator|.
name|code
operator||=
name|op2
operator|.
name|code
operator|<<
literal|6
expr_stmt|;
name|str
operator|=
name|parse_separator
argument_list|(
name|str
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Missing ','"
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|parse_expression
argument_list|(
name|str
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|op1
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|op1
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_PDP11_DISP_6_PCREL
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|op1
operator|.
name|error
operator|=
literal|"Symbol expected"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op1
operator|.
name|code
operator|&
operator|~
literal|0x3f
condition|)
block|{
name|err
operator|=
literal|"6-bit displacement out of range"
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|new
expr_stmt|;
name|insn
operator|.
name|code
operator||=
name|op1
operator|.
name|code
expr_stmt|;
name|insn
operator|.
name|reloc
operator|=
name|op1
operator|.
name|reloc
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|op
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op1
operator|.
name|error
condition|)
name|err
operator|=
name|op1
operator|.
name|error
expr_stmt|;
elseif|else
if|if
condition|(
name|op2
operator|.
name|error
condition|)
name|err
operator|=
name|op2
operator|.
name|error
expr_stmt|;
else|else
block|{
name|str
operator|=
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
name|err
operator|=
literal|"Too many operands"
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|to
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|insn
operator|.
name|code
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|insn
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|insn
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
name|to
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|additional
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|op1
operator|.
name|word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|op1
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|op1
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|op1
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
name|to
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|op2
operator|.
name|additional
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|op2
operator|.
name|word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|op2
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|op2
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|op2
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|int
name|set_option
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|yes
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"all-extensions"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|pdp11_extension
argument_list|,
operator|~
literal|0
argument_list|,
sizeof|sizeof
name|pdp11_extension
argument_list|)
expr_stmt|;
name|pdp11_extension
index|[
name|PDP11_NONE
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-extensions"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|pdp11_extension
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|pdp11_extension
argument_list|)
expr_stmt|;
name|pdp11_extension
index|[
name|PDP11_BASIC
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yes
operator|=
literal|0
expr_stmt|;
name|arg
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"cis"
argument_list|)
operator|==
literal|0
condition|)
comment|/* commersial instructions */
name|pdp11_extension
index|[
name|PDP11_CIS
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"csm"
argument_list|)
operator|==
literal|0
condition|)
comment|/* call supervisor mode */
name|pdp11_extension
index|[
name|PDP11_CSM
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"eis"
argument_list|)
operator|==
literal|0
condition|)
comment|/* extended instruction set */
name|pdp11_extension
index|[
name|PDP11_EIS
index|]
operator|=
name|pdp11_extension
index|[
name|PDP11_LEIS
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fis"
argument_list|)
operator|==
literal|0
operator|||
comment|/* KEV11 floating-point */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"kev11"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"kev-11"
argument_list|)
operator|==
literal|0
condition|)
name|pdp11_extension
index|[
name|PDP11_FIS
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fpp"
argument_list|)
operator|==
literal|0
operator|||
comment|/* FP-11 floating-point */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fpu"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fp11"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fp-11"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fpj11"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fp-j11"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fpj-11"
argument_list|)
operator|==
literal|0
condition|)
name|pdp11_extension
index|[
name|PDP11_FPP
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"limited-eis"
argument_list|)
operator|==
literal|0
condition|)
comment|/* limited extended insns */
block|{
name|pdp11_extension
index|[
name|PDP11_LEIS
index|]
operator|=
name|yes
expr_stmt|;
if|if
condition|(
operator|!
name|pdp11_extension
index|[
name|PDP11_LEIS
index|]
condition|)
name|pdp11_extension
index|[
name|PDP11_EIS
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mfpt"
argument_list|)
operator|==
literal|0
condition|)
comment|/* move from processor type */
name|pdp11_extension
index|[
name|PDP11_MFPT
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"mproc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
comment|/* multiprocessor insns: */
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"multiproc"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
comment|/* TSTSET, WRTLCK */
name|pdp11_extension
index|[
name|PDP11_MPROC
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mxps"
argument_list|)
operator|==
literal|0
condition|)
comment|/* move from/to proc status */
name|pdp11_extension
index|[
name|PDP11_MXPS
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pic"
argument_list|)
operator|==
literal|0
condition|)
comment|/* position-independent code */
name|asm_option
index|[
name|ASM_OPT_PIC
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"spl"
argument_list|)
operator|==
literal|0
condition|)
comment|/* set priority level */
name|pdp11_extension
index|[
name|PDP11_SPL
index|]
operator|=
name|yes
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ucode"
argument_list|)
operator|==
literal|0
operator|||
comment|/* microcode instructions: */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"microcode"
argument_list|)
operator|==
literal|0
condition|)
comment|/* LDUB, MED, XFC */
name|pdp11_extension
index|[
name|PDP11_UCODE
index|]
operator|=
name|yes
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_cpu_model
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|model
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'k'
condition|)
name|arg
operator|++
expr_stmt|;
operator|*
name|model
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"abdx"
argument_list|,
name|model
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|model
index|[
operator|-
literal|1
index|]
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'f'
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'j'
condition|)
name|model
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|model
index|[
operator|-
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
name|model
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"11"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|arg
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* allow up to two revision letters */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
operator|*
name|model
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
operator|*
name|model
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
operator|*
name|model
operator|++
operator|=
literal|0
expr_stmt|;
name|set_option
argument_list|(
literal|"no-extensions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"a"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* KA11 (11/15/20) */
return|return
literal|1
return|;
comment|/* no extensions */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"b"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* KB11 (11/45/50/55/70) */
return|return
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"spl"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"da"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-A (11/35/40) */
return|return
name|set_option
argument_list|(
literal|"limited-eis"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"db"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
comment|/* KD11-B (11/05/10) */
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"dd"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-D (11/04) */
return|return
literal|1
return|;
comment|/* no extensions */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"de"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-E (11/34) */
return|return
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"df"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
comment|/* KD11-F (11/03) */
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"dh"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
comment|/* KD11-H (11/03) */
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"dq"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-Q (11/03) */
return|return
name|set_option
argument_list|(
literal|"limited-eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"dk"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-K (11/60) */
return|return
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"ucode"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"dz"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* KD11-Z (11/44) */
return|return
name|set_option
argument_list|(
literal|"csm"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mfpt"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"spl"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"f"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* F11 (11/23/24) */
return|return
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mfpt"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"j"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* J11 (11/53/73/83/84/93/94)*/
return|return
name|set_option
argument_list|(
literal|"csm"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mfpt"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"multiproc"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"spl"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"t"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* T11 (11/21) */
return|return
name|set_option
argument_list|(
literal|"limited-eis"
argument_list|)
operator|&&
name|set_option
argument_list|(
literal|"mxps"
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_machine_model
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"pdp-11/"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"pdp11/"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"11/"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"pdp"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|arg
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"11/"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|arg
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"03"
argument_list|)
operator|==
literal|0
condition|)
comment|/* 11/03 */
return|return
name|set_cpu_model
argument_list|(
literal|"kd11f"
argument_list|)
return|;
comment|/* KD11-F */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"04"
argument_list|)
operator|==
literal|0
condition|)
comment|/* 11/04 */
return|return
name|set_cpu_model
argument_list|(
literal|"kd11d"
argument_list|)
return|;
comment|/* KD11-D */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"05"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/05 or 11/10 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"10"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"kd11b"
argument_list|)
return|;
comment|/* KD11-B */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"15"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/15 or 11/20 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"20"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"ka11"
argument_list|)
return|;
comment|/* KA11 */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"21"
argument_list|)
operator|==
literal|0
condition|)
comment|/* 11/21 */
return|return
name|set_cpu_model
argument_list|(
literal|"t11"
argument_list|)
return|;
comment|/* T11 */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"23"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/23 or 11/24 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"24"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"f11"
argument_list|)
return|;
comment|/* F11 */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"34"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/34 or 11/34a */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"34a"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"kd11e"
argument_list|)
return|;
comment|/* KD11-E */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"35"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/35 or 11/40 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"40"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"kd11da"
argument_list|)
return|;
comment|/* KD11-A */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"44"
argument_list|)
operator|==
literal|0
condition|)
comment|/* 11/44 */
return|return
name|set_cpu_model
argument_list|(
literal|"kd11dz"
argument_list|)
return|;
comment|/* KD11-Z */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"45"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/45/50/55/70 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"50"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"55"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"70"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"kb11"
argument_list|)
return|;
comment|/* KB11 */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"60"
argument_list|)
operator|==
literal|0
condition|)
comment|/* 11/60 */
return|return
name|set_cpu_model
argument_list|(
literal|"kd11k"
argument_list|)
return|;
comment|/* KD11-K */
comment|/* FPP? */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"53"
argument_list|)
operator|==
literal|0
operator|||
comment|/* 11/53/73/83/84/93/94 */
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"73"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"83"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"84"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"93"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"94"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_cpu_model
argument_list|(
literal|"j11"
argument_list|)
operator|&&
comment|/* J11 */
name|set_option
argument_list|(
literal|"fpp"
argument_list|)
return|;
comment|/* All J11 machines come */
comment|/* with FPP installed.  */
else|else
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_CPU
value|257
block|{
literal|"cpu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU
block|}
block|,
define|#
directive|define
name|OPTION_MACHINE
value|258
block|{
literal|"machine"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MACHINE
block|}
block|,
define|#
directive|define
name|OPTION_PIC
value|259
block|{
literal|"pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * md_parse_option  *	Invocation line includes a switch not recognized by the base assembler.  *	See if it's a processor-specific option.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|init_defaults
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
if|if
condition|(
name|set_option
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set_cpu_model
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set_machine_model
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|OPTION_CPU
case|:
if|if
condition|(
name|set_cpu_model
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|OPTION_MACHINE
case|:
if|if
condition|(
name|set_machine_model
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|OPTION_PIC
case|:
if|if
condition|(
name|set_option
argument_list|(
literal|"pic"
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
name|as_bad
argument_list|(
literal|"unrecognized option `-%c%s'"
argument_list|,
name|c
argument_list|,
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* One possible way of parsing options.  enum {   OPTION_CSM,   OPTION_CIS,   ... };  struct {   const char *pattern;   int opt;   const char *description; } options;  static struct options extension_opts[] = {   { "Ncsm", OPTION_CSM, 			"allow (disallow) CSM instruction" },   { "Ncis", OPTION_CIS, 			"allow (disallow) commersial instruction set" },   { "Neis", OPTION_EIS, 			"allow (disallow) extended instruction set" },   ...   { "all-extensions", OPTION_ALL_EXTENSIONS, 			"allow all instruction set extensions\n\ 			(this is the default)" },   { "no-extensions", OPTION_NO_EXTENSIONS, 			"disallow all instruction set extensions" },   { "pic", OPTION_PIC, 			"position-independent code" }, };  static struct options cpu_opts[] = {   { "Ka_11_*", OPTION_KA11, "KA11 CPU. ..." },   { "Kb_11_*", OPTION_KB11, "KB11 CPU. ..." },   { "Kd_11_a*", OPTION_KD11A, "KD11-A CPU. ..." },   { "Kd_11_b*", OPTION_KD11B, "KD11-B CPU. ..." },   { "Kd_11_d*", OPTION_KD11D, "KD11-D CPU. ..." },   { "Kd_11_e*", OPTION_KD11E, "KD11-E CPU. ..." },   { "Kd_11_f*", OPTION_KD11F, "KD11-F CPU. ..." },   { "Kd_11_h*", OPTION_KD11H, "KD11-H CPU. ..." },   { "Kd_11_q*", OPTION_KD11Q, "KD11-Q CPU. ..." },   { "Kd_11_z*", OPTION_KD11Z, "KD11-Z CPU. ..." },   { "Df_11_*", OPTION_F11, "F11 CPU. ..." },   { "Dj_11_*", OPTION_J11, "J11 CPU. ..." },   { "Dt_11_*", OPTION_T11, "T11 CPU. ..." }, };  static struct options model_opts[] = {   { "P03", OPTION_PDP11_03, "same as ..." },   { "P04", OPTION_PDP11_04, "same as ..." },   { "P05", OPTION_PDP11_05, "same as ..." },   { "P10", OPTION_PDP11_10, "same as ..." },   { "P15", OPTION_PDP11_15, "same as ..." },   { "P20", OPTION_PDP11_20, "same as ..." },   { "P21", OPTION_PDP11_21, "same as ..." },   { "P24", OPTION_PDP11_24, "same as ..." },   { "P34", OPTION_PDP11_34, "same as ..." },   { "P34a", OPTION_PDP11_34A, "same as ..." },   { "P40", OPTION_PDP11_40, "same as ..." },   { "P44", OPTION_PDP11_44, "same as ..." },   { "P45", OPTION_PDP11_45, "same as ..." },   { "P50", OPTION_PDP11_50, "same as ..." },   { "P53", OPTION_PDP11_53, "same as ..." },   { "P55", OPTION_PDP11_55, "same as ..." },   { "P60", OPTION_PDP11_60, "same as ..." },   { "P70", OPTION_PDP11_70, "same as ..." },   { "P73", OPTION_PDP11_73, "same as ..." },   { "P83", OPTION_PDP11_83, "same as ..." },   { "P84", OPTION_PDP11_84, "same as ..." },   { "P93", OPTION_PDP11_93, "same as ..." },   { "P94", OPTION_PDP11_94, "same as ..." }, };  struct {   const char *title;   struct options *opts;   int num; } all_opts[] = {   { "PDP-11 instruction set extentions",     extension_opts,     sizeof extension_opts / sizeof extension_opts[0] },   { "PDP-11 CPU model options",     cpu_opts,     sizeof cpu_opts / sizeof cpu_opts[0] },   { "PDP-11 machine model options",     model_opts,     sizeof model_opts / sizeof model_opts[0] }, };  int parse_match (char *arg, char *pattern) {   int yes = 1;    while (*pattern)     {       switch (*pattern++) 	{ 	case 'N': 	  if (strncmp (arg, "no-") == 0) 	    { 	      yes = 0; 	      arg += 3; 	    } 	  break;  	case 'K': 	  if (arg[0] == 'k') 	    arg++; 	  break;  	case 'D': 	  if (strncmp (arg, "kd", 2) == 0) 	    arg +=2; 	  break;  	case 'P': 	  if (strncmp (arg, "pdp-11/", 7) == 0) 	    arg += 7; 	  else if (strncmp (arg, "pdp11/", 6) == 0) 	    arg += 6; 	  else if (strncmp (arg, "11/", 3) == 0) 	    arg += 3; 	  break;  	case '_': 	  if (arg[0] == "-") 	    { 	      if (*++arg == 0) 		return 0; 	    } 	  break;  	case '*': 	  return 1;  	default: 	  if (*arg++ != pattern[-1]) 	    return 0; 	}     }    return arg[0] == 0; }  int fprint_opt (stream, pattern)      FILE *stream;      const char *pattern; {   int n;    while (*pattern)     {       switch (*pattern++) 	{ 	case 'N': 	  n += fprintf (stream, "(no-)"); 	  break;  	case 'K': 	  n += fprintf (stream, "k"); 	  break;  	case 'P': 	  n += fprintf (stream "11/"); 	  break;  	case 'D': 	case '_': 	case '*': 	  break;  	default: 	  fputc (pattern[-1], stream); 	  n++; 	}     }    return n; }  int parse_option (char *arg) {   int i, j;    for (i = 0; i< sizeof all_opts / sizeof all_opts[0]; i++)     {       for (j = 0; j< all_opts[i].num; j++) 	{ 	  if (parse_match (arg, all_opts[i].opts[j].pattern)) 	    { 	      set_option (all_opts[i].opts[j].opt); 	      return 1; 	    } 	}     }    return 0; }  static void fprint_space (stream, n)      FILE *stream;      int n; {   while (n--)     fputc (' ', stream); }  void md_show_usage (stream)      FILE *stream; {   int i, j, n;    for (i = 0; i< sizeof all_opts / sizeof all_opts[0]; i++)     {       fprintf (stream "\n%s:\n\n", all_opts[i].title);        for (j = 0; j< all_opts[i].num; j++) 	{ 	  fprintf (stream, "-m"); 	  n = fprintf_opt (stream, all_opts[i].opts[j].pattern); 	  fprint_space (stream, 22 - n); 	  fprintf (stream, "%s\n", all_opts[i].opts[j].description); 	}     } } */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ \n\ PDP-11 instruction set extentions:\n\ \n\ -m(no-)cis		allow (disallow) commersial instruction set\n\ -m(no-)csm		allow (disallow) CSM instruction\n\ -m(no-)eis		allow (disallow) full extended instruction set\n\ -m(no-)fis		allow (disallow) KEV11 floating-point instructions\n\ -m(no-)fpp		allow (disallow) FP-11 floating-point instructions\n\ -m(no-)fpu		allow (disallow) FP-11 floating-point instructions\n\ -m(no-)limited-eis	allow (disallow) limited extended instruction set\n\ -m(no-)mfpt		allow (disallow) processor type instruction\n\ -m(no-)multiproc	allow (disallow) multiprocessor instructions\n\ -m(no-)mxps		allow (disallow) processor status instructions\n\ -m(no-)spl		allow (disallow) SPL instruction\n\ -m(no-)ucode		allow (disallow) microcode instructions\n\ -mall-extensions	allow all instruction set extensions\n\ 			(this is the default)\n\ -mno-extentions		disallow all instruction set extensions\n\ -pic			generate position-indepenent code\n\ \n\ PDP-11 CPU model options:\n\ \n\ -mka11*			KA11 CPU.  base line instruction set only\n\ -mkb11*			KB11 CPU.  enable full EIS and SPL\n\ -mkd11a*		KD11-A CPU.  enable limited EIS\n\ -mkd11b*		KD11-B CPU.  base line instruction set only\n\ -mkd11d*		KD11-D CPU.  base line instruction set only\n\ -mkd11e*		KD11-E CPU.  enable full EIS, MTPS, and MFPS\n\ -mkd11f*		KD11-F CPU.  enable limited EIS, MTPS, and MFPS\n\ -mkd11h*		KD11-H CPU.  enable limited EIS, MTPS, and MFPS\n\ -mkd11q*		KD11-Q CPU.  enable limited EIS, MTPS, and MFPS\n\ -mkd11k*		KD11-K CPU.  enable full EIS, MTPS, MFPS, LDUB, MED,\n\ 			XFC, and MFPT\n\ -mkd11z*		KD11-Z CPU.  enable full EIS, MTPS, MFPS, MFPT, SPL,\n\ 			and CSM\n\ -mf11*			F11 CPU.  enable full EIS, MFPS, MTPS, and MFPT\n\ -mj11*			J11 CPU.  enable full EIS, MTPS, MFPS, MFPT, SPL,\n\ 			CSM, TSTSET, and WRTLCK\n\ -mt11*			T11 CPU.  enable limited EIS, MTPS, and MFPS\n\ \n\ PDP-11 machine model options:\n\ \n\ -m11/03			same as -mkd11f\n\ -m11/04			same as -mkd11d\n\ -m11/05			same as -mkd11b\n\ -m11/10			same as -mkd11b\n\ -m11/15			same as -mka11\n\ -m11/20			same as -mka11\n\ -m11/21			same as -mt11\n\ -m11/23			same as -mf11\n\ -m11/24			same as -mf11\n\ -m11/34			same as -mkd11e\n\ -m11/34a		same as -mkd11e -mfpp\n\ -m11/35			same as -mkd11a\n\ -m11/40			same as -mkd11a\n\ -m11/44			same as -mkd11z\n\ -m11/45			same as -mkb11\n\ -m11/50			same as -mkb11\n\ -m11/53			same as -mj11\n\ -m11/55			same as -mkb11\n\ -m11/60			same as -mkd11k\n\ -m11/70			same as -mkb11\n\ -m11/73			same as -mj11\n\ -m11/83			same as -mj11\n\ -m11/84			same as -mj11\n\ -m11/93			same as -mj11\n\ -m11/94			same as -mj11\n\ "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_size
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* This is taken account for in md_apply_fix3().  */
name|reloc
operator|->
name|addend
operator|=
operator|-
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Can not represent %s relocation in this object file format"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|void
name|pseudo_bss
parameter_list|(
name|c
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pseudo_even
parameter_list|(
name|c
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|alignment
init|=
literal|1
decl_stmt|;
comment|/* 2^1 */
name|frag_align
argument_list|(
name|alignment
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of tc-pdp11.c */
end_comment

end_unit

