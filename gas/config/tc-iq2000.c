begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-iq2000.c -- Assembler for the Sitera IQ2000.    Copyright (C) 2003, 2004, 2005 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/iq2000-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/iq2000-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/iq2000.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|iq2000_insn
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default machine.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_iq2000
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_IQ2000_CPU_IQ2000
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|iq2000_mach
init|=
name|bfd_mach_iq2000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_mach
init|=
operator|(
literal|1
operator|<<
name|MACH_IQ2000
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to set in the elf header.  */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|iq2000_flags
init|=
name|DEFAULT_FLAGS
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|proc
block|{
name|symbolS
modifier|*
name|isym
decl_stmt|;
name|unsigned
name|long
name|reg_mask
decl_stmt|;
name|unsigned
name|long
name|reg_offset
decl_stmt|;
name|unsigned
name|long
name|fpreg_mask
decl_stmt|;
name|unsigned
name|long
name|fpreg_offset
decl_stmt|;
name|unsigned
name|long
name|frame_offset
decl_stmt|;
name|unsigned
name|long
name|frame_reg
decl_stmt|;
name|unsigned
name|long
name|pc_reg
decl_stmt|;
block|}
name|procS
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|procS
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|procS
modifier|*
name|cur_proc_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numprocs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocations against symbols are done in two    parts, with a HI relocation and a LO relocation.  Each relocation    has only 16 bits of space to store an addend.  This means that in    order for the linker to handle carries correctly, it must be able    to locate both the HI and the LO relocation.  This means that the    relocations must appear in order in the relocation table.     In order to implement this, we keep track of each unmatched HI    relocation.  We then sort them so that they immediately precede the    corresponding LO relocation.  */
end_comment

begin_struct
struct|struct
name|iq2000_hi_fixup
block|{
name|struct
name|iq2000_hi_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Next HI fixup.  */
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* This fixup.  */
name|segT
name|seg
decl_stmt|;
comment|/* The section this fixup is in.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The list of unmatched HI relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|iq2000_hi_fixup
modifier|*
name|iq2000_hi_fixup_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro hash table, which we will add to.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|hash_control
modifier|*
name|macro_hash
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Automatically enter conditional branch macros.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|mnemonic
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|expansion
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
block|}
name|iq2000_macro_defs_s
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|abs_args
index|[]
init|=
block|{
literal|"rd"
block|,
literal|"rs"
block|,
literal|"scratch=%1"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|abs_expn
init|=
literal|"\n sra \\rd,\\rs,31\n xor \\scratch,\\rd,\\rs\n sub \\rd,\\scratch,\\rd\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|la_expn
init|=
literal|"\n lui \\reg,%hi(\\label)\n ori \\reg,\\reg,%lo(\\label)\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|la_args
index|[]
init|=
block|{
literal|"reg"
block|,
literal|"label"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bxx_args
index|[]
init|=
block|{
literal|"rs"
block|,
literal|"rt"
block|,
literal|"label"
block|,
literal|"scratch=%1"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bge_expn
init|=
literal|"\n slt \\scratch,\\rs,\\rt\n beq %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bgeu_expn
init|=
literal|"\n sltu \\scratch,\\rs,\\rt\n beq %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bgt_expn
init|=
literal|"\n slt \\scratch,\\rt,\\rs\n bne %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bgtu_expn
init|=
literal|"\n sltu \\scratch,\\rt,\\rs\n bne %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ble_expn
init|=
literal|"\n slt \\scratch,\\rt,\\rs\n beq %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bleu_expn
init|=
literal|"\n sltu \\scratch,\\rt,\\rs\n beq %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|blt_expn
init|=
literal|"\n slt \\scratch,\\rs,\\rt\n bne %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bltu_expn
init|=
literal|"\n sltu \\scratch,\\rs,\\rt\n bne %0,\\scratch,\\label\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sxx_args
index|[]
init|=
block|{
literal|"rd"
block|,
literal|"rs"
block|,
literal|"rt"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sge_expn
init|=
literal|"\n slt \\rd,\\rs,\\rt\n xori \\rd,\\rd,1\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sgeu_expn
init|=
literal|"\n sltu \\rd,\\rs,\\rt\n xori \\rd,\\rd,1\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sle_expn
init|=
literal|"\n slt \\rd,\\rt,\\rs\n xori \\rd,\\rd,1\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sleu_expn
init|=
literal|"\n sltu \\rd,\\rt,\\rs\n xori \\rd,\\rd,1\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sgt_expn
init|=
literal|"\n slt \\rd,\\rt,\\rs\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sgtu_expn
init|=
literal|"\n sltu \\rd,\\rt,\\rs\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sne_expn
init|=
literal|"\n xor \\rd,\\rt,\\rs\n sltu \\rd,%0,\\rd\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|seq_expn
init|=
literal|"\n xor \\rd,\\rt,\\rs\n sltu \\rd,%0,\\rd\n xori \\rd,\\rd,1\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ai32_args
index|[]
init|=
block|{
literal|"rt"
block|,
literal|"rs"
block|,
literal|"imm"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|andi32_expn
init|=
literal|"\n\  .if (\\imm& 0xffff0000 == 0xffff0000)\n\  andoi \\rt,\\rs,%lo(\\imm)\n\  .elseif (\\imm& 0x0000ffff == 0x0000ffff)\n\  andoui \\rt,\\rs,%uhi(\\imm)\n\  .elseif (\\imm& 0xffff0000 == 0x00000000)\n\  andi \\rt,\\rs,%lo(\\imm)\n\  .else\n\  andoui \\rt,\\rs,%uhi(\\imm)\n\  andoi \\rt,\\rt,%lo(\\imm)\n\  .endif\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ori32_expn
init|=
literal|"\n\  .if (\\imm& 0xffff == 0)\n\  orui \\rt,\\rs,%uhi(\\imm)\n\  .elseif (\\imm& 0xffff0000 == 0)\n\  ori \\rt,\\rs,%lo(\\imm)\n\  .else\n\  orui \\rt,\\rs,%uhi(\\imm)\n\  ori \\rt,\\rt,%lo(\\imm)\n\  .endif\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|neg_args
index|[]
init|=
block|{
literal|"rd"
block|,
literal|"rs"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|neg_expn
init|=
literal|"\n sub \\rd,%0,\\rs\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|negu_expn
init|=
literal|"\n subu \\rd,%0,\\rs\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|li_args
index|[]
init|=
block|{
literal|"rt"
block|,
literal|"imm"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|li_expn
init|=
literal|"\n\  .if (\\imm& 0xffff0000 == 0x0)\n\  ori \\rt,%0,\\imm\n\  .elseif (\\imm& 0xffff0000 == 0xffff0000)\n\  addi \\rt,%0,\\imm\n\  .elseif (\\imm& 0x0000ffff == 0)\n\  lui \\rt,%uhi(\\imm)\n\  .else\n\  lui \\rt,%uhi(\\imm)\n\  ori \\rt,\\rt,%lo(\\imm)\n\  .endif\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|iq2000_macro_defs_s
name|iq2000_macro_defs
index|[]
init|=
block|{
block|{
literal|"abs"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|abs_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|abs_args
block|}
block|,
block|{
literal|"la"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|la_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|la_args
block|}
block|,
block|{
literal|"bge"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bge_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"bgeu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bgeu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"bgt"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bgt_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"bgtu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bgtu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"ble"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|ble_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"bleu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bleu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"blt"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|blt_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"bltu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bltu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|bxx_args
block|}
block|,
block|{
literal|"sge"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sge_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sgeu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sgeu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sle"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sle_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sleu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sleu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sgt"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sgt_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sgtu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sgtu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"seq"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|seq_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"sne"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sne_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|sxx_args
block|}
block|,
block|{
literal|"neg"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|neg_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|neg_args
block|}
block|,
block|{
literal|"negu"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|negu_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|neg_args
block|}
block|,
block|{
literal|"li"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|li_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|li_args
block|}
block|,
block|{
literal|"ori32"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|ori32_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|ai32_args
block|}
block|,
block|{
literal|"andi32"
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|andi32_expn
block|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|ai32_args
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|iq2000_add_macro
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|semantics
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|arguments
parameter_list|)
block|{
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|sb
name|macro_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|namestr
decl_stmt|;
name|macro
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|macro_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|macro
operator|->
name|sub
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|macro_name
argument_list|)
expr_stmt|;
name|macro
operator|->
name|formal_count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formals
operator|=
literal|0
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|macro
operator|->
name|sub
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|arguments
operator|!=
name|NULL
condition|)
block|{
name|formal_entry
modifier|*
modifier|*
name|p
init|=
operator|&
name|macro
operator|->
name|formals
decl_stmt|;
name|macro
operator|->
name|formal_count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formal_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|arguments
operator|!=
name|NULL
condition|)
block|{
name|formal_entry
modifier|*
name|formal
decl_stmt|;
name|formal
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|actual
argument_list|)
expr_stmt|;
comment|/* chlm: Added the following to allow defaulted args.  */
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|arguments
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tt_args
init|=
name|strdup
argument_list|(
operator|*
name|arguments
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tt_dflt
init|=
name|strchr
argument_list|(
name|tt_args
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
operator|*
name|tt_dflt
operator|=
literal|0
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|,
name|tt_args
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|,
name|tt_dflt
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sb_add_string
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|,
operator|*
name|arguments
argument_list|)
expr_stmt|;
comment|/* Add to macro's hash table.  */
name|hash_jam
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
argument_list|,
name|formal
argument_list|)
expr_stmt|;
name|formal
operator|->
name|index
operator|=
name|macro
operator|->
name|formal_count
expr_stmt|;
name|macro
operator|->
name|formal_count
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|formal
expr_stmt|;
name|p
operator|=
operator|&
name|formal
operator|->
name|next
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
operator|++
name|arguments
expr_stmt|;
block|}
block|}
name|sb_add_string
argument_list|(
operator|&
name|macro_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|namestr
operator|=
name|sb_terminate
argument_list|(
operator|&
name|macro_name
argument_list|)
expr_stmt|;
name|hash_jam
argument_list|(
name|macro_hash
argument_list|,
name|namestr
argument_list|,
name|macro
argument_list|)
expr_stmt|;
name|macro_defined
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iq2000_load_macros
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mcnt
init|=
name|ARRAY_SIZE
argument_list|(
name|iq2000_macro_defs
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcnt
condition|;
name|i
operator|++
control|)
name|iq2000_add_macro
argument_list|(
name|iq2000_macro_defs
index|[
name|i
index|]
operator|.
name|mnemonic
argument_list|,
operator|*
name|iq2000_macro_defs
index|[
name|i
index|]
operator|.
name|expansion
argument_list|,
name|iq2000_macro_defs
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|iq2000_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
name|cpu_mach
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|iq2000_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
comment|/* Set the ELF flags if desired.  */
if|if
condition|(
name|iq2000_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|iq2000_flags
argument_list|)
expr_stmt|;
comment|/* Set the machine type */
name|bfd_default_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_iq2000
argument_list|,
name|iq2000_mach
argument_list|)
expr_stmt|;
name|iq2000_load_macros
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|long
name|delayed_load_register
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_insn_had_delay_slot
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_insn_has_load_delay
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_insn_unconditional_jump
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_insn_was_ldw
init|=
literal|0
decl_stmt|;
name|iq2000_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|iq2000_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We need to generate an error if there's a yielding instruction in the delay      slot of a control flow modifying instruction (jump (yes), load (no))  */
if|if
condition|(
operator|(
name|last_insn_had_delay_slot
operator|&&
operator|!
name|last_insn_has_load_delay
operator|)
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_YIELD_INSN
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"the yielding instruction %s may not be in a delay slot."
argument_list|)
argument_list|,
name|CGEN_INSN_NAME
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Warn about odd numbered base registers for paired-register      instructions like LDW.  On iq2000, result is always rt.  */
if|if
condition|(
name|iq2000_mach
operator|==
name|bfd_mach_iq2000
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_EVEN_REG_NUM
argument_list|)
operator|&&
operator|(
name|insn
operator|.
name|fields
operator|.
name|f_rt
operator|%
literal|2
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register number (R%ld) for double word access must be even."
argument_list|)
argument_list|,
name|insn
operator|.
name|fields
operator|.
name|f_rt
argument_list|)
expr_stmt|;
comment|/* Warn about insns that reference the target of a previous load.  */
comment|/* NOTE: R0 is a special case and is not subject to load delays (except for ldw).  */
if|if
condition|(
name|delayed_load_register
operator|&&
operator|(
name|last_insn_has_load_delay
operator|||
name|last_insn_was_ldw
operator|)
condition|)
block|{
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RD
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rd
operator|==
name|delayed_load_register
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand references R%ld of previous load."
argument_list|)
argument_list|,
name|insn
operator|.
name|fields
operator|.
name|f_rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RS
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rs
operator|==
name|delayed_load_register
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand references R%ld of previous load."
argument_list|)
argument_list|,
name|insn
operator|.
name|fields
operator|.
name|f_rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RT
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rt
operator|==
name|delayed_load_register
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand references R%ld of previous load."
argument_list|)
argument_list|,
name|insn
operator|.
name|fields
operator|.
name|f_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_R31
argument_list|)
operator|&&
name|delayed_load_register
operator|==
literal|31
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"instruction implicitly accesses R31 of previous load."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about insns that reference the (target + 1) of a previous ldw.  */
if|if
condition|(
name|last_insn_was_ldw
condition|)
block|{
if|if
condition|(
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RD
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rd
operator|==
name|delayed_load_register
operator|+
literal|1
operator|)
operator|||
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RS
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rs
operator|==
name|delayed_load_register
operator|+
literal|1
operator|)
operator|||
operator|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_USES_RT
argument_list|)
operator|&&
name|insn
operator|.
name|fields
operator|.
name|f_rt
operator|==
name|delayed_load_register
operator|+
literal|1
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand references R%ld of previous load."
argument_list|)
argument_list|,
name|delayed_load_register
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|last_insn_had_delay_slot
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_DELAY_SLOT
argument_list|)
expr_stmt|;
name|last_insn_has_load_delay
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_LOAD_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn_unconditional_jump
condition|)
name|last_insn_has_load_delay
operator|=
name|last_insn_unconditional_jump
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
argument_list|,
literal|"j"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
argument_list|,
literal|"jal"
argument_list|)
condition|)
name|last_insn_unconditional_jump
operator|=
literal|1
expr_stmt|;
comment|/* The meaning of EVEN_REG_NUM was overloaded to also imply LDW.  Since      that's not true for IQ10, let's make the above logic specific to LDW.  */
name|last_insn_was_ldw
operator|=
operator|!
name|strcmp
argument_list|(
literal|"ldw"
argument_list|,
name|CGEN_INSN_NAME
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The assumption here is that the target of a load is always rt.  */
name|delayed_load_register
operator|=
name|insn
operator|.
name|fields
operator|.
name|f_rt
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|old_fr_fix
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
comment|/* The only thing we have to handle here are symbols outside of the      current segment.  They may be undefined or in a different segment in      which case linker scripts may place them anywhere.      However, we can't finish the fragment here and emit the reloc as insn      alignment requirements may move the insn about.  */
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section). 	 Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
comment|/* Return the address of the delay slot.  */
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|IQ2000_OPERAND_OFFSET
case|:
return|return
name|BFD_RELOC_16_PCREL_S2
return|;
case|case
name|IQ2000_OPERAND_JMPTARG
case|:
return|return
name|BFD_RELOC_IQ2000_OFFSET_16
return|;
case|case
name|IQ2000_OPERAND_JMPTARGQ10
case|:
return|return
name|BFD_RELOC_NONE
return|;
case|case
name|IQ2000_OPERAND_HI16
case|:
return|return
name|BFD_RELOC_HI16
return|;
case|case
name|IQ2000_OPERAND_LO16
case|:
return|return
name|BFD_RELOC_LO16
return|;
default|default:
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Record a HI16 reloc for later matching with its LO16 cousin.  */
end_comment

begin_function
specifier|static
name|void
name|iq2000_record_hi16
parameter_list|(
name|int
name|reloc_type
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|iq2000_hi_fixup
modifier|*
name|hi_fixup
decl_stmt|;
name|assert
argument_list|(
name|reloc_type
operator|==
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
name|hi_fixup
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|hi_fixup
argument_list|)
expr_stmt|;
name|hi_fixup
operator|->
name|fixp
operator|=
name|fixP
expr_stmt|;
name|hi_fixup
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
name|hi_fixup
operator|->
name|next
operator|=
name|iq2000_hi_fixup_list
expr_stmt|;
name|iq2000_hi_fixup_list
operator|=
name|hi_fixup
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called while parsing an instruction to create a fixup.    We need to check for HI16 relocs and queue them up for later sorting.  */
end_comment

begin_function
name|fixS
modifier|*
name|iq2000_cgen_record_fixup_exp
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|int
name|opinfo
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|fixS
modifier|*
name|fixP
init|=
name|gas_cgen_record_fixup_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|operand
argument_list|,
name|opinfo
argument_list|,
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|type
operator|==
name|IQ2000_OPERAND_HI16
comment|/* If low/high was used, it is recorded in `opinfo'.  */
operator|&&
operator|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|==
name|BFD_RELOC_HI16
operator|||
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|==
name|BFD_RELOC_LO16
operator|)
condition|)
name|iq2000_record_hi16
argument_list|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
argument_list|,
name|fixP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Return BFD reloc type from opinfo field in a fixS.    It's tricky using fx_r_type in iq2000_frob_file because the values    are BFD_RELOC_UNUSED + operand number.  */
end_comment

begin_define
define|#
directive|define
name|FX_OPINFO_R_TYPE
parameter_list|(
name|f
parameter_list|)
value|((f)->fx_cgen.opinfo)
end_define

begin_comment
comment|/* Sort any unmatched HI16 relocs so that they immediately precede    the corresponding LO16 reloc.  This is called before md_apply_fix and    tc_gen_reloc.  */
end_comment

begin_function
name|void
name|iq2000_frob_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|iq2000_hi_fixup
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|iq2000_hi_fixup_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|assert
argument_list|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_HI16
operator|||
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
operator|==
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
comment|/* Check quickly whether the next fixup happens to be a matching low.  */
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
name|FX_OPINFO_R_TYPE
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
argument_list|)
operator|==
name|BFD_RELOC_LO16
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_addsy
operator|&&
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|->
name|fx_offset
condition|)
continue|continue;
comment|/* Look through the fixups for this segment for a matching          `low'.  When we find one, move the high just in front of it.          We do this in two passes.  In the first pass, we try to find          a unique `low'.  In the second pass, we permit multiple          high's relocs for a single `low'.  */
name|seginfo
operator|=
name|seg_info
argument_list|(
name|l
operator|->
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|fixS
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fx_next
control|)
block|{
comment|/* Check whether this is a `low' fixup which matches l->fixp.  */
if|if
condition|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|f
argument_list|)
operator|==
name|BFD_RELOC_LO16
operator|&&
name|f
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|&&
name|f
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|&&
operator|(
name|pass
operator|==
literal|1
operator|||
name|prev
operator|==
name|NULL
operator|||
operator|(
name|FX_OPINFO_R_TYPE
argument_list|(
name|prev
argument_list|)
operator|!=
name|BFD_RELOC_HI16
operator|)
operator|||
name|prev
operator|->
name|fx_addsy
operator|!=
name|f
operator|->
name|fx_addsy
operator|||
name|prev
operator|->
name|fx_offset
operator|!=
name|f
operator|->
name|fx_offset
operator|)
condition|)
block|{
name|fixS
modifier|*
modifier|*
name|pf
decl_stmt|;
comment|/* Move l->fixp before f.  */
for|for
control|(
name|pf
operator|=
operator|&
name|seginfo
operator|->
name|fix_root
init|;
operator|*
name|pf
operator|!=
name|l
operator|->
name|fixp
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|fx_next
control|)
name|assert
argument_list|(
operator|*
name|pf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|l
operator|->
name|fixp
operator|->
name|fx_next
expr_stmt|;
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|seginfo
operator|->
name|fix_root
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
else|else
name|prev
operator|->
name|fx_next
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|as_warn_where
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_file
argument_list|,
name|l
operator|->
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unmatched high relocation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.  */
end_comment

begin_function
name|int
name|iq2000_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the .set pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_iq2000_set
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ignored_arguments
index|[]
init|=
block|{
literal|"reorder"
block|,
literal|"noreorder"
block|,
literal|"at"
block|,
literal|"noat"
block|,
literal|"macro"
block|,
literal|"nomacro"
block|,
literal|"move"
block|,
literal|"novolatile"
block|,
literal|"nomove"
block|,
literal|"volatile"
block|,
literal|"bopt"
block|,
literal|"nobopt"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|ignored
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|save_ILP
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ignored
operator|=
name|ignored_arguments
init|;
operator|*
name|ignored
condition|;
name|ignored
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|ignored
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|ignored
operator|==
name|NULL
condition|)
block|{
comment|/* We'd like to be able to use .set symbol, expn */
name|input_line_pointer
operator|=
name|save_ILP
expr_stmt|;
name|s_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
comment|/* In case of a syntax error, escape back to try next syntax combo.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|gas_cgen_md_operand
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP .  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|iq2000_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|NULL
decl_stmt|;
name|int
name|opindex
init|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
init|=
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|opindex
argument_list|)
decl_stmt|;
name|reloc_type
operator|=
name|md_cgen_lookup_reloc
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Prevent all adjustments to global symbols.  */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|reloc_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
name|sec
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The ELF backend needs to know that we are changing sections, so      that .previous works correctly.  We could do something like check      for a obj_section_change_hook macro, but that might be confusing      as it would not be appropriate to use it in the section changing      functions in read.c, since obj-elf.c intercepts those.  FIXME:      This should be cleaner, somehow.  */
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
literal|'t'
case|:
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'r'
case|:
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The .end directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_iq2000_end
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|p
decl_stmt|;
name|int
name|maybe_text
decl_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|p
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|maybe_text
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end not in text section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_proc_ptr
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .ent directive."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|cur_proc_ptr
operator|->
name|isym
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end symbol does not match .ent symbol."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive missing or unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected simple number."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISXDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator||=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|3
expr_stmt|;
name|val
operator||=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" *input_line_pointer == '%c' 0x%02x\n"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* The .aent and .ent directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_iq2000_ent
parameter_list|(
name|int
name|aent
parameter_list|)
block|{
name|int
name|number
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|maybe_text
decl_stmt|;
name|symbolP
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
name|number
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|maybe_text
operator|=
literal|1
expr_stmt|;
else|else
name|maybe_text
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|maybe_text
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ent or .aent not in text section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
operator|&&
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing `.end'"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
condition|)
block|{
name|cur_proc_ptr
operator|=
operator|&
name|cur_proc
expr_stmt|;
name|memset
argument_list|(
name|cur_proc_ptr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|procS
argument_list|)
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|isym
operator|=
name|symbolP
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|numprocs
operator|++
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .frame directive. If the mdebug section is present (IRIX 5 native)    then ecoff.c (ecoff_directive_frame) is used. For embedded targets,    s_iq2000_frame is used so that we can set the PDR information correctly.    We can't use the ecoff routines because they make reference to the ecoff    symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_iq2000_frame
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|s_ignore
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .fmask and .mask directives. If the mdebug section is present    (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For    embedded targets, s_iq2000_mask is used so that we can set the PDR    information correctly. We can't use the ecoff routines because they    make reference to the ecoff symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_iq2000_mask
parameter_list|(
name|int
name|reg_type
parameter_list|)
block|{
name|s_ignore
argument_list|(
name|reg_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"rdata"
block|,
name|s_change_sec
block|,
literal|'r'
block|}
block|,
block|{
literal|"sdata"
block|,
name|s_change_sec
block|,
literal|'s'
block|}
block|,
block|{
literal|"set"
block|,
name|s_iq2000_set
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|s_iq2000_ent
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_iq2000_end
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|s_iq2000_frame
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|s_iq2000_mask
block|,
literal|'F'
block|}
block|,
block|{
literal|"mask"
block|,
name|s_iq2000_mask
block|,
literal|'R'
block|}
block|,
block|{
literal|"dword"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

