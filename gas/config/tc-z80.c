begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-z80.c -- Assemble code for the Zilog Z80 and ASCII R800    Copyright 2005, 2006 Free Software Foundation, Inc.    Contributed by Arnold Metselaar<arnold_m@operamail.com>     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* Exported constants.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#;\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"RrFf\0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For machine specific options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* None yet.  */
end_comment

begin_enum
enum|enum
name|options
block|{
name|OPTION_MACH_Z80
init|=
name|OPTION_MD_BASE
block|,
name|OPTION_MACH_R800
block|,
name|OPTION_MACH_IUD
block|,
name|OPTION_MACH_WUD
block|,
name|OPTION_MACH_FUD
block|,
name|OPTION_MACH_IUP
block|,
name|OPTION_MACH_WUP
block|,
name|OPTION_MACH_FUP
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|INS_Z80
value|1
end_define

begin_define
define|#
directive|define
name|INS_UNDOC
value|2
end_define

begin_define
define|#
directive|define
name|INS_UNPORT
value|4
end_define

begin_define
define|#
directive|define
name|INS_R800
value|8
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"z80"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_Z80
block|}
block|,
block|{
literal|"r800"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_R800
block|}
block|,
block|{
literal|"ignore-undocumented-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_IUD
block|}
block|,
block|{
literal|"Wnud"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_IUD
block|}
block|,
block|{
literal|"warn-undocumented-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_WUD
block|}
block|,
block|{
literal|"Wud"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_WUD
block|}
block|,
block|{
literal|"forbid-undocumented-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_FUD
block|}
block|,
block|{
literal|"Fud"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_FUD
block|}
block|,
block|{
literal|"ignore-unportable-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_IUP
block|}
block|,
block|{
literal|"Wnup"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_IUP
block|}
block|,
block|{
literal|"warn-unportable-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_WUP
block|}
block|,
block|{
literal|"Wup"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_WUP
block|}
block|,
block|{
literal|"forbid-unportable-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_FUP
block|}
block|,
block|{
literal|"Fup"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MACH_FUP
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|coff_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction classes that silently assembled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ins_ok
init|=
name|INS_Z80
operator||
name|INS_UNDOC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction classes that generate errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ins_err
init|=
name|INS_R800
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction classes actually used, determines machine type.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ins_used
init|=
name|INS_Z80
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|OPTION_MACH_Z80
case|:
name|ins_ok
operator|&=
operator|~
name|INS_R800
expr_stmt|;
name|ins_err
operator||=
name|INS_R800
expr_stmt|;
break|break;
case|case
name|OPTION_MACH_R800
case|:
name|ins_ok
operator|=
name|INS_Z80
operator||
name|INS_UNDOC
operator||
name|INS_R800
expr_stmt|;
name|ins_err
operator|=
name|INS_UNPORT
expr_stmt|;
break|break;
case|case
name|OPTION_MACH_IUD
case|:
name|ins_ok
operator||=
name|INS_UNDOC
expr_stmt|;
name|ins_err
operator|&=
operator|~
name|INS_UNDOC
expr_stmt|;
break|break;
case|case
name|OPTION_MACH_IUP
case|:
name|ins_ok
operator||=
name|INS_UNDOC
operator||
name|INS_UNPORT
expr_stmt|;
name|ins_err
operator|&=
operator|~
operator|(
name|INS_UNDOC
operator||
name|INS_UNPORT
operator|)
expr_stmt|;
break|break;
case|case
name|OPTION_MACH_WUD
case|:
if|if
condition|(
operator|(
name|ins_ok
operator|&
name|INS_R800
operator|)
operator|==
literal|0
condition|)
block|{
name|ins_ok
operator|&=
operator|~
operator|(
name|INS_UNDOC
operator||
name|INS_UNPORT
operator|)
expr_stmt|;
name|ins_err
operator|&=
operator|~
name|INS_UNDOC
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_MACH_WUP
case|:
name|ins_ok
operator|&=
operator|~
name|INS_UNPORT
expr_stmt|;
name|ins_err
operator|&=
operator|~
operator|(
name|INS_UNDOC
operator||
name|INS_UNPORT
operator|)
expr_stmt|;
break|break;
case|case
name|OPTION_MACH_FUD
case|:
if|if
condition|(
operator|(
name|ins_ok
operator|&
name|INS_R800
operator|)
operator|==
literal|0
condition|)
block|{
name|ins_ok
operator|&=
operator|(
name|INS_UNDOC
operator||
name|INS_UNPORT
operator|)
expr_stmt|;
name|ins_err
operator||=
name|INS_UNDOC
operator||
name|INS_UNPORT
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_MACH_FUP
case|:
name|ins_ok
operator|&=
operator|~
name|INS_UNPORT
expr_stmt|;
name|ins_err
operator||=
name|INS_UNPORT
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\ CPU model/instruction set options:\n\ \n\   -z80\t\t  assemble for Z80\n\   -ignore-undocumented-instructions\n\   -Wnud\n\ \tsilently assemble undocumented Z80-instructions that work on R800\n\   -ignore-unportable-instructions\n\   -Wnup\n\ \tsilently assemble all undocumented Z80-instructions\n\   -warn-undocumented-instructions\n\   -Wud\n\ \tissue warnings for undocumented Z80-instructions that work on R800\n\   -warn-unportable-instructions\n\   -Wup\n\ \tissue warnings for other undocumented Z80-instructions\n\   -forbid-undocumented-instructions\n\   -Fud\n\ \ttreat all undocumented z80-instructions as errors\n\   -forbid-unportable-instructions\n\   -Fup\n\ \ttreat undocumented z80-instructions that do not work on R800 as errors\n\   -r800\t  assemble for R800\n\n\ Default: -z80 -ignore-undocument-instructions -warn-unportable-instructions.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|zero
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|expressionS
name|nul
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
literal|"0"
expr_stmt|;
name|nul
operator|.
name|X_md
operator|=
literal|0
expr_stmt|;
name|expression
argument_list|(
operator|&
name|nul
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|zero
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|nul
argument_list|)
expr_stmt|;
comment|/* We do not use relaxation (yet).  */
name|linkrelax
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|z80_md_end
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mach_type
decl_stmt|;
if|if
condition|(
name|ins_used
operator|&
operator|(
name|INS_UNPORT
operator||
name|INS_R800
operator|)
condition|)
name|ins_used
operator||=
name|INS_UNDOC
expr_stmt|;
switch|switch
condition|(
name|ins_used
condition|)
block|{
case|case
name|INS_Z80
case|:
name|mach_type
operator|=
name|bfd_mach_z80strict
expr_stmt|;
break|break;
case|case
name|INS_Z80
operator||
name|INS_UNDOC
case|:
name|mach_type
operator|=
name|bfd_mach_z80
expr_stmt|;
break|break;
case|case
name|INS_Z80
operator||
name|INS_UNDOC
operator||
name|INS_UNPORT
case|:
name|mach_type
operator|=
name|bfd_mach_z80full
expr_stmt|;
break|break;
case|case
name|INS_Z80
operator||
name|INS_UNDOC
operator||
name|INS_R800
case|:
name|mach_type
operator|=
name|bfd_mach_r800
expr_stmt|;
break|break;
default|default:
name|mach_type
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|mach_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip_space
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* A non-zero return-value causes a continue in the    function read_a_source_file () in ../read.c.  */
end_comment

begin_function
name|int
name|z80_start_line_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|quote
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Convert one character constants.  */
for|for
control|(
name|p
operator|=
name|input_line_pointer
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|++
name|p
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\''
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\''
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
literal|"%3d"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
for|for
control|(
name|quote
operator|=
operator|*
name|p
operator|++
init|;
name|quote
operator|!=
operator|*
name|p
operator|&&
literal|'\n'
operator|!=
operator|*
name|p
condition|;
operator|++
name|p
control|)
comment|/* No escapes.  */
empty_stmt|;
if|if
condition|(
name|quote
operator|!=
operator|*
name|p
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-- unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
comment|/* Check for<label>[:] [.](EQU|DEFL)<value>.  */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|rest
decl_stmt|,
modifier|*
name|line_start
decl_stmt|;
name|int
name|len
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|line_start
operator|=
name|input_line_pointer
expr_stmt|;
name|LISTING_NEWLINE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ignore_input
argument_list|()
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|rest
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|':'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|' '
operator|||
operator|*
name|rest
operator|==
literal|'\t'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|==
literal|'.'
condition|)
operator|++
name|rest
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"EQU"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|rest
argument_list|,
literal|"DEFL"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|=
literal|4
expr_stmt|;
else|else
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|&&
operator|(
name|rest
index|[
name|len
index|]
operator|==
literal|' '
operator|||
name|rest
index|[
name|len
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* Handle assignment here.  */
name|input_line_pointer
operator|=
name|rest
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|line_start
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bump_line_counters
argument_list|()
expr_stmt|;
comment|/* Most Z80 assemblers require the first definition of a              label to use "EQU" and redefinitions to have "DEFL".  */
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|line_start
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|symbol_equated_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|line_start
argument_list|)
expr_stmt|;
block|}
name|equals
argument_list|(
name|line_start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Restore line and pointer.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|line_start
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|litP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|sizeP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|_
argument_list|(
literal|"floating point numbers are not implemented"
argument_list|)
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
return|return
name|size
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_where
operator|+
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
name|asfunc
function_decl|)
parameter_list|(
name|char
parameter_list|,
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_table_t
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|prefix
decl_stmt|;
name|char
name|opcode
decl_stmt|;
name|asfunc
modifier|*
name|fp
decl_stmt|;
block|}
name|table_t
typedef|;
end_typedef

begin_comment
comment|/* Compares the key for structs that start with a char * to the key.  */
end_comment

begin_function
specifier|static
name|int
name|key_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str_a
decl_stmt|,
modifier|*
name|str_b
decl_stmt|;
name|str_a
operator|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|a
operator|)
expr_stmt|;
name|str_b
operator|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|b
operator|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|str_a
argument_list|,
name|str_b
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUFLEN
value|8
end_define

begin_comment
comment|/* Large enough for any keyword.  */
end_comment

begin_decl_stmt
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|key
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|R_STACKABLE
value|(0x80)
end_define

begin_define
define|#
directive|define
name|R_ARITH
value|(0x40)
end_define

begin_define
define|#
directive|define
name|R_IX
value|(0x20)
end_define

begin_define
define|#
directive|define
name|R_IY
value|(0x10)
end_define

begin_define
define|#
directive|define
name|R_INDEX
value|(R_IX | R_IY)
end_define

begin_define
define|#
directive|define
name|REG_A
value|(7)
end_define

begin_define
define|#
directive|define
name|REG_B
value|(0)
end_define

begin_define
define|#
directive|define
name|REG_C
value|(1)
end_define

begin_define
define|#
directive|define
name|REG_D
value|(2)
end_define

begin_define
define|#
directive|define
name|REG_E
value|(3)
end_define

begin_define
define|#
directive|define
name|REG_H
value|(4)
end_define

begin_define
define|#
directive|define
name|REG_L
value|(5)
end_define

begin_define
define|#
directive|define
name|REG_F
value|(6 | 8)
end_define

begin_define
define|#
directive|define
name|REG_I
value|(9)
end_define

begin_define
define|#
directive|define
name|REG_R
value|(10)
end_define

begin_define
define|#
directive|define
name|REG_AF
value|(3 | R_STACKABLE)
end_define

begin_define
define|#
directive|define
name|REG_BC
value|(0 | R_STACKABLE | R_ARITH)
end_define

begin_define
define|#
directive|define
name|REG_DE
value|(1 | R_STACKABLE | R_ARITH)
end_define

begin_define
define|#
directive|define
name|REG_HL
value|(2 | R_STACKABLE | R_ARITH)
end_define

begin_define
define|#
directive|define
name|REG_SP
value|(3 | R_ARITH)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|reg_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|regtable
index|[]
init|=
block|{
block|{
literal|"a"
block|,
name|REG_A
block|}
block|,
block|{
literal|"af"
block|,
name|REG_AF
block|}
block|,
block|{
literal|"b"
block|,
name|REG_B
block|}
block|,
block|{
literal|"bc"
block|,
name|REG_BC
block|}
block|,
block|{
literal|"c"
block|,
name|REG_C
block|}
block|,
block|{
literal|"d"
block|,
name|REG_D
block|}
block|,
block|{
literal|"de"
block|,
name|REG_DE
block|}
block|,
block|{
literal|"e"
block|,
name|REG_E
block|}
block|,
block|{
literal|"f"
block|,
name|REG_F
block|}
block|,
block|{
literal|"h"
block|,
name|REG_H
block|}
block|,
block|{
literal|"hl"
block|,
name|REG_HL
block|}
block|,
block|{
literal|"i"
block|,
name|REG_I
block|}
block|,
block|{
literal|"ix"
block|,
name|REG_HL
operator||
name|R_IX
block|}
block|,
block|{
literal|"ixh"
block|,
name|REG_H
operator||
name|R_IX
block|}
block|,
block|{
literal|"ixl"
block|,
name|REG_L
operator||
name|R_IX
block|}
block|,
block|{
literal|"iy"
block|,
name|REG_HL
operator||
name|R_IY
block|}
block|,
block|{
literal|"iyh"
block|,
name|REG_H
operator||
name|R_IY
block|}
block|,
block|{
literal|"iyl"
block|,
name|REG_L
operator||
name|R_IY
block|}
block|,
block|{
literal|"l"
block|,
name|REG_L
block|}
block|,
block|{
literal|"r"
block|,
name|REG_R
block|}
block|,
block|{
literal|"sp"
block|,
name|REG_SP
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* Prevent an error on a line from also generating    a "junk at end of line" error message.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|err_flag
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|as_bad
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ill_op
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrong_mach
parameter_list|(
name|int
name|ins_type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ins_type
condition|)
block|{
case|case
name|INS_UNDOC
case|:
name|p
operator|=
literal|"undocumented instruction"
expr_stmt|;
break|break;
case|case
name|INS_UNPORT
case|:
name|p
operator|=
literal|"instruction does not work on R800"
expr_stmt|;
break|break;
case|case
name|INS_R800
case|:
name|p
operator|=
literal|"instruction only works R800"
expr_stmt|;
break|break;
default|default:
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Not reachable.  */
block|}
if|if
condition|(
name|ins_type
operator|&
name|ins_err
condition|)
name|error
argument_list|(
name|_
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_mach
parameter_list|(
name|int
name|ins_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ins_type
operator|&
name|ins_ok
operator|)
operator|==
literal|0
condition|)
name|wrong_mach
argument_list|(
name|ins_type
argument_list|)
expr_stmt|;
name|ins_used
operator||=
name|ins_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether an expression is indirect.  */
end_comment

begin_function
specifier|static
name|int
name|is_indir
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|quote
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|,
name|depth
decl_stmt|;
comment|/* Indirection is indicated with parentheses.  */
name|indir
operator|=
operator|(
operator|*
name|s
operator|==
literal|'('
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|depth
operator|=
literal|0
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|;
operator|++
name|p
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
for|for
control|(
name|quote
operator|=
operator|*
name|p
operator|++
init|;
name|quote
operator|!=
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
condition|)
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'('
case|:
operator|++
name|depth
expr_stmt|;
break|break;
case|case
literal|')'
case|:
operator|--
name|depth
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|skip_space
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|indir
operator|=
literal|0
expr_stmt|;
operator|--
name|p
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"mismatched parentheses"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|depth
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"mismatched parentheses"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|indir
return|;
block|}
end_function

begin_comment
comment|/* Parse general expression.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parse_exp2
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|,
name|segT
modifier|*
name|pseg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|reg_entry
modifier|*
name|regp
decl_stmt|;
name|expressionS
name|offset
decl_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|op
operator|->
name|X_md
operator|=
name|indir
operator|=
name|is_indir
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p
operator|=
name|skip_space
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFLEN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* Register names consist of letters only.  */
break|break;
name|buf
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|BUFLEN
operator|)
operator|&&
operator|(
operator|(
name|p
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|strchr
argument_list|(
literal|")+-, \t"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|regp
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|regtable
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|regtable
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|regtable
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|key_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|regp
condition|)
block|{
operator|*
name|pseg
operator|=
name|reg_section
expr_stmt|;
name|op
operator|->
name|X_add_symbol
operator|=
name|op
operator|->
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|X_add_number
operator|=
name|regp
operator|->
name|number
expr_stmt|;
name|op
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|regp
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|regp
operator|->
name|number
operator|&
name|R_INDEX
operator|)
operator|&&
operator|(
name|regp
operator|->
name|number
operator|&
name|R_ARITH
operator|)
condition|)
block|{
name|op
operator|->
name|X_op
operator|=
name|O_md1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
block|{
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|expression
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad offset expression syntax"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
name|op
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* We treat (i[xy]) as (i[xy]+0), which is how it will 		     end up anyway, unless we're processing jp (i[xy]).  */
name|op
operator|->
name|X_add_symbol
operator|=
name|zero
expr_stmt|;
block|}
block|}
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|','
operator|)
condition|)
return|return
name|p
return|;
block|}
block|}
comment|/* Not an argument involving a register; use the generic parser.  */
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
operator|*
name|pseg
operator|=
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_illegal
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad expression syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|input_line_pointer
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parse_exp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
name|segT
name|dummy
decl_stmt|;
return|return
name|parse_exp2
argument_list|(
name|s
argument_list|,
name|op
argument_list|,
operator|&
name|dummy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Condition codes, including some synonyms provided by HiTech zas.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|cc_tab
index|[]
init|=
block|{
block|{
literal|"age"
block|,
literal|6
operator|<<
literal|3
block|}
block|,
block|{
literal|"alt"
block|,
literal|7
operator|<<
literal|3
block|}
block|,
block|{
literal|"c"
block|,
literal|3
operator|<<
literal|3
block|}
block|,
block|{
literal|"di"
block|,
literal|4
operator|<<
literal|3
block|}
block|,
block|{
literal|"ei"
block|,
literal|5
operator|<<
literal|3
block|}
block|,
block|{
literal|"lge"
block|,
literal|2
operator|<<
literal|3
block|}
block|,
block|{
literal|"llt"
block|,
literal|3
operator|<<
literal|3
block|}
block|,
block|{
literal|"m"
block|,
literal|7
operator|<<
literal|3
block|}
block|,
block|{
literal|"nc"
block|,
literal|2
operator|<<
literal|3
block|}
block|,
block|{
literal|"nz"
block|,
literal|0
operator|<<
literal|3
block|}
block|,
block|{
literal|"p"
block|,
literal|6
operator|<<
literal|3
block|}
block|,
block|{
literal|"pe"
block|,
literal|5
operator|<<
literal|3
block|}
block|,
block|{
literal|"po"
block|,
literal|4
operator|<<
literal|3
block|}
block|,
block|{
literal|"z"
block|,
literal|1
operator|<<
literal|3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse condition code.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parse_cc
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|cc_p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFLEN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* Condition codes consist of letters only.  */
break|break;
name|buf
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|BUFLEN
operator|)
operator|&&
operator|(
operator|(
name|s
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|s
index|[
name|i
index|]
operator|==
literal|','
operator|)
operator|)
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cc_p
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|cc_tab
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|cc_tab
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|cc_tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|key_cmp
argument_list|)
expr_stmt|;
block|}
else|else
name|cc_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cc_p
condition|)
block|{
operator|*
name|op
operator|=
name|cc_p
operator|->
name|number
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|i
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_insn
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|prefix
expr_stmt|;
block|}
else|else
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|opcode
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_function
name|void
name|z80_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag_p
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|r
index|[
literal|4
index|]
init|=
block|{
name|BFD_RELOC_8
block|,
name|BFD_RELOC_16
block|,
name|BFD_RELOC_24
block|,
name|BFD_RELOC_32
block|}
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|1
operator|||
name|nbytes
operator|>
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag_p
argument_list|,
name|offset
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
index|[
name|nbytes
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_byte
parameter_list|(
name|expressionS
modifier|*
name|val
parameter_list|,
name|bfd_reloc_code_real_type
name|r_type
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|val
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
operator|&&
operator|(
name|val
operator|->
name|X_op
operator|==
name|O_constant
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot make a relative jump to an absolute location"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|lo
operator|=
operator|-
literal|128
expr_stmt|;
name|hi
operator|=
operator|(
name|BFD_RELOC_8
operator|==
name|r_type
operator|)
condition|?
literal|255
else|:
literal|127
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|->
name|X_add_number
operator|<
name|lo
operator|)
operator|||
operator|(
name|val
operator|->
name|X_add_number
operator|>
name|hi
operator|)
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_Z80_DISP8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"offset too large"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"overflow"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|1
argument_list|,
name|val
argument_list|,
operator|(
name|r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* FIXME : Process constant offsets immediately.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_word
parameter_list|(
name|expressionS
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|->
name|X_op
operator|==
name|O_register
operator|)
operator|||
operator|(
name|val
operator|->
name|X_op
operator|==
name|O_md1
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
name|val
operator|->
name|X_add_number
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|->
name|X_add_number
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|val
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mx
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
name|int
name|shift
parameter_list|,
name|expressionS
modifier|*
name|arg
parameter_list|)
comment|/* The operand m may be r, (hl), (ix+d), (iy+d), 	if 0 == prefix m may also be ixl, ixh, iyl, iyh.  */
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|rnum
decl_stmt|;
name|rnum
operator|=
name|arg
operator|->
name|X_add_number
expr_stmt|;
switch|switch
condition|(
name|arg
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
if|if
condition|(
name|arg
operator|->
name|X_md
condition|)
block|{
if|if
condition|(
name|rnum
operator|!=
name|REG_HL
condition|)
block|{
name|ill_op
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
name|rnum
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|prefix
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rnum
operator|&
name|R_INDEX
operator|)
condition|)
block|{
name|prefix
operator|=
operator|(
name|rnum
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
name|check_mach
argument_list|(
name|INS_UNDOC
argument_list|)
expr_stmt|;
name|rnum
operator|&=
operator|~
name|R_INDEX
expr_stmt|;
block|}
if|if
condition|(
name|rnum
operator|>
literal|7
condition|)
block|{
name|ill_op
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|q
operator|=
name|frag_more
argument_list|(
name|prefix
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|opcode
operator|+
operator|(
name|rnum
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|O_md1
case|:
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|rnum
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
operator|(
name|prefix
operator|)
condition|?
name|prefix
else|:
operator|(
name|opcode
operator|+
operator|(
literal|6
operator|<<
name|shift
operator|)
operator|)
expr_stmt|;
name|emit_byte
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|arg
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
name|BFD_RELOC_Z80_DISP8
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
literal|6
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The operand m may be r, (hl), (ix+d), (iy+d),    if 0 = prefix m may also be ixl, ixh, iyl, iyh.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_m
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|arg_m
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|arg_m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|arg_m
operator|.
name|X_op
condition|)
block|{
case|case
name|O_md1
case|:
case|case
name|O_register
case|:
name|emit_mx
argument_list|(
name|prefix
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
operator|&
name|arg_m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The operand m may be as above or one of the undocumented    combinations (ix+d),r and (iy+d),r (if unportable instructions    are allowed).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_mr
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|arg_m
decl_stmt|,
name|arg_r
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|arg_m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|arg_m
operator|.
name|X_op
condition|)
block|{
case|case
name|O_md1
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|=
name|parse_exp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|arg_r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg_r
operator|.
name|X_md
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arg_r
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|arg_r
operator|.
name|X_add_number
operator|<
literal|8
operator|)
condition|)
name|opcode
operator|+=
name|arg_r
operator|.
name|X_add_number
operator|-
literal|6
expr_stmt|;
comment|/* Emit_mx () will add 6.  */
else|else
block|{
name|ill_op
argument_list|()
expr_stmt|;
break|break;
block|}
name|check_mach
argument_list|(
name|INS_UNPORT
argument_list|)
expr_stmt|;
block|}
case|case
name|O_register
case|:
name|emit_mx
argument_list|(
name|prefix
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
operator|&
name|arg_m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_sx
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
name|expressionS
modifier|*
name|arg_p
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
switch|switch
condition|(
name|arg_p
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_md1
case|:
name|emit_mx
argument_list|(
name|prefix
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
name|arg_p
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arg_p
operator|->
name|X_md
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
name|prefix
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|^
literal|0x46
expr_stmt|;
name|emit_byte
argument_list|(
name|arg_p
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The operand s may be r, (hl), (ix+d), (iy+d), n.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_s
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|arg_s
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|arg_s
argument_list|)
expr_stmt|;
name|emit_sx
argument_list|(
name|prefix
argument_list|,
name|opcode
argument_list|,
operator|&
name|arg_s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_call
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|X_md
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
expr_stmt|;
name|emit_word
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Operand may be rr, r, (hl), (ix+d), (iy+d).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_incdec
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|operand
decl_stmt|;
name|int
name|rnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
name|rnum
operator|=
name|operand
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|operand
operator|.
name|X_md
operator|)
operator|&&
operator|(
name|operand
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|R_ARITH
operator|&
name|rnum
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
operator|(
name|rnum
operator|&
name|R_INDEX
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnum
operator|&
name|R_INDEX
condition|)
operator|*
name|q
operator|++
operator|=
operator|(
name|rnum
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
name|prefix
operator|+
operator|(
operator|(
name|rnum
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|operand
operator|.
name|X_op
operator|==
name|O_md1
operator|)
operator|||
operator|(
name|operand
operator|.
name|X_op
operator|==
name|O_register
operator|)
condition|)
name|emit_mx
argument_list|(
literal|0
argument_list|,
name|opcode
argument_list|,
literal|3
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_jr
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|X_md
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
expr_stmt|;
name|emit_byte
argument_list|(
operator|&
name|addr
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_jp
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|rnum
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|X_md
condition|)
block|{
name|rnum
operator|=
name|addr
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|rnum
operator|&
operator|~
name|R_INDEX
operator|)
operator|==
name|REG_HL
operator|)
comment|/* An operand (i[xy]) would have been rewritten to (i[xy]+0)             in parse_exp ().  */
operator|||
operator|(
name|addr
operator|.
name|X_op
operator|==
name|O_md1
operator|&&
name|addr
operator|.
name|X_add_symbol
operator|==
name|zero
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
operator|(
name|rnum
operator|&
name|R_INDEX
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnum
operator|&
name|R_INDEX
condition|)
operator|*
name|q
operator|++
operator|=
operator|(
name|rnum
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
name|prefix
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
expr_stmt|;
name|emit_word
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_im
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|X_md
operator|||
operator|(
name|mode
operator|.
name|X_op
operator|!=
name|O_constant
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|mode
operator|.
name|X_add_number
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
operator|++
name|mode
operator|.
name|X_add_number
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|0
case|:
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
literal|8
operator|*
name|mode
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_pop
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|regp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|regp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|regp
operator|.
name|X_md
operator|)
operator|&&
operator|(
name|regp
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|regp
operator|.
name|X_add_number
operator|&
name|R_STACKABLE
operator|)
condition|)
block|{
name|int
name|rnum
decl_stmt|;
name|rnum
operator|=
name|regp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|rnum
operator|&
name|R_INDEX
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|rnum
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
block|}
else|else
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
operator|(
name|rnum
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_retcc
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|char
name|cc
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_cc
argument_list|(
name|args
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|q
operator|=
name|opcode
operator|+
name|cc
expr_stmt|;
else|else
operator|*
name|q
operator|=
name|prefix
expr_stmt|;
return|return
name|p
condition|?
name|p
else|:
name|args
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_adc
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|term
decl_stmt|;
name|int
name|rnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
operator|(
name|term
operator|.
name|X_md
operator|)
operator|||
operator|(
name|term
operator|.
name|X_op
operator|!=
name|O_register
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|term
operator|.
name|X_add_number
condition|)
block|{
case|case
name|REG_A
case|:
name|p
operator|=
name|emit_s
argument_list|(
literal|0
argument_list|,
name|prefix
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_HL
case|:
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|term
operator|.
name|X_md
operator|)
operator|&&
operator|(
name|term
operator|.
name|X_op
operator|==
name|O_register
operator|)
condition|)
block|{
name|rnum
operator|=
name|term
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|R_ARITH
operator|==
operator|(
name|rnum
operator|&
operator|(
name|R_ARITH
operator||
name|R_INDEX
operator|)
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
operator|(
name|rnum
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_add
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|term
decl_stmt|;
name|int
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
operator|(
name|term
operator|.
name|X_md
operator|)
operator|||
operator|(
name|term
operator|.
name|X_op
operator|!=
name|O_register
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|term
operator|.
name|X_add_number
operator|&
operator|~
name|R_INDEX
condition|)
block|{
case|case
name|REG_A
case|:
name|p
operator|=
name|emit_s
argument_list|(
literal|0
argument_list|,
name|prefix
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_HL
case|:
name|lhs
operator|=
name|term
operator|.
name|X_add_number
expr_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|term
operator|.
name|X_md
operator|)
operator|&&
operator|(
name|term
operator|.
name|X_op
operator|==
name|O_register
operator|)
condition|)
block|{
name|rhs
operator|=
name|term
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|rhs
operator|&
name|R_ARITH
operator|)
operator|&&
operator|(
operator|(
name|rhs
operator|==
name|lhs
operator|)
operator|||
operator|(
operator|(
name|rhs
operator|&
operator|~
name|R_INDEX
operator|)
operator|!=
name|REG_HL
operator|)
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
operator|(
name|lhs
operator|&
name|R_INDEX
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|&
name|R_INDEX
condition|)
operator|*
name|q
operator|++
operator|=
operator|(
name|lhs
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
operator|(
name|rhs
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_bit
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|b
decl_stmt|;
name|int
name|bn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|bn
operator|=
name|b
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|b
operator|.
name|X_md
operator|)
operator|&&
operator|(
name|b
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
literal|0
operator|<=
name|bn
operator|)
operator|&&
operator|(
name|bn
operator|<
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
literal|0x40
condition|)
comment|/* Bit : no optional third operand.  */
name|p
operator|=
name|emit_m
argument_list|(
name|prefix
argument_list|,
name|opcode
operator|+
operator|(
name|bn
operator|<<
literal|3
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
comment|/* Set, res : resulting byte can be copied to register.  */
name|p
operator|=
name|emit_mr
argument_list|(
name|prefix
argument_list|,
name|opcode
operator|+
operator|(
name|bn
operator|<<
literal|3
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_jpcc
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|char
name|cc
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_cc
argument_list|(
name|args
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
name|p
operator|=
name|emit_call
argument_list|(
literal|0
argument_list|,
name|opcode
operator|+
name|cc
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|prefix
operator|==
operator|(
name|char
operator|)
literal|0xC3
operator|)
condition|?
name|emit_jp
argument_list|(
literal|0xE9
argument_list|,
name|prefix
argument_list|,
name|args
argument_list|)
else|:
name|emit_call
argument_list|(
literal|0
argument_list|,
name|prefix
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_jrcc
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|char
name|cc
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|parse_cc
argument_list|(
name|args
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|cc
operator|>
operator|(
literal|3
operator|<<
literal|3
operator|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"condition code invalid for jr"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|emit_jr
argument_list|(
literal|0
argument_list|,
name|opcode
operator|+
name|cc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|emit_jr
argument_list|(
literal|0
argument_list|,
name|prefix
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_ex
parameter_list|(
name|char
name|prefix_in
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode_in
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|prefix
decl_stmt|,
name|opcode
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"bad instruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|prefix
operator|=
name|opcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|X_op
operator|==
name|O_register
condition|)
switch|switch
condition|(
name|op
operator|.
name|X_add_number
operator||
operator|(
name|op
operator|.
name|X_md
condition|?
literal|0x8000
else|:
literal|0
operator|)
condition|)
block|{
case|case
name|REG_AF
case|:
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|==
literal|'a'
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|==
literal|'f'
condition|)
block|{
comment|/* The scrubber changes '\'' to '`' in this context.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'`'
condition|)
operator|++
name|p
expr_stmt|;
name|opcode
operator|=
literal|0x08
expr_stmt|;
block|}
break|break;
case|case
name|REG_DE
case|:
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|==
literal|'h'
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|==
literal|'l'
condition|)
name|opcode
operator|=
literal|0xEB
expr_stmt|;
break|break;
case|case
name|REG_SP
operator||
literal|0x8000
case|:
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|op
operator|.
name|X_md
operator|==
literal|0
operator|&&
operator|(
name|op
operator|.
name|X_add_number
operator|&
operator|~
name|R_INDEX
operator|)
operator|==
name|REG_HL
condition|)
block|{
name|opcode
operator|=
literal|0xE3
expr_stmt|;
if|if
condition|(
name|R_INDEX
operator|&
name|op
operator|.
name|X_add_number
condition|)
name|prefix
operator|=
operator|(
name|R_IX
operator|&
name|op
operator|.
name|X_add_number
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|opcode
condition|)
name|emit_insn
argument_list|(
name|prefix
argument_list|,
name|opcode
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|ill_op
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_in
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|reg
decl_stmt|,
name|port
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|.
name|X_md
operator|==
literal|0
operator|&&
name|reg
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|reg
operator|.
name|X_add_number
operator|<=
literal|7
operator|||
name|reg
operator|.
name|X_add_number
operator|==
name|REG_F
operator|)
operator|&&
operator|(
name|port
operator|.
name|X_md
operator|)
condition|)
block|{
if|if
condition|(
name|port
operator|.
name|X_op
operator|!=
name|O_md1
operator|&&
name|port
operator|.
name|X_op
operator|!=
name|O_register
condition|)
block|{
if|if
condition|(
name|REG_A
operator|==
name|reg
operator|.
name|X_add_number
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0xDB
expr_stmt|;
name|emit_byte
argument_list|(
operator|&
name|port
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|port
operator|.
name|X_add_number
operator|==
name|REG_C
condition|)
block|{
if|if
condition|(
name|reg
operator|.
name|X_add_number
operator|==
name|REG_F
condition|)
name|check_mach
argument_list|(
name|INS_UNDOC
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
literal|0x40
operator||
operator|(
operator|(
name|reg
operator|.
name|X_add_number
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_out
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|reg
decl_stmt|,
name|port
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|.
name|X_md
condition|)
block|{
name|ill_op
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Allow "out (c), 0" as unportable instruction.  */
if|if
condition|(
name|reg
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|reg
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|check_mach
argument_list|(
name|INS_UNPORT
argument_list|)
expr_stmt|;
name|reg
operator|.
name|X_op
operator|=
name|O_register
expr_stmt|;
name|reg
operator|.
name|X_add_number
operator|=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|.
name|X_md
operator|||
name|reg
operator|.
name|X_op
operator|!=
name|O_register
operator|||
name|reg
operator|.
name|X_add_number
operator|>
literal|7
condition|)
name|ill_op
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|port
operator|.
name|X_op
operator|!=
name|O_md1
condition|)
block|{
if|if
condition|(
name|REG_A
operator|==
name|reg
operator|.
name|X_add_number
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0xD3
expr_stmt|;
name|emit_byte
argument_list|(
operator|&
name|port
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REG_C
operator|==
name|port
operator|.
name|X_add_number
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
literal|0x41
operator||
operator|(
name|reg
operator|.
name|X_add_number
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_rst
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|error
argument_list|(
literal|"rst needs constant address"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|addr
operator|.
name|X_add_number
operator|&
operator|~
operator|(
literal|7
operator|<<
literal|3
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
name|addr
operator|.
name|X_add_number
operator|&
operator|(
literal|7
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_ldxhl
parameter_list|(
name|char
name|prefix
parameter_list|,
name|char
name|opcode
parameter_list|,
name|expressionS
modifier|*
name|src
parameter_list|,
name|expressionS
modifier|*
name|d
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|X_md
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|src
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
if|if
condition|(
name|src
operator|->
name|X_add_number
operator|>
literal|7
condition|)
name|ill_op
argument_list|()
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
block|}
else|else
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
name|src
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|emit_byte
argument_list|(
name|d
argument_list|,
name|BFD_RELOC_Z80_DISP8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prefix
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
block|}
else|else
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|^
literal|0x46
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|emit_byte
argument_list|(
name|d
argument_list|,
name|BFD_RELOC_Z80_DISP8
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|src
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_ldreg
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|rnum
decl_stmt|;
switch|switch
condition|(
name|dest
condition|)
block|{
comment|/* 8 Bit ld group:  */
case|case
name|REG_I
case|:
case|case
name|REG_R
case|:
if|if
condition|(
name|src
operator|->
name|X_md
operator|==
literal|0
operator|&&
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|src
operator|->
name|X_add_number
operator|==
name|REG_A
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
operator|(
name|dest
operator|==
name|REG_I
operator|)
condition|?
literal|0x47
else|:
literal|0x4F
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
break|break;
case|case
name|REG_A
case|:
if|if
condition|(
operator|(
name|src
operator|->
name|X_md
operator|)
operator|&&
name|src
operator|->
name|X_op
operator|!=
name|O_register
operator|&&
name|src
operator|->
name|X_op
operator|!=
name|O_md1
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0x3A
expr_stmt|;
name|emit_word
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|src
operator|->
name|X_md
operator|)
operator|&&
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|src
operator|->
name|X_add_number
operator|==
name|REG_BC
operator|||
name|src
operator|->
name|X_add_number
operator|==
name|REG_DE
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0x0A
operator|+
operator|(
operator|(
name|dest
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|!
name|src
operator|->
name|X_md
operator|)
operator|&&
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|src
operator|->
name|X_add_number
operator|==
name|REG_R
operator|||
name|src
operator|->
name|X_add_number
operator|==
name|REG_I
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
operator|(
name|src
operator|->
name|X_add_number
operator|==
name|REG_I
operator|)
condition|?
literal|0x57
else|:
literal|0x5F
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|REG_B
case|:
case|case
name|REG_C
case|:
case|case
name|REG_D
case|:
case|case
name|REG_E
case|:
name|emit_sx
argument_list|(
literal|0
argument_list|,
literal|0x40
operator|+
operator|(
name|dest
operator|<<
literal|3
operator|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_H
case|:
case|case
name|REG_L
case|:
if|if
condition|(
operator|(
name|src
operator|->
name|X_md
operator|==
literal|0
operator|)
operator|&&
operator|(
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|src
operator|->
name|X_add_number
operator|&
name|R_INDEX
operator|)
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
name|emit_sx
argument_list|(
literal|0
argument_list|,
literal|0x40
operator|+
operator|(
name|dest
operator|<<
literal|3
operator|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IX
operator||
name|REG_H
case|:
case|case
name|R_IX
operator||
name|REG_L
case|:
case|case
name|R_IY
operator||
name|REG_H
case|:
case|case
name|R_IY
operator||
name|REG_L
case|:
if|if
condition|(
name|src
operator|->
name|X_md
condition|)
block|{
name|ill_op
argument_list|()
expr_stmt|;
break|break;
block|}
name|check_mach
argument_list|(
name|INS_UNDOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|X_op
operator|==
name|O_register
condition|)
block|{
name|rnum
operator|=
name|src
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|(
name|rnum
operator|&
operator|~
name|R_INDEX
operator|)
operator|<
literal|8
operator|&&
operator|(
operator|(
name|rnum
operator|&
name|R_INDEX
operator|)
operator|==
operator|(
name|dest
operator|&
name|R_INDEX
operator|)
operator|||
operator|(
operator|(
name|rnum
operator|&
operator|~
name|R_INDEX
operator|)
operator|!=
name|REG_H
operator|&&
operator|(
name|rnum
operator|&
operator|~
name|R_INDEX
operator|)
operator|!=
name|REG_L
operator|)
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|dest
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
literal|0x40
operator|+
operator|(
operator|(
name|dest
operator|&
literal|0x07
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
name|rnum
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|dest
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
literal|0x06
operator|+
operator|(
operator|(
name|dest
operator|&
literal|0x07
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|emit_byte
argument_list|(
name|src
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 16 Bit ld group:  */
case|case
name|REG_SP
case|:
if|if
condition|(
name|src
operator|->
name|X_md
operator|==
literal|0
operator|&&
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|&&
name|REG_HL
operator|==
operator|(
name|src
operator|->
name|X_add_number
operator|&
operator|~
name|R_INDEX
operator|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
operator|(
name|src
operator|->
name|X_add_number
operator|&
name|R_INDEX
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|X_add_number
operator|&
name|R_INDEX
condition|)
operator|*
name|q
operator|++
operator|=
operator|(
name|src
operator|->
name|X_add_number
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
literal|0xF9
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|REG_BC
case|:
case|case
name|REG_DE
case|:
if|if
condition|(
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|||
name|src
operator|->
name|X_op
operator|==
name|O_md1
condition|)
name|ill_op
argument_list|()
expr_stmt|;
name|q
operator|=
name|frag_more
argument_list|(
name|src
operator|->
name|X_md
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|X_md
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0xED
expr_stmt|;
operator|*
name|q
operator|=
literal|0x4B
operator|+
operator|(
operator|(
name|dest
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0x01
operator|+
operator|(
operator|(
name|dest
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|emit_word
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_HL
case|:
case|case
name|REG_HL
operator||
name|R_IX
case|:
case|case
name|REG_HL
operator||
name|R_IY
case|:
if|if
condition|(
name|src
operator|->
name|X_op
operator|==
name|O_register
operator|||
name|src
operator|->
name|X_op
operator|==
name|O_md1
condition|)
name|ill_op
argument_list|()
expr_stmt|;
name|q
operator|=
name|frag_more
argument_list|(
operator|(
name|dest
operator|&
name|R_INDEX
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|&
name|R_INDEX
condition|)
operator|*
name|q
operator|++
operator|=
operator|(
name|dest
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
expr_stmt|;
operator|*
name|q
operator|=
operator|(
name|src
operator|->
name|X_md
operator|)
condition|?
literal|0x2A
else|:
literal|0x21
expr_stmt|;
name|emit_word
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_AF
case|:
case|case
name|REG_F
case|:
name|ill_op
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_ld
parameter_list|(
name|char
name|prefix_in
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode_in
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|expressionS
name|dst
decl_stmt|,
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|prefix
decl_stmt|,
name|opcode
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|args
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad intruction syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dst
operator|.
name|X_op
condition|)
block|{
case|case
name|O_md1
case|:
name|emit_ldxhl
argument_list|(
operator|(
name|dst
operator|.
name|X_add_number
operator|&
name|R_IX
operator|)
condition|?
literal|0xDD
else|:
literal|0xFD
argument_list|,
literal|0x70
argument_list|,
operator|&
name|src
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|dst
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_register
case|:
if|if
condition|(
name|dst
operator|.
name|X_md
condition|)
block|{
switch|switch
condition|(
name|dst
operator|.
name|X_add_number
condition|)
block|{
case|case
name|REG_BC
case|:
case|case
name|REG_DE
case|:
if|if
condition|(
name|src
operator|.
name|X_md
operator|==
literal|0
operator|&&
name|src
operator|.
name|X_op
operator|==
name|O_register
operator|&&
name|src
operator|.
name|X_add_number
operator|==
name|REG_A
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0x02
operator|+
operator|(
operator|(
name|dst
operator|.
name|X_add_number
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
break|break;
case|case
name|REG_HL
case|:
name|emit_ldxhl
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
operator|&
name|src
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|emit_ldreg
argument_list|(
name|dst
operator|.
name|X_add_number
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|src
operator|.
name|X_md
operator|!=
literal|0
operator|||
name|src
operator|.
name|X_op
operator|!=
name|O_register
condition|)
name|ill_op
argument_list|()
expr_stmt|;
name|prefix
operator|=
name|opcode
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|src
operator|.
name|X_add_number
condition|)
block|{
case|case
name|REG_A
case|:
name|opcode
operator|=
literal|0x32
expr_stmt|;
break|break;
case|case
name|REG_BC
case|:
case|case
name|REG_DE
case|:
case|case
name|REG_SP
case|:
name|prefix
operator|=
literal|0xED
expr_stmt|;
name|opcode
operator|=
literal|0x43
operator|+
operator|(
operator|(
name|src
operator|.
name|X_add_number
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|REG_HL
case|:
name|opcode
operator|=
literal|0x22
expr_stmt|;
break|break;
case|case
name|REG_HL
operator||
name|R_IX
case|:
name|prefix
operator|=
literal|0xDD
expr_stmt|;
name|opcode
operator|=
literal|0x22
expr_stmt|;
break|break;
case|case
name|REG_HL
operator||
name|R_IY
case|:
name|prefix
operator|=
literal|0xFD
expr_stmt|;
name|opcode
operator|=
literal|0x22
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
name|prefix
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
expr_stmt|;
name|emit_word
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
name|ill_op
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_data
parameter_list|(
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|u
decl_stmt|,
name|quote
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|skip_space
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
for|for
control|(
name|quote
operator|=
operator|*
name|p
operator|,
name|q
operator|=
operator|++
name|p
operator|,
name|cnt
operator|=
literal|0
init|;
operator|*
name|p
operator|&&
name|quote
operator|!=
operator|*
name|p
condition|;
operator|++
name|p
operator|,
operator|++
name|cnt
control|)
empty_stmt|;
name|u
operator|=
name|frag_more
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|u
argument_list|,
name|q
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|skip_space
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_md1
operator|||
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|ill_op
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|exp
operator|.
name|X_md
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"parentheses ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
operator|&
name|exp
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_mulub
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|!=
literal|'a'
operator|||
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|q
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
name|check_mach
argument_list|(
name|INS_R800
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|skip_space
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
operator|(
name|reg
operator|-
literal|'b'
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
block|}
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|emit_muluw
parameter_list|(
name|char
name|prefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|!=
literal|'h'
operator|||
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|!=
literal|'l'
operator|||
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|ill_op
argument_list|()
expr_stmt|;
else|else
block|{
name|expressionS
name|reg
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|parse_exp
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|reg
operator|.
name|X_md
operator|)
operator|&&
name|reg
operator|.
name|X_op
operator|==
name|O_register
condition|)
switch|switch
condition|(
name|reg
operator|.
name|X_add_number
condition|)
block|{
case|case
name|REG_BC
case|:
case|case
name|REG_SP
case|:
name|check_mach
argument_list|(
name|INS_R800
argument_list|)
expr_stmt|;
name|q
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|prefix
expr_stmt|;
operator|*
name|q
operator|=
name|opcode
operator|+
operator|(
operator|(
name|reg
operator|.
name|X_add_number
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
default|default:
name|ill_op
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Port specific pseudo ops.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"db"
block|,
name|emit_data
block|,
literal|1
block|}
block|,
block|{
literal|"d24"
block|,
name|cons
block|,
literal|3
block|}
block|,
block|{
literal|"d32"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"def24"
block|,
name|cons
block|,
literal|3
block|}
block|,
block|{
literal|"def32"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"defb"
block|,
name|emit_data
block|,
literal|1
block|}
block|,
block|{
literal|"defs"
block|,
name|s_space
block|,
literal|1
block|}
block|,
comment|/* Synonym for ds on some assemblers.  */
block|{
literal|"defw"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"ds"
block|,
name|s_space
block|,
literal|1
block|}
block|,
comment|/* Fill with bytes rather than words.  */
block|{
literal|"dw"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"psect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* TODO: Translate attributes.  */
block|{
literal|"set"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Real instruction on z80.  */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|table_t
name|instab
index|[]
init|=
block|{
block|{
literal|"adc"
block|,
literal|0x88
block|,
literal|0x4A
block|,
name|emit_adc
block|}
block|,
block|{
literal|"add"
block|,
literal|0x80
block|,
literal|0x09
block|,
name|emit_add
block|}
block|,
block|{
literal|"and"
block|,
literal|0x00
block|,
literal|0xA0
block|,
name|emit_s
block|}
block|,
block|{
literal|"bit"
block|,
literal|0xCB
block|,
literal|0x40
block|,
name|emit_bit
block|}
block|,
block|{
literal|"call"
block|,
literal|0xCD
block|,
literal|0xC4
block|,
name|emit_jpcc
block|}
block|,
block|{
literal|"ccf"
block|,
literal|0x00
block|,
literal|0x3F
block|,
name|emit_insn
block|}
block|,
block|{
literal|"cp"
block|,
literal|0x00
block|,
literal|0xB8
block|,
name|emit_s
block|}
block|,
block|{
literal|"cpd"
block|,
literal|0xED
block|,
literal|0xA9
block|,
name|emit_insn
block|}
block|,
block|{
literal|"cpdr"
block|,
literal|0xED
block|,
literal|0xB9
block|,
name|emit_insn
block|}
block|,
block|{
literal|"cpi"
block|,
literal|0xED
block|,
literal|0xA1
block|,
name|emit_insn
block|}
block|,
block|{
literal|"cpir"
block|,
literal|0xED
block|,
literal|0xB1
block|,
name|emit_insn
block|}
block|,
block|{
literal|"cpl"
block|,
literal|0x00
block|,
literal|0x2F
block|,
name|emit_insn
block|}
block|,
block|{
literal|"daa"
block|,
literal|0x00
block|,
literal|0x27
block|,
name|emit_insn
block|}
block|,
block|{
literal|"dec"
block|,
literal|0x0B
block|,
literal|0x05
block|,
name|emit_incdec
block|}
block|,
block|{
literal|"di"
block|,
literal|0x00
block|,
literal|0xF3
block|,
name|emit_insn
block|}
block|,
block|{
literal|"djnz"
block|,
literal|0x00
block|,
literal|0x10
block|,
name|emit_jr
block|}
block|,
block|{
literal|"ei"
block|,
literal|0x00
block|,
literal|0xFB
block|,
name|emit_insn
block|}
block|,
block|{
literal|"ex"
block|,
literal|0x00
block|,
literal|0x00
block|,
name|emit_ex
block|}
block|,
block|{
literal|"exx"
block|,
literal|0x00
block|,
literal|0xD9
block|,
name|emit_insn
block|}
block|,
block|{
literal|"halt"
block|,
literal|0x00
block|,
literal|0x76
block|,
name|emit_insn
block|}
block|,
block|{
literal|"im"
block|,
literal|0xED
block|,
literal|0x46
block|,
name|emit_im
block|}
block|,
block|{
literal|"in"
block|,
literal|0x00
block|,
literal|0x00
block|,
name|emit_in
block|}
block|,
block|{
literal|"inc"
block|,
literal|0x03
block|,
literal|0x04
block|,
name|emit_incdec
block|}
block|,
block|{
literal|"ind"
block|,
literal|0xED
block|,
literal|0xAA
block|,
name|emit_insn
block|}
block|,
block|{
literal|"indr"
block|,
literal|0xED
block|,
literal|0xBA
block|,
name|emit_insn
block|}
block|,
block|{
literal|"ini"
block|,
literal|0xED
block|,
literal|0xA2
block|,
name|emit_insn
block|}
block|,
block|{
literal|"inir"
block|,
literal|0xED
block|,
literal|0xB2
block|,
name|emit_insn
block|}
block|,
block|{
literal|"jp"
block|,
literal|0xC3
block|,
literal|0xC2
block|,
name|emit_jpcc
block|}
block|,
block|{
literal|"jr"
block|,
literal|0x18
block|,
literal|0x20
block|,
name|emit_jrcc
block|}
block|,
block|{
literal|"ld"
block|,
literal|0x00
block|,
literal|0x00
block|,
name|emit_ld
block|}
block|,
block|{
literal|"ldd"
block|,
literal|0xED
block|,
literal|0xA8
block|,
name|emit_insn
block|}
block|,
block|{
literal|"lddr"
block|,
literal|0xED
block|,
literal|0xB8
block|,
name|emit_insn
block|}
block|,
block|{
literal|"ldi"
block|,
literal|0xED
block|,
literal|0xA0
block|,
name|emit_insn
block|}
block|,
block|{
literal|"ldir"
block|,
literal|0xED
block|,
literal|0xB0
block|,
name|emit_insn
block|}
block|,
block|{
literal|"mulub"
block|,
literal|0xED
block|,
literal|0xC5
block|,
name|emit_mulub
block|}
block|,
comment|/* R800 only.  */
block|{
literal|"muluw"
block|,
literal|0xED
block|,
literal|0xC3
block|,
name|emit_muluw
block|}
block|,
comment|/* R800 only.  */
block|{
literal|"neg"
block|,
literal|0xed
block|,
literal|0x44
block|,
name|emit_insn
block|}
block|,
block|{
literal|"nop"
block|,
literal|0x00
block|,
literal|0x00
block|,
name|emit_insn
block|}
block|,
block|{
literal|"or"
block|,
literal|0x00
block|,
literal|0xB0
block|,
name|emit_s
block|}
block|,
block|{
literal|"otdr"
block|,
literal|0xED
block|,
literal|0xBB
block|,
name|emit_insn
block|}
block|,
block|{
literal|"otir"
block|,
literal|0xED
block|,
literal|0xB3
block|,
name|emit_insn
block|}
block|,
block|{
literal|"out"
block|,
literal|0x00
block|,
literal|0x00
block|,
name|emit_out
block|}
block|,
block|{
literal|"outd"
block|,
literal|0xED
block|,
literal|0xAB
block|,
name|emit_insn
block|}
block|,
block|{
literal|"outi"
block|,
literal|0xED
block|,
literal|0xA3
block|,
name|emit_insn
block|}
block|,
block|{
literal|"pop"
block|,
literal|0x00
block|,
literal|0xC1
block|,
name|emit_pop
block|}
block|,
block|{
literal|"push"
block|,
literal|0x00
block|,
literal|0xC5
block|,
name|emit_pop
block|}
block|,
block|{
literal|"res"
block|,
literal|0xCB
block|,
literal|0x80
block|,
name|emit_bit
block|}
block|,
block|{
literal|"ret"
block|,
literal|0xC9
block|,
literal|0xC0
block|,
name|emit_retcc
block|}
block|,
block|{
literal|"reti"
block|,
literal|0xED
block|,
literal|0x4D
block|,
name|emit_insn
block|}
block|,
block|{
literal|"retn"
block|,
literal|0xED
block|,
literal|0x45
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rl"
block|,
literal|0xCB
block|,
literal|0x10
block|,
name|emit_mr
block|}
block|,
block|{
literal|"rla"
block|,
literal|0x00
block|,
literal|0x17
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rlc"
block|,
literal|0xCB
block|,
literal|0x00
block|,
name|emit_mr
block|}
block|,
block|{
literal|"rlca"
block|,
literal|0x00
block|,
literal|0x07
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rld"
block|,
literal|0xED
block|,
literal|0x6F
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rr"
block|,
literal|0xCB
block|,
literal|0x18
block|,
name|emit_mr
block|}
block|,
block|{
literal|"rra"
block|,
literal|0x00
block|,
literal|0x1F
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rrc"
block|,
literal|0xCB
block|,
literal|0x08
block|,
name|emit_mr
block|}
block|,
block|{
literal|"rrca"
block|,
literal|0x00
block|,
literal|0x0F
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rrd"
block|,
literal|0xED
block|,
literal|0x67
block|,
name|emit_insn
block|}
block|,
block|{
literal|"rst"
block|,
literal|0x00
block|,
literal|0xC7
block|,
name|emit_rst
block|}
block|,
block|{
literal|"sbc"
block|,
literal|0x98
block|,
literal|0x42
block|,
name|emit_adc
block|}
block|,
block|{
literal|"scf"
block|,
literal|0x00
block|,
literal|0x37
block|,
name|emit_insn
block|}
block|,
block|{
literal|"set"
block|,
literal|0xCB
block|,
literal|0xC0
block|,
name|emit_bit
block|}
block|,
block|{
literal|"sla"
block|,
literal|0xCB
block|,
literal|0x20
block|,
name|emit_mr
block|}
block|,
block|{
literal|"sli"
block|,
literal|0xCB
block|,
literal|0x30
block|,
name|emit_mr
block|}
block|,
block|{
literal|"sll"
block|,
literal|0xCB
block|,
literal|0x30
block|,
name|emit_mr
block|}
block|,
block|{
literal|"sra"
block|,
literal|0xCB
block|,
literal|0x28
block|,
name|emit_mr
block|}
block|,
block|{
literal|"srl"
block|,
literal|0xCB
block|,
literal|0x38
block|,
name|emit_mr
block|}
block|,
block|{
literal|"sub"
block|,
literal|0x00
block|,
literal|0x90
block|,
name|emit_s
block|}
block|,
block|{
literal|"xor"
block|,
literal|0x00
block|,
literal|0xA8
block|,
name|emit_s
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|old_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|table_t
modifier|*
name|insp
decl_stmt|;
name|err_flag
operator|=
literal|0
expr_stmt|;
name|old_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|BUFLEN
operator|)
operator|&&
operator|(
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
control|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BUFLEN
condition|)
block|{
name|buf
index|[
name|BUFLEN
operator|-
literal|3
index|]
operator|=
name|buf
index|[
name|BUFLEN
operator|-
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
comment|/* Mark opcode as abbreviated.  */
name|buf
index|[
name|BUFLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown instruction '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|key
operator|=
name|buf
expr_stmt|;
name|insp
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|instab
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|instab
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|instab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|key_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insp
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown instruction '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
name|insp
operator|->
name|fp
argument_list|(
name|insp
operator|->
name|prefix
argument_list|,
name|insp
operator|->
name|opcode
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_space
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|err_flag
operator|)
operator|&&
operator|*
name|p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line, first unrecognized character is `%c'"
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|=
name|old_ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
operator|(
operator|-
literal|128
operator|<=
name|val
operator|&&
name|val
operator|<
literal|128
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_no_overflow
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relative jump out of range"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_Z80_DISP8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fixP
operator|->
name|fx_no_overflow
operator|=
operator|(
operator|-
literal|128
operator|<=
name|val
operator|&&
name|val
operator|<
literal|128
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_no_overflow
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"index offset  out of range"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|val
operator|>
literal|255
operator|||
name|val
operator|<
operator|-
literal|128
condition|)
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"overflow"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24
case|:
comment|/* Def24 may produce this.  */
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
comment|/* Def32 and .long may produce this.  */
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"md_apply_fix: unknown r_type 0x%x\n"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GAS will call this to generate a reloc.  GAS will pass the    resulting reloc to `bfd_install_relocation'.  This currently works    poorly, as `bfd_install_relocation' often does the wrong thing, and    instances of `tc_gen_reloc' have been written to work around the    problems, which in turns makes it difficult to fix    `bfd_install_relocation'.  */
end_comment

begin_comment
comment|/* If while processing a fixup, a reloc really    needs to be created then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

