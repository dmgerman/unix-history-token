begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-openrisc.c -- Assembler for the OpenRISC family.    Copyright 2001, 2002, 2003, 2005, 2006 Free Software Foundation.    Contributed by Johan Rydberg, jrydberg@opencores.org     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/openrisc-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/openrisc-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|openrisc_insn
name|openrisc_insn
typedef|;
end_typedef

begin_struct
struct|struct
name|openrisc_insn
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|OPENRISC_SHORTOPTS
value|"m:"
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|OPENRISC_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|openrisc_machine
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ignore_pseudo
parameter_list|(
name|int
name|val
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|discard_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
name|openrisc_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"proc"
block|,
name|ignore_pseudo
block|,
literal|0
block|}
block|,
block|{
literal|"endproc"
block|,
name|ignore_pseudo
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|openrisc_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
literal|0
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|openrisc_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|int
name|last_insn_had_delay_slot
init|=
literal|0
decl_stmt|;
name|openrisc_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|openrisc_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last_insn_had_delay_slot
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_DELAY_SLOT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The syntax in the manual says constants begin with '#'.    We just ignore it.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface to relax_segment.  */
end_comment

begin_comment
comment|/* FIXME: Look through this.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:    1) most positive reach of this state,    2) most negative reach of this state,    3) how many bytes this mode will add to the size of the current frag    4) which index into the table to try if we can't fit into this one.  */
comment|/* The first entry must be unused because an `rlx_more' value of zero ends      each list.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* The displacement used by GAS is from the end of the 2 byte insn,      so we subtract 2 from the following.  */
comment|/* 16 bit insn, 8 bit disp -> 10 bit range.      This doesn't handle a branch in the right slot at the border:      the "& -4" isn't taken into account.  It's not important enough to      complicate things over it, so we subtract an extra 2 (or + 2 in -ve      case).  */
block|{
literal|511
operator|-
literal|2
operator|-
literal|2
block|,
operator|-
literal|512
operator|-
literal|2
operator|+
literal|2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* 32 bit insn, 24 bit disp -> 26 bit range.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* Same thing, but with leading nop for alignment.  */
block|{
literal|0x2000000
operator|-
literal|1
operator|-
literal|2
block|,
operator|-
literal|0x2000000
operator|-
literal|2
block|,
literal|4
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
parameter_list|)
block|{
comment|/* The only thing we have to handle here are symbols outside of the      current segment.  They may be undefined or in a different segment in      which case linker scripts may place them anywhere.      However, we can't finish the fragment here and emit the reloc as insn      alignment requirements may move the insn about.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
comment|/* The symbol is undefined in this segment. 	 Change the relaxation subtype to the max allowable and leave 	 all further handling to md_convert_frag.  */
name|fragP
operator|->
name|fr_subtype
operator|=
literal|2
expr_stmt|;
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update the recorded insn. 	   Fortunately we don't have to look very far. 	   FIXME: Change this to record in the instruction the next higher 	   relaxable insn to use.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|insn
operator|=
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|insn
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
argument_list|)
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_RELAXED
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* FIXME */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
comment|/* The symbol is undefined (or is defined but not in this section).        Let the linker figure it out.  */
return|return
literal|0
return|;
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|OPENRISC_OPERAND_ABS_26
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|BFD_RELOC_OPENRISC_ABS_26
expr_stmt|;
goto|goto
name|emit
goto|;
case|case
name|OPENRISC_OPERAND_DISP_26
case|:
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|BFD_RELOC_OPENRISC_REL_26
expr_stmt|;
goto|goto
name|emit
goto|;
case|case
name|OPENRISC_OPERAND_HI16
case|:
name|type
operator|=
name|BFD_RELOC_HI16
expr_stmt|;
goto|goto
name|emit
goto|;
case|case
name|OPENRISC_OPERAND_LO16
case|:
name|type
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
goto|goto
name|emit
goto|;
name|emit
label|:
return|return
name|type
return|;
default|default :
comment|/* avoid -Wall warning */
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK. */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|openrisc_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

