begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-vax.c - vax-specific -    Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002,    2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"vax-inst.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For FRAG_APPEND_1_CHAR macro in "frags.h" */
end_comment

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/vax.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line.  */
end_comment

begin_comment
comment|/* Note that for the VAX the are the same as comment_chars above.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    as in 0f123.456    or    0H1.234E-12 (see exp chars above).  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dDfFgGhH"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c .  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.  */
end_comment

begin_comment
comment|/* Hold details of an operand expression.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|exp_of_operand
index|[
name|VIT_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|seg_of_operand
index|[
name|VIT_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vax instruction after decoding.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vit
name|v
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hold details of big operands.  */
end_comment

begin_decl_stmt
name|LITTLENUM_TYPE
name|big_operand_bits
index|[
name|VIT_MAX_OPERANDS
index|]
index|[
name|SIZE_OF_LARGE_NUMBER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLONUM_TYPE
name|float_operand
index|[
name|VIT_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Above is made to point into big_operand_bits by md_begin().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_define
define|#
directive|define
name|GLOBAL_OFFSET_TABLE_NAME
value|"_GLOBAL_OFFSET_TABLE_"
end_define

begin_define
define|#
directive|define
name|PROCEDURE_LINKAGE_TABLE_NAME
value|"_PROCEDURE_LINKAGE_TABLE_"
end_define

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|PLT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_PROCEDURE_LINKAGE_TABLE_".  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|flag_hash_long_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -+ */
end_comment

begin_decl_stmt
name|int
name|flag_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1 */
end_comment

begin_decl_stmt
name|int
name|flag_show_after_trunc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -H */
end_comment

begin_decl_stmt
name|int
name|flag_no_hash_mixed_case
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h NUM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|int
name|flag_want_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -k */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* For VAX, relative addresses of "just the right length" are easy.    The branch displacement is always the last operand, even in    synthetic instructions.    For VAX, we encode the relax_substateTs (in e.g. fr_substate) as:    		    4       3       2       1       0	     bit number   	---/ /--+-------+-------+-------+-------+-------+   		|     what state ?	|  how long ?	|   	---/ /--+-------+-------+-------+-------+-------+     The "how long" bits are 00=byte, 01=word, 10=long.    This is a Un*x convention.    Not all lengths are legit for a given value of (what state).    The "how long" refers merely to the displacement length.    The address usually has some constant bytes in it as well.   groups for VAX address relaxing.   1.	"foo" pc-relative.  length of byte, word, long   2a.	J<cond> where<cond> is a simple flag test.  length of byte, word, long.  VAX opcodes are:	(Hex)  bneq/bnequ	12  beql/beqlu	13  bgtr		14  bleq		15  bgeq		18  blss		19  bgtru		1a  blequ		1b  bvc		1c  bvs		1d  bgequ/bcc	1e  blssu/bcs	1f  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcode, then 1-byte displacement.   2b.	J<cond> where cond tests a memory bit.  length of byte, word, long.  Vax opcodes are:	(Hex)  bbs		e0  bbc		e1  bbss		e2  bbcs		e3  bbsc		e4  bbcc		e5  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcde, longword-address, byte-address, 1-byte-displacement   2c.	J<cond> where cond tests low-order memory bit  length of byte,word,long.  Vax opcodes are:	(Hex)  blbs		e8  blbc		e9  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcode, longword-address, 1-byte displacement.   3.	Jbs/Jbr.  length of byte,word,long.  Vax opcodes are:	(Hex)  bsbb		10  brb		11  These are like (2) but there is no condition to reverse.  Always, 1 byte opcode, then displacement/absolute.   4a.	JacbX  length of word, long.  Vax opcodes are:	(Hex)  acbw		3d  acbf		4f  acbd		6f  abcb		9d  acbl		f1  acbg	      4ffd  acbh	      6ffd  Always, we cannot reverse the sense of the branch; we have a word  displacement.  The double-byte op-codes don't hurt: we never want to modify the  opcode, so we don't care how many bytes are between the opcode and  the operand.   4b.	JXobXXX  length of long, long, byte.  Vax opcodes are:	(Hex)  aoblss		f2  aobleq		f3  sobgeq		f4  sobgtr		f5  Always, we cannot reverse the sense of the branch; we have a byte  displacement.   The only time we need to modify the opcode is for class 2 instructions.  After relax() we may complement the lowest order bit of such instruction  to reverse sense of branch.   For class 2 instructions, we store context of "where is the opcode literal".  We can change an opcode's lowest order bit without breaking anything else.   We sometimes store context in the operand literal. This way we can figure out  after relax() what the original addressing mode was.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These displacements are relative to the start address of the    displacement.  The first letter is Byte, Word.  2nd letter is    Forward, Backward.  */
end_comment

begin_define
define|#
directive|define
name|BF
value|(1+ 127)
end_define

begin_define
define|#
directive|define
name|BB
value|(1+-128)
end_define

begin_define
define|#
directive|define
name|WF
value|(2+ 32767)
end_define

begin_define
define|#
directive|define
name|WB
value|(2+-32768)
end_define

begin_comment
comment|/* Dont need LF, LB because they always reach. [They are coded as 0.]  */
end_comment

begin_define
define|#
directive|define
name|C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX(a,b)
end_define

begin_comment
comment|/* This macro has no side-effects.  */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_define
define|#
directive|define
name|RELAX_STATE
parameter_list|(
name|s
parameter_list|)
value|((s)>> 2)
end_define

begin_define
define|#
directive|define
name|RELAX_LENGTH
parameter_list|(
name|s
parameter_list|)
value|((s)& 3)
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* error sentinel   0,0	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,1	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,2	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,3	*/
block|{
name|BF
operator|+
literal|1
block|,
name|BB
operator|+
literal|1
block|,
literal|2
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* B^"foo"	    1,0 */
block|{
name|WF
operator|+
literal|1
block|,
name|WB
operator|+
literal|1
block|,
literal|3
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* W^"foo"	    1,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* L^"foo"	    1,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    1,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* b<cond> B^"foo"  2,0 */
block|{
name|WF
operator|+
literal|2
block|,
name|WB
operator|+
literal|2
block|,
literal|4
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* br.+? brw X	    2,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* br.+? jmp X	    2,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    2,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* brb B^foo	    3,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* brw W^foo	    3,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* Jmp L^foo	    3,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    3,3 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* acb_ ^Wfoo	    4,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
comment|/* acb_,br,jmp L^foo4,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* Xob___,,foo      5,0 */
block|{
name|WF
operator|+
literal|4
block|,
name|WB
operator|+
literal|4
block|,
literal|6
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* Xob.+2,brb.+3,brw5,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|}
block|,
comment|/* Xob.+2,brb.+6,jmp5,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    5,3 */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|BF
end_undef

begin_undef
undef|#
directive|undef
name|BB
end_undef

begin_undef
undef|#
directive|undef
name|WF
end_undef

begin_undef
undef|#
directive|undef
name|WB
end_undef

begin_function_decl
name|void
name|float_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|flonum_gen2vax
parameter_list|(
name|char
parameter_list|,
name|FLONUM_TYPE
modifier|*
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"gfloat"
block|,
name|float_cons
block|,
literal|'g'
block|}
block|,
block|{
literal|"hfloat"
block|,
name|float_cons
block|,
literal|'h'
block|}
block|,
block|{
literal|"d_floating"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"f_floating"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"g_floating"
block|,
name|float_cons
block|,
literal|'g'
block|}
block|,
block|{
literal|"h_floating"
block|,
name|float_cons
block|,
literal|'h'
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATE_PC_RELATIVE
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_CONDITIONAL_BRANCH
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_ALWAYS_BRANCH
value|(3)
end_define

begin_comment
comment|/* includes BSB...  */
end_comment

begin_define
define|#
directive|define
name|STATE_COMPLEX_BRANCH
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_COMPLEX_HOP
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_BYTE
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_WORD
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_LONG
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_UNDF
value|(3)
end_define

begin_comment
comment|/* Symbol undefined in pass1.  */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_escape
end_escape

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
name|con
index|[]
parameter_list|,
name|valueT
name|value
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|number_to_chars_littleendian
argument_list|(
name|con
argument_list|,
name|value
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up some data or instructions after we find out the value of a symbol    that they reference.  */
end_comment

begin_function
name|void
comment|/* Knows about order of bytes in address.  */
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valueP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|valueT
name|value
init|=
operator|*
name|valueP
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
operator|)
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_PLT_PCREL
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_GOT_PCREL
operator|)
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|NO_RELOC
condition|)
name|number_to_chars_littleendian
argument_list|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a number from VAX byte order (little endian)    into host byte order.    con		is the buffer to convert,    nbytes	is the length of the given buffer.  */
end_comment

begin_function
specifier|static
name|long
name|md_chars_to_number
parameter_list|(
name|unsigned
name|char
name|con
index|[]
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|long
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
operator|,
name|con
operator|+=
name|nbytes
operator|-
literal|1
init|;
name|nbytes
operator|--
condition|;
name|con
operator|--
control|)
block|{
name|retval
operator|<<=
name|BITS_PER_CHAR
expr_stmt|;
name|retval
operator||=
operator|*
name|con
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Copy a bignum from in to out.    If the output is shorter than the input, copy lower-order    littlenums.  Return 0 or the number of significant littlenums    dropped.  Assumes littlenum arrays are densely packed: no unused    chars between the littlenums. Uses memcpy() to move littlenums, and    wants to know length (in chars) of the input bignum.  */
end_comment

begin_function
specifier|static
name|int
name|bignum_copy
parameter_list|(
name|LITTLENUM_TYPE
modifier|*
name|in
parameter_list|,
name|int
name|in_length
parameter_list|,
comment|/* in sizeof(littlenum)s */
name|LITTLENUM_TYPE
modifier|*
name|out
parameter_list|,
name|int
name|out_length
comment|/* in sizeof(littlenum)s */
parameter_list|)
block|{
name|int
name|significant_littlenums_dropped
decl_stmt|;
if|if
condition|(
name|out_length
operator|<
name|in_length
condition|)
block|{
name|LITTLENUM_TYPE
modifier|*
name|p
decl_stmt|;
comment|/* -> most significant (non-zero) input 				      littlenum.  */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|out
argument_list|,
operator|(
name|void
operator|*
operator|)
name|in
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|out_length
operator|<<
name|LITTLENUM_SHIFT
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|in
operator|+
name|in_length
operator|-
literal|1
init|;
name|p
operator|>=
name|in
condition|;
operator|--
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
condition|)
break|break;
block|}
name|significant_littlenums_dropped
operator|=
name|p
operator|-
name|in
operator|-
name|in_length
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|significant_littlenums_dropped
operator|<
literal|0
condition|)
name|significant_littlenums_dropped
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|in_length
operator|<<
name|LITTLENUM_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_length
operator|>
name|in_length
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|out
operator|+
name|in_length
operator|)
argument_list|,
literal|'\0'
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|out_length
operator|-
name|in_length
argument_list|)
operator|<<
name|LITTLENUM_SHIFT
argument_list|)
expr_stmt|;
name|significant_littlenums_dropped
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|significant_littlenums_dropped
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_estimate_size_before_relax(), called just before relax().    Any symbol that is now undefined will not become defined.    Return the correct fr_subtype in the frag and the growth beyond    fr_fix.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
parameter_list|)
block|{
if|if
condition|(
name|RELAX_LENGTH
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_UNDF
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
ifdef|#
directive|ifdef
name|OBJ_ELF
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* Non-relaxable cases.  */
name|int
name|reloc_type
init|=
name|NO_RELOC
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If this is to an undefined symbol, then if it's an indirect 	     reference indicate that is can mutated into a GLOB_DAT or 	     JUMP_SLOT by the loader.  We restrict ourselves to no offset 	     due to a limitation in the NetBSD linker.  */
if|if
condition|(
name|GOT_symbol
operator|==
name|NULL
condition|)
name|GOT_symbol
operator|=
name|symbol_find
argument_list|(
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLT_symbol
operator|==
name|NULL
condition|)
name|PLT_symbol
operator|=
name|symbol_find
argument_list|(
name|PROCEDURE_LINKAGE_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GOT_symbol
operator|==
name|NULL
operator|||
name|fragP
operator|->
name|fr_symbol
operator|!=
name|GOT_symbol
operator|)
operator|&&
operator|(
name|PLT_symbol
operator|==
name|NULL
operator|||
name|fragP
operator|->
name|fr_symbol
operator|!=
name|PLT_symbol
operator|)
operator|&&
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|&&
name|flag_want_pic
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x10
condition|)
block|{
if|if
condition|(
name|flag_want_pic
condition|)
name|as_fatal
argument_list|(
literal|"PIC reference to %s is indirect.\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|==
name|VAX_CALLS
operator|||
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|==
name|VAX_CALLG
operator|||
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|==
name|VAX_JSB
operator|||
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|)
index|[
literal|0
index|]
operator|==
name|VAX_JMP
operator|||
name|S_IS_FUNCTION
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
switch|switch
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|STATE_PC_RELATIVE
case|:
name|p
index|[
literal|0
index|]
operator||=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* Preserve @ bit.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH
case|:
operator|*
name|fragP
operator|->
name|fr_opcode
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of branch.  */
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(PC) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_COMPLEX_BRANCH
case|:
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(pc) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|6
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_COMPLEX_HOP
case|:
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(pc) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|5
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_ALWAYS_BRANCH
case|:
operator|*
name|fragP
operator|->
name|fr_opcode
operator|+=
name|VAX_WIDEN_LONG
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(PC) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/* Return the growth in the fixed part of the frag.  */
return|return
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
return|;
block|}
comment|/* Relaxable cases.  Set up the initial guess for the variable 	 part of the frag.  */
switch|switch
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|STATE_PC_RELATIVE
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_COMPLEX_BRANCH
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_COMPLEX_HOP
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_ALWAYS_BRANCH
case|:
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Return the size of the variable part of the frag.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called after relax() is finished.    In:	Address of frag.   	fr_type == rs_machine_dependent.   	fr_subtype is what the address relaxed to.     Out:	Any fixSs and constants are set up.   	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|char
modifier|*
name|addressP
decl_stmt|;
comment|/* -> _var to change.  */
name|char
modifier|*
name|opcodeP
decl_stmt|;
comment|/* -> opcode char(s) to change.  */
name|short
name|int
name|extension
init|=
literal|0
decl_stmt|;
comment|/* Size of relaxed address.  */
comment|/* Added to fr_fix: incl. ALL var chars.  */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|long
name|where
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|addressP
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|opcodeP
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit.  */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xAF
expr_stmt|;
comment|/* Byte displacement. */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit.  */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xCF
expr_stmt|;
comment|/* Word displacement. */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit.  */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xEF
expr_stmt|;
comment|/* Long word displacement. */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of test.  */
name|addressP
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRW
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of test.  */
name|addressP
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|+=
name|VAX_WIDEN_WORD
expr_stmt|;
comment|/* brb -> brw, bsbb -> bsbw */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|+=
name|VAX_WIDEN_LONG
expr_stmt|;
comment|/* brb -> jmp, bsbb -> jsb */
name|addressP
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|6
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
name|VAX_BRW
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|5
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|9
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate internal format of relocation info into target format.     On vax: first 4 bytes are normal unsigned long, next three bytes    are symbolnum, least sig. byte first.  Last byte is broken up with    the upper nibble as nuthin, bit 3 as extern, bits 2& 1 as length, and    bit 0 as pcrel.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|char
modifier|*
name|the_bytes
parameter_list|,
name|struct
name|reloc_info_generic
name|ri
parameter_list|)
block|{
comment|/* This is easy.  */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|.
name|r_address
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|.
name|r_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now the fun stuff.  */
name|the_bytes
index|[
literal|6
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|4
index|]
operator|=
name|ri
operator|.
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|.
name|r_extern
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_length
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|&
literal|0x0F
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_comment
comment|/*       BUGS, GRIPES,  APOLOGIA, etc.     The opcode table 'votstrs' needs to be sorted on opcode frequency.    That is, AFTER we hash it with hash_...(), we want most-used opcodes    to come out of the hash table faster.     I am sorry to inflict yet another VAX assembler on the world, but    RMS says we must do everything from scratch, to prevent pin-heads    restricting this software.     This is a vaguely modular set of routines in C to parse VAX    assembly code using DEC mnemonics. It is NOT un*x specific.     The idea here is that the assembler has taken care of all:      labels      macros      listing      pseudo-ops      line continuation      comments      condensing any whitespace down to exactly one space    and all we have to do is parse 1 line into a vax instruction    partially formed. We will accept a line, and deliver:      an error message (hopefully empty)      a skeleton VAX instruction (tree structure)      textual pointers to all the operand expressions      a warning message that notes a silly operand (hopefully empty)    		E D I T   H I S T O R Y     17may86 Dean Elsner. Bug if line ends immediately after opcode.    30apr86 Dean Elsner. New vip_op() uses arg block so change call.     6jan86 Dean Elsner. Crock vip_begin() to call vip_op_defaults().     2jan86 Dean Elsner. Invent synthetic opcodes.   	Widen vax_opcodeT to 32 bits. Use a bit for VIT_OPCODE_SYNTHETIC,   	which means this is not a real opcode, it is like a macro; it will   	be relax()ed into 1 or more instructions.   	Use another bit for VIT_OPCODE_SPECIAL if the op-code is not optimised   	like a regular branch instruction. Option added to vip_begin():   	exclude	synthetic opcodes. Invent synthetic_votstrs[].    31dec85 Dean Elsner. Invent vit_opcode_nbytes.   	Also make vit_opcode into a char[]. We now have n-byte vax opcodes,   	so caller's don't have to know the difference between a 1-byte& a   	2-byte op-code. Still need vax_opcodeT concept, so we know how   	big an object must be to hold an op.code.    30dec85 Dean Elsner. Widen typedef vax_opcodeT in "vax-inst.h"   	because vax opcodes may be 16 bits. Our crufty C compiler was   	happily initialising 8-bit vot_codes with 16-bit numbers!   	(Wouldn't the 'phone company like to compress data so easily!)    29dec85 Dean Elsner. New static table vax_operand_width_size[].   	Invented so we know hw many bytes a "I^#42" needs in its immediate   	operand. Revised struct vop in "vax-inst.h": explicitly include   	byte length of each operand, and it's letter-code datum type.    17nov85 Dean Elsner. Name Change.   	Due to ar(1) truncating names, we learned the hard way that   	"vax-inst-parse.c" -> "vax-inst-parse." dropping the "o" off   	the archived object name. SO... we shortened the name of this   	source file, and changed the makefile.  */
end_comment

begin_comment
comment|/* Handle of the OPCODE hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In:	1 character, from "bdfghloqpw" being the data-type of an operand   	of a vax instruction.     Out:	the length of an operand of that type, in bytes.   	Special branch operands types "-?!" have length 0.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|vax_operand_width_size
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
comment|/* ..b.d.fgh...l..o  */
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* .q.....w........  */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
comment|/* ..b.d.fgh...l..o  */
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* .q.....w........  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This perversion encodes all the vax opcodes as a bunch of strings.    RMS says we should build our hash-table at run-time. Hmm.    Please would someone arrange these in decreasing frequency of opcode?    Because of the way hash_...() works, the most frequently used opcode    should be textually first and so on.     Input for this table was 'vax.opcodes', awk(1)ed by 'vax.opcodes.c.awk' .    So change 'vax.opcodes', then re-generate this table.  */
end_comment

begin_include
include|#
directive|include
file|"opcode/vax.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This is a table of optional op-codes. All of them represent    'synthetic' instructions that seem popular.     Here we make some pseudo op-codes. Every code has a bit set to say    it is synthetic. This lets you catch them if you want to    ban these opcodes. They are mnemonics for "elastic" instructions    that are supposed to assemble into the fewest bytes needed to do a    branch, or to do a conditional branch, or whatever.       The opcode is in the usual place [low-order n*8 bits]. This means    that if you mask off the bucky bits, the usual rules apply about    how long the opcode is.       All VAX branch displacements come at the end of the instruction.    For simple branches (1-byte opcode + 1-byte displacement) the last    operand is coded 'b?' where the "data type" '?' is a clue that we    may reverse the sense of the branch (complement lowest order bit)    and branch around a jump. This is by far the most common case.    That is why the VIT_OPCODE_SYNTHETIC bit is set: it says this is    a 0-byte op-code followed by 2 or more bytes of operand address.       If the op-code has VIT_OPCODE_SPECIAL set, then we have a more unusual    case.       For JBSB& JBR the treatment is the similar, except (1) we have a 'bw'    option before (2) we can directly JSB/JMP because there is no condition.    These operands have 'b-' as their access/data type.       That leaves a bunch of random opcodes: JACBx, JxOBxxx. In these    cases, we do the same idea. JACBxxx are all marked with a 'b!'    JAOBxxx& JSOBxxx are marked with a 'b:'.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|VIT_OPCODE_SYNTHETIC
operator|!=
literal|0x80000000
operator|)
end_if

begin_error
error|#
directive|error
literal|"You have just broken the encoding below, which assumes the sign bit means 'I am an imaginary instruction'."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|VIT_OPCODE_SPECIAL
operator|!=
literal|0x40000000
operator|)
end_if

begin_error
error|#
directive|error
literal|"You have just broken the encoding below, which assumes the 0x40 M bit means 'I am not to be "
error|optimised" the way normal branches are'."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vot
name|synthetic_votstrs
index|[]
init|=
block|{
block|{
literal|"jbsb"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000010
block|}
block|}
block|,
comment|/* BSD 4.2 */
comment|/* jsb used already */
block|{
literal|"jbr"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000011
block|}
block|}
block|,
comment|/* BSD 4.2 */
block|{
literal|"jr"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000011
block|}
block|}
block|,
comment|/* consistent */
block|{
literal|"jneq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000012
block|}
block|}
block|,
block|{
literal|"jnequ"
block|,
block|{
literal|"b?"
block|,
literal|0x80000012
block|}
block|}
block|,
block|{
literal|"jeql"
block|,
block|{
literal|"b?"
block|,
literal|0x80000013
block|}
block|}
block|,
block|{
literal|"jeqlu"
block|,
block|{
literal|"b?"
block|,
literal|0x80000013
block|}
block|}
block|,
block|{
literal|"jgtr"
block|,
block|{
literal|"b?"
block|,
literal|0x80000014
block|}
block|}
block|,
block|{
literal|"jleq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000015
block|}
block|}
block|,
comment|/* un-used opcodes here */
block|{
literal|"jgeq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000018
block|}
block|}
block|,
block|{
literal|"jlss"
block|,
block|{
literal|"b?"
block|,
literal|0x80000019
block|}
block|}
block|,
block|{
literal|"jgtru"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001a
block|}
block|}
block|,
block|{
literal|"jlequ"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001b
block|}
block|}
block|,
block|{
literal|"jvc"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001c
block|}
block|}
block|,
block|{
literal|"jvs"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001d
block|}
block|}
block|,
block|{
literal|"jgequ"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001e
block|}
block|}
block|,
block|{
literal|"jcc"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001e
block|}
block|}
block|,
block|{
literal|"jlssu"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001f
block|}
block|}
block|,
block|{
literal|"jcs"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001f
block|}
block|}
block|,
block|{
literal|"jacbw"
block|,
block|{
literal|"rwrwmwb!"
block|,
literal|0xC000003d
block|}
block|}
block|,
block|{
literal|"jacbf"
block|,
block|{
literal|"rfrfmfb!"
block|,
literal|0xC000004f
block|}
block|}
block|,
block|{
literal|"jacbd"
block|,
block|{
literal|"rdrdmdb!"
block|,
literal|0xC000006f
block|}
block|}
block|,
block|{
literal|"jacbb"
block|,
block|{
literal|"rbrbmbb!"
block|,
literal|0xC000009d
block|}
block|}
block|,
block|{
literal|"jacbl"
block|,
block|{
literal|"rlrlmlb!"
block|,
literal|0xC00000f1
block|}
block|}
block|,
block|{
literal|"jacbg"
block|,
block|{
literal|"rgrgmgb!"
block|,
literal|0xC0004ffd
block|}
block|}
block|,
block|{
literal|"jacbh"
block|,
block|{
literal|"rhrhmhb!"
block|,
literal|0xC0006ffd
block|}
block|}
block|,
block|{
literal|"jbs"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e0
block|}
block|}
block|,
block|{
literal|"jbc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e1
block|}
block|}
block|,
block|{
literal|"jbss"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e2
block|}
block|}
block|,
block|{
literal|"jbcs"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e3
block|}
block|}
block|,
block|{
literal|"jbsc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e4
block|}
block|}
block|,
block|{
literal|"jbcc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e5
block|}
block|}
block|,
block|{
literal|"jlbs"
block|,
block|{
literal|"rlb?"
block|,
literal|0x800000e8
block|}
block|}
block|,
block|{
literal|"jlbc"
block|,
block|{
literal|"rlb?"
block|,
literal|0x800000e9
block|}
block|}
block|,
block|{
literal|"jaoblss"
block|,
block|{
literal|"rlmlb:"
block|,
literal|0xC00000f2
block|}
block|}
block|,
block|{
literal|"jaobleq"
block|,
block|{
literal|"rlmlb:"
block|,
literal|0xC00000f3
block|}
block|}
block|,
block|{
literal|"jsobgeq"
block|,
block|{
literal|"mlb:"
block|,
literal|0xC00000f4
block|}
block|}
block|,
block|{
literal|"jsobgtr"
block|,
block|{
literal|"mlb:"
block|,
literal|0xC00000f5
block|}
block|}
block|,
comment|/* CASEx has no branch addresses in our conception of it.  */
comment|/* You should use ".word ..." statements after the "case ...".  */
block|{
literal|""
block|,
block|{
literal|""
block|,
literal|0
block|}
block|}
comment|/* Empty is end sentinel.  */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Because this module is useful for both VMS and UN*X style assemblers    and because of the variety of UN*X assemblers we must recognise    the different conventions for assembler operand notation. For example    VMS says "#42" for immediate mode, while most UN*X say "$42".    We permit arbitrary sets of (single) characters to represent the    3 concepts that DEC writes '#', '@', '^'.  */
end_comment

begin_comment
comment|/* Character tests.  */
end_comment

begin_define
define|#
directive|define
name|VIP_IMMEDIATE
value|01
end_define

begin_comment
comment|/* Character is like DEC # */
end_comment

begin_define
define|#
directive|define
name|VIP_INDIRECT
value|02
end_define

begin_comment
comment|/* Char is like DEC @ */
end_comment

begin_define
define|#
directive|define
name|VIP_DISPLEN
value|04
end_define

begin_comment
comment|/* Char is like DEC ^ */
end_comment

begin_define
define|#
directive|define
name|IMMEDIATEP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters [(c)& 0xff]& VIP_IMMEDIATE)
end_define

begin_define
define|#
directive|define
name|INDIRECTP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters [(c)& 0xff]& VIP_INDIRECT)
end_define

begin_define
define|#
directive|define
name|DISPLENP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters [(c)& 0xff]& VIP_DISPLEN)
end_define

begin_comment
comment|/* We assume 8 bits per byte. Use vip_op_defaults() to set these up BEFORE we    are ever called.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONST_TABLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|_
value|0,
end_define

begin_define
define|#
directive|define
name|I
value|VIP_IMMEDIATE,
end_define

begin_define
define|#
directive|define
name|S
value|VIP_INDIRECT,
end_define

begin_define
define|#
directive|define
name|D
value|VIP_DISPLEN,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vip_metacharacters
index|[
literal|256
index|]
init|=
block|{
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/* ^@ ^A ^B ^C ^D ^E ^F ^G ^H ^I ^J ^K ^L ^M ^N ^O*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/* ^P ^Q ^R ^S ^T ^U ^V ^W ^X ^Y ^Z ^[ ^\ ^] ^^ ^_ */
name|_
name|_
name|_
name|_
name|I
name|_
name|_
name|_
name|_
name|_
name|S
name|_
name|_
name|_
name|_
name|_
comment|/* sp !  "  #  $  %& '  (  )  *  +  ,  -  .  / */
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*0  1  2  3  4  5  6  7  8  9  :  ;<  =>  ?*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*@  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _*/
name|D
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*`  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^?*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_undef
undef|#
directive|undef
name|I
end_undef

begin_undef
undef|#
directive|undef
name|S
end_undef

begin_undef
undef|#
directive|undef
name|D
end_undef

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|vip_metacharacters
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vip_op_1
parameter_list|(
name|int
name|bit
parameter_list|,
specifier|const
name|char
modifier|*
name|syms
parameter_list|)
block|{
name|unsigned
name|char
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
operator|*
name|syms
operator|++
operator|)
operator|!=
literal|0
condition|)
name|vip_metacharacters
index|[
name|t
index|]
operator||=
name|bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Can be called any time.  More arguments may appear in future.  */
end_comment

begin_function
specifier|static
name|void
name|vip_op_defaults
parameter_list|(
specifier|const
name|char
modifier|*
name|immediate
parameter_list|,
specifier|const
name|char
modifier|*
name|indirect
parameter_list|,
specifier|const
name|char
modifier|*
name|displen
parameter_list|)
block|{
name|vip_op_1
argument_list|(
name|VIP_IMMEDIATE
argument_list|,
name|immediate
argument_list|)
expr_stmt|;
name|vip_op_1
argument_list|(
name|VIP_INDIRECT
argument_list|,
name|indirect
argument_list|)
expr_stmt|;
name|vip_op_1
argument_list|(
name|VIP_DISPLEN
argument_list|,
name|displen
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Call me once before you decode any lines.    I decode votstrs into a hash table at op_hash (which I create).    I return an error text or null.    If you want, I will include the 'synthetic' jXXX instructions in the    instruction table.    You must nominate metacharacters for eg DEC's "#", "@", "^".  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|vip_begin
parameter_list|(
name|int
name|synthetic_too
parameter_list|,
comment|/* 1 means include jXXX op-codes.  */
specifier|const
name|char
modifier|*
name|immediate
parameter_list|,
specifier|const
name|char
modifier|*
name|indirect
parameter_list|,
specifier|const
name|char
modifier|*
name|displen
parameter_list|)
block|{
specifier|const
name|struct
name|vot
modifier|*
name|vP
decl_stmt|;
comment|/* scan votstrs */
specifier|const
name|char
modifier|*
name|retval
init|=
literal|0
decl_stmt|;
comment|/* error text */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|vP
operator|=
name|votstrs
init|;
operator|*
name|vP
operator|->
name|vot_name
operator|&&
operator|!
name|retval
condition|;
name|vP
operator|++
control|)
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|vP
operator|->
name|vot_name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|vP
operator|->
name|vot_detail
argument_list|)
expr_stmt|;
if|if
condition|(
name|synthetic_too
condition|)
for|for
control|(
name|vP
operator|=
name|synthetic_votstrs
init|;
operator|*
name|vP
operator|->
name|vot_name
operator|&&
operator|!
name|retval
condition|;
name|vP
operator|++
control|)
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|vP
operator|->
name|vot_name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|vP
operator|->
name|vot_detail
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CONST_TABLE
name|vip_op_defaults
argument_list|(
name|immediate
argument_list|,
name|indirect
argument_list|,
name|displen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Take 3 char.s, the last of which may be `\0` (non-existent)    and return the VAX register number that they represent.       Return -1 if they don't form a register name. Good names return    a number from 0:15 inclusive.       Case is not important in a name.       Register names understood are:      	R0   	R1   	R2   	R3   	R4   	R5   	R6    	R7   	R8   	R9   	R10   	R11   	R12	AP   	R13	FP   	R14	SP   	R15	PC  */
end_comment

begin_define
define|#
directive|define
name|AP
value|12
end_define

begin_define
define|#
directive|define
name|FP
value|13
end_define

begin_define
define|#
directive|define
name|SP
value|14
end_define

begin_define
define|#
directive|define
name|PC
value|15
end_define

begin_comment
comment|/* Returns the register number of something like '%r15' or 'ap', supplied    in four single chars. Returns -1 if the register isn't recognized,    0..15 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|vax_reg_parse
parameter_list|(
name|char
name|c1
parameter_list|,
name|char
name|c2
parameter_list|,
name|char
name|c3
parameter_list|,
name|char
name|c4
parameter_list|)
block|{
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|c1
operator|!=
literal|'%'
condition|)
comment|/* Register prefixes are mandatory for ELF.  */
return|return
name|retval
return|;
name|c1
operator|=
name|c2
expr_stmt|;
name|c2
operator|=
name|c3
expr_stmt|;
name|c3
operator|=
name|c4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_VMS
if|if
condition|(
name|c4
operator|!=
literal|0
condition|)
comment|/* Register prefixes are not allowed under VMS.  */
return|return
name|retval
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_AOUT
if|if
condition|(
name|c1
operator|==
literal|'%'
condition|)
comment|/* Register prefixes are optional under a.out.  */
block|{
name|c1
operator|=
name|c2
expr_stmt|;
name|c2
operator|=
name|c3
expr_stmt|;
name|c3
operator|=
name|c4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c3
operator|&&
name|c4
condition|)
comment|/* Can't be 4 characters long.  */
return|return
name|retval
return|;
endif|#
directive|endif
name|c1
operator|=
name|TOLOWER
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TOLOWER
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c2
argument_list|)
operator|&&
name|c1
operator|==
literal|'r'
condition|)
block|{
name|retval
operator|=
name|c2
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c3
argument_list|)
condition|)
block|{
name|retval
operator|=
name|retval
operator|*
literal|10
operator|+
name|c3
operator|-
literal|'0'
expr_stmt|;
name|retval
operator|=
operator|(
name|retval
operator|>
literal|15
operator|)
condition|?
operator|-
literal|1
else|:
name|retval
expr_stmt|;
comment|/* clamp the register value to 1 hex digit */
block|}
elseif|else
if|if
condition|(
name|c3
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* c3 must be '\0' or a digit.  */
block|}
elseif|else
if|if
condition|(
name|c3
condition|)
comment|/* There are no three letter regs.  */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'p'
condition|)
block|{
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
literal|'s'
case|:
name|retval
operator|=
name|SP
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|retval
operator|=
name|FP
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|retval
operator|=
name|AP
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'p'
operator|&&
name|c2
operator|==
literal|'c'
condition|)
name|retval
operator|=
name|PC
expr_stmt|;
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Parse a vax operand in DEC assembler notation.    For speed, expect a string of whitespace to be reduced to a single ' '.    This is the case for GNU AS, and is easy for other DEC-compatible    assemblers.       Knowledge about DEC VAX assembler operand notation lives here.    This doesn't even know what a register name is, except it believes    all register names are 2 or 3 characters, and lets vax_reg_parse() say    what number each name represents.    It does, however, know that PC, SP etc are special registers so it can    detect addressing modes that are silly for those registers.       Where possible, it delivers 1 fatal or 1 warning message if the operand    is suspect. Exactly what we test for is still evolving.     ---   	Arg block.       There were a number of 'mismatched argument type' bugs to vip_op.    The most general solution is to typedef each (of many) arguments.    We used instead a typedef'd argument block. This is less modular    than using separate return pointers for each result, but runs faster    on most engines, and seems to keep programmers happy. It will have    to be done properly if we ever want to use vip_op as a general-purpose    module (it was designed to be).     	G^     Doesn't support DEC "G^" format operands. These always take 5 bytes    to express, and code as modes 8F or 9F. Reason: "G^" deprives you of    optimising to (say) a "B^" if you are lucky in the way you link.    When someone builds a linker smart enough to convert "G^" to "B^", "W^"    whenever possible, then we should implement it.    If there is some other use for "G^", feel free to code it in!    	speed       If I nested if()s more, I could avoid testing (*err) which would save    time, space and page faults. I didn't nest all those if()s for clarity    and because I think the mode testing can be re-arranged 1st to test the    commoner constructs 1st. Does anybody have statistics on this?        	error messages       In future, we should be able to 'compose' error messages in a scratch area    and give the user MUCH more informative error messages. Although this takes    a little more code at run-time, it will make this module much more self-    documenting. As an example of what sucks now: most error messages have    hardwired into them the DEC VAX metacharacters "#^@" which are nothing like    the Un*x characters "$`*", that most users will expect from this AS.     ----        The input is a string, ending with '\0'.       We also require a 'hint' of what kind of operand is expected: so    we can remind caller not to write into literals for instance.       The output is a skeletal instruction.       The algorithm has two parts.    1. extract the syntactic features (parse off all the @^#-()+[] mode crud);    2. express the @^#-()+[] as some parameters suited to further analysis.       2nd step is where we detect the googles of possible invalid combinations    a human (or compiler) might write. Note that if we do a half-way    decent assembler, we don't know how long to make (eg) displacement    fields when we first meet them (because they may not have defined values).    So we must wait until we know how many bits are needed for each address,    then we can know both length and opcodes of instructions.    For reason(s) above, we will pass to our caller a 'broken' instruction    of these major components, from which our caller can generate instructions:     -  displacement length      I^ S^ L^ B^ W^ unspecified     -  mode                     (many)     -  register                 R0-R15 or absent     -  index register           R0-R15 or absent     -  expression text          what we don't parse     -  error text(s)            why we couldn't understand the operand     ----         To decode output of this, test errtxt. If errtxt[0] == '\0', then    we had no errors that prevented parsing. Also, if we ever report    an internal bug, errtxt[0] is set non-zero. So one test tells you    if the other outputs are to be taken seriously.     ----        Dec defines the semantics of address modes (and values)    by a two-letter code, explained here.         letter 1:   access type           a         address calculation - no data access, registers forbidden        b         branch displacement        m         read - let go of bus - write back    "modify"        r         read        v         bit field address: like 'a' but registers are OK        w         write        space	 no operator (eg ".long foo") [our convention]         letter 2:   data type (i.e. width, alignment)           b         byte        d         double precision floating point (D format)        f         single precision floating point (F format)        g         G format floating        h         H format floating        l         longword        o         octaword        q         quadword        w         word        ?	 simple synthetic branch operand        -	 unconditional synthetic JSB/JSR operand        !	 complex synthetic branch operand       The '-?!' letter 2's are not for external consumption. They are used    for various assemblers. Generally, all unknown widths are assumed 0.    We don't limit your choice of width character.       DEC operands are hard work to parse. For example, '@' as the first    character means indirect (deferred) mode but elsewhere it is a shift    operator.    The long-winded explanation of how this is supposed to work is    cancelled. Read a DEC vax manual.    We try hard not to parse anything that MIGHT be part of the expression    buried in that syntax. For example if we see @...(Rn) we don't check    for '-' before the '(' because mode @-(Rn) does not exist.       After parsing we have:       at                     1 if leading '@' (or Un*x '*')    len                    takes one value from " bilsw". eg B^ -> 'b'.    hash                   1 if leading '#' (or Un*x '$')    expr_begin, expr_end   the expression we did not parse                           even though we don't interpret it, we make use                           of its presence or absence.    sign                   -1: -(Rn)    0: absent    +1: (Rn)+    paren                  1 if () are around register    reg                    major register number 0:15    -1 means absent    ndx                    index register number 0:15    -1 means absent       Again, I dare not explain it: just trace ALL the code!     Summary of vip_op outputs.    mode	reg	len	ndx   (Rn) => @Rn   {@}Rn			5+@	n	' '	optional   branch operand		0	-1	' '	-1   S^#foo			0	-1	's'	-1   -(Rn)			7	n	' '	optional   {@}(Rn)+		8+@	n	' '	optional   {@}#foo, no S^		8+@	PC	" i"	optional   {@}{q^}{(Rn)}		10+@+q	option	" bwl"	optional  */
end_comment

begin_comment
comment|/* Dissect user-input 'optext' (which is something like "@B^foo@bar(AP)[FP]:")    using the vop in vopP. vopP's vop_access and vop_width. We fill _ndx, _reg,    _mode, _short, _warn, _error, _expr_begin, _expr_end and _nbytes.  */
end_comment

begin_function
specifier|static
name|void
name|vip_op
parameter_list|(
name|char
modifier|*
name|optext
parameter_list|,
name|struct
name|vop
modifier|*
name|vopP
parameter_list|)
block|{
comment|/* Track operand text forward.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Track operand text backward.  */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* 1 if leading '@' ('*') seen.  */
name|int
name|at
decl_stmt|;
comment|/* one of " bilsw" */
name|char
name|len
decl_stmt|;
comment|/* 1 if leading '#' ('$') seen.  */
name|int
name|hash
decl_stmt|;
comment|/* -1, 0 or +1.  */
name|int
name|sign
init|=
literal|0
decl_stmt|;
comment|/* 1 if () surround register.  */
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* Register number, -1:absent.  */
name|int
name|reg
init|=
literal|0
decl_stmt|;
comment|/* Index register number -1:absent.  */
name|int
name|ndx
init|=
literal|0
decl_stmt|;
comment|/* Report illegal operand, ""==OK.  */
comment|/* " " is a FAKE error: means we won.  */
comment|/* ANY err that begins with ' ' is a fake.  */
comment|/* " " is converted to "" before return.  */
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
comment|/* Warn about weird modes pf address.  */
specifier|const
name|char
modifier|*
name|wrn
decl_stmt|;
comment|/* Preserve q in case we backup.  */
name|char
modifier|*
name|oldq
init|=
name|NULL
decl_stmt|;
comment|/* Build up 4-bit operand mode here.  */
comment|/* Note: index mode is in ndx, this is.  */
comment|/* The major mode of operand address.  */
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* Notice how we move wrong-arg-type bugs INSIDE this module: if we      get the types wrong below, we lose at compile time rather than at      lint or run time.  */
name|char
name|access_mode
decl_stmt|;
comment|/* vop_access.  */
name|char
name|width
decl_stmt|;
comment|/* vop_width.  */
name|access_mode
operator|=
name|vopP
operator|->
name|vop_access
expr_stmt|;
name|width
operator|=
name|vopP
operator|->
name|vop_width
expr_stmt|;
comment|/* None of our code bugs (yet), no user text errors, no warnings      even.  */
name|err
operator|=
name|wrn
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|optext
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|p
operator|++
expr_stmt|;
comment|/* skip over whitespace */
if|if
condition|(
operator|(
name|at
operator|=
name|INDIRECTP
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 1 if *p=='@'(or '*' for Un*x) */
name|p
operator|++
expr_stmt|;
comment|/* at is determined */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|p
operator|++
expr_stmt|;
comment|/* skip over whitespace */
block|}
comment|/* This code is subtle. It tries to detect all legal (letter)'^'      but it doesn't waste time explicitly testing for premature '\0' because      this case is rejected as a mismatch against either (letter) or '^'.  */
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
name|c
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISPLENP
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"bilws"
argument_list|,
name|len
operator|=
name|c
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Skip (letter) '^'.  */
else|else
comment|/* No (letter) '^' seen.  */
name|len
operator|=
literal|' '
expr_stmt|;
comment|/* Len is determined.  */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|=
name|IMMEDIATEP
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* 1 if *p=='#' ('$' for Un*x) */
name|p
operator|++
expr_stmt|;
comment|/* Hash is determined.  */
comment|/* p points to what may be the beginning of an expression.      We have peeled off the front all that is peelable.      We know at, len, hash.           Lets point q at the end of the text and parse that (backwards).  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
empty_stmt|;
name|q
operator|--
expr_stmt|;
comment|/* Now q points at last char of text.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|q
operator|--
expr_stmt|;
comment|/* Reverse over whitespace, but don't.  */
comment|/* Run back over *p.  */
comment|/* As a matter of policy here, we look for [Rn], although both Rn and S^#      forbid [Rn]. This is because it is easy, and because only a sick      cyborg would have [...] trailing an expression in a VAX-like assembler.      A meticulous parser would first check for Rn followed by '(' or '['      and not parse a trailing ']' if it found another. We just ban expressions      ending in ']'.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|']'
condition|)
block|{
while|while
condition|(
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|'['
condition|)
name|q
operator|--
expr_stmt|;
comment|/* Either q<p or we got matching '['.  */
if|if
condition|(
name|q
operator|<
name|p
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"no '[' to match ']'"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Confusers like "[]" will eventually lose with a bad register 	   * name error. So again we don't need to check for early '\0'.  */
if|if
condition|(
name|q
index|[
literal|3
index|]
operator|==
literal|']'
condition|)
name|ndx
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|==
literal|']'
condition|)
name|ndx
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|5
index|]
operator|==
literal|']'
condition|)
name|ndx
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|ndx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Since we saw a ']' we will demand a register name in the []. 	   * If luser hasn't given us one: be rude.  */
if|if
condition|(
name|ndx
operator|<
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"bad register in []"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|==
name|PC
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"[PC] index banned"
argument_list|)
expr_stmt|;
else|else
comment|/* Point q just before "[...]".  */
name|q
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* No ']', so no iNDeX register.  */
name|ndx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If err = "..." then we lost: run away.      Otherwise ndx == -1 if there was no "[...]".      Otherwise, ndx is index register number, and q points before "[...]".  */
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|q
operator|--
expr_stmt|;
comment|/* Reverse over whitespace, but don't.  */
comment|/* Run back over *p.  */
if|if
condition|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
condition|)
block|{
comment|/* no ()+ or -() seen yet */
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|p
operator|+
literal|3
operator|&&
operator|*
name|q
operator|==
literal|'+'
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* we saw a ")+" */
name|q
operator|--
expr_stmt|;
comment|/* q points to ')' */
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|')'
operator|&&
name|q
operator|>
name|p
operator|+
literal|2
condition|)
block|{
name|paren
operator|=
literal|1
expr_stmt|;
comment|/* assume we have "(...)" */
while|while
condition|(
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|'('
condition|)
name|q
operator|--
expr_stmt|;
comment|/* either q<p or we got matching '(' */
if|if
condition|(
name|q
operator|<
name|p
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"no '(' to match ')'"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Confusers like "()" will eventually lose with a bad register 	         name error. So again we don't need to check for early '\0'.  */
if|if
condition|(
name|q
index|[
literal|3
index|]
operator|==
literal|')'
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|==
literal|')'
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|5
index|]
operator|==
literal|')'
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Since we saw a ')' we will demand a register name in the ')'. 	         This is nasty: why can't our hypothetical assembler permit 	         parenthesised expressions? BECAUSE I AM LAZY! That is why. 	         Abuse luser if we didn't spy a register name.  */
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
block|{
comment|/* JF allow parenthesized expressions.  I hope this works.  */
name|paren
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|')'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* err = "unknown register in ()"; */
block|}
else|else
name|q
operator|--
expr_stmt|;
comment|/* point just before '(' of "(...)" */
comment|/* If err == "..." then we lost. Run away. 	         Otherwise if reg>= 0 then we saw (Rn).  */
block|}
comment|/* If err == "..." then we lost. 	     Otherwise paren==1 and reg = register in "()".  */
block|}
else|else
name|paren
operator|=
literal|0
expr_stmt|;
comment|/* If err == "..." then we lost.          Otherwise, q points just before "(Rn)", if any.          If there was a "(...)" then paren==1, and reg is the register.  */
comment|/* We should only seek '-' of "-(...)" if:            we saw "(...)"                    paren == 1            we have no errors so far          ! *err            we did not see '+' of "(...)+"    sign< 1          We don't check len. We want a specific error message later if          user tries "x^...-(Rn)". This is a feature not a bug.  */
if|if
condition|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
condition|)
block|{
if|if
condition|(
name|paren
operator|&&
name|sign
operator|<
literal|1
condition|)
comment|/* !sign is adequate test */
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
block|}
comment|/* We have back-tracked over most 	     of the crud at the end of an operand. 	     Unless err, we know: sign, paren. If paren, we know reg. 	     The last case is of an expression "Rn". 	     This is worth hunting for if !err, !paren. 	     We wouldn't be here if err. 	     We remember to save q, in case we didn't want "Rn" anyway.  */
if|if
condition|(
operator|!
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '.  */
name|q
operator|--
expr_stmt|;
comment|/* Reverse over whitespace, but don't.  */
comment|/* Run back over *p.  */
comment|/* Room for Rn or Rnn (include prefix) exactly?  */
if|if
condition|(
name|q
operator|>
name|p
operator|&&
name|q
operator|<
name|p
operator|+
literal|4
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|q
operator|<
name|p
operator|+
literal|2
condition|?
literal|0
else|:
name|p
index|[
literal|2
index|]
argument_list|,
name|q
operator|<
name|p
operator|+
literal|3
condition|?
literal|0
else|:
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Always comes here if no register at all.  */
comment|/* Here with a definitive reg value.  */
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
name|oldq
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|p
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* have reg. -1:absent; else 0:15.  */
comment|/* We have:  err, at, len, hash, ndx, sign, paren, reg.      Also, any remaining expression is from *p through *q inclusive.      Should there be no expression, q==p-1. So expression length = q-p+1.      This completes the first part: parsing the operand text.  */
comment|/* We now want to boil the data down, checking consistency on the way.      We want:  len, mode, reg, ndx, err, p, q, wrn, bug.      We will deliver a 4-bit reg, and a 4-bit mode.  */
comment|/* Case of branch operand. Different. No L^B^W^I^S^ allowed for instance.           in:  at	?           len	?           hash	?           p:q	?           sign  ?           paren	?           reg   ?           ndx   ?           out: mode  0           reg   -1           len	' '           p:q	whatever was input           ndx	-1           err	" "		 or error message, and other outputs trashed.  */
comment|/* Branch operands have restricted forms.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|access_mode
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|at
operator|||
name|hash
operator|||
name|sign
operator|||
name|paren
operator|||
name|ndx
operator|>=
literal|0
operator|||
name|reg
operator|>=
literal|0
operator|||
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"invalid branch operand"
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
literal|" "
expr_stmt|;
block|}
comment|/* Since nobody seems to use it: comment this 'feature'(?) out for now.  */
ifdef|#
directive|ifdef
name|NEVER
comment|/* Case of stand-alone operand. e.g. ".long foo"           in:  at	?           len	?           hash	?           p:q	?           sign  ?           paren	?           reg   ?           ndx   ?           out: mode  0           reg   -1           len	' '           p:q	whatever was input           ndx	-1           err	" "		 or error message, and other outputs trashed.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|access_mode
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|at
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits @"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hash
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits #"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
condition|)
block|{
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits -()"
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits ()+"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paren
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits ()"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits []"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"address prohibits displacement length specifier"
argument_list|)
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* succeed */
name|mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Case of S^#.           in:  at       0           len      's'               definition           hash     1              demand           p:q                        demand not empty           sign     0                 by paren==0           paren    0             by "()" scan logic because "S^" seen           reg      -1                or nn by mistake           ndx      -1           out: mode     0           reg      -1           len      's'           exp           ndx      -1  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|len
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|!
name|hash
operator|||
name|paren
operator|||
name|at
operator|||
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"invalid operand of S^#"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
comment|/* Darn! we saw S^#Rnn ! put the Rnn back in 	         expression. KLUDGE! Use oldq so we don't 	         need to know exact length of reg name.  */
name|q
operator|=
name|oldq
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We have all the expression we will ever get.  */
if|if
condition|(
name|p
operator|>
name|q
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"S^# needs expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access_mode
operator|==
literal|'r'
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* WIN! */
name|mode
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|_
argument_list|(
literal|"S^# may only read-access"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Case of -(Rn), which is weird case.           in:  at       0           len      '           hash     0           p:q      q<p           sign     -1                by definition           paren    1              by definition           reg      present           by definition           ndx      optional           out: mode     7           reg      present           len      ' '           exp      ""                enforce empty expression           ndx      optional          warn if same as reg.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|sign
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
operator|||
name|hash
operator|||
name|at
operator|||
name|p
operator|<=
name|q
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"invalid operand of -()"
argument_list|)
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"-(PC) unpredictable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|ndx
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"[]index same as -()register: unpredictable"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We convert "(Rn)" to "@Rn" for our convenience.      (I hope this is convenient: has someone got a better way to parse this?)      A side-effect of this is that "@Rn" is a valid operand.  */
if|if
condition|(
name|paren
operator|&&
operator|!
name|sign
operator|&&
operator|!
name|hash
operator|&&
operator|!
name|at
operator|&&
name|len
operator|==
literal|' '
operator|&&
name|p
operator|>
name|q
condition|)
block|{
name|at
operator|=
literal|1
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Case of (Rn)+, which is slightly different.           in:  at           len      ' '           hash     0           p:q      q<p           sign     +1                by definition           paren    1              by definition           reg      present           by definition           ndx      optional           out: mode     8+@           reg      present           len      ' '           exp      ""                enforce empty expression           ndx      optional          warn if same as reg.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|sign
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
operator|||
name|hash
operator|||
name|p
operator|<=
name|q
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"invalid operand of ()+"
argument_list|)
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|8
operator|+
operator|(
name|at
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"(PC)+ unpredictable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|ndx
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"[]index same as ()+register: unpredictable"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Case of #, without S^.           in:  at           len      ' ' or 'i'           hash     1              by definition           p:q           sign     0           paren    0           reg      absent           ndx      optional           out: mode     8+@           reg      PC           len      ' ' or 'i'           exp           ndx      optional.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
name|hash
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|'i'
operator|&&
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"# conflicts length"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|paren
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"# bars register"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
comment|/* Darn! we saw #Rnn! Put the Rnn back into the expression. 	         By using oldq, we don't need to know how long Rnn was. 	         KLUDGE!  */
name|q
operator|=
name|oldq
expr_stmt|;
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No register any more.  */
block|}
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* Win.  */
comment|/* JF a bugfix, I think!  */
if|if
condition|(
name|at
operator|&&
name|access_mode
operator|==
literal|'a'
condition|)
name|vopP
operator|->
name|vop_nbytes
operator|=
literal|4
expr_stmt|;
name|mode
operator|=
operator|(
name|at
condition|?
literal|9
else|:
literal|8
operator|)
expr_stmt|;
name|reg
operator|=
name|PC
expr_stmt|;
if|if
condition|(
operator|(
name|access_mode
operator|==
literal|'m'
operator|||
name|access_mode
operator|==
literal|'w'
operator|)
operator|&&
operator|!
name|at
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"writing or modifying # is unpredictable"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If !*err, then       sign == 0                           hash == 0 */
comment|/* Case of Rn. We separate this one because it has a few special      errors the remaining modes lack.           in:  at       optional           len      ' '           hash     0             by program logic           p:q      empty           sign     0                 by program logic           paren    0             by definition           reg      present           by definition           ndx      optional           out: mode     5+@           reg      present           len      ' '               enforce no length           exp      ""                enforce empty expression           ndx      optional          warn if same as reg.  */
if|if
condition|(
operator|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
operator|)
operator|&&
operator|!
name|paren
operator|&&
name|reg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"length not needed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|at
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|6
expr_stmt|;
comment|/* @Rn */
block|}
elseif|else
if|if
condition|(
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"can't []index a register, because it has no address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access_mode
operator|==
literal|'a'
condition|)
name|err
operator|=
name|_
argument_list|(
literal|"a register has no address"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Idea here is to detect from length of datum 	     and from register number if we will touch PC. 	     Warn if we do. 	     vop_nbytes is number of bytes in operand. 	     Compute highest byte affected, compare to PC0.  */
if|if
condition|(
operator|(
name|vopP
operator|->
name|vop_nbytes
operator|+
name|reg
operator|*
literal|4
operator|)
operator|>
literal|60
condition|)
name|wrn
operator|=
name|_
argument_list|(
literal|"PC part of operand unpredictable"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|5
expr_stmt|;
comment|/* Rn */
block|}
block|}
comment|/* If !*err,        sign  == 0                       hash  == 0                       paren == 1  OR reg==-1  */
comment|/* Rest of cases fit into one bunch.           in:  at       optional           len      ' ' or 'b' or 'w' or 'l'           hash     0             by program logic           p:q      expected          (empty is not an error)           sign     0                 by program logic           paren    optional           reg      optional           ndx      optional           out: mode     10 + @ + len           reg      optional           len      ' ' or 'b' or 'w' or 'l'           exp                        maybe empty           ndx      optional          warn if same as reg.  */
if|if
condition|(
operator|!
name|err
operator|||
operator|!
operator|*
name|err
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win (always) */
name|mode
operator|=
literal|10
operator|+
operator|(
name|at
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|'l'
case|:
name|mode
operator|+=
literal|2
expr_stmt|;
case|case
literal|'w'
case|:
name|mode
operator|+=
literal|2
expr_stmt|;
case|case
literal|' '
case|:
comment|/* Assumed B^ until our caller changes it.  */
case|case
literal|'b'
case|:
break|break;
block|}
block|}
comment|/* here with completely specified     mode     					len     					reg     					expression   p,q     					ndx.  */
if|if
condition|(
operator|*
name|err
operator|==
literal|' '
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* " " is no longer an error.  */
name|vopP
operator|->
name|vop_mode
operator|=
name|mode
expr_stmt|;
name|vopP
operator|->
name|vop_reg
operator|=
name|reg
expr_stmt|;
name|vopP
operator|->
name|vop_short
operator|=
name|len
expr_stmt|;
name|vopP
operator|->
name|vop_expr_begin
operator|=
name|p
expr_stmt|;
name|vopP
operator|->
name|vop_expr_end
operator|=
name|q
expr_stmt|;
name|vopP
operator|->
name|vop_ndx
operator|=
name|ndx
expr_stmt|;
name|vopP
operator|->
name|vop_error
operator|=
name|err
expr_stmt|;
name|vopP
operator|->
name|vop_warn
operator|=
name|wrn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This converts a string into a vax instruction.    The string must be a bare single instruction in dec-vax (with BSD4 frobs)    format.    It provides some error messages: at most one fatal error message (which    stops the scan) and at most one warning message for each operand.    The vax instruction is returned in exploded form, since we have no    knowledge of how you parse (or evaluate) your expressions.    We do however strip off and decode addressing modes and operation    mnemonic.       The exploded instruction is returned to a struct vit of your choice.    #include "vax-inst.h" to know what a struct vit is.       This function's value is a string. If it is not "" then an internal    logic error was found: read this code to assign meaning to the string.    No argument string should generate such an error string:    it means a bug in our code, not in the user's text.       You MUST have called vip_begin() once before using this function.  */
end_comment

begin_function
specifier|static
name|void
name|vip
parameter_list|(
name|struct
name|vit
modifier|*
name|vitP
parameter_list|,
comment|/* We build an exploded instruction here.  */
name|char
modifier|*
name|instring
parameter_list|)
comment|/* Text of a vax instruction: we modify.  */
block|{
comment|/* How to bit-encode this opcode.  */
name|struct
name|vot_wot
modifier|*
name|vwP
decl_stmt|;
comment|/* 1/skip whitespace.2/scan vot_how */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* counts number of operands seen */
name|unsigned
name|char
name|count
decl_stmt|;
comment|/* scan operands in struct vit */
name|struct
name|vop
modifier|*
name|operandp
decl_stmt|;
comment|/* error over all operands */
specifier|const
name|char
modifier|*
name|alloperr
decl_stmt|;
comment|/* Remember char, (we clobber it with '\0' temporarily).  */
name|char
name|c
decl_stmt|;
comment|/* Op-code of this instruction.  */
name|vax_opcodeT
name|oc
decl_stmt|;
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
operator|++
name|instring
expr_stmt|;
comment|/* MUST end in end-of-string or exactly 1 space.  */
for|for
control|(
name|p
operator|=
name|instring
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* Scanned up to end of operation-code.  */
comment|/* Operation-code is ended with whitespace.  */
if|if
condition|(
name|p
operator|-
name|instring
operator|==
literal|0
condition|)
block|{
name|vitP
operator|->
name|vit_error
operator|=
name|_
argument_list|(
literal|"No operator"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Here with instring pointing to what better be an op-name, and p          pointing to character just past that.          We trust instring points to an op-name, with no whitespace.  */
name|vwP
operator|=
operator|(
expr|struct
name|vot_wot
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|instring
argument_list|)
expr_stmt|;
comment|/* Restore char after op-code.  */
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|vwP
operator|==
literal|0
condition|)
block|{
name|vitP
operator|->
name|vit_error
operator|=
name|_
argument_list|(
literal|"Unknown operator"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We found a match! So let's pick up as many operands as the 	     instruction wants, and even gripe if there are too many. 	     We expect comma to separate each operand. 	     We let instring track the text, while p tracks a part of the 	     struct vot.  */
specifier|const
name|char
modifier|*
name|howp
decl_stmt|;
comment|/* The lines below know about 2-byte opcodes starting FD,FE or FF. 	     They also understand synthetic opcodes. Note: 	     we return 32 bits of opcode, including bucky bits, BUT 	     an opcode length is either 8 or 16 bits for vit_opcode_nbytes.  */
name|oc
operator|=
name|vwP
operator|->
name|vot_code
expr_stmt|;
comment|/* The op-code.  */
name|vitP
operator|->
name|vit_opcode_nbytes
operator|=
operator|(
name|oc
operator|&
literal|0xFF
operator|)
operator|>=
literal|0xFD
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
name|oc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* No operands seen yet.  */
name|instring
operator|=
name|p
expr_stmt|;
comment|/* Point just past operation code.  */
name|alloperr
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|howp
operator|=
name|vwP
operator|->
name|vot_how
operator|,
name|operandp
operator|=
name|vitP
operator|->
name|vit_operand
init|;
operator|!
operator|(
name|alloperr
operator|&&
operator|*
name|alloperr
operator|)
operator|&&
operator|*
name|howp
condition|;
name|operandp
operator|++
operator|,
name|howp
operator|+=
literal|2
control|)
block|{
comment|/* Here to parse one operand. Leave instring pointing just 	         past any one ',' that marks the end of this operand.  */
if|if
condition|(
operator|!
name|howp
index|[
literal|1
index|]
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"odd number of bytes in operand description"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|instring
condition|)
block|{
for|for
control|(
name|q
operator|=
name|instring
init|;
operator|(
name|c
operator|=
operator|*
name|q
operator|)
operator|&&
name|c
operator|!=
literal|','
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Q points to ',' or '\0' that ends argument. C is that 		     character.  */
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|operandp
operator|->
name|vop_width
operator|=
name|howp
index|[
literal|1
index|]
expr_stmt|;
name|operandp
operator|->
name|vop_nbytes
operator|=
name|vax_operand_width_size
index|[
operator|(
name|unsigned
operator|)
name|howp
index|[
literal|1
index|]
index|]
expr_stmt|;
name|operandp
operator|->
name|vop_access
operator|=
name|howp
index|[
literal|0
index|]
expr_stmt|;
name|vip_op
argument_list|(
name|instring
argument_list|,
name|operandp
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
comment|/* Restore input text.  */
if|if
condition|(
name|operandp
operator|->
name|vop_error
condition|)
name|alloperr
operator|=
name|_
argument_list|(
literal|"Bad operand"
argument_list|)
expr_stmt|;
name|instring
operator|=
name|q
operator|+
operator|(
name|c
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Next operand (if any).  */
name|count
operator|++
expr_stmt|;
comment|/*  Won another argument, may have an operr.  */
block|}
else|else
name|alloperr
operator|=
name|_
argument_list|(
literal|"Not enough operands"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|alloperr
condition|)
block|{
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
name|instring
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|instring
condition|)
name|alloperr
operator|=
name|_
argument_list|(
literal|"Too many operands"
argument_list|)
expr_stmt|;
block|}
name|vitP
operator|->
name|vit_error
operator|=
name|alloperr
expr_stmt|;
block|}
block|}
name|vitP
operator|->
name|vit_operands
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|test
end_ifdef

begin_comment
comment|/* Test program for above.  */
end_comment

begin_decl_stmt
name|struct
name|vit
name|myvit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build an exploded vax instruction here.  */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Human types a line of vax assembler here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mybug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "" or an internal logic diagnostic.  */
end_comment

begin_decl_stmt
name|int
name|mycount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands.  */
end_comment

begin_decl_stmt
name|struct
name|vop
modifier|*
name|myvop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan operands from myvit.  */
end_comment

begin_decl_stmt
name|int
name|mysynth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means want synthetic opcodes.  */
end_comment

begin_decl_stmt
name|char
name|my_immediate
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_indirect
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_displen
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"0 means no synthetic instructions.   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Value for vip_begin?  "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|answer
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mysynth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Synthetic opcodes %s be included.\n"
argument_list|,
name|mysynth
condition|?
literal|"will"
else|:
literal|"will not"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter immediate symbols eg enter #   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_immediate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter indirect symbols  eg enter @   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_indirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter displen symbols   eg enter ^   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_displen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|vip_begin
argument_list|(
name|mysynth
argument_list|,
name|my_immediate
argument_list|,
name|my_indirect
argument_list|,
name|my_displen
argument_list|)
condition|)
name|error
argument_list|(
literal|"vip_begin=%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"An empty input line will quit you from the vax instruction parser\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"vax instruction: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|answer
condition|)
break|break;
comment|/* Out of for each input text loop.  */
name|vip
argument_list|(
operator|&
name|myvit
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|myvit
operator|.
name|vit_error
condition|)
name|printf
argument_list|(
literal|"ERR:\"%s\"\n"
argument_list|,
name|myvit
operator|.
name|vit_error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode="
argument_list|)
expr_stmt|;
for|for
control|(
name|mycount
operator|=
name|myvit
operator|.
name|vit_opcode_nbytes
operator|,
name|p
operator|=
name|myvit
operator|.
name|vit_opcode
init|;
name|mycount
condition|;
name|mycount
operator|--
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|*
name|p
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   operand count=%d.\n"
argument_list|,
name|mycount
operator|=
name|myvit
operator|.
name|vit_operands
argument_list|)
expr_stmt|;
for|for
control|(
name|myvop
operator|=
name|myvit
operator|.
name|vit_operand
init|;
name|mycount
condition|;
name|mycount
operator|--
operator|,
name|myvop
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"mode=%xx reg=%xx ndx=%xx len='%c'=%c%c%d. expr=\""
argument_list|,
name|myvop
operator|->
name|vop_mode
argument_list|,
name|myvop
operator|->
name|vop_reg
argument_list|,
name|myvop
operator|->
name|vop_ndx
argument_list|,
name|myvop
operator|->
name|vop_short
argument_list|,
name|myvop
operator|->
name|vop_access
argument_list|,
name|myvop
operator|->
name|vop_width
argument_list|,
name|myvop
operator|->
name|vop_nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|myvop
operator|->
name|vop_expr_begin
init|;
name|p
operator|<=
name|myvop
operator|->
name|vop_expr_end
condition|;
name|p
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|myvop
operator|->
name|vop_error
condition|)
name|printf
argument_list|(
literal|"  err:\"%s\"\n"
argument_list|,
name|myvop
operator|->
name|vop_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|myvop
operator|->
name|vop_warn
condition|)
name|printf
argument_list|(
literal|"  wrn:\"%s\"\n"
argument_list|,
name|myvop
operator|->
name|vop_warn
argument_list|)
expr_stmt|;
block|}
block|}
name|vip_end
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* #Define to use this testbed.  */
end_comment

begin_comment
comment|/* Follows a test program for this function.    We declare arrays non-local in case some of our tiny-minded machines    default to small stacks. Also, helps with some debuggers.  */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Human types into here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mywrn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mybug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myaccess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mywidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mymode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mylen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myright
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myndx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|my_operand_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_immediate
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_indirect
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_displen
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"enter immediate symbols eg enter #   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_immediate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter indirect symbols  eg enter @   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_indirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter displen symbols   eg enter ^   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_displen
argument_list|)
expr_stmt|;
name|vip_op_defaults
argument_list|(
name|my_immediate
argument_list|,
name|my_indirect
argument_list|,
name|my_displen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"access,width (eg 'ab' or 'wh') [empty line to quit] :  "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
index|[
literal|0
index|]
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
name|myaccess
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
name|mywidth
operator|=
name|answer
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|mywidth
condition|)
block|{
case|case
literal|'b'
case|:
name|my_operand_length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|my_operand_length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|my_operand_length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|my_operand_length
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|my_operand_length
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|my_operand_length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|my_operand_length
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|my_operand_length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|my_operand_length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'?'
case|:
case|case
literal|'-'
case|:
name|my_operand_length
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|my_operand_length
operator|=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"I dn't understand access width %c\n"
argument_list|,
name|mywidth
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"VAX assembler instruction operand: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|mybug
operator|=
name|vip_op
argument_list|(
name|answer
argument_list|,
name|myaccess
argument_list|,
name|mywidth
argument_list|,
name|my_operand_length
argument_list|,
operator|&
name|mymode
argument_list|,
operator|&
name|myreg
argument_list|,
operator|&
name|mylen
argument_list|,
operator|&
name|myleft
argument_list|,
operator|&
name|myright
argument_list|,
operator|&
name|myndx
argument_list|,
operator|&
name|myerr
argument_list|,
operator|&
name|mywrn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|myerr
condition|)
block|{
name|printf
argument_list|(
literal|"error: \"%s\"\n"
argument_list|,
name|myerr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mybug
condition|)
name|printf
argument_list|(
literal|" bug: \"%s\"\n"
argument_list|,
name|mybug
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|mywrn
condition|)
name|printf
argument_list|(
literal|"warning: \"%s\"\n"
argument_list|,
name|mywrn
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"mode"
argument_list|,
name|mymode
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"register"
argument_list|,
name|myreg
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"index"
argument_list|,
name|myndx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"width:'%c'  "
argument_list|,
name|mylen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"expression: \""
argument_list|)
expr_stmt|;
while|while
condition|(
name|myleft
operator|<=
name|myright
condition|)
name|putchar
argument_list|(
operator|*
name|myleft
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mumble
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%xx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ABSENT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
parameter_list|,
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|valueT
name|offset
decl_stmt|;
comment|/* This former calculation was off by two:       offset = to_addr - (from_addr + 1);      We need to account for the one byte instruction and also its      two byte operand.  */
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|1
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|VAX_BRW
expr_stmt|;
comment|/* Branch with word (16 bit) offset.  */
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|addressT
name|to_addr
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|symbolS
modifier|*
name|to_symbol
parameter_list|)
block|{
name|valueT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|VAX_JMP
expr_stmt|;
comment|/* Arbitrary jump.  */
operator|*
name|ptr
operator|++
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_VMS
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"d:STt:V+1h:Hv::"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
end_elif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"d:STt:VkKQ:"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"d:STt:V"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_PIC
value|(OPTION_MD_BASE)
block|{
literal|"pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIC
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'S'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"SYMBOL TABLE not implemented"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"TOKEN TRACE not implemented"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Displacement length %s ignored!"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"I don't need or use temp. file \"%s\"."
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"I don't use an interpass file! -V ignored"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_VMS
case|case
literal|'+'
case|:
comment|/* For g++.  Hash any name> 31 chars long.  */
name|flag_hash_long_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* For backward compatibility.  */
name|flag_one
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Show new symbol after hash truncation.  */
name|flag_show_after_trunc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* No hashing of mixed-case names.  */
block|{
specifier|extern
name|char
name|vms_name_mapping
decl_stmt|;
name|vms_name_mapping
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|flag_no_hash_mixed_case
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
block|{
specifier|extern
name|char
modifier|*
name|compiler_version_string
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
operator|||
name|access
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Have caller show the assembler version.  */
name|compiler_version_string
operator|=
name|arg
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_PIC
case|:
case|case
literal|'k'
case|:
name|flag_want_pic
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* -pic, Position Independent Code.  */
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment 	section should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ VAX options:\n\ -d LENGTH		ignored\n\ -J			ignored\n\ -S			ignored\n\ -t FILE			ignored\n\ -T			ignored\n\ -V			ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ VMS options:\n\ -+			hash encode names longer than 31 characters\n\ -1			`const' handling compatible with gcc 1.x\n\ -H			show new symbol after hash truncation\n\ -h NUM			don't hash mixed-case names, and adjust case:\n\ 			0 = upper, 2 = lower, 3 = preserve case\n\ -v\"VERSION\"		code being assembled was produced by compiler \"VERSION\"\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
comment|/* Byte alignment is fine */
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the vax, they're relative to the address of the offset, plus    its size. */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_tcbit
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_8_GOT_PCREL
case|:
case|case
name|BFD_RELOC_16_GOT_PCREL
case|:
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_8_PLT_PCREL
case|:
case|case
name|BFD_RELOC_16_PLT_PCREL
case|:
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
endif|#
directive|endif
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot make %s relocation PC relative"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
define|#
directive|define
name|F
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|)
value|(((SZ)<< 1) + (PCREL))
switch|switch
condition|(
name|F
argument_list|(
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|)
condition|)
block|{
define|#
directive|define
name|MAP
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|,
name|TYPE
parameter_list|)
value|case F(SZ,PCREL): code = (TYPE); break
name|MAP
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|F
undef|#
directive|undef
name|MAP
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reloc
operator|->
name|howto
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* vax:md_assemble() emit frags for 1 instruction given in textual form.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|instruction_string
parameter_list|)
block|{
comment|/* Non-zero if operand expression's segment is not known yet.  */
name|int
name|is_undefined
decl_stmt|;
comment|/* Non-zero if operand expression's segment is absolute.  */
name|int
name|is_absolute
decl_stmt|;
name|int
name|length_code
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* An operand. Scans all operands.  */
name|struct
name|vop
modifier|*
name|operandP
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
comment|/* What used to live after an expression.  */
name|char
name|c_save
decl_stmt|;
comment|/* 1: instruction_string bad for all passes.  */
name|int
name|goofed
decl_stmt|;
comment|/* Points to slot just after last operand.  */
name|struct
name|vop
modifier|*
name|end_operandP
decl_stmt|;
comment|/* Points to expression values for this operand.  */
name|expressionS
modifier|*
name|expP
decl_stmt|;
name|segT
modifier|*
name|segP
decl_stmt|;
comment|/* These refer to an instruction operand expression.  */
comment|/* Target segment of the address.	 */
name|segT
name|to_seg
decl_stmt|;
name|valueT
name|this_add_number
decl_stmt|;
comment|/* Positive (minuend) symbol.  */
name|symbolS
modifier|*
name|this_add_symbol
decl_stmt|;
comment|/* As a number.  */
name|long
name|opcode_as_number
decl_stmt|;
comment|/* Least significant byte 1st.  */
name|char
modifier|*
name|opcode_as_chars
decl_stmt|;
comment|/* As an array of characters.  */
comment|/* Least significant byte 1st */
name|char
modifier|*
name|opcode_low_byteP
decl_stmt|;
comment|/* length (bytes) meant by vop_short.  */
name|int
name|length
decl_stmt|;
comment|/* 0, or 1 if '@' is in addressing mode.  */
name|int
name|at
decl_stmt|;
comment|/* From vop_nbytes: vax_operand_width (in bytes) */
name|int
name|nbytes
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|floatP
decl_stmt|;
name|LITTLENUM_TYPE
name|literal_float
index|[
literal|8
index|]
decl_stmt|;
comment|/* Big enough for any floating point literal.  */
name|vip
argument_list|(
operator|&
name|v
argument_list|,
name|instruction_string
argument_list|)
expr_stmt|;
comment|/* Now we try to find as many as_warn()s as we can. If we do any as_warn()s      then goofed=1. Notice that we don't make any frags yet.      Should goofed be 1, then this instruction will wedge in any pass,      and we can safely flush it, without causing interpass symbol phase      errors. That is, without changing label values in different passes.  */
if|if
condition|(
operator|(
name|goofed
operator|=
operator|(
operator|*
name|v
operator|.
name|vit_error
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Ignoring statement due to \"%s\""
argument_list|)
argument_list|,
name|v
operator|.
name|vit_error
argument_list|)
expr_stmt|;
block|}
comment|/* We need to use expression() and friends, which require us to diddle      input_line_pointer. So we save it and restore it later.  */
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|operandP
operator|=
name|v
operator|.
name|vit_operand
operator|,
name|expP
operator|=
name|exp_of_operand
operator|,
name|segP
operator|=
name|seg_of_operand
operator|,
name|floatP
operator|=
name|float_operand
operator|,
name|end_operandP
operator|=
name|v
operator|.
name|vit_operand
operator|+
name|v
operator|.
name|vit_operands
init|;
name|operandP
operator|<
name|end_operandP
condition|;
name|operandP
operator|++
operator|,
name|expP
operator|++
operator|,
name|segP
operator|++
operator|,
name|floatP
operator|++
control|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_error
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Aborting because statement has \"%s\""
argument_list|)
argument_list|,
name|operandP
operator|->
name|vop_error
argument_list|)
expr_stmt|;
name|goofed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Statement has no syntax goofs: let's sniff the expression.  */
name|int
name|can_be_short
init|=
literal|0
decl_stmt|;
comment|/* 1 if a bignum can be reduced to a short literal.  */
name|input_line_pointer
operator|=
name|operandP
operator|->
name|vop_expr_begin
expr_stmt|;
name|c_save
operator|=
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
expr_stmt|;
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If to_seg == SEG_PASS1, expression() will have set need_pass_2 = 1.  */
operator|*
name|segP
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|expP
operator|->
name|X_op
condition|)
block|{
case|case
name|O_absent
case|:
comment|/* for BSD4.2 compatibility, missing expression is absolute 0 */
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* For SEG_ABSOLUTE, we shouldn't need to set X_op_symbol, 		 X_add_symbol to any particular value.  But, we will program 		 defensively. Since this situation occurs rarely so it costs 		 us little to do, and stops Dean worrying about the origin of 		 random bits in expressionS's.  */
name|expP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
case|case
name|O_constant
case|:
break|break;
default|default:
comment|/* Major bug. We can't handle the case of a 	         SEG_OP expression in a VIT_OPCODE_SYNTHETIC 	         variable-length instruction. 	         We don't have a frag type that is smart enough to 	         relax a SEG_OP, and so we just force all 	         SEG_OPs to behave like SEG_PASS1s. 	         Clearly, if there is a demand we can invent a new or 	         modified frag type and then coding up a frag for this 	         case will be easy. SEG_OP was invented for the 	         .words after a CASE opcode, and was never intended for 	         instruction operands.  */
name|need_pass_2
operator|=
literal|1
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't relocate expression"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_big
case|:
comment|/* Preserve the bits.  */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|bignum_copy
argument_list|(
name|generic_bignum
argument_list|,
name|expP
operator|->
name|X_add_number
argument_list|,
name|floatP
operator|->
name|low
argument_list|,
name|SIZE_OF_LARGE_NUMBER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|expP
operator|->
name|X_add_number
operator|<
literal|0
argument_list|)
expr_stmt|;
name|flonum_copy
argument_list|(
operator|&
name|generic_floating_point_number
argument_list|,
name|floatP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"s i"
argument_list|,
name|operandP
operator|->
name|vop_short
argument_list|)
condition|)
block|{
comment|/* Could possibly become S^# */
name|flonum_gen2vax
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|,
name|floatP
argument_list|,
name|literal_float
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|-
name|expP
operator|->
name|X_add_number
condition|)
block|{
case|case
literal|'f'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFC0F
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFC0F
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFF81
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|can_be_short
operator|=
operator|(
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFFF8
operator|)
operator|==
literal|0x4000
operator|&&
operator|(
name|literal_float
index|[
literal|1
index|]
operator|&
literal|0xE000
operator|)
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|7
index|]
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
operator|||
name|operandP
operator|->
name|vop_short
operator|==
literal|'i'
operator|||
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|&&
name|operandP
operator|->
name|vop_reg
operator|==
literal|0xF
operator|&&
operator|(
name|operandP
operator|->
name|vop_mode
operator|&
literal|0xE
operator|)
operator|==
literal|0x8
operator|)
condition|)
block|{
comment|/* Saw a '#'.  */
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
condition|)
block|{
comment|/* We must chose S^ or I^.  */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
comment|/* Bignum: Short literal impossible.  */
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC.  */
block|}
else|else
block|{
comment|/* Flonum: Try to do it.  */
if|if
condition|(
name|can_be_short
condition|)
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'s'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|0
expr_stmt|;
name|operandP
operator|->
name|vop_ndx
operator|=
operator|-
literal|1
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|expP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
else|else
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC */
block|}
block|}
comment|/* bignum or flonum ? */
block|}
comment|/*  if #, but no S^ or I^ seen.  */
comment|/* No more ' ' case: either 's' or 'i'.  */
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
comment|/* Wants to be a short literal.  */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bignum not permitted in short literal. Immediate mode assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC.  */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|can_be_short
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't do flonum short literal: immediate mode used."
argument_list|)
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC.  */
block|}
else|else
block|{
comment|/* Encode short literal now.  */
name|int
name|temp
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|-
name|expP
operator|->
name|X_add_number
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'d'
case|:
name|temp
operator|=
name|literal_float
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|temp
operator|=
name|literal_float
index|[
literal|0
index|]
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|temp
operator|=
operator|(
operator|(
name|literal_float
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
operator|&
literal|070
operator|)
operator||
operator|(
operator|(
name|literal_float
index|[
literal|1
index|]
operator|>>
literal|13
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
name|floatP
operator|->
name|low
index|[
literal|0
index|]
operator|=
name|temp
operator|&
literal|077
expr_stmt|;
name|floatP
operator|->
name|low
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* I^# seen: set it up if float.  */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|floatP
operator|->
name|low
argument_list|,
name|literal_float
argument_list|,
sizeof|sizeof
argument_list|(
name|literal_float
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if S^# seen.  */
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"A bignum/flonum may not be a displacement: 0x%lx used"
argument_list|)
argument_list|,
operator|(
name|expP
operator|->
name|X_add_number
operator|=
literal|0x80000000L
operator|)
argument_list|)
expr_stmt|;
comment|/* Chosen so luser gets the most offset bits to patch later.  */
block|}
name|expP
operator|->
name|X_add_number
operator|=
name|floatP
operator|->
name|low
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|LITTLENUM_MASK
operator|&
operator|(
name|floatP
operator|->
name|low
index|[
literal|1
index|]
operator|)
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
expr_stmt|;
comment|/* For the O_big case we have: 	         If vop_short == 's' then a short floating literal is in the 	        	lowest 6 bits of floatP -> low [0], which is 	        	big_operand_bits [---] [0]. 	         If vop_short == 'i' then the appropriate number of elements 	        	of big_operand_bits [---] [...] are set up with the correct 	        	bits. 	         Also, just in case width is byte word or long, we copy the lowest 	         32 bits of the number to X_add_number.  */
break|break;
block|}
if|if
condition|(
name|input_line_pointer
operator|!=
name|operandP
operator|->
name|vop_expr_end
operator|+
literal|1
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Junk at end of expression \"%s\""
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|goofed
operator|=
literal|1
expr_stmt|;
block|}
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
operator|=
name|c_save
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|need_pass_2
operator|||
name|goofed
condition|)
return|return;
comment|/* Emit op-code.  */
comment|/* Remember where it is, in case we want to modify the op-code later.  */
name|opcode_low_byteP
operator|=
name|frag_more
argument_list|(
name|v
operator|.
name|vit_opcode_nbytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opcode_low_byteP
argument_list|,
name|v
operator|.
name|vit_opcode
argument_list|,
name|v
operator|.
name|vit_opcode_nbytes
argument_list|)
expr_stmt|;
name|opcode_as_chars
operator|=
name|v
operator|.
name|vit_opcode
expr_stmt|;
name|opcode_as_number
operator|=
name|md_chars_to_number
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|opcode_as_chars
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|operandP
operator|=
name|v
operator|.
name|vit_operand
operator|,
name|expP
operator|=
name|exp_of_operand
operator|,
name|segP
operator|=
name|seg_of_operand
operator|,
name|floatP
operator|=
name|float_operand
operator|,
name|end_operandP
operator|=
name|v
operator|.
name|vit_operand
operator|+
name|v
operator|.
name|vit_operands
init|;
name|operandP
operator|<
name|end_operandP
condition|;
name|operandP
operator|++
operator|,
name|floatP
operator|++
operator|,
name|segP
operator|++
operator|,
name|expP
operator|++
control|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_ndx
operator|>=
literal|0
condition|)
block|{
comment|/* Indexed addressing byte.  */
comment|/* Legality of indexed mode already checked: it is OK.  */
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0x40
operator|+
name|operandP
operator|->
name|vop_ndx
argument_list|)
expr_stmt|;
block|}
comment|/* if(vop_ndx>=0) */
comment|/* Here to make main operand frag(s).  */
name|this_add_number
operator|=
name|expP
operator|->
name|X_add_number
expr_stmt|;
name|this_add_symbol
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
name|to_seg
operator|=
operator|*
name|segP
expr_stmt|;
name|is_undefined
operator|=
operator|(
name|to_seg
operator|==
name|undefined_section
operator|)
expr_stmt|;
name|is_absolute
operator|=
operator|(
name|to_seg
operator|==
name|absolute_section
operator|)
expr_stmt|;
name|at
operator|=
name|operandP
operator|->
name|vop_mode
operator|&
literal|1
expr_stmt|;
name|length
operator|=
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'b'
condition|?
literal|1
else|:
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'w'
condition|?
literal|2
else|:
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'l'
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|nbytes
operator|=
name|operandP
operator|->
name|vop_nbytes
expr_stmt|;
if|if
condition|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|to_seg
operator|==
name|now_seg
operator|||
name|is_undefined
condition|)
block|{
comment|/* If is_undefined, then it might BECOME now_seg.  */
if|if
condition|(
name|nbytes
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* to_seg==now_seg || to_seg == SEG_UNKNOWN */
comment|/* nbytes==0 */
name|length_code
operator|=
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_BYTE
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|length_code
operator|=
name|STATE_WORD
expr_stmt|;
comment|/* JF: There is no state_byte for this one! */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_CONDITIONAL_JUMP
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg&& to_seg != SEG_UNKNOWN */
comment|/* --- SEG FLOAT MAY APPEAR HERE ---  */
if|if
condition|(
name|is_absolute
condition|)
block|{
if|if
condition|(
name|nbytes
condition|)
block|{
name|know
argument_list|(
operator|!
operator|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Conventional relocation.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
operator|*
name|opcode_low_byteP
operator|=
name|opcode_as_chars
index|[
literal|0
index|]
operator|+
name|VAX_WIDEN_LONG
expr_stmt|;
name|know
argument_list|(
name|opcode_as_chars
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#...  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now (eg) JMP @#foo or JSB @#foo.  */
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#...  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now (eg)	ACBx	1f 				    		BRB	2f 				    	1:	JMP	@#foo 				    	2:  */
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#...  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now (eg)	xOBxxx	1f 				   		BRB	2f 				   	1:	JMP	@#foo 				   	2:  */
block|}
block|}
block|}
else|else
block|{
comment|/* b<cond> */
operator|*
name|opcode_low_byteP
operator|^=
literal|1
expr_stmt|;
comment|/* To reverse the condition in a VAX branch, 			     complement the lowest order bit.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#...  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now (eg)	BLEQ	1f 			   		JMP	@#foo 			   	1:  */
block|}
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg&& !is_undefinfed&& !is_absolute */
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
comment|/* Pc-relative. Conventional relocation.  */
name|know
argument_list|(
operator|!
operator|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
name|know
argument_list|(
name|opcode_as_chars
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode_low_byteP
operator|=
name|opcode_as_chars
index|[
literal|0
index|]
operator|+
name|VAX_WIDEN_LONG
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Now eg JMP foo or JSB foo.  */
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|6
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Now (eg)	ACBx	1f 				   		BRB	2f 				   	1:	JMP	foo 				   	2:  */
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|5
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Now (eg)	xOBxxx	1f 				   		BRB	2f 				   	1:	JMP	foo 				   	2:  */
block|}
block|}
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_CONDITIONAL_JUMP
argument_list|)
expr_stmt|;
operator|*
name|opcode_low_byteP
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse branch condition.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|3
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* So it is ordinary operand.  */
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|!=
literal|'b'
argument_list|)
expr_stmt|;
comment|/* ' ' target-independent: elsewhere.  */
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|!=
literal|' '
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'a'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'m'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'r'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'v'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|is_absolute
condition|)
block|{
if|if
condition|(
name|this_add_number
operator|>=
literal|64
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Short literal overflow(%ld.), immediate mode assumed."
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|this_add_number
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Forced short literal to immediate mode. now_seg=%s to_seg=%s"
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|to_seg
argument_list|)
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operandP
operator|->
name|vop_reg
operator|>=
literal|0
operator|&&
operator|(
name|operandP
operator|->
name|vop_mode
operator|<
literal|8
operator|||
operator|(
name|operandP
operator|->
name|vop_reg
operator|!=
literal|0xF
operator|&&
name|operandP
operator|->
name|vop_mode
operator|<
literal|10
operator|)
operator|)
condition|)
block|{
comment|/* One byte operand.  */
name|know
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|>
literal|3
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|<<
literal|4
operator||
name|operandP
operator|->
name|vop_reg
argument_list|)
expr_stmt|;
comment|/* All 1-bytes except S^# happen here.  */
block|}
else|else
block|{
comment|/* {@}{q^}foo{(Rn)} or S^#foo */
if|if
condition|(
name|operandP
operator|->
name|vop_reg
operator|==
operator|-
literal|1
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|'s'
condition|)
block|{
comment|/* "{@}{q^}foo" */
if|if
condition|(
name|to_seg
operator|==
name|now_seg
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|length_code
operator|=
name|STATE_BYTE
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|this_add_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|this_add_symbol
argument_list|)
condition|)
name|length_code
operator|=
name|STATE_UNDF
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|==
literal|10
operator|+
name|at
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|at
operator|<<
literal|4
expr_stmt|;
comment|/* At is the only context we need to carry 			     to other side of relax() process.  Must 			     be in the correct bit position of VAX 			     operand spec. byte.  */
block|}
else|else
block|{
name|know
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0xF
operator||
operator|(
operator|(
name|at
operator|+
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg */
if|if
condition|(
name|this_add_symbol
operator|==
name|NULL
condition|)
block|{
name|know
argument_list|(
name|is_absolute
argument_list|)
expr_stmt|;
comment|/* Do @#foo: simpler relocation than foo-.(pc) anyway.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#...  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|&&
name|length
operator|!=
literal|4
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Length specification ignored. Address mode 9F used"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* {@}{q^}other_seg */
name|know
argument_list|(
operator|(
name|length
operator|==
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|)
operator|||
operator|(
name|length
operator|>
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_undefined
ifdef|#
directive|ifdef
name|OBJ_ELF
operator|||
name|S_IS_WEAK
argument_list|(
name|this_add_symbol
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|this_add_symbol
argument_list|)
endif|#
directive|endif
condition|)
block|{
switch|switch
condition|(
name|length
condition|)
block|{
default|default:
name|length_code
operator|=
name|STATE_UNDF
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|length_code
operator|=
name|STATE_BYTE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|length_code
operator|=
name|STATE_WORD
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|length_code
operator|=
name|STATE_LONG
expr_stmt|;
break|break;
block|}
comment|/* We have a SEG_UNKNOWN symbol. It might 			         turn out to be in the same segment as 			         the instruction, permitting relaxation.  */
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|at
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|length
operator|=
literal|4
expr_stmt|;
comment|/* Longest possible.  */
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0xF
operator||
operator|(
operator|(
name|at
operator|+
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* {@}{q^}foo(Rn) or S^# or I^# or # */
if|if
condition|(
name|operandP
operator|->
name|vop_mode
operator|<
literal|0xA
condition|)
block|{
comment|/* # or S^# or I^# */
if|if
condition|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'v'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'v'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid operand:  immediate value used as base address."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid operand:  immediate value used as address."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* gcc 2.6.3 is known to generate these in at least 			     one case.  */
block|}
if|if
condition|(
name|length
operator|==
literal|0
operator|&&
name|is_absolute
operator|&&
operator|(
name|expP
operator|->
name|X_op
operator|!=
name|O_big
operator|)
operator|&&
name|operandP
operator|->
name|vop_mode
operator|==
literal|8
comment|/* No '@'.  */
operator|&&
name|this_add_number
operator|<
literal|64
condition|)
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'s'
expr_stmt|;
block|}
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|this_add_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I^#...  */
name|know
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_reg
operator|==
literal|0xF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|flag_want_pic
operator|&&
name|operandP
operator|->
name|vop_mode
operator|==
literal|8
operator|&&
name|this_add_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Symbol used as immediate operand in PIC mode."
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|operandP
operator|->
name|vop_mode
operator|<<
literal|4
operator|)
operator||
literal|0xF
expr_stmt|;
if|if
condition|(
operator|(
name|is_absolute
operator|)
operator|&&
operator|(
name|expP
operator|->
name|X_op
operator|!=
name|O_big
operator|)
condition|)
block|{
comment|/* If nbytes> 4, then we are scrod. We 			         don't know if the high order bytes 			         are to be 0xFF or 0x00.  BSD4.2& RMS 			         say use 0x00. OK --- but this 			         assembler needs ANOTHER rewrite to 			         cope properly with this bug.  */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
name|memset
argument_list|(
name|p
operator|+
literal|5
argument_list|,
literal|'\0'
argument_list|,
name|nbytes
operator|-
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|expP
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Problem here is to get the bytes 				     in the right order.  We stored 				     our constant as LITTLENUMs, not 				     bytes.  */
name|LITTLENUM_TYPE
modifier|*
name|lP
decl_stmt|;
name|lP
operator|=
name|floatP
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|nbytes
operator|&
literal|1
condition|)
block|{
name|know
argument_list|(
name|nbytes
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|*
name|lP
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|++
init|;
name|nbytes
condition|;
name|nbytes
operator|-=
literal|2
operator|,
name|p
operator|+=
literal|2
operator|,
name|lP
operator|++
control|)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|*
name|lP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* {@}{q^}foo(Rn) */
name|know
argument_list|(
operator|(
name|length
operator|==
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|)
operator|||
operator|(
name|length
operator|>
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_absolute
condition|)
block|{
name|long
name|test
decl_stmt|;
name|test
operator|=
name|this_add_number
expr_stmt|;
if|if
condition|(
name|test
operator|<
literal|0
condition|)
name|test
operator|=
operator|~
name|test
expr_stmt|;
name|length
operator|=
name|test
operator|&
literal|0xffff8000
condition|?
literal|4
else|:
name|test
operator|&
literal|0xffffff80
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
literal|4
expr_stmt|;
block|}
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_reg
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|operandP
operator|->
name|vop_reg
operator||
operator|(
operator|(
name|at
operator||
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|is_absolute
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errtxt
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|fP
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|errtxt
operator|=
name|vip_begin
argument_list|(
literal|1
argument_list|,
literal|"$"
argument_list|,
literal|"*"
argument_list|,
literal|"`"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"VIP_BEGIN error:%s"
argument_list|)
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fP
operator|=
name|float_operand
init|;
name|fP
operator|<
name|float_operand
operator|+
name|VIT_MAX_OPERANDS
condition|;
name|i
operator|++
operator|,
name|fP
operator|++
control|)
block|{
name|fP
operator|->
name|low
operator|=
operator|&
name|big_operand_bits
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fP
operator|->
name|high
operator|=
operator|&
name|big_operand_bits
index|[
name|i
index|]
index|[
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vax_cons_special_reloc
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vax_cons
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|vax_cons_special_reloc
operator|=
name|NULL
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|,
literal|"pcrel"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|vax_cons_special_reloc
operator|=
literal|"pcrel"
expr_stmt|;
block|}
if|if
condition|(
name|vax_cons_special_reloc
condition|)
block|{
name|int
name|bad
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'8'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'1'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'6'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'3'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'2'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: Only %%r_%s%d allowed in %d-byte data fields"
argument_list|)
argument_list|,
name|vax_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|vax_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|input_line_pointer
operator|=
name|save
expr_stmt|;
name|vax_cons_special_reloc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|end
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|int
name|npar
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|c
operator|=
operator|*
name|end
operator|)
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|npar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|npar
condition|)
break|break;
name|npar
operator|--
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|vax_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|!=
name|end
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|vax_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: garbage after %%r_%s%d()"
argument_list|)
argument_list|,
name|vax_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|vax_cons_special_reloc
operator|==
name|NULL
condition|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a    reloc for a cons.  */
end_comment

begin_function
name|void
name|vax_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|unsigned
name|int
name|nbytes
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|nbytes
operator|==
literal|1
condition|?
name|BFD_RELOC_8
else|:
operator|(
name|nbytes
operator|==
literal|2
condition|?
name|BFD_RELOC_16
else|:
name|BFD_RELOC_32
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vax_cons_special_reloc
condition|)
block|{
if|if
condition|(
operator|*
name|vax_cons_special_reloc
operator|==
literal|'p'
condition|)
block|{
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|r
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|vax_cons_special_reloc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

