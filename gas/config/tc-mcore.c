begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mcore.c -- Assemble code for M*Core    Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"../opcodes/mcore-opc.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/mcore.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|streq
end_ifndef

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp (a, b) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations for dumb compilers.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mcore_s_literals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_pool_count
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_float_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_stringer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_fill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log2
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_creg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_exp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_rt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_imm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_mem
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|,
name|unsigned
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_psrmod
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enter_literal
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_literals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_literals
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_s_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_s_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_s_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcore_s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|mcore_s_comm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Several places in this file insert raw instructions into the    object. They should use MCORE_INST_XXX macros to get the opcodes    and then use these two macros to crack the MCORE_INST value into    the appropriate byte values.  */
end_comment

begin_define
define|#
directive|define
name|INST_BYTE0
parameter_list|(
name|x
parameter_list|)
value|(target_big_endian ? (((x)>> 8)& 0xFF) : ((x)& 0xFF))
end_define

begin_define
define|#
directive|define
name|INST_BYTE1
parameter_list|(
name|x
parameter_list|)
value|(target_big_endian ? ((x)& 0xFF) : (((x)>> 8)& 0xFF))
end_define

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_jsri2bsr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Change here from 1 by Cruess 19 August 97.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sifilter_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant     As in 0f12.456     or    0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_define
define|#
directive|define
name|GET_WHAT
parameter_list|(
name|x
parameter_list|)
value|((x>> 2))
end_define

begin_comment
comment|/* These are the two types of relaxable instruction */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_define
define|#
directive|define
name|UNCD_JUMP
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF_DISP
value|0
end_define

begin_define
define|#
directive|define
name|DISP12
value|1
end_define

begin_define
define|#
directive|define
name|DISP32
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF_WORD_DISP
value|3
end_define

begin_define
define|#
directive|define
name|C12_LEN
value|2
end_define

begin_define
define|#
directive|define
name|C32_LEN
value|10
end_define

begin_comment
comment|/* allow for align */
end_comment

begin_define
define|#
directive|define
name|U12_LEN
value|2
end_define

begin_define
define|#
directive|define
name|U32_LEN
value|8
end_define

begin_comment
comment|/* allow for align */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|M210
block|,
name|M340
block|}
name|cpu_type
typedef|;
end_typedef

begin_decl_stmt
name|cpu_type
name|cpu
init|=
name|M340
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the relax table.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* COND_JUMP */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNDEF_DISP */
block|{
literal|2048
block|,
operator|-
literal|2046
block|,
name|C12_LEN
block|,
name|C
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DISP32
argument_list|)
block|}
block|,
comment|/* DISP12 */
block|{
literal|0
block|,
literal|0
block|,
name|C32_LEN
block|,
literal|0
block|}
block|,
comment|/* DISP32 */
block|{
literal|0
block|,
literal|0
block|,
name|C32_LEN
block|,
literal|0
block|}
block|,
comment|/* UNDEF_WORD_DISP */
comment|/* UNCD_JUMP */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNDEF_DISP */
block|{
literal|2048
block|,
operator|-
literal|2046
block|,
name|U12_LEN
block|,
name|C
argument_list|(
argument|UNCD_JUMP
argument_list|,
argument|DISP32
argument_list|)
block|}
block|,
comment|/* DISP12 */
block|{
literal|0
block|,
literal|0
block|,
name|U32_LEN
block|,
literal|0
block|}
block|,
comment|/* DISP32 */
block|{
literal|0
block|,
literal|0
block|,
name|U32_LEN
block|,
literal|0
block|}
comment|/* UNDEF_WORD_DISP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Literal pool data structures.  */
end_comment

begin_struct
struct|struct
name|literal
block|{
name|unsigned
name|short
name|refcnt
decl_stmt|;
name|unsigned
name|char
name|ispcrel
decl_stmt|;
name|unsigned
name|char
name|unused
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_POOL_SIZE
value|(1024/4)
end_define

begin_decl_stmt
specifier|static
name|struct
name|literal
name|litpool
index|[
name|MAX_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|poolsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|poolnumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|poolspan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPANPANIC: the point at which we get too scared and force a dump    of the literal pool, and perhaps put a branch in place.    Calculated as:   		 1024	span of lrw/jmpi/jsri insn (actually span+1)   		-2	possible alignment at the insn.   		-2	possible alignment to get the table aligned.   		-2	an inserted branch around the table.   	     == 1018    at 1018, we might be in trouble.    -- so we have to be smaller than 1018 and since we deal with 2-byte    instructions, the next good choice is 1016.    -- Note we have a test case that fails when we've got 1018 here.  */
end_comment

begin_define
define|#
directive|define
name|SPANPANIC
value|(1016)
end_define

begin_comment
comment|/* 1024 - 1 entry - 2 byte rounding.  */
end_comment

begin_define
define|#
directive|define
name|SPANCLOSE
value|(900)
end_define

begin_define
define|#
directive|define
name|SPANEXIT
value|(600)
end_define

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|poolsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* label for current pool.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|poolname
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics.  */
end_comment

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:      Pseudo-op name without dot      Function to call to execute this pseudo-op      Integer arg to pass to the function.   */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"export"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"literals"
block|,
name|mcore_s_literals
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
comment|/* The following are to intercept the placement of data into the text      section (eg addresses for a switch table), so that the space they      occupy can be taken into account when deciding whether or not to      dump the current literal pool.      XXX - currently we do not cope with the .space and .dcb.d directives.  */
block|{
literal|"ascii"
block|,
name|mcore_stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|mcore_stringer
block|,
literal|1
block|}
block|,
block|{
literal|"byte"
block|,
name|mcore_cons
block|,
literal|1
block|}
block|,
block|{
literal|"dc"
block|,
name|mcore_cons
block|,
literal|2
block|}
block|,
block|{
literal|"dc.b"
block|,
name|mcore_cons
block|,
literal|1
block|}
block|,
block|{
literal|"dc.d"
block|,
name|mcore_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"dc.l"
block|,
name|mcore_cons
block|,
literal|4
block|}
block|,
block|{
literal|"dc.s"
block|,
name|mcore_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dc.w"
block|,
name|mcore_cons
block|,
literal|2
block|}
block|,
block|{
literal|"dc.x"
block|,
name|mcore_float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"double"
block|,
name|mcore_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"float"
block|,
name|mcore_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"hword"
block|,
name|mcore_cons
block|,
literal|2
block|}
block|,
block|{
literal|"int"
block|,
name|mcore_cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|mcore_cons
block|,
literal|4
block|}
block|,
block|{
literal|"octa"
block|,
name|mcore_cons
block|,
literal|16
block|}
block|,
block|{
literal|"quad"
block|,
name|mcore_cons
block|,
literal|8
block|}
block|,
block|{
literal|"short"
block|,
name|mcore_cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|mcore_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"string"
block|,
name|mcore_stringer
block|,
literal|1
block|}
block|,
block|{
literal|"word"
block|,
name|mcore_cons
block|,
literal|2
block|}
block|,
block|{
literal|"fill"
block|,
name|mcore_fill
block|,
literal|0
block|}
block|,
comment|/* Allow for the effect of section changes.  */
block|{
literal|"text"
block|,
name|mcore_s_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|mcore_s_data
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|mcore_s_bss
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"comm"
block|,
name|mcore_s_comm
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"section"
block|,
name|mcore_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|mcore_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|mcore_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|mcore_s_section
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mcore_s_literals
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform FUNC (ARG), and track number of bytes added to frag.  */
end_comment

begin_function_decl
specifier|static
name|void
name|mcore_pool_count
parameter_list|(
name|func
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|fragS
modifier|*
name|curr_frag
init|=
name|frag_now
decl_stmt|;
name|offsetT
name|added
init|=
operator|-
name|frag_now_fix_octets
argument_list|()
decl_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_frag
operator|!=
name|frag_now
condition|)
block|{
name|added
operator|+=
name|curr_frag
operator|->
name|fr_fix
expr_stmt|;
name|curr_frag
operator|=
name|curr_frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|added
operator|+=
name|frag_now_fix_octets
argument_list|()
expr_stmt|;
name|poolspan
operator|+=
name|added
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|mcore_cons
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|mcore_pool_count
argument_list|(
name|cons
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|cons
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|/* In theory we ought to call check_literals (2,0) here in case      we need to dump the literal table.  We cannot do this however,      as the directives that we are intercepting may be being used      to build a switch table, and we must not interfere with its      contents.  Instead we cross our fingers and pray...  */
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_float_cons
parameter_list|(
name|float_type
parameter_list|)
name|int
name|float_type
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|mcore_pool_count
argument_list|(
name|float_cons
argument_list|,
name|float_type
argument_list|)
expr_stmt|;
else|else
name|float_cons
argument_list|(
name|float_type
argument_list|)
expr_stmt|;
comment|/* See the comment in mcore_cons () about calling check_literals.      It is unlikely that a switch table will be constructed using      floating point values, but it is still likely that an indexed      table of floating point constants is being created by these      directives, so again we must not interfere with their placement.  */
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_stringer
parameter_list|(
name|append_zero
parameter_list|)
name|int
name|append_zero
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|mcore_pool_count
argument_list|(
name|stringer
argument_list|,
name|append_zero
argument_list|)
expr_stmt|;
else|else
name|stringer
argument_list|(
name|append_zero
argument_list|)
expr_stmt|;
comment|/* We call check_literals here in case a large number of strings are      being placed into the text section with a sequence of stringer      directives.  In theory we could be upsetting something if these      strings are actually in an indexed table instead of referenced by      individual labels.  Let us hope that that never happens.  */
name|check_literals
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_fill
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|text_section
condition|)
name|mcore_pool_count
argument_list|(
name|s_fill
argument_list|,
name|unused
argument_list|)
expr_stmt|;
else|else
name|s_fill
argument_list|(
name|unused
argument_list|)
expr_stmt|;
name|check_literals
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the section changing pseudo-ops.  These call through to the    normal implementations, but they dump the literal pool first.  */
end_comment

begin_function
specifier|static
name|void
name|mcore_s_text
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_s_data
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_s_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
comment|/* Scan forwards to find the name of the section.  If the section      being switched to is ".line" then this is a DWARF1 debug section      which is arbitrarily placed inside generated code.  In this case      do not dump the literal pool because it is a) inefficient and      b) would require the generation of extra code to jump around the      pool.  */
name|char
modifier|*
name|ilp
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|*
name|ilp
operator|!=
literal|0
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|ilp
argument_list|)
condition|)
operator|++
name|ilp
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ilp
argument_list|,
literal|".line"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ISSPACE
argument_list|(
name|ilp
index|[
literal|5
index|]
argument_list|)
operator|||
operator|*
name|ilp
operator|==
literal|'\n'
operator|||
operator|*
name|ilp
operator|==
literal|'\r'
operator|)
condition|)
empty_stmt|;
else|else
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_COFF
name|obj_coff_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mcore_s_bss
parameter_list|(
name|needs_align
parameter_list|)
name|int
name|needs_align
decl_stmt|;
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|s_lcomm_bytes
argument_list|(
name|needs_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|void
name|mcore_s_comm
parameter_list|(
name|needs_align
parameter_list|)
name|int
name|needs_align
decl_stmt|;
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|obj_elf_common
argument_list|(
name|needs_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|mcore_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table */
for|for
control|(
name|opcode
operator|=
name|mcore_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|streq
argument_list|(
name|prev_name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
name|opcode
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a log2(val).  */
end_comment

begin_function
specifier|static
name|int
name|log2
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|log
operator|++
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Try to parse a reg name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_reg
parameter_list|(
name|s
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
modifier|*
name|reg
decl_stmt|;
block|{
comment|/* Strip leading whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|TOLOWER
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|s
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
operator|*
name|reg
operator|=
literal|10
operator|+
name|s
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|3
return|;
block|}
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|reg
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|2
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'p'
operator|&&
operator|!
name|ISALNUM
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|reg
operator|=
literal|0
expr_stmt|;
return|return
name|s
operator|+
literal|2
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register expected, but saw '%.6s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|Cregs
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|crnum
decl_stmt|;
block|}
name|cregs
index|[]
init|=
block|{
block|{
literal|"psr"
block|,
literal|0
block|}
block|,
block|{
literal|"vbr"
block|,
literal|1
block|}
block|,
block|{
literal|"epsr"
block|,
literal|2
block|}
block|,
block|{
literal|"fpsr"
block|,
literal|3
block|}
block|,
block|{
literal|"epc"
block|,
literal|4
block|}
block|,
block|{
literal|"fpc"
block|,
literal|5
block|}
block|,
block|{
literal|"ss0"
block|,
literal|6
block|}
block|,
block|{
literal|"ss1"
block|,
literal|7
block|}
block|,
block|{
literal|"ss2"
block|,
literal|8
block|}
block|,
block|{
literal|"ss3"
block|,
literal|9
block|}
block|,
block|{
literal|"ss4"
block|,
literal|10
block|}
block|,
block|{
literal|"gcr"
block|,
literal|11
block|}
block|,
block|{
literal|"gsr"
block|,
literal|12
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|parse_creg
parameter_list|(
name|s
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
modifier|*
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Strip leading whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|TOLOWER
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
name|TOLOWER
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
operator|)
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'3'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'1'
condition|)
block|{
operator|*
name|reg
operator|=
literal|30
operator|+
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|4
return|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'2'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|reg
operator|=
literal|20
operator|+
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|4
return|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'1'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|reg
operator|=
literal|10
operator|+
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|4
return|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|reg
operator|=
name|s
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|s
operator|+
literal|3
return|;
block|}
block|}
comment|/* Look at alternate creg names before giving error.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cregs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|j
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|cregs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
name|buf
index|[
name|j
index|]
operator|=
name|TOLOWER
argument_list|(
name|s
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cregs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|reg
operator|=
name|cregs
index|[
name|i
index|]
operator|.
name|crnum
expr_stmt|;
return|return
name|s
operator|+
name|length
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"control register expected, but saw '%.6s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_psrmod
parameter_list|(
name|s
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
modifier|*
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
specifier|static
struct|struct
name|psrmods
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|}
name|psrmods
index|[]
init|=
block|{
block|{
literal|"ie"
block|,
literal|1
block|}
block|,
block|{
literal|"fe"
block|,
literal|2
block|}
block|,
block|{
literal|"ee"
block|,
literal|4
block|}
block|,
block|{
literal|"af"
block|,
literal|8
block|}
comment|/* Really 0 and non-combinable.  */
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|psrmods
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|psrmods
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|psrmods
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|reg
operator|=
name|psrmods
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
name|s
operator|+
literal|2
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad/missing psr specifier"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reg
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_name
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|s
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
name|hex
index|[
operator|(
name|n
operator|>>
literal|12
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|s
index|[
literal|4
index|]
operator|=
name|hex
index|[
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|s
index|[
literal|5
index|]
operator|=
name|hex
index|[
operator|(
name|n
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|s
index|[
literal|6
index|]
operator|=
name|hex
index|[
operator|(
name|n
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|s
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|POOL_END_LABEL
value|".LE"
end_define

begin_define
define|#
directive|define
name|POOL_START_LABEL
value|".LS"
end_define

begin_function
specifier|static
name|void
name|dump_literals
parameter_list|(
name|isforce
parameter_list|)
name|int
name|isforce
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|literal
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|brarsym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|poolsize
operator|==
literal|0
condition|)
return|return;
comment|/* Must we branch around the literal table? */
if|if
condition|(
name|isforce
condition|)
block|{
name|char
modifier|*
name|output
decl_stmt|;
name|char
name|brarname
index|[
literal|8
index|]
decl_stmt|;
name|make_name
argument_list|(
name|brarname
argument_list|,
name|POOL_END_LABEL
argument_list|,
name|poolnumber
argument_list|)
expr_stmt|;
name|brarsym
operator|=
name|symbol_make
argument_list|(
name|brarname
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|brarsym
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|brarsym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|MCORE_INST_BR
argument_list|)
expr_stmt|;
comment|/* br .+xxx */
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|MCORE_INST_BR
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that the section is sufficiently aligned and that      the literal table is aligned within it.  */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|S_GET_NAME
argument_list|(
name|poolsym
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|litpool
init|;
name|i
operator|<
name|poolsize
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|emit_expr
argument_list|(
operator|&
name|p
operator|->
name|e
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|brarsym
operator|!=
name|NULL
condition|)
name|colon
argument_list|(
name|S_GET_NAME
argument_list|(
name|brarsym
argument_list|)
argument_list|)
expr_stmt|;
name|poolsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_literals
parameter_list|(
name|kind
parameter_list|,
name|offset
parameter_list|)
name|int
name|kind
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|poolspan
operator|+=
name|offset
expr_stmt|;
comment|/* SPANCLOSE and SPANEXIT are smaller numbers than SPANPANIC.      SPANPANIC means that we must dump now.      kind == 0 is any old instruction.      kind> 0 means we just had a control transfer instruction.      kind == 1 means within a function      kind == 2 means we just left a function       The dump_literals (1) call inserts a branch around the table, so      we first look to see if its a situation where we won't have to      insert a branch (e.g., the previous instruction was an unconditional      branch).       SPANPANIC is the point where we must dump a single-entry pool.      it accounts for alignments and an inserted branch.      the 'poolsize*2' accounts for the scenario where we do:        lrw r1,lit1; lrw r2,lit2; lrw r3,lit3      Note that the 'lit2' reference is 2 bytes further along      but the literal it references will be 4 bytes further along,      so we must consider the poolsize into this equation.      This is slightly over-cautious, but guarantees that we won't      panic because a relocation is too distant.  */
if|if
condition|(
name|poolspan
operator|>
name|SPANCLOSE
operator|&&
name|kind
operator|>
literal|0
condition|)
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|poolspan
operator|>
name|SPANEXIT
operator|&&
name|kind
operator|>
literal|1
condition|)
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|poolspan
operator|>=
operator|(
name|SPANPANIC
operator|-
name|poolsize
operator|*
literal|2
operator|)
condition|)
name|dump_literals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|enter_literal
parameter_list|(
name|e
parameter_list|,
name|ispcrel
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
name|int
name|ispcrel
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|literal
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|poolsize
operator|>=
name|MAX_POOL_SIZE
operator|-
literal|2
condition|)
block|{
comment|/* The literal pool is as full as we can handle. We have 	 to be 2 entries shy of the 1024/4=256 entries because we 	 have to allow for the branch (2 bytes) and the alignment 	 (2 bytes before the first insn referencing the pool and 	 2 bytes before the pool itself) == 6 bytes, rounds up 	 to 2 entries.  */
name|dump_literals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|poolsize
operator|==
literal|0
condition|)
block|{
comment|/* Create new literal pool.  */
if|if
condition|(
operator|++
name|poolnumber
operator|>
literal|0xFFFF
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"more than 65K literal pools"
argument_list|)
argument_list|)
expr_stmt|;
name|make_name
argument_list|(
name|poolname
argument_list|,
name|POOL_START_LABEL
argument_list|,
name|poolnumber
argument_list|)
expr_stmt|;
name|poolsym
operator|=
name|symbol_make
argument_list|(
name|poolname
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|poolsym
argument_list|)
expr_stmt|;
name|poolspan
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search pool for value so we don't have duplicates.  */
for|for
control|(
name|p
operator|=
name|litpool
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poolsize
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|e
operator|->
name|X_op
operator|==
name|p
operator|->
name|e
operator|.
name|X_op
operator|&&
name|e
operator|->
name|X_add_symbol
operator|==
name|p
operator|->
name|e
operator|.
name|X_add_symbol
operator|&&
name|e
operator|->
name|X_add_number
operator|==
name|p
operator|->
name|e
operator|.
name|X_add_number
operator|&&
name|ispcrel
operator|==
name|p
operator|->
name|ispcrel
condition|)
block|{
name|p
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
name|p
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|ispcrel
operator|=
name|ispcrel
expr_stmt|;
name|p
operator|->
name|e
operator|=
operator|*
name|e
expr_stmt|;
name|poolsize
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Parse a literal specification. -- either new or old syntax.    old syntax: the user supplies the label and places the literal.    new syntax: we put it into the literal pool.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_rt
parameter_list|(
name|s
parameter_list|,
name|outputp
parameter_list|,
name|ispcrel
parameter_list|,
name|ep
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|outputp
decl_stmt|;
name|int
name|ispcrel
decl_stmt|;
name|expressionS
modifier|*
name|ep
decl_stmt|;
block|{
name|expressionS
name|e
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|ep
condition|)
comment|/* Indicate nothing there.  */
name|ep
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
name|s
operator|=
name|parse_exp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|']'
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing ']'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|parse_exp
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|n
operator|=
name|enter_literal
argument_list|(
operator|&
name|e
argument_list|,
name|ispcrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|e
expr_stmt|;
comment|/* Create a reference to pool entry.  */
name|e
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|e
operator|.
name|X_add_symbol
operator|=
name|poolsym
expr_stmt|;
name|e
operator|.
name|X_add_number
operator|=
name|n
operator|<<
literal|2
expr_stmt|;
block|}
operator|*
name|outputp
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|*
name|outputp
operator|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|e
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MCORE_PCREL_IMM8BY4
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_imm
parameter_list|(
name|s
parameter_list|,
name|val
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
modifier|*
name|val
decl_stmt|;
name|unsigned
name|min
decl_stmt|;
name|unsigned
name|max
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|new
operator|=
name|parse_exp
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_absent
condition|)
empty_stmt|;
comment|/* An error message has already been emitted.  */
elseif|else
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand must be a constant"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|addressT
operator|)
name|e
operator|.
name|X_add_number
operator|<
name|min
operator|||
operator|(
name|addressT
operator|)
name|e
operator|.
name|X_add_number
operator|>
name|max
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand must be absolute in range %u..%u, not %ld"
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
operator|(
name|long
operator|)
name|e
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|e
operator|.
name|X_add_number
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_mem
parameter_list|(
name|s
parameter_list|,
name|reg
parameter_list|,
name|off
parameter_list|,
name|siz
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
modifier|*
name|reg
decl_stmt|;
name|unsigned
modifier|*
name|off
decl_stmt|;
name|unsigned
name|siz
decl_stmt|;
block|{
operator|*
name|off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|s
operator|=
name|parse_reg
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|s
operator|=
name|parse_imm
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|off
argument_list|,
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|siz
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|off
operator|&
literal|0x3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand must be a multiple of 4"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|off
operator|>>=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|off
operator|&
literal|0x1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand must be a multiple of 2"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|off
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"base register expected"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|mcore_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|inst
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|unsigned
name|off
decl_stmt|;
name|unsigned
name|isize
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|str
init|;
name|nlen
operator|<
literal|20
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
name|name
index|[
name|nlen
index|]
operator|=
name|op_start
index|[
name|nlen
index|]
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
operator|(
name|mcore_opcode_info
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|=
name|opcode
operator|->
name|inst
expr_stmt|;
name|isize
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|opclass
condition|)
block|{
case|case
name|O0
case|:
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OT
case|:
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|O1
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|JMP
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* In a sifilter mode, we emit this insn 2 times, 	 fixes problem of an interrupt during a jmp..  */
if|if
condition|(
name|sifilter_mode
condition|)
block|{
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|JSR
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register: r15 illegal"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifilter_mode
condition|)
block|{
comment|/* Replace with:  bsr .+2 ; addi r15,6; jmp rx ; jmp rx */
name|inst
operator|=
name|MCORE_INST_BSR
expr_stmt|;
comment|/* with 0 displacement */
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|inst
operator|=
name|MCORE_INST_ADDI
expr_stmt|;
name|inst
operator||=
literal|15
expr_stmt|;
comment|/* addi r15,6 */
name|inst
operator||=
operator|(
literal|6
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* over the jmp's */
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|inst
operator|=
name|MCORE_INST_JMP
operator||
name|reg
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 2nd emitted in fallthru */
block|}
break|break;
case|case
name|OC
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_creg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULSH
case|:
if|if
condition|(
name|cpu
operator|==
name|M210
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"M340 specific opcode used when assembling for M210"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* drop through...  */
case|case
name|O2
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|X1
case|:
comment|/* Handle both syntax-> xtrb- r1,rx OR xtrb- rx */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
comment|/* xtrb- r1,rx */
block|{
if|if
condition|(
name|reg
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"destination register must be r1"
argument_list|)
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
block|}
name|inst
operator||=
name|reg
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|O1R1
case|:
comment|/* div- rx,r1 */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"source register must be r1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OI
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|inst
operator||=
operator|(
name|reg
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OB
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OB2
case|:
comment|/* like OB, but arg is 2^n instead of n */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* Further restrict the immediate to a power of two.  */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|reg
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|reg
operator|=
name|log2
argument_list|(
name|reg
argument_list|)
expr_stmt|;
else|else
block|{
name|reg
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate is not a power of two"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator||=
operator|(
name|reg
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBRa
case|:
comment|/* Specific for bgeni: imm of 0->6 translate to movi.  */
case|case
name|OBRb
case|:
case|case
name|OBRc
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|)
expr_stmt|;
comment|/* immediate values of 0 -> 6 translate to movi */
if|if
condition|(
name|reg
operator|<=
literal|6
condition|)
block|{
name|inst
operator|=
operator|(
name|inst
operator|&
literal|0xF
operator|)
operator||
name|MCORE_INST_BGENI_ALT
expr_stmt|;
name|reg
operator|=
literal|0x1
operator|<<
name|reg
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating bgeni to movi"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator|&=
operator|~
literal|0x01f0
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBR2
case|:
comment|/* like OBR, but arg is 2^n instead of n */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* Further restrict the immediate to a power of two.  */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|reg
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|reg
operator|=
name|log2
argument_list|(
name|reg
argument_list|)
expr_stmt|;
else|else
block|{
name|reg
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate is not a power of two"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Immediate values of 0 -> 6 translate to movi.  */
if|if
condition|(
name|reg
operator|<=
literal|6
condition|)
block|{
name|inst
operator|=
operator|(
name|inst
operator|&
literal|0xF
operator|)
operator||
name|MCORE_INST_BGENI_ALT
expr_stmt|;
name|reg
operator|=
literal|0x1
operator|<<
name|reg
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating mgeni to movi"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMa
case|:
comment|/* Specific for bmaski: imm 1->7 translate to movi.  */
case|case
name|OMb
case|:
case|case
name|OMc
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Immediate values of 1 -> 7 translate to movi.  */
if|if
condition|(
name|reg
operator|<=
literal|7
condition|)
block|{
name|inst
operator|=
operator|(
name|inst
operator|&
literal|0xF
operator|)
operator||
name|MCORE_INST_BMASKI_ALT
expr_stmt|;
name|reg
operator|=
operator|(
literal|0x1
operator|<<
name|reg
operator|)
operator|-
literal|1
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"translating bmaski to movi"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|&=
operator|~
literal|0x01F0
expr_stmt|;
name|inst
operator||=
operator|(
name|reg
operator|&
literal|0x1F
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|I7
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|0
argument_list|,
literal|0x7F
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|LS
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|8
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0x6000
operator|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0x6000
operator|)
operator|==
literal|0x4000
condition|)
name|size
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0x6000
operator|)
operator|==
literal|0x2000
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|parse_mem
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
operator|&
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
literal|16
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"displacement too large (%d)"
argument_list|)
argument_list|,
name|off
argument_list|)
expr_stmt|;
else|else
name|inst
operator||=
operator|(
name|reg
operator|)
operator||
operator|(
name|off
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|LR
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|reg
operator|==
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register: r0 and r15 illegal"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator||=
operator|(
name|reg
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
comment|/* parse_rt calls frag_more() for us.  */
name|input_line_pointer
operator|=
name|parse_rt
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|output
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* save its space */
block|}
break|break;
case|case
name|LJ
case|:
name|input_line_pointer
operator|=
name|parse_rt
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|output
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* parse_rt() calls frag_more() for us.  */
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
break|break;
case|case
name|RM
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|reg
operator|==
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad starting register: r0 and r15 invalid"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'-'
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|15
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ending register must be r15"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|++
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'('
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad base register: must be r0"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|')'
condition|)
name|op_end
operator|++
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"base register expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQ
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|4
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"first register must be r4"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'-'
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|7
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"last register must be r7"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|++
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'('
condition|)
block|{
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|4
operator|&&
name|reg
operator|<=
literal|7
condition|)
name|as_fatal
argument_list|(
literal|"base register cannot be r4, r5, r6, or r7"
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|')'
condition|)
name|op_end
operator|++
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"base register expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"reg-reg expected"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BR
case|:
name|input_line_pointer
operator|=
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|e
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MCORE_PCREL_IMM11BY2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BL
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|e
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MCORE_PCREL_IMM4BY2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|JC
case|:
name|input_line_pointer
operator|=
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
name|output
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP12
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|COND_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|e
operator|.
name|X_add_symbol
argument_list|,
name|e
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isize
operator|=
name|C32_LEN
expr_stmt|;
break|break;
case|case
name|JU
case|:
name|input_line_pointer
operator|=
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
name|output
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|e
operator|.
name|X_add_symbol
argument_list|,
name|e
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isize
operator|=
name|U32_LEN
expr_stmt|;
break|break;
case|case
name|JL
case|:
name|inst
operator|=
name|MCORE_INST_JSRI
expr_stmt|;
comment|/* jsri */
name|input_line_pointer
operator|=
name|parse_rt
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|output
argument_list|,
literal|1
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|/* parse_rt() calls frag_more for us.  */
name|op_end
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Only do this if we know how to do it ...  */
if|if
condition|(
name|e
operator|.
name|X_op
operator|!=
name|O_absent
operator|&&
name|do_jsri2bsr
condition|)
block|{
comment|/* Look at adding the R_PCREL_JSRIMM11BY2.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|e
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RSI
case|:
comment|/* SI, but imm becomes 32-imm */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|32
operator|-
name|reg
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO21
case|:
comment|/* O2, dup rd, lit must be 1 */
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand must be 1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIa
case|:
name|op_end
operator|=
name|parse_reg
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
operator|++
name|op_end
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|op_end
operator|=
name|parse_imm
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"zero used as immediate value"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator||=
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand missing"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSR
case|:
if|if
condition|(
name|cpu
operator|==
name|M210
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"M340 specific opcode used when assembling for M210"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|op_end
operator|=
name|parse_psrmod
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
comment|/* Look for further selectors.  */
while|while
condition|(
operator|*
name|op_end
operator|==
literal|','
condition|)
block|{
name|unsigned
name|value
decl_stmt|;
name|op_end
operator|=
name|parse_psrmod
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
name|reg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"duplicated psr bit specifier"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|>
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`af' must appear alone"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator||=
operator|(
name|reg
operator|&
literal|0x7
operator|)
expr_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unimplemented opcode \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Drop whitespace after all the operands have been parsed.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
name|op_end
operator|++
expr_stmt|;
comment|/* Give warning message if the insn has more operands than required.  */
if|if
condition|(
name|strcmp
argument_list|(
name|op_end
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|op_end
argument_list|,
literal|""
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring operands: %s "
argument_list|)
argument_list|,
name|op_end
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|inst
argument_list|)
expr_stmt|;
name|check_literals
argument_list|(
name|opcode
operator|->
name|transfer
argument_list|,
name|isize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_mcore_end
parameter_list|()
block|{
name|dump_literals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Various routines to kill one day.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP.  An error message is returned, or NULL on OK.*/
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_NTOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_JSRI2BSR_ON
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_JSRI2BSR_OFF
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SIFILTER_ON
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_SIFILTER_OFF
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_CPU
value|(OPTION_MD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 6)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"no-jsri2bsr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_JSRI2BSR_OFF
block|}
block|,
block|{
literal|"jsri2bsr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_JSRI2BSR_ON
block|}
block|,
block|{
literal|"sifilter"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SIFILTER_ON
block|}
block|,
block|{
literal|"no-sifilter"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SIFILTER_OFF
block|}
block|,
block|{
literal|"cpu"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_CPU
block|}
block|,
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CPU
case|:
if|if
condition|(
name|streq
argument_list|(
name|arg
argument_list|,
literal|"210"
argument_list|)
condition|)
block|{
name|cpu
operator|=
name|M210
expr_stmt|;
name|target_big_endian
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|arg
argument_list|,
literal|"340"
argument_list|)
condition|)
name|cpu
operator|=
name|M340
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unrecognised cpu type '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
name|M340
expr_stmt|;
break|break;
case|case
name|OPTION_JSRI2BSR_ON
case|:
name|do_jsri2bsr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_JSRI2BSR_OFF
case|:
name|do_jsri2bsr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SIFILTER_ON
case|:
name|sifilter_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_SIFILTER_OFF
case|:
name|sifilter_mode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ MCORE specific options:\n\   -{no-}jsri2bsr	  {dis}able jsri to bsr transformation (def: dis)\n\   -{no-}sifilter	  {dis}able silicon filter behavior (def: dis)\n\   -cpu=[210|340]          select CPU type\n\   -EB                     assemble for a big endian system (default)\n\   -EL                     assemble for a little endian system\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_Nddr
parameter_list|,
name|to_Nddr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_Nddr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_Nddr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check: short_jump"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_Nddr
parameter_list|,
name|to_Nddr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|from_Nddr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_Nddr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check: long_jump"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after relaxing, change the frags so they know how big they are.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|targ_addr
init|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
decl_stmt|;
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
operator|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
case|:
block|{
comment|/* Get the address of the end of the instruction.  */
name|int
name|next_inst
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
operator|+
literal|2
decl_stmt|;
name|unsigned
name|char
name|t0
decl_stmt|;
name|int
name|disp
init|=
name|targ_addr
operator|-
name|next_inst
decl_stmt|;
if|if
condition|(
name|disp
operator|&
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"odd displacement at %x"
argument_list|)
argument_list|,
name|next_inst
operator|-
literal|2
argument_list|)
expr_stmt|;
name|disp
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|t0
operator|=
name|buffer
index|[
literal|1
index|]
operator|&
literal|0xF8
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buffer
argument_list|,
name|disp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x07
operator|)
operator||
name|t0
expr_stmt|;
block|}
else|else
block|{
name|t0
operator|=
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xF8
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buffer
argument_list|,
name|disp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator||
name|t0
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
block|{
comment|/* A conditional branch wont fit into 12 bits so: 	 *	b!cond	1f 	 *	jmpi	0f 	 *	.align 2 	 * 0:	.long disp 	 * 1: 	 * 	 * if the b!cond is 4 byte aligned, the literal which would 	 * go at x+4 will also be aligned. 	 */
name|int
name|first_inst
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
name|int
name|needpad
init|=
operator|(
name|first_inst
operator|&
literal|3
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buffer
index|[
literal|1
index|]
operator|^=
literal|0x08
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|^=
literal|0x08
expr_stmt|;
comment|/* Toggle T/F bit */
name|buffer
index|[
literal|2
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|MCORE_INST_JMPI
argument_list|)
expr_stmt|;
comment|/* Build jmpi */
name|buffer
index|[
literal|3
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|MCORE_INST_JMPI
argument_list|)
expr_stmt|;
if|if
condition|(
name|needpad
condition|)
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* branch over jmpi, pad, and ptr */
name|buffer
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* jmpi offset of 1 gets the pointer */
block|}
else|else
block|{
name|buffer
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
comment|/* branch over jmpi, pad, and ptr */
name|buffer
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
comment|/* jmpi offset of 1 gets the pointer */
block|}
name|buffer
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* alignment/pad */
name|buffer
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
comment|/* space for 32 bit address */
name|buffer
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make reloc for the long disp */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|6
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|C32_LEN
expr_stmt|;
block|}
else|else
block|{
comment|/* See comment below about this given gas' limitations for 	       shrinking the fragment. '3' is the amount of code that 	       we inserted here, but '4' is right for the space we reserved 	       for this fragment.  */
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
comment|/* branch over jmpi, and ptr */
name|buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* jmpi offset of 0 gets the pointer */
block|}
else|else
block|{
name|buffer
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* branch over jmpi, and ptr */
name|buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* jmpi offset of 0 gets the pointer */
block|}
name|buffer
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* space for 32 bit address */
name|buffer
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make reloc for the long disp.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|C32_LEN
expr_stmt|;
comment|/* Frag is actually shorter (see the other side of this ifdef) 	       but gas isn't prepared for that.  We have to re-adjust 	       the branch displacement so that it goes beyond the 	       full length of the fragment, not just what we actually 	       filled in.  */
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* jmpi, ptr, and the 'tail pad' */
else|else
name|buffer
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
comment|/* jmpi, ptr, and the 'tail pad' */
block|}
block|}
break|break;
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
block|{
comment|/* An unconditional branch will not fit in 12 bits, make code which 	   looks like: 	  	jmpi	0f 	  	.align 2 	     0:	.long disp 	   we need a pad if "first_inst" is 4 byte aligned. 	   [because the natural literal place is x + 2]  */
name|int
name|first_inst
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
name|int
name|needpad
init|=
operator|!
operator|(
name|first_inst
operator|&
literal|3
operator|)
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|MCORE_INST_JMPI
argument_list|)
expr_stmt|;
comment|/* Build jmpi */
name|buffer
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|MCORE_INST_JMPI
argument_list|)
expr_stmt|;
if|if
condition|(
name|needpad
condition|)
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* jmpi offset of 1 since padded */
else|else
name|buffer
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* jmpi offset of 1 since padded */
name|buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* alignment */
name|buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* space for 32 bit address */
name|buffer
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make reloc for the long disp.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|U32_LEN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* jmpi offset of 0 if no pad */
else|else
name|buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* jmpi offset of 0 if no pad */
name|buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* space for 32 bit address */
name|buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make reloc for the long disp.  */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|U32_LEN
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Applies the desired value to the specified location.    Also sets up addends for 'rela' type relocations.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|segment
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|fixP
operator|->
name|fx_file
condition|?
name|fixP
operator|->
name|fx_file
else|:
name|_
argument_list|(
literal|"unknown"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
comment|/* Note: use offsetT because it is signed, valueT is unsigned.  */
name|offsetT
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|symname
operator|=
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
comment|/* Save this for the addend in the relocation record.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* For ELF we can just return and let the reloc that will be generated 	 take care of everything.  For COFF we still have to insert 'val' 	 into the insn since the addend field will be ignored.  */
return|return;
endif|#
directive|endif
block|}
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_MCORE_PCREL_IMM11BY2
case|:
comment|/* second byte of 2 byte opcode */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"odd distance branch (0x%lx bytes)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|~
literal|0x3ff
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator||
literal|0x3ff
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel for branch to %s too far (0x%lx)"
argument_list|)
argument_list|,
name|symname
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_MCORE_PCREL_IMM8BY4
case|:
comment|/* lower 8 bits of 2 byte opcode */
name|val
operator|+=
literal|3
expr_stmt|;
name|val
operator|/=
literal|4
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel for lrw/jmpi/jsri to %s too far (0x%lx)"
argument_list|)
argument_list|,
name|symname
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0xff
operator|)
expr_stmt|;
else|else
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MCORE_PCREL_IMM4BY2
case|:
comment|/* loopt instruction */
if|if
condition|(
operator|(
name|val
operator|<
operator|-
literal|32
operator|)
operator|||
operator|(
name|val
operator|>
operator|-
literal|2
operator|)
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel for loopt too far (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0xf
operator|)
expr_stmt|;
else|else
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
case|:
comment|/* Conditional linker map jsri to bsr.  */
comment|/* If its a local target and close enough, fix it. 	 NB:>= -2k for backwards bsr;< 2k for forwards...  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
name|val
operator|>=
operator|-
literal|2048
operator|&&
name|val
operator|<
literal|2048
condition|)
block|{
name|long
name|nval
init|=
operator|(
name|val
operator|/
literal|2
operator|)
operator|&
literal|0x7ff
decl_stmt|;
name|nval
operator||=
name|MCORE_INST_BSR
expr_stmt|;
comment|/* REPLACE the instruction, don't just modify it.  */
name|buf
index|[
literal|0
index|]
operator|=
name|INST_BYTE0
argument_list|(
name|nval
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|INST_BYTE1
argument_list|(
name|nval
argument_list|)
expr_stmt|;
block|}
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MCORE_PCREL_32
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
comment|/* If the fix is an absolute reloc based on a symbol's 	     address, then it cannot be resolved until the final link.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
operator|&&
name|val
operator|>=
operator|-
literal|32768
operator|&&
name|val
operator|<=
literal|32767
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
operator|&&
name|val
operator|>=
operator|-
literal|256
operator|&&
name|val
operator|<=
literal|255
condition|)
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
comment|/* Ignore leading hash symbol, if poresent.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|md_long_jump_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called just before address relaxation, return the length    by which a fragment must grow to reach it's destination.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment_type
decl_stmt|;
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
comment|/* Used to be a branch to somewhere which was unknown.  */
if|if
condition|(
operator|!
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
comment|/* Used to be a branch to somewhere which was unknown.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
comment|/* Got a symbol and it's defined in this segment, become byte 	     sized - maybe it will fix up */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
comment|/* Its got a segment, but its not ours, so it will always be long.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We know the abs value.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP12
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|DISP32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCD_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|DISP32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
comment|/* When relaxing a section for the second time, we don't need to 	 do anything besides return the current size.  */
break|break;
block|}
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|ptr
parameter_list|,
name|use
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|valueT
name|use
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|4
case|:
name|ptr
index|[
literal|3
index|]
operator|=
operator|(
name|use
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|3
case|:
name|ptr
index|[
literal|2
index|]
operator|=
operator|(
name|use
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|2
case|:
name|ptr
index|[
literal|1
index|]
operator|=
operator|(
name|use
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|1
case|:
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|use
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|ptr
operator|++
operator|=
operator|(
name|use
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|3
case|:
operator|*
name|ptr
operator|++
operator|=
operator|(
name|use
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|2
case|:
operator|*
name|ptr
operator|++
operator|=
operator|(
name|use
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* fall through */
case|case
literal|1
case|:
operator|*
name|ptr
operator|++
operator|=
operator|(
name|use
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixp
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* If the symbol is undefined or defined in another section      we leave the add number alone for the linker to fix it later.      Only account for the PC pre-bump (which is 2 bytes on the MCore).  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
block|{
name|assert
argument_list|(
name|fixp
operator|->
name|fx_size
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* must be an insn */
return|return
name|fixp
operator|->
name|fx_size
return|;
block|}
endif|#
directive|endif
comment|/* The case where we are going to resolve things...  */
return|return
name|fixp
operator|->
name|fx_size
operator|+
name|fixp
operator|->
name|fx_where
operator|+
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_define
define|#
directive|define
name|F
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|)
value|(((SZ)<< 1) + (PCREL))
end_define

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|,
name|TYPE
parameter_list|)
value|case F (SZ, PCREL): code = (TYPE); break
end_define

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
comment|/* These confuse the size/pcrel macro approach.  */
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_MCORE_PCREL_IMM4BY2
case|:
case|case
name|BFD_RELOC_MCORE_PCREL_IMM8BY4
case|:
case|case
name|BFD_RELOC_MCORE_PCREL_IMM11BY2
case|:
case|case
name|BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
case|:
case|case
name|BFD_RELOC_RVA
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|F
argument_list|(
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|)
condition|)
block|{
name|MAP
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_8
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_32_PCREL
argument_list|)
expr_stmt|;
default|default:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte %srelocation"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
condition|?
name|_
argument_list|(
literal|"pc-relative"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* Always pass the addend along!  */
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|mcore_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_RVA
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the fix can be handled by GAS, false if it must    be passed through to the linker.  */
end_comment

begin_function
name|bfd_boolean
name|mcore_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

end_unit

