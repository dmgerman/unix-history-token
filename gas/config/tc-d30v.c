begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-d30v.c -- Assembler code for the Mitsubishi D30V    Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/d30v.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"OnNcC"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NOP_MULTIPLY
value|1
end_define

begin_define
define|#
directive|define
name|NOP_ALL
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|warn_nops
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Optimizing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_register_name_conflicts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FORCE_SHORT
value|1
end_define

begin_define
define|#
directive|define
name|FORCE_LONG
value|2
end_define

begin_comment
comment|/* EXEC types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_exec_type
block|{
name|EXEC_UNKNOWN
block|,
comment|/* no order specified */
name|EXEC_PARALLEL
block|,
comment|/* done in parallel (FM=00) */
name|EXEC_SEQ
block|,
comment|/* sequential (FM=01) */
name|EXEC_REVSEQ
comment|/* reverse sequential (FM=10) */
block|}
name|exec_type_enum
typedef|;
end_typedef

begin_comment
comment|/* Fixups.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|(5)
end_define

begin_struct
struct|struct
name|d30v_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|operand
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|size
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|_fixups
block|{
name|int
name|fc
decl_stmt|;
name|struct
name|d30v_fixup
name|fix
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
name|struct
name|_fixups
modifier|*
name|next
decl_stmt|;
block|}
name|Fixups
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Fixups
name|FixUps
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Fixups
modifier|*
name|fixups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether current and previous instruction are word multiply insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_mul32_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_mul32_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The flag_explicitly_parallel is true iff the instruction being assembled     has been explicitly written as a parallel short-instruction pair by the     human programmer.  It is used in parallel_ok () to distinguish between     those dangerous parallelizations attempted by the human, which are to be     allowed, and those attempted by the assembler, which are not.  It is set     from md_assemble ().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_explicitly_parallel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flag_xp_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether current and previous left sub-instruction disables    execution of right sub-instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_left_kills_right_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_left_kills_right_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The known current alignment of the current section.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d30v_current_align
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|d30v_current_align_seg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last seen label in the current section.  This is used to auto-align    labels preceding instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|d30v_last_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two nops.  */
end_comment

begin_define
define|#
directive|define
name|NOP_LEFT
value|((long long) NOP<< 32)
end_define

begin_define
define|#
directive|define
name|NOP_RIGHT
value|((long long) NOP)
end_define

begin_define
define|#
directive|define
name|NOP2
value|(FM00 | NOP_LEFT | NOP_RIGHT)
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_name_search
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|expressionP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_range
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|num
operator|,
name|int
name|bits
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|postfix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|get_reloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_operand
operator|*
name|op
operator|,
name|int
name|rel_flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_operands
name|PARAMS
argument_list|(
operator|(
name|expressionS
name|exp
index|[]
operator|,
name|int
name|cmp_hack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|d30v_format
modifier|*
name|find_format
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_opcode
operator|*
name|opcode
operator|,
name|expressionS
name|ops
index|[]
operator|,
name|int
name|fsize
operator|,
name|int
name|cmp_hack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|long
name|build_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_insn
operator|*
name|opcode
operator|,
name|expressionS
operator|*
name|opers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_long
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_insn
operator|*
name|opcode
operator|,
name|long
name|long
name|insn
operator|,
name|Fixups
operator|*
name|fx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_1_short
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_insn
operator|*
name|opcode
operator|,
name|long
name|long
name|insn
operator|,
name|Fixups
operator|*
name|fx
operator|,
name|int
name|use_sequential
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_2_short
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_insn
operator|*
name|opcode1
operator|,
name|long
name|long
name|insn1
operator|,
expr|struct
name|d30v_insn
operator|*
name|opcode2
operator|,
name|long
name|long
name|insn2
operator|,
name|exec_type_enum
name|exec_type
operator|,
name|Fixups
operator|*
name|fx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|long
name|do_assemble
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
expr|struct
name|d30v_insn
operator|*
name|opcode
operator|,
name|int
name|shortp
operator|,
name|int
name|is_parallel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parallel_ok
name|PARAMS
argument_list|(
operator|(
expr|struct
name|d30v_insn
operator|*
name|opcode1
operator|,
name|unsigned
name|long
name|insn1
operator|,
expr|struct
name|d30v_insn
operator|*
name|opcode2
operator|,
name|unsigned
name|long
name|insn2
operator|,
name|exec_type_enum
name|exec_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|d30v_number_to_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|long
name|long
name|value
operator|,
name|int
name|nbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_size
name|PARAMS
argument_list|(
operator|(
name|long
name|value
operator|,
name|int
name|bits
operator|,
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|d30v_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_d30v_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_d30v_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_d30v_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_d30v_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"hword"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"align"
block|,
name|s_d30v_align
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|s_d30v_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|s_d30v_data
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|s_d30v_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|s_d30v_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|s_d30v_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|s_d30v_section
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|d30v_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a binary search of the pre_defined_registers array to see if    NAME is a valid regiter name.  Return the register number from the    array on success, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|reg_name_cnt
argument_list|()
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|pre_defined_registers
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|warn_register_name_conflicts
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Register name %s conflicts with symbol of the same name"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|pre_defined_registers
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check the string at input_line_pointer to see if it is a valid    register name.  */
end_comment

begin_function
specifier|static
name|int
name|register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
comment|/* Temporarily store a pointer to the string here.  */
name|expressionP
operator|->
name|X_op_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|input_line_pointer
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_range
parameter_list|(
name|num
parameter_list|,
name|bits
parameter_list|,
name|flags
parameter_list|)
name|unsigned
name|long
name|num
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* Don't bother checking 32-bit values.  */
if|if
condition|(
name|bits
operator|==
literal|32
condition|)
block|{
if|if
condition|(
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|CHAR_BIT
operator|==
literal|32
condition|)
return|return
literal|0
return|;
comment|/* We don't record signed or unsigned for 32-bit quantities. 	 Allow either.  */
name|min
operator|=
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|max
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|num
operator|<
name|min
operator|||
operator|(
name|long
operator|)
name|num
operator|>
name|max
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|OPERAND_SHIFT
condition|)
block|{
comment|/* We know that all shifts are right by three bits.  */
name|num
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_SIGNED
condition|)
block|{
name|unsigned
name|long
name|sign_bit
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1L
operator|>>
literal|4
operator|)
operator|+
literal|1
decl_stmt|;
name|num
operator|=
operator|(
name|num
operator|^
name|sign_bit
operator|)
operator|-
name|sign_bit
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|OPERAND_SIGNED
condition|)
block|{
name|max
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|num
operator|>
name|max
operator|||
operator|(
name|long
operator|)
name|num
operator|<
name|min
return|;
block|}
else|else
block|{
name|max
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|num
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
return|;
block|}
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\nD30V options:\n\ -O                      Make adjacent short instructions parallel if possible.\n\ -n                      Warn about all NOPs inserted by the assembler.\n\ -N			Warn about NOPs inserted after word multiplies.\n\ -c                      Warn about symbols whoes names match register names.\n\ -C                      Opposite of -C.  -c is the default.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Optimize.  Will attempt to parallelize operations.  */
case|case
literal|'O'
case|:
name|Optimizing
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Warn about all NOPS that the assembler inserts.  */
case|case
literal|'n'
case|:
name|warn_nops
operator|=
name|NOP_ALL
expr_stmt|;
break|break;
comment|/* Warn about the NOPS that the assembler inserts because of the 	 multiply hazard.  */
case|case
literal|'N'
case|:
name|warn_nops
operator|=
name|NOP_MULTIPLY
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|warn_register_name_conflicts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|warn_register_name_conflicts
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|struct
name|d30v_opcode
modifier|*
name|opcode
decl_stmt|;
name|d30v_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert opcode names into a hash table.  */
for|for
control|(
name|opcode
operator|=
operator|(
expr|struct
name|d30v_opcode
operator|*
operator|)
name|d30v_opcode_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|d30v_hash
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|fixups
operator|=
operator|&
name|FixUps
index|[
literal|0
index|]
expr_stmt|;
name|FixUps
index|[
literal|0
index|]
operator|.
name|next
operator|=
operator|&
name|FixUps
index|[
literal|1
index|]
expr_stmt|;
name|FixUps
index|[
literal|1
index|]
operator|.
name|next
operator|=
operator|&
name|FixUps
index|[
literal|0
index|]
expr_stmt|;
name|d30v_current_align_seg
operator|=
name|now_seg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the postincrement or postdecrement operator ( '+' or '-' )    from an expression.  */
end_comment

begin_function
specifier|static
name|int
name|postfix
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|'+'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|get_reloc
parameter_list|(
name|op
parameter_list|,
name|rel_flag
parameter_list|)
name|struct
name|d30v_operand
modifier|*
name|op
decl_stmt|;
name|int
name|rel_flag
decl_stmt|;
block|{
switch|switch
condition|(
name|op
operator|->
name|bits
condition|)
block|{
case|case
literal|6
case|:
if|if
condition|(
name|op
operator|->
name|flags
operator|&
name|OPERAND_SHIFT
condition|)
return|return
name|BFD_RELOC_D30V_9_PCREL
return|;
else|else
return|return
name|BFD_RELOC_D30V_6
return|;
break|break;
case|case
literal|12
case|:
if|if
condition|(
operator|!
operator|(
name|op
operator|->
name|flags
operator|&
name|OPERAND_SHIFT
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unexpected 12-bit reloc type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_flag
operator|==
name|RELOC_PCREL
condition|)
return|return
name|BFD_RELOC_D30V_15_PCREL
return|;
else|else
return|return
name|BFD_RELOC_D30V_15
return|;
case|case
literal|18
case|:
if|if
condition|(
operator|!
operator|(
name|op
operator|->
name|flags
operator|&
name|OPERAND_SHIFT
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unexpected 18-bit reloc type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_flag
operator|==
name|RELOC_PCREL
condition|)
return|return
name|BFD_RELOC_D30V_21_PCREL
return|;
else|else
return|return
name|BFD_RELOC_D30V_21
return|;
case|case
literal|32
case|:
if|if
condition|(
name|rel_flag
operator|==
name|RELOC_PCREL
condition|)
return|return
name|BFD_RELOC_D30V_32_PCREL
return|;
else|else
return|return
name|BFD_RELOC_D30V_32
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a string of operands and return an array of expressions.  */
end_comment

begin_function
specifier|static
name|int
name|get_operands
parameter_list|(
name|exp
parameter_list|,
name|cmp_hack
parameter_list|)
name|expressionS
name|exp
index|[]
decl_stmt|;
name|int
name|cmp_hack
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|numops
init|=
literal|0
decl_stmt|;
name|int
name|post
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmp_hack
condition|)
block|{
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|cmp_hack
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'@'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATPAR
expr_stmt|;
name|post
operator|=
name|postfix
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATMINUS
expr_stmt|;
block|}
else|else
block|{
name|exp
index|[
name|numops
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_ATSIGN
expr_stmt|;
name|post
operator|=
name|postfix
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|numops
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* Just skip the trailing paren.  */
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
comment|/* Check to see if it might be a register name.  */
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
condition|)
block|{
comment|/* Parse as an expression.  */
name|expression
argument_list|(
operator|&
name|exp
index|[
name|numops
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|numops
operator|++
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|post
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Postdecrement mode.  */
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_MINUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Postincrement mode.  */
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numops
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|OPERAND_PLUS
expr_stmt|;
break|break;
block|}
name|post
operator|=
literal|0
expr_stmt|;
block|}
name|exp
index|[
name|numops
index|]
operator|.
name|X_op
operator|=
literal|0
expr_stmt|;
return|return
name|numops
return|;
block|}
end_function

begin_comment
comment|/* Generate the instruction.    It does everything but write the FM bits.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|build_insn
parameter_list|(
name|opcode
parameter_list|,
name|opers
parameter_list|)
name|struct
name|d30v_insn
modifier|*
name|opcode
decl_stmt|;
name|expressionS
modifier|*
name|opers
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|length
decl_stmt|,
name|bits
decl_stmt|,
name|shift
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|,
name|id
init|=
literal|0
decl_stmt|;
name|long
name|long
name|insn
decl_stmt|;
name|struct
name|d30v_opcode
modifier|*
name|op
init|=
name|opcode
operator|->
name|op
decl_stmt|;
name|struct
name|d30v_format
modifier|*
name|form
init|=
name|opcode
operator|->
name|form
decl_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|ecc
operator|<<
literal|28
operator||
name|op
operator|->
name|op1
operator|<<
literal|25
operator||
name|op
operator|->
name|op2
operator|<<
literal|20
operator||
name|form
operator|->
name|modifier
operator|<<
literal|18
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|form
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|d30v_operand_table
index|[
name|form
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
expr_stmt|;
comment|/* Must be a register or number.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OPERAND_REG
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OPERAND_NUM
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OPERAND_NAME
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OPERAND_SPECIAL
operator|)
condition|)
continue|continue;
name|bits
operator|=
name|d30v_operand_table
index|[
name|form
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|bits
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_SHIFT
condition|)
name|bits
operator|+=
literal|3
expr_stmt|;
name|length
operator|=
name|d30v_operand_table
index|[
name|form
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|length
expr_stmt|;
name|shift
operator|=
literal|12
operator|-
name|d30v_operand_table
index|[
name|form
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|position
expr_stmt|;
if|if
condition|(
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
name|number
operator|=
name|opers
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
else|else
name|number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
comment|/* Check for mvfsys or mvtsys control registers.  */
if|if
condition|(
name|flags
operator|&
name|OPERAND_CONTROL
operator|&&
operator|(
name|number
operator|&
literal|0x7f
operator|)
operator|>
name|MAX_CONTROL_REG
condition|)
block|{
comment|/* PSWL or PSWH.  */
name|id
operator|=
operator|(
name|number
operator|&
literal|0x7f
operator|)
operator|-
name|MAX_CONTROL_REG
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|number
operator|&
name|OPERAND_FLAG
condition|)
block|{
comment|/* NUMBER is a flag register.  */
name|id
operator|=
literal|3
expr_stmt|;
block|}
name|number
operator|&=
literal|0x7F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_SPECIAL
condition|)
block|{
name|number
operator|=
name|id
expr_stmt|;
block|}
if|if
condition|(
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OPERAND_NAME
operator|)
condition|)
block|{
comment|/* Now create a fixup.  */
if|if
condition|(
name|fixups
operator|->
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|=
name|get_reloc
argument_list|(
operator|(
expr|struct
name|d30v_operand
operator|*
operator|)
operator|&
name|d30v_operand_table
index|[
name|form
operator|->
name|operands
index|[
name|i
index|]
index|]
argument_list|,
name|op
operator|->
name|reloc_flag
argument_list|)
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|exp
operator|=
name|opers
index|[
name|i
index|]
expr_stmt|;
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|operand
operator|=
name|form
operator|->
name|operands
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_D30V_9_PCREL
condition|)
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|pcrel
operator|=
name|RELOC_PCREL
expr_stmt|;
else|else
name|fixups
operator|->
name|fix
index|[
name|fixups
operator|->
name|fc
index|]
operator|.
name|pcrel
operator|=
name|op
operator|->
name|reloc_flag
expr_stmt|;
operator|(
name|fixups
operator|->
name|fc
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Truncate to the proper number of bits.  */
if|if
condition|(
operator|(
name|opers
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
name|check_range
argument_list|(
name|number
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand out of range: %ld"
argument_list|)
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|31
condition|)
name|number
operator|&=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|bits
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_SHIFT
condition|)
name|number
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|32
condition|)
block|{
comment|/* It's a LONG instruction.  */
name|insn
operator||=
operator|(
operator|(
name|number
operator|&
literal|0xffffffff
operator|)
operator|>>
literal|26
operator|)
expr_stmt|;
comment|/* top 6 bits */
name|insn
operator|<<=
literal|32
expr_stmt|;
comment|/* shift the first word over */
name|insn
operator||=
operator|(
operator|(
name|number
operator|&
literal|0x03FC0000
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* next 8 bits */
name|insn
operator||=
name|number
operator|&
literal|0x0003FFFF
expr_stmt|;
comment|/* bottom 18 bits */
block|}
else|else
name|insn
operator||=
name|number
operator|<<
name|shift
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Write out a long form instruction.  */
end_comment

begin_function
specifier|static
name|void
name|write_long
parameter_list|(
name|opcode
parameter_list|,
name|insn
parameter_list|,
name|fx
parameter_list|)
name|struct
name|d30v_insn
modifier|*
name|opcode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|long
name|insn
decl_stmt|;
name|Fixups
modifier|*
name|fx
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|where
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|frag_more
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|insn
operator||=
name|FM11
expr_stmt|;
name|d30v_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a short form instruction by itself.  */
end_comment

begin_function
specifier|static
name|void
name|write_1_short
parameter_list|(
name|opcode
parameter_list|,
name|insn
parameter_list|,
name|fx
parameter_list|,
name|use_sequential
parameter_list|)
name|struct
name|d30v_insn
modifier|*
name|opcode
decl_stmt|;
name|long
name|long
name|insn
decl_stmt|;
name|Fixups
modifier|*
name|fx
decl_stmt|;
name|int
name|use_sequential
decl_stmt|;
block|{
name|char
modifier|*
name|f
init|=
name|frag_more
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|where
decl_stmt|;
if|if
condition|(
name|warn_nops
operator|==
name|NOP_ALL
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s NOP inserted"
argument_list|)
argument_list|,
name|use_sequential
condition|?
name|_
argument_list|(
literal|"sequential"
argument_list|)
else|:
name|_
argument_list|(
literal|"parallel"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The other container needs to be NOP.  */
if|if
condition|(
name|use_sequential
condition|)
block|{
comment|/* Use a sequential NOP rather than a parallel one, 	 as the current instruction is a FLAG_MUL32 type one 	 and the next instruction is a load.  */
comment|/* According to 4.3.1: for FM=01, sub-instructions performed 	 only by IU cannot be encoded in L-container.  */
if|if
condition|(
name|opcode
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
comment|/* Right then left.  */
name|insn
operator||=
name|FM10
operator||
name|NOP_LEFT
expr_stmt|;
else|else
comment|/* Left then right.  */
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn
operator|<<
literal|32
operator|)
operator||
name|NOP_RIGHT
expr_stmt|;
block|}
else|else
block|{
comment|/* According to 4.3.1: for FM=00, sub-instructions performed 	 only by IU cannot be encoded in L-container.  */
if|if
condition|(
name|opcode
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
comment|/* Right container.  */
name|insn
operator||=
name|FM00
operator||
name|NOP_LEFT
expr_stmt|;
else|else
comment|/* Left container.  */
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn
operator|<<
literal|32
operator|)
operator||
name|NOP_RIGHT
expr_stmt|;
block|}
name|d30v_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a short form instruction if possible.    Return number of instructions not written out.  */
end_comment

begin_function
specifier|static
name|int
name|write_2_short
parameter_list|(
name|opcode1
parameter_list|,
name|insn1
parameter_list|,
name|opcode2
parameter_list|,
name|insn2
parameter_list|,
name|exec_type
parameter_list|,
name|fx
parameter_list|)
name|struct
name|d30v_insn
modifier|*
name|opcode1
decl_stmt|,
decl|*
name|opcode2
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|long
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|exec_type_enum
name|exec_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Fixups
modifier|*
name|fx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|long
name|insn
init|=
name|NOP2
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|where
decl_stmt|;
if|if
condition|(
name|exec_type
operator|==
name|EXEC_SEQ
operator|&&
operator|(
name|opcode1
operator|->
name|op
operator|->
name|flags_used
operator|&
operator|(
name|FLAG_JMP
operator||
name|FLAG_JSR
operator|)
operator|)
operator|&&
operator|(
operator|(
name|opcode1
operator|->
name|op
operator|->
name|flags_used
operator|&
name|FLAG_DELAY
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opcode1
operator|->
name|ecc
operator|==
name|ECC_AL
operator|)
operator|||
operator|!
name|Optimizing
operator|)
condition|)
block|{
comment|/* Unconditional, non-delayed branches kill instructions in 	 the right bin.  Conditional branches don't always but if 	 we are not optimizing, then we have been asked to produce 	 an error about such constructs.  For the purposes of this 	 test, subroutine calls are considered to be branches.  */
name|write_1_short
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|fx
operator|->
name|next
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Note: we do not have to worry about subroutine calls occurring      in the right hand container.  The return address is always      aligned to the next 64 bit boundary, be that 64 or 32 bit away.  */
switch|switch
condition|(
name|exec_type
condition|)
block|{
case|case
name|EXEC_UNKNOWN
case|:
comment|/* Order not specified.  */
if|if
condition|(
name|Optimizing
operator|&&
name|parallel_ok
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|opcode2
argument_list|,
name|insn2
argument_list|,
name|exec_type
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
operator|||
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
operator|)
operator|&&
operator|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
operator|||
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
operator|)
operator|)
condition|)
block|{
comment|/* Parallel.  */
name|exec_type
operator|=
name|EXEC_PARALLEL
expr_stmt|;
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
operator|||
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
operator|||
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|32
operator|)
operator||
name|insn1
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn1
operator|<<
literal|32
operator|)
operator||
name|insn2
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|opcode1
operator|->
name|op
operator|->
name|flags_used
operator|&
operator|(
name|FLAG_JMP
operator||
name|FLAG_JSR
operator|)
operator|&&
operator|(
operator|(
name|opcode1
operator|->
name|op
operator|->
name|flags_used
operator|&
name|FLAG_DELAY
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
name|opcode1
operator|->
name|op
operator|->
name|flags_used
operator|&
name|FLAG_RP
condition|)
block|{
comment|/* We must emit (non-delayed) branch type instructions 	     on their own with nothing in the right container.  */
comment|/* We must treat repeat instructions likewise, since the 	     following instruction has to be separate from the repeat 	     in order to be repeated.  */
name|write_1_short
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|fx
operator|->
name|next
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|prev_left_kills_right_p
condition|)
block|{
comment|/* The left instruction kils the right slot, so we 	     must leave it empty.  */
name|write_1_short
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|fx
operator|->
name|next
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
block|{
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
block|{
comment|/* Case 103810 is a request from Mitsubishi that opcodes 		 with EITHER_BUT_PREFER_MU should not be executed in 		 reverse sequential order.  */
name|write_1_short
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|fx
operator|->
name|next
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Reverse sequential.  */
name|insn
operator|=
name|FM10
operator||
operator|(
name|insn2
operator|<<
literal|32
operator|)
operator||
name|insn1
expr_stmt|;
name|exec_type
operator|=
name|EXEC_REVSEQ
expr_stmt|;
block|}
else|else
block|{
comment|/* Sequential.  */
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn1
operator|<<
literal|32
operator|)
operator||
name|insn2
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
name|exec_type
operator|=
name|EXEC_SEQ
expr_stmt|;
block|}
break|break;
case|case
name|EXEC_PARALLEL
case|:
comment|/* Parallel.  */
name|flag_explicitly_parallel
operator|=
name|flag_xp_state
expr_stmt|;
if|if
condition|(
operator|!
name|parallel_ok
argument_list|(
name|opcode1
argument_list|,
name|insn1
argument_list|,
name|opcode2
argument_list|,
name|insn2
argument_list|,
name|exec_type
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instructions may not be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
block|{
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Two IU instructions may not be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|32
operator|)
operator||
name|insn1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
condition|)
block|{
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Two MU instructions may not be executed in parallel"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Executing %s in IU may not work"
argument_list|)
argument_list|,
name|opcode1
operator|->
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Swapping instruction order"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn2
operator|<<
literal|32
operator|)
operator||
name|insn1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Executing %s in IU may not work in parallel execution"
argument_list|)
argument_list|,
name|opcode2
operator|->
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM00
operator||
operator|(
name|insn1
operator|<<
literal|32
operator|)
operator||
name|insn2
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
block|}
name|flag_explicitly_parallel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EXEC_SEQ
case|:
comment|/* Sequential.  */
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"IU instruction may not be in the left container"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_left_kills_right_p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"special left instruction `%s' kills instruction "
literal|"`%s' in right container"
argument_list|)
argument_list|,
name|opcode1
operator|->
name|op
operator|->
name|name
argument_list|,
name|opcode2
operator|->
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM01
operator||
operator|(
name|insn1
operator|<<
literal|32
operator|)
operator||
name|insn2
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|EXEC_REVSEQ
case|:
comment|/* Reverse sequential.  */
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MU instruction may not be in the right container"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode1
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Executing %s in reverse serial with %s may not work"
argument_list|)
argument_list|,
name|opcode1
operator|->
name|op
operator|->
name|name
argument_list|,
name|opcode2
operator|->
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER_BUT_PREFER_MU
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Executing %s in IU in reverse serial may not work"
argument_list|)
argument_list|,
name|opcode2
operator|->
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn
operator|=
name|FM10
operator||
operator|(
name|insn1
operator|<<
literal|32
operator|)
operator||
name|insn2
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown execution type passed to write_2_short()"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("writing out %llx\n", insn);
endif|#
directive|endif
name|f
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|d30v_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* If the previous instruction was a 32-bit multiply but it is put into a      parallel container, mark the current instruction as being a 32-bit      multiply.  */
if|if
condition|(
name|prev_mul32_p
operator|&&
name|exec_type
operator|==
name|EXEC_PARALLEL
condition|)
name|cur_mul32_p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fx
operator|->
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
name|where
operator|=
operator|(
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|+
literal|4
operator|*
name|j
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
operator|(
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|exp
operator|)
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|fx
operator|->
name|fix
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
name|fx
operator|->
name|fc
operator|=
literal|0
expr_stmt|;
name|fx
operator|=
name|fx
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Check 2 instructions and determine if they can be safely    executed in parallel.  Return 1 if they can be.  */
end_comment

begin_function
specifier|static
name|int
name|parallel_ok
parameter_list|(
name|op1
parameter_list|,
name|insn1
parameter_list|,
name|op2
parameter_list|,
name|insn2
parameter_list|,
name|exec_type
parameter_list|)
name|struct
name|d30v_insn
modifier|*
name|op1
decl_stmt|,
decl|*
name|op2
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|long
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|exec_type_enum
name|exec_type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|shift
decl_stmt|,
name|regno
decl_stmt|,
name|bits
decl_stmt|,
name|ecc
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|,
name|mask
decl_stmt|,
name|flags_set1
decl_stmt|,
name|flags_set2
decl_stmt|,
name|flags_used1
decl_stmt|,
name|flags_used2
decl_stmt|;
name|unsigned
name|long
name|ins
decl_stmt|,
name|mod_reg
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|,
name|used_reg
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|,
name|flag_reg
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|d30v_format
modifier|*
name|f
decl_stmt|;
name|struct
name|d30v_opcode
modifier|*
name|op
decl_stmt|;
comment|/* Section 4.3: Both instructions must not be IU or MU only.  */
if|if
condition|(
operator|(
name|op1
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
operator|&&
name|op2
operator|->
name|op
operator|->
name|unit
operator|==
name|IU
operator|)
operator|||
operator|(
name|op1
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
operator|&&
name|op2
operator|->
name|op
operator|->
name|unit
operator|==
name|MU
operator|)
condition|)
return|return
literal|0
return|;
comment|/* First instruction must not be a jump to safely optimize, unless this      is an explicit parallel operation.  */
if|if
condition|(
name|exec_type
operator|!=
name|EXEC_PARALLEL
operator|&&
operator|(
name|op1
operator|->
name|op
operator|->
name|flags_used
operator|&
operator|(
name|FLAG_JMP
operator||
name|FLAG_JSR
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If one instruction is /TX or /XT and the other is /FX or /XF respectively,      then it is safe to allow the two to be done as parallel ops, since only      one will ever be executed at a time.  */
if|if
condition|(
operator|(
name|op1
operator|->
name|ecc
operator|==
name|ECC_TX
operator|&&
name|op2
operator|->
name|ecc
operator|==
name|ECC_FX
operator|)
operator|||
operator|(
name|op1
operator|->
name|ecc
operator|==
name|ECC_FX
operator|&&
name|op2
operator|->
name|ecc
operator|==
name|ECC_TX
operator|)
operator|||
operator|(
name|op1
operator|->
name|ecc
operator|==
name|ECC_XT
operator|&&
name|op2
operator|->
name|ecc
operator|==
name|ECC_XF
operator|)
operator|||
operator|(
name|op1
operator|->
name|ecc
operator|==
name|ECC_XF
operator|&&
name|op2
operator|->
name|ecc
operator|==
name|ECC_XT
operator|)
condition|)
return|return
literal|1
return|;
comment|/* [0] r0-r31      [1] r32-r63      [2] a0, a1, flag registers.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|op1
operator|->
name|form
expr_stmt|;
name|op
operator|=
name|op1
operator|->
name|op
expr_stmt|;
name|ecc
operator|=
name|op1
operator|->
name|ecc
expr_stmt|;
name|ins
operator|=
name|insn1
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|op2
operator|->
name|form
expr_stmt|;
name|op
operator|=
name|op2
operator|->
name|op
expr_stmt|;
name|ecc
operator|=
name|op2
operator|->
name|ecc
expr_stmt|;
name|ins
operator|=
name|insn2
expr_stmt|;
block|}
name|flag_reg
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|mod_reg
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|mod_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|used_reg
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|used_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_explicitly_parallel
condition|)
block|{
comment|/* For human specified parallel instructions we have been asked 	     to ignore the possibility that both instructions could modify 	     bits in the PSW, so we initialise the mod& used arrays to 0. 	     We have been asked, however, to refuse to allow parallel 	     instructions which explicitly set the same flag register, 	     eg "cmpne f0,r1,0x10 || cmpeq f0, r5, 0x2", so further on we test 	     for the use of a flag register and set a bit in the mod or used 	     array appropriately.  */
name|mod_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mod_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|op
operator|->
name|flags_set
operator|&
name|FLAG_ALL
operator|)
expr_stmt|;
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|op
operator|->
name|flags_used
operator|&
name|FLAG_ALL
operator|)
expr_stmt|;
block|}
comment|/* BSR/JSR always sets R62.  */
if|if
condition|(
name|op
operator|->
name|flags_used
operator|&
name|FLAG_JSR
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|1L
operator|<<
operator|(
literal|62
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
comment|/* Conditional execution affects the flags_used.  */
switch|switch
condition|(
name|ecc
condition|)
block|{
case|case
name|ECC_TX
case|:
case|case
name|ECC_FX
case|:
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|flag_reg
index|[
name|j
index|]
operator|=
name|FLAG_0
expr_stmt|;
break|break;
case|case
name|ECC_XT
case|:
case|case
name|ECC_XF
case|:
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|flag_reg
index|[
name|j
index|]
operator|=
name|FLAG_1
expr_stmt|;
break|break;
case|case
name|ECC_TT
case|:
case|case
name|ECC_TF
case|:
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|flag_reg
index|[
name|j
index|]
operator|=
operator|(
name|FLAG_0
operator||
name|FLAG_1
operator|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|operands
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|d30v_operand_table
index|[
name|f
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|shift
operator|=
literal|12
operator|-
name|d30v_operand_table
index|[
name|f
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|position
expr_stmt|;
name|bits
operator|=
name|d30v_operand_table
index|[
name|f
operator|->
name|operands
index|[
name|i
index|]
index|]
operator|.
name|bits
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|32
condition|)
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|mask
operator|=
literal|0x7FFFFFFF
operator|>>
operator|(
literal|31
operator|-
name|bits
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|OPERAND_PLUS
operator|)
operator|||
operator|(
name|flags
operator|&
name|OPERAND_MINUS
operator|)
condition|)
block|{
comment|/* This is a post-increment or post-decrement. 		 The previous register needs to be marked as modified.  */
name|shift
operator|=
literal|12
operator|-
name|d30v_operand_table
index|[
name|f
operator|->
name|operands
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|.
name|position
expr_stmt|;
name|regno
operator|=
operator|(
name|ins
operator|>>
name|shift
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|32
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator||=
literal|1L
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
expr_stmt|;
else|else
name|mod_reg
index|[
name|j
index|]
index|[
literal|0
index|]
operator||=
literal|1L
operator|<<
name|regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
name|regno
operator|=
operator|(
name|ins
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
comment|/* The memory write functions don't have a destination                  register.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|OPERAND_DEST
operator|)
operator|&&
operator|!
operator|(
name|op
operator|->
name|flags_set
operator|&
name|FLAG_MEM
operator|)
condition|)
block|{
comment|/* MODIFIED registers and flags.  */
if|if
condition|(
name|flags
operator|&
name|OPERAND_ACC
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|FLAG_A0
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
literal|1
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|FLAG_A1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_FLAG
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
literal|1L
operator|<<
name|regno
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OPERAND_CONTROL
operator|)
condition|)
block|{
name|int
name|r
decl_stmt|,
name|z
decl_stmt|;
comment|/* Need to check if there are two destination 			 registers, for example ld2w.  */
if|if
condition|(
name|flags
operator|&
name|OPERAND_2REG
condition|)
name|z
operator|=
literal|1
expr_stmt|;
else|else
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<=
name|regno
operator|+
name|z
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|r
operator|>=
literal|32
condition|)
name|mod_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator||=
literal|1L
operator|<<
operator|(
name|r
operator|-
literal|32
operator|)
expr_stmt|;
else|else
name|mod_reg
index|[
name|j
index|]
index|[
literal|0
index|]
operator||=
literal|1L
operator|<<
name|r
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* USED, but not modified registers and flags.  */
if|if
condition|(
name|flags
operator|&
name|OPERAND_ACC
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|FLAG_A0
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
literal|1
condition|)
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
name|FLAG_A1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_FLAG
condition|)
name|used_reg
index|[
name|j
index|]
index|[
literal|2
index|]
operator||=
literal|1L
operator|<<
name|regno
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OPERAND_CONTROL
operator|)
condition|)
block|{
name|int
name|r
decl_stmt|,
name|z
decl_stmt|;
comment|/* Need to check if there are two source 			 registers, for example st2w.  */
if|if
condition|(
name|flags
operator|&
name|OPERAND_2REG
condition|)
name|z
operator|=
literal|1
expr_stmt|;
else|else
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<=
name|regno
operator|+
name|z
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|r
operator|>=
literal|32
condition|)
name|used_reg
index|[
name|j
index|]
index|[
literal|1
index|]
operator||=
literal|1L
operator|<<
operator|(
name|r
operator|-
literal|32
operator|)
expr_stmt|;
else|else
name|used_reg
index|[
name|j
index|]
index|[
literal|0
index|]
operator||=
literal|1L
operator|<<
name|r
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|flags_set1
operator|=
name|op1
operator|->
name|op
operator|->
name|flags_set
expr_stmt|;
name|flags_set2
operator|=
name|op2
operator|->
name|op
operator|->
name|flags_set
expr_stmt|;
name|flags_used1
operator|=
name|op1
operator|->
name|op
operator|->
name|flags_used
expr_stmt|;
name|flags_used2
operator|=
name|op2
operator|->
name|op
operator|->
name|flags_used
expr_stmt|;
comment|/* Check for illegal combinations with ADDppp/SUBppp.  */
if|if
condition|(
operator|(
operator|(
name|flags_set1
operator|&
name|FLAG_NOT_WITH_ADDSUBppp
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags_used2
operator|&
name|FLAG_ADDSUBppp
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|flags_set2
operator|&
name|FLAG_NOT_WITH_ADDSUBppp
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags_used1
operator|&
name|FLAG_ADDSUBppp
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Load instruction combined with half-word multiply is illegal.  */
if|if
condition|(
operator|(
operator|(
name|flags_used1
operator|&
name|FLAG_MEM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags_used2
operator|&
name|FLAG_MUL16
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags_used2
operator|&
name|FLAG_MEM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags_used1
operator|&
name|FLAG_MUL16
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Specifically allow add || add by removing carry, overflow bits dependency.      This is safe, even if an addc follows since the IU takes the argument in      the right container, and it writes its results last.      However, don't paralellize add followed by addc or sub followed by      subb.  */
if|if
condition|(
name|mod_reg
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
name|FLAG_CVVA
operator|&&
name|mod_reg
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
name|FLAG_CVVA
operator|&&
operator|(
name|used_reg
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|&
operator|~
name|flag_reg
index|[
literal|0
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|used_reg
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|&
operator|~
name|flag_reg
index|[
literal|1
index|]
operator|)
operator|==
literal|0
operator|&&
name|op1
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER
operator|&&
name|op2
operator|->
name|op
operator|->
name|unit
operator|==
name|EITHER
condition|)
block|{
name|mod_reg
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|mod_reg
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
comment|/* If the second instruction depends on the first, we obviously 	 cannot parallelize.  Note, the mod flag implies use, so 	 check that as well.  */
comment|/* If flag_explicitly_parallel is set, then the case of the 	 second instruction using a register the first instruction 	 modifies is assumed to be okay; we trust the human.  We 	 don't trust the human if both instructions modify the same 	 register but we do trust the human if they modify the same 	 flags.  */
comment|/* We have now been requested not to trust the human if the 	 instructions modify the same flag registers either.  */
if|if
condition|(
name|flag_explicitly_parallel
condition|)
block|{
if|if
condition|(
operator|(
name|mod_reg
index|[
literal|0
index|]
index|[
name|j
index|]
operator|&
name|mod_reg
index|[
literal|1
index|]
index|[
name|j
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mod_reg
index|[
literal|0
index|]
index|[
name|j
index|]
operator|&
operator|(
name|mod_reg
index|[
literal|1
index|]
index|[
name|j
index|]
operator||
name|used_reg
index|[
literal|1
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This is the main entry point for the machine-dependent assembler.    STR points to a machine-dependent instruction.  This function is    supposed to emit the frags/bytes it assembles to.  For the D30V, it    mostly handles the special VLIW parsing and packing and leaves the    difficult stuff to do_assemble ().  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|long
name|prev_insn
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|d30v_insn
name|prev_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|subsegT
name|prev_subseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|prev_seg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|d30v_insn
name|opcode
decl_stmt|;
name|long
name|long
name|insn
decl_stmt|;
comment|/* Execution type; parallel, etc.  */
name|exec_type_enum
name|extype
init|=
name|EXEC_UNKNOWN
decl_stmt|;
comment|/* Saved extype.  Used for multiline instructions.  */
specifier|static
name|exec_type_enum
name|etype
init|=
name|EXEC_UNKNOWN
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
if|if
condition|(
operator|(
name|prev_insn
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|prev_seg
operator|&&
operator|(
operator|(
name|prev_seg
operator|!=
name|now_seg
operator|)
operator|||
operator|(
name|prev_subseg
operator|!=
name|now_subseg
operator|)
operator|)
condition|)
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|d30v_current_align
operator|<
literal|3
condition|)
name|d30v_align
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
name|d30v_last_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d30v_current_align
operator|>
literal|3
condition|)
name|d30v_current_align
operator|=
literal|3
expr_stmt|;
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
name|flag_explicitly_parallel
operator|=
literal|0
expr_stmt|;
name|flag_xp_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|EXEC_UNKNOWN
condition|)
block|{
comment|/* Look for the special multiple instruction separators.  */
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
block|{
name|extype
operator|=
name|EXEC_PARALLEL
expr_stmt|;
name|flag_xp_state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
name|extype
operator|=
name|EXEC_SEQ
expr_stmt|;
else|else
block|{
name|str2
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"<-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
condition|)
name|extype
operator|=
name|EXEC_REVSEQ
expr_stmt|;
block|}
block|}
comment|/* STR2 points to the separator, if one.  */
if|if
condition|(
name|str2
condition|)
block|{
operator|*
name|str2
operator|=
literal|0
expr_stmt|;
comment|/* If two instructions are present and we already have one saved, 	     then first write it out.  */
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assemble first instruction and save it.  */
name|prev_insn
operator|=
name|do_assemble
argument_list|(
name|str
argument_list|,
operator|&
name|prev_opcode
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_insn
operator|==
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cannot assemble instruction"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_opcode
operator|.
name|form
operator|!=
name|NULL
operator|&&
name|prev_opcode
operator|.
name|form
operator|->
name|form
operator|>=
name|LONG
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"First opcode is long.  Unable to mix instructions as specified."
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|str
operator|=
name|str2
operator|+
literal|2
expr_stmt|;
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|do_assemble
argument_list|(
name|str
argument_list|,
operator|&
name|opcode
argument_list|,
operator|(
name|extype
operator|!=
name|EXEC_UNKNOWN
operator|||
name|etype
operator|!=
name|EXEC_UNKNOWN
operator|)
argument_list|,
name|extype
operator|==
name|EXEC_PARALLEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|extype
operator|!=
name|EXEC_UNKNOWN
condition|)
name|etype
operator|=
name|extype
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Cannot assemble instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|etype
operator|!=
name|EXEC_UNKNOWN
condition|)
block|{
name|extype
operator|=
name|etype
expr_stmt|;
name|etype
operator|=
name|EXEC_UNKNOWN
expr_stmt|;
block|}
comment|/* Word multiply instructions must not be followed by either a load or a      16-bit multiply instruction in the next cycle.  */
if|if
condition|(
operator|(
name|extype
operator|!=
name|EXEC_REVSEQ
operator|)
operator|&&
name|prev_mul32_p
operator|&&
operator|(
name|opcode
operator|.
name|op
operator|->
name|flags_used
operator|&
operator|(
name|FLAG_MEM
operator||
name|FLAG_MUL16
operator|)
operator|)
condition|)
block|{
comment|/* However, load and multiply should able to be combined in a parallel 	 operation, so check for that first.  */
if|if
condition|(
name|prev_insn
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|opcode
operator|.
name|op
operator|->
name|flags_used
operator|&
name|FLAG_MEM
operator|)
operator|&&
name|opcode
operator|.
name|form
operator|->
name|form
operator|<
name|LONG
operator|&&
operator|(
name|extype
operator|==
name|EXEC_PARALLEL
operator|||
operator|(
name|Optimizing
operator|&&
name|extype
operator|==
name|EXEC_UNKNOWN
operator|)
operator|)
operator|&&
name|parallel_ok
argument_list|(
operator|&
name|prev_opcode
argument_list|,
operator|(
name|long
operator|)
name|prev_insn
argument_list|,
operator|&
name|opcode
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|,
name|extype
argument_list|)
operator|&&
name|write_2_short
argument_list|(
operator|&
name|prev_opcode
argument_list|,
operator|(
name|long
operator|)
name|prev_insn
argument_list|,
operator|&
name|opcode
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|,
name|extype
argument_list|,
name|fixups
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* No instructions saved.  */
name|prev_insn
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Can't parallelize, flush previous instruction and emit a 	     word of NOPS, unless the previous instruction is a NOP, 	     in which case just flush it, as this will generate a word 	     of NOPs for us.  */
if|if
condition|(
name|prev_insn
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|strcmp
argument_list|(
name|prev_opcode
operator|.
name|op
operator|->
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|prev_insn
operator|!=
operator|-
literal|1
condition|)
name|d30v_cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|d30v_number_to_chars
argument_list|(
name|f
argument_list|,
name|NOP2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nops
operator|==
name|NOP_ALL
operator|||
name|warn_nops
operator|==
name|NOP_MULTIPLY
condition|)
block|{
if|if
condition|(
name|opcode
operator|.
name|op
operator|->
name|flags_used
operator|&
name|FLAG_MEM
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"word of NOPs added between word multiply and load"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"word of NOPs added between word multiply and 16-bit multiply"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|extype
operator|=
name|EXEC_UNKNOWN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|extype
operator|==
name|EXEC_REVSEQ
operator|)
operator|&&
name|cur_mul32_p
operator|&&
operator|(
name|prev_opcode
operator|.
name|op
operator|->
name|flags_used
operator|&
operator|(
name|FLAG_MEM
operator||
name|FLAG_MUL16
operator|)
operator|)
condition|)
block|{
comment|/* Can't parallelize, flush current instruction and add a          sequential NOP.  */
name|write_1_short
argument_list|(
operator|&
name|opcode
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|,
name|fixups
operator|->
name|next
operator|->
name|next
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Make the previous instruction the current one.  */
name|extype
operator|=
name|EXEC_UNKNOWN
expr_stmt|;
name|insn
operator|=
name|prev_insn
expr_stmt|;
name|now_seg
operator|=
name|prev_seg
expr_stmt|;
name|now_subseg
operator|=
name|prev_subseg
expr_stmt|;
name|prev_insn
operator|=
operator|-
literal|1
expr_stmt|;
name|cur_mul32_p
operator|=
name|prev_mul32_p
expr_stmt|;
name|prev_mul32_p
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|opcode
argument_list|,
operator|&
name|prev_opcode
argument_list|,
sizeof|sizeof
argument_list|(
name|prev_opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a long instruction, write it and any previous short      instruction.  */
if|if
condition|(
name|opcode
operator|.
name|form
operator|->
name|form
operator|>=
name|LONG
condition|)
block|{
if|if
condition|(
name|extype
operator|!=
name|EXEC_UNKNOWN
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction uses long version, so it cannot be mixed as specified"
argument_list|)
argument_list|)
expr_stmt|;
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|write_long
argument_list|(
operator|&
name|opcode
argument_list|,
name|insn
argument_list|,
name|fixups
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prev_insn
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|write_2_short
argument_list|(
operator|&
name|prev_opcode
argument_list|,
operator|(
name|long
operator|)
name|prev_insn
argument_list|,
operator|&
name|opcode
argument_list|,
operator|(
name|long
operator|)
name|insn
argument_list|,
name|extype
argument_list|,
name|fixups
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* No instructions saved.  */
name|prev_insn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|extype
operator|!=
name|EXEC_UNKNOWN
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unable to mix instructions as specified"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save off last instruction so it may be packed on next pass.  */
name|memcpy
argument_list|(
operator|&
name|prev_opcode
argument_list|,
operator|&
name|opcode
argument_list|,
sizeof|sizeof
argument_list|(
name|prev_opcode
argument_list|)
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|insn
expr_stmt|;
name|prev_seg
operator|=
name|now_seg
expr_stmt|;
name|prev_subseg
operator|=
name|now_subseg
expr_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|prev_mul32_p
operator|=
name|cur_mul32_p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a single instruction and return an opcode.    Return -1 (an invalid opcode) on error.  */
end_comment

begin_define
define|#
directive|define
name|NAME_BUF_LEN
value|20
end_define

begin_function
specifier|static
name|long
name|long
name|do_assemble
parameter_list|(
name|str
parameter_list|,
name|opcode
parameter_list|,
name|shortp
parameter_list|,
name|is_parallel
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|d30v_insn
modifier|*
name|opcode
decl_stmt|;
name|int
name|shortp
decl_stmt|;
name|int
name|is_parallel
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|op_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|save
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_end
decl_stmt|;
name|char
name|name
index|[
name|NAME_BUF_LEN
index|]
decl_stmt|;
name|int
name|cmp_hack
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
name|int
name|fsize
init|=
operator|(
name|shortp
condition|?
name|FORCE_SHORT
else|:
literal|0
operator|)
decl_stmt|;
name|expressionS
name|myops
index|[
literal|6
index|]
decl_stmt|;
name|long
name|long
name|insn
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the opcode end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|)
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
operator|(
name|NAME_BUF_LEN
operator|-
literal|1
operator|)
operator|&&
operator|*
name|op_end
operator|!=
literal|'/'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
name|name
index|[
name|nlen
index|]
operator|=
name|TOLOWER
argument_list|(
name|op_start
index|[
name|nlen
index|]
argument_list|)
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there is an execution condition code, handle it.  */
if|if
condition|(
operator|*
name|op_end
operator|==
literal|'/'
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|ECC_MAX
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|d30v_ecc_names
index|[
name|i
index|]
argument_list|,
name|op_end
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ECC_MAX
condition|)
block|{
name|char
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|tmp
argument_list|,
name|op_end
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown condition code: %s"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
literal|0
block|printf ("condition code=%d\n", i);
endif|#
directive|endif
name|opcode
operator|->
name|ecc
operator|=
name|i
expr_stmt|;
name|op_end
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|opcode
operator|->
name|ecc
operator|=
name|ECC_AL
expr_stmt|;
comment|/* CMP and CMPU change their name based on condition codes.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"cmp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|int
name|p
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|d30v_cc_names
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|==
literal|'u'
condition|)
name|p
operator|=
literal|4
expr_stmt|;
else|else
name|p
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|str
operator|&&
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
operator|&
name|name
index|[
name|p
index|]
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
operator|,
name|str
operator|++
control|)
empty_stmt|;
comment|/* cmpu only supports some condition codes.  */
if|if
condition|(
name|p
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|3
operator|||
name|i
operator|>
literal|6
condition|)
block|{
name|name
index|[
name|p
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cmpu doesn't support condition code %s"
argument_list|)
argument_list|,
operator|&
name|name
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|str
condition|)
block|{
name|name
index|[
name|p
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown condition code: %s"
argument_list|)
argument_list|,
operator|&
name|name
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
name|cmp_hack
operator|=
name|i
expr_stmt|;
name|name
index|[
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cmp_hack
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("cmp_hack=%d\n", cmp_hack);
endif|#
directive|endif
comment|/* Need to look for .s or .l.  */
if|if
condition|(
name|name
index|[
name|nlen
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|name
index|[
name|nlen
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|fsize
operator|=
name|FORCE_SHORT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fsize
operator|=
name|FORCE_LONG
expr_stmt|;
break|break;
block|}
name|name
index|[
name|nlen
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find the first opcode with the proper name.  */
name|opcode
operator|->
name|op
operator|=
operator|(
expr|struct
name|d30v_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|d30v_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|op
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|op_end
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|opcode
operator|->
name|form
operator|=
name|find_format
argument_list|(
name|opcode
operator|->
name|op
argument_list|,
name|myops
argument_list|,
name|fsize
argument_list|,
name|cmp_hack
argument_list|)
operator|)
condition|)
block|{
name|opcode
operator|->
name|op
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|op
operator|->
name|name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|opcode
operator|->
name|op
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operands for opcode `%s' do not match any valid format"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|input_line_pointer
operator|=
name|save
expr_stmt|;
name|insn
operator|=
name|build_insn
argument_list|(
name|opcode
argument_list|,
name|myops
argument_list|)
expr_stmt|;
comment|/* Propagate multiply status.  */
if|if
condition|(
name|insn
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_parallel
operator|&&
name|prev_mul32_p
condition|)
name|cur_mul32_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|prev_mul32_p
operator|=
name|cur_mul32_p
expr_stmt|;
name|cur_mul32_p
operator|=
operator|(
name|opcode
operator|->
name|op
operator|->
name|flags_used
operator|&
name|FLAG_MUL32
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Propagate left_kills_right status.  */
if|if
condition|(
name|insn
operator|!=
operator|-
literal|1
condition|)
block|{
name|prev_left_kills_right_p
operator|=
name|cur_left_kills_right_p
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|op
operator|->
name|flags_set
operator|&
name|FLAG_LKR
condition|)
block|{
name|cur_left_kills_right_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opcode
operator|->
name|op
operator|->
name|name
argument_list|,
literal|"mvtsys"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Left kills right for only mvtsys only for                  PSW/PSWH/PSWL/flags target.  */
if|if
condition|(
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|)
operator|||
comment|/* psw */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
name|MAX_CONTROL_REG
operator|+
literal|2
operator|)
operator|||
comment|/* pswh */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_CONTROL
operator|+
name|MAX_CONTROL_REG
operator|+
literal|1
operator|)
operator|||
comment|/* pswl */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|0
operator|)
operator|||
comment|/* f0 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|1
operator|)
operator|||
comment|/* f1 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|2
operator|)
operator|||
comment|/* f2 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|3
operator|)
operator|||
comment|/* f3 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|4
operator|)
operator|||
comment|/* f4 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|5
operator|)
operator|||
comment|/* f5 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|6
operator|)
operator|||
comment|/* f6 */
operator|(
name|myops
index|[
literal|0
index|]
operator|.
name|X_add_number
operator|==
name|OPERAND_FLAG
operator|+
literal|7
operator|)
operator|)
condition|)
comment|/* f7 */
block|{
name|cur_left_kills_right_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Other mvtsys target registers don't kill right                      instruction.  */
name|cur_left_kills_right_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* mvtsys */
block|}
else|else
name|cur_left_kills_right_p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Get a pointer to an entry in the format table.    It must look at all formats for an opcode and use the operands    to choose the correct one.  Return NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|d30v_format
modifier|*
name|find_format
parameter_list|(
name|opcode
parameter_list|,
name|myops
parameter_list|,
name|fsize
parameter_list|,
name|cmp_hack
parameter_list|)
name|struct
name|d30v_opcode
modifier|*
name|opcode
decl_stmt|;
name|expressionS
name|myops
index|[]
decl_stmt|;
name|int
name|fsize
decl_stmt|;
name|int
name|cmp_hack
decl_stmt|;
block|{
name|int
name|numops
decl_stmt|,
name|match
decl_stmt|,
name|index
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|d30v_format
modifier|*
name|fm
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Get all the operands and save them as expressions.  */
name|numops
operator|=
name|get_operands
argument_list|(
name|myops
argument_list|,
name|cmp_hack
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|index
operator|=
name|opcode
operator|->
name|format
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fsize
operator|==
name|FORCE_SHORT
operator|&&
name|index
operator|>=
name|LONG
condition|)
continue|continue;
if|if
condition|(
name|fsize
operator|==
name|FORCE_LONG
operator|&&
name|index
operator|<
name|LONG
condition|)
continue|continue;
name|fm
operator|=
operator|(
expr|struct
name|d30v_format
operator|*
operator|)
operator|&
name|d30v_format_table
index|[
name|index
index|]
expr_stmt|;
name|k
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|fm
operator|->
name|form
operator|==
name|index
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
comment|/* Now check the operands for compatibility.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|match
operator|&&
name|fm
operator|->
name|operands
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|int
name|flags
init|=
name|d30v_operand_table
index|[
name|fm
operator|->
name|operands
index|[
name|j
index|]
index|]
operator|.
name|flags
decl_stmt|;
name|int
name|bits
init|=
name|d30v_operand_table
index|[
name|fm
operator|->
name|operands
index|[
name|j
index|]
index|]
operator|.
name|bits
decl_stmt|;
name|int
name|X_op
init|=
name|myops
index|[
name|j
index|]
operator|.
name|X_op
decl_stmt|;
name|int
name|num
init|=
name|myops
index|[
name|j
index|]
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPERAND_SPECIAL
condition|)
break|break;
elseif|else
if|if
condition|(
name|X_op
operator|==
name|O_illegal
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_REG
condition|)
block|{
if|if
condition|(
name|X_op
operator|!=
name|O_register
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ACC
operator|)
operator|&&
operator|!
operator|(
name|num
operator|&
name|OPERAND_ACC
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|flags
operator|&
name|OPERAND_ACC
operator|)
operator|&&
operator|(
name|num
operator|&
name|OPERAND_ACC
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_FLAG
operator|)
operator|&&
operator|!
operator|(
name|num
operator|&
name|OPERAND_FLAG
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|OPERAND_FLAG
operator||
name|OPERAND_CONTROL
operator|)
operator|)
operator|&&
operator|(
name|num
operator|&
name|OPERAND_FLAG
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_CONTROL
operator|)
operator|&&
operator|!
operator|(
name|num
operator|&
operator|(
name|OPERAND_CONTROL
operator||
name|OPERAND_FLAG
operator|)
operator|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|OPERAND_MINUS
operator|)
operator|&&
operator|(
name|X_op
operator|!=
name|O_absent
operator|||
name|num
operator|!=
name|OPERAND_MINUS
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_PLUS
operator|)
operator|&&
operator|(
name|X_op
operator|!=
name|O_absent
operator|||
name|num
operator|!=
name|OPERAND_PLUS
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATMINUS
operator|)
operator|&&
operator|(
name|X_op
operator|!=
name|O_absent
operator|||
name|num
operator|!=
name|OPERAND_ATMINUS
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATPAR
operator|)
operator|&&
operator|(
name|X_op
operator|!=
name|O_absent
operator|||
name|num
operator|!=
name|OPERAND_ATPAR
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|OPERAND_ATSIGN
operator|)
operator|&&
operator|(
name|X_op
operator|!=
name|O_absent
operator|||
name|num
operator|!=
name|OPERAND_ATSIGN
operator|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|OPERAND_NUM
condition|)
block|{
comment|/* A number can be a constant or symbol expression.  */
comment|/* If we have found a register name, but that name 		     also matches a symbol, then re-parse the name as 		     an expression.  */
if|if
condition|(
name|X_op
operator|==
name|O_register
operator|&&
name|symbol_find
argument_list|(
operator|(
name|char
operator|*
operator|)
name|myops
index|[
name|j
index|]
operator|.
name|X_op_symbol
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|myops
index|[
name|j
index|]
operator|.
name|X_op_symbol
expr_stmt|;
name|expression
argument_list|(
operator|&
name|myops
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Turn an expression into a symbol for later resolution.  */
if|if
condition|(
name|X_op
operator|!=
name|O_absent
operator|&&
name|X_op
operator|!=
name|O_constant
operator|&&
name|X_op
operator|!=
name|O_symbol
operator|&&
name|X_op
operator|!=
name|O_register
operator|&&
name|X_op
operator|!=
name|O_big
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|make_expr_symbol
argument_list|(
operator|&
name|myops
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|myops
index|[
name|j
index|]
operator|.
name|X_op
operator|=
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|myops
index|[
name|j
index|]
operator|.
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|myops
index|[
name|j
index|]
operator|.
name|X_add_number
operator|=
name|num
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fm
operator|->
name|form
operator|>=
name|LONG
condition|)
block|{
comment|/* If we're testing for a LONG format, either fits.  */
if|if
condition|(
name|X_op
operator|!=
name|O_constant
operator|&&
name|X_op
operator|!=
name|O_symbol
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fm
operator|->
name|form
operator|<
name|LONG
operator|&&
operator|(
operator|(
name|fsize
operator|==
name|FORCE_SHORT
operator|&&
name|X_op
operator|==
name|O_symbol
operator|)
operator|||
operator|(
name|fm
operator|->
name|form
operator|==
name|SHORT_D2
operator|&&
name|j
operator|==
literal|0
operator|)
operator|)
condition|)
name|match
operator|=
literal|1
expr_stmt|;
comment|/* This is the tricky part.  Will the constant or symbol 		     fit into the space in the current format?  */
elseif|else
if|if
condition|(
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|check_range
argument_list|(
name|num
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_op
operator|==
name|O_symbol
operator|&&
name|S_IS_DEFINED
argument_list|(
name|myops
index|[
name|j
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|myops
index|[
name|j
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|&&
name|opcode
operator|->
name|reloc_flag
operator|==
name|RELOC_PCREL
condition|)
block|{
comment|/* If the symbol is defined, see if the value will fit 			 into the form we're considering.  */
name|fragS
modifier|*
name|f
decl_stmt|;
name|long
name|value
decl_stmt|;
comment|/* Calculate the current address by running through the 			 previous frags and adding our current offset.  */
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
name|frchain_now
operator|->
name|frch_root
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
name|value
operator|+=
name|f
operator|->
name|fr_fix
operator|+
name|f
operator|->
name|fr_offset
expr_stmt|;
name|value
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|myops
index|[
name|j
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|-
name|value
operator|-
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|check_range
argument_list|(
name|value
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|printf ("through the loop: match=%d\n", match);
endif|#
directive|endif
comment|/* We're only done if the operands matched so far AND there 	     are no more to check.  */
if|if
condition|(
name|match
operator|&&
name|myops
index|[
name|j
index|]
operator|.
name|X_op
operator|==
literal|0
condition|)
block|{
comment|/* Final check - issue a warning if an odd numbered register 		 is used as the first register in an instruction that reads 		 or writes 2 registers.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fm
operator|->
name|operands
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|myops
index|[
name|j
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|&&
operator|(
name|myops
index|[
name|j
index|]
operator|.
name|X_add_number
operator|&
literal|1
operator|)
operator|&&
operator|(
name|d30v_operand_table
index|[
name|fm
operator|->
name|operands
index|[
name|j
index|]
index|]
operator|.
name|flags
operator|&
name|OPERAND_2REG
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Odd numbered register used as target of multi-register instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fm
return|;
block|}
name|fm
operator|=
operator|(
expr|struct
name|d30v_format
operator|*
operator|)
operator|&
name|d30v_format_table
index|[
operator|++
name|k
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("trying another format: i=%d\n", i);
endif|#
directive|endif
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created,    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixp
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|,
name|insn2
decl_stmt|;
name|long
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* We don't support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand      value, and stuff the instruction back again.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
comment|/* Check for a bad .byte directive.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unable to place address of symbol '%s' into a byte"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|value
operator|)
operator|>
literal|0xff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unable to place value %lx into a byte"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
comment|/* Check for a bad .short directive.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unable to place address of symbol '%s' into a short"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|value
operator|)
operator|>
literal|0xffff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unable to place value %lx into a short"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
comment|/* Check for a bad .quad directive.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unable to place address of symbol '%s' into a quad"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_D30V_6
case|:
name|check_size
argument_list|(
name|value
argument_list|,
literal|6
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
name|value
operator|&
literal|0x3F
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_9_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|&
literal|0x7
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|value
operator|+=
literal|4
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_D30V_9_PCREL_R
expr_stmt|;
block|}
name|check_size
argument_list|(
name|value
argument_list|,
literal|9
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|value
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
operator|)
operator|<<
literal|12
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_15
case|:
name|check_size
argument_list|(
name|value
argument_list|,
literal|15
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|3
operator|)
operator|&
literal|0xFFF
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_15_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|&
literal|0x7
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|value
operator|+=
literal|4
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_D30V_15_PCREL_R
expr_stmt|;
block|}
name|check_size
argument_list|(
name|value
argument_list|,
literal|15
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|3
operator|)
operator|&
literal|0xFFF
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_21
case|:
name|check_size
argument_list|(
name|value
argument_list|,
literal|21
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|3
operator|)
operator|&
literal|0x3FFFF
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_21_PCREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|&
literal|0x7
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|value
operator|+=
literal|4
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_D30V_21_PCREL_R
expr_stmt|;
block|}
name|check_size
argument_list|(
name|value
argument_list|,
literal|21
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|3
operator|)
operator|&
literal|0x3FFFF
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_32
case|:
name|insn2
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|26
operator|)
operator|&
literal|0x3F
expr_stmt|;
comment|/* Top 6 bits.  */
name|insn2
operator||=
operator|(
operator|(
name|value
operator|&
literal|0x03FC0000
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Next 8 bits.  */
name|insn2
operator||=
name|value
operator|&
literal|0x0003FFFF
expr_stmt|;
comment|/* Bottom 18 bits.  */
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn2
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_D30V_32_PCREL
case|:
name|insn2
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|>>
literal|26
operator|)
operator|&
literal|0x3F
expr_stmt|;
comment|/* Top 6 bits.  */
name|insn2
operator||=
operator|(
operator|(
name|value
operator|&
literal|0x03FC0000
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Next 8 bits.  */
name|insn2
operator||=
name|value
operator|&
literal|0x0003FFFF
expr_stmt|;
comment|/* Bottom 18 bits.  */
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn2
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"line %d: unknown relocation type: 0x%x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after the assembler has finished parsing the input file or    after a label is defined.  Because the D30V assembler sometimes    saves short instructions to see if it can package them with the    next instruction, there may be a short instruction that still needs    written.  */
end_comment

begin_function
name|int
name|d30v_cleanup
parameter_list|(
name|use_sequential
parameter_list|)
name|int
name|use_sequential
decl_stmt|;
block|{
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
if|if
condition|(
name|prev_insn
operator|!=
operator|-
literal|1
condition|)
block|{
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
name|subseg_set
argument_list|(
name|prev_seg
argument_list|,
name|prev_subseg
argument_list|)
expr_stmt|;
name|write_1_short
argument_list|(
operator|&
name|prev_opcode
argument_list|,
operator|(
name|long
operator|)
name|prev_insn
argument_list|,
name|fixups
operator|->
name|next
argument_list|,
name|use_sequential
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|use_sequential
condition|)
name|prev_mul32_p
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|d30v_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Return 'nbytes' of chars here.  */
name|long
name|long
name|value
decl_stmt|;
comment|/* The value of the bits.  */
name|int
name|n
decl_stmt|;
comment|/* Number of bytes in the output.  */
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|buf
index|[
name|n
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called at the start of every line.  It checks to    see if the first character is a '.', which indicates the start of a    pseudo-op.  If it is, then write out any unwritten instructions.  */
end_comment

begin_function
name|void
name|d30v_start_line
parameter_list|()
block|{
name|char
modifier|*
name|c
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'.'
condition|)
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_size
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|long
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|~
name|value
expr_stmt|;
else|else
name|tmp
operator|=
name|value
expr_stmt|;
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|max
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"value too large to fit in %d bits"
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* d30v_frob_label() is called when after a label is recognized.  */
end_comment

begin_function
name|void
name|d30v_frob_label
parameter_list|(
name|lab
parameter_list|)
name|symbolS
modifier|*
name|lab
decl_stmt|;
block|{
comment|/* Emit any pending instructions.  */
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Update the label's address with the current output pointer.  */
name|symbol_set_frag
argument_list|(
name|lab
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|lab
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Record this label for future adjustment after we find out what      kind of data it references, and the required alignment therewith.  */
name|d30v_last_label
operator|=
name|lab
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook into cons for capturing alignment changes.  */
end_comment

begin_function
name|void
name|d30v_cons_align
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|log_size
decl_stmt|;
name|log_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|size
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|log_size
expr_stmt|;
if|if
condition|(
name|d30v_current_align
operator|<
name|log_size
condition|)
name|d30v_align
argument_list|(
name|log_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d30v_current_align
operator|>
name|log_size
condition|)
name|d30v_current_align
operator|=
name|log_size
expr_stmt|;
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called internally to handle all alignment needs.  This takes care    of eliding calls to frag_align if'n the cached current alignment    says we've already got it, as well as taking care of the auto-aligning    labels wrt code.  */
end_comment

begin_function
specifier|static
name|void
name|d30v_align
parameter_list|(
name|n
parameter_list|,
name|pfill
parameter_list|,
name|label
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|pfill
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
block|{
comment|/* The front end is prone to changing segments out from under us      temporarily when -g is in effect.  */
name|int
name|switched_seg_p
init|=
operator|(
name|d30v_current_align_seg
operator|!=
name|now_seg
operator|)
decl_stmt|;
comment|/* Do not assume that if 'd30v_current_align>= n' and      '! switched_seg_p' that it is safe to avoid performing      this alignment request.  The alignment of the current frag      can be changed under our feet, for example by a .ascii      directive in the source code.  cf testsuite/gas/d30v/reloc.s  */
name|d30v_cleanup
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfill
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
specifier|const
name|nop
index|[
literal|4
index|]
init|=
block|{
literal|0x00
block|,
literal|0xf0
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* First, make sure we're on a four-byte boundary, in case 	     someone has been putting .byte values the text section.  */
if|if
condition|(
name|d30v_current_align
operator|<
literal|2
operator|||
name|switched_seg_p
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|nop
argument_list|,
sizeof|sizeof
name|nop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
operator|*
name|pfill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|switched_seg_p
condition|)
name|d30v_current_align
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|label_seen
init|=
name|FALSE
decl_stmt|;
name|struct
name|frag
modifier|*
name|old_frag
decl_stmt|;
name|valueT
name|old_value
decl_stmt|;
name|valueT
name|new_value
decl_stmt|;
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|old_frag
operator|=
name|symbol_get_frag
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|S_GET_VALUE
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|new_value
operator|=
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* It is possible to have more than one label at a particular 	 address, especially if debugging is enabled, so we must 	 take care to adjust all the labels at this address in this 	 fragment.  To save time we search from the end of the symbol 	 list, backwards, since the symbols we are interested in are 	 almost certainly the ones that were most recently added. 	 Also to save time we stop searching once we have seen at least 	 one matching label, and we encounter a label that is no longer 	 in the target fragment.  Note, this search is guaranteed to 	 find at least one match when sym == label, so no special case 	 code is necessary.  */
for|for
control|(
name|sym
operator|=
name|symbol_lastP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_previous
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|==
name|old_frag
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
name|old_value
condition|)
block|{
name|label_seen
operator|=
name|TRUE
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|label_seen
operator|&&
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|!=
name|old_frag
condition|)
break|break;
block|}
block|}
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .align pseudo-op.  This aligns to a power of two.  We    hook here to latch the current alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_d30v_align
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
name|char
name|fill
decl_stmt|,
modifier|*
name|pfill
init|=
name|NULL
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Alignment too large: %d assumed"
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Alignment negative: 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|pfill
operator|=
operator|&
name|fill
expr_stmt|;
block|}
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
name|d30v_align
argument_list|(
name|align
argument_list|,
name|pfill
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .text pseudo-op.  This is like the usual one, but it    clears the saved last label and resets known alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_d30v_text
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|s_text
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
name|d30v_current_align
operator|=
literal|0
expr_stmt|;
name|d30v_current_align_seg
operator|=
name|now_seg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .data pseudo-op.  This is like the usual one, but it    clears the saved last label and resets known alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_d30v_data
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|s_data
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
name|d30v_current_align
operator|=
literal|0
expr_stmt|;
name|d30v_current_align_seg
operator|=
name|now_seg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .section pseudo-op.  This is like the usual one, but it    clears the saved last label and resets known alignment.  */
end_comment

begin_function
specifier|static
name|void
name|s_d30v_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
name|d30v_last_label
operator|=
name|NULL
expr_stmt|;
name|d30v_current_align
operator|=
literal|0
expr_stmt|;
name|d30v_current_align_seg
operator|=
name|now_seg
expr_stmt|;
block|}
end_function

end_unit

