begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-xtensa.c -- Assemble Xtensa instructions.    Copyright 2003 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,     MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"tc-xtensa.h"
end_include

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-relax.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-istack.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|uint32
end_ifndef

begin_define
define|#
directive|define
name|uint32
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|int32
end_ifndef

begin_define
define|#
directive|define
name|int32
value|signed int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Notes:     There are 3 forms for instructions,    1) the MEMORY format -- this is the encoding 2 or 3 byte instruction    2) the TInsn -- handles instructions/labels and literals;       all operands are assumed to be expressions    3) the IStack -- a stack of TInsn.  this allows us to        reason about the generated expansion instructions       Naming conventions (used somewhat inconsistently):       The xtensa_ functions are exported       The xg_ functions are internal     We also have a couple of different extensibility mechanisms.    1) The idiom replacement:       This is used when a line is first parsed to       replace an instruction pattern with another instruction       It is currently limited to replacements of instructions       with constant operands.    2) The xtensa-relax.c mechanism that has stronger instruction       replacement patterns.  When an instruction's immediate field       does not fit the next instruction sequence is attempted.       In addition, "narrow" opcodes are supported this way.  */
end_comment

begin_comment
comment|/* Define characters with special meanings to GAS.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to indicate whether the hardware supports the density option.    If not, enabling density instructions (via directives or --density flag)    is illegal.  */
end_comment

begin_if
if|#
directive|if
name|STATIC_LIBISA
end_if

begin_decl_stmt
name|bfd_boolean
name|density_supported
init|=
name|XCHAL_HAVE_DENSITY
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|bfd_boolean
name|density_supported
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XTENSA_FETCH_WIDTH
value|4
end_define

begin_comment
comment|/* Flags for properties of the last instruction in a segment.  */
end_comment

begin_define
define|#
directive|define
name|FLAG_IS_A0_WRITER
value|0x1
end_define

begin_define
define|#
directive|define
name|FLAG_IS_BAD_LOOPEND
value|0x2
end_define

begin_comment
comment|/* We define a special segment names ".literal" to place literals    into.  The .fini and .init sections are special because they    contain code that is moved together by the linker.  We give them    their own special .fini.literal and .init.literal sections.  */
end_comment

begin_define
define|#
directive|define
name|LITERAL_SECTION_NAME
value|xtensa_section_rename (".literal")
end_define

begin_define
define|#
directive|define
name|FINI_SECTION_NAME
value|xtensa_section_rename (".fini")
end_define

begin_define
define|#
directive|define
name|INIT_SECTION_NAME
value|xtensa_section_rename (".init")
end_define

begin_define
define|#
directive|define
name|FINI_LITERAL_SECTION_NAME
value|xtensa_section_rename (".fini.literal")
end_define

begin_define
define|#
directive|define
name|INIT_LITERAL_SECTION_NAME
value|xtensa_section_rename (".init.literal")
end_define

begin_comment
comment|/* This type is used for the directive_stack to keep track of the     state of the literal collection pools.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lit_state_struct
block|{
specifier|const
name|char
modifier|*
name|lit_seg_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|init_lit_seg_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|fini_lit_seg_name
decl_stmt|;
name|segT
name|lit_seg
decl_stmt|;
name|segT
name|init_lit_seg
decl_stmt|;
name|segT
name|fini_lit_seg
decl_stmt|;
block|}
name|lit_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|lit_state
name|default_lit_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep lists of literal segments.  The seg_list type is the node    for such a list.  The *_literal_head locals are the heads of the    various lists.  All of these lists have a dummy node at the start.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|seg_list_struct
block|{
name|struct
name|seg_list_struct
modifier|*
name|next
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|}
name|seg_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|seg_list
name|literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
modifier|*
name|literal_head
init|=
operator|&
name|literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
name|init_literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
modifier|*
name|init_literal_head
init|=
operator|&
name|init_literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
name|fini_literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
modifier|*
name|fini_literal_head
init|=
operator|&
name|fini_literal_head_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lists of symbols.  We keep a list of symbols that label the current    instruction, so that we can adjust the symbols when inserting alignment    for various instructions.  We also keep a list of all the symbols on    literals, so that we can fix up those symbols when the literals are    later moved into the text sections.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sym_list_struct
block|{
name|struct
name|sym_list_struct
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|}
name|sym_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|free_insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|saved_insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|literal_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global flag to indicate when we are emitting literals.  */
end_comment

begin_decl_stmt
name|int
name|generating_literals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for saving the current state before emitting literals.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|emit_state_struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|now_seg
decl_stmt|;
name|subsegT
name|now_subseg
decl_stmt|;
name|int
name|generating_literals
decl_stmt|;
block|}
name|emit_state
typedef|;
end_typedef

begin_comment
comment|/* Directives.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|directive_none
init|=
literal|0
block|,
name|directive_literal
block|,
name|directive_density
block|,
name|directive_generics
block|,
name|directive_relax
block|,
name|directive_freeregs
block|,
name|directive_longcalls
block|,
name|directive_literal_prefix
block|}
name|directiveE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|can_be_negated
decl_stmt|;
block|}
name|directive_infoS
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|directive_infoS
name|directive_info
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|FALSE
block|}
block|,
block|{
literal|"literal"
block|,
name|FALSE
block|}
block|,
block|{
literal|"density"
block|,
name|TRUE
block|}
block|,
block|{
literal|"generics"
block|,
name|TRUE
block|}
block|,
block|{
literal|"relax"
block|,
name|TRUE
block|}
block|,
block|{
literal|"freeregs"
block|,
name|FALSE
block|}
block|,
block|{
literal|"longcalls"
block|,
name|TRUE
block|}
block|,
block|{
literal|"literal_prefix"
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|directive_state
index|[]
init|=
block|{
name|FALSE
block|,
comment|/* none */
name|FALSE
block|,
comment|/* literal */
if|#
directive|if
name|STATIC_LIBISA
operator|&&
operator|!
name|XCHAL_HAVE_DENSITY
name|FALSE
block|,
comment|/* density */
else|#
directive|else
name|TRUE
block|,
comment|/* density */
endif|#
directive|endif
name|TRUE
block|,
comment|/* generics */
name|TRUE
block|,
comment|/* relax */
name|FALSE
block|,
comment|/* freeregs */
name|FALSE
block|,
comment|/* longcalls */
name|FALSE
comment|/* literal_prefix */
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|xtensa_relax_statesE
block|{
name|RELAX_ALIGN_NEXT_OPCODE
block|,
comment|/* Use the first opcode of the next fragment to determine the      alignment requirements.  This is ONLY used for LOOPS      currently.  */
name|RELAX_DESIRE_ALIGN_IF_TARGET
block|,
comment|/* These are placed in front of labels.  They will all be converted      to RELAX_DESIRE_ALIGN / RELAX_LOOP_END or rs_fill of 0 before      relaxation begins.  */
name|RELAX_ADD_NOP_IF_A0_B_RETW
block|,
comment|/* These are placed in front of conditional branches.  It will be      turned into a NOP (using a1) if the branch is immediately      followed by a RETW or RETW.N.  Otherwise it will be turned into      an rs_fill of 0 before relaxation begins.  */
name|RELAX_ADD_NOP_IF_PRE_LOOP_END
block|,
comment|/* These are placed after JX instructions.  It will be turned into a      NOP if there is one instruction before a loop end label.      Otherwise it will be turned into an rs_fill of 0 before      relaxation begins.  This is used to avoid a hardware TIE      interlock issue prior to T1040.  */
name|RELAX_ADD_NOP_IF_SHORT_LOOP
block|,
comment|/* These are placed after LOOP instructions.  It will be turned into      a NOP when: (1) there are less than 3 instructions in the loop;      we place 2 of these in a row to add up to 2 NOPS in short loops;      or (2) The instructions in the loop do not include a branch or      jump.  Otherwise it will be turned into an rs_fill of 0 before      relaxation begins.  This is used to avoid hardware bug      PR3830.  */
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
block|,
comment|/* These are placed after LOOP instructions.  It will be turned into      a NOP if there are less than 12 bytes to the end of some other      loop's end.  Otherwise it will be turned into an rs_fill of 0      before relaxation begins.  This is used to avoid hardware bug      PR3830.  */
name|RELAX_DESIRE_ALIGN
block|,
comment|/* The next fragment like its first instruction to NOT cross a      4-byte boundary.  */
name|RELAX_LOOP_END
block|,
comment|/* This will be turned into a NOP or NOP.N if the previous      instruction is expanded to negate a loop.  */
name|RELAX_LOOP_END_ADD_NOP
block|,
comment|/* When the code density option is available, this will generate a      NOP.N marked RELAX_NARROW.  Otherwise, it will create an rs_fill      fragment with a NOP in it.  */
name|RELAX_LITERAL
block|,
comment|/* Another fragment could generate an expansion here but has not yet.  */
name|RELAX_LITERAL_NR
block|,
comment|/* Expansion has been generated by an instruction that generates a      literal.  However, the stretch has NOT been reported yet in this      fragment.  */
name|RELAX_LITERAL_FINAL
block|,
comment|/* Expansion has been generated by an instruction that generates a      literal.  */
name|RELAX_LITERAL_POOL_BEGIN
block|,
name|RELAX_LITERAL_POOL_END
block|,
comment|/* Technically these are not relaxations at all, but mark a location      to store literals later.  Note that fr_var stores the frchain for      BEGIN frags and fr_var stores now_seg for END frags.  */
name|RELAX_NARROW
block|,
comment|/* The last instruction in this fragment (at->fr_opcode) can be      freely replaced with a single wider instruction if a future      alignment desires or needs it.  */
name|RELAX_IMMED
block|,
comment|/* The last instruction in this fragment (at->fr_opcode) contains      the value defined by fr_symbol (fr_offset = 0).  If the value      does not fit, use the specified expansion.  This is similar to      "NARROW", except that these may not be expanded in order to align      code.  */
name|RELAX_IMMED_STEP1
block|,
comment|/* The last instruction in this fragment (at->fr_opcode) contains a      literal.  It has already been expanded at least 1 step.  */
name|RELAX_IMMED_STEP2
comment|/* The last instruction in this fragment (at->fr_opcode) contains a      literal.  It has already been expanded at least 2 steps.  */
block|}
enum|;
end_enum

begin_comment
comment|/* This is used as a stopper to bound the number of steps that    can be taken.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_IMMED_MAXSTEPS
value|(RELAX_IMMED_STEP2 - RELAX_IMMED)
end_define

begin_typedef
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|frag_predicate
function_decl|)
parameter_list|(
specifier|const
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Directive functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|use_generics
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|use_longcalls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|code_density_available
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|can_relax
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|directive_push
name|PARAMS
argument_list|(
operator|(
name|directiveE
operator|,
name|bfd_boolean
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|directive_pop
name|PARAMS
argument_list|(
operator|(
name|directiveE
operator|*
operator|,
name|bfd_boolean
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
specifier|const
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|directive_balance
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|inside_directive
name|PARAMS
argument_list|(
operator|(
name|directiveE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_directive
name|PARAMS
argument_list|(
operator|(
name|directiveE
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_begin_directive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_end_directive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_literal_prefix
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_literal_position
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_literal_pseudo
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing and Idiom Translation Functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|expression_end
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|tc_get_register
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expression_maybe_register
name|PARAMS
argument_list|(
operator|(
name|xtensa_operand
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tokenize_arguments
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|parse_arguments
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_translate_idioms
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_translate_sysreg_op
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_reverse_shift_count
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_arg_is_constant
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|offsetT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_replace_opname
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_check_num_args
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for dealing with the Xtensa ISA.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|operand_is_immed
name|PARAMS
argument_list|(
operator|(
name|xtensa_operand
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|operand_is_pcrel_label
name|PARAMS
argument_list|(
operator|(
name|xtensa_operand
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_relaxable_immed
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|get_opcode_from_buf
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_entry_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_loop_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_the_loop_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_jx_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_windowed_return_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_conditional_branch_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_branch_or_jump_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|opnum_to_reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_to_opnum
name|PARAMS
argument_list|(
operator|(
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_insnbuf_set_operand
name|PARAMS
argument_list|(
operator|(
name|xtensa_insnbuf
operator|,
name|xtensa_opcode
operator|,
name|xtensa_operand
operator|,
name|int32
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32
name|xtensa_insnbuf_get_operand
name|PARAMS
argument_list|(
operator|(
name|xtensa_insnbuf
operator|,
name|xtensa_opcode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_insnbuf_set_immediate_field
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|,
name|xtensa_insnbuf
operator|,
name|int32
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_negatable_branch
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various Other Internal Functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_unique_insn_expansion
name|PARAMS
argument_list|(
operator|(
name|TransitionRule
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_get_insn_size
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_get_build_instr_size
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_is_narrow_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_is_single_relaxable_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_get_max_narrow_insn_size
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_get_max_insn_widen_size
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_get_max_insn_widen_literal_size
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_is_relaxable_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|get_special_literal_symbol
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|get_special_label_symbol
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_build_to_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|TInsn
operator|*
operator|,
name|BuildInstr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_build_to_stack
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|,
name|TInsn
operator|*
operator|,
name|BuildInstr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_expand_to_stack
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|,
name|TInsn
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_expand_narrow
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_immeds_fit
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_symbolic_immeds_fit
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|,
name|segT
operator|,
name|fragS
operator|*
operator|,
name|offsetT
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_check_operand
name|PARAMS
argument_list|(
operator|(
name|int32
operator|,
name|xtensa_operand
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_dnrange
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|symbolS
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xg_assembly_relax
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|,
name|TInsn
operator|*
operator|,
name|segT
operator|,
name|fragS
operator|*
operator|,
name|offsetT
operator|,
name|int
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_force_frag_space
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_finish_frag
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|xtensa_relax_statesE
operator|,
name|int
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_branch_jmp_to_next
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_add_branch_and_loop_targets
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_instruction_matches_rule
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|TransitionRule
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TransitionRule
modifier|*
name|xg_instruction_match
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_build_token_insn
name|PARAMS
argument_list|(
operator|(
name|BuildInstr
operator|*
operator|,
name|TInsn
operator|*
operator|,
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_simplify_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_expand_assembly_insn
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|,
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|xg_assemble_literal
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_assemble_literal_space
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|xtensa_create_literal_symbol
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_add_literal_sym
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_add_insn_label
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_clear_insn_labels
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_is_linkonce_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_emit_insn
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_emit_insn_to_buf
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|char
operator|*
operator|,
name|fragS
operator|*
operator|,
name|offsetT
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xg_add_opcode_fix
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|,
name|int
operator|,
name|expressionS
operator|*
operator|,
name|fragS
operator|*
operator|,
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_resolve_literals
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_resolve_labels
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xg_assemble_tokens
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_register_writer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_bad_loopend_opcode
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_unaligned_label
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|next_non_empty_frag
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|next_frag_opcode
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_next_frag_nop_state
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|next_frag_is_branch_target
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|next_frag_is_loop_target
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|next_frag_pre_opcode_bytes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_next_frag_target
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|,
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_mark_literal_pool_location
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_move_labels
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|valueT
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assemble_nop
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|get_expanded_loop_offset
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|get_literal_pool_location
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_literal_pool_location
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helpers for xtensa_end().  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|xtensa_cleanup_align_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_fix_target_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|frag_can_negate_branch
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_fix_a0_b_retw_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|next_instrs_are_b_retw
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_fix_b_j_loop_end_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|next_instr_is_loop_end
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_fix_close_loop_end_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|min_bytes_to_other_loop_end
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|fragS
operator|*
operator|,
name|offsetT
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|unrelaxed_frag_min_size
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_fix_short_loop_frags
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|count_insns_to_loop_end
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|bfd_boolean
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|unrelaxed_frag_min_insn_count
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|branch_before_loop_end
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|unrelaxed_frag_has_b_j
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_sanity_check
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_empty_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_local_forward_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alignment Functions.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|get_text_align_power
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|get_text_align_max_fill_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|bfd_boolean
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|get_text_align_fill_size
name|PARAMS
argument_list|(
operator|(
name|addressT
operator|,
name|int
operator|,
name|int
operator|,
name|bfd_boolean
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|get_text_align_nop_count
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|get_text_align_nth_nop_size
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|size_t
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|get_noop_aligned_address
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|addressT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|addressT
name|get_widen_aligned_address
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|addressT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helpers for xtensa_relax_frag().  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|relax_frag_text_align
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|relax_frag_add_nop
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|relax_frag_narrow
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|future_alignment_required
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|relax_frag_immed
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helpers for md_convert_frag().  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|convert_frag_align_next_opcode
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_frag_narrow
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_frag_immed
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fixS
modifier|*
name|fix_new_exp_in_seg
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|subsegT
operator|,
name|fragS
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_frag_immed_finish_loop
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|,
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|offsetT
name|get_expression_value
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags for the Last Instruction in Each Subsegment.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|get_last_insn_flags
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|subsegT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_last_insn_flags
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|subsegT
operator|,
name|unsigned
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Segment list functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|xtensa_remove_section
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_insert_section
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_move_seg_list_to_beginning
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_move_literals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_literal_frags
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_reorder_seg_list
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_reorder_segments
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|get_last_sec
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_switch_to_literal_fragment
name|PARAMS
argument_list|(
operator|(
name|emit_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_switch_section_emit_state
name|PARAMS
argument_list|(
operator|(
name|emit_state
operator|*
operator|,
name|segT
operator|,
name|subsegT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtensa_restore_emit_state
name|PARAMS
argument_list|(
operator|(
name|emit_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cache_literal_section
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|segT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|retrieve_literal_seg
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|seg_present
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_seg_list
name|PARAMS
argument_list|(
operator|(
name|seg_list
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Property Table (e.g., ".xt.insn" and ".xt.lit") Functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|xtensa_create_property_segments
name|PARAMS
argument_list|(
operator|(
name|frag_predicate
operator|,
specifier|const
name|char
operator|*
operator|,
name|xt_section_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segment_info_type
modifier|*
name|retrieve_segment_info
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|retrieve_xtensa_section
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|section_has_property
name|PARAMS
argument_list|(
operator|(
name|segT
name|sec
operator|,
name|frag_predicate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_xt_block_frags
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|segT
operator|,
name|xtensa_block_info
operator|*
operator|*
operator|,
name|frag_predicate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_frag_is_literal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_frag_is_insn
name|PARAMS
argument_list|(
operator|(
specifier|const
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Import from elf32-xtensa.c in BFD library.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xtensa_get_property_section_name
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TInsn and IStack functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|tinsn_has_symbolic_operands
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|tinsn_has_invalid_symbolic_operands
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|tinsn_has_complex_operands
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|tinsn_to_insnbuf
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|xtensa_insnbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|tinsn_check_arguments
name|PARAMS
argument_list|(
operator|(
specifier|const
name|TInsn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tinsn_from_chars
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tinsn_immed_from_frag
name|PARAMS
argument_list|(
operator|(
name|TInsn
operator|*
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_num_stack_text_bytes
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_num_stack_literal_bytes
name|PARAMS
argument_list|(
operator|(
name|IStack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expression Utilities.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|expr_is_const
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|offsetT
name|get_expr_const
name|PARAMS
argument_list|(
operator|(
specifier|const
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_expr_const
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_expr_symbol_offset
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|symbolS
operator|*
operator|,
name|offsetT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|expr_is_equal
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_expr
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
specifier|const
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|build_section_rename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_section_rename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISA imported from bfd.  */
end_comment

begin_decl_stmt
specifier|extern
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_addi_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_addmi_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call0_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call4_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call8_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call12_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx0_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx4_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx8_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx12_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_entry_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_isync_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_j_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_jx_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loop_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loopnez_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loopgtz_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_nop_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_or_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_ret_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_ret_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_retw_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_retw_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_rsr_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_waiti_opcode
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Command-line Options.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|use_literal_section
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|align_targets
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|align_only_targets
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|software_a0_b_retw_interlock
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|has_a0_b_retw
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_a0_b_retw
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|software_avoid_b_j_loop_end
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_b_j_loop_end
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|maybe_has_b_j_loop_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|software_avoid_short_loop
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_short_loop
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|maybe_has_short_loop
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|software_avoid_close_loop_end
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_close_loop_end
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|maybe_has_close_loop_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When avoid_short_loops is true, all loops with early exits must    have at least 3 instructions.  avoid_all_short_loops is a modifier    to the avoid_short_loop flag.  In addition to the avoid_short_loop    actions, all straightline loopgtz and loopnez must have at least 3    instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|software_avoid_all_short_loops
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_all_short_loops
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is on a per-instruction basis.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|specific_opcode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|option_density
init|=
name|OPTION_MD_BASE
block|,
name|option_no_density
block|,
name|option_relax
block|,
name|option_no_relax
block|,
name|option_generics
block|,
name|option_no_generics
block|,
name|option_text_section_literals
block|,
name|option_no_text_section_literals
block|,
name|option_align_targets
block|,
name|option_no_align_targets
block|,
name|option_align_only_targets
block|,
name|option_no_align_only_targets
block|,
name|option_longcalls
block|,
name|option_no_longcalls
block|,
name|option_workaround_a0_b_retw
block|,
name|option_no_workaround_a0_b_retw
block|,
name|option_workaround_b_j_loop_end
block|,
name|option_no_workaround_b_j_loop_end
block|,
name|option_workaround_short_loop
block|,
name|option_no_workaround_short_loop
block|,
name|option_workaround_all_short_loops
block|,
name|option_no_workaround_all_short_loops
block|,
name|option_workaround_close_loop_end
block|,
name|option_no_workaround_close_loop_end
block|,
name|option_no_workarounds
block|,
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
name|option_literal_section_name
block|,
name|option_text_section_name
block|,
name|option_data_section_name
block|,
name|option_bss_section_name
block|,
name|option_rename_section_name
block|,
endif|#
directive|endif
name|option_eb
block|,
name|option_el
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"density"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_density
block|}
block|,
block|{
literal|"no-density"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_density
block|}
block|,
comment|/* At least as early as alameda, --[no-]relax didn't work as      documented, so as of albany, --[no-]relax is equivalent to      --[no-]generics.  Both of these will be deprecated in      BearValley.  */
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_generics
block|}
block|,
block|{
literal|"no-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_generics
block|}
block|,
block|{
literal|"generics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_generics
block|}
block|,
block|{
literal|"no-generics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_generics
block|}
block|,
block|{
literal|"text-section-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_text_section_literals
block|}
block|,
block|{
literal|"no-text-section-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_text_section_literals
block|}
block|,
comment|/* This option was changed from -align-target to -target-align      because it conflicted with the "-al" option.  */
block|{
literal|"target-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_align_targets
block|}
block|,
block|{
literal|"no-target-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_align_targets
block|}
block|,
if|#
directive|if
literal|0
comment|/* This option  should do a better job aligning targets because      it will only attempt to align targets that are the target of a       branch.  */
block|{ "target-align-only", no_argument, NULL, option_align_only_targets },    { "no-target-align-only", no_argument, NULL, option_no_align_only_targets },
endif|#
directive|endif
comment|/* 0 */
block|{
literal|"longcalls"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_longcalls
block|}
block|,
block|{
literal|"no-longcalls"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_longcalls
block|}
block|,
block|{
literal|"no-workaround-a0-b-retw"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_a0_b_retw
block|}
block|,
block|{
literal|"workaround-a0-b-retw"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_a0_b_retw
block|}
block|,
block|{
literal|"no-workaround-b-j-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_b_j_loop_end
block|}
block|,
block|{
literal|"workaround-b-j-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_b_j_loop_end
block|}
block|,
block|{
literal|"no-workaround-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_short_loop
block|}
block|,
block|{
literal|"workaround-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_short_loop
block|}
block|,
block|{
literal|"no-workaround-all-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_all_short_loops
block|}
block|,
block|{
literal|"workaround-all-short-loop"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_all_short_loops
block|}
block|,
block|{
literal|"no-workaround-close-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_close_loop_end
block|}
block|,
block|{
literal|"workaround-close-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_close_loop_end
block|}
block|,
block|{
literal|"no-workarounds"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workarounds
block|}
block|,
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
block|{
literal|"literal-section-name"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_literal_section_name
block|}
block|,
block|{
literal|"text-section-name"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_text_section_name
block|}
block|,
block|{
literal|"data-section-name"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_data_section_name
block|}
block|,
block|{
literal|"rename-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_rename_section_name
block|}
block|,
block|{
literal|"bss-section-name"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_bss_section_name
block|}
block|,
endif|#
directive|endif
comment|/* XTENSA_SECTION_RENAME */
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
name|md_longopts
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|option_density
case|:
if|if
condition|(
operator|!
name|density_supported
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'--density' option not supported in this Xtensa "
literal|"configuration"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|directive_state
index|[
name|directive_density
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_density
case|:
name|directive_state
index|[
name|directive_density
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_generics
case|:
name|directive_state
index|[
name|directive_generics
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_generics
case|:
name|directive_state
index|[
name|directive_generics
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_longcalls
case|:
name|directive_state
index|[
name|directive_longcalls
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_longcalls
case|:
name|directive_state
index|[
name|directive_longcalls
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_text_section_literals
case|:
name|use_literal_section
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_text_section_literals
case|:
name|use_literal_section
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_a0_b_retw
case|:
name|workaround_a0_b_retw
operator|=
name|TRUE
expr_stmt|;
name|software_a0_b_retw_interlock
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_a0_b_retw
case|:
name|workaround_a0_b_retw
operator|=
name|FALSE
expr_stmt|;
name|software_a0_b_retw_interlock
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_b_j_loop_end
case|:
name|workaround_b_j_loop_end
operator|=
name|TRUE
expr_stmt|;
name|software_avoid_b_j_loop_end
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_b_j_loop_end
case|:
name|workaround_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_short_loop
case|:
name|workaround_short_loop
operator|=
name|TRUE
expr_stmt|;
name|software_avoid_short_loop
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_short_loop
case|:
name|workaround_short_loop
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_short_loop
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_all_short_loops
case|:
name|workaround_all_short_loops
operator|=
name|TRUE
expr_stmt|;
name|software_avoid_all_short_loops
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_all_short_loops
case|:
name|workaround_all_short_loops
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_all_short_loops
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_close_loop_end
case|:
name|workaround_close_loop_end
operator|=
name|TRUE
expr_stmt|;
name|software_avoid_close_loop_end
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_close_loop_end
case|:
name|workaround_close_loop_end
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_close_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workarounds
case|:
name|workaround_a0_b_retw
operator|=
name|FALSE
expr_stmt|;
name|software_a0_b_retw_interlock
operator|=
name|FALSE
expr_stmt|;
name|workaround_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
name|workaround_short_loop
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_short_loop
operator|=
name|FALSE
expr_stmt|;
name|workaround_all_short_loops
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_all_short_loops
operator|=
name|FALSE
expr_stmt|;
name|workaround_close_loop_end
operator|=
name|FALSE
expr_stmt|;
name|software_avoid_close_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_align_targets
case|:
name|align_targets
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_align_targets
case|:
name|align_targets
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_align_only_targets
case|:
name|align_only_targets
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_align_only_targets
case|:
name|align_only_targets
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
case|case
name|option_literal_section_name
case|:
name|add_section_rename
argument_list|(
literal|".literal"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"'--literal-section-name' is deprecated; "
literal|"use '--rename-section .literal=NEWNAME'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_text_section_name
case|:
name|add_section_rename
argument_list|(
literal|".text"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"'--text-section-name' is deprecated; "
literal|"use '--rename-section .text=NEWNAME'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_data_section_name
case|:
name|add_section_rename
argument_list|(
literal|".data"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"'--data-section-name' is deprecated; "
literal|"use '--rename-section .data=NEWNAME'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_bss_section_name
case|:
name|add_section_rename
argument_list|(
literal|".bss"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"'--bss-section-name' is deprecated; "
literal|"use '--rename-section .bss=NEWNAME'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_rename_section_name
case|:
name|build_section_rename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* XTENSA_SECTION_RENAME */
case|case
literal|'Q'
case|:
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section          should be emitted or not.  FIXME: Not implemented.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\nXtensa options:\n"
literal|"--[no-]density          [Do not] emit density instructions\n"
literal|"--[no-]relax            [Do not] perform branch relaxation\n"
literal|"--[no-]generics         [Do not] transform instructions\n"
literal|"--[no-]longcalls        [Do not] emit 32-bit call sequences\n"
literal|"--[no-]target-align     [Do not] try to align branch targets\n"
literal|"--[no-]text-section-literals\n"
literal|"                        [Do not] put literals in the text section\n"
literal|"--no-workarounds        Do not use any Xtensa workarounds\n"
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
literal|"--rename-section old=new(:old1=new1)*\n"
literal|"                        Rename section 'old' to 'new'\n"
literal|"\nThe following Xtensa options are deprecated\n"
literal|"--literal-section-name  Name of literal section (default .literal)\n"
literal|"--text-section-name     Name of text section (default .text)\n"
literal|"--data-section-name     Name of data section (default .data)\n"
literal|"--bss-section-name      Name of bss section (default .bss)\n"
endif|#
directive|endif
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Directive data and functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|state_stackS_struct
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
name|bfd_boolean
name|old_state
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|void
modifier|*
name|datum
decl_stmt|;
name|struct
name|state_stackS_struct
modifier|*
name|prev
decl_stmt|;
block|}
name|state_stackS
typedef|;
end_typedef

begin_decl_stmt
name|state_stackS
modifier|*
name|directive_state_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0) */
block|{
literal|"literal_position"
block|,
name|xtensa_literal_position
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* formerly used for STABS debugging */
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"begin"
block|,
name|xtensa_begin_directive
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|xtensa_end_directive
block|,
literal|0
block|}
block|,
block|{
literal|"literal"
block|,
name|xtensa_literal_pseudo
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_boolean
name|use_generics
parameter_list|()
block|{
return|return
name|directive_state
index|[
name|directive_generics
index|]
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|use_longcalls
parameter_list|()
block|{
return|return
name|directive_state
index|[
name|directive_longcalls
index|]
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|code_density_available
parameter_list|()
block|{
return|return
name|directive_state
index|[
name|directive_density
index|]
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|can_relax
parameter_list|()
block|{
return|return
name|use_generics
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_push
parameter_list|(
name|directive
parameter_list|,
name|negated
parameter_list|,
name|datum
parameter_list|)
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
specifier|const
name|void
modifier|*
name|datum
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|state_stackS
modifier|*
name|stack
init|=
operator|(
name|state_stackS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|state_stackS
argument_list|)
argument_list|)
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|stack
operator|->
name|directive
operator|=
name|directive
expr_stmt|;
name|stack
operator|->
name|negated
operator|=
name|negated
expr_stmt|;
name|stack
operator|->
name|old_state
operator|=
name|directive_state
index|[
name|directive
index|]
expr_stmt|;
name|stack
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|stack
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|stack
operator|->
name|datum
operator|=
name|datum
expr_stmt|;
name|stack
operator|->
name|prev
operator|=
name|directive_state_stack
expr_stmt|;
name|directive_state_stack
operator|=
name|stack
expr_stmt|;
name|directive_state
index|[
name|directive
index|]
operator|=
operator|!
name|negated
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_pop
parameter_list|(
name|directive
parameter_list|,
name|negated
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|datum
parameter_list|)
name|directiveE
modifier|*
name|directive
decl_stmt|;
name|bfd_boolean
modifier|*
name|negated
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|datum
decl_stmt|;
block|{
name|state_stackS
modifier|*
name|top
init|=
name|directive_state_stack
decl_stmt|;
if|if
condition|(
operator|!
name|directive_state_stack
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unmatched end directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|directive
operator|=
name|directive_none
expr_stmt|;
return|return;
block|}
name|directive_state
index|[
name|directive_state_stack
operator|->
name|directive
index|]
operator|=
name|top
operator|->
name|old_state
expr_stmt|;
operator|*
name|directive
operator|=
name|top
operator|->
name|directive
expr_stmt|;
operator|*
name|negated
operator|=
name|top
operator|->
name|negated
expr_stmt|;
operator|*
name|file
operator|=
name|top
operator|->
name|file
expr_stmt|;
operator|*
name|line
operator|=
name|top
operator|->
name|line
expr_stmt|;
operator|*
name|datum
operator|=
name|top
operator|->
name|datum
expr_stmt|;
name|directive_state_stack
operator|=
name|top
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_balance
parameter_list|()
block|{
while|while
condition|(
name|directive_state_stack
condition|)
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|void
modifier|*
name|datum
decl_stmt|;
name|directive_pop
argument_list|(
operator|&
name|directive
argument_list|,
operator|&
name|negated
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|datum
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|".begin directive with no matching .end directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|inside_directive
parameter_list|(
name|dir
parameter_list|)
name|directiveE
name|dir
decl_stmt|;
block|{
name|state_stackS
modifier|*
name|top
init|=
name|directive_state_stack
decl_stmt|;
while|while
condition|(
name|top
operator|&&
name|top
operator|->
name|directive
operator|!=
name|dir
condition|)
name|top
operator|=
name|top
operator|->
name|prev
expr_stmt|;
return|return
operator|(
name|top
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_directive
parameter_list|(
name|directive
parameter_list|,
name|negated
parameter_list|)
name|directiveE
modifier|*
name|directive
decl_stmt|;
name|bfd_boolean
modifier|*
name|negated
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|negated
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
operator|*
name|negated
operator|=
name|TRUE
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
name|len
operator|=
name|strspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz_/0123456789."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|directive_info
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|directive_info
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|directive_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
name|len
expr_stmt|;
operator|*
name|directive
operator|=
operator|(
name|directiveE
operator|)
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|negated
operator|&&
operator|!
name|directive_info
index|[
name|i
index|]
operator|.
name|can_be_negated
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directive %s can't be negated"
argument_list|)
argument_list|,
name|directive_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|directive
operator|=
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_begin_directive
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
name|emit_state
modifier|*
name|state
decl_stmt|;
name|int
name|len
decl_stmt|;
name|lit_state
modifier|*
name|ls
decl_stmt|;
name|md_flush_pending_output
argument_list|()
expr_stmt|;
name|get_directive
argument_list|(
operator|&
name|directive
argument_list|,
operator|&
name|negated
argument_list|)
expr_stmt|;
if|if
condition|(
name|directive
operator|==
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
condition|)
block|{
name|discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|directive
condition|)
block|{
case|case
name|directive_literal
case|:
if|if
condition|(
operator|!
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
comment|/* Previous labels go with whatever follows this directive, not with 	     the literal, so save them now.  */
name|saved_insn_labels
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
block|}
name|state
operator|=
operator|(
name|emit_state
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|emit_state
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive_literal
argument_list|,
name|negated
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_literal_prefix
case|:
comment|/* Check to see if the current fragment is a literal 	 fragment.  If it is, then this operation is not allowed.  */
if|if
condition|(
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_literal
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot set literal_prefix inside literal fragment"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate the literal state for this section and push 	 onto the directive stack.  */
name|ls
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lit_state
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ls
argument_list|)
expr_stmt|;
operator|*
name|ls
operator|=
name|default_lit_sections
expr_stmt|;
name|directive_push
argument_list|(
name|directive_literal_prefix
argument_list|,
name|negated
argument_list|,
name|ls
argument_list|)
expr_stmt|;
comment|/* Parse the new prefix from the input_line_pointer.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|len
operator|=
name|strspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
literal|"abcdefghijklmnopqrstuvwxyz_/0123456789.$"
argument_list|)
expr_stmt|;
comment|/* Process the new prefix.  */
name|xtensa_literal_prefix
argument_list|(
name|input_line_pointer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Skip the name in the input line.  */
name|input_line_pointer
operator|+=
name|len
expr_stmt|;
break|break;
case|case
name|directive_freeregs
case|:
comment|/* This information is currently unused, but we'll accept the statement          and just discard the rest of the line.  This won't check the syntax,          but it will accept every correct freeregs directive.  */
name|input_line_pointer
operator|+=
name|strcspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive_freeregs
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_density
case|:
if|if
condition|(
operator|!
name|density_supported
operator|&&
operator|!
name|negated
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Xtensa density option not supported; ignored"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|directive_push
argument_list|(
name|directive
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_end_directive
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|directiveE
name|begin_directive
decl_stmt|,
name|end_directive
decl_stmt|;
name|bfd_boolean
name|begin_negated
decl_stmt|,
name|end_negated
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|emit_state
modifier|*
name|state
decl_stmt|;
name|lit_state
modifier|*
name|s
decl_stmt|;
name|md_flush_pending_output
argument_list|()
expr_stmt|;
name|get_directive
argument_list|(
operator|&
name|end_directive
argument_list|,
operator|&
name|end_negated
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_directive
operator|==
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
condition|)
block|{
name|discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end_directive
operator|==
name|directive_density
operator|&&
operator|!
name|density_supported
operator|&&
operator|!
name|end_negated
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Xtensa density option not supported; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|directive_pop
argument_list|(
operator|&
name|begin_directive
argument_list|,
operator|&
name|begin_negated
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_directive
operator|!=
name|directive_none
condition|)
block|{
if|if
condition|(
name|begin_directive
operator|!=
name|end_directive
operator|||
name|begin_negated
operator|!=
name|end_negated
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"does not match begin %s%s at %s:%d"
argument_list|)
argument_list|,
name|begin_negated
condition|?
literal|"no-"
else|:
literal|""
argument_list|,
name|directive_info
index|[
name|begin_directive
index|]
operator|.
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|end_directive
condition|)
block|{
case|case
name|directive_literal
case|:
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
comment|/* Restore the list of current labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
name|insn_labels
operator|=
name|saved_insn_labels
expr_stmt|;
block|}
break|break;
case|case
name|directive_freeregs
case|:
break|break;
case|case
name|directive_literal_prefix
case|:
comment|/* Restore the default collection sections from saved state.  */
name|s
operator|=
operator|(
name|lit_state
operator|*
operator|)
name|state
expr_stmt|;
name|assert
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_literal_section
condition|)
name|default_lit_sections
operator|=
operator|*
name|s
expr_stmt|;
comment|/* free the state storage */
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place an aligned literal fragment at the current location.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_literal_position
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".literal_position inside literal directive; ignoring"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|use_literal_section
condition|)
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support .literal label, value@plt + offset.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_literal_pseudo
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|emit_state
name|state
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|base_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|expressionS
name|expP
decl_stmt|;
name|segT
name|dest_seg
decl_stmt|;
if|if
condition|(
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".literal not allowed inside .begin literal region"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Previous labels go with whatever follows this directive, not with      the literal, so save them now.  */
name|saved_insn_labels
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
comment|/* If we are using text-section literals, then this is the right value... */
name|dest_seg
operator|=
name|now_seg
expr_stmt|;
name|base_name
operator|=
name|input_line_pointer
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* ...but if we aren't using text-section-literals, then we       need to put them in the section we just switched to.  */
if|if
condition|(
name|use_literal_section
condition|)
name|dest_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* All literals are aligned to four-byte boundaries      which is handled by switch to literal fragment.  */
comment|/* frag_align (2, 0, 0);  */
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma or colon after symbol name; "
literal|"rest of line ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|colon
argument_list|(
name|base_name
argument_list|)
expr_stmt|;
do|do
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' or ':' */
name|expr
argument_list|(
literal|0
argument_list|,
operator|&
name|expP
argument_list|)
expr_stmt|;
comment|/* We only support 4-byte literals with .literal.  */
name|emit_expr
argument_list|(
operator|&
name|expP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
do|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* Restore the list of current labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
name|insn_labels
operator|=
name|saved_insn_labels
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_literal_prefix
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|)
name|char
specifier|const
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|segT
name|s_now
decl_stmt|;
comment|/* Storage for the current seg and subseg.  */
name|subsegT
name|ss_now
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Pointer to the name itself.  */
name|char
modifier|*
name|newname
decl_stmt|;
if|if
condition|(
operator|!
name|use_literal_section
condition|)
return|return;
comment|/* Store away the current section and subsection.  */
name|s_now
operator|=
name|now_seg
expr_stmt|;
name|ss_now
operator|=
name|now_subseg
expr_stmt|;
comment|/* Get a null-terminated copy of the name.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the sections (interesting note: the memory pointing to      the name is actually used for the name by the new section). */
name|newname
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|strlen
argument_list|(
literal|".literal"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
operator|+
name|len
argument_list|,
literal|".literal"
argument_list|)
expr_stmt|;
comment|/* Note that retrieve_literal_seg does not create a segment if       it already exists.  */
name|default_lit_sections
operator|.
name|lit_seg
operator|=
name|NULL
expr_stmt|;
comment|/* retrieved on demand */
comment|/* Canonicalizing section names allows renaming literal      sections to occur correctly.  */
name|default_lit_sections
operator|.
name|lit_seg_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Restore the current section and subsection and set the       generation into the old segment.  */
name|subseg_set
argument_list|(
name|s_now
argument_list|,
name|ss_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parsing and Idiom Translation.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|expression_end
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|';'
case|:
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
return|return
name|name
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
operator|++
name|name
expr_stmt|;
continue|continue;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ERROR_REG_NUM
value|((unsigned) -1)
end_define

begin_function
specifier|static
name|unsigned
name|tc_get_register
parameter_list|(
name|prefix
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|unsigned
name|reg
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_line_pointer
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|old_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Accept "sp" as a synonym for "a1".  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|expression_end
argument_list|(
name|input_line_pointer
operator|+
literal|2
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
comment|/* AR[1] */
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
operator|*
name|prefix
operator|++
condition|)
empty_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
operator|--
name|prefix
expr_stmt|;
if|if
condition|(
operator|*
name|prefix
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name: %s"
argument_list|)
argument_list|,
name|old_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register number: %s"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
name|reg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|reg
operator|=
name|reg
operator|*
literal|10
operator|+
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_expr
operator|=
name|expression_end
argument_list|(
name|input_line_pointer
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name: %s"
argument_list|)
argument_list|,
name|old_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|next_expr
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PLT_SUFFIX
value|"@PLT"
end_define

begin_define
define|#
directive|define
name|plt_suffix
value|"@plt"
end_define

begin_function
specifier|static
name|void
name|expression_maybe_register
parameter_list|(
name|opnd
parameter_list|,
name|tok
parameter_list|)
name|xtensa_operand
name|opnd
decl_stmt|;
name|expressionS
modifier|*
name|tok
decl_stmt|;
block|{
name|char
modifier|*
name|kind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|kind
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|kind
operator|==
literal|'l'
operator|||
operator|*
name|kind
operator|==
literal|'L'
operator|||
operator|*
name|kind
operator|==
literal|'i'
operator|||
operator|*
name|kind
operator|==
literal|'r'
operator|)
condition|)
block|{
name|segT
name|t
init|=
name|expression
argument_list|(
name|tok
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|absolute_section
operator|&&
name|operand_is_pcrel_label
argument_list|(
name|opnd
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|tok
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|tok
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|tok
operator|->
name|X_add_symbol
operator|=
operator|&
name|abs_symbol
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|PLT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|PLT_SUFFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|plt_suffix
argument_list|,
name|strlen
argument_list|(
name|plt_suffix
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|symbol_get_tc
argument_list|(
name|tok
operator|->
name|X_add_symbol
argument_list|)
operator|->
name|plt
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|+=
name|strlen
argument_list|(
name|plt_suffix
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|reg
init|=
name|tc_get_register
argument_list|(
name|kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
name|ERROR_REG_NUM
condition|)
comment|/* Already errored */
block|{
name|uint32
name|buf
init|=
name|reg
decl_stmt|;
if|if
condition|(
operator|(
name|xtensa_operand_encode
argument_list|(
name|opnd
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|xtensa_encode_result_ok
operator|)
operator|||
operator|(
name|reg
operator|!=
name|xtensa_operand_decode
argument_list|(
name|opnd
argument_list|,
name|buf
argument_list|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register number out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tok
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|tok
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|tok
operator|->
name|X_add_number
operator|=
name|reg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split up the arguments for an opcode or pseudo-op.  */
end_comment

begin_function
specifier|static
name|int
name|tokenize_arguments
parameter_list|(
name|args
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
name|bfd_boolean
name|saw_comma
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|saw_arg
init|=
name|FALSE
decl_stmt|;
name|int
name|num_args
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg_end
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|arg_len
decl_stmt|;
comment|/* Save and restore input_line_pointer around this function.  */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|fini
goto|;
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|saw_comma
operator|||
operator|!
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|saw_comma
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|saw_comma
operator|&&
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|arg_end
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|expression_end
argument_list|(
name|arg_end
argument_list|)
condition|)
name|arg_end
operator|+=
literal|1
expr_stmt|;
name|arg_len
operator|=
name|arg_end
operator|-
name|input_line_pointer
expr_stmt|;
name|arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|arg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|num_args
index|]
operator|=
name|arg
expr_stmt|;
name|strncpy
argument_list|(
name|arg
argument_list|,
name|input_line_pointer
argument_list|,
name|arg_len
argument_list|)
expr_stmt|;
name|arg
index|[
name|arg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_line_pointer
operator|=
name|arg_end
expr_stmt|;
name|num_args
operator|+=
literal|1
expr_stmt|;
name|saw_comma
operator|=
name|FALSE
expr_stmt|;
name|saw_arg
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|fini
label|:
if|if
condition|(
name|saw_comma
condition|)
goto|goto
name|err
goto|;
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
name|num_args
return|;
name|err
label|:
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse the arguments to an opcode.  Return true on error.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_arguments
parameter_list|(
name|insn
parameter_list|,
name|num_args
parameter_list|,
name|arg_strings
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_strings
decl_stmt|;
block|{
name|expressionS
modifier|*
name|tok
init|=
name|insn
operator|->
name|tok
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|insn
operator|->
name|opcode
decl_stmt|;
name|bfd_boolean
name|had_error
init|=
name|TRUE
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|opcode_operand_count
decl_stmt|;
name|int
name|actual_operand_count
init|=
literal|0
decl_stmt|;
name|xtensa_operand
name|opnd
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
condition|)
name|opcode_operand_count
operator|=
literal|1
expr_stmt|;
else|else
name|opcode_operand_count
operator|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tok
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tok
argument_list|)
operator|*
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
comment|/* Save and restore input_line_pointer around this function.  */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_args
condition|;
name|n
operator|++
control|)
block|{
name|input_line_pointer
operator|=
name|arg_strings
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|actual_operand_count
operator|>=
name|opcode_operand_count
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|assert
argument_list|(
name|actual_operand_count
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|opnd
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|actual_operand_count
argument_list|)
expr_stmt|;
name|expression_maybe_register
argument_list|(
name|opnd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|tok
operator|->
name|X_op
operator|==
name|O_absent
condition|)
goto|goto
name|err
goto|;
name|actual_operand_count
operator|++
expr_stmt|;
name|tok
operator|++
expr_stmt|;
block|}
name|insn
operator|->
name|ntok
operator|=
name|tok
operator|-
name|insn
operator|->
name|tok
expr_stmt|;
name|had_error
operator|=
name|FALSE
expr_stmt|;
name|err
label|:
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
name|had_error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_reverse_shift_count
parameter_list|(
name|cnt_argp
parameter_list|)
name|char
modifier|*
modifier|*
name|cnt_argp
decl_stmt|;
block|{
name|char
modifier|*
name|cnt_arg
decl_stmt|,
modifier|*
name|new_arg
decl_stmt|;
name|cnt_arg
operator|=
operator|*
name|cnt_argp
expr_stmt|;
comment|/* replace the argument with "31-(argument)" */
name|new_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cnt_arg
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_arg
argument_list|,
literal|"31-(%s)"
argument_list|,
name|cnt_arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cnt_arg
argument_list|)
expr_stmt|;
operator|*
name|cnt_argp
operator|=
name|new_arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If "arg" is a constant expression, return non-zero with the value    in *valp.  */
end_comment

begin_function
specifier|static
name|int
name|xg_arg_is_constant
parameter_list|(
name|arg
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|offsetT
modifier|*
name|valp
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|save_ptr
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
name|arg
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
operator|*
name|valp
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_replace_opname
parameter_list|(
name|popname
parameter_list|,
name|newop
parameter_list|)
name|char
modifier|*
modifier|*
name|popname
decl_stmt|;
name|char
modifier|*
name|newop
decl_stmt|;
block|{
name|free
argument_list|(
operator|*
name|popname
argument_list|)
expr_stmt|;
operator|*
name|popname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|newop
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|popname
argument_list|,
name|newop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_check_num_args
parameter_list|(
name|pnum_args
parameter_list|,
name|expected_num
parameter_list|,
name|opname
parameter_list|,
name|arg_strings
parameter_list|)
name|int
modifier|*
name|pnum_args
decl_stmt|;
name|int
name|expected_num
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_strings
decl_stmt|;
block|{
name|int
name|num_args
init|=
operator|*
name|pnum_args
decl_stmt|;
if|if
condition|(
name|num_args
operator|<
name|expected_num
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"not enough operands (%d) for '%s'; expected %d"
argument_list|)
argument_list|,
name|num_args
argument_list|,
name|opname
argument_list|,
name|expected_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|num_args
operator|>
name|expected_num
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many operands (%d) for '%s'; expected %d"
argument_list|)
argument_list|,
name|num_args
argument_list|,
name|opname
argument_list|,
name|expected_num
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_args
operator|--
operator|>
name|expected_num
condition|)
block|{
name|free
argument_list|(
name|arg_strings
index|[
name|num_args
index|]
argument_list|)
expr_stmt|;
name|arg_strings
index|[
name|num_args
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pnum_args
operator|=
name|expected_num
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_translate_sysreg_op
parameter_list|(
name|popname
parameter_list|,
name|pnum_args
parameter_list|,
name|arg_strings
parameter_list|)
name|char
modifier|*
modifier|*
name|popname
decl_stmt|;
name|int
modifier|*
name|pnum_args
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_strings
decl_stmt|;
block|{
name|char
modifier|*
name|opname
decl_stmt|,
modifier|*
name|new_opname
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
name|opname
operator|=
operator|*
name|popname
expr_stmt|;
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Opname == [rw]ur... */
if|if
condition|(
name|opname
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* If the register is not specified as part of the opcode, 	 then get it from the operand and move it to the opcode.  */
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|2
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|xg_arg_is_constant
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register number for `%s' is not a constant"
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|unsigned
operator|)
name|val
operator|>
literal|255
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register number (%ld) for `%s' is out of range"
argument_list|)
argument_list|,
name|val
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Remove the last argument, which is now part of the opcode.  */
name|free
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|1
expr_stmt|;
comment|/* Translate the opcode.  */
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
literal|"%s%cur%u"
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_"
else|:
literal|""
operator|)
argument_list|,
name|opname
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|popname
argument_list|)
expr_stmt|;
operator|*
name|popname
operator|=
name|new_opname
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the instruction is an idiom (i.e., a built-in macro), translate it.    Returns non-zero if an error was found.  */
end_comment

begin_function
specifier|static
name|int
name|xg_translate_idioms
parameter_list|(
name|popname
parameter_list|,
name|pnum_args
parameter_list|,
name|arg_strings
parameter_list|)
name|char
modifier|*
modifier|*
name|popname
decl_stmt|;
name|int
modifier|*
name|pnum_args
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_strings
decl_stmt|;
block|{
name|char
modifier|*
name|opname
init|=
operator|*
name|popname
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|has_underbar
operator|&&
name|code_density_available
argument_list|()
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"mov.n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|2
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_or"
else|:
literal|"or"
operator|)
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"bbsi.l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|3
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_bbsi"
else|:
literal|"bbsi"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|xg_reverse_shift_count
argument_list|(
operator|&
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"bbci.l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|3
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_bbci"
else|:
literal|"bbci"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|xg_reverse_shift_count
argument_list|(
operator|&
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|has_underbar
operator|&&
name|code_density_available
argument_list|()
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"nop.n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|0
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_or"
else|:
literal|"or"
operator|)
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|0
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|opname
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'u'
operator|&&
name|opname
index|[
literal|2
index|]
operator|==
literal|'r'
condition|)
return|return
name|xg_translate_sysreg_op
argument_list|(
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
return|;
comment|/* WIDENING DENSITY OPCODES       questionable relaxations (widening) from old "tai" idioms:         ADD.N --> ADD        BEQZ.N --> BEQZ        RET.N --> RET        RETW.N --> RETW        MOVI.N --> MOVI        MOV.N --> MOV        NOP.N --> NOP       Note: this incomplete list was imported to match the "tai"      behavior; other density opcodes are not handled.       The xtensa-relax code may know how to do these but it doesn't do      anything when these density opcodes appear inside a no-density      region.  Somehow GAS should either print an error when that happens      or do the widening.  The old "tai" behavior was to do the widening.      For now, I'll make it widen but print a warning.       FIXME: GAS needs to detect density opcodes inside no-density      regions and treat them as errors.  This code should be removed      when that is done.  */
if|if
condition|(
name|use_generics
argument_list|()
operator|&&
operator|!
name|has_underbar
operator|&&
name|density_supported
operator|&&
operator|!
name|code_density_available
argument_list|()
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"add.n"
argument_list|)
operator|==
literal|0
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"beqz.n"
argument_list|)
operator|==
literal|0
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"beqz"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"ret.n"
argument_list|)
operator|==
literal|0
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"ret"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"retw.n"
argument_list|)
operator|==
literal|0
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"retw"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"movi.n"
argument_list|)
operator|==
literal|0
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"movi"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"mov.n"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|2
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"nop.n"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|0
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|0
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the Xtensa ISA.  */
end_comment

begin_comment
comment|/* Return true if the given operand is an immed or target instruction,    i.e., has a reloc associated with it.  Currently, this is only true    if the operand kind is "i, "l" or "L".  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|operand_is_immed
parameter_list|(
name|opnd
parameter_list|)
name|xtensa_operand
name|opnd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opkind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|opkind
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|opkind
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|opkind
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given operand is a pc-relative label.  This is    true for "l", "L", and "r" operand kinds.  */
end_comment

begin_function
name|bfd_boolean
name|operand_is_pcrel_label
parameter_list|(
name|opnd
parameter_list|)
name|xtensa_operand
name|opnd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opkind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|opkind
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|opkind
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|opkind
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Currently the assembler only allows us to use a single target per    fragment.  Because of this, only one operand for a given    instruction may be symbolic.  If there is an operand of kind "lrL",    the last one is chosen.  Otherwise, the result is the number of the    last operand of type "i", and if there are none of those, we fail    and return -1.  */
end_comment

begin_function
name|int
name|get_relaxable_immed
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|int
name|last_immed
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|noperands
decl_stmt|,
name|opi
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
operator|-
literal|1
return|;
name|noperands
operator|=
name|xtensa_num_operands
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opi
operator|=
name|noperands
operator|-
literal|1
init|;
name|opi
operator|>=
literal|0
condition|;
name|opi
operator|--
control|)
block|{
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_is_pcrel_label
argument_list|(
name|operand
argument_list|)
condition|)
return|return
name|opi
return|;
if|if
condition|(
name|last_immed
operator|==
operator|-
literal|1
operator|&&
name|operand_is_immed
argument_list|(
name|operand
argument_list|)
condition|)
name|last_immed
operator|=
name|opi
expr_stmt|;
block|}
return|return
name|last_immed
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|get_opcode_from_buf
parameter_list|(
name|buf
parameter_list|)
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
return|return
name|opcode
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_call0_opcode
operator|||
name|opcode
operator|==
name|xtensa_call4_opcode
operator|||
name|opcode
operator|==
name|xtensa_call8_opcode
operator|||
name|opcode
operator|==
name|xtensa_call12_opcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_callx0_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx4_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx8_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx12_opcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the opcode is an entry opcode.  This is used because    "entry" adds an implicit ".align 4" and also the entry instruction    has an extra check for an operand value.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_entry_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_entry_opcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is one of the loop opcodes.  Loops are special    because they need automatic alignment and they have a relaxation so    complex that we hard-coded it.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_loop_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_loop_opcode
operator|||
name|opcode
operator|==
name|xtensa_loopnez_opcode
operator|||
name|opcode
operator|==
name|xtensa_loopgtz_opcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_the_loop_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_loop_opcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_jx_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_jx_opcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the opcode is a retw or retw.n.    Needed to add nops to avoid a hardware interlock issue.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_windowed_return_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|opcode
operator|==
name|xtensa_retw_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_n_opcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the opcode type is "l" and the opcode is NOT a jump.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_conditional_branch_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|num_ops
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_j_opcode
operator|&&
name|opcode
operator|!=
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|num_ops
operator|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_operand
name|operand
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xtensa_operand_kind
argument_list|(
name|operand
argument_list|)
argument_list|,
literal|"l"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given opcode is a conditional branch    instruction, i.e., currently this is true if the instruction     is a jx or has an operand with 'l' type and is not a loop.  */
end_comment

begin_function
name|bfd_boolean
name|is_branch_or_jump_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|int
name|opn
decl_stmt|,
name|op_count
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|is_jx_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|op_count
operator|=
name|xtensa_num_operands
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opn
operator|=
literal|0
init|;
name|opn
operator|<
name|op_count
condition|;
name|opn
operator|++
control|)
block|{
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|opkind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|opkind
operator|&&
name|opkind
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|opkind
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert from operand numbers to BFD relocation type code.    Return BFD_RELOC_NONE on failure.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|opnum_to_reloc
parameter_list|(
name|opnum
parameter_list|)
name|int
name|opnum
decl_stmt|;
block|{
switch|switch
condition|(
name|opnum
condition|)
block|{
case|case
literal|0
case|:
return|return
name|BFD_RELOC_XTENSA_OP0
return|;
case|case
literal|1
case|:
return|return
name|BFD_RELOC_XTENSA_OP1
return|;
case|case
literal|2
case|:
return|return
name|BFD_RELOC_XTENSA_OP2
return|;
default|default:
break|break;
block|}
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_comment
comment|/* Convert from BFD relocation type code to operand number.    Return -1 on failure.  */
end_comment

begin_function
name|int
name|reloc_to_opnum
parameter_list|(
name|reloc
parameter_list|)
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|{
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_XTENSA_OP0
case|:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_XTENSA_OP1
case|:
return|return
literal|1
return|;
case|case
name|BFD_RELOC_XTENSA_OP2
case|:
return|return
literal|2
return|;
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_insnbuf_set_operand
parameter_list|(
name|insnbuf
parameter_list|,
name|opcode
parameter_list|,
name|operand
parameter_list|,
name|value
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|xtensa_insnbuf
name|insnbuf
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
name|int32
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|xtensa_encode_result
name|encode_result
decl_stmt|;
name|uint32
name|valbuf
init|=
name|value
decl_stmt|;
name|encode_result
operator|=
name|xtensa_operand_encode
argument_list|(
name|operand
argument_list|,
operator|&
name|valbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encode_result
condition|)
block|{
case|case
name|xtensa_encode_result_ok
case|:
break|break;
case|case
name|xtensa_encode_result_align
case|:
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d not properly aligned for '%s'"
argument_list|)
argument_list|,
name|value
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_not_in_table
case|:
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d not in immediate table for '%s'"
argument_list|)
argument_list|,
name|value
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_too_high
case|:
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d too large for '%s'"
argument_list|)
argument_list|,
name|value
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_too_low
case|:
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d too small for '%s'"
argument_list|)
argument_list|,
name|value
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_not_ok
case|:
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d is invalid for '%s'"
argument_list|)
argument_list|,
name|value
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|xtensa_operand_set_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32
name|xtensa_insnbuf_get_operand
parameter_list|(
name|insnbuf
parameter_list|,
name|opcode
parameter_list|,
name|opnum
parameter_list|)
name|xtensa_insnbuf
name|insnbuf
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
block|{
name|xtensa_operand
name|op
init|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|)
decl_stmt|;
return|return
name|xtensa_operand_decode
argument_list|(
name|op
argument_list|,
name|xtensa_operand_get_field
argument_list|(
name|op
argument_list|,
name|insnbuf
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_insnbuf_set_immediate_field
parameter_list|(
name|opcode
parameter_list|,
name|insnbuf
parameter_list|,
name|value
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_insnbuf
name|insnbuf
decl_stmt|;
name|int32
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|last_opnd
init|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|-
literal|1
decl_stmt|;
name|xtensa_operand
name|operand
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|last_opnd
argument_list|)
decl_stmt|;
name|xtensa_insnbuf_set_operand
argument_list|(
name|insnbuf
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|,
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_negatable_branch
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_ops
init|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|kind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|kind
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|kind
operator|==
literal|'l'
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Various Other Internal Functions.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_unique_insn_expansion
parameter_list|(
name|r
parameter_list|)
name|TransitionRule
modifier|*
name|r
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|to_instr
operator|||
name|r
operator|->
name|to_instr
operator|->
name|next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|r
operator|->
name|to_instr
operator|->
name|typ
operator|!=
name|INSTR_INSTR
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_get_insn_size
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
return|return
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_get_build_instr_size
parameter_list|(
name|insn
parameter_list|)
name|BuildInstr
modifier|*
name|insn
decl_stmt|;
block|{
name|assert
argument_list|(
name|insn
operator|->
name|typ
operator|==
name|INSTR_INSTR
argument_list|)
expr_stmt|;
return|return
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_is_narrow_insn
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|num_match
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
operator|&&
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|/* It only generates one instruction... */
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
comment|/* ...and it is a larger instruction.  */
if|if
condition|(
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
operator|<
name|xg_get_build_instr_size
argument_list|(
name|rule
operator|->
name|to_instr
argument_list|)
condition|)
block|{
name|num_match
operator|++
expr_stmt|;
if|if
condition|(
name|num_match
operator|>
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
operator|(
name|num_match
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_is_single_relaxable_insn
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|num_match
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
operator|&&
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
comment|/* ... and it is a larger instruction.  */
if|if
condition|(
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
operator|<=
name|xg_get_build_instr_size
argument_list|(
name|rule
operator|->
name|to_instr
argument_list|)
condition|)
block|{
name|num_match
operator|++
expr_stmt|;
if|if
condition|(
name|num_match
operator|>
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
operator|(
name|num_match
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the largest size instruction that this instruction can    expand to.  Currently, in all cases, this is 3 bytes.  Of course we    could just calculate this once and generate a table.  */
end_comment

begin_function
name|int
name|xg_get_max_narrow_insn_size
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
comment|/* Go ahead and compute it, but it better be 3.  */
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|old_size
init|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
comment|/* Actually we can do better. Check to see of Only one applies.  */
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
comment|/* If it only generates one instruction.  */
if|if
condition|(
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|int
name|new_size
init|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|rule
operator|->
name|to_instr
operator|->
name|opcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_size
operator|>
name|old_size
condition|)
block|{
name|assert
argument_list|(
name|new_size
operator|==
literal|3
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
block|}
return|return
name|old_size
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of bytes this opcode can expand to.  */
end_comment

begin_function
name|int
name|xg_get_max_insn_widen_size
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|max_size
init|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
name|BuildInstr
modifier|*
name|build_list
decl_stmt|;
name|int
name|this_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rule
condition|)
continue|continue;
name|build_list
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
if|if
condition|(
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|build_list
operator|->
name|typ
operator|==
name|INSTR_INSTR
argument_list|)
expr_stmt|;
name|this_size
operator|=
name|xg_get_max_insn_widen_size
argument_list|(
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|build_list
operator|!=
name|NULL
condition|;
name|build_list
operator|=
name|build_list
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|build_list
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|this_size
operator|+=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
case|case
name|INSTR_LABEL_DEF
case|:
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|this_size
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|this_size
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of literal bytes this opcode can generate.  */
end_comment

begin_function
name|int
name|xg_get_max_insn_widen_literal_size
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|max_size
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
name|BuildInstr
modifier|*
name|build_list
decl_stmt|;
name|int
name|this_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rule
condition|)
continue|continue;
name|build_list
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
if|if
condition|(
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|build_list
operator|->
name|typ
operator|==
name|INSTR_INSTR
argument_list|)
expr_stmt|;
name|this_size
operator|=
name|xg_get_max_insn_widen_literal_size
argument_list|(
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|build_list
operator|!=
name|NULL
condition|;
name|build_list
operator|=
name|build_list
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|build_list
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_LITERAL_DEF
case|:
comment|/* hard coded 4-byte literal.  */
name|this_size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|INSTR_INSTR
case|:
case|case
name|INSTR_LABEL_DEF
case|:
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|this_size
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|this_size
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_is_relaxable_insn
parameter_list|(
name|insn
parameter_list|,
name|lateral_steps
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|int
name|lateral_steps
decl_stmt|;
block|{
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|==
name|lateral_steps
condition|)
return|return
name|TRUE
return|;
name|steps_taken
operator|++
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_special_literal_symbol
parameter_list|()
block|{
specifier|static
name|symbolS
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
literal|"SPECIAL_LITERAL0\001"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_special_label_symbol
parameter_list|()
block|{
specifier|static
name|symbolS
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
literal|"SPECIAL_LABEL0\001"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Return true on success.  */
end_comment

begin_function
name|bfd_boolean
name|xg_build_to_insn
parameter_list|(
name|targ
parameter_list|,
name|insn
parameter_list|,
name|bi
parameter_list|)
name|TInsn
modifier|*
name|targ
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
block|{
name|BuildOp
modifier|*
name|op
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|memset
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bi
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|bi
operator|->
name|opcode
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|int
name|op_num
init|=
name|op
operator|->
name|op_num
decl_stmt|;
name|int
name|op_data
init|=
name|op
operator|->
name|op_data
decl_stmt|;
name|assert
argument_list|(
name|op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|ntok
operator|<=
name|op_num
condition|)
name|targ
operator|->
name|ntok
operator|=
name|op_num
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
name|set_expr_const
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|op_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
name|sym
operator|=
name|get_special_literal_symbol
argument_list|()
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LABEL
case|:
name|sym
operator|=
name|get_special_label_symbol
argument_list|()
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* currently handles: 		 OP_OPERAND_LOW8 		 OP_OPERAND_HI24S 		 OP_OPERAND_F32MINUS */
if|if
condition|(
name|xg_has_userdef_op_fn
argument_list|(
name|op
operator|->
name|typ
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_is_const
argument_list|(
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
condition|)
block|{
name|long
name|val
decl_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|xg_apply_userdef_op_fn
argument_list|(
name|op
operator|->
name|typ
argument_list|,
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
operator|=
name|val
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* We cannot use a relocation for this.  */
break|break;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_LITERAL
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|int
name|op_num
init|=
name|op
operator|->
name|op_num
decl_stmt|;
name|int
name|op_data
init|=
name|op
operator|->
name|op_data
decl_stmt|;
name|assert
argument_list|(
name|op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|ntok
operator|<=
name|op_num
condition|)
name|targ
operator|->
name|ntok
operator|=
name|op_num
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_CONSTANT
case|:
case|case
name|OP_LABEL
case|:
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|INSTR_LABEL_DEF
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_LABEL
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
comment|/* Literal with no ops. is a label?  */
name|assert
argument_list|(
name|op
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true on success.  */
end_comment

begin_function
name|bfd_boolean
name|xg_build_to_stack
parameter_list|(
name|istack
parameter_list|,
name|insn
parameter_list|,
name|bi
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|BuildInstr
modifier|*
name|bi
decl_stmt|;
block|{
for|for
control|(
init|;
name|bi
operator|!=
name|NULL
condition|;
name|bi
operator|=
name|bi
operator|->
name|next
control|)
block|{
name|TInsn
modifier|*
name|next_insn
init|=
name|istack_push_space
argument_list|(
name|istack
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xg_build_to_insn
argument_list|(
name|next_insn
argument_list|,
name|insn
argument_list|,
name|bi
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true on valid expansion.  */
end_comment

begin_function
name|bfd_boolean
name|xg_expand_to_stack
parameter_list|(
name|istack
parameter_list|,
name|insn
parameter_list|,
name|lateral_steps
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|int
name|lateral_steps
decl_stmt|;
block|{
name|int
name|stack_size
init|=
name|istack
operator|->
name|ninsn
decl_stmt|;
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
block|{
if|if
condition|(
name|lateral_steps
operator|==
name|steps_taken
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is it.  Expand the rule to the stack.  */
if|if
condition|(
operator|!
name|xg_build_to_stack
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|,
name|rule
operator|->
name|to_instr
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Check to see if it fits.  */
for|for
control|(
name|i
operator|=
name|stack_size
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|insn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
operator|&&
operator|!
name|tinsn_has_symbolic_operands
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|xg_immeds_fit
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|istack
operator|->
name|ninsn
operator|=
name|stack_size
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|steps_taken
operator|++
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xg_expand_narrow
parameter_list|(
name|targ
parameter_list|,
name|insn
parameter_list|)
name|TInsn
modifier|*
name|targ
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
operator|&&
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|/* Is it a larger instruction?  */
if|if
condition|(
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
operator|<=
name|xg_get_build_instr_size
argument_list|(
name|rule
operator|->
name|to_instr
argument_list|)
condition|)
block|{
name|xg_build_to_insn
argument_list|(
name|targ
argument_list|,
name|insn
argument_list|,
name|rule
operator|->
name|to_instr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Assumes: All immeds are constants.  Check that all constants fit    into their immeds; return false if not.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_immeds_fit
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|operand_is_immed
argument_list|(
name|opnd
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
block|{
if|if
condition|(
name|xg_check_operand
argument_list|(
name|expr
operator|->
name|X_add_number
argument_list|,
name|opnd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
comment|/* The symbol should have a fixup associated with it.  */
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This should only be called after we have an initial    estimate of the addresses.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_symbolic_immeds_fit
parameter_list|(
name|insn
parameter_list|,
name|pc_seg
parameter_list|,
name|pc_frag
parameter_list|,
name|pc_offset
parameter_list|,
name|stretch
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|segT
name|pc_seg
decl_stmt|;
name|fragS
modifier|*
name|pc_frag
decl_stmt|;
name|offsetT
name|pc_offset
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|offsetT
name|target
decl_stmt|,
name|pc
decl_stmt|,
name|new_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|operand_is_immed
argument_list|(
name|opnd
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
if|if
condition|(
name|xg_check_operand
argument_list|(
name|expr
operator|->
name|X_add_number
argument_list|,
name|opnd
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|O_symbol
case|:
comment|/* We only allow symbols for pc-relative stuff. 	     If pc_frag == 0, then we don't have frag locations yet.  */
if|if
condition|(
name|pc_frag
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* If it is PC-relative and the symbol is in the same segment as 	     the PC.... */
if|if
condition|(
operator|!
name|xtensa_operand_isPCRelative
argument_list|(
name|opnd
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|pc_seg
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
name|target
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|expr
operator|->
name|X_add_number
expr_stmt|;
name|pc
operator|=
name|pc_frag
operator|->
name|fr_address
operator|+
name|pc_offset
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, assume it 	     will move by STRETCH just as we did.  If this is not so, 	     it will be because some frag between grows, and that will 	     force another pass.  Beware zero-length frags.  There 	     should be a faster way to do this.  */
if|if
condition|(
name|stretch
operator|&&
name|is_dnrange
argument_list|(
name|pc_frag
argument_list|,
name|symbolP
argument_list|,
name|stretch
argument_list|)
condition|)
name|target
operator|+=
name|stretch
expr_stmt|;
name|new_offset
operator|=
name|xtensa_operand_do_reloc
argument_list|(
name|opnd
argument_list|,
name|target
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_check_operand
argument_list|(
name|new_offset
argument_list|,
name|opnd
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
comment|/* The symbol should have a fixup associated with it.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This will check to see if the value can be converted into the    operand type.  It will return true if it does not fit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_check_operand
parameter_list|(
name|value
parameter_list|,
name|operand
parameter_list|)
name|int32
name|value
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
block|{
name|uint32
name|valbuf
init|=
name|value
decl_stmt|;
return|return
operator|(
name|xtensa_operand_encode
argument_list|(
name|operand
argument_list|,
operator|&
name|valbuf
argument_list|)
operator|!=
name|xtensa_encode_result_ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if a symbol is pointing to somewhere after    the start frag, given that the segment has stretched     by stretch during relaxation.     This is more complicated than it might appear at first blush    because of the stretching that goes on. Here is how the check    works:     If the symbol and the frag are in the same segment, then    the symbol could be down range. Note that this function     assumes that start_frag is in now_seg.     If the symbol is pointing to a frag with an address greater than     than the start_frag's address, then it _could_ be down range.      The problem comes because target_frag may or may not have had    stretch bytes added to its address already, depending on if it is     before or after start frag. (And if we knew that, then we wouldn't    need this function.) start_frag has definitely already had stretch    bytes added to its address.        If target_frag's address hasn't been adjusted yet, then to     determine if it comes after start_frag, we need to subtract    stretch from start_frag's address.     If target_frag's address has been adjusted, then it might have    been adjusted such that it comes after start_frag's address minus    stretch bytes.     So, in that case, we scan for it down stream to within     stretch bytes. We could search to the end of the fr_chain, but    that ends up taking too much time (over a minute on some gnu     tests).  */
end_comment

begin_function
name|int
name|is_dnrange
parameter_list|(
name|start_frag
parameter_list|,
name|sym
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|start_frag
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|now_seg
condition|)
block|{
name|fragS
modifier|*
name|cur_frag
init|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_frag
operator|->
name|fr_address
operator|>=
name|start_frag
operator|->
name|fr_address
operator|-
name|stretch
condition|)
block|{
name|int
name|distance
init|=
name|stretch
decl_stmt|;
while|while
condition|(
name|cur_frag
operator|&&
name|distance
operator|>=
literal|0
condition|)
block|{
name|distance
operator|-=
name|cur_frag
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|cur_frag
operator|==
name|start_frag
condition|)
return|return
literal|0
return|;
name|cur_frag
operator|=
name|cur_frag
operator|->
name|fr_next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relax the assembly instruction at least "min_steps".    Return the number of steps taken.  */
end_comment

begin_function
name|int
name|xg_assembly_relax
parameter_list|(
name|istack
parameter_list|,
name|insn
parameter_list|,
name|pc_seg
parameter_list|,
name|pc_frag
parameter_list|,
name|pc_offset
parameter_list|,
name|min_steps
parameter_list|,
name|stretch
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|segT
name|pc_seg
decl_stmt|;
name|fragS
modifier|*
name|pc_frag
decl_stmt|;
comment|/* If pc_frag == 0, then no pc-relative.  */
name|offsetT
name|pc_offset
decl_stmt|;
comment|/* Offset in fragment.  */
name|int
name|min_steps
decl_stmt|;
comment|/* Minimum number of conversion steps.  */
name|long
name|stretch
decl_stmt|;
comment|/* Number of bytes stretched so far.  */
block|{
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
comment|/* assert (has no symbolic operands)      Some of its immeds don't fit.      Try to build a relaxed version.      This may go through a couple of stages      of single instruction transformations before      we get there.  */
name|TInsn
name|single_target
decl_stmt|;
name|TInsn
name|current_insn
decl_stmt|;
name|int
name|lateral_steps
init|=
literal|0
decl_stmt|;
name|int
name|istack_size
init|=
name|istack
operator|->
name|ninsn
decl_stmt|;
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
name|insn
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
operator|&&
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
name|tinsn_copy
argument_list|(
operator|&
name|current_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Walk through all of the single instruction expansions. */
while|while
condition|(
name|xg_is_single_relaxable_insn
argument_list|(
operator|&
name|current_insn
argument_list|)
condition|)
block|{
name|int
name|error_val
init|=
name|xg_expand_narrow
argument_list|(
operator|&
name|single_target
argument_list|,
operator|&
name|current_insn
argument_list|)
decl_stmt|;
name|assert
argument_list|(
operator|!
name|error_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
operator|&
name|single_target
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
name|steps_taken
operator|++
expr_stmt|;
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
operator|&
name|single_target
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
block|}
name|tinsn_copy
argument_list|(
operator|&
name|current_insn
argument_list|,
operator|&
name|single_target
argument_list|)
expr_stmt|;
block|}
comment|/* Now check for a multi-instruction expansion.  */
while|while
condition|(
name|xg_is_relaxable_insn
argument_list|(
operator|&
name|current_insn
argument_list|,
name|lateral_steps
argument_list|)
condition|)
block|{
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
operator|&
name|current_insn
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
operator|&
name|current_insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
block|}
name|steps_taken
operator|++
expr_stmt|;
if|if
condition|(
name|xg_expand_to_stack
argument_list|(
name|istack
argument_list|,
operator|&
name|current_insn
argument_list|,
name|lateral_steps
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
return|return
name|steps_taken
return|;
block|}
name|lateral_steps
operator|++
expr_stmt|;
name|istack
operator|->
name|ninsn
operator|=
name|istack_size
expr_stmt|;
block|}
comment|/* It's not going to work -- use the original.  */
name|istack_push
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_force_frag_space
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
comment|/* This may have the side effect of creating a new fragment for the      space to go into.  I just do not like the name of the "frag"      functions.  */
name|frag_grow
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xg_finish_frag
parameter_list|(
name|last_insn
parameter_list|,
name|state
parameter_list|,
name|max_growth
parameter_list|,
name|is_insn
parameter_list|)
name|char
modifier|*
name|last_insn
decl_stmt|;
name|enum
name|xtensa_relax_statesE
name|state
decl_stmt|;
name|int
name|max_growth
decl_stmt|;
name|bfd_boolean
name|is_insn
decl_stmt|;
block|{
comment|/* Finish off this fragment so that it has at LEAST the desired      max_growth.  If it doesn't fit in this fragment, close this one      and start a new one.  In either case, return a pointer to the      beginning of the growth area.  */
name|fragS
modifier|*
name|old_frag
decl_stmt|;
name|xg_force_frag_space
argument_list|(
name|max_growth
argument_list|)
expr_stmt|;
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|fr_opcode
operator|=
name|last_insn
expr_stmt|;
if|if
condition|(
name|is_insn
condition|)
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_growth
argument_list|,
name|max_growth
argument_list|,
name|state
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
comment|/* Just to make sure that we did not split it up.  */
name|assert
argument_list|(
name|old_frag
operator|->
name|fr_next
operator|==
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_branch_jmp_to_next
parameter_list|(
name|insn
parameter_list|,
name|fragP
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_ops
init|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|target_op
init|=
operator|-
literal|1
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|fragS
modifier|*
name|target_frag
decl_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|kind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|kind
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|kind
operator|==
literal|'l'
condition|)
block|{
name|target_op
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target_op
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|target_op
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|sym
operator|=
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|target_frag
operator|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_frag
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|is_next_frag_target
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|target_frag
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
name|target_frag
operator|->
name|fr_address
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_add_branch_and_loop_targets
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|num_ops
init|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|kind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|kind
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|kind
operator|==
literal|'l'
condition|)
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|symbol_get_tc
argument_list|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|is_loop_target
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Currently, we do not add branch targets.  This is an optimization      for later that tries to align only branch targets, not just any      label in a text section.  */
if|if
condition|(
name|align_only_targets
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
operator|&&
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_operand
name|opnd
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|kind
init|=
name|xtensa_operand_kind
argument_list|(
name|opnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|kind
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|kind
operator|==
literal|'l'
operator|&&
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
decl_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the transition rule that matches or NULL if none matches.  */
end_comment

begin_function
name|bfd_boolean
name|xg_instruction_matches_rule
parameter_list|(
name|insn
parameter_list|,
name|rule
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|TransitionRule
modifier|*
name|rule
decl_stmt|;
block|{
name|PreconditionList
modifier|*
name|condition_l
decl_stmt|;
if|if
condition|(
name|rule
operator|->
name|opcode
operator|!=
name|insn
operator|->
name|opcode
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|condition_l
operator|=
name|rule
operator|->
name|conditions
init|;
name|condition_l
operator|!=
name|NULL
condition|;
name|condition_l
operator|=
name|condition_l
operator|->
name|next
control|)
block|{
name|expressionS
modifier|*
name|exp1
decl_stmt|;
name|expressionS
modifier|*
name|exp2
decl_stmt|;
name|Precondition
modifier|*
name|cond
init|=
name|condition_l
operator|->
name|precond
decl_stmt|;
switch|switch
condition|(
name|cond
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
comment|/* The expression must be the constant.  */
name|assert
argument_list|(
name|cond
operator|->
name|op_num
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|exp1
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_num
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|expr_is_const
argument_list|(
name|exp1
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|cond
operator|->
name|cmp
condition|)
block|{
case|case
name|OP_EQUAL
case|:
if|if
condition|(
name|get_expr_const
argument_list|(
name|exp1
argument_list|)
operator|!=
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_NOTEQUAL
case|:
if|if
condition|(
name|get_expr_const
argument_list|(
name|exp1
argument_list|)
operator|==
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|cond
operator|->
name|op_num
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cond
operator|->
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|exp1
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_num
index|]
expr_stmt|;
name|exp2
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_data
index|]
expr_stmt|;
switch|switch
condition|(
name|cond
operator|->
name|cmp
condition|)
block|{
case|case
name|OP_EQUAL
case|:
if|if
condition|(
operator|!
name|expr_is_equal
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_NOTEQUAL
case|:
if|if
condition|(
name|expr_is_equal
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_LABEL
case|:
default|default:
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|TransitionRule
modifier|*
name|xg_instruction_match
parameter_list|(
name|insn
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_simplify_table
argument_list|()
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
comment|/* Walk through all of the possible transitions.  */
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
return|return
name|rule
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return false if no error.  */
end_comment

begin_function
name|bfd_boolean
name|xg_build_token_insn
parameter_list|(
name|instr_spec
parameter_list|,
name|old_insn
parameter_list|,
name|new_insn
parameter_list|)
name|BuildInstr
modifier|*
name|instr_spec
decl_stmt|;
name|TInsn
modifier|*
name|old_insn
decl_stmt|;
name|TInsn
modifier|*
name|new_insn
decl_stmt|;
block|{
name|int
name|num_ops
init|=
literal|0
decl_stmt|;
name|BuildOp
modifier|*
name|b_op
decl_stmt|;
switch|switch
condition|(
name|instr_spec
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|new_insn
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|new_insn
operator|->
name|opcode
operator|=
name|instr_spec
operator|->
name|opcode
expr_stmt|;
name|new_insn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
name|new_insn
operator|->
name|insn_type
operator|=
name|ITYPE_LITERAL
expr_stmt|;
name|new_insn
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|new_insn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|INSTR_LABEL_DEF
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"INSTR_LABEL_DEF not supported yet"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|b_op
operator|=
name|instr_spec
operator|->
name|ops
init|;
name|b_op
operator|!=
name|NULL
condition|;
name|b_op
operator|=
name|b_op
operator|->
name|next
control|)
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|src_exp
decl_stmt|;
name|num_ops
operator|++
expr_stmt|;
switch|switch
condition|(
name|b_op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
comment|/* The expression must be the constant.  */
name|assert
argument_list|(
name|b_op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|new_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_num
index|]
expr_stmt|;
name|set_expr_const
argument_list|(
name|exp
argument_list|,
name|b_op
operator|->
name|op_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|b_op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b_op
operator|->
name|op_data
operator|<
operator|(
name|unsigned
operator|)
name|old_insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|src_exp
operator|=
operator|&
name|old_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_data
index|]
expr_stmt|;
name|exp
operator|=
operator|&
name|new_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_num
index|]
expr_stmt|;
name|copy_expr
argument_list|(
name|exp
argument_list|,
name|src_exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_LABEL
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle generation of literal/labels yet"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle undefined OP TYPE"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|new_insn
operator|->
name|ntok
operator|=
name|num_ops
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if it was simplified.  */
end_comment

begin_function
name|bfd_boolean
name|xg_simplify_insn
parameter_list|(
name|old_insn
parameter_list|,
name|new_insn
parameter_list|)
name|TInsn
modifier|*
name|old_insn
decl_stmt|;
name|TInsn
modifier|*
name|new_insn
decl_stmt|;
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|xg_instruction_match
argument_list|(
name|old_insn
argument_list|)
decl_stmt|;
name|BuildInstr
modifier|*
name|insn_spec
decl_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|insn_spec
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
comment|/* There should only be one.  */
name|assert
argument_list|(
name|insn_spec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn_spec
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_spec
operator|->
name|next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
name|xg_build_token_insn
argument_list|(
name|insn_spec
argument_list|,
name|old_insn
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* xg_expand_assembly_insn: (1) Simplify the instruction, i.e., l32i ->    l32i.n. (2) Check the number of operands.  (3) Place the instruction    tokens into the stack or if we can relax it at assembly time, place    multiple instructions/literals onto the stack.  Return false if no    error.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_expand_assembly_insn
parameter_list|(
name|istack
parameter_list|,
name|orig_insn
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
name|TInsn
modifier|*
name|orig_insn
decl_stmt|;
block|{
name|int
name|noperands
decl_stmt|;
name|TInsn
name|new_insn
decl_stmt|;
name|memset
argument_list|(
operator|&
name|new_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On return, we will be using the "use_tokens" with "use_ntok".      This will reduce things like addi to addi.n.  */
if|if
condition|(
name|code_density_available
argument_list|()
operator|&&
operator|!
name|orig_insn
operator|->
name|is_specific_opcode
condition|)
block|{
if|if
condition|(
name|xg_simplify_insn
argument_list|(
name|orig_insn
argument_list|,
operator|&
name|new_insn
argument_list|)
condition|)
name|orig_insn
operator|=
operator|&
name|new_insn
expr_stmt|;
block|}
name|noperands
operator|=
name|xtensa_num_operands
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_insn
operator|->
name|ntok
operator|<
name|noperands
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"found %d operands for '%s':  Expected %d"
argument_list|)
argument_list|,
name|orig_insn
operator|->
name|ntok
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
argument_list|,
name|noperands
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|orig_insn
operator|->
name|ntok
operator|>
name|noperands
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"found too many (%d) operands for '%s':  Expected %d"
argument_list|)
argument_list|,
name|orig_insn
operator|->
name|ntok
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
argument_list|,
name|noperands
argument_list|)
expr_stmt|;
comment|/* If there are not enough operands, we will assert above. If there      are too many, just cut out the extras here.  */
name|orig_insn
operator|->
name|ntok
operator|=
name|noperands
expr_stmt|;
comment|/* Cases:        Instructions with all constant immeds:      Assemble them and relax the instruction if possible.      Give error if not possible; no fixup needed.       Instructions with symbolic immeds:      Assemble them with a Fix up (that may cause instruction expansion).      Also close out the fragment if the fixup may cause instruction expansion.             There are some other special cases where we need alignment.      1) before certain instructions with required alignment (OPCODE_ALIGN)      2) before labels that have jumps (LABEL_ALIGN)      3) after call instructions (RETURN_ALIGN)         Multiple of these may be possible on the same fragment.  	If so, make sure to satisfy the required alignment.  	Then try to get the desired alignment.  */
if|if
condition|(
name|tinsn_has_invalid_symbolic_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|orig_insn
operator|->
name|is_specific_opcode
operator|||
operator|!
name|can_relax
argument_list|()
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tinsn_has_symbolic_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|tinsn_has_complex_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
name|xg_assembly_relax
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|istack_push
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xg_immeds_fit
argument_list|(
name|orig_insn
argument_list|)
condition|)
name|istack_push
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
else|else
name|xg_assembly_relax
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (i = 0; i< istack->ninsn; i++)     {       if (xg_simplify_insn (&new_insn,&istack->insn[i])) 	istack->insn[i] = new_insn;     }
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Currently all literals that are generated here are 32-bit L32R targets.  */
end_comment

begin_function
name|symbolS
modifier|*
name|xg_assemble_literal
parameter_list|(
name|insn
parameter_list|)
comment|/* const */
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|emit_state
name|state
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
comment|/* size = 4 for L32R.  It could easily be larger when we move to      larger constants.  Add a parameter later.  */
name|offsetT
name|litsize
init|=
literal|4
decl_stmt|;
name|offsetT
name|litalign
init|=
literal|2
decl_stmt|;
comment|/* 2^2 = 4 */
name|expressionS
name|saved_loc
decl_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|saved_loc
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|ntok
operator|=
literal|1
argument_list|)
expr_stmt|;
comment|/* must be only one token here */
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* Force a 4-byte align here.  Note that this opens a new frag, so all      literals done with this function have a frag to themselves.  That's      important for the way text section literals work.  */
name|frag_align
argument_list|(
name|litalign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|insn
operator|->
name|tok
index|[
literal|0
index|]
argument_list|,
name|litsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|xtensa_create_literal_symbol
argument_list|(
name|now_seg
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|lit_sym
operator|=
name|frag_now
operator|->
name|fr_symbol
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|=
name|TRUE
expr_stmt|;
comment|/* Go back.  */
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
name|lit_sym
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_assemble_literal_space
parameter_list|(
name|size
parameter_list|)
comment|/* const */
name|int
name|size
decl_stmt|;
block|{
name|emit_state
name|state
decl_stmt|;
comment|/* We might have to do something about this alignment.  It only        takes effect if something is placed here.  */
name|offsetT
name|litalign
init|=
literal|2
decl_stmt|;
comment|/* 2^2 = 4 */
name|fragS
modifier|*
name|lit_saved_frag
decl_stmt|;
name|expressionS
name|saved_loc
decl_stmt|;
name|assert
argument_list|(
name|size
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|saved_loc
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* Force a 4-byte align here.  */
name|frag_align
argument_list|(
name|litalign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xg_force_frag_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|lit_saved_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|xtensa_create_literal_symbol
argument_list|(
name|now_seg
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|xg_finish_frag
argument_list|(
literal|0
argument_list|,
name|RELAX_LITERAL
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Go back.  */
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|lit_saved_frag
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|xtensa_create_literal_symbol
parameter_list|(
name|sec
parameter_list|,
name|frag
parameter_list|)
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
specifier|static
name|int
name|lit_num
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".L_lit_sym%d"
argument_list|,
name|lit_num
argument_list|)
expr_stmt|;
comment|/* Create a local symbol.  If it is in a linkonce section, we have to      be careful to make sure that if it is used in a relocation that the      symbol will be in the output file.  */
if|if
condition|(
name|get_is_linkonce_section
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* symbolP->local = 1; */
block|}
else|else
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|xtensa_add_literal_sym
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|frag
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|=
name|TRUE
expr_stmt|;
name|lit_num
operator|++
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_add_literal_sym
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|sym_list
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
name|sym_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|literal_syms
expr_stmt|;
name|literal_syms
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_add_insn_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|sym_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|free_insn_labels
condition|)
name|l
operator|=
operator|(
name|sym_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_list
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
name|free_insn_labels
expr_stmt|;
name|free_insn_labels
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|l
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|sym_list
modifier|*
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
operator|&
name|free_insn_labels
init|;
operator|*
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pl
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the section flags are marked linkonce    or the name is .gnu.linkonce*.  */
end_comment

begin_function
name|bfd_boolean
name|get_is_linkonce_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|,
name|link_once_flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|link_once_flags
operator|=
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
expr_stmt|;
comment|/* Flags might not be set yet.  */
if|if
condition|(
operator|!
name|link_once_flags
condition|)
block|{
specifier|static
name|size_t
name|len
init|=
sizeof|sizeof
expr|".gnu.linkonce.t."
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|link_once_flags
operator|=
name|SEC_LINK_ONCE
expr_stmt|;
block|}
return|return
operator|(
name|link_once_flags
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Emit an instruction to the current fragment.  If record_fix is true,    then this instruction will not change and we can go ahead and record    the fixup.  If record_fix is false, then the instruction may change    and we are going to close out this fragment.  Go ahead and set the    fr_symbol and fr_offset instead of adding a fixup.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_emit_insn
parameter_list|(
name|t_insn
parameter_list|,
name|record_fix
parameter_list|)
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
name|bfd_boolean
name|record_fix
decl_stmt|;
block|{
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|t_insn
operator|->
name|opcode
decl_stmt|;
name|bfd_boolean
name|has_fixup
init|=
name|FALSE
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|int
name|i
decl_stmt|,
name|byte_count
decl_stmt|;
name|fragS
modifier|*
name|oldfrag
decl_stmt|;
name|size_t
name|old_size
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
comment|/* Use a static pointer to the insn buffer so we don't have to call       malloc each time through.  */
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|has_fixup
operator|=
name|tinsn_to_insnbuf
argument_list|(
name|t_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|noperands
operator|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|noperands
operator|==
name|t_insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|byte_count
operator|=
name|xtensa_insn_length
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|oldfrag
operator|=
name|frag_now
expr_stmt|;
comment|/* This should NEVER cause us to jump into a new frag;      we've already reserved space.  */
name|old_size
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
name|byte_count
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oldfrag
operator|==
name|frag_now
argument_list|)
expr_stmt|;
comment|/* This needs to generate a record that lists the parts that are      instructions.  */
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
comment|/* If we are at the beginning of a fragment, switch this 	 fragment to an instruction fragment.  */
if|if
condition|(
name|now_seg
operator|!=
name|absolute_section
operator|&&
name|old_size
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"instruction fragment may contain data"
argument_list|)
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
block|}
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|byte_count
argument_list|)
expr_stmt|;
comment|/* Now spit out the opcode fixup.... */
if|if
condition|(
operator|!
name|has_fixup
condition|)
return|return
operator|!
name|ok
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
operator|++
name|i
control|)
block|{
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|t_insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_symbol
case|:
if|if
condition|(
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|record_fix
condition|)
block|{
if|if
condition|(
operator|!
name|xg_add_opcode_fix
argument_list|(
name|opcode
argument_list|,
name|i
argument_list|,
name|expr
argument_list|,
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Write it to the fr_offset, fr_symbol.  */
name|frag_now
operator|->
name|fr_symbol
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
name|frag_now
operator|->
name|fr_offset
operator|=
name|expr
operator|->
name|X_add_number
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand %d on '%s'"
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|O_constant
case|:
case|case
name|O_register
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid expression for operand %d on '%s'"
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|!
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_emit_insn_to_buf
parameter_list|(
name|t_insn
parameter_list|,
name|buf
parameter_list|,
name|fragP
parameter_list|,
name|offset
parameter_list|,
name|build_fix
parameter_list|)
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|bfd_boolean
name|build_fix
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|has_symbolic_immed
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|has_symbolic_immed
operator|=
name|tinsn_to_insnbuf
argument_list|(
name|t_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_symbolic_immed
operator|&&
name|build_fix
condition|)
block|{
comment|/* Add a fixup.  */
name|int
name|opnum
init|=
name|get_relaxable_immed
argument_list|(
name|t_insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|t_insn
operator|->
name|tok
index|[
name|opnum
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|xg_add_opcode_fix
argument_list|(
name|t_insn
operator|->
name|opcode
argument_list|,
name|opnum
argument_list|,
name|exp
argument_list|,
name|fragP
argument_list|,
name|offset
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Put in a fixup record based on the opcode.    Return true on success.  */
end_comment

begin_function
name|bfd_boolean
name|xg_add_opcode_fix
parameter_list|(
name|opcode
parameter_list|,
name|opnum
parameter_list|,
name|expr
parameter_list|,
name|fragP
parameter_list|,
name|offset
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|expressionS
modifier|*
name|expr
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|insn_length
decl_stmt|;
name|fixS
modifier|*
name|the_fix
decl_stmt|;
name|reloc
operator|=
name|opnum_to_reloc
argument_list|(
name|opnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid relocation operand %i on '%s'"
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|howto
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"undefined symbol for opcode \"%s\"."
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|insn_length
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|the_fix
operator|=
name|fix_new_exp
argument_list|(
name|fragP
argument_list|,
name|offset
argument_list|,
name|insn_length
argument_list|,
name|expr
argument_list|,
name|howto
operator|->
name|pc_relative
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_add_symbol
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
operator|)
condition|)
name|the_fix
operator|->
name|fx_plt
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|xg_resolve_literals
parameter_list|(
name|insn
parameter_list|,
name|lit_sym
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
init|=
name|get_special_literal_symbol
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lit_sym
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|==
name|sym
condition|)
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|lit_sym
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xg_resolve_labels
parameter_list|(
name|insn
parameter_list|,
name|label_sym
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|symbolS
modifier|*
name|label_sym
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
init|=
name|get_special_label_symbol
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* assert(!insn->is_literal); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|==
name|sym
condition|)
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|label_sym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_assemble_tokens
parameter_list|(
name|insn
parameter_list|)
comment|/*const */
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
comment|/* By the time we get here, there's not too much left to do.       1) Check our assumptions.       2) Check if the current instruction is "narrow".          If so, then finish the frag, create another one.         We could also go back to change some previous         "narrow" frags into no-change ones if we have more than         MAX_NARROW_ALIGNMENT of them without alignment restrictions         between them.       Cases:         1) It has constant operands and doesn't fit.            Go ahead and assemble it so it will fail.         2) It has constant operands that fit.            If narrow and !is_specific_opcode,               assemble it and put in a relocation            else               assemble it.         3) It has a symbolic immediate operand            a) Find the worst-case relaxation required            b) Find the worst-case literal pool space required.               Insert appropriate alignment& space in the literal.               Assemble it.               Add the relocation.  */
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tinsn_has_symbolic_operands
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|xg_is_narrow_insn
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|insn
operator|->
name|is_specific_opcode
condition|)
block|{
comment|/* assemble it but add max required space */
name|int
name|max_size
init|=
name|xg_get_max_narrow_insn_size
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|min_size
init|=
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|char
modifier|*
name|last_insn
decl_stmt|;
name|assert
argument_list|(
name|max_size
operator|==
literal|3
argument_list|)
expr_stmt|;
comment|/* make sure we have enough space to widen it */
name|xg_force_frag_space
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
comment|/* Output the instruction.  It may cause an error if some  	     operands do not fit.  */
name|last_insn
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_emit_insn
argument_list|(
name|insn
argument_list|,
name|TRUE
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"instruction with constant operands does not fit"
argument_list|)
argument_list|)
expr_stmt|;
name|xg_finish_frag
argument_list|(
name|last_insn
argument_list|,
name|RELAX_NARROW
argument_list|,
name|max_size
operator|-
name|min_size
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Assemble it.  No relocation needed.  */
name|int
name|max_size
init|=
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|xg_force_frag_space
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_emit_insn
argument_list|(
name|insn
argument_list|,
name|FALSE
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"instruction with constant operands does not "
literal|"fit without widening"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* frag_more (max_size); */
comment|/* Special case for jx.  If the jx is the next to last 	     instruction in a loop, we will add a NOP after it.  This 	     avoids a hardware issue that could occur if the jx jumped 	     to the next instruction.  */
if|if
condition|(
name|software_avoid_b_j_loop_end
operator|&&
name|is_jx_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
block|{
name|maybe_has_b_j_loop_end
operator|=
name|TRUE
expr_stmt|;
comment|/* add 2 of these */
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_PRE_LOOP_END
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Need to assemble it with space for the relocation.  */
if|if
condition|(
operator|!
name|insn
operator|->
name|is_specific_opcode
condition|)
block|{
comment|/* Assemble it but add max required space.  */
name|char
modifier|*
name|last_insn
decl_stmt|;
name|int
name|min_size
init|=
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|max_size
init|=
name|xg_get_max_insn_widen_size
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|max_literal_size
init|=
name|xg_get_max_insn_widen_literal_size
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|symbolS *immed_sym = xg_get_insn_immed_symbol (insn); 	  set_frag_segment (frag_now, now_seg);
endif|#
directive|endif
comment|/* 0 */
comment|/* Make sure we have enough space to widen the instruction.  	     This may open a new fragment.  */
name|xg_force_frag_space
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_literal_size
operator|!=
literal|0
condition|)
name|xg_assemble_literal_space
argument_list|(
name|max_literal_size
argument_list|)
expr_stmt|;
comment|/* Output the instruction.  It may cause an error if some  	     operands do not fit.  Emit the incomplete instruction.  */
name|last_insn
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xg_emit_insn
argument_list|(
name|insn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xg_finish_frag
argument_list|(
name|last_insn
argument_list|,
name|RELAX_IMMED
argument_list|,
name|max_size
operator|-
name|min_size
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Special cases for loops: 	     close_loop_end should be inserted AFTER short_loop. 	     Make sure that CLOSE loops are processed BEFORE short_loops 	     when converting them.  */
comment|/* "short_loop": add a NOP if the loop is< 4 bytes.  */
if|if
condition|(
name|software_avoid_short_loop
operator|&&
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
block|{
name|maybe_has_short_loop
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_SHORT_LOOP
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_SHORT_LOOP
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* "close_loop_end": Add up to 12 bytes of NOPs to keep a 	     loop at least 12 bytes away from another loop's loop 	     end.  */
if|if
condition|(
name|software_avoid_close_loop_end
operator|&&
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
block|{
name|maybe_has_close_loop_end
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|12
argument_list|,
literal|12
argument_list|,
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Assemble it in place.  No expansion will be required,  	     but we'll still need a relocation record.  */
name|int
name|max_size
init|=
name|xg_get_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|xg_force_frag_space
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_emit_insn
argument_list|(
name|insn
argument_list|,
name|TRUE
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"instruction's constant operands do not fit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if the instruction can write to the specified    integer register.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_register_writer
parameter_list|(
name|insn
parameter_list|,
name|regset
parameter_list|,
name|regnum
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|regset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_ops
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|num_ops
operator|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_operand
name|operand
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
name|inout
init|=
name|xtensa_operand_inout
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|inout
operator|==
literal|'>'
operator|||
name|inout
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|xtensa_operand_kind
argument_list|(
name|operand
argument_list|)
argument_list|,
name|regset
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|regnum
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_bad_loopend_opcode
parameter_list|(
name|tinsn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|tinsn
decl_stmt|;
block|{
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_call0_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx0_opcode
operator|||
name|opcode
operator|==
name|xtensa_call4_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx4_opcode
operator|||
name|opcode
operator|==
name|xtensa_call8_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx8_opcode
operator|||
name|opcode
operator|==
name|xtensa_call12_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx12_opcode
operator|||
name|opcode
operator|==
name|xtensa_isync_opcode
operator|||
name|opcode
operator|==
name|xtensa_ret_opcode
operator|||
name|opcode
operator|==
name|xtensa_ret_n_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_n_opcode
operator|||
name|opcode
operator|==
name|xtensa_waiti_opcode
condition|)
return|return
name|TRUE
return|;
comment|/* An RSR of LCOUNT is illegal as the last opcode in a loop.  */
if|if
condition|(
name|opcode
operator|==
name|xtensa_rsr_opcode
operator|&&
name|tinsn
operator|->
name|ntok
operator|>=
literal|2
operator|&&
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|==
literal|2
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Labels that begin with ".Ln" or ".LM"  are unaligned.    This allows the debugger to add unaligned labels.    Also, the assembler generates stabs labels that need    not be aligned:  FAKE_LABEL_NAME . {"F", "L", "endfunc"}.  */
end_comment

begin_function
name|bfd_boolean
name|is_unaligned_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
specifier|static
name|size_t
name|fake_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'n'
operator|||
name|name
index|[
literal|2
index|]
operator|==
literal|'M'
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* FAKE_LABEL_NAME followed by "F", "L" or "endfunc" */
if|if
condition|(
name|fake_size
operator|==
literal|0
condition|)
name|fake_size
operator|=
name|strlen
argument_list|(
name|FAKE_LABEL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|strncmp
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|name
argument_list|,
name|fake_size
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
name|fake_size
index|]
operator|==
literal|'F'
operator|||
name|name
index|[
name|fake_size
index|]
operator|==
literal|'L'
operator|||
operator|(
name|name
index|[
name|fake_size
index|]
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
literal|"endfunc"
argument_list|,
name|name
operator|+
name|fake_size
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|fragS
modifier|*
name|next_non_empty_frag
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|fragS
modifier|*
name|next_fragP
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
comment|/* Sometimes an empty will end up here due storage allocation issues.       So we have to skip until we find something legit.  */
while|while
condition|(
name|next_fragP
operator|&&
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
operator|||
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|next_fragP
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|next_frag_opcode
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|next_fragP
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
return|return
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the target frag is one of the next non-empty frags.  */
end_comment

begin_function
name|bfd_boolean
name|is_next_frag_target
parameter_list|(
name|fragP
parameter_list|,
name|target
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|const
name|fragS
modifier|*
name|target
decl_stmt|;
block|{
if|if
condition|(
name|fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|==
name|target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|fragP
operator|->
name|fr_offset
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|)
operator|&&
operator|(
operator|(
name|fragP
operator|->
name|fr_address
operator|%
operator|(
literal|1
operator|<<
name|fragP
operator|->
name|fr_offset
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_space
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* If the next legit fragment is an end-of-loop marker,    switch its state so it will instantiate a NOP.  */
end_comment

begin_function
specifier|static
name|void
name|update_next_frag_nop_state
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|fragS
modifier|*
name|next_fragP
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
while|while
condition|(
name|next_fragP
operator|&&
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|next_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_LOOP_END
condition|)
block|{
name|next_fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LOOP_END_ADD_NOP
expr_stmt|;
return|return;
block|}
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_frag_is_branch_target
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
comment|/* Sometimes an empty will end up here due storage allocation issues,      so we have to skip until we find something legit.  */
for|for
control|(
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_frag_is_loop_target
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
comment|/* Sometimes an empty will end up here due storage allocation issues.       So we have to skip until we find something legit. */
for|for
control|(
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|addressT
name|next_frag_pre_opcode_bytes
parameter_list|(
name|fragp
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
specifier|const
name|fragS
modifier|*
name|next_fragp
init|=
name|fragp
operator|->
name|fr_next
decl_stmt|;
name|xtensa_opcode
name|next_opcode
init|=
name|next_frag_opcode
argument_list|(
name|fragp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_loop_opcode
argument_list|(
name|next_opcode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Sometimes an empty will end up here due storage allocation issues.      So we have to skip until we find something legit.  */
while|while
condition|(
name|next_fragp
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|next_fragp
operator|=
name|next_fragp
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|next_fragp
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
condition|)
return|return
literal|0
return|;
comment|/* There is some implicit knowledge encoded in here.      The LOOP instructions that are NOT RELAX_IMMED have      been relaxed.  */
if|if
condition|(
name|next_fragp
operator|->
name|fr_subtype
operator|>
name|RELAX_IMMED
condition|)
return|return
name|get_expanded_loop_offset
argument_list|(
name|next_opcode
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark a location where we can later insert literal frags.  Update    the section's literal_pool_loc, so subsequent literals can be    placed nearest to their use.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_mark_literal_pool_location
parameter_list|()
block|{
comment|/* Any labels pointing to the current location need      to be adjusted to after the literal pool.  */
name|emit_state
name|s
decl_stmt|;
name|fragS
modifier|*
name|pool_location
decl_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We stash info in the fr_var of these frags      so we can later move the literal's fixes into this       frchain's fix list.  We can use fr_var because fr_var's      interpretation depends solely on the fr_type and subtype.  */
name|pool_location
operator|=
name|frag_now
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|frchain_now
argument_list|,
name|RELAX_LITERAL_POOL_BEGIN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|now_seg
argument_list|,
name|RELAX_LITERAL_POOL_END
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now put a frag into the literal pool that points to this location.  */
name|set_literal_pool_location
argument_list|(
name|now_seg
argument_list|,
name|pool_location
argument_list|)
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Close whatever frag is there.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|pool_location
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "loops_ok" argument is provided to allow ignoring labels that     define loop ends.  This fixes a bug where the NOPs to align a     loop opcode were included in a previous zero-cost loop:     loop a0, loopend<loop1 body>    loopend:     loop a2, loopend2<loop2 body>     would become:     loop a0, loopend<loop1 body>      nop.n<===== bad!    loopend:     loop a2, loopend2<loop2 body>     This argument is used to prevent moving the NOP to before the    loop-end label, which is what you want in this special case.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_move_labels
parameter_list|(
name|new_frag
parameter_list|,
name|new_offset
parameter_list|,
name|loops_ok
parameter_list|)
name|fragS
modifier|*
name|new_frag
decl_stmt|;
name|valueT
name|new_offset
decl_stmt|;
name|bfd_boolean
name|loops_ok
decl_stmt|;
block|{
name|sym_list
modifier|*
name|lit
decl_stmt|;
for|for
control|(
name|lit
operator|=
name|insn_labels
init|;
name|lit
condition|;
name|lit
operator|=
name|lit
operator|->
name|next
control|)
block|{
name|symbolS
modifier|*
name|lit_sym
init|=
name|lit
operator|->
name|sym
decl_stmt|;
if|if
condition|(
name|loops_ok
operator|||
name|symbol_get_tc
argument_list|(
name|lit_sym
argument_list|)
operator|->
name|is_loop_target
operator|==
literal|0
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|lit_sym
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lit_sym
argument_list|,
name|new_frag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assemble a NOP of the requested size in the buffer.  User must have    allocated "buf" with at least "size" bytes.  */
end_comment

begin_function
name|void
name|assemble_nop
parameter_list|(
name|size
parameter_list|,
name|buf
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|t_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|t_insn
operator|.
name|opcode
operator|=
name|xtensa_nop_n_opcode
expr_stmt|;
name|t_insn
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_insn
operator|.
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode 'NOP.N' unavailable in this configuration"
argument_list|)
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|t_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|t_insn
operator|.
name|opcode
operator|=
name|xtensa_or_opcode
expr_stmt|;
name|assert
argument_list|(
name|t_insn
operator|.
name|opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_insn
operator|.
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode 'OR' unavailable in this configuration"
argument_list|)
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t_insn
operator|.
name|ntok
operator|=
literal|3
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|t_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid %d-byte NOP requested"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of bytes for the offset of the expanded loop    instruction.  This should be incorporated into the relaxation    specification but is hard-coded here.  This is used to auto-align    the loop instruction.  It is invalid to call this function if the    configuration does not have loops or if the opcode is not a loop    opcode.  */
end_comment

begin_function
specifier|static
name|addressT
name|get_expanded_loop_offset
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
comment|/* This is the OFFSET of the loop instruction in the expanded loop.      This MUST correspond directly to the specification of the loop      expansion.  It will be validated on fragment conversion.  */
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"get_expanded_loop_offset: undefined opcode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loop_opcode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loopnez_opcode
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loopgtz_opcode
condition|)
return|return
literal|6
return|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"get_expanded_loop_offset: invalid opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|fragS
modifier|*
name|get_literal_pool_location
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
return|return
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|literal_pool_loc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_literal_pool_location
parameter_list|(
name|seg
parameter_list|,
name|literal_pool_loc
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|fragS
modifier|*
name|literal_pool_loc
decl_stmt|;
block|{
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|literal_pool_loc
operator|=
name|literal_pool_loc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* External Functions and Other GAS Hooks.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|xtensa_target_format
parameter_list|()
block|{
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-xtensa-be"
else|:
literal|"elf32-xtensa-le"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xtensa_file_arch_init
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_set_private_flags
argument_list|(
name|abfd
argument_list|,
literal|0x100
operator||
literal|0x200
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
name|xtensa_isa
name|isa
decl_stmt|;
if|#
directive|if
name|STATIC_LIBISA
name|isa
operator|=
name|xtensa_isa_init
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ISA was already initialized by xtensa_init().  */
name|isa
operator|=
name|xtensa_default_isa
expr_stmt|;
endif|#
directive|endif
comment|/* Set  up the .literal, .fini.literal and .init.literal sections.  */
name|memset
argument_list|(
operator|&
name|default_lit_sections
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|default_lit_sections
argument_list|)
argument_list|)
expr_stmt|;
name|default_lit_sections
operator|.
name|init_lit_seg_name
operator|=
name|INIT_LITERAL_SECTION_NAME
expr_stmt|;
name|default_lit_sections
operator|.
name|fini_lit_seg_name
operator|=
name|FINI_LITERAL_SECTION_NAME
expr_stmt|;
name|default_lit_sections
operator|.
name|lit_seg_name
operator|=
name|LITERAL_SECTION_NAME
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
name|xtensa_addi_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"addi"
argument_list|)
expr_stmt|;
name|xtensa_addmi_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"addmi"
argument_list|)
expr_stmt|;
name|xtensa_call0_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call0"
argument_list|)
expr_stmt|;
name|xtensa_call4_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call4"
argument_list|)
expr_stmt|;
name|xtensa_call8_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call8"
argument_list|)
expr_stmt|;
name|xtensa_call12_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call12"
argument_list|)
expr_stmt|;
name|xtensa_callx0_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx0"
argument_list|)
expr_stmt|;
name|xtensa_callx4_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx4"
argument_list|)
expr_stmt|;
name|xtensa_callx8_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx8"
argument_list|)
expr_stmt|;
name|xtensa_callx12_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx12"
argument_list|)
expr_stmt|;
name|xtensa_entry_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"entry"
argument_list|)
expr_stmt|;
name|xtensa_isync_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"isync"
argument_list|)
expr_stmt|;
name|xtensa_j_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"j"
argument_list|)
expr_stmt|;
name|xtensa_jx_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"jx"
argument_list|)
expr_stmt|;
name|xtensa_loop_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loop"
argument_list|)
expr_stmt|;
name|xtensa_loopnez_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loopnez"
argument_list|)
expr_stmt|;
name|xtensa_loopgtz_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loopgtz"
argument_list|)
expr_stmt|;
name|xtensa_nop_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"nop.n"
argument_list|)
expr_stmt|;
name|xtensa_or_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|xtensa_ret_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"ret"
argument_list|)
expr_stmt|;
name|xtensa_ret_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"ret.n"
argument_list|)
expr_stmt|;
name|xtensa_retw_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"retw"
argument_list|)
expr_stmt|;
name|xtensa_retw_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"retw.n"
argument_list|)
expr_stmt|;
name|xtensa_rsr_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"rsr"
argument_list|)
expr_stmt|;
name|xtensa_waiti_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"waiti"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tc_frob_label hook */
end_comment

begin_function
name|void
name|xtensa_frob_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|generating_literals
condition|)
name|xtensa_add_literal_sym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|xtensa_add_insn_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_loop_target
operator|&&
operator|(
name|get_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
operator|&
name|FLAG_IS_BAD_LOOPEND
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid last instruction for a zero-overhead loop"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No target aligning in the absolute section.  */
if|if
condition|(
name|now_seg
operator|!=
name|absolute_section
operator|&&
name|align_targets
operator|&&
operator|!
name|is_unaligned_label
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_literal
condition|)
block|{
comment|/* frag_now->tc_frag_data.is_insn = TRUE; */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_DESIRE_ALIGN_IF_TARGET
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If the label is already known to be a branch target, i.e., a 	 forward branch, mark the frag accordingly.  Backward branches 	 are handled by xg_add_branch_and_loop_targets.  */
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_branch_target
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
comment|/* Loops only go forward, so they can be identified here.  */
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_loop_target
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_flush_pending_output hook */
end_comment

begin_function
name|void
name|xtensa_flush_pending_output
parameter_list|()
block|{
comment|/* If there is a non-zero instruction fragment, close it.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
operator|&&
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|FALSE
expr_stmt|;
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|;
name|unsigned
name|opnamelen
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|arg_strings
index|[
name|MAX_INSN_ARGS
index|]
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|IStack
name|istack
decl_stmt|;
comment|/* Put instructions into here.  */
name|TInsn
name|orig_insn
decl_stmt|;
comment|/* Original instruction from the input.  */
name|int
name|i
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_literal
condition|)
block|{
specifier|static
name|bfd_boolean
name|reported
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reported
operator|<
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot assemble '%s' into a literal fragment"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reported
operator|==
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"..."
argument_list|)
argument_list|)
expr_stmt|;
name|reported
operator|++
expr_stmt|;
return|return;
block|}
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|orig_insn
argument_list|)
expr_stmt|;
comment|/* Split off the opcode.  */
name|opnamelen
operator|=
name|strspn
argument_list|(
name|str
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz_/0123456789."
argument_list|)
expr_stmt|;
name|opname
operator|=
name|xmalloc
argument_list|(
name|opnamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opname
argument_list|,
name|str
argument_list|,
name|opnamelen
argument_list|)
expr_stmt|;
name|opname
index|[
name|opnamelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|num_args
operator|=
name|tokenize_arguments
argument_list|(
name|arg_strings
argument_list|,
name|str
operator|+
name|opnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|==
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xg_translate_idioms
argument_list|(
operator|&
name|opname
argument_list|,
operator|&
name|num_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return;
comment|/* Check for an underbar prefix.  */
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
name|orig_insn
operator|.
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|orig_insn
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
name|orig_insn
operator|.
name|is_specific_opcode
operator|=
operator|(
name|has_underbar
operator|||
operator|!
name|use_generics
argument_list|()
operator|)
expr_stmt|;
name|specific_opcode
operator|=
name|orig_insn
operator|.
name|is_specific_opcode
expr_stmt|;
name|orig_insn
operator|.
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_insn
operator|.
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode %s"
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
operator|&&
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|software_a0_b_retw_interlock
condition|)
block|{
if|if
condition|(
operator|(
name|get_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
operator|&
name|FLAG_IS_A0_WRITER
operator|)
operator|!=
literal|0
operator|&&
name|is_conditional_branch_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
name|has_a0_b_retw
operator|=
name|TRUE
expr_stmt|;
comment|/* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW. 	     After the first assembly pass we will check all of them and 	     add a nop if needed.  */
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_A0_B_RETW
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_A0_B_RETW
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Special case: The call instructions should be marked "specific opcode"      to keep them from expanding.  */
if|if
condition|(
operator|!
name|use_longcalls
argument_list|()
operator|&&
name|is_direct_call_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
name|orig_insn
operator|.
name|is_specific_opcode
operator|=
name|TRUE
expr_stmt|;
comment|/* Parse the arguments.  */
if|if
condition|(
name|parse_arguments
argument_list|(
operator|&
name|orig_insn
argument_list|,
name|num_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Free the opcode and argument strings, now that they've been parsed.  */
name|free
argument_list|(
name|has_underbar
condition|?
name|opname
operator|-
literal|1
else|:
name|opname
argument_list|)
expr_stmt|;
name|opname
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num_args
operator|--
operator|>
literal|0
condition|)
name|free
argument_list|(
name|arg_strings
index|[
name|num_args
index|]
argument_list|)
expr_stmt|;
comment|/* Check for the right number and type of arguments.  */
if|if
condition|(
name|tinsn_check_arguments
argument_list|(
operator|&
name|orig_insn
argument_list|)
condition|)
return|return;
comment|/* See if the instruction implies an aligned section.  */
if|if
condition|(
name|is_entry_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
operator|||
name|is_loop_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xg_add_branch_and_loop_targets
argument_list|(
operator|&
name|orig_insn
argument_list|)
expr_stmt|;
comment|/* Special cases for instructions that force an alignment... */
if|if
condition|(
operator|!
name|orig_insn
operator|.
name|is_specific_opcode
operator|&&
name|is_loop_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
name|size_t
name|max_fill
decl_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|=
operator|!
name|code_density_available
argument_list|()
expr_stmt|;
name|max_fill
operator|=
name|get_text_align_max_fill_size
argument_list|(
name|get_text_align_power
argument_list|(
name|XTENSA_FETCH_WIDTH
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_no_density
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_fill
argument_list|,
name|max_fill
argument_list|,
name|RELAX_ALIGN_NEXT_OPCODE
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Special-case for "entry" instruction.  */
if|if
condition|(
name|is_entry_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
comment|/* Check that the second opcode (#1) is>= 16.  */
if|if
condition|(
name|orig_insn
operator|.
name|ntok
operator|>=
literal|2
condition|)
block|{
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|orig_insn
operator|.
name|tok
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
if|if
condition|(
name|exp
operator|->
name|X_add_number
operator|<
literal|16
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"entry instruction with stack decrement< 16"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"entry instruction with non-constant decrement"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|orig_insn
operator|.
name|is_specific_opcode
condition|)
block|{
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
comment|/* Automatically align ENTRY instructions.  */
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Any extra alignment frags have been inserted now, and we're about to      emit a new instruction so clear the list of labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
if|if
condition|(
name|software_a0_b_retw_interlock
condition|)
name|set_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|FLAG_IS_A0_WRITER
argument_list|,
name|is_register_writer
argument_list|(
operator|&
name|orig_insn
argument_list|,
literal|"a"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|FLAG_IS_BAD_LOOPEND
argument_list|,
name|is_bad_loopend_opcode
argument_list|(
operator|&
name|orig_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish it off:      assemble_tokens (opcode, tok, ntok);       expand the tokens from the orig_insn into the       stack of instructions that will not expand       unless required at relaxation time.  */
if|if
condition|(
name|xg_expand_assembly_insn
argument_list|(
operator|&
name|istack
argument_list|,
operator|&
name|orig_insn
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|insn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
condition|)
block|{
name|assert
argument_list|(
name|lit_sym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lit_sym
operator|=
name|xg_assemble_literal
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lit_sym
condition|)
name|xg_resolve_literals
argument_list|(
name|insn
argument_list|,
name|lit_sym
argument_list|)
expr_stmt|;
name|xg_assemble_tokens
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, if the original opcode was a call... */
if|if
condition|(
name|align_targets
operator|&&
name|is_call_opcode
argument_list|(
name|orig_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_DESIRE_ALIGN
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* TC_CONS_FIX_NEW hook: Check for "@PLT" suffix on symbol references.    If found, use an XTENSA_PLT reloc for 4-byte values.  Otherwise, this    is the same as the standard code in read.c.  */
end_comment

begin_function
name|void
name|xtensa_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|bfd_boolean
name|plt
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|PLT_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|PLT_SUFFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
name|plt_suffix
argument_list|,
name|strlen
argument_list|(
name|plt_suffix
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"undefined @ suffix '%s', expected '%s'"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|,
name|plt_suffix
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|+=
name|strlen
argument_list|(
name|plt_suffix
argument_list|)
expr_stmt|;
name|plt
operator|=
name|TRUE
expr_stmt|;
block|}
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|r
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|plt
condition|?
name|BFD_RELOC_XTENSA_PLT
else|:
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TC_FRAG_INIT hook */
end_comment

begin_function
name|void
name|xtensa_frag_init
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|frag
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|=
operator|!
name|code_density_available
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine.  */
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|char
modifier|*
name|insn_p
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
return|return
name|addr
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_XTENSA_ASM_EXPAND
condition|)
return|return
name|addr
return|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|insn_p
operator|=
operator|&
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
index|[
name|fixP
operator|->
name|fx_where
index|]
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|insn_p
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|opnum
operator|=
name|reloc_to_opnum
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|<
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid operand relocation for '%s' instruction"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|>=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid relocation for operand %d in '%s' instruction"
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand
condition|)
block|{
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid relocation type %d for %s instruction"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
if|if
condition|(
operator|!
name|operand_is_pcrel_label
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid relocation for operand %d of '%s'"
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
if|if
condition|(
operator|!
name|xtensa_operand_isPCRelative
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"non-PCREL relocation operand %d for '%s': %s"
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
return|return
literal|0
operator|-
name|xtensa_operand_do_reloc
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* tc_symbol_new_hook */
end_comment

begin_function
name|void
name|xtensa_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|symbol_get_tc
argument_list|(
name|symbolP
argument_list|)
operator|->
name|plt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tc_fix_adjustable hook */
end_comment

begin_function
name|bfd_boolean
name|xtensa_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
block|{
comment|/* This happens when the relocation is within the current section.           It seems this implies a PCREL operation.  We'll catch it and error           if not.  */
name|char
modifier|*
specifier|const
name|fixpos
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_XTENSA_ASM_SIMPLIFY
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unhandled local relocation fix %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_8
case|:
comment|/* The only one we support that isn't an instruction field.  */
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
operator|*
name|valP
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_XTENSA_OP0
case|:
case|case
name|BFD_RELOC_XTENSA_OP1
case|:
case|case
name|BFD_RELOC_XTENSA_OP2
case|:
name|isa
operator|=
name|xtensa_default_isa
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|fixpos
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable FIX"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_set_immediate_field
argument_list|(
name|opcode
argument_list|,
name|insnbuf
argument_list|,
operator|*
name|valP
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|fixpos
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unhandled local relocation fix %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|idx
init|=
name|i
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|idx
operator|=
operator|(
name|prec
operator|-
literal|1
operator|-
name|i
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|idx
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* Make sure none of our internal relocations make it this far.      They'd better have been fully resolved by this point.  */
name|assert
argument_list|(
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent `%s' relocation in object file"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|!=
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error? cannot generate `%s' relocation"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_XTENSA_OP0
case|:
case|case
name|BFD_RELOC_XTENSA_OP1
case|:
case|case
name|BFD_RELOC_XTENSA_OP2
case|:
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_XTENSA_PLT
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
break|break;
case|case
name|BFD_RELOC_XTENSA_ASM_SIMPLIFY
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"emitting simplification relocation"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"emitting unknown relocation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|xtensa_end
parameter_list|()
block|{
name|directive_balance
argument_list|()
expr_stmt|;
name|xtensa_move_literals
argument_list|()
expr_stmt|;
name|xtensa_reorder_segments
argument_list|()
expr_stmt|;
name|xtensa_cleanup_align_frags
argument_list|()
expr_stmt|;
name|xtensa_fix_target_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|software_a0_b_retw_interlock
operator|&&
name|has_a0_b_retw
condition|)
name|xtensa_fix_a0_b_retw_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|software_avoid_b_j_loop_end
operator|&&
name|maybe_has_b_j_loop_end
condition|)
name|xtensa_fix_b_j_loop_end_frags
argument_list|()
expr_stmt|;
comment|/* "close_loop_end" should be processed BEFORE "short_loop".  */
if|if
condition|(
name|software_avoid_close_loop_end
operator|&&
name|maybe_has_close_loop_end
condition|)
name|xtensa_fix_close_loop_end_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|software_avoid_short_loop
operator|&&
name|maybe_has_short_loop
condition|)
name|xtensa_fix_short_loop_frags
argument_list|()
expr_stmt|;
name|xtensa_sanity_check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_cleanup_align_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|||
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
operator|)
operator|)
operator|)
operator|&&
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
block|{
name|fragS
modifier|*
name|next
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|next
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
condition|)
block|{
name|frag_wane
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_DESIRE_ALIGN_IF_TARGET fragments.  If there is a branch    target in the next fragment, convert this to RELAX_DESIRE_ALIGN.    If the next fragment starts with a loop target, AND the previous    fragment can be expanded to negate the branch, convert this to a    RELAX_LOOP_END.  Otherwise, convert to a .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_target_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|bfd_boolean
name|prev_frag_can_negate_branch
init|=
name|FALSE
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
condition|)
block|{
if|if
condition|(
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev_frag_can_negate_branch
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LOOP_END
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|align_only_targets
operator|||
name|next_frag_is_branch_target
argument_list|(
name|fragP
argument_list|)
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_DESIRE_ALIGN
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|align_only_targets
operator|||
name|next_frag_is_branch_target
argument_list|(
name|fragP
argument_list|)
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_DESIRE_ALIGN
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
name|prev_frag_can_negate_branch
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|frag_can_negate_branch
argument_list|(
name|fragP
argument_list|)
condition|)
name|prev_frag_can_negate_branch
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|frag_can_negate_branch
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_IMMED
condition|)
block|{
name|TInsn
name|t_insn
decl_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_negatable_branch
argument_list|(
operator|&
name|t_insn
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_A0_B_RETW.  If the next instruction is a    conditional branch or a retw/retw.n, convert this frag to one that    will generate a NOP.  In any case close it off with a .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_a0_b_retw_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_A0_B_RETW
condition|)
block|{
if|if
condition|(
name|next_instrs_are_b_retw
argument_list|(
name|fragP
argument_list|)
condition|)
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|bfd_boolean
name|next_instrs_are_b_retw
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check for the conditional branch.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|&
name|next_fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_conditional_branch_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|offset
operator|+=
name|xtensa_insn_length
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|next_fragP
operator|->
name|fr_fix
condition|)
block|{
name|next_fragP
operator|=
name|next_non_empty_frag
argument_list|(
name|next_fragP
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check for the retw/retw.n.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|&
name|next_fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_windowed_return_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_PRE_LOOP_END.  If there is one instruction and a    loop end label, convert this frag to one that will generate a NOP.    In any case close it off with a .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_b_j_loop_end_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_PRE_LOOP_END
condition|)
block|{
if|if
condition|(
name|next_instr_is_loop_end
argument_list|(
name|fragP
argument_list|)
condition|)
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|bfd_boolean
name|next_instr_is_loop_end
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|const
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|next_fragP
operator|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|next_frag_is_loop_target
argument_list|(
name|next_fragP
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the size is>= 3 then there is more than one instruction here.      The hardware bug will not fire.  */
if|if
condition|(
name|next_fragP
operator|->
name|fr_fix
operator|>
literal|3
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_CLOSE_LOOP_END.  If there is an loop end that is    not MY loop's loop end within 12 bytes, add enough nops here to    make it at least 12 bytes away.  In any case close it off with a    .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_close_loop_end_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
name|current_target
init|=
name|NULL
decl_stmt|;
name|offsetT
name|current_offset
init|=
literal|0
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_IMMED
condition|)
block|{
comment|/* Read it.  If the instruction is a loop, get the target.  */
name|xtensa_opcode
name|opcode
init|=
name|get_opcode_from_buf
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|TInsn
name|t_insn
decl_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Get the current fragment target.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|current_target
operator|=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|current_offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_target
operator|&&
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
condition|)
block|{
name|size_t
name|min_bytes
decl_stmt|;
name|size_t
name|bytes_added
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|REQUIRED_LOOP_DIVIDING_BYTES
value|12
comment|/* Max out at 12.  */
name|min_bytes
operator|=
name|min_bytes_to_other_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|current_target
argument_list|,
name|current_offset
argument_list|,
name|REQUIRED_LOOP_DIVIDING_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_bytes
operator|<
name|REQUIRED_LOOP_DIVIDING_BYTES
condition|)
block|{
while|while
condition|(
name|min_bytes
operator|+
name|bytes_added
operator|<
name|REQUIRED_LOOP_DIVIDING_BYTES
condition|)
block|{
name|int
name|length
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|<
name|length
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"fr_var %lu< length %d; ignoring"
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
name|assemble_nop
argument_list|(
name|length
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|length
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|length
expr_stmt|;
block|}
name|bytes_added
operator|+=
name|length
expr_stmt|;
block|}
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|size_t
name|min_bytes_to_other_loop_end
parameter_list|(
name|fragP
parameter_list|,
name|current_target
parameter_list|,
name|current_offset
parameter_list|,
name|max_size
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
name|current_target
decl_stmt|;
name|offsetT
name|current_offset
decl_stmt|;
name|size_t
name|max_size
decl_stmt|;
block|{
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|current_fragP
decl_stmt|;
for|for
control|(
name|current_fragP
operator|=
name|fragP
init|;
name|current_fragP
condition|;
name|current_fragP
operator|=
name|current_fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|current_fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
operator|&&
name|current_fragP
operator|!=
name|current_target
condition|)
return|return
name|offset
operator|+
name|current_offset
return|;
name|offset
operator|+=
name|unrelaxed_frag_min_size
argument_list|(
name|current_fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|current_offset
operator|>=
name|max_size
condition|)
return|return
name|max_size
return|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_function
name|size_t
name|unrelaxed_frag_min_size
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|size_t
name|size
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
comment|/* add fill size */
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
condition|)
name|size
operator|+=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all    of the RELAX_ADD_NOP_IF_SHORT_LOOP.  If:     A)      1) the instruction size count to the loop end label         is too short (<= 2 instructions),      2) loop has a jump or branch in it     or B)      1) software_avoid_all_short_loops is true      2) The generating loop was a  'loopgtz' or 'loopnez'      3) the instruction size count to the loop end label is too short         (<= 2 instructions)    then convert this frag (and maybe the next one) to generate a NOP.    In any case close it off with a .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_short_loop_frags
parameter_list|()
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
name|current_target
init|=
name|NULL
decl_stmt|;
name|offsetT
name|current_offset
init|=
literal|0
decl_stmt|;
name|xtensa_opcode
name|current_opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* check on the current loop */
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_IMMED
condition|)
block|{
comment|/* Read it.  If the instruction is a loop, get the target.  */
name|xtensa_opcode
name|opcode
init|=
name|get_opcode_from_buf
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|TInsn
name|t_insn
decl_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Get the current fragment target.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|current_target
operator|=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|current_offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|current_opcode
operator|=
name|opcode
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_SHORT_LOOP
condition|)
block|{
name|size_t
name|insn_count
init|=
name|count_insns_to_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|TRUE
argument_list|,
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn_count
operator|<
literal|3
operator|&&
operator|(
name|branch_before_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
operator|||
operator|(
name|software_avoid_all_short_loops
operator|&&
name|current_opcode
operator|!=
name|XTENSA_UNDEFINED
operator|&&
operator|!
name|is_the_loop_opcode
argument_list|(
name|current_opcode
argument_list|)
operator|)
operator|)
condition|)
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|size_t
name|count_insns_to_loop_end
parameter_list|(
name|base_fragP
parameter_list|,
name|count_relax_add
parameter_list|,
name|max_count
parameter_list|)
name|fragS
modifier|*
name|base_fragP
decl_stmt|;
name|bfd_boolean
name|count_relax_add
decl_stmt|;
name|size_t
name|max_count
decl_stmt|;
block|{
name|fragS
modifier|*
name|fragP
init|=
name|NULL
decl_stmt|;
name|size_t
name|insn_count
init|=
literal|0
decl_stmt|;
name|fragP
operator|=
name|base_fragP
expr_stmt|;
for|for
control|(
init|;
name|fragP
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|insn_count
operator|+=
name|unrelaxed_frag_min_insn_count
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_count
operator|>=
name|max_count
condition|)
return|return
name|max_count
return|;
if|if
condition|(
name|count_relax_add
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_SHORT_LOOP
condition|)
block|{
comment|/* In order to add the appropriate number of 	         NOPs, we count an instruction for downstream 	         occurrences.  */
name|insn_count
operator|++
expr_stmt|;
if|if
condition|(
name|insn_count
operator|>=
name|max_count
condition|)
return|return
name|max_count
return|;
block|}
block|}
block|}
return|return
name|insn_count
return|;
block|}
end_function

begin_function
name|size_t
name|unrelaxed_frag_min_insn_count
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|size_t
name|insn_count
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
return|return
name|insn_count
return|;
comment|/* Decode the fixed instructions.  */
while|while
condition|(
name|offset
operator|<
name|fragP
operator|->
name|fr_fix
condition|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|get_opcode_from_buf
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable instruction in instruction frag"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn_count
return|;
block|}
name|offset
operator|+=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|insn_count
operator|++
expr_stmt|;
block|}
return|return
name|insn_count
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|branch_before_loop_end
parameter_list|(
name|base_fragP
parameter_list|)
name|fragS
modifier|*
name|base_fragP
decl_stmt|;
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|base_fragP
init|;
name|fragP
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|unrelaxed_frag_has_b_j
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|unrelaxed_frag_has_b_j
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|size_t
name|insn_count
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
return|return
name|FALSE
return|;
comment|/* Decode the fixed instructions.  */
while|while
condition|(
name|offset
operator|<
name|fragP
operator|->
name|fr_fix
condition|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|get_opcode_from_buf
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable instruction in instruction frag"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn_count
return|;
block|}
if|if
condition|(
name|is_branch_or_jump_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|offset
operator|+=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Checks to be made after initial assembly but before relaxation.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_sanity_check
parameter_list|()
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|int
name|line
decl_stmt|;
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|frchP
operator|=
name|frchain_root
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* Currently we only check for empty loops here.  */
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_IMMED
condition|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|t_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_empty_loop
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
condition|)
block|{
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid empty loop"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_local_forward_loop
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
condition|)
block|{
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"loop target does not follow "
literal|"loop instruction in section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LOOP_IMMED_OPN
value|1
end_define

begin_comment
comment|/* Return true if the loop target is the next non-zero fragment.  */
end_comment

begin_function
name|bfd_boolean
name|is_empty_loop
parameter_list|(
name|insn
parameter_list|,
name|fragP
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|const
name|expressionS
modifier|*
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|!=
name|ITYPE_INSN
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|LOOP_IMMED_OPN
condition|)
return|return
name|FALSE
return|;
name|expr
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|LOOP_IMMED_OPN
index|]
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Walk through the zero-size fragments from this one.  If we find      the target fragment, then this is a zero-size loop.  */
for|for
control|(
name|next_fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|next_fragP
operator|!=
name|NULL
condition|;
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|next_fragP
operator|==
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|next_fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_local_forward_loop
parameter_list|(
name|insn
parameter_list|,
name|fragP
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|const
name|expressionS
modifier|*
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|!=
name|ITYPE_INSN
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_loop_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|LOOP_IMMED_OPN
condition|)
return|return
name|FALSE
return|;
name|expr
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|LOOP_IMMED_OPN
index|]
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Walk through fragments until we find the target.      If we do not find the target, then this is an invalid loop.  */
for|for
control|(
name|next_fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|next_fragP
operator|!=
name|NULL
condition|;
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
control|)
if|if
condition|(
name|next_fragP
operator|==
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Alignment Functions.  */
end_comment

begin_function
name|size_t
name|get_text_align_power
parameter_list|(
name|target_size
parameter_list|)
name|int
name|target_size
decl_stmt|;
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|target_size
operator|<=
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
return|return
name|i
return|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"get_text_align_power: argument too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|addressT
name|get_text_align_max_fill_size
parameter_list|(
name|align_pow
parameter_list|,
name|use_nops
parameter_list|,
name|use_no_density
parameter_list|)
name|int
name|align_pow
decl_stmt|;
name|bfd_boolean
name|use_nops
decl_stmt|;
name|bfd_boolean
name|use_no_density
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|use_nops
condition|)
return|return
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
if|if
condition|(
name|use_no_density
condition|)
return|return
literal|3
operator|*
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
return|return
literal|1
operator|+
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_text_align_fill_size ()       Desired alignments:       give the address       target_size = size of next instruction       align_pow = get_text_align_power (target_size).       use_nops = 0       use_no_density = 0;    Loop alignments:       address = current address + loop instruction size;       target_size = 3 (for 2 or 3 byte target)                   = 8 (for 8 byte target)       align_pow = get_text_align_power (target_size);       use_nops = 1       use_no_density = set appropriately    Text alignments:       address = current address + loop instruction size;       target_size = 0       align_pow = get_text_align_power (target_size);       use_nops = 0       use_no_density = 0.  */
end_comment

begin_function
name|addressT
name|get_text_align_fill_size
parameter_list|(
name|address
parameter_list|,
name|align_pow
parameter_list|,
name|target_size
parameter_list|,
name|use_nops
parameter_list|,
name|use_no_density
parameter_list|)
name|addressT
name|address
decl_stmt|;
name|int
name|align_pow
decl_stmt|;
name|int
name|target_size
decl_stmt|;
name|bfd_boolean
name|use_nops
decl_stmt|;
name|bfd_boolean
name|use_no_density
decl_stmt|;
block|{
comment|/* Input arguments:       align_pow: log2 (required alignment).       target_size: alignment must allow the new_address and      new_address+target_size-1.       use_nops: if true, then we can only use 2 or 3 byte nops.       use_no_density: if use_nops and use_no_density, we can only use      3-byte nops.       Usually, for non-zero target_size, the align_pow is the power of 2      that is greater than or equal to the target_size.  This handles the      2-byte, 3-byte and 8-byte instructions.  */
name|size_t
name|alignment
init|=
operator|(
literal|1
operator|<<
name|align_pow
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|use_nops
condition|)
block|{
comment|/* This is the easy case.  */
name|size_t
name|mod
decl_stmt|;
name|mod
operator|=
name|address
operator|%
name|alignment
expr_stmt|;
if|if
condition|(
name|mod
operator|!=
literal|0
condition|)
name|mod
operator|=
name|alignment
operator|-
name|mod
expr_stmt|;
name|assert
argument_list|(
operator|(
name|address
operator|+
name|mod
operator|)
operator|%
name|alignment
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|mod
return|;
block|}
comment|/* This is the slightly harder case.  */
name|assert
argument_list|(
operator|(
name|int
operator|)
name|alignment
operator|>=
name|target_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|target_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_no_density
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alignment
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|address
operator|+
name|i
operator|)
operator|>>
name|align_pow
operator|==
operator|(
name|address
operator|+
name|i
operator|+
name|target_size
operator|-
literal|1
operator|)
operator|>>
name|align_pow
condition|)
return|return
name|i
return|;
block|}
block|}
else|else
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Can only fill multiples of 3.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|alignment
operator|*
literal|3
condition|;
name|i
operator|+=
literal|3
control|)
block|{
if|if
condition|(
operator|(
name|address
operator|+
name|i
operator|)
operator|>>
name|align_pow
operator|==
operator|(
name|address
operator|+
name|i
operator|+
name|target_size
operator|-
literal|1
operator|)
operator|>>
name|align_pow
condition|)
return|return
name|i
return|;
block|}
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This will assert if it is not possible.  */
end_comment

begin_function
name|size_t
name|get_text_align_nop_count
parameter_list|(
name|fill_size
parameter_list|,
name|use_no_density
parameter_list|)
name|size_t
name|fill_size
decl_stmt|;
name|bfd_boolean
name|use_no_density
decl_stmt|;
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_no_density
condition|)
block|{
name|assert
argument_list|(
name|fill_size
operator|%
literal|3
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|fill_size
operator|/
literal|3
operator|)
return|;
block|}
name|assert
argument_list|(
name|fill_size
operator|!=
literal|1
argument_list|)
expr_stmt|;
comment|/* Bad argument.  */
while|while
condition|(
name|fill_size
operator|>
literal|1
condition|)
block|{
name|size_t
name|insn_size
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|2
operator|||
name|fill_size
operator|==
literal|4
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fill_size
operator|-=
name|insn_size
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|fill_size
operator|!=
literal|1
argument_list|)
expr_stmt|;
comment|/* Bad algorithm.  */
return|return
name|count
return|;
block|}
end_function

begin_function
name|size_t
name|get_text_align_nth_nop_size
parameter_list|(
name|fill_size
parameter_list|,
name|n
parameter_list|,
name|use_no_density
parameter_list|)
name|size_t
name|fill_size
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|bfd_boolean
name|use_no_density
decl_stmt|;
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|get_text_align_nop_count
argument_list|(
name|fill_size
argument_list|,
name|use_no_density
argument_list|)
operator|>
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_no_density
condition|)
return|return
literal|3
return|;
while|while
condition|(
name|fill_size
operator|>
literal|1
condition|)
block|{
name|size_t
name|insn_size
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|2
operator|||
name|fill_size
operator|==
literal|4
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fill_size
operator|-=
name|insn_size
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|==
name|count
condition|)
return|return
name|insn_size
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For the given fragment, find the appropriate address    for it to begin at if we are using NOPs to align it.  */
end_comment

begin_function
specifier|static
name|addressT
name|get_noop_aligned_address
parameter_list|(
name|fragP
parameter_list|,
name|address
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|addressT
name|address
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|fill_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_machine_dependent
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
condition|)
block|{
comment|/* The rule is: get next fragment's FIRST instruction.  Find 	     the smallest number of bytes that need to be added to 	     ensure that the next fragment's FIRST instruction will fit 	     in a single word.  	     E.G.,   2 bytes : 0, 1, 2 mod 4  		     3 bytes: 0, 1 mod 4   	     If the FIRST instruction MIGHT be relaxed,  	     assume that it will become a 3 byte instruction.  */
name|int
name|target_insn_size
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|next_frag_opcode
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
name|addressT
name|pre_opcode_bytes
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"invalid opcode for RELAX_ALIGN_NEXT_OPCODE"
argument_list|)
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot continue"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target_insn_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|pre_opcode_bytes
operator|=
name|next_frag_pre_opcode_bytes
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
comment|/* next_fragP should be the loop.  */
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
name|xtensa_opcode
name|next_opcode
init|=
name|next_frag_opcode
argument_list|(
name|next_fragP
argument_list|)
decl_stmt|;
name|size_t
name|alignment
decl_stmt|;
name|pre_opcode_bytes
operator|+=
name|target_insn_size
expr_stmt|;
comment|/* For loops, the alignment depends on the size of the 		 instruction following the loop, not the loop instruction.  */
if|if
condition|(
name|next_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|target_insn_size
operator|=
literal|3
expr_stmt|;
else|else
block|{
name|target_insn_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|next_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_insn_size
operator|==
literal|2
condition|)
name|target_insn_size
operator|=
literal|3
expr_stmt|;
comment|/* ISA specifies this.  */
block|}
comment|/* If it was 8, then we'll need a larger alignment 	         for the section.  */
name|alignment
operator|=
name|get_text_align_power
argument_list|(
name|target_insn_size
argument_list|)
expr_stmt|;
comment|/* Is Now_seg valid */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected loop opcode in relax align next target"
argument_list|)
argument_list|)
expr_stmt|;
name|fill_size
operator|=
name|get_text_align_fill_size
argument_list|(
name|address
operator|+
name|pre_opcode_bytes
argument_list|,
name|get_text_align_power
argument_list|(
name|target_insn_size
argument_list|)
argument_list|,
name|target_insn_size
argument_list|,
name|TRUE
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case rs_align:     case rs_align_code:       fill_size = get_text_align_fill_size 	(address, fragP->fr_offset, 1, TRUE, 	 fragP->tc_frag_data.is_no_density);       break;
endif|#
directive|endif
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"expected align_code or RELAX_ALIGN_NEXT_OPCODE"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|address
operator|+
name|fill_size
return|;
block|}
end_function

begin_comment
comment|/* 3 mechanisms for relaxing an alignment:         Align to a power of 2.     Align so the next fragment's instruction does not cross a word boundary.     Align the current instruction so that if the next instruction         were 3 bytes, it would not cross a word boundary.         We can align with:     zeros    - This is easy; always insert zeros.     nops     - 3 and 2 byte instructions                2 - 2 byte nop                3 - 3 byte nop                4 - 2, 2-byte nops>=5 : 3 byte instruction + fn(n-3)     widening - widen previous instructions.  */
end_comment

begin_function
specifier|static
name|addressT
name|get_widen_aligned_address
parameter_list|(
name|fragP
parameter_list|,
name|address
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|addressT
name|address
decl_stmt|;
block|{
name|addressT
name|align_pow
decl_stmt|,
name|new_address
decl_stmt|,
name|loop_insn_offset
decl_stmt|;
name|fragS
modifier|*
name|next_frag
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|,
name|next_opcode
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
condition|)
block|{
name|align_pow
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|new_address
operator|=
operator|(
operator|(
name|address
operator|+
operator|(
operator|(
literal|1
operator|<<
name|align_pow
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|align_pow
operator|)
operator|>>
name|align_pow
expr_stmt|;
return|return
name|new_address
return|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
condition|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* The rule is: get the next fragment's FIRST instruction.  	     Find the smallest number of bytes needed to be added  	     in order to ensure that the next fragment is FIRST  	     instruction will fit in a single word.  	     i.e.    2 bytes : 0, 1, 2.  mod 4  	             3 bytes: 0, 1 mod 4  	     If the FIRST instruction MIGHT be relaxed,  	     assume that it will become a 3-byte instruction.  */
name|insn_size
operator|=
literal|3
expr_stmt|;
comment|/* Check to see if it might be 2 bytes.  */
name|next_opcode
operator|=
name|next_frag_opcode
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_opcode
operator|!=
name|XTENSA_UNDEFINED
operator|&&
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|next_opcode
argument_list|)
operator|==
literal|2
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|assert
argument_list|(
name|insn_size
operator|<=
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|new_address
operator|=
name|address
init|;
name|new_address
operator|<
name|address
operator|+
literal|4
condition|;
name|new_address
operator|++
control|)
block|{
if|if
condition|(
name|new_address
operator|>>
literal|2
operator|==
operator|(
name|new_address
operator|+
name|insn_size
operator|-
literal|1
operator|)
operator|>>
literal|2
condition|)
return|return
name|new_address
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal error aligning"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
comment|/* The rule is: get next fragment's FIRST instruction.  	     Find the smallest number of bytes needed to be added  	     in order to ensure that the next fragment's FIRST  	     instruction will fit in a single word.  	     i.e.    2 bytes : 0, 1, 2.  mod 4  	             3 bytes: 0, 1 mod 4  	     If the FIRST instruction MIGHT be relaxed,  	     assume that it will become a 3 byte instruction.  */
name|opcode
operator|=
name|next_frag_opcode
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"invalid opcode for RELAX_ALIGN_NEXT_OPCODE"
argument_list|)
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot continue"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn_size
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_loop_opcode
argument_list|(
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|loop_insn_offset
operator|=
literal|0
expr_stmt|;
name|next_frag
operator|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/* If the loop has been expanded then the loop 	     instruction could be at an offset from this fragment.  */
if|if
condition|(
name|next_frag
operator|->
name|fr_subtype
operator|!=
name|RELAX_IMMED
condition|)
name|loop_insn_offset
operator|=
name|get_expanded_loop_offset
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|new_address
operator|=
name|address
init|;
name|new_address
operator|<
name|address
operator|+
literal|4
condition|;
name|new_address
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|new_address
operator|+
name|loop_insn_offset
operator|+
name|insn_size
operator|)
operator|>>
literal|2
operator|==
operator|(
name|new_address
operator|+
name|loop_insn_offset
operator|+
name|insn_size
operator|+
literal|2
operator|)
operator|>>
literal|2
condition|)
return|return
name|new_address
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal error aligning"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal error aligning"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal error aligning"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_relax_frag Hook and Helper Functions.  */
end_comment

begin_comment
comment|/* Return the number of bytes added to this fragment, given that the    input has been stretched already by "stretch".  */
end_comment

begin_function
name|long
name|xtensa_relax_frag
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|,
name|stretched_p
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
name|int
modifier|*
name|stretched_p
decl_stmt|;
block|{
name|int
name|unreported
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
decl_stmt|;
name|long
name|new_stretch
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|int
name|line
decl_stmt|,
name|lit_size
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
comment|/* Always convert.  */
name|new_stretch
operator|=
name|relax_frag_text_align
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_LOOP_END
case|:
comment|/* Do nothing.  */
break|break;
case|case
name|RELAX_LOOP_END_ADD_NOP
case|:
comment|/* Add a NOP and switch to .fill 0.  */
name|new_stretch
operator|=
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* We REALLY want to change the relaxation order here.  This          should do NOTHING.  The narrowing before it will either align          it or not.  */
break|break;
case|case
name|RELAX_LITERAL
case|:
case|case
name|RELAX_LITERAL_FINAL
case|:
return|return
literal|0
return|;
case|case
name|RELAX_LITERAL_NR
case|:
name|lit_size
operator|=
literal|4
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_FINAL
expr_stmt|;
name|assert
argument_list|(
name|unreported
operator|==
name|lit_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|lit_size
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|lit_size
expr_stmt|;
name|new_stretch
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|RELAX_NARROW
case|:
name|new_stretch
operator|=
name|relax_frag_narrow
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
case|case
name|RELAX_IMMED_STEP1
case|:
case|case
name|RELAX_IMMED_STEP2
case|:
comment|/* Place the immediate.  */
name|new_stretch
operator|=
name|relax_frag_immed
argument_list|(
name|now_seg
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|,
name|fragP
operator|->
name|fr_subtype
operator|-
name|RELAX_IMMED
argument_list|,
name|stretched_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_LITERAL_POOL_BEGIN
case|:
case|case
name|RELAX_LITERAL_POOL_END
case|:
comment|/* No relaxation required.  */
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relaxation state"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|new_stretch
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|relax_frag_text_align
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
name|addressT
name|old_address
decl_stmt|,
name|old_next_address
decl_stmt|,
name|old_size
decl_stmt|;
name|addressT
name|new_address
decl_stmt|,
name|new_next_address
decl_stmt|,
name|new_size
decl_stmt|;
name|addressT
name|growth
decl_stmt|;
comment|/* Overview of the relaxation procedure for alignment      inside an executable section:           The old size is stored in the tc_frag_data.text_expansion field.           Calculate the new address, fix up the text_expansion and      return the growth.  */
comment|/* Calculate the old address of this fragment and the next fragment.  */
name|old_address
operator|=
name|fragP
operator|->
name|fr_address
operator|-
name|stretch
expr_stmt|;
name|old_next_address
operator|=
operator|(
name|fragP
operator|->
name|fr_address
operator|-
name|stretch
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|)
expr_stmt|;
name|old_size
operator|=
name|old_next_address
operator|-
name|old_address
expr_stmt|;
comment|/* Calculate the new address of this fragment and the next fragment.  */
name|new_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|new_next_address
operator|=
name|get_noop_aligned_address
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|new_next_address
operator|-
name|new_address
expr_stmt|;
name|growth
operator|=
name|new_size
operator|-
name|old_size
expr_stmt|;
comment|/* Fix up the text_expansion field and return the new growth.  */
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|+=
name|growth
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Add a NOP (i.e., "or a1, a1, a1").  Use the 3-byte one because we    don't know about the availability of density yet.  TODO: When the    flags are stored per fragment, use NOP.N when possible.  */
end_comment

begin_function
specifier|static
name|long
name|relax_frag_add_nop
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|;
name|char
modifier|*
name|nop_buf
init|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|t_insn
argument_list|)
expr_stmt|;
name|t_insn
operator|.
name|opcode
operator|=
name|xtensa_or_opcode
expr_stmt|;
name|assert
argument_list|(
name|t_insn
operator|.
name|opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|t_insn
operator|.
name|ntok
operator|=
literal|3
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|t_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
name|nop_buf
argument_list|)
expr_stmt|;
name|length
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|<
name|length
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"fr_var (%ld)< length (%d); ignoring"
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|length
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|length
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|relax_frag_narrow
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
comment|/* Overview of the relaxation procedure for alignment inside an      executable section: Find the number of widenings required and the      number of nop bytes required. Store the number of bytes ALREADY      widened. If there are enough instructions to widen (must go back      ONLY through NARROW fragments), mark each of the fragments as TO BE      widened, recalculate the fragment addresses.  */
name|assert
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_NARROW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|future_alignment_required
argument_list|(
name|fragP
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If already expanded but no longer needed because of a prior          stretch, it is SAFE to unexpand because the next fragment will          NEVER start at an address> the previous time through the          relaxation.  */
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
condition|)
block|{
if|if
condition|(
name|stretch
operator|>
literal|0
condition|)
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Otherwise we have to live with this bad choice.  */
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|future_alignment_required
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
name|long
name|address
init|=
name|fragP
operator|->
name|fr_address
operator|+
name|stretch
decl_stmt|;
name|int
name|num_widens
init|=
literal|0
decl_stmt|;
name|addressT
name|aligned_address
decl_stmt|;
name|offsetT
name|desired_diff
decl_stmt|;
while|while
condition|(
name|fragP
condition|)
block|{
comment|/* Limit this to a small search.  */
if|if
condition|(
name|num_widens
operator|>
literal|8
condition|)
return|return
name|FALSE
return|;
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_machine_dependent
case|:
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_NARROW
case|:
comment|/* address += fragP->fr_fix; */
name|num_widens
operator|++
expr_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
name|address
operator|+=
operator|(
comment|/* fragP->fr_fix + */
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|)
expr_stmt|;
break|break;
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* address += fragP->fr_fix; */
name|aligned_address
operator|=
name|get_widen_aligned_address
argument_list|(
name|fragP
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|desired_diff
operator|=
name|aligned_address
operator|-
name|address
expr_stmt|;
name|assert
argument_list|(
name|desired_diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are enough wideners in between do it.  */
comment|/* return (num_widens == desired_diff); */
if|if
condition|(
name|num_widens
operator|==
name|desired_diff
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|relax_frag_immed
parameter_list|(
name|segP
parameter_list|,
name|fragP
parameter_list|,
name|stretch
parameter_list|,
name|min_steps
parameter_list|,
name|stretched_p
parameter_list|)
name|segT
name|segP
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
name|int
name|min_steps
decl_stmt|;
name|int
modifier|*
name|stretched_p
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|;
name|int
name|old_size
decl_stmt|;
name|bfd_boolean
name|negatable_branch
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|branch_jmp_to_next
init|=
name|FALSE
decl_stmt|;
name|IStack
name|istack
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
name|int
name|num_steps
decl_stmt|;
name|fragS
modifier|*
name|lit_fragP
decl_stmt|;
name|int
name|num_text_bytes
decl_stmt|,
name|num_literal_bytes
decl_stmt|;
name|int
name|literal_diff
decl_stmt|,
name|text_diff
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
name|negatable_branch
operator|=
name|is_negatable_branch
argument_list|(
operator|&
name|t_insn
argument_list|)
expr_stmt|;
name|old_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|software_avoid_b_j_loop_end
condition|)
name|branch_jmp_to_next
operator|=
name|is_branch_jmp_to_next
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Special case: replace a branch to the next instruction with a NOP.      This is required to work around a hardware bug in T1040.0 and also      serves as an optimization.  */
if|if
condition|(
name|branch_jmp_to_next
operator|&&
operator|(
operator|(
name|old_size
operator|==
literal|2
operator|)
operator|||
operator|(
name|old_size
operator|==
literal|3
operator|)
operator|)
operator|&&
operator|!
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Here is the fun stuff: Get the immediate field from this      instruction.  If it fits, we are done.  If not, find the next      instruction sequence that fits.  */
name|frag_offset
operator|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|num_steps
operator|=
name|xg_assembly_relax
argument_list|(
operator|&
name|istack
argument_list|,
operator|&
name|t_insn
argument_list|,
name|segP
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|min_steps
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_steps
operator|<
name|min_steps
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: relaxation failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|num_steps
operator|>
name|RELAX_IMMED_MAXSTEPS
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: relaxation requires too many steps"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|->
name|fr_subtype
operator|=
operator|(
name|int
operator|)
name|RELAX_IMMED
operator|+
name|num_steps
expr_stmt|;
comment|/* Figure out the number of bytes needed.  */
name|lit_fragP
operator|=
literal|0
expr_stmt|;
name|num_text_bytes
operator|=
name|get_num_stack_text_bytes
argument_list|(
operator|&
name|istack
argument_list|)
operator|-
name|old_size
expr_stmt|;
name|num_literal_bytes
operator|=
name|get_num_stack_literal_bytes
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|literal_diff
operator|=
name|num_literal_bytes
operator|-
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_expansion
expr_stmt|;
name|text_diff
operator|=
name|num_text_bytes
operator|-
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
expr_stmt|;
comment|/* It MUST get larger.  If not, we could get an infinite loop.  */
name|know
argument_list|(
name|num_text_bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|literal_diff
operator|>=
literal|0
operator|&&
name|text_diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|=
name|num_text_bytes
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_expansion
operator|=
name|num_literal_bytes
expr_stmt|;
comment|/* Find the associated expandable literal for this.  */
if|if
condition|(
name|literal_diff
operator|!=
literal|0
condition|)
block|{
name|lit_fragP
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
if|if
condition|(
name|lit_fragP
condition|)
block|{
name|assert
argument_list|(
name|literal_diff
operator|==
literal|4
argument_list|)
expr_stmt|;
name|lit_fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|+=
name|literal_diff
expr_stmt|;
comment|/* We expect that the literal section state has NOT been 	     modified yet.  */
name|assert
argument_list|(
name|lit_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|lit_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL
argument_list|)
expr_stmt|;
name|lit_fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_NR
expr_stmt|;
comment|/* We need to mark this section for another iteration 	     of relaxation.  */
operator|(
operator|*
name|stretched_p
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* This implicitly uses the assumption that a branch is negated      when the size of the output increases by at least 2 bytes.  */
if|if
condition|(
name|negatable_branch
operator|&&
name|num_text_bytes
operator|>=
literal|2
condition|)
block|{
comment|/* If next frag is a loop end, then switch it to add a NOP.  */
name|update_next_frag_nop_state
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
return|return
name|text_diff
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_convert_frag Hook and Helper Functions.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|int
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragp
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
comment|/* Always convert.  */
name|convert_frag_align_next_opcode
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* Do nothing.  If not aligned already, too bad.  */
break|break;
case|case
name|RELAX_LITERAL
case|:
case|case
name|RELAX_LITERAL_FINAL
case|:
break|break;
case|case
name|RELAX_NARROW
case|:
comment|/* No conversion.  */
name|convert_frag_narrow
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
case|case
name|RELAX_IMMED_STEP1
case|:
case|case
name|RELAX_IMMED_STEP2
case|:
comment|/* Place the immediate.  */
name|convert_frag_immed
argument_list|(
name|sec
argument_list|,
name|fragp
argument_list|,
name|fragp
operator|->
name|fr_subtype
operator|-
name|RELAX_IMMED
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_LITERAL_NR
case|:
if|if
condition|(
name|use_literal_section
condition|)
block|{
comment|/* This should have been handled during relaxation.  When 	     relaxing a code segment, literals sometimes need to be 	     added to the corresponding literal segment.  If that 	     literal segment has already been relaxed, then we end up 	     in this situation.  Marking the literal segments as data 	     would make this happen less often (since GAS always relaxes 	     code before data), but we could still get into trouble if 	     there are instructions in a segment that is not marked as 	     containing code.  Until we can implement a better solution, 	     cheat and adjust the addresses of all the following frags. 	     This could break subsequent alignments, but the linker's 	     literal coalescing will do that anyway.  */
name|fragS
modifier|*
name|f
decl_stmt|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_FINAL
expr_stmt|;
name|assert
argument_list|(
name|fragp
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|==
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fragp
operator|->
name|fr_literal
index|[
name|fragp
operator|->
name|fr_fix
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|-=
literal|4
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fragp
operator|->
name|fr_next
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
name|f
operator|->
name|fr_address
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid relaxation fragment result"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragp
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_frag_align_next_opcode
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
name|char
modifier|*
name|nop_buf
decl_stmt|;
comment|/* Location for Writing.  */
name|size_t
name|i
decl_stmt|;
name|bfd_boolean
name|use_no_density
init|=
name|fragp
operator|->
name|tc_frag_data
operator|.
name|is_no_density
decl_stmt|;
name|addressT
name|aligned_address
decl_stmt|;
name|size_t
name|fill_size
decl_stmt|,
name|nop_count
decl_stmt|;
name|aligned_address
operator|=
name|get_noop_aligned_address
argument_list|(
name|fragp
argument_list|,
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fill_size
operator|=
name|aligned_address
operator|-
operator|(
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
operator|)
expr_stmt|;
name|nop_count
operator|=
name|get_text_align_nop_count
argument_list|(
name|fill_size
argument_list|,
name|use_no_density
argument_list|)
expr_stmt|;
name|nop_buf
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nop_count
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|nop_size
decl_stmt|;
name|nop_size
operator|=
name|get_text_align_nth_nop_size
argument_list|(
name|fill_size
argument_list|,
name|i
argument_list|,
name|use_no_density
argument_list|)
expr_stmt|;
name|assemble_nop
argument_list|(
name|nop_size
argument_list|,
name|nop_buf
argument_list|)
expr_stmt|;
name|nop_buf
operator|+=
name|nop_size
expr_stmt|;
block|}
name|fragp
operator|->
name|fr_fix
operator|+=
name|fill_size
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|-=
name|fill_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_frag_narrow
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|,
name|single_target
decl_stmt|;
name|int
name|size
decl_stmt|,
name|old_size
decl_stmt|,
name|diff
decl_stmt|,
name|error_val
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
operator|==
literal|0
condition|)
block|{
comment|/* No conversion.  */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Just convert it to a wide form....  */
name|size
operator|=
literal|0
expr_stmt|;
name|old_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|single_target
argument_list|)
expr_stmt|;
name|frag_offset
operator|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
name|error_val
operator|=
name|xg_expand_narrow
argument_list|(
operator|&
name|single_target
argument_list|,
operator|&
name|t_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_val
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unable to widen instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|single_target
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|xg_emit_insn_to_buf
argument_list|(
operator|&
name|single_target
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|diff
operator|=
name|size
operator|-
name|old_size
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|<=
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|diff
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|diff
expr_stmt|;
comment|/* clean it up */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_frag_immed
parameter_list|(
name|segP
parameter_list|,
name|fragP
parameter_list|,
name|min_steps
parameter_list|)
name|segT
name|segP
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|int
name|min_steps
decl_stmt|;
block|{
name|char
modifier|*
name|immed_instr
init|=
name|fragP
operator|->
name|fr_opcode
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|orig_t_insn
decl_stmt|;
name|bfd_boolean
name|expanded
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|fr_opcode
init|=
name|fragP
operator|->
name|fr_opcode
decl_stmt|;
name|bfd_boolean
name|branch_jmp_to_next
init|=
name|FALSE
decl_stmt|;
name|int
name|size
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|orig_t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|orig_t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Here is the fun stuff:  Get the immediate field from this      instruction.  If it fits, we're done.  If not, find the next      instruction sequence that fits.  */
if|if
condition|(
name|software_avoid_b_j_loop_end
condition|)
name|branch_jmp_to_next
operator|=
name|is_branch_jmp_to_next
argument_list|(
operator|&
name|orig_t_insn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_jmp_to_next
operator|&&
operator|!
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
comment|/* Conversion just inserts a NOP and marks the fix as completed.  */
name|size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_t_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|assemble_nop
argument_list|(
name|size
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|IStack
name|istack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
name|int
name|total_size
init|=
literal|0
decl_stmt|;
name|int
name|old_size
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|symbolS
modifier|*
name|gen_label
init|=
name|NULL
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
comment|/* It does not fit.  Find something that does and           convert immediately.  */
name|frag_offset
operator|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|xg_assembly_relax
argument_list|(
operator|&
name|istack
argument_list|,
operator|&
name|orig_t_insn
argument_list|,
name|segP
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|min_steps
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_t_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
comment|/* Assemble this right inline.  */
comment|/* First, create the mapping from a label name to the REAL label.  */
name|total_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|t_insn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|lit_frag
decl_stmt|;
switch|switch
condition|(
name|t_insn
operator|->
name|insn_type
condition|)
block|{
case|case
name|ITYPE_LITERAL
case|:
if|if
condition|(
name|lit_sym
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple literals in expansion"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First find the appropriate space in the literal pool.  */
name|lit_frag
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
if|if
condition|(
name|lit_frag
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no registered fragment for literal"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_insn
operator|->
name|ntok
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"number of literal tokens != 1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the literal symbol and add a fixup.  */
name|lit_sym
operator|=
name|lit_frag
operator|->
name|fr_symbol
expr_stmt|;
break|break;
case|case
name|ITYPE_LABEL
case|:
name|assert
argument_list|(
name|gen_label
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|gen_label
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
name|total_size
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITYPE_INSN
case|:
name|size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|size
expr_stmt|;
break|break;
block|}
block|}
name|total_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|t_insn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
name|fragS
modifier|*
name|lit_frag
decl_stmt|;
name|int
name|size
decl_stmt|;
name|segT
name|target_seg
decl_stmt|;
switch|switch
condition|(
name|t_insn
operator|->
name|insn_type
condition|)
block|{
case|case
name|ITYPE_LITERAL
case|:
name|lit_frag
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
comment|/* already checked */
name|assert
argument_list|(
name|lit_frag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lit_sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t_insn
operator|->
name|ntok
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* add a fixup */
name|target_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|lit_sym
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|target_seg
argument_list|)
expr_stmt|;
name|fix_new_exp_in_seg
argument_list|(
name|target_seg
argument_list|,
literal|0
argument_list|,
name|lit_frag
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
operator|&
name|t_insn
operator|->
name|tok
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITYPE_LABEL
case|:
break|break;
case|case
name|ITYPE_INSN
case|:
name|xg_resolve_labels
argument_list|(
name|t_insn
argument_list|,
name|gen_label
argument_list|)
expr_stmt|;
name|xg_resolve_literals
argument_list|(
name|t_insn
argument_list|,
name|lit_sym
argument_list|)
expr_stmt|;
name|size
operator|=
name|xtensa_insn_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|size
expr_stmt|;
name|xg_emit_insn_to_buf
argument_list|(
name|t_insn
argument_list|,
name|immed_instr
argument_list|,
name|fragP
argument_list|,
name|immed_instr
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|immed_instr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
block|}
name|diff
operator|=
name|total_size
operator|-
name|old_size
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
name|expanded
operator|=
name|TRUE
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|<=
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|diff
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|diff
expr_stmt|;
block|}
comment|/* Clean it up.  */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
comment|/* Check for undefined immediates in LOOP instructions.  */
if|if
condition|(
name|is_loop_opcode
argument_list|(
name|orig_t_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|orig_t_insn
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unresolved loop target symbol: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|=
name|orig_t_insn
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_op_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unresolved loop target symbol: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|expanded
operator|&&
name|is_loop_opcode
argument_list|(
name|orig_t_insn
operator|.
name|opcode
argument_list|)
condition|)
name|convert_frag_immed_finish_loop
argument_list|(
name|segP
argument_list|,
name|fragP
argument_list|,
operator|&
name|orig_t_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
operator|&&
name|is_direct_call_opcode
argument_list|(
name|orig_t_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
comment|/* Add an expansion note on the expanded instruction.  */
name|fix_new_exp_in_seg
argument_list|(
name|now_seg
argument_list|,
literal|0
argument_list|,
name|fragP
argument_list|,
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|orig_t_insn
operator|.
name|tok
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_XTENSA_ASM_EXPAND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a new fix expression into the desired segment.  We have to    switch to that segment to do this.  */
end_comment

begin_function
specifier|static
name|fixS
modifier|*
name|fix_new_exp_in_seg
parameter_list|(
name|new_seg
parameter_list|,
name|new_subseg
parameter_list|,
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
name|segT
name|new_seg
decl_stmt|;
name|subsegT
name|new_subseg
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
name|segT
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|assert
argument_list|(
name|new_seg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|new_seg
argument_list|,
name|new_subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_32
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|&&
name|symbol_get_tc
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|->
name|plt
operator|==
literal|1
condition|)
block|{
name|r_type
operator|=
name|BFD_RELOC_XTENSA_PLT
expr_stmt|;
block|}
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
return|return
name|new_fix
return|;
block|}
end_function

begin_comment
comment|/* Relax a loop instruction so that it can span loop>256 bytes.  */
end_comment

begin_comment
comment|/*                    loop    as, .L1            .L0:                    rsr     as, LEND                    wsr     as, LBEG                    addi    as, as, lo8(label-.L1)                    addmi   as, as, mid8(label-.L1)                    wsr     as, LEND                    isync                    rsr     as, LCOUNT                    addi    as, as, 1            .L1:<<body>>            label:                                     */
end_comment

begin_function
specifier|static
name|void
name|convert_frag_immed_finish_loop
parameter_list|(
name|segP
parameter_list|,
name|fragP
parameter_list|,
name|t_insn
parameter_list|)
name|segT
name|segP
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
block|{
name|TInsn
name|loop_insn
decl_stmt|;
name|TInsn
name|addi_insn
decl_stmt|;
name|TInsn
name|addmi_insn
decl_stmt|;
name|unsigned
name|long
name|target
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|loop_length
decl_stmt|,
name|loop_length_hi
decl_stmt|,
name|loop_length_lo
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|addressT
name|loop_offset
decl_stmt|;
name|addressT
name|addi_offset
init|=
literal|9
decl_stmt|;
name|addressT
name|addmi_offset
init|=
literal|12
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Get the loop offset.  */
name|loop_offset
operator|=
name|get_expanded_loop_offset
argument_list|(
name|t_insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
comment|/* Validate that there really is a LOOP at the loop_offset.  */
name|tinsn_from_chars
argument_list|(
operator|&
name|loop_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|loop_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_loop_opcode
argument_list|(
name|loop_insn
operator|.
name|opcode
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"loop relaxation specification does not correspond"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|addi_offset
operator|+=
name|loop_offset
expr_stmt|;
name|addmi_offset
operator|+=
name|loop_offset
expr_stmt|;
name|assert
argument_list|(
name|t_insn
operator|->
name|ntok
operator|==
literal|2
argument_list|)
expr_stmt|;
name|target
operator|=
name|get_expression_value
argument_list|(
name|segP
argument_list|,
operator|&
name|t_insn
operator|->
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
operator|||
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|loop_length
operator|=
name|target
operator|-
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
expr_stmt|;
name|loop_length_hi
operator|=
name|loop_length
operator|&
operator|~
literal|0x0ff
expr_stmt|;
name|loop_length_lo
operator|=
name|loop_length
operator|&
literal|0x0ff
expr_stmt|;
if|if
condition|(
name|loop_length_lo
operator|>=
literal|128
condition|)
block|{
name|loop_length_lo
operator|-=
literal|256
expr_stmt|;
name|loop_length_hi
operator|+=
literal|256
expr_stmt|;
block|}
comment|/* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most       32512.  If the loop is larger than that, then we just fail.  */
if|if
condition|(
name|loop_length_hi
operator|>
literal|32512
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"loop too long for LOOP instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|addi_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addi_offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addi_insn
operator|.
name|opcode
operator|==
name|xtensa_addi_opcode
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|addmi_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addmi_offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addmi_insn
operator|.
name|opcode
operator|==
name|xtensa_addmi_opcode
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|addi_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
name|loop_length_lo
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|addi_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addi_offset
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|addmi_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
name|loop_length_hi
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|addmi_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addmi_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|get_expression_value
parameter_list|(
name|segP
parameter_list|,
name|exp
parameter_list|)
name|segT
name|segP
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
condition|)
return|return
name|exp
operator|->
name|X_add_number
return|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
comment|/* Find the fragment.  */
name|symbolS
modifier|*
name|sym
init|=
name|exp
operator|->
name|X_add_symbol
decl_stmt|;
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|segP
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|absolute_section
argument_list|)
expr_stmt|;
return|return
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|+
name|exp
operator|->
name|X_add_number
operator|)
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid expression evaluation type %d"
argument_list|)
argument_list|,
name|exp
operator|->
name|X_op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A map that keeps information on a per-subsegment basis.  This is    maintained during initial assembly, but is invalid once the    subsegments are smashed together.  I.E., it cannot be used during    the relaxation.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|subseg_map_struct
block|{
comment|/* the key */
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
comment|/* the data */
name|unsigned
name|flags
decl_stmt|;
name|struct
name|subseg_map_struct
modifier|*
name|next
decl_stmt|;
block|}
name|subseg_map
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|subseg_map
modifier|*
name|sseg_map
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|get_last_insn_flags
parameter_list|(
name|seg
parameter_list|,
name|subseg
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
block|{
name|subseg_map
modifier|*
name|subseg_e
decl_stmt|;
for|for
control|(
name|subseg_e
operator|=
name|sseg_map
init|;
name|subseg_e
operator|!=
name|NULL
condition|;
name|subseg_e
operator|=
name|subseg_e
operator|->
name|next
control|)
if|if
condition|(
name|seg
operator|==
name|subseg_e
operator|->
name|seg
operator|&&
name|subseg
operator|==
name|subseg_e
operator|->
name|subseg
condition|)
return|return
name|subseg_e
operator|->
name|flags
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_last_insn_flags
parameter_list|(
name|seg
parameter_list|,
name|subseg
parameter_list|,
name|fl
parameter_list|,
name|val
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|unsigned
name|fl
decl_stmt|;
name|bfd_boolean
name|val
decl_stmt|;
block|{
name|subseg_map
modifier|*
name|subseg_e
decl_stmt|;
for|for
control|(
name|subseg_e
operator|=
name|sseg_map
init|;
name|subseg_e
condition|;
name|subseg_e
operator|=
name|subseg_e
operator|->
name|next
control|)
if|if
condition|(
name|seg
operator|==
name|subseg_e
operator|->
name|seg
operator|&&
name|subseg
operator|==
name|subseg_e
operator|->
name|subseg
condition|)
break|break;
if|if
condition|(
operator|!
name|subseg_e
condition|)
block|{
name|subseg_e
operator|=
operator|(
name|subseg_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|subseg_map
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|subseg_e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|subseg_map
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_e
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
name|subseg_e
operator|->
name|subseg
operator|=
name|subseg
expr_stmt|;
name|subseg_e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|subseg_e
operator|->
name|next
operator|=
name|sseg_map
expr_stmt|;
name|sseg_map
operator|=
name|subseg_e
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
name|subseg_e
operator|->
name|flags
operator||=
name|fl
expr_stmt|;
else|else
name|subseg_e
operator|->
name|flags
operator|&=
operator|~
name|fl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Segment Lists and emit_state Stuff.  */
end_comment

begin_comment
comment|/* Remove the segment from the global sections list.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_remove_section
parameter_list|(
name|sec
parameter_list|)
name|segT
name|sec
decl_stmt|;
block|{
comment|/* Handle brain-dead bfd_section_list_remove macro, which      expect the address of the prior section's "next" field, not      just the address of the section to remove.  */
name|segT
modifier|*
name|ps_next_ptr
init|=
operator|&
name|stdoutput
operator|->
name|sections
decl_stmt|;
while|while
condition|(
operator|*
name|ps_next_ptr
operator|!=
name|sec
operator|&&
operator|*
name|ps_next_ptr
operator|!=
name|NULL
condition|)
name|ps_next_ptr
operator|=
operator|&
operator|(
operator|*
name|ps_next_ptr
operator|)
operator|->
name|next
expr_stmt|;
name|assert
argument_list|(
operator|*
name|ps_next_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|ps_next_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_insert_section
parameter_list|(
name|after_sec
parameter_list|,
name|sec
parameter_list|)
name|segT
name|after_sec
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
name|segT
modifier|*
name|after_sec_next
decl_stmt|;
if|if
condition|(
name|after_sec
operator|==
name|NULL
condition|)
name|after_sec_next
operator|=
operator|&
name|stdoutput
operator|->
name|sections
expr_stmt|;
else|else
name|after_sec_next
operator|=
operator|&
name|after_sec
operator|->
name|next
expr_stmt|;
name|bfd_section_list_insert
argument_list|(
name|stdoutput
argument_list|,
name|after_sec_next
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_move_seg_list_to_beginning
parameter_list|(
name|head
parameter_list|)
name|seg_list
modifier|*
name|head
decl_stmt|;
block|{
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|segT
name|literal_section
init|=
name|head
operator|->
name|seg
decl_stmt|;
comment|/* Move the literal section to the front of the section list.  */
name|assert
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
name|xtensa_remove_section
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
name|xtensa_insert_section
argument_list|(
name|NULL
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xtensa_move_literals
parameter_list|()
block|{
name|seg_list
modifier|*
name|segment
decl_stmt|;
name|frchainS
modifier|*
name|frchain_from
decl_stmt|,
modifier|*
name|frchain_to
decl_stmt|;
name|fragS
modifier|*
name|search_frag
decl_stmt|,
modifier|*
name|next_frag
decl_stmt|,
modifier|*
name|last_frag
decl_stmt|,
modifier|*
name|literal_pool
decl_stmt|,
modifier|*
name|insert_after
decl_stmt|;
name|fragS
modifier|*
modifier|*
name|frag_splice
decl_stmt|;
name|emit_state
name|state
decl_stmt|;
name|segT
name|dest_seg
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|,
modifier|*
name|next_fix
decl_stmt|,
modifier|*
modifier|*
name|fix_splice
decl_stmt|;
name|sym_list
modifier|*
name|lit
decl_stmt|;
name|mark_literal_frags
argument_list|(
name|literal_head
operator|->
name|next
argument_list|)
expr_stmt|;
name|mark_literal_frags
argument_list|(
name|init_literal_head
operator|->
name|next
argument_list|)
expr_stmt|;
name|mark_literal_frags
argument_list|(
name|fini_literal_head
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_literal_section
condition|)
return|return;
name|segment
operator|=
name|literal_head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|segment
condition|)
block|{
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|search_frag
operator|=
name|frchain_from
operator|->
name|frch_root
expr_stmt|;
name|literal_pool
operator|=
name|NULL
expr_stmt|;
name|frchain_to
operator|=
name|NULL
expr_stmt|;
name|frag_splice
operator|=
operator|&
operator|(
name|frchain_from
operator|->
name|frch_root
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
condition|)
block|{
name|assert
argument_list|(
name|search_frag
operator|->
name|fr_fix
operator|==
literal|0
operator|||
name|search_frag
operator|->
name|fr_type
operator|==
name|rs_align
argument_list|)
expr_stmt|;
name|search_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|assert
argument_list|(
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL_POOL_BEGIN
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
operator|&
name|state
argument_list|,
name|segment
operator|->
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that all the frags in this series are closed, and 	 that there is at least one left over of zero-size.  This 	 prevents us from making a segment with an frchain without any 	 frags in it.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|search_frag
operator|!=
name|frag_now
condition|)
block|{
name|next_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
comment|/* First, move the frag out of the literal section and  	     to the appropriate place.  */
if|if
condition|(
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
condition|)
block|{
name|literal_pool
operator|=
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
name|assert
argument_list|(
name|literal_pool
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL_POOL_BEGIN
argument_list|)
expr_stmt|;
comment|/* Note that we set this fr_var to be a fix  		 chain when we created the literal pool location 		 as RELAX_LITERAL_POOL_BEGIN.  */
name|frchain_to
operator|=
operator|(
name|frchainS
operator|*
operator|)
name|literal_pool
operator|->
name|fr_var
expr_stmt|;
block|}
name|insert_after
operator|=
name|literal_pool
expr_stmt|;
while|while
condition|(
name|insert_after
operator|->
name|fr_next
operator|->
name|fr_subtype
operator|!=
name|RELAX_LITERAL_POOL_END
condition|)
name|insert_after
operator|=
name|insert_after
operator|->
name|fr_next
expr_stmt|;
name|dest_seg
operator|=
operator|(
name|segT
operator|)
name|insert_after
operator|->
name|fr_next
operator|->
name|fr_var
expr_stmt|;
operator|*
name|frag_splice
operator|=
name|next_frag
expr_stmt|;
name|search_frag
operator|->
name|fr_next
operator|=
name|insert_after
operator|->
name|fr_next
expr_stmt|;
name|insert_after
operator|->
name|fr_next
operator|=
name|search_frag
expr_stmt|;
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|lit_seg
operator|=
name|dest_seg
expr_stmt|;
comment|/* Now move any fixups associated with this frag to the 	     right section.  */
name|fix
operator|=
name|frchain_from
operator|->
name|fix_root
expr_stmt|;
name|fix_splice
operator|=
operator|&
operator|(
name|frchain_from
operator|->
name|fix_root
operator|)
expr_stmt|;
while|while
condition|(
name|fix
condition|)
block|{
name|next_fix
operator|=
name|fix
operator|->
name|fx_next
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_frag
operator|==
name|search_frag
condition|)
block|{
operator|*
name|fix_splice
operator|=
name|next_fix
expr_stmt|;
name|fix
operator|->
name|fx_next
operator|=
name|frchain_to
operator|->
name|fix_root
expr_stmt|;
name|frchain_to
operator|->
name|fix_root
operator|=
name|fix
expr_stmt|;
if|if
condition|(
name|frchain_to
operator|->
name|fix_tail
operator|==
name|NULL
condition|)
name|frchain_to
operator|->
name|fix_tail
operator|=
name|fix
expr_stmt|;
block|}
else|else
name|fix_splice
operator|=
operator|&
operator|(
name|fix
operator|->
name|fx_next
operator|)
expr_stmt|;
name|fix
operator|=
name|next_fix
expr_stmt|;
block|}
name|search_frag
operator|=
name|next_frag
expr_stmt|;
block|}
if|if
condition|(
name|frchain_from
operator|->
name|fix_root
operator|!=
name|NULL
condition|)
block|{
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"fixes not all moved from %s"
argument_list|)
argument_list|,
name|segment
operator|->
name|seg
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|frchain_from
operator|->
name|fix_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|frchain_from
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|segment
operator|=
name|segment
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now fix up the SEGMENT value for all the literal symbols.  */
for|for
control|(
name|lit
operator|=
name|literal_syms
init|;
name|lit
condition|;
name|lit
operator|=
name|lit
operator|->
name|next
control|)
block|{
name|symbolS
modifier|*
name|lit_sym
init|=
name|lit
operator|->
name|sym
decl_stmt|;
name|segT
name|dest_seg
init|=
name|symbol_get_frag
argument_list|(
name|lit_sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|lit_seg
decl_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|lit_sym
argument_list|,
name|dest_seg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk over all the frags for segments in a list and mark them as    containing literals.  As clunky as this is, we can't rely on frag_var    and frag_variant to get called in all situations.  */
end_comment

begin_function
specifier|static
name|void
name|mark_literal_frags
parameter_list|(
name|segment
parameter_list|)
name|seg_list
modifier|*
name|segment
decl_stmt|;
block|{
name|frchainS
modifier|*
name|frchain_from
decl_stmt|;
name|fragS
modifier|*
name|search_frag
decl_stmt|;
while|while
condition|(
name|segment
condition|)
block|{
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|search_frag
operator|=
name|frchain_from
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|search_frag
condition|)
block|{
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|=
name|TRUE
expr_stmt|;
name|search_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|segment
operator|=
name|segment
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_reorder_seg_list
parameter_list|(
name|head
parameter_list|,
name|after
parameter_list|)
name|seg_list
modifier|*
name|head
decl_stmt|;
name|segT
name|after
decl_stmt|;
block|{
comment|/* Move all of the sections in the section list to come      after "after" in the gnu segment list.  */
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|segT
name|literal_section
init|=
name|head
operator|->
name|seg
decl_stmt|;
comment|/* Move the literal section after "after".  */
name|assert
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|literal_section
operator|!=
name|after
condition|)
block|{
name|xtensa_remove_section
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
name|xtensa_insert_section
argument_list|(
name|after
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push all the literal segments to the end of the gnu list.  */
end_comment

begin_function
name|void
name|xtensa_reorder_segments
parameter_list|()
block|{
name|segT
name|sec
decl_stmt|;
name|segT
name|last_sec
decl_stmt|;
name|int
name|old_count
init|=
literal|0
decl_stmt|;
name|int
name|new_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
name|old_count
operator|++
expr_stmt|;
comment|/* Now that we have the last section, push all the literal      sections to the end.  */
name|last_sec
operator|=
name|get_last_sec
argument_list|()
expr_stmt|;
name|xtensa_reorder_seg_list
argument_list|(
name|literal_head
argument_list|,
name|last_sec
argument_list|)
expr_stmt|;
name|xtensa_reorder_seg_list
argument_list|(
name|init_literal_head
argument_list|,
name|last_sec
argument_list|)
expr_stmt|;
name|xtensa_reorder_seg_list
argument_list|(
name|fini_literal_head
argument_list|,
name|last_sec
argument_list|)
expr_stmt|;
comment|/* Now perform the final error check.  */
for|for
control|(
name|sec
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
name|new_count
operator|++
expr_stmt|;
name|assert
argument_list|(
name|new_count
operator|==
name|old_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|segT
name|get_last_sec
parameter_list|()
block|{
name|segT
name|last_sec
init|=
name|stdoutput
operator|->
name|sections
decl_stmt|;
while|while
condition|(
name|last_sec
operator|->
name|next
operator|!=
name|NULL
condition|)
name|last_sec
operator|=
name|last_sec
operator|->
name|next
expr_stmt|;
return|return
name|last_sec
return|;
block|}
end_function

begin_comment
comment|/* Change the emit state (seg, subseg, and frag related stuff) to the    correct location.  Return a emit_state which can be passed to    xtensa_restore_emit_state to return to current fragment.  */
end_comment

begin_function
name|void
name|xtensa_switch_to_literal_fragment
parameter_list|(
name|result
parameter_list|)
name|emit_state
modifier|*
name|result
decl_stmt|;
block|{
comment|/* When we mark a literal pool location, we want to put a frag in      the literal pool that points to it.  But to do that, we want to      switch_to_literal_fragment.  But literal sections don't have      literal pools, so their location is always null, so we would      recurse forever.  This is kind of hacky, but it works.  */
specifier|static
name|bfd_boolean
name|recursive
init|=
name|FALSE
decl_stmt|;
name|fragS
modifier|*
name|pool_location
init|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|bfd_boolean
name|is_init
init|=
operator|(
name|now_seg
operator|&&
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|INIT_SECTION_NAME
argument_list|)
operator|)
decl_stmt|;
name|bfd_boolean
name|is_fini
init|=
operator|(
name|now_seg
operator|&&
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|FINI_SECTION_NAME
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|pool_location
operator|==
name|NULL
operator|&&
operator|!
name|use_literal_section
operator|&&
operator|!
name|recursive
operator|&&
operator|!
name|is_init
operator|&&
operator|!
name|is_fini
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"inlining literal pool; "
literal|"specify location with .literal_position."
argument_list|)
argument_list|)
expr_stmt|;
name|recursive
operator|=
name|TRUE
expr_stmt|;
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
name|recursive
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Special case: If we are in the ".fini" or ".init" section, then      we will ALWAYS be generating to the ".fini.literal" and      ".init.literal" sections.  */
if|if
condition|(
name|is_init
condition|)
block|{
name|cache_literal_section
argument_list|(
name|init_literal_head
argument_list|,
name|default_lit_sections
operator|.
name|init_lit_seg_name
argument_list|,
operator|&
name|default_lit_sections
operator|.
name|init_lit_seg
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
name|result
argument_list|,
name|default_lit_sections
operator|.
name|init_lit_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_fini
condition|)
block|{
name|cache_literal_section
argument_list|(
name|fini_literal_head
argument_list|,
name|default_lit_sections
operator|.
name|fini_lit_seg_name
argument_list|,
operator|&
name|default_lit_sections
operator|.
name|fini_lit_seg
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
name|result
argument_list|,
name|default_lit_sections
operator|.
name|fini_lit_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cache_literal_section
argument_list|(
name|literal_head
argument_list|,
name|default_lit_sections
operator|.
name|lit_seg_name
argument_list|,
operator|&
name|default_lit_sections
operator|.
name|lit_seg
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
name|result
argument_list|,
name|default_lit_sections
operator|.
name|lit_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_literal_section
operator|&&
operator|!
name|is_init
operator|&&
operator|!
name|is_fini
operator|&&
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
operator|!=
name|pool_location
condition|)
block|{
comment|/* Close whatever frag is there.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|pool_location
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Do a 4 byte align here.  */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function before emitting data into the literal section.    This is a helper function for xtensa_switch_to_literal_fragment.    This is similar to a .section new_now_seg subseg. */
end_comment

begin_function
name|void
name|xtensa_switch_section_emit_state
parameter_list|(
name|state
parameter_list|,
name|new_now_seg
parameter_list|,
name|new_now_subseg
parameter_list|)
name|emit_state
modifier|*
name|state
decl_stmt|;
name|segT
name|new_now_seg
decl_stmt|;
name|subsegT
name|new_now_subseg
decl_stmt|;
block|{
name|state
operator|->
name|name
operator|=
name|now_seg
operator|->
name|name
expr_stmt|;
name|state
operator|->
name|now_seg
operator|=
name|now_seg
expr_stmt|;
name|state
operator|->
name|now_subseg
operator|=
name|now_subseg
expr_stmt|;
name|state
operator|->
name|generating_literals
operator|=
name|generating_literals
expr_stmt|;
name|generating_literals
operator|++
expr_stmt|;
name|subseg_new
argument_list|(
name|segment_name
argument_list|(
name|new_now_seg
argument_list|)
argument_list|,
name|new_now_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use to restore the emitting into the normal place.  */
end_comment

begin_function
name|void
name|xtensa_restore_emit_state
parameter_list|(
name|state
parameter_list|)
name|emit_state
modifier|*
name|state
decl_stmt|;
block|{
name|generating_literals
operator|=
name|state
operator|->
name|generating_literals
expr_stmt|;
name|subseg_new
argument_list|(
name|state
operator|->
name|name
argument_list|,
name|state
operator|->
name|now_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a segment of a given name.  If the segment is already    present, return it; otherwise, create a new one.  */
end_comment

begin_function
specifier|static
name|void
name|cache_literal_section
parameter_list|(
name|head
parameter_list|,
name|name
parameter_list|,
name|seg
parameter_list|)
name|seg_list
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
modifier|*
name|seg
decl_stmt|;
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
if|if
condition|(
operator|*
name|seg
operator|!=
literal|0
condition|)
return|return;
operator|*
name|seg
operator|=
name|retrieve_literal_seg
argument_list|(
name|head
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a segment of a given name.  If the segment is already    present, return it; otherwise, create a new one.  */
end_comment

begin_function
specifier|static
name|segT
name|retrieve_literal_seg
parameter_list|(
name|head
parameter_list|,
name|name
parameter_list|)
name|seg_list
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|segT
name|ret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|ret
operator|=
name|seg_present
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|add_seg_list
argument_list|(
name|head
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|ret
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|ret
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a segment of a given name if it is present.  */
end_comment

begin_function
specifier|static
name|segT
name|seg_present
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|segT
name|seg
decl_stmt|;
name|seg
operator|=
name|stdoutput
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|seg
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|seg
return|;
name|seg
operator|=
name|seg
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a segment to a segment list.  */
end_comment

begin_function
specifier|static
name|void
name|add_seg_list
parameter_list|(
name|head
parameter_list|,
name|seg
parameter_list|)
name|seg_list
modifier|*
name|head
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|seg_list
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|seg_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|seg_list
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up Property Tables after Relaxation.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_INSN_SEC_NAME
value|".xt.insn"
end_define

begin_define
define|#
directive|define
name|XTENSA_LIT_SEC_NAME
value|".xt.lit"
end_define

begin_function
name|void
name|xtensa_post_relax_hook
parameter_list|()
block|{
name|xtensa_move_seg_list_to_beginning
argument_list|(
name|literal_head
argument_list|)
expr_stmt|;
name|xtensa_move_seg_list_to_beginning
argument_list|(
name|init_literal_head
argument_list|)
expr_stmt|;
name|xtensa_move_seg_list_to_beginning
argument_list|(
name|fini_literal_head
argument_list|)
expr_stmt|;
name|xtensa_create_property_segments
argument_list|(
name|get_frag_is_insn
argument_list|,
name|XTENSA_INSN_SEC_NAME
argument_list|,
name|xt_insn_sec
argument_list|)
expr_stmt|;
name|xtensa_create_property_segments
argument_list|(
name|get_frag_is_literal
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|xt_literal_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|get_frag_is_literal
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|assert
argument_list|(
name|fragP
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|get_frag_is_insn
parameter_list|(
name|fragP
parameter_list|)
specifier|const
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|assert
argument_list|(
name|fragP
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_create_property_segments
parameter_list|(
name|property_function
parameter_list|,
name|section_name_base
parameter_list|,
name|sec_type
parameter_list|)
name|frag_predicate
name|property_function
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name_base
decl_stmt|;
name|xt_section_type
name|sec_type
decl_stmt|;
block|{
name|segT
modifier|*
name|seclist
decl_stmt|;
comment|/* Walk over all of the current segments.      Walk over each fragment       For each fragment that has instructions       Build an instruction record (append where possible).  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
if|if
condition|(
name|section_has_property
argument_list|(
name|sec
argument_list|,
name|property_function
argument_list|)
condition|)
block|{
name|char
modifier|*
name|property_section_name
init|=
name|xtensa_get_property_section_name
argument_list|(
name|sec
argument_list|,
name|section_name_base
argument_list|)
decl_stmt|;
name|segT
name|insn_sec
init|=
name|retrieve_xtensa_section
argument_list|(
name|property_section_name
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
init|=
name|retrieve_segment_info
argument_list|(
name|insn_sec
argument_list|)
decl_stmt|;
name|xtensa_block_info
modifier|*
modifier|*
name|xt_blocks
init|=
operator|&
name|xt_seg_info
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
decl_stmt|;
comment|/* Walk over all of the frchains here and add new sections.  */
name|add_xt_block_frags
argument_list|(
name|sec
argument_list|,
name|insn_sec
argument_list|,
name|xt_blocks
argument_list|,
name|property_function
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we fill them out....  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|xtensa_block_info
modifier|*
name|block
decl_stmt|;
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|block
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|xtensa_block_info
modifier|*
name|cur_block
decl_stmt|;
comment|/* This is a section with some data.  */
name|size_t
name|num_recs
init|=
literal|0
decl_stmt|;
name|size_t
name|rec_size
decl_stmt|;
for|for
control|(
name|cur_block
operator|=
name|block
init|;
name|cur_block
condition|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
control|)
name|num_recs
operator|++
expr_stmt|;
name|rec_size
operator|=
name|num_recs
operator|*
literal|8
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|rec_size
argument_list|)
expr_stmt|;
comment|/* In order to make this work with the assembler, we have to 	     build some frags and then build the "fixups" for it.  It 	     would be easier to just set the contents then set the 	     arlents.  */
if|if
condition|(
name|num_recs
condition|)
block|{
comment|/* Allocate a fragment and leak it.  */
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|size_t
name|frag_size
decl_stmt|;
name|fixS
modifier|*
name|fixes
decl_stmt|;
name|frchainS
modifier|*
name|frchainP
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|frag_data
decl_stmt|;
name|frag_size
operator|=
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
operator|+
name|rec_size
expr_stmt|;
name|fragP
operator|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
name|frag_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fragP
argument_list|,
literal|0
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_address
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|=
name|rec_size
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
comment|/* the rest are zeros */
name|frchainP
operator|=
name|seginfo
operator|->
name|frchainP
expr_stmt|;
name|frchainP
operator|->
name|frch_root
operator|=
name|fragP
expr_stmt|;
name|frchainP
operator|->
name|frch_last
operator|=
name|fragP
expr_stmt|;
name|fixes
operator|=
operator|(
name|fixS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fixes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|fixes
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
operator|&
name|fixes
index|[
name|num_recs
operator|-
literal|1
index|]
expr_stmt|;
name|cur_block
operator|=
name|block
expr_stmt|;
name|frag_data
operator|=
operator|&
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_recs
condition|;
name|i
operator|++
control|)
block|{
name|fixS
modifier|*
name|fix
init|=
operator|&
name|fixes
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Write the fixup.  */
if|if
condition|(
name|i
operator|!=
name|num_recs
operator|-
literal|1
condition|)
name|fix
operator|->
name|fx_next
operator|=
operator|&
name|fixes
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|fix
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
name|fix
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fix
operator|->
name|fx_frag
operator|=
name|fragP
expr_stmt|;
name|fix
operator|->
name|fx_where
operator|=
name|i
operator|*
literal|8
expr_stmt|;
name|fix
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|cur_block
operator|->
name|sec
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_offset
operator|=
name|cur_block
operator|->
name|offset
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|fix
operator|->
name|fx_file
operator|=
literal|"Internal Assembly"
expr_stmt|;
name|fix
operator|->
name|fx_line
operator|=
literal|0
expr_stmt|;
comment|/* Write the length.  */
name|md_number_to_chars
argument_list|(
operator|&
name|frag_data
index|[
literal|4
operator|+
literal|8
operator|*
name|i
index|]
argument_list|,
name|cur_block
operator|->
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|segment_info_type
modifier|*
name|retrieve_segment_info
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|bfd_get_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
name|frchainS
modifier|*
name|frchainP
decl_stmt|;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|seginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|seg
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
literal|0
expr_stmt|;
comment|/* We will not be dealing with these, only our special ones.  */
if|#
directive|if
literal|0
block|if (seg == bfd_abs_section_ptr) 	abs_seg_info = seginfo;       else if (seg == bfd_und_section_ptr) 	und_seg_info = seginfo;       else
endif|#
directive|endif
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|PTR
operator|)
name|seginfo
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|seg_fix_rootP =&segment_info[seg].fix_root;       seg_fix_tailP =&segment_info[seg].fix_tail;
endif|#
directive|endif
name|frchainP
operator|=
operator|(
name|frchainS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|frchainS
argument_list|)
argument_list|)
expr_stmt|;
name|frchainP
operator|->
name|frch_root
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_last
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_next
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_seg
operator|=
name|seg
expr_stmt|;
name|frchainP
operator|->
name|frch_subseg
operator|=
literal|0
expr_stmt|;
name|frchainP
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
comment|/* Do not init the objstack.  */
comment|/* obstack_begin (&frchainP->frch_obstack, chunksize); */
comment|/* frchainP->frch_frag_now = fragP; */
name|frchainP
operator|->
name|frch_frag_now
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|frchainP
operator|=
name|frchainP
expr_stmt|;
block|}
return|return
name|seginfo
return|;
block|}
end_function

begin_function
name|segT
name|retrieve_xtensa_section
parameter_list|(
name|sec_name
parameter_list|)
name|char
modifier|*
name|sec_name
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|stdoutput
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|out_flags
decl_stmt|,
name|link_once_flags
decl_stmt|;
name|segT
name|s
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|link_once_flags
operator|=
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
expr_stmt|;
if|if
condition|(
name|link_once_flags
condition|)
name|link_once_flags
operator||=
operator|(
name|flags
operator|&
name|SEC_LINK_DUPLICATES
operator|)
expr_stmt|;
name|out_flags
operator|=
operator|(
name|SEC_RELOC
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|link_once_flags
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"could not create section %s"
argument_list|)
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|out_flags
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid flag combination on section %s"
argument_list|)
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|section_has_property
parameter_list|(
name|sec
parameter_list|,
name|property_function
parameter_list|)
name|segT
name|sec
decl_stmt|;
name|frag_predicate
name|property_function
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|property_function
argument_list|(
name|fragP
argument_list|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_fill
operator|||
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Two types of block sections exist right now: literal and insns.  */
end_comment

begin_function
name|void
name|add_xt_block_frags
parameter_list|(
name|sec
parameter_list|,
name|xt_block_sec
parameter_list|,
name|xt_block
parameter_list|,
name|property_function
parameter_list|)
name|segT
name|sec
decl_stmt|;
name|segT
name|xt_block_sec
decl_stmt|;
name|xtensa_block_info
modifier|*
modifier|*
name|xt_block
decl_stmt|;
name|frag_predicate
name|property_function
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seg_info
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
decl_stmt|;
name|bfd_vma
name|seg_offset
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|xt_seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|xt_block_sec
argument_list|)
expr_stmt|;
name|seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Build it if needed.  */
while|while
condition|(
operator|*
name|xt_block
operator|!=
name|NULL
condition|)
name|xt_block
operator|=
operator|&
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
expr_stmt|;
comment|/* We are either at NULL at the beginning or at the end.  */
comment|/* Walk through the frags.  */
name|seg_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg_info
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seg_info
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|property_function
argument_list|(
name|fragP
argument_list|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_fill
operator|||
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|xt_block
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|offset
operator|+
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|size
operator|==
name|fragP
operator|->
name|fr_address
condition|)
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|size
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
else|else
name|xt_block
operator|=
operator|&
operator|(
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|xt_block
operator|==
name|NULL
condition|)
block|{
name|xtensa_block_info
modifier|*
name|new_block
init|=
operator|(
name|xtensa_block_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_block_info
argument_list|)
argument_list|)
decl_stmt|;
name|new_block
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|new_block
operator|->
name|offset
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|new_block
operator|->
name|size
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|new_block
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|xt_block
operator|=
name|new_block
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction Stack Functions (from "xtensa-istack.h").  */
end_comment

begin_function
name|void
name|istack_init
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|IStack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|istack_empty
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
return|return
operator|(
name|stack
operator|->
name|ninsn
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|istack_full
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
return|return
operator|(
name|stack
operator|->
name|ninsn
operator|==
name|MAX_ISTACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the top IStack entry.    It is an error to call this if istack_empty () is true. */
end_comment

begin_function
name|TInsn
modifier|*
name|istack_top
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_empty
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
return|;
block|}
end_function

begin_comment
comment|/* Add a new TInsn to an IStack.    It is an error to call this if istack_full () is true.  */
end_comment

begin_function
name|void
name|istack_push
parameter_list|(
name|stack
parameter_list|,
name|insn
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_full
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|tinsn_copy
argument_list|(
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear space for the next TInsn on the IStack and return a pointer    to it.  It is an error to call this if istack_full () is true.  */
end_comment

begin_function
name|TInsn
modifier|*
name|istack_push_space
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_full
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
expr_stmt|;
name|memset
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|++
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Remove the last pushed instruction.  It is an error to call this if    istack_empty () returns true.  */
end_comment

begin_function
name|void
name|istack_pop
parameter_list|(
name|stack
parameter_list|)
name|IStack
modifier|*
name|stack
decl_stmt|;
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_empty
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|--
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TInsn functions.  */
end_comment

begin_function
name|void
name|tinsn_init
parameter_list|(
name|dst
parameter_list|)
name|TInsn
modifier|*
name|dst
decl_stmt|;
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tinsn_copy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|TInsn
modifier|*
name|dst
decl_stmt|;
specifier|const
name|TInsn
modifier|*
name|src
decl_stmt|;
block|{
name|tinsn_init
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the ``num''th token of the TInsn.    It is illegal to call this if num> insn->ntoks.  */
end_comment

begin_function
name|expressionS
modifier|*
name|tinsn_get_tok
parameter_list|(
name|insn
parameter_list|,
name|num
parameter_list|)
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|assert
argument_list|(
name|num
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
return|return
operator|&
name|insn
operator|->
name|tok
index|[
name|num
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return true if ANY of the operands in the insn are symbolic.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_has_symbolic_operands
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|tinsn_has_invalid_symbolic_operands
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
break|break;
default|default:
if|if
condition|(
name|i
operator|==
name|get_relaxable_immed
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
condition|)
break|break;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid symbolic operand %d on '%s'"
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* For assembly code with complex expressions (e.g. subtraction),    we have to build them in the literal pool so that    their results are calculated correctly after relaxation.    The relaxation only handles expressions that    boil down to SYMBOL + OFFSET.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_has_complex_operands
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert the constant operands in the t_insn to insnbuf.    Return true if there is a symbol in the immediate field.     Before this is called,     1) the number of operands are correct    2) the t_insn is a ITYPE_INSN    3) ONLY the relaxable_ is built    4) All operands are O_constant, O_symbol.  All constants fit    The return value tells whether there are any remaining O_symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_to_insnbuf
parameter_list|(
name|t_insn
parameter_list|,
name|insnbuf
parameter_list|)
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
name|xtensa_insnbuf
name|insnbuf
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|t_insn
operator|->
name|opcode
decl_stmt|;
name|bfd_boolean
name|has_fixup
init|=
name|FALSE
decl_stmt|;
name|int
name|noperands
init|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32
name|opnd_value
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|int
name|line
decl_stmt|;
name|assert
argument_list|(
name|t_insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|!=
name|t_insn
operator|->
name|ntok
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"operand number mismatch"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_encode_insn
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
operator|++
name|i
control|)
block|{
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|t_insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
name|xtensa_operand
name|operand
init|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
comment|/* The register number has already been checked in   	     expression_maybe_register, so we don't need to check here.  */
name|opnd_value
operator|=
name|expr
operator|->
name|X_add_number
expr_stmt|;
operator|(
name|void
operator|)
name|xtensa_operand_encode
argument_list|(
name|operand
argument_list|,
operator|&
name|opnd_value
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|,
name|opnd_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
comment|/* It is a constant and we called this function, 	     then we have to try to fit it.  */
name|xtensa_insnbuf_set_operand
argument_list|(
name|insnbuf
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|,
name|expr
operator|->
name|X_add_number
argument_list|,
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
default|default:
name|has_fixup
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|has_fixup
return|;
block|}
end_function

begin_comment
comment|/* Check the instruction arguments.  Return true on failure.  */
end_comment

begin_function
name|bfd_boolean
name|tinsn_check_arguments
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|TInsn
modifier|*
name|insn
decl_stmt|;
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|insn
operator|->
name|opcode
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|>
name|insn
operator|->
name|ntok
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too few operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|<
name|insn
operator|->
name|ntok
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Load an instruction from its encoded form.  */
end_comment

begin_function
specifier|static
name|void
name|tinsn_from_chars
parameter_list|(
name|t_insn
parameter_list|,
name|f
parameter_list|)
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
comment|/* Find the immed.  */
name|tinsn_init
argument_list|(
name|t_insn
argument_list|)
expr_stmt|;
name|t_insn
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|t_insn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
comment|/* Must not be specific.  */
name|t_insn
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|t_insn
operator|->
name|ntok
operator|=
name|xtensa_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t_insn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
block|{
name|set_expr_const
argument_list|(
operator|&
name|t_insn
operator|->
name|tok
index|[
name|i
index|]
argument_list|,
name|xtensa_insnbuf_get_operand
argument_list|(
name|insnbuf
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the value of the relaxable immed from the fr_symbol and fr_offset.  */
end_comment

begin_function
specifier|static
name|void
name|tinsn_immed_from_frag
parameter_list|(
name|t_insn
parameter_list|,
name|fragP
parameter_list|)
name|TInsn
modifier|*
name|t_insn
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|xtensa_opcode
name|opcode
init|=
name|t_insn
operator|->
name|opcode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|opnum
operator|=
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|t_insn
operator|->
name|tok
index|[
name|opnum
index|]
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_stack_text_bytes
parameter_list|(
name|istack
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|text_bytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|t_insn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t_insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
condition|)
name|text_bytes
operator|+=
name|xg_get_insn_size
argument_list|(
name|t_insn
argument_list|)
expr_stmt|;
block|}
return|return
name|text_bytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_stack_literal_bytes
parameter_list|(
name|istack
parameter_list|)
name|IStack
modifier|*
name|istack
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|lit_bytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|t_insn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t_insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
operator|&&
name|t_insn
operator|->
name|ntok
operator|==
literal|1
condition|)
name|lit_bytes
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|lit_bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression utilities.  */
end_comment

begin_comment
comment|/* Return true if the expression is an integer constant.  */
end_comment

begin_function
name|bfd_boolean
name|expr_is_const
parameter_list|(
name|s
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|->
name|X_op
operator|==
name|O_constant
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the expression constant.    Calling this is illegal if expr_is_const () returns true.  */
end_comment

begin_function
name|offsetT
name|get_expr_const
parameter_list|(
name|s
parameter_list|)
specifier|const
name|expressionS
modifier|*
name|s
decl_stmt|;
block|{
name|assert
argument_list|(
name|expr_is_const
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Set the expression to a constant value.  */
end_comment

begin_function
name|void
name|set_expr_const
parameter_list|(
name|s
parameter_list|,
name|val
parameter_list|)
name|expressionS
modifier|*
name|s
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
block|{
name|s
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|s
operator|->
name|X_add_number
operator|=
name|val
expr_stmt|;
name|s
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the expression to a symbol + constant offset.  */
end_comment

begin_function
name|void
name|set_expr_symbol_offset
parameter_list|(
name|s
parameter_list|,
name|sym
parameter_list|,
name|offset
parameter_list|)
name|expressionS
modifier|*
name|s
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
block|{
name|s
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|s
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|s
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* unused */
name|s
operator|->
name|X_add_number
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|expr_is_equal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|expressionS
modifier|*
name|s1
decl_stmt|;
name|expressionS
modifier|*
name|s2
decl_stmt|;
block|{
if|if
condition|(
name|s1
operator|->
name|X_op
operator|!=
name|s2
operator|->
name|X_op
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_add_symbol
operator|!=
name|s2
operator|->
name|X_add_symbol
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_op_symbol
operator|!=
name|s2
operator|->
name|X_op_symbol
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_add_number
operator|!=
name|s2
operator|->
name|X_add_number
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_expr
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|expressionS
modifier|*
name|dst
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|src
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for Tensilica's "--rename-section" option.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XTENSA_SECTION_RENAME
end_ifdef

begin_struct
struct|struct
name|rename_section_struct
block|{
name|char
modifier|*
name|old_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|rename_section_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|rename_section_struct
modifier|*
name|section_rename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the string oldname=new_name:oldname2=new_name2     and call add_section_rename.  */
end_comment

begin_function
name|void
name|build_section_rename
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|this_arg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|next_arg
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|this_arg
operator|=
name|strdup
argument_list|(
name|arg
argument_list|)
init|;
name|this_arg
operator|!=
name|NULL
condition|;
name|this_arg
operator|=
name|next_arg
control|)
block|{
if|if
condition|(
name|this_arg
condition|)
block|{
name|next_arg
operator|=
name|strchr
argument_list|(
name|this_arg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
condition|)
block|{
operator|*
name|next_arg
operator|=
literal|'\0'
expr_stmt|;
name|next_arg
operator|++
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
name|old_name
init|=
name|this_arg
decl_stmt|;
name|char
modifier|*
name|new_name
init|=
name|strchr
argument_list|(
name|this_arg
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|old_name
operator|==
literal|'\0'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring extra '-rename-section' delimiter ':'"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|new_name
operator|||
name|new_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring invalid '-rename-section' "
literal|"specification: '%s'"
argument_list|)
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|new_name
operator|=
literal|'\0'
expr_stmt|;
name|new_name
operator|++
expr_stmt|;
name|add_section_rename
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_section_rename
parameter_list|(
name|old_name
parameter_list|,
name|new_name
parameter_list|)
name|char
modifier|*
name|old_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
block|{
name|struct
name|rename_section_struct
modifier|*
name|r
init|=
name|section_rename
decl_stmt|;
comment|/* Check for invalid section renaming.  */
for|for
control|(
name|r
operator|=
name|section_rename
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|old_name
argument_list|,
name|old_name
argument_list|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"section %s renamed multiple times"
argument_list|)
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|new_name
argument_list|,
name|new_name
argument_list|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple sections remapped to output section %s"
argument_list|)
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
comment|/* Now add it.  */
name|r
operator|=
operator|(
expr|struct
name|rename_section_struct
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rename_section_struct
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|old_name
operator|=
name|strdup
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|r
operator|->
name|new_name
operator|=
name|strdup
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|section_rename
expr_stmt|;
name|section_rename
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_section_rename
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|rename_section_struct
modifier|*
name|r
init|=
name|section_rename
decl_stmt|;
for|for
control|(
name|r
operator|=
name|section_rename
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|old_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|r
operator|->
name|new_name
return|;
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XTENSA_SECTION_RENAME */
end_comment

end_unit

