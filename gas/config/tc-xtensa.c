begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-xtensa.c -- Assemble Xtensa instructions.    Copyright 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"tc-xtensa.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-relax.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-istack.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-config.h"
end_include

begin_comment
comment|/* Provide default values for new configuration settings.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XSHAL_ABI
end_ifndef

begin_define
define|#
directive|define
name|XSHAL_ABI
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|uint32
end_ifndef

begin_define
define|#
directive|define
name|uint32
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|int32
end_ifndef

begin_define
define|#
directive|define
name|int32
value|signed int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Notes:     Naming conventions (used somewhat inconsistently):       The xtensa_ functions are exported       The xg_ functions are internal     We also have a couple of different extensibility mechanisms.    1) The idiom replacement:       This is used when a line is first parsed to       replace an instruction pattern with another instruction       It is currently limited to replacements of instructions       with constant operands.    2) The xtensa-relax.c mechanism that has stronger instruction       replacement patterns.  When an instruction's immediate field       does not fit the next instruction sequence is attempted.       In addition, "narrow" opcodes are supported this way.  */
end_comment

begin_comment
comment|/* Define characters with special meanings to GAS.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to indicate whether the hardware supports the density and    absolute literals options.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|density_supported
init|=
name|XCHAL_HAVE_DENSITY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|absolute_literals_supported
init|=
name|XSHAL_USE_ABSOLUTE_LITERALS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum width we would pad an unreachable frag to get alignment.  */
end_comment

begin_define
define|#
directive|define
name|UNREACHABLE_MAX_WIDTH
value|8
end_define

begin_decl_stmt
specifier|static
name|vliw_insn
name|cur_vinsn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|xtensa_fetch_width
init|=
name|XCHAL_INST_FETCH_WIDTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|debug_info_type
name|xt_saved_debug_type
init|=
name|DEBUG_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some functions are only valid in the front end.  This variable    allows us to assert that we haven't crossed over into the    back end.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|past_xtensa_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags for properties of the last instruction in a segment.  */
end_comment

begin_define
define|#
directive|define
name|FLAG_IS_A0_WRITER
value|0x1
end_define

begin_define
define|#
directive|define
name|FLAG_IS_BAD_LOOPEND
value|0x2
end_define

begin_comment
comment|/* We define a special segment names ".literal" to place literals    into.  The .fini and .init sections are special because they    contain code that is moved together by the linker.  We give them    their own special .fini.literal and .init.literal sections.  */
end_comment

begin_define
define|#
directive|define
name|LITERAL_SECTION_NAME
value|xtensa_section_rename (".literal")
end_define

begin_define
define|#
directive|define
name|LIT4_SECTION_NAME
value|xtensa_section_rename (".lit4")
end_define

begin_define
define|#
directive|define
name|INIT_SECTION_NAME
value|xtensa_section_rename (".init")
end_define

begin_define
define|#
directive|define
name|FINI_SECTION_NAME
value|xtensa_section_rename (".fini")
end_define

begin_comment
comment|/* This type is used for the directive_stack to keep track of the    state of the literal collection pools.  If lit_prefix is set, it is    used to determine the literal section names; otherwise, the literal    sections are determined based on the current text section.  The    lit_seg and lit4_seg fields cache these literal sections, with the    current_text_seg field used a tag to indicate whether the cached    values are valid.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lit_state_struct
block|{
name|char
modifier|*
name|lit_prefix
decl_stmt|;
name|segT
name|current_text_seg
decl_stmt|;
name|segT
name|lit_seg
decl_stmt|;
name|segT
name|lit4_seg
decl_stmt|;
block|}
name|lit_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|lit_state
name|default_lit_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a list of literal segments.  The seg_list type is the node    for this list.  The literal_head pointer is the head of the list,    with the literal_head_h dummy node at the start.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|seg_list_struct
block|{
name|struct
name|seg_list_struct
modifier|*
name|next
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|}
name|seg_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|seg_list
name|literal_head_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|seg_list
modifier|*
name|literal_head
init|=
operator|&
name|literal_head_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lists of symbols.  We keep a list of symbols that label the current    instruction, so that we can adjust the symbols when inserting alignment    for various instructions.  We also keep a list of all the symbols on    literals, so that we can fix up those symbols when the literals are    later moved into the text sections.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sym_list_struct
block|{
name|struct
name|sym_list_struct
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|}
name|sym_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|free_insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|saved_insn_labels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sym_list
modifier|*
name|literal_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to determine whether to prefer const16 or l32r    if both options are available.  */
end_comment

begin_decl_stmt
name|int
name|prefer_const16
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prefer_l32r
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global flag to indicate when we are emitting literals.  */
end_comment

begin_decl_stmt
name|int
name|generating_literals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following PROPERTY table definitions are copied from<elf/xtensa.h> and must be kept in sync with the code there.  */
end_comment

begin_comment
comment|/* Flags in the property tables to specify whether blocks of memory    are literals, instructions, data, or unreachable.  For    instructions, blocks that begin loop targets and branch targets are    designated.  Blocks that do not allow density, instruction    reordering or transformation are also specified.  Finally, for    branch targets, branch target alignment priority is included.    Alignment of the next block is specified in the current block    and the size of the current block does not include any fill required    to align to the next block.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_LITERAL
value|0x00000001
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN
value|0x00000002
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_DATA
value|0x00000004
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_UNREACHABLE
value|0x00000008
end_define

begin_comment
comment|/* Instruction only properties at beginning of code.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN_LOOP_TARGET
value|0x00000010
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN_BRANCH_TARGET
value|0x00000020
end_define

begin_comment
comment|/* Instruction only properties about code.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN_NO_DENSITY
value|0x00000040
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN_NO_REORDER
value|0x00000080
end_define

begin_comment
comment|/* Historically, NO_TRANSFORM was a property of instructions,    but it should apply to literals under certain circumstances.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_NO_TRANSFORM
value|0x00000100
end_define

begin_comment
comment|/*  Branch target alignment information.  This transmits information     to the linker optimization about the priority of aligning a     particular block for branch target alignment: None, low priority,     high priority, or required.  These only need to be checked in     instruction blocks marked as XTENSA_PROP_INSN_BRANCH_TARGET.     Common usage is      switch (GET_XTENSA_PROP_BT_ALIGN (flags))     case XTENSA_PROP_BT_ALIGN_NONE:     case XTENSA_PROP_BT_ALIGN_LOW:     case XTENSA_PROP_BT_ALIGN_HIGH:     case XTENSA_PROP_BT_ALIGN_REQUIRE: */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_BT_ALIGN_MASK
value|0x00000600
end_define

begin_comment
comment|/* No branch target alignment.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_BT_ALIGN_NONE
value|0x0
end_define

begin_comment
comment|/* Low priority branch target alignment.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_BT_ALIGN_LOW
value|0x1
end_define

begin_comment
comment|/* High priority branch target alignment.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_BT_ALIGN_HIGH
value|0x2
end_define

begin_comment
comment|/* Required branch target alignment.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_BT_ALIGN_REQUIRE
value|0x3
end_define

begin_define
define|#
directive|define
name|GET_XTENSA_PROP_BT_ALIGN
parameter_list|(
name|flag
parameter_list|)
define|\
value|(((unsigned) ((flag)& (XTENSA_PROP_BT_ALIGN_MASK)))>> 9)
end_define

begin_define
define|#
directive|define
name|SET_XTENSA_PROP_BT_ALIGN
parameter_list|(
name|flag
parameter_list|,
name|align
parameter_list|)
define|\
value|(((flag)& (~XTENSA_PROP_BT_ALIGN_MASK)) | \     (((align)<< 9)& XTENSA_PROP_BT_ALIGN_MASK))
end_define

begin_comment
comment|/* Alignment is specified in the block BEFORE the one that needs    alignment.  Up to 5 bits.  Use GET_XTENSA_PROP_ALIGNMENT(flags) to    get the required alignment specified as a power of 2.  Use    SET_XTENSA_PROP_ALIGNMENT(flags, pow2) to set the required    alignment.  Be careful of side effects since the SET will evaluate    flags twice.  Also, note that the SIZE of a block in the property    table does not include the alignment size, so the alignment fill    must be calculated to determine if two blocks are contiguous.    TEXT_ALIGN is not currently implemented but is a placeholder for a    possible future implementation.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_PROP_ALIGN
value|0x00000800
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_ALIGNMENT_MASK
value|0x0001f000
end_define

begin_define
define|#
directive|define
name|GET_XTENSA_PROP_ALIGNMENT
parameter_list|(
name|flag
parameter_list|)
define|\
value|(((unsigned) ((flag)& (XTENSA_PROP_ALIGNMENT_MASK)))>> 12)
end_define

begin_define
define|#
directive|define
name|SET_XTENSA_PROP_ALIGNMENT
parameter_list|(
name|flag
parameter_list|,
name|align
parameter_list|)
define|\
value|(((flag)& (~XTENSA_PROP_ALIGNMENT_MASK)) | \     (((align)<< 12)& XTENSA_PROP_ALIGNMENT_MASK))
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_INSN_ABSLIT
value|0x00020000
end_define

begin_comment
comment|/* Structure for saving instruction and alignment per-fragment data    that will be written to the object file.  This structure is    equivalent to the actual data that will be written out to the file    but is easier to use.   We provide a conversion to file flags    in frag_flags_to_number.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|frag_flags_struct
name|frag_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|frag_flags_struct
block|{
comment|/* is_literal should only be used after xtensa_move_literals.      If you need to check if you are generating a literal fragment,      then use the generating_literals global.  */
name|unsigned
name|is_literal
range|:
literal|1
decl_stmt|;
name|unsigned
name|is_insn
range|:
literal|1
decl_stmt|;
name|unsigned
name|is_data
range|:
literal|1
decl_stmt|;
name|unsigned
name|is_unreachable
range|:
literal|1
decl_stmt|;
comment|/* is_specific_opcode implies no_transform.  */
name|unsigned
name|is_no_transform
range|:
literal|1
decl_stmt|;
struct|struct
block|{
name|unsigned
name|is_loop_target
range|:
literal|1
decl_stmt|;
name|unsigned
name|is_branch_target
range|:
literal|1
decl_stmt|;
comment|/* Branch targets have a priority.  */
name|unsigned
name|bt_align_priority
range|:
literal|2
decl_stmt|;
name|unsigned
name|is_no_density
range|:
literal|1
decl_stmt|;
comment|/* no_longcalls flag does not need to be placed in the object file.  */
name|unsigned
name|is_no_reorder
range|:
literal|1
decl_stmt|;
comment|/* Uses absolute literal addressing for l32r.  */
name|unsigned
name|is_abslit
range|:
literal|1
decl_stmt|;
block|}
name|insn
struct|;
name|unsigned
name|is_align
range|:
literal|1
decl_stmt|;
name|unsigned
name|alignment
range|:
literal|5
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for saving information about a block of property data    for frags that have the same flags.  */
end_comment

begin_struct
struct|struct
name|xtensa_block_info_struct
block|{
name|segT
name|sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|frag_flags
name|flags
decl_stmt|;
name|struct
name|xtensa_block_info_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for saving the current state before emitting literals.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|emit_state_struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|now_seg
decl_stmt|;
name|subsegT
name|now_subseg
decl_stmt|;
name|int
name|generating_literals
decl_stmt|;
block|}
name|emit_state
typedef|;
end_typedef

begin_comment
comment|/* Opcode placement information */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|bitfield
typedef|;
end_typedef

begin_define
define|#
directive|define
name|bit_is_set
parameter_list|(
name|bit
parameter_list|,
name|bf
parameter_list|)
value|((bf)& (0x01ll<< (bit)))
end_define

begin_define
define|#
directive|define
name|set_bit
parameter_list|(
name|bit
parameter_list|,
name|bf
parameter_list|)
value|((bf) |= (0x01ll<< (bit)))
end_define

begin_define
define|#
directive|define
name|clear_bit
parameter_list|(
name|bit
parameter_list|,
name|bf
parameter_list|)
value|((bf)&= ~(0x01ll<< (bit)))
end_define

begin_define
define|#
directive|define
name|MAX_FORMATS
value|32
end_define

begin_typedef
typedef|typedef
struct|struct
name|op_placement_info_struct
block|{
name|int
name|num_formats
decl_stmt|;
comment|/* A number describing how restrictive the issue is for this      opcode.  For example, an opcode that fits lots of different      formats has a high freedom, as does an opcode that fits      only one format but many slots in that format.  The most      restrictive is the opcode that fits only one slot in one      format.  */
name|int
name|issuef
decl_stmt|;
name|xtensa_format
name|narrowest
decl_stmt|;
name|char
name|narrowest_size
decl_stmt|;
name|char
name|narrowest_slot
decl_stmt|;
comment|/* formats is a bitfield with the Nth bit set      if the opcode fits in the Nth xtensa_format.  */
name|bitfield
name|formats
decl_stmt|;
comment|/* slots[N]'s Mth bit is set if the op fits in the      Mth slot of the Nth xtensa_format.  */
name|bitfield
name|slots
index|[
name|MAX_FORMATS
index|]
decl_stmt|;
comment|/* A count of the number of slots in a given format      an op can fit (i.e., the bitcount of the slot field above).  */
name|char
name|slots_in_format
index|[
name|MAX_FORMATS
index|]
decl_stmt|;
block|}
name|op_placement_info
operator|,
typedef|*
name|op_placement_info_table
typedef|;
end_typedef

begin_decl_stmt
name|op_placement_info_table
name|op_placement_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extra expression types.  */
end_comment

begin_define
define|#
directive|define
name|O_pltrel
value|O_md1
end_define

begin_comment
comment|/* like O_symbol but use a PLT reloc */
end_comment

begin_define
define|#
directive|define
name|O_hi16
value|O_md2
end_define

begin_comment
comment|/* use high 16 bits of symbolic value */
end_comment

begin_define
define|#
directive|define
name|O_lo16
value|O_md3
end_define

begin_comment
comment|/* use low 16 bits of symbolic value */
end_comment

begin_struct
struct|struct
name|suffix_reloc_map
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|length
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|unsigned
name|char
name|operator
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SUFFIX_MAP
parameter_list|(
name|str
parameter_list|,
name|reloc
parameter_list|,
name|op
parameter_list|)
value|{ str, sizeof (str) - 1, reloc, op }
end_define

begin_decl_stmt
specifier|static
name|struct
name|suffix_reloc_map
name|suffix_relocs
index|[]
init|=
block|{
name|SUFFIX_MAP
argument_list|(
literal|"l"
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|O_lo16
argument_list|)
block|,
name|SUFFIX_MAP
argument_list|(
literal|"h"
argument_list|,
name|BFD_RELOC_HI16
argument_list|,
name|O_hi16
argument_list|)
block|,
name|SUFFIX_MAP
argument_list|(
literal|"plt"
argument_list|,
name|BFD_RELOC_XTENSA_PLT
argument_list|,
name|O_pltrel
argument_list|)
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directives.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|directive_none
init|=
literal|0
block|,
name|directive_literal
block|,
name|directive_density
block|,
name|directive_transform
block|,
name|directive_freeregs
block|,
name|directive_longcalls
block|,
name|directive_literal_prefix
block|,
name|directive_schedule
block|,
name|directive_absolute_literals
block|,
name|directive_last_directive
block|}
name|directiveE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|can_be_negated
decl_stmt|;
block|}
name|directive_infoS
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|directive_infoS
name|directive_info
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|FALSE
block|}
block|,
block|{
literal|"literal"
block|,
name|FALSE
block|}
block|,
block|{
literal|"density"
block|,
name|TRUE
block|}
block|,
block|{
literal|"transform"
block|,
name|TRUE
block|}
block|,
block|{
literal|"freeregs"
block|,
name|FALSE
block|}
block|,
block|{
literal|"longcalls"
block|,
name|TRUE
block|}
block|,
block|{
literal|"literal_prefix"
block|,
name|FALSE
block|}
block|,
block|{
literal|"schedule"
block|,
name|TRUE
block|}
block|,
block|{
literal|"absolute-literals"
block|,
name|TRUE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|directive_state
index|[]
init|=
block|{
name|FALSE
block|,
comment|/* none */
name|FALSE
block|,
comment|/* literal */
if|#
directive|if
operator|!
name|XCHAL_HAVE_DENSITY
name|FALSE
block|,
comment|/* density */
else|#
directive|else
name|TRUE
block|,
comment|/* density */
endif|#
directive|endif
name|TRUE
block|,
comment|/* transform */
name|FALSE
block|,
comment|/* freeregs */
name|FALSE
block|,
comment|/* longcalls */
name|FALSE
block|,
comment|/* literal_prefix */
name|FALSE
block|,
comment|/* schedule */
if|#
directive|if
name|XSHAL_USE_ABSOLUTE_LITERALS
name|TRUE
comment|/* absolute_literals */
else|#
directive|else
name|FALSE
comment|/* absolute_literals */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directive functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xtensa_begin_directive
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_end_directive
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_literal_prefix
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_literal_position
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_literal_pseudo
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_frequency_pseudo
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_elf_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parsing and Idiom Translation.  */
end_comment

begin_function_decl
specifier|static
name|bfd_reloc_code_real_type
name|xtensa_elf_suffix
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various Other Internal Functions.  */
end_comment

begin_function_decl
specifier|extern
name|bfd_boolean
name|xg_is_single_relaxable_insn
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|TInsn
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|xg_build_to_insn
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|TInsn
modifier|*
parameter_list|,
name|BuildInstr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_mark_literal_pool_location
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|addressT
name|get_expanded_loop_offset
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fragS
modifier|*
name|get_literal_pool_location
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_literal_pool_location
parameter_list|(
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_set_frag_assembly_state
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_vinsn
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|emit_single_op
parameter_list|(
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|total_frag_text_expansion
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Alignment Functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|get_text_align_power
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_text_align_max_fill_size
parameter_list|(
name|int
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|branch_align_power
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helpers for xtensa_relax_frag().  */
end_comment

begin_function_decl
specifier|static
name|long
name|relax_frag_add_nop
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Accessors for additional per-subsegment information.  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|get_last_insn_flags
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_last_insn_flags
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|,
name|unsigned
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|float
name|get_subseg_total_freq
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|float
name|get_subseg_target_freq
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_subseg_freq
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|,
name|float
parameter_list|,
name|float
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Segment list functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xtensa_move_literals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_reorder_segments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_switch_to_literal_fragment
parameter_list|(
name|emit_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_switch_to_non_abs_literal_fragment
parameter_list|(
name|emit_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_switch_section_emit_state
parameter_list|(
name|emit_state
modifier|*
parameter_list|,
name|segT
parameter_list|,
name|subsegT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_restore_emit_state
parameter_list|(
name|emit_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segT
name|cache_literal_section
parameter_list|(
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Import from elf32-xtensa.c in BFD library.  */
end_comment

begin_function_decl
specifier|extern
name|asection
modifier|*
name|xtensa_get_property_section
parameter_list|(
name|asection
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* op_placement_info functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_op_placement_info_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bfd_boolean
name|opcode_fits_format_slot
parameter_list|(
name|xtensa_opcode
parameter_list|,
name|xtensa_format
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xg_get_single_size
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_format
name|xg_get_single_format
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xg_get_single_slot
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* TInsn and IStack functions.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|tinsn_has_symbolic_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|tinsn_has_invalid_symbolic_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|tinsn_has_complex_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|tinsn_to_insnbuf
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|xtensa_insnbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|tinsn_check_arguments
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tinsn_from_chars
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tinsn_immed_from_frag
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_num_stack_text_bytes
parameter_list|(
name|IStack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_num_stack_literal_bytes
parameter_list|(
name|IStack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vliw_insn functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xg_init_vinsn
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xg_clear_vinsn
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|vinsn_has_specific_opcodes
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xg_free_vinsn
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|vinsn_to_insnbuf
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vinsn_from_chars
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Expression Utilities.  */
end_comment

begin_function_decl
name|bfd_boolean
name|expr_is_const
parameter_list|(
specifier|const
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|offsetT
name|get_expr_const
parameter_list|(
specifier|const
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_expr_const
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bfd_boolean
name|expr_is_register
parameter_list|(
specifier|const
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|offsetT
name|get_expr_register
parameter_list|(
specifier|const
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_expr_symbol_offset
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bfd_boolean
name|expr_is_equal
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_expr
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
specifier|const
name|expressionS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Section renaming.  */
end_comment

begin_function_decl
specifier|static
name|void
name|build_section_rename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ISA imported from bfd.  */
end_comment

begin_decl_stmt
specifier|extern
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_addi_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_addmi_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call0_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call4_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call8_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_call12_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx0_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx4_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx8_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_callx12_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_const16_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_entry_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_movi_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_movi_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_isync_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_jx_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_l32r_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loop_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loopnez_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_loopgtz_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_nop_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_nop_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_or_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_ret_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_ret_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_retw_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_retw_n_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_rsr_lcount_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|xtensa_waiti_opcode
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Command-line Options.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|use_literal_section
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|align_targets
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|warn_unaligned_branch_targets
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|has_a0_b_retw
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_a0_b_retw
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_b_j_loop_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_short_loop
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|maybe_has_short_loop
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_close_loop_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|maybe_has_close_loop_end
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|enforce_three_byte_loop_align
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When workaround_short_loops is TRUE, all loops with early exits must    have at least 3 instructions.  workaround_all_short_loops is a modifier    to the workaround_short_loop flag.  In addition to the    workaround_short_loop actions, all straightline loopgtz and loopnez    must have at least 3 instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|workaround_all_short_loops
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xtensa_setup_hw_workarounds
parameter_list|(
name|int
name|earliest
parameter_list|,
name|int
name|latest
parameter_list|)
block|{
if|if
condition|(
name|earliest
operator|>
name|latest
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"illegal range of target hardware versions"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable all workarounds for pre-T1050.0 hardware.  */
if|if
condition|(
name|earliest
operator|<
literal|105000
operator|||
name|latest
operator|<
literal|105000
condition|)
block|{
name|workaround_a0_b_retw
operator||=
name|TRUE
expr_stmt|;
name|workaround_b_j_loop_end
operator||=
name|TRUE
expr_stmt|;
name|workaround_short_loop
operator||=
name|TRUE
expr_stmt|;
name|workaround_close_loop_end
operator||=
name|TRUE
expr_stmt|;
name|workaround_all_short_loops
operator||=
name|TRUE
expr_stmt|;
name|enforce_three_byte_loop_align
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_enum
enum|enum
block|{
name|option_density
init|=
name|OPTION_MD_BASE
block|,
name|option_no_density
block|,
name|option_relax
block|,
name|option_no_relax
block|,
name|option_link_relax
block|,
name|option_no_link_relax
block|,
name|option_generics
block|,
name|option_no_generics
block|,
name|option_transform
block|,
name|option_no_transform
block|,
name|option_text_section_literals
block|,
name|option_no_text_section_literals
block|,
name|option_absolute_literals
block|,
name|option_no_absolute_literals
block|,
name|option_align_targets
block|,
name|option_no_align_targets
block|,
name|option_warn_unaligned_targets
block|,
name|option_longcalls
block|,
name|option_no_longcalls
block|,
name|option_workaround_a0_b_retw
block|,
name|option_no_workaround_a0_b_retw
block|,
name|option_workaround_b_j_loop_end
block|,
name|option_no_workaround_b_j_loop_end
block|,
name|option_workaround_short_loop
block|,
name|option_no_workaround_short_loop
block|,
name|option_workaround_all_short_loops
block|,
name|option_no_workaround_all_short_loops
block|,
name|option_workaround_close_loop_end
block|,
name|option_no_workaround_close_loop_end
block|,
name|option_no_workarounds
block|,
name|option_rename_section_name
block|,
name|option_prefer_l32r
block|,
name|option_prefer_const16
block|,
name|option_target_hardware
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"density"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_density
block|}
block|,
block|{
literal|"no-density"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_density
block|}
block|,
comment|/* Both "relax" and "generics" are deprecated and treated as equivalent      to the "transform" option.  */
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_relax
block|}
block|,
block|{
literal|"no-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_relax
block|}
block|,
block|{
literal|"generics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_generics
block|}
block|,
block|{
literal|"no-generics"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_generics
block|}
block|,
block|{
literal|"transform"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_transform
block|}
block|,
block|{
literal|"no-transform"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_transform
block|}
block|,
block|{
literal|"text-section-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_text_section_literals
block|}
block|,
block|{
literal|"no-text-section-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_text_section_literals
block|}
block|,
block|{
literal|"absolute-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_absolute_literals
block|}
block|,
block|{
literal|"no-absolute-literals"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_absolute_literals
block|}
block|,
comment|/* This option was changed from -align-target to -target-align      because it conflicted with the "-al" option.  */
block|{
literal|"target-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_align_targets
block|}
block|,
block|{
literal|"no-target-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_align_targets
block|}
block|,
block|{
literal|"warn-unaligned-targets"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_warn_unaligned_targets
block|}
block|,
block|{
literal|"longcalls"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_longcalls
block|}
block|,
block|{
literal|"no-longcalls"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_longcalls
block|}
block|,
block|{
literal|"no-workaround-a0-b-retw"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_a0_b_retw
block|}
block|,
block|{
literal|"workaround-a0-b-retw"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_a0_b_retw
block|}
block|,
block|{
literal|"no-workaround-b-j-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_b_j_loop_end
block|}
block|,
block|{
literal|"workaround-b-j-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_b_j_loop_end
block|}
block|,
block|{
literal|"no-workaround-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_short_loop
block|}
block|,
block|{
literal|"workaround-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_short_loop
block|}
block|,
block|{
literal|"no-workaround-all-short-loops"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_all_short_loops
block|}
block|,
block|{
literal|"workaround-all-short-loop"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_all_short_loops
block|}
block|,
block|{
literal|"prefer-l32r"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_prefer_l32r
block|}
block|,
block|{
literal|"prefer-const16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_prefer_const16
block|}
block|,
block|{
literal|"no-workarounds"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workarounds
block|}
block|,
block|{
literal|"no-workaround-close-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_workaround_close_loop_end
block|}
block|,
block|{
literal|"workaround-close-loop-end"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_workaround_close_loop_end
block|}
block|,
block|{
literal|"rename-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_rename_section_name
block|}
block|,
block|{
literal|"link-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_link_relax
block|}
block|,
block|{
literal|"no-link-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|option_no_link_relax
block|}
block|,
block|{
literal|"target-hardware"
block|,
name|required_argument
block|,
name|NULL
block|,
name|option_target_hardware
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
name|md_longopts
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|option_density
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--density option is ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_density
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--no-density option is ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_link_relax
case|:
name|linkrelax
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_link_relax
case|:
name|linkrelax
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_generics
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--generics is deprecated; use --transform instead"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|md_parse_option
argument_list|(
name|option_transform
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|option_no_generics
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--no-generics is deprecated; use --no-transform instead"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|md_parse_option
argument_list|(
name|option_no_transform
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|option_relax
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--relax is deprecated; use --transform instead"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|md_parse_option
argument_list|(
name|option_transform
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|option_no_relax
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"--no-relax is deprecated; use --no-transform instead"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|md_parse_option
argument_list|(
name|option_no_transform
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|option_longcalls
case|:
name|directive_state
index|[
name|directive_longcalls
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_longcalls
case|:
name|directive_state
index|[
name|directive_longcalls
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_text_section_literals
case|:
name|use_literal_section
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_text_section_literals
case|:
name|use_literal_section
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_absolute_literals
case|:
if|if
condition|(
operator|!
name|absolute_literals_supported
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"--absolute-literals option not supported in this Xtensa configuration"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|directive_state
index|[
name|directive_absolute_literals
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_absolute_literals
case|:
name|directive_state
index|[
name|directive_absolute_literals
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_a0_b_retw
case|:
name|workaround_a0_b_retw
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_a0_b_retw
case|:
name|workaround_a0_b_retw
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_b_j_loop_end
case|:
name|workaround_b_j_loop_end
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_b_j_loop_end
case|:
name|workaround_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_short_loop
case|:
name|workaround_short_loop
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_short_loop
case|:
name|workaround_short_loop
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_all_short_loops
case|:
name|workaround_all_short_loops
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_all_short_loops
case|:
name|workaround_all_short_loops
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_workaround_close_loop_end
case|:
name|workaround_close_loop_end
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workaround_close_loop_end
case|:
name|workaround_close_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_workarounds
case|:
name|workaround_a0_b_retw
operator|=
name|FALSE
expr_stmt|;
name|workaround_b_j_loop_end
operator|=
name|FALSE
expr_stmt|;
name|workaround_short_loop
operator|=
name|FALSE
expr_stmt|;
name|workaround_all_short_loops
operator|=
name|FALSE
expr_stmt|;
name|workaround_close_loop_end
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_align_targets
case|:
name|align_targets
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_no_align_targets
case|:
name|align_targets
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_warn_unaligned_targets
case|:
name|warn_unaligned_branch_targets
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_rename_section_name
case|:
name|build_section_rename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'Q'
case|:
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section          should be emitted or not.  FIXME: Not implemented.  */
return|return
literal|1
return|;
case|case
name|option_prefer_l32r
case|:
if|if
condition|(
name|prefer_const16
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"prefer-l32r conflicts with prefer-const16"
argument_list|)
argument_list|)
expr_stmt|;
name|prefer_l32r
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_prefer_const16
case|:
if|if
condition|(
name|prefer_l32r
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"prefer-const16 conflicts with prefer-l32r"
argument_list|)
argument_list|)
expr_stmt|;
name|prefer_const16
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|option_target_hardware
case|:
block|{
name|int
name|earliest
decl_stmt|,
name|latest
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|0
operator|||
operator|*
name|arg
operator|==
literal|'-'
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid target hardware version"
argument_list|)
argument_list|)
expr_stmt|;
name|earliest
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|0
condition|)
name|latest
operator|=
name|earliest
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid target hardware version"
argument_list|)
argument_list|)
expr_stmt|;
name|latest
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid target hardware version"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_setup_hw_workarounds
argument_list|(
name|earliest
argument_list|,
name|latest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|option_transform
case|:
comment|/* This option has no affect other than to use the defaults, 	 which are already set.  */
return|return
literal|1
return|;
case|case
name|option_no_transform
case|:
comment|/* This option turns off all transformations of any kind. 	 However, because we want to preserve the state of other 	 directives, we only change its own field.  Thus, before 	 you perform any transformation, always check if transform 	 is available.  If you use the functions we provide for this 	 purpose, you will be ok.  */
name|directive_state
index|[
name|directive_transform
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"\n\ Xtensa options:\n\   --[no-]text-section-literals\n\                           [Do not] put literals in the text section\n\   --[no-]absolute-literals\n\                           [Do not] default to use non-PC-relative literals\n\   --[no-]target-align     [Do not] try to align branch targets\n\   --[no-]longcalls        [Do not] emit 32-bit call sequences\n\   --[no-]transform        [Do not] transform instructions\n\   --rename-section old=new Rename section 'old' to 'new'\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions related to the list of current label symbols.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_add_insn_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|sym_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|free_insn_labels
condition|)
name|l
operator|=
operator|(
name|sym_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_list
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
name|free_insn_labels
expr_stmt|;
name|free_insn_labels
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|l
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|sym_list
modifier|*
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
operator|&
name|free_insn_labels
init|;
operator|*
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pl
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_move_labels
parameter_list|(
name|fragS
modifier|*
name|new_frag
parameter_list|,
name|valueT
name|new_offset
parameter_list|)
block|{
name|sym_list
modifier|*
name|lit
decl_stmt|;
for|for
control|(
name|lit
operator|=
name|insn_labels
init|;
name|lit
condition|;
name|lit
operator|=
name|lit
operator|->
name|next
control|)
block|{
name|symbolS
modifier|*
name|lit_sym
init|=
name|lit
operator|->
name|sym
decl_stmt|;
name|S_SET_VALUE
argument_list|(
name|lit_sym
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|lit_sym
argument_list|,
name|new_frag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Directive data and functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|state_stackS_struct
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
name|bfd_boolean
name|old_state
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|void
modifier|*
name|datum
decl_stmt|;
name|struct
name|state_stackS_struct
modifier|*
name|prev
decl_stmt|;
block|}
name|state_stackS
typedef|;
end_typedef

begin_decl_stmt
name|state_stackS
modifier|*
name|directive_state_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0).  */
block|{
literal|"literal_position"
block|,
name|xtensa_literal_position
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Formerly used for STABS debugging.  */
block|{
literal|"long"
block|,
name|xtensa_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|xtensa_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"short"
block|,
name|xtensa_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"begin"
block|,
name|xtensa_begin_directive
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|xtensa_end_directive
block|,
literal|0
block|}
block|,
block|{
literal|"literal"
block|,
name|xtensa_literal_pseudo
block|,
literal|0
block|}
block|,
block|{
literal|"frequency"
block|,
name|xtensa_frequency_pseudo
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|use_transform
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* After md_end, you should be checking frag by frag, rather      than state directives.  */
name|assert
argument_list|(
operator|!
name|past_xtensa_end
argument_list|)
expr_stmt|;
return|return
name|directive_state
index|[
name|directive_transform
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|do_align_targets
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do not use this function after md_end; just look at align_targets      instead.  There is no target-align directive, so alignment is either      enabled for all frags or not done at all.  */
name|assert
argument_list|(
operator|!
name|past_xtensa_end
argument_list|)
expr_stmt|;
return|return
name|align_targets
operator|&&
name|use_transform
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_push
parameter_list|(
name|directiveE
name|directive
parameter_list|,
name|bfd_boolean
name|negated
parameter_list|,
specifier|const
name|void
modifier|*
name|datum
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|state_stackS
modifier|*
name|stack
init|=
operator|(
name|state_stackS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|state_stackS
argument_list|)
argument_list|)
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|stack
operator|->
name|directive
operator|=
name|directive
expr_stmt|;
name|stack
operator|->
name|negated
operator|=
name|negated
expr_stmt|;
name|stack
operator|->
name|old_state
operator|=
name|directive_state
index|[
name|directive
index|]
expr_stmt|;
name|stack
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|stack
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|stack
operator|->
name|datum
operator|=
name|datum
expr_stmt|;
name|stack
operator|->
name|prev
operator|=
name|directive_state_stack
expr_stmt|;
name|directive_state_stack
operator|=
name|stack
expr_stmt|;
name|directive_state
index|[
name|directive
index|]
operator|=
operator|!
name|negated
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_pop
parameter_list|(
name|directiveE
modifier|*
name|directive
parameter_list|,
name|bfd_boolean
modifier|*
name|negated
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
modifier|*
name|line
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|datum
parameter_list|)
block|{
name|state_stackS
modifier|*
name|top
init|=
name|directive_state_stack
decl_stmt|;
if|if
condition|(
operator|!
name|directive_state_stack
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unmatched end directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|directive
operator|=
name|directive_none
expr_stmt|;
return|return;
block|}
name|directive_state
index|[
name|directive_state_stack
operator|->
name|directive
index|]
operator|=
name|top
operator|->
name|old_state
expr_stmt|;
operator|*
name|directive
operator|=
name|top
operator|->
name|directive
expr_stmt|;
operator|*
name|negated
operator|=
name|top
operator|->
name|negated
expr_stmt|;
operator|*
name|file
operator|=
name|top
operator|->
name|file
expr_stmt|;
operator|*
name|line
operator|=
name|top
operator|->
name|line
expr_stmt|;
operator|*
name|datum
operator|=
name|top
operator|->
name|datum
expr_stmt|;
name|directive_state_stack
operator|=
name|top
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|directive_balance
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|directive_state_stack
condition|)
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|void
modifier|*
name|datum
decl_stmt|;
name|directive_pop
argument_list|(
operator|&
name|directive
argument_list|,
operator|&
name|negated
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|datum
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|".begin directive with no matching .end directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|inside_directive
parameter_list|(
name|directiveE
name|dir
parameter_list|)
block|{
name|state_stackS
modifier|*
name|top
init|=
name|directive_state_stack
decl_stmt|;
while|while
condition|(
name|top
operator|&&
name|top
operator|->
name|directive
operator|!=
name|dir
condition|)
name|top
operator|=
name|top
operator|->
name|prev
expr_stmt|;
return|return
operator|(
name|top
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_directive
parameter_list|(
name|directiveE
modifier|*
name|directive
parameter_list|,
name|bfd_boolean
modifier|*
name|negated
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|char
modifier|*
name|directive_string
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|negated
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
operator|*
name|negated
operator|=
name|TRUE
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
name|len
operator|=
name|strspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz_-/0123456789."
argument_list|)
expr_stmt|;
comment|/* This code is a hack to make .begin [no-][generics|relax] exactly      equivalent to .begin [no-]transform.  We should remove it when      we stop accepting those options.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"generics"
argument_list|,
name|strlen
argument_list|(
literal|"generics"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"[no-]generics is deprecated; use [no-]transform instead"
argument_list|)
argument_list|)
expr_stmt|;
name|directive_string
operator|=
literal|"transform"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"relax"
argument_list|,
name|strlen
argument_list|(
literal|"relax"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"[no-]relax is deprecated; use [no-]transform instead"
argument_list|)
argument_list|)
expr_stmt|;
name|directive_string
operator|=
literal|"transform"
expr_stmt|;
block|}
else|else
name|directive_string
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|directive_info
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|directive_info
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|directive_string
argument_list|,
name|directive_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
name|len
expr_stmt|;
operator|*
name|directive
operator|=
operator|(
name|directiveE
operator|)
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|negated
operator|&&
operator|!
name|directive_info
index|[
name|i
index|]
operator|.
name|can_be_negated
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directive %s cannot be negated"
argument_list|)
argument_list|,
name|directive_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|directive
operator|=
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_begin_directive
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|directiveE
name|directive
decl_stmt|;
name|bfd_boolean
name|negated
decl_stmt|;
name|emit_state
modifier|*
name|state
decl_stmt|;
name|lit_state
modifier|*
name|ls
decl_stmt|;
name|get_directive
argument_list|(
operator|&
name|directive
argument_list|,
operator|&
name|negated
argument_list|)
expr_stmt|;
if|if
condition|(
name|directive
operator|==
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
condition|)
block|{
name|discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directives are not valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|directive
condition|)
block|{
case|case
name|directive_literal
case|:
if|if
condition|(
operator|!
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
comment|/* Previous labels go with whatever follows this directive, not with 	     the literal, so save them now.  */
name|saved_insn_labels
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
block|}
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin literal is deprecated; use .literal instead"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
name|emit_state
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|emit_state
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive_literal
argument_list|,
name|negated
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_literal_prefix
case|:
comment|/* Have to flush pending output because a movi relaxed to an l32r 	 might produce a literal.  */
name|md_flush_pending_output
argument_list|()
expr_stmt|;
comment|/* Check to see if the current fragment is a literal 	 fragment.  If it is, then this operation is not allowed.  */
if|if
condition|(
name|generating_literals
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot set literal_prefix inside literal fragment"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate the literal state for this section and push 	 onto the directive stack.  */
name|ls
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lit_state
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ls
argument_list|)
expr_stmt|;
operator|*
name|ls
operator|=
name|default_lit_sections
expr_stmt|;
name|directive_push
argument_list|(
name|directive_literal_prefix
argument_list|,
name|negated
argument_list|,
name|ls
argument_list|)
expr_stmt|;
comment|/* Process the new prefix.  */
name|xtensa_literal_prefix
argument_list|()
expr_stmt|;
break|break;
case|case
name|directive_freeregs
case|:
comment|/* This information is currently unused, but we'll accept the statement          and just discard the rest of the line.  This won't check the syntax,          but it will accept every correct freeregs directive.  */
name|input_line_pointer
operator|+=
name|strcspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive_freeregs
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_schedule
case|:
name|md_flush_pending_output
argument_list|()
expr_stmt|;
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|frag_now
operator|->
name|fr_subtype
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive_schedule
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_density
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".begin [no-]density is ignored"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_absolute_literals
case|:
name|md_flush_pending_output
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|absolute_literals_supported
operator|&&
operator|!
name|negated
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Xtensa absolute literals option not supported; ignored"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|md_flush_pending_output
argument_list|()
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|directive_push
argument_list|(
name|directive
argument_list|,
name|negated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_end_directive
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|directiveE
name|begin_directive
decl_stmt|,
name|end_directive
decl_stmt|;
name|bfd_boolean
name|begin_negated
decl_stmt|,
name|end_negated
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|emit_state
modifier|*
name|state
decl_stmt|;
name|emit_state
modifier|*
modifier|*
name|state_ptr
decl_stmt|;
name|lit_state
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directives are not valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
name|get_directive
argument_list|(
operator|&
name|end_directive
argument_list|,
operator|&
name|end_negated
argument_list|)
expr_stmt|;
name|md_flush_pending_output
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|end_directive
condition|)
block|{
case|case
operator|(
name|directiveE
operator|)
name|XTENSA_UNDEFINED
case|:
name|discard_rest_of_line
argument_list|()
expr_stmt|;
return|return;
case|case
name|directive_density
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end [no-]density is ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
case|case
name|directive_absolute_literals
case|:
if|if
condition|(
operator|!
name|absolute_literals_supported
operator|&&
operator|!
name|end_negated
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Xtensa absolute literals option not supported; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
name|state_ptr
operator|=
operator|&
name|state
expr_stmt|;
comment|/* use state_ptr to avoid type-punning warning */
name|directive_pop
argument_list|(
operator|&
name|begin_directive
argument_list|,
operator|&
name|begin_negated
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
name|state_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_directive
operator|!=
name|directive_none
condition|)
block|{
if|if
condition|(
name|begin_directive
operator|!=
name|end_directive
operator|||
name|begin_negated
operator|!=
name|end_negated
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"does not match begin %s%s at %s:%d"
argument_list|)
argument_list|,
name|begin_negated
condition|?
literal|"no-"
else|:
literal|""
argument_list|,
name|directive_info
index|[
name|begin_directive
index|]
operator|.
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|end_directive
condition|)
block|{
case|case
name|directive_literal
case|:
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
comment|/* Restore the list of current labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
name|insn_labels
operator|=
name|saved_insn_labels
expr_stmt|;
block|}
break|break;
case|case
name|directive_literal_prefix
case|:
comment|/* Restore the default collection sections from saved state.  */
name|s
operator|=
operator|(
name|lit_state
operator|*
operator|)
name|state
expr_stmt|;
name|assert
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|default_lit_sections
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Free the state storage.  */
name|free
argument_list|(
name|s
operator|->
name|lit_prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|directive_schedule
case|:
case|case
name|directive_freeregs
case|:
break|break;
default|default:
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place an aligned literal fragment at the current location.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_literal_position
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|md_flush_pending_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".literal_position inside literal directive; ignoring"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support .literal label, expr, ...  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_literal_pseudo
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|emit_state
name|state
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|base_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|segT
name|dest_seg
decl_stmt|;
if|if
condition|(
name|inside_directive
argument_list|(
name|directive_literal
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".literal not allowed inside .begin literal region"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|md_flush_pending_output
argument_list|()
expr_stmt|;
comment|/* Previous labels go with whatever follows this directive, not with      the literal, so save them now.  */
name|saved_insn_labels
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
comment|/* If we are using text-section literals, then this is the right value... */
name|dest_seg
operator|=
name|now_seg
expr_stmt|;
name|base_name
operator|=
name|input_line_pointer
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* ...but if we aren't using text-section-literals, then we      need to put them in the section we just switched to.  */
if|if
condition|(
name|use_literal_section
operator|||
name|directive_state
index|[
name|directive_absolute_literals
index|]
condition|)
name|dest_seg
operator|=
name|now_seg
expr_stmt|;
comment|/* All literals are aligned to four-byte boundaries.  */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma or colon after symbol name; "
literal|"rest of line ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|colon
argument_list|(
name|base_name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' or ':' */
name|xtensa_elf_cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* Restore the list of current labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
name|insn_labels
operator|=
name|saved_insn_labels
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_literal_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Parse the new prefix from the input_line_pointer.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|len
operator|=
name|strspn
argument_list|(
name|input_line_pointer
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
literal|"abcdefghijklmnopqrstuvwxyz_/0123456789.$"
argument_list|)
expr_stmt|;
comment|/* Get a null-terminated copy of the name.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|input_line_pointer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Skip the name in the input line.  */
name|input_line_pointer
operator|+=
name|len
expr_stmt|;
name|default_lit_sections
operator|.
name|lit_prefix
operator|=
name|name
expr_stmt|;
comment|/* Clear cached literal sections, since the prefix has changed.  */
name|default_lit_sections
operator|.
name|lit_seg
operator|=
name|NULL
expr_stmt|;
name|default_lit_sections
operator|.
name|lit4_seg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support ".frequency branch_target_frequency fall_through_frequency".  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_frequency_pseudo
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|float
name|fall_through_f
decl_stmt|,
name|target_f
decl_stmt|;
name|fall_through_f
operator|=
operator|(
name|float
operator|)
name|strtod
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fall_through_f
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"fall through frequency must be greater than 0"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|target_f
operator|=
operator|(
name|float
operator|)
name|strtod
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_f
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branch target frequency must be greater than 0"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|set_subseg_freq
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|target_f
operator|+
name|fall_through_f
argument_list|,
name|target_f
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like normal .long/.short/.word, except support @plt, etc.    Clobbers input_line_pointer, checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_elf_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|md_flush_pending_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directives are not valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'@'
operator|&&
operator|(
operator|(
name|reloc
operator|=
name|xtensa_elf_suffix
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_NONE
operator|)
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_UNUSED
operator|||
operator|!
name|reloc_howto
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported relocation"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reloc
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_OP
operator|&&
name|reloc
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_OP
operator|)
operator|||
operator|(
name|reloc
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_ALT
operator|&&
name|reloc
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_ALT
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode-specific %s relocation used outside "
literal|"an instruction"
argument_list|)
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|!=
operator|(
name|int
operator|)
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|)
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
decl_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parsing and Idiom Translation.  */
end_comment

begin_comment
comment|/* Parse @plt, etc. and return the desired relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|xtensa_elf_suffix
parameter_list|(
name|char
modifier|*
modifier|*
name|str_p
parameter_list|,
name|expressionS
modifier|*
name|exp_p
parameter_list|)
block|{
name|char
name|ident
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|suffix_reloc_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'@'
condition|)
return|return
name|BFD_RELOC_NONE
return|;
for|for
control|(
name|ch
operator|=
operator|*
name|str
operator|,
name|str2
operator|=
name|ident
init|;
operator|(
name|str2
operator|<
name|ident
operator|+
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
operator|-
literal|1
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'@'
operator|)
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|str
control|)
block|{
operator|*
name|str2
operator|++
operator|=
operator|(
name|ISLOWER
argument_list|(
name|ch
argument_list|)
operator|)
condition|?
name|ch
else|:
name|TOLOWER
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
operator|*
name|str2
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|str2
operator|-
name|ident
expr_stmt|;
name|ch
operator|=
name|ident
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|suffix_relocs
index|[
literal|0
index|]
init|;
name|ptr
operator|->
name|length
operator|>
literal|0
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|ch
operator|==
name|ptr
operator|->
name|suffix
index|[
literal|0
index|]
operator|&&
name|len
operator|==
name|ptr
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|ident
argument_list|,
name|ptr
operator|->
name|suffix
argument_list|,
name|ptr
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Now check for "identifier@suffix+constant".  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|char
modifier|*
name|orig_line
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|new_exp
decl_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|&
name|input_line_pointer
operator|!=
name|str_p
condition|)
name|input_line_pointer
operator|=
name|orig_line
expr_stmt|;
block|}
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
return|return
name|ptr
operator|->
name|reloc
return|;
block|}
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Find the matching operator type.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|map_suffix_reloc_to_operator
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|)
block|{
name|struct
name|suffix_reloc_map
modifier|*
name|sfx
decl_stmt|;
name|unsigned
name|char
name|operator
init|=
operator|(
name|unsigned
name|char
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|sfx
operator|=
operator|&
name|suffix_relocs
index|[
literal|0
index|]
init|;
name|sfx
operator|->
name|suffix
condition|;
name|sfx
operator|++
control|)
block|{
if|if
condition|(
name|sfx
operator|->
name|reloc
operator|==
name|reloc
condition|)
block|{
name|operator
operator|=
name|sfx
operator|->
name|operator
expr_stmt|;
break|break;
block|}
block|}
name|assert
argument_list|(
name|operator
operator|!=
operator|(
name|unsigned
name|char
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|operator
return|;
block|}
end_function

begin_comment
comment|/* Find the matching reloc type.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|map_operator_to_reloc
parameter_list|(
name|unsigned
name|char
name|operator
parameter_list|)
block|{
name|struct
name|suffix_reloc_map
modifier|*
name|sfx
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
init|=
name|BFD_RELOC_UNUSED
decl_stmt|;
for|for
control|(
name|sfx
operator|=
operator|&
name|suffix_relocs
index|[
literal|0
index|]
init|;
name|sfx
operator|->
name|suffix
condition|;
name|sfx
operator|++
control|)
block|{
if|if
condition|(
name|sfx
operator|->
name|operator
operator|==
name|operator
condition|)
block|{
name|reloc
operator|=
name|sfx
operator|->
name|reloc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
return|return
name|BFD_RELOC_32
return|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|expression_end
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'}'
case|:
case|case
literal|';'
case|:
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
case|case
literal|':'
case|:
return|return
name|name
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
operator|++
name|name
expr_stmt|;
continue|continue;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ERROR_REG_NUM
value|((unsigned) -1)
end_define

begin_function
specifier|static
name|unsigned
name|tc_get_register
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|unsigned
name|reg
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_line_pointer
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|old_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Accept "sp" as a synonym for "a1".  */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|expression_end
argument_list|(
name|input_line_pointer
operator|+
literal|2
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
comment|/* AR[1] */
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
operator|*
name|prefix
operator|++
condition|)
empty_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
operator|--
name|prefix
expr_stmt|;
if|if
condition|(
operator|*
name|prefix
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name: %s"
argument_list|)
argument_list|,
name|old_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register number: %s"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
name|reg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|int
operator|)
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|reg
operator|=
name|reg
operator|*
literal|10
operator|+
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_expr
operator|=
name|expression_end
argument_list|(
name|input_line_pointer
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register name: %s"
argument_list|)
argument_list|,
name|old_line_pointer
argument_list|)
expr_stmt|;
return|return
name|ERROR_REG_NUM
return|;
block|}
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|next_expr
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expression_maybe_register
parameter_list|(
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|expressionS
modifier|*
name|tok
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
comment|/* Check if this is an immediate operand.  */
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|segT
name|t
init|=
name|expression
argument_list|(
name|tok
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|absolute_section
operator|&&
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|1
condition|)
block|{
name|assert
argument_list|(
name|tok
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|tok
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|tok
operator|->
name|X_add_symbol
operator|=
operator|&
name|abs_symbol
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tok
operator|->
name|X_op
operator|==
name|O_constant
operator|||
name|tok
operator|->
name|X_op
operator|==
name|O_symbol
operator|)
operator|&&
operator|(
operator|(
name|reloc
operator|=
name|xtensa_elf_suffix
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|tok
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_NONE
operator|)
condition|)
block|{
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported relocation"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tok
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_LO16
case|:
name|tok
operator|->
name|X_add_number
operator|&=
literal|0xffff
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_HI16
case|:
name|tok
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|tok
operator|->
name|X_add_number
operator|)
operator|>>
literal|16
expr_stmt|;
return|return;
default|default:
break|break;
block|}
block|}
name|tok
operator|->
name|X_op
operator|=
name|map_suffix_reloc_to_operator
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xtensa_regfile
name|opnd_rf
init|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
decl_stmt|;
name|unsigned
name|reg
init|=
name|tc_get_register
argument_list|(
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
name|ERROR_REG_NUM
condition|)
comment|/* Already errored */
block|{
name|uint32
name|buf
init|=
name|reg
decl_stmt|;
if|if
condition|(
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register number out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tok
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|tok
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|tok
operator|->
name|X_add_number
operator|=
name|reg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split up the arguments for an opcode or pseudo-op.  */
end_comment

begin_function
specifier|static
name|int
name|tokenize_arguments
parameter_list|(
name|char
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
name|bfd_boolean
name|saw_comma
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|saw_arg
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|saw_colon
init|=
name|FALSE
decl_stmt|;
name|int
name|num_args
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg_end
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|arg_len
decl_stmt|;
comment|/* Save and restore input_line_pointer around this function.  */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'}'
case|:
goto|goto
name|fini
goto|;
case|case
literal|':'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|saw_comma
operator|||
name|saw_colon
operator|||
operator|!
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|saw_colon
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|saw_comma
operator|||
name|saw_colon
operator|||
operator|!
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|saw_comma
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|saw_comma
operator|&&
operator|!
name|saw_colon
operator|&&
name|saw_arg
condition|)
goto|goto
name|err
goto|;
name|arg_end
operator|=
name|input_line_pointer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|expression_end
argument_list|(
name|arg_end
argument_list|)
condition|)
name|arg_end
operator|+=
literal|1
expr_stmt|;
name|arg_len
operator|=
name|arg_end
operator|-
name|input_line_pointer
expr_stmt|;
name|arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|saw_colon
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|arg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|num_args
index|]
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|saw_colon
condition|)
operator|*
name|arg
operator|++
operator|=
literal|':'
expr_stmt|;
name|strncpy
argument_list|(
name|arg
argument_list|,
name|input_line_pointer
argument_list|,
name|arg_len
argument_list|)
expr_stmt|;
name|arg
index|[
name|arg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_line_pointer
operator|=
name|arg_end
expr_stmt|;
name|num_args
operator|+=
literal|1
expr_stmt|;
name|saw_comma
operator|=
name|FALSE
expr_stmt|;
name|saw_colon
operator|=
name|FALSE
expr_stmt|;
name|saw_arg
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|fini
label|:
if|if
condition|(
name|saw_comma
operator|||
name|saw_colon
condition|)
goto|goto
name|err
goto|;
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
name|num_args
return|;
name|err
label|:
if|if
condition|(
name|saw_comma
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"extra comma"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_colon
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"extra colon"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|saw_arg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing argument"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing comma or colon"
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse the arguments to an opcode.  Return TRUE on error.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_arguments
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|int
name|num_args
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_strings
parameter_list|)
block|{
name|expressionS
modifier|*
name|tok
decl_stmt|,
modifier|*
name|last_tok
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|insn
operator|->
name|opcode
decl_stmt|;
name|bfd_boolean
name|had_error
init|=
name|TRUE
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|n
decl_stmt|,
name|num_regs
init|=
literal|0
decl_stmt|;
name|int
name|opcode_operand_count
decl_stmt|;
name|int
name|opnd_cnt
decl_stmt|,
name|last_opnd_cnt
decl_stmt|;
name|unsigned
name|int
name|next_reg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
condition|)
name|opcode_operand_count
operator|=
literal|1
expr_stmt|;
else|else
name|opcode_operand_count
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|tok
operator|=
name|insn
operator|->
name|tok
expr_stmt|;
name|memset
argument_list|(
name|tok
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tok
argument_list|)
operator|*
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
comment|/* Save and restore input_line_pointer around this function.  */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|last_tok
operator|=
literal|0
expr_stmt|;
name|last_opnd_cnt
operator|=
operator|-
literal|1
expr_stmt|;
name|opnd_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Skip invisible operands.  */
while|while
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd_cnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opnd_cnt
operator|+=
literal|1
expr_stmt|;
name|tok
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_args
condition|;
name|n
operator|++
control|)
block|{
name|input_line_pointer
operator|=
name|arg_strings
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
name|xtensa_regfile
name|opnd_rf
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|num_regs
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|assert
argument_list|(
name|opnd_cnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|num_regs
operator|--
expr_stmt|;
name|opnd_rf
operator|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|last_opnd_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_reg
operator|!=
name|tc_get_register
argument_list|(
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"incorrect register number, ignoring"
argument_list|)
argument_list|)
expr_stmt|;
name|next_reg
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opnd_cnt
operator|>=
name|opcode_operand_count
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|assert
argument_list|(
name|opnd_cnt
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|expression_maybe_register
argument_list|(
name|opcode
argument_list|,
name|opnd_cnt
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|next_reg
operator|=
name|tok
operator|->
name|X_add_number
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|X_op
operator|==
name|O_illegal
operator|||
name|tok
operator|->
name|X_op
operator|==
name|O_absent
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd_cnt
argument_list|)
operator|==
literal|1
condition|)
block|{
name|num_regs
operator|=
name|xtensa_operand_num_regs
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd_cnt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* minus 1 because we are seeing one right now */
block|}
else|else
name|num_regs
operator|=
literal|0
expr_stmt|;
name|last_tok
operator|=
name|tok
expr_stmt|;
name|last_opnd_cnt
operator|=
name|opnd_cnt
expr_stmt|;
do|do
block|{
name|opnd_cnt
operator|+=
literal|1
expr_stmt|;
name|tok
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd_cnt
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
block|}
if|if
condition|(
name|num_regs
operator|>
literal|0
operator|&&
operator|(
operator|(
name|int
operator|)
name|next_reg
operator|!=
name|last_tok
operator|->
name|X_add_number
operator|+
literal|1
operator|)
condition|)
goto|goto
name|err
goto|;
name|insn
operator|->
name|ntok
operator|=
name|tok
operator|-
name|insn
operator|->
name|tok
expr_stmt|;
name|had_error
operator|=
name|FALSE
expr_stmt|;
name|err
label|:
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
return|return
name|had_error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_invisible_operands
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_opcode
name|opc
init|=
name|insn
operator|->
name|opcode
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|opnd
decl_stmt|,
name|fmt_found
decl_stmt|;
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|slotbuf
condition|)
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Find format/slot where this can be encoded.  */
name|fmt_found
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fmt
operator|=
literal|0
init|;
name|fmt
operator|<
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
condition|;
name|fmt
operator|++
control|)
block|{
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
name|opc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fmt_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fmt_found
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|fmt_found
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot encode opcode \"%s\""
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* First encode all the visible operands      (to deal with shared field operands).  */
for|for
control|(
name|opnd
operator|=
literal|0
init|;
name|opnd
operator|<
name|insn
operator|->
name|ntok
condition|;
name|opnd
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_op
operator|==
name|O_constant
operator|)
condition|)
block|{
name|val
operator|=
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_add_number
expr_stmt|;
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Then pull out the values for the invisible ones.  */
for|for
control|(
name|opnd
operator|=
literal|0
init|;
name|opnd
operator|<
name|insn
operator|->
name|ntok
condition|;
name|opnd
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_add_number
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|1
condition|)
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_op
operator|=
name|O_register
expr_stmt|;
else|else
name|insn
operator|->
name|tok
index|[
name|opnd
index|]
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_reverse_shift_count
parameter_list|(
name|char
modifier|*
modifier|*
name|cnt_argp
parameter_list|)
block|{
name|char
modifier|*
name|cnt_arg
decl_stmt|,
modifier|*
name|new_arg
decl_stmt|;
name|cnt_arg
operator|=
operator|*
name|cnt_argp
expr_stmt|;
comment|/* replace the argument with "31-(argument)" */
name|new_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cnt_arg
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_arg
argument_list|,
literal|"31-(%s)"
argument_list|,
name|cnt_arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cnt_arg
argument_list|)
expr_stmt|;
operator|*
name|cnt_argp
operator|=
name|new_arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If "arg" is a constant expression, return non-zero with the value    in *valp.  */
end_comment

begin_function
specifier|static
name|int
name|xg_arg_is_constant
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|offsetT
modifier|*
name|valp
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|save_ptr
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
name|arg
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
operator|*
name|valp
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_replace_opname
parameter_list|(
name|char
modifier|*
modifier|*
name|popname
parameter_list|,
name|char
modifier|*
name|newop
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|popname
argument_list|)
expr_stmt|;
operator|*
name|popname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|newop
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|popname
argument_list|,
name|newop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_check_num_args
parameter_list|(
name|int
modifier|*
name|pnum_args
parameter_list|,
name|int
name|expected_num
parameter_list|,
name|char
modifier|*
name|opname
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_strings
parameter_list|)
block|{
name|int
name|num_args
init|=
operator|*
name|pnum_args
decl_stmt|;
if|if
condition|(
name|num_args
operator|<
name|expected_num
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"not enough operands (%d) for '%s'; expected %d"
argument_list|)
argument_list|,
name|num_args
argument_list|,
name|opname
argument_list|,
name|expected_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|num_args
operator|>
name|expected_num
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"too many operands (%d) for '%s'; expected %d"
argument_list|)
argument_list|,
name|num_args
argument_list|,
name|opname
argument_list|,
name|expected_num
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_args
operator|--
operator|>
name|expected_num
condition|)
block|{
name|free
argument_list|(
name|arg_strings
index|[
name|num_args
index|]
argument_list|)
expr_stmt|;
name|arg_strings
index|[
name|num_args
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pnum_args
operator|=
name|expected_num
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the register is not specified as part of the opcode,    then get it from the operand and move it to the opcode.  */
end_comment

begin_function
specifier|static
name|int
name|xg_translate_sysreg_op
parameter_list|(
name|char
modifier|*
modifier|*
name|popname
parameter_list|,
name|int
modifier|*
name|pnum_args
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_strings
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_sysreg
name|sr
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|,
modifier|*
name|new_opname
decl_stmt|;
specifier|const
name|char
modifier|*
name|sr_name
decl_stmt|;
name|int
name|is_user
decl_stmt|,
name|is_write
decl_stmt|;
name|opname
operator|=
operator|*
name|popname
expr_stmt|;
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
name|opname
operator|+=
literal|1
expr_stmt|;
name|is_user
operator|=
operator|(
name|opname
index|[
literal|1
index|]
operator|==
literal|'u'
operator|)
expr_stmt|;
name|is_write
operator|=
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
expr_stmt|;
comment|/* Opname == [rw]ur or [rwx]sr... */
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|2
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check if the argument is a symbolic register name.  */
name|sr
operator|=
name|xtensa_sysreg_lookup_name
argument_list|(
name|isa
argument_list|,
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Handle WSR to "INTSET" as a special case.  */
if|if
condition|(
name|sr
operator|==
name|XTENSA_UNDEFINED
operator|&&
name|is_write
operator|&&
operator|!
name|is_user
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
literal|"intset"
argument_list|)
condition|)
name|sr
operator|=
name|xtensa_sysreg_lookup_name
argument_list|(
name|isa
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|XTENSA_UNDEFINED
operator|||
operator|(
name|xtensa_sysreg_is_user
argument_list|(
name|isa
argument_list|,
name|sr
argument_list|)
operator|==
literal|1
operator|)
operator|!=
name|is_user
condition|)
block|{
comment|/* Maybe it's a register number.... */
name|offsetT
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|xg_arg_is_constant
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register '%s' for '%s' instruction"
argument_list|)
argument_list|,
name|arg_strings
index|[
literal|1
index|]
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sr
operator|=
name|xtensa_sysreg_lookup
argument_list|(
name|isa
argument_list|,
name|val
argument_list|,
name|is_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register number (%ld) for '%s' instruction"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Remove the last argument, which is now part of the opcode.  */
name|free
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|1
expr_stmt|;
comment|/* Translate the opcode.  */
name|sr_name
operator|=
name|xtensa_sysreg_name
argument_list|(
name|isa
argument_list|,
name|sr
argument_list|)
expr_stmt|;
comment|/* Another special case for "WSR.INTSET"....  */
if|if
condition|(
name|is_write
operator|&&
operator|!
name|is_user
operator|&&
operator|!
name|strcasecmp
argument_list|(
literal|"interrupt"
argument_list|,
name|sr_name
argument_list|)
condition|)
name|sr_name
operator|=
literal|"intset"
expr_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|sr_name
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
literal|"%s.%s"
argument_list|,
operator|*
name|popname
argument_list|,
name|sr_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|popname
argument_list|)
expr_stmt|;
operator|*
name|popname
operator|=
name|new_opname
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xtensa_translate_old_userreg_ops
parameter_list|(
name|char
modifier|*
modifier|*
name|popname
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_sysreg
name|sr
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|,
modifier|*
name|new_opname
decl_stmt|;
specifier|const
name|char
modifier|*
name|sr_name
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
name|opname
operator|=
operator|*
name|popname
expr_stmt|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
name|sr
operator|=
name|xtensa_sysreg_lookup_name
argument_list|(
name|isa
argument_list|,
name|opname
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|XTENSA_UNDEFINED
condition|)
block|{
comment|/* The new default name ("nnn") is different from the old default 	 name ("URnnn").  The old default is handled below, and we don't 	 want to recognize [RW]nnn, so do nothing if the name is the (new) 	 default.  */
specifier|static
name|char
name|namebuf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%d"
argument_list|,
name|xtensa_sysreg_number
argument_list|(
name|isa
argument_list|,
name|sr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|namebuf
argument_list|,
name|opname
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Only continue if the reg name is "URnnn".  */
if|if
condition|(
name|opname
index|[
literal|1
index|]
operator|!=
literal|'u'
operator|||
name|opname
index|[
literal|2
index|]
operator|!=
literal|'r'
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|strtoul
argument_list|(
name|opname
operator|+
literal|3
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|sr
operator|=
name|xtensa_sysreg_lookup
argument_list|(
name|isa
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register number (%ld) for '%s'"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Translate the opcode.  */
name|sr_name
operator|=
name|xtensa_sysreg_name
argument_list|(
name|isa
argument_list|,
name|sr
argument_list|)
expr_stmt|;
name|new_opname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|sr_name
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_opname
argument_list|,
literal|"%s%cur.%s"
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_"
else|:
literal|""
operator|)
argument_list|,
name|opname
index|[
literal|0
index|]
argument_list|,
name|sr_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|popname
argument_list|)
expr_stmt|;
operator|*
name|popname
operator|=
name|new_opname
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xtensa_translate_zero_immed
parameter_list|(
name|char
modifier|*
name|old_op
parameter_list|,
name|char
modifier|*
name|new_op
parameter_list|,
name|char
modifier|*
modifier|*
name|popname
parameter_list|,
name|int
modifier|*
name|pnum_args
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_strings
parameter_list|)
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|opname
operator|=
operator|*
name|popname
expr_stmt|;
name|assert
argument_list|(
name|opname
index|[
literal|0
index|]
operator|!=
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
name|old_op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|3
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xg_arg_is_constant
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
operator|&
name|val
argument_list|)
operator|&&
name|val
operator|==
literal|0
condition|)
block|{
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
name|new_op
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
name|arg_strings
index|[
literal|2
index|]
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the instruction is an idiom (i.e., a built-in macro), translate it.    Returns non-zero if an error was found.  */
end_comment

begin_function
specifier|static
name|int
name|xg_translate_idioms
parameter_list|(
name|char
modifier|*
modifier|*
name|popname
parameter_list|,
name|int
modifier|*
name|pnum_args
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_strings
parameter_list|)
block|{
name|char
modifier|*
name|opname
init|=
operator|*
name|popname
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|use_transform
argument_list|()
operator|&&
operator|!
name|has_underbar
operator|&&
name|density_supported
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"mov.n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|2
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_or"
else|:
literal|"or"
operator|)
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"bbsi.l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|3
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_bbsi"
else|:
literal|"bbsi"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|xg_reverse_shift_count
argument_list|(
operator|&
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"bbci.l"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|3
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_bbci"
else|:
literal|"bbci"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|xg_reverse_shift_count
argument_list|(
operator|&
name|arg_strings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Don't do anything special with NOPs inside FLIX instructions.  They      are handled elsewhere.  Real NOP instructions are always available       in configurations with FLIX, so this should never be an issue but      check for it anyway.  */
if|if
condition|(
operator|!
name|cur_vinsn
operator|.
name|inside_bundle
operator|&&
name|xtensa_nop_opcode
operator|==
name|XTENSA_UNDEFINED
operator|&&
name|strcmp
argument_list|(
name|opname
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|use_transform
argument_list|()
operator|&&
operator|!
name|has_underbar
operator|&&
name|density_supported
condition|)
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
literal|"nop.n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xg_check_num_args
argument_list|(
name|pnum_args
argument_list|,
literal|0
argument_list|,
name|opname
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xg_replace_opname
argument_list|(
name|popname
argument_list|,
operator|(
name|has_underbar
condition|?
literal|"_or"
else|:
literal|"or"
operator|)
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|arg_strings
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|0
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|1
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_strings
index|[
literal|2
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
operator|*
name|pnum_args
operator|=
literal|3
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Recognize [RW]UR and [RWX]SR.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|opname
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|opname
index|[
literal|1
index|]
operator|==
literal|'u'
operator|||
name|opname
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|)
operator|||
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|)
operator|&&
name|opname
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
name|opname
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
return|return
name|xg_translate_sysreg_op
argument_list|(
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
return|;
comment|/* Backward compatibility for RUR and WUR: Recognize [RW]UR<nnn> and      [RW]<name> if<name> is the non-default name of a user register.  */
if|if
condition|(
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|opname
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
operator|&&
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opname
argument_list|)
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|xtensa_translate_old_userreg_ops
argument_list|(
name|popname
argument_list|)
return|;
comment|/* Relax branches that don't allow comparisons against an immediate value      of zero to the corresponding branches with implicit zero immediates.  */
if|if
condition|(
operator|!
name|has_underbar
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
if|if
condition|(
name|xtensa_translate_zero_immed
argument_list|(
literal|"bnei"
argument_list|,
literal|"bnez"
argument_list|,
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xtensa_translate_zero_immed
argument_list|(
literal|"beqi"
argument_list|,
literal|"beqz"
argument_list|,
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xtensa_translate_zero_immed
argument_list|(
literal|"bgei"
argument_list|,
literal|"bgez"
argument_list|,
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xtensa_translate_zero_immed
argument_list|(
literal|"blti"
argument_list|,
literal|"bltz"
argument_list|,
name|popname
argument_list|,
name|pnum_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the Xtensa ISA.  */
end_comment

begin_comment
comment|/* Currently the assembler only allows us to use a single target per    fragment.  Because of this, only one operand for a given    instruction may be symbolic.  If there is a PC-relative operand,    the last one is chosen.  Otherwise, the result is the number of the    last immediate operand, and if there are none of those, we fail and    return -1.  */
end_comment

begin_function
specifier|static
name|int
name|get_relaxable_immed
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|int
name|last_immed
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|noperands
decl_stmt|,
name|opi
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
operator|-
literal|1
return|;
name|noperands
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opi
operator|=
name|noperands
operator|-
literal|1
init|;
name|opi
operator|>=
literal|0
condition|;
name|opi
operator|--
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|1
condition|)
return|return
name|opi
return|;
if|if
condition|(
name|last_immed
operator|==
operator|-
literal|1
operator|&&
name|xtensa_operand_is_register
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|0
condition|)
name|last_immed
operator|=
name|opi
expr_stmt|;
block|}
return|return
name|last_immed
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|get_opcode_from_buf
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|slot
operator|>=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
return|return
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TENSILICA_DEBUG
end_ifdef

begin_comment
comment|/* For debugging, print out the mapping of opcode numbers to opcodes.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_print_insn_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num_opcodes
decl_stmt|,
name|num_operands
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|num_opcodes
operator|=
name|xtensa_isa_num_opcodes
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
for|for
control|(
name|opcode
operator|=
literal|0
init|;
name|opcode
operator|<
name|num_opcodes
condition|;
name|opcode
operator|++
control|)
block|{
name|int
name|opn
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: %s: "
argument_list|,
name|opcode
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|num_operands
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opn
operator|=
literal|0
init|;
name|opn
operator|<
name|num_operands
condition|;
name|opn
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|xtensa_regfile
name|opnd_rf
init|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
operator|==
literal|1
condition|)
name|fputs
argument_list|(
literal|"[lLr] "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"i "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_vliw_insn
parameter_list|(
name|xtensa_insnbuf
name|vbuf
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|f
init|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|vbuf
argument_list|)
decl_stmt|;
name|xtensa_insnbuf
name|sbuf
init|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
decl_stmt|;
name|int
name|op
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"format = %d\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|f
argument_list|)
condition|;
name|op
operator|++
control|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|operands
decl_stmt|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|f
argument_list|,
name|op
argument_list|,
name|vbuf
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|f
argument_list|,
name|op
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
name|opname
operator|=
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"op in slot %i is %s;\n"
argument_list|,
name|op
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   operands = "
argument_list|)
expr_stmt|;
for|for
control|(
name|operands
operator|=
literal|0
init|;
name|operands
operator|<
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
condition|;
name|operands
operator|++
control|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|operands
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|operands
argument_list|,
name|f
argument_list|,
name|op
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|operands
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_free
argument_list|(
name|isa
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TENSILICA_DEBUG */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|n
decl_stmt|,
name|num_operands
decl_stmt|;
if|if
condition|(
name|xtensa_opcode_is_call
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|num_operands
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|n
argument_list|)
operator|==
literal|1
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert from BFD relocation type code to slot and operand number.    Returns non-zero on failure.  */
end_comment

begin_function
specifier|static
name|int
name|decode_reloc
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|int
modifier|*
name|slot
parameter_list|,
name|bfd_boolean
modifier|*
name|is_alt
parameter_list|)
block|{
if|if
condition|(
name|reloc
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_OP
operator|&&
name|reloc
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_OP
condition|)
block|{
operator|*
name|slot
operator|=
name|reloc
operator|-
name|BFD_RELOC_XTENSA_SLOT0_OP
expr_stmt|;
operator|*
name|is_alt
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_ALT
operator|&&
name|reloc
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_ALT
condition|)
block|{
operator|*
name|slot
operator|=
name|reloc
operator|-
name|BFD_RELOC_XTENSA_SLOT0_ALT
expr_stmt|;
operator|*
name|is_alt
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert from slot number to BFD relocation type code for the    standard PC-relative relocations.  Return BFD_RELOC_NONE on    failure.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|encode_reloc
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|<
literal|0
operator|||
name|slot
operator|>
literal|14
condition|)
return|return
name|BFD_RELOC_NONE
return|;
return|return
name|BFD_RELOC_XTENSA_SLOT0_OP
operator|+
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Convert from slot numbers to BFD relocation type code for the    "alternate" relocations.  Return BFD_RELOC_NONE on failure.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|encode_alt_reloc
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|<
literal|0
operator|||
name|slot
operator|>
literal|14
condition|)
return|return
name|BFD_RELOC_NONE
return|;
return|return
name|BFD_RELOC_XTENSA_SLOT0_ALT
operator|+
name|slot
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_insnbuf_set_operand
parameter_list|(
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|operand
parameter_list|,
name|uint32
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|uint32
name|valbuf
init|=
name|value
decl_stmt|;
if|if
condition|(
name|xtensa_operand_encode
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|,
operator|&
name|valbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|)
operator|==
literal|1
condition|)
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d of '%s' has out of range value '%u'"
argument_list|)
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand %d of '%s' has invalid value '%u'"
argument_list|)
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|xtensa_operand_set_field
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32
name|xtensa_insnbuf_get_operand
parameter_list|(
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|opnum
parameter_list|)
block|{
name|uint32
name|val
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|xtensa_operand_get_field
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xtensa_operand_decode
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Checks for rules from xtensa-relax tables.  */
end_comment

begin_comment
comment|/* The routine xg_instruction_matches_option_term must return TRUE    when a given option term is true.  The meaning of all of the option    terms is given interpretation by this function.  This is needed when    an option depends on the state of a directive, but there are no such    options in use right now.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_instruction_matches_option_term
parameter_list|(
name|TInsn
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|ReqOrOption
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|option
operator|->
name|option_name
argument_list|,
literal|"realnop"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|option
operator|->
name|option_name
argument_list|,
literal|"IsaUse"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* These conditions were evaluated statically when building the 	 relaxation table.  There's no need to reevaluate them now.  */
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: unknown option name '%s'"
argument_list|)
argument_list|,
name|option
operator|->
name|option_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_instruction_matches_or_options
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
specifier|const
name|ReqOrOptionList
modifier|*
name|or_option
parameter_list|)
block|{
specifier|const
name|ReqOrOption
modifier|*
name|option
decl_stmt|;
comment|/* Must match each of the AND terms.  */
for|for
control|(
name|option
operator|=
name|or_option
init|;
name|option
operator|!=
name|NULL
condition|;
name|option
operator|=
name|option
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xg_instruction_matches_option_term
argument_list|(
name|insn
argument_list|,
name|option
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_instruction_matches_options
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
specifier|const
name|ReqOptionList
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|ReqOption
modifier|*
name|req_options
decl_stmt|;
comment|/* Must match each of the AND terms.  */
for|for
control|(
name|req_options
operator|=
name|options
init|;
name|req_options
operator|!=
name|NULL
condition|;
name|req_options
operator|=
name|req_options
operator|->
name|next
control|)
block|{
comment|/* Must match one of the OR clauses.  */
if|if
condition|(
operator|!
name|xg_instruction_matches_or_options
argument_list|(
name|insn
argument_list|,
name|req_options
operator|->
name|or_option_terms
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the transition rule that matches or NULL if none matches.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_instruction_matches_rule
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|TransitionRule
modifier|*
name|rule
parameter_list|)
block|{
name|PreconditionList
modifier|*
name|condition_l
decl_stmt|;
if|if
condition|(
name|rule
operator|->
name|opcode
operator|!=
name|insn
operator|->
name|opcode
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|condition_l
operator|=
name|rule
operator|->
name|conditions
init|;
name|condition_l
operator|!=
name|NULL
condition|;
name|condition_l
operator|=
name|condition_l
operator|->
name|next
control|)
block|{
name|expressionS
modifier|*
name|exp1
decl_stmt|;
name|expressionS
modifier|*
name|exp2
decl_stmt|;
name|Precondition
modifier|*
name|cond
init|=
name|condition_l
operator|->
name|precond
decl_stmt|;
switch|switch
condition|(
name|cond
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
comment|/* The expression must be the constant.  */
name|assert
argument_list|(
name|cond
operator|->
name|op_num
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|exp1
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_num
index|]
expr_stmt|;
if|if
condition|(
name|expr_is_const
argument_list|(
name|exp1
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cond
operator|->
name|cmp
condition|)
block|{
case|case
name|OP_EQUAL
case|:
if|if
condition|(
name|get_expr_const
argument_list|(
name|exp1
argument_list|)
operator|!=
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_NOTEQUAL
case|:
if|if
condition|(
name|get_expr_const
argument_list|(
name|exp1
argument_list|)
operator|==
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|expr_is_register
argument_list|(
name|exp1
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cond
operator|->
name|cmp
condition|)
block|{
case|case
name|OP_EQUAL
case|:
if|if
condition|(
name|get_expr_register
argument_list|(
name|exp1
argument_list|)
operator|!=
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_NOTEQUAL
case|:
if|if
condition|(
name|get_expr_register
argument_list|(
name|exp1
argument_list|)
operator|==
name|cond
operator|->
name|op_data
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
else|else
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|cond
operator|->
name|op_num
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cond
operator|->
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|exp1
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_num
index|]
expr_stmt|;
name|exp2
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|cond
operator|->
name|op_data
index|]
expr_stmt|;
switch|switch
condition|(
name|cond
operator|->
name|cmp
condition|)
block|{
case|case
name|OP_EQUAL
case|:
if|if
condition|(
operator|!
name|expr_is_equal
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|OP_NOTEQUAL
case|:
if|if
condition|(
name|expr_is_equal
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_LABEL
case|:
default|default:
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|xg_instruction_matches_options
argument_list|(
name|insn
argument_list|,
name|rule
operator|->
name|options
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|transition_rule_cmp
parameter_list|(
specifier|const
name|TransitionRule
modifier|*
name|a
parameter_list|,
specifier|const
name|TransitionRule
modifier|*
name|b
parameter_list|)
block|{
name|bfd_boolean
name|a_greater
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|b_greater
init|=
name|FALSE
decl_stmt|;
name|ReqOptionList
modifier|*
name|l_a
init|=
name|a
operator|->
name|options
decl_stmt|;
name|ReqOptionList
modifier|*
name|l_b
init|=
name|b
operator|->
name|options
decl_stmt|;
comment|/* We only care if they both are the same except for      a const16 vs. an l32r.  */
while|while
condition|(
name|l_a
operator|&&
name|l_b
operator|&&
operator|(
operator|(
name|l_a
operator|->
name|next
operator|==
name|NULL
operator|)
operator|==
operator|(
name|l_b
operator|->
name|next
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|ReqOrOptionList
modifier|*
name|l_or_a
init|=
name|l_a
operator|->
name|or_option_terms
decl_stmt|;
name|ReqOrOptionList
modifier|*
name|l_or_b
init|=
name|l_b
operator|->
name|or_option_terms
decl_stmt|;
while|while
condition|(
name|l_or_a
operator|&&
name|l_or_b
operator|&&
operator|(
operator|(
name|l_a
operator|->
name|next
operator|==
name|NULL
operator|)
operator|==
operator|(
name|l_b
operator|->
name|next
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l_or_a
operator|->
name|is_true
operator|!=
name|l_or_b
operator|->
name|is_true
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|l_or_a
operator|->
name|option_name
argument_list|,
name|l_or_b
operator|->
name|option_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is the case we care about.  */
if|if
condition|(
name|strcmp
argument_list|(
name|l_or_a
operator|->
name|option_name
argument_list|,
literal|"IsaUseConst16"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|l_or_b
operator|->
name|option_name
argument_list|,
literal|"IsaUseL32R"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prefer_const16
condition|)
name|a_greater
operator|=
name|TRUE
expr_stmt|;
else|else
name|b_greater
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|l_or_a
operator|->
name|option_name
argument_list|,
literal|"IsaUseL32R"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|l_or_b
operator|->
name|option_name
argument_list|,
literal|"IsaUseConst16"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prefer_const16
condition|)
name|b_greater
operator|=
name|TRUE
expr_stmt|;
else|else
name|a_greater
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|l_or_a
operator|=
name|l_or_a
operator|->
name|next
expr_stmt|;
name|l_or_b
operator|=
name|l_or_b
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|l_or_a
operator|||
name|l_or_b
condition|)
return|return
literal|0
return|;
name|l_a
operator|=
name|l_a
operator|->
name|next
expr_stmt|;
name|l_b
operator|=
name|l_b
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|l_a
operator|||
name|l_b
condition|)
return|return
literal|0
return|;
comment|/* Incomparable if the substitution was used differently in two cases.  */
if|if
condition|(
name|a_greater
operator|&&
name|b_greater
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|b_greater
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a_greater
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|TransitionRule
modifier|*
name|xg_instruction_match
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_simplify_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
comment|/* Walk through all of the possible transitions.  */
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
return|return
name|rule
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Various Other Internal Functions.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_unique_insn_expansion
parameter_list|(
name|TransitionRule
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|to_instr
operator|||
name|r
operator|->
name|to_instr
operator|->
name|next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|r
operator|->
name|to_instr
operator|->
name|typ
operator|!=
name|INSTR_INSTR
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check if there is exactly one relaxation for INSN that converts it to    another instruction of equal or larger size.  If so, and if TARG is    non-null, go ahead and generate the relaxed instruction into TARG.  If    NARROW_ONLY is true, then only consider relaxations that widen a narrow    instruction, i.e., ignore relaxations that convert to an instruction of    equal size.  In some contexts where this function is used, only    a single widening is allowed and the NARROW_ONLY argument is used to    exclude cases like ADDI being "widened" to an ADDMI, which may    later be relaxed to an ADDMI/ADDI pair.  */
end_comment

begin_function
name|bfd_boolean
name|xg_is_single_relaxable_insn
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|TInsn
modifier|*
name|targ
parameter_list|,
name|bfd_boolean
name|narrow_only
parameter_list|)
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|TransitionRule
modifier|*
name|match
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
operator|&&
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
operator|&&
operator|(
name|xg_get_single_size
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
operator|+
operator|(
name|narrow_only
condition|?
literal|1
else|:
literal|0
operator|)
operator|<=
name|xg_get_single_size
argument_list|(
name|rule
operator|->
name|to_instr
operator|->
name|opcode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|match
condition|)
return|return
name|FALSE
return|;
name|match
operator|=
name|rule
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|targ
condition|)
name|xg_build_to_insn
argument_list|(
name|targ
argument_list|,
name|insn
argument_list|,
name|match
operator|->
name|to_instr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of bytes this opcode can expand to.  */
end_comment

begin_function
specifier|static
name|int
name|xg_get_max_insn_widen_size
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|max_size
init|=
name|xg_get_single_size
argument_list|(
name|opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
name|BuildInstr
modifier|*
name|build_list
decl_stmt|;
name|int
name|this_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rule
condition|)
continue|continue;
name|build_list
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
if|if
condition|(
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|build_list
operator|->
name|typ
operator|==
name|INSTR_INSTR
argument_list|)
expr_stmt|;
name|this_size
operator|=
name|xg_get_max_insn_widen_size
argument_list|(
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|build_list
operator|!=
name|NULL
condition|;
name|build_list
operator|=
name|build_list
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|build_list
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|this_size
operator|+=
name|xg_get_single_size
argument_list|(
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
case|case
name|INSTR_LABEL_DEF
case|:
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|this_size
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|this_size
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of literal bytes this opcode can generate.  */
end_comment

begin_function
specifier|static
name|int
name|xg_get_max_insn_widen_literal_size
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|int
name|max_size
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
name|BuildInstr
modifier|*
name|build_list
decl_stmt|;
name|int
name|this_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rule
condition|)
continue|continue;
name|build_list
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
if|if
condition|(
name|is_unique_insn_expansion
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|build_list
operator|->
name|typ
operator|==
name|INSTR_INSTR
argument_list|)
expr_stmt|;
name|this_size
operator|=
name|xg_get_max_insn_widen_literal_size
argument_list|(
name|build_list
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|build_list
operator|!=
name|NULL
condition|;
name|build_list
operator|=
name|build_list
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|build_list
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_LITERAL_DEF
case|:
comment|/* Hard-coded 4-byte literal.  */
name|this_size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|INSTR_INSTR
case|:
case|case
name|INSTR_LABEL_DEF
case|:
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|this_size
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|this_size
expr_stmt|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_is_relaxable_insn
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|int
name|lateral_steps
parameter_list|)
block|{
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|==
name|lateral_steps
condition|)
return|return
name|TRUE
return|;
name|steps_taken
operator|++
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_special_literal_symbol
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|symbolS
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
literal|"SPECIAL_LITERAL0\001"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_special_label_symbol
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|symbolS
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
literal|"SPECIAL_LABEL0\001"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_valid_literal_expression
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_big
case|:
case|case
name|O_uminus
case|:
case|case
name|O_subtract
case|:
case|case
name|O_pltrel
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* This will check to see if the value can be converted into the    operand type.  It will return TRUE if it does not fit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_check_operand
parameter_list|(
name|int32
name|value
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|operand
parameter_list|)
block|{
name|uint32
name|valbuf
init|=
name|value
decl_stmt|;
if|if
condition|(
name|xtensa_operand_encode
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|operand
argument_list|,
operator|&
name|valbuf
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Assumes: All immeds are constants.  Check that all constants fit    into their immeds; return FALSE if not.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_immeds_fit
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
if|if
condition|(
name|xg_check_operand
argument_list|(
name|expr
operator|->
name|X_add_number
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
comment|/* The symbol should have a fixup associated with it.  */
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This should only be called after we have an initial    estimate of the addresses.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_symbolic_immeds_fit
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|,
name|segT
name|pc_seg
parameter_list|,
name|fragS
modifier|*
name|pc_frag
parameter_list|,
name|offsetT
name|pc_offset
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|offsetT
name|target
decl_stmt|,
name|pc
decl_stmt|;
name|uint32
name|new_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|insn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
if|if
condition|(
name|xg_check_operand
argument_list|(
name|expr
operator|->
name|X_add_number
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|O_lo16
case|:
case|case
name|O_hi16
case|:
comment|/* Check for the worst case.  */
if|if
condition|(
name|xg_check_operand
argument_list|(
literal|0xffff
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|O_symbol
case|:
comment|/* We only allow symbols for PC-relative references. 	     If pc_frag == 0, then we don't have frag locations yet.  */
if|if
condition|(
name|pc_frag
operator|==
literal|0
operator|||
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* If it is a weak symbol, then assume it won't reach.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
operator|&&
operator|!
name|pc_frag
operator|->
name|tc_frag_data
operator|.
name|use_longcalls
condition|)
block|{
comment|/* If callee is undefined or in a different segment, be 		 optimistic and assume it will be in range.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|pc_seg
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* Only references within a segment can be known to fit in the 	     operands at assembly time.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|expr
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|pc_seg
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|target
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|expr
operator|->
name|X_add_number
expr_stmt|;
name|pc
operator|=
name|pc_frag
operator|->
name|fr_address
operator|+
name|pc_offset
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, assume it 	     will move by STRETCH just as we did.  If this is not so, 	     it will be because some frag between grows, and that will 	     force another pass.  Beware zero-length frags.  There 	     should be a faster way to do this.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|pc_frag
operator|->
name|relax_marker
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|pc_seg
condition|)
block|{
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
name|new_offset
operator|=
name|target
expr_stmt|;
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|,
operator|&
name|new_offset
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xg_check_operand
argument_list|(
name|new_offset
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
comment|/* The symbol should have a fixup associated with it.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE on success.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_build_to_insn
parameter_list|(
name|TInsn
modifier|*
name|targ
parameter_list|,
name|TInsn
modifier|*
name|insn
parameter_list|,
name|BuildInstr
modifier|*
name|bi
parameter_list|)
block|{
name|BuildOp
modifier|*
name|op
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|tinsn_init
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|targ
operator|->
name|linenum
operator|=
name|insn
operator|->
name|linenum
expr_stmt|;
switch|switch
condition|(
name|bi
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|bi
operator|->
name|opcode
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|int
name|op_num
init|=
name|op
operator|->
name|op_num
decl_stmt|;
name|int
name|op_data
init|=
name|op
operator|->
name|op_data
decl_stmt|;
name|assert
argument_list|(
name|op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|ntok
operator|<=
name|op_num
condition|)
name|targ
operator|->
name|ntok
operator|=
name|op_num
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
name|set_expr_const
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|op_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
name|sym
operator|=
name|get_special_literal_symbol
argument_list|()
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LABEL
case|:
name|sym
operator|=
name|get_special_label_symbol
argument_list|()
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OPERAND_HI16U
case|:
case|case
name|OP_OPERAND_LOW16U
case|:
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_is_const
argument_list|(
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
condition|)
block|{
name|long
name|val
decl_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|xg_apply_userdef_op_fn
argument_list|(
name|op
operator|->
name|typ
argument_list|,
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* For const16 we can create relocations for these.  */
if|if
condition|(
name|targ
operator|->
name|opcode
operator|==
name|XTENSA_UNDEFINED
operator|||
operator|(
name|targ
operator|->
name|opcode
operator|!=
name|xtensa_const16_opcode
operator|)
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
comment|/* Need to build a O_lo16 or O_hi16.  */
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
if|if
condition|(
name|op
operator|->
name|typ
operator|==
name|OP_OPERAND_HI16U
condition|)
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_op
operator|=
name|O_hi16
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|typ
operator|==
name|OP_OPERAND_LOW16U
condition|)
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_op
operator|=
name|O_lo16
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
block|}
break|break;
default|default:
comment|/* currently handles: 		 OP_OPERAND_LOW8 		 OP_OPERAND_HI24S 		 OP_OPERAND_F32MINUS */
if|if
condition|(
name|xg_has_userdef_op_fn
argument_list|(
name|op
operator|->
name|typ
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_is_const
argument_list|(
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
condition|)
block|{
name|long
name|val
decl_stmt|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|xg_apply_userdef_op_fn
argument_list|(
name|op
operator|->
name|typ
argument_list|,
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
operator|.
name|X_add_number
operator|=
name|val
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* We cannot use a relocation for this.  */
break|break;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_LITERAL
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|int
name|op_num
init|=
name|op
operator|->
name|op_num
decl_stmt|;
name|int
name|op_data
init|=
name|op
operator|->
name|op_data
decl_stmt|;
name|assert
argument_list|(
name|op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|ntok
operator|<=
name|op_num
condition|)
name|targ
operator|->
name|ntok
operator|=
name|op_num
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|op_data
operator|<
name|insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
comment|/* We can only pass resolvable literals through.  */
if|if
condition|(
operator|!
name|xg_valid_literal_expression
argument_list|(
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|copy_expr
argument_list|(
operator|&
name|targ
operator|->
name|tok
index|[
name|op_num
index|]
argument_list|,
operator|&
name|insn
operator|->
name|tok
index|[
name|op_data
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_CONSTANT
case|:
case|case
name|OP_LABEL
case|:
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|INSTR_LABEL_DEF
case|:
name|op
operator|=
name|bi
operator|->
name|ops
expr_stmt|;
name|targ
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|targ
operator|->
name|insn_type
operator|=
name|ITYPE_LABEL
expr_stmt|;
name|targ
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
comment|/* Literal with no ops is a label?  */
name|assert
argument_list|(
name|op
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE on success.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_build_to_stack
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|,
name|TInsn
modifier|*
name|insn
parameter_list|,
name|BuildInstr
modifier|*
name|bi
parameter_list|)
block|{
for|for
control|(
init|;
name|bi
operator|!=
name|NULL
condition|;
name|bi
operator|=
name|bi
operator|->
name|next
control|)
block|{
name|TInsn
modifier|*
name|next_insn
init|=
name|istack_push_space
argument_list|(
name|istack
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xg_build_to_insn
argument_list|(
name|next_insn
argument_list|,
name|insn
argument_list|,
name|bi
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE on valid expansion.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_expand_to_stack
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|,
name|TInsn
modifier|*
name|insn
parameter_list|,
name|int
name|lateral_steps
parameter_list|)
block|{
name|int
name|stack_size
init|=
name|istack
operator|->
name|ninsn
decl_stmt|;
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
name|TransitionTable
modifier|*
name|table
init|=
name|xg_build_widen_table
argument_list|(
operator|&
name|transition_rule_cmp
argument_list|)
decl_stmt|;
name|TransitionList
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|opcode
operator|<
name|table
operator|->
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|table
operator|->
name|table
index|[
name|insn
operator|->
name|opcode
index|]
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|TransitionRule
modifier|*
name|rule
init|=
name|l
operator|->
name|rule
decl_stmt|;
if|if
condition|(
name|xg_instruction_matches_rule
argument_list|(
name|insn
argument_list|,
name|rule
argument_list|)
condition|)
block|{
if|if
condition|(
name|lateral_steps
operator|==
name|steps_taken
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is it.  Expand the rule to the stack.  */
if|if
condition|(
operator|!
name|xg_build_to_stack
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|,
name|rule
operator|->
name|to_instr
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Check to see if it fits.  */
for|for
control|(
name|i
operator|=
name|stack_size
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|insn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
operator|&&
operator|!
name|tinsn_has_symbolic_operands
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|xg_immeds_fit
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|istack
operator|->
name|ninsn
operator|=
name|stack_size
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|steps_taken
operator|++
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relax the assembly instruction at least "min_steps".    Return the number of steps taken.     For relaxation to correctly terminate, every relaxation chain must    terminate in one of two ways:     1.  If the chain from one instruction to the next consists entirely of        single instructions, then the chain *must* handle all possible        immediates without failing.  It must not ever fail because an        immediate is out of range.  The MOVI.N -> MOVI -> L32R relaxation        chain is one example.  L32R loads 32 bits, and there cannot be an        immediate larger than 32 bits, so it satisfies this condition.        Single instruction relaxation chains are as defined by        xg_is_single_relaxable_instruction.     2.  Otherwise, the chain must end in a multi-instruction expansion: e.g.,        BNEZ.N -> BNEZ -> BNEZ.W15 -> BENZ.N/J     Strictly speaking, in most cases you can violate condition 1 and be OK    -- in particular when the last two instructions have the same single    size.  But nevertheless, you should guarantee the above two conditions.     We could fix this so that single-instruction expansions correctly    terminate when they can't handle the range, but the error messages are    worse, and it actually turns out that in every case but one (18-bit wide    branches), you need a multi-instruction expansion to get the full range    anyway.  And because 18-bit branches are handled identically to 15-bit    branches, there isn't any point in changing it.  */
end_comment

begin_function
specifier|static
name|int
name|xg_assembly_relax
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|,
name|TInsn
modifier|*
name|insn
parameter_list|,
name|segT
name|pc_seg
parameter_list|,
name|fragS
modifier|*
name|pc_frag
parameter_list|,
comment|/* if pc_frag == 0, not pc-relative */
name|offsetT
name|pc_offset
parameter_list|,
comment|/* offset in fragment */
name|int
name|min_steps
parameter_list|,
comment|/* minimum conversion steps */
name|long
name|stretch
parameter_list|)
comment|/* number of bytes stretched so far */
block|{
name|int
name|steps_taken
init|=
literal|0
decl_stmt|;
comment|/* Some of its immeds don't fit.  Try to build a relaxed version.      This may go through a couple of stages of single instruction      transformations before we get there.  */
name|TInsn
name|single_target
decl_stmt|;
name|TInsn
name|current_insn
decl_stmt|;
name|int
name|lateral_steps
init|=
literal|0
decl_stmt|;
name|int
name|istack_size
init|=
name|istack
operator|->
name|ninsn
decl_stmt|;
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
name|insn
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
operator|&&
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
name|current_insn
operator|=
operator|*
name|insn
expr_stmt|;
comment|/* Walk through all of the single instruction expansions.  */
while|while
condition|(
name|xg_is_single_relaxable_insn
argument_list|(
operator|&
name|current_insn
argument_list|,
operator|&
name|single_target
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|steps_taken
operator|++
expr_stmt|;
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
operator|&
name|single_target
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
operator|&
name|single_target
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
block|}
name|current_insn
operator|=
name|single_target
expr_stmt|;
block|}
comment|/* Now check for a multi-instruction expansion.  */
while|while
condition|(
name|xg_is_relaxable_insn
argument_list|(
operator|&
name|current_insn
argument_list|,
name|lateral_steps
argument_list|)
condition|)
block|{
if|if
condition|(
name|xg_symbolic_immeds_fit
argument_list|(
operator|&
name|current_insn
argument_list|,
name|pc_seg
argument_list|,
name|pc_frag
argument_list|,
name|pc_offset
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
block|{
name|istack_push
argument_list|(
name|istack
argument_list|,
operator|&
name|current_insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
block|}
name|steps_taken
operator|++
expr_stmt|;
if|if
condition|(
name|xg_expand_to_stack
argument_list|(
name|istack
argument_list|,
operator|&
name|current_insn
argument_list|,
name|lateral_steps
argument_list|)
condition|)
block|{
if|if
condition|(
name|steps_taken
operator|>=
name|min_steps
condition|)
return|return
name|steps_taken
return|;
block|}
name|lateral_steps
operator|++
expr_stmt|;
name|istack
operator|->
name|ninsn
operator|=
name|istack_size
expr_stmt|;
block|}
comment|/* It's not going to work -- use the original.  */
name|istack_push
argument_list|(
name|istack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|steps_taken
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_force_frag_space
parameter_list|(
name|int
name|size
parameter_list|)
block|{
comment|/* This may have the side effect of creating a new fragment for the      space to go into.  I just do not like the name of the "frag"      functions.  */
name|frag_grow
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_finish_frag
parameter_list|(
name|char
modifier|*
name|last_insn
parameter_list|,
name|enum
name|xtensa_relax_statesE
name|frag_state
parameter_list|,
name|enum
name|xtensa_relax_statesE
name|slot0_state
parameter_list|,
name|int
name|max_growth
parameter_list|,
name|bfd_boolean
name|is_insn
parameter_list|)
block|{
comment|/* Finish off this fragment so that it has at LEAST the desired      max_growth.  If it doesn't fit in this fragment, close this one      and start a new one.  In either case, return a pointer to the      beginning of the growth area.  */
name|fragS
modifier|*
name|old_frag
decl_stmt|;
name|xg_force_frag_space
argument_list|(
name|max_growth
argument_list|)
expr_stmt|;
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|fr_opcode
operator|=
name|last_insn
expr_stmt|;
if|if
condition|(
name|is_insn
condition|)
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_growth
argument_list|,
name|max_growth
argument_list|,
name|frag_state
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|old_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|=
name|slot0_state
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
comment|/* Just to make sure that we did not split it up.  */
name|assert
argument_list|(
name|old_frag
operator|->
name|fr_next
operator|==
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the target frag is one of the next non-empty frags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_next_frag_target
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|,
specifier|const
name|fragS
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|==
name|target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|fragP
operator|->
name|fr_offset
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|)
operator|&&
operator|(
operator|(
name|fragP
operator|->
name|fr_address
operator|%
operator|(
literal|1
operator|<<
name|fragP
operator|->
name|fr_offset
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_space
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_branch_jmp_to_next
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_ops
init|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|target_op
init|=
operator|-
literal|1
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|fragS
modifier|*
name|target_frag
decl_stmt|;
if|if
condition|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|!=
literal|1
operator|&&
name|xtensa_opcode_is_jump
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
condition|)
block|{
name|target_op
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target_op
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|target_op
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|sym
operator|=
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|target_op
index|]
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|target_frag
operator|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_frag
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|is_next_frag_target
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|target_frag
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
name|target_frag
operator|->
name|fr_address
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_add_branch_and_loop_targets
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|num_ops
init|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
operator|&&
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|symbol_get_tc
argument_list|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|is_loop_target
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|==
literal|1
operator|||
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
operator|&&
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
operator|&&
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
decl_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return FALSE if no error.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_build_token_insn
parameter_list|(
name|BuildInstr
modifier|*
name|instr_spec
parameter_list|,
name|TInsn
modifier|*
name|old_insn
parameter_list|,
name|TInsn
modifier|*
name|new_insn
parameter_list|)
block|{
name|int
name|num_ops
init|=
literal|0
decl_stmt|;
name|BuildOp
modifier|*
name|b_op
decl_stmt|;
switch|switch
condition|(
name|instr_spec
operator|->
name|typ
condition|)
block|{
case|case
name|INSTR_INSTR
case|:
name|new_insn
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|new_insn
operator|->
name|opcode
operator|=
name|instr_spec
operator|->
name|opcode
expr_stmt|;
name|new_insn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
name|new_insn
operator|->
name|linenum
operator|=
name|old_insn
operator|->
name|linenum
expr_stmt|;
break|break;
case|case
name|INSTR_LITERAL_DEF
case|:
name|new_insn
operator|->
name|insn_type
operator|=
name|ITYPE_LITERAL
expr_stmt|;
name|new_insn
operator|->
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|new_insn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
name|new_insn
operator|->
name|linenum
operator|=
name|old_insn
operator|->
name|linenum
expr_stmt|;
break|break;
case|case
name|INSTR_LABEL_DEF
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"INSTR_LABEL_DEF not supported yet"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|b_op
operator|=
name|instr_spec
operator|->
name|ops
init|;
name|b_op
operator|!=
name|NULL
condition|;
name|b_op
operator|=
name|b_op
operator|->
name|next
control|)
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|src_exp
decl_stmt|;
name|num_ops
operator|++
expr_stmt|;
switch|switch
condition|(
name|b_op
operator|->
name|typ
condition|)
block|{
case|case
name|OP_CONSTANT
case|:
comment|/* The expression must be the constant.  */
name|assert
argument_list|(
name|b_op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|&
name|new_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_num
index|]
expr_stmt|;
name|set_expr_const
argument_list|(
name|exp
argument_list|,
name|b_op
operator|->
name|op_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OPERAND
case|:
name|assert
argument_list|(
name|b_op
operator|->
name|op_num
operator|<
name|MAX_INSN_ARGS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b_op
operator|->
name|op_data
operator|<
operator|(
name|unsigned
operator|)
name|old_insn
operator|->
name|ntok
argument_list|)
expr_stmt|;
name|src_exp
operator|=
operator|&
name|old_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_data
index|]
expr_stmt|;
name|exp
operator|=
operator|&
name|new_insn
operator|->
name|tok
index|[
name|b_op
operator|->
name|op_num
index|]
expr_stmt|;
name|copy_expr
argument_list|(
name|exp
argument_list|,
name|src_exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LITERAL
case|:
case|case
name|OP_LABEL
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle generation of literal/labels yet"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't handle undefined OP TYPE"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|new_insn
operator|->
name|ntok
operator|=
name|num_ops
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if it was simplified.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_simplify_insn
parameter_list|(
name|TInsn
modifier|*
name|old_insn
parameter_list|,
name|TInsn
modifier|*
name|new_insn
parameter_list|)
block|{
name|TransitionRule
modifier|*
name|rule
decl_stmt|;
name|BuildInstr
modifier|*
name|insn_spec
decl_stmt|;
if|if
condition|(
name|old_insn
operator|->
name|is_specific_opcode
operator|||
operator|!
name|density_supported
condition|)
return|return
name|FALSE
return|;
name|rule
operator|=
name|xg_instruction_match
argument_list|(
name|old_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|insn_spec
operator|=
name|rule
operator|->
name|to_instr
expr_stmt|;
comment|/* There should only be one.  */
name|assert
argument_list|(
name|insn_spec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn_spec
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_spec
operator|->
name|next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
name|xg_build_token_insn
argument_list|(
name|insn_spec
argument_list|,
name|old_insn
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* xg_expand_assembly_insn: (1) Simplify the instruction, i.e., l32i ->    l32i.n. (2) Check the number of operands.  (3) Place the instruction    tokens into the stack or relax it and place multiple    instructions/literals onto the stack.  Return FALSE if no error.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_expand_assembly_insn
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|,
name|TInsn
modifier|*
name|orig_insn
parameter_list|)
block|{
name|int
name|noperands
decl_stmt|;
name|TInsn
name|new_insn
decl_stmt|;
name|bfd_boolean
name|do_expand
decl_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|new_insn
argument_list|)
expr_stmt|;
comment|/* Narrow it if we can.  xg_simplify_insn now does all the      appropriate checking (e.g., for the density option).  */
if|if
condition|(
name|xg_simplify_insn
argument_list|(
name|orig_insn
argument_list|,
operator|&
name|new_insn
argument_list|)
condition|)
name|orig_insn
operator|=
operator|&
name|new_insn
expr_stmt|;
name|noperands
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_insn
operator|->
name|ntok
operator|<
name|noperands
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"found %d operands for '%s':  Expected %d"
argument_list|)
argument_list|,
name|orig_insn
operator|->
name|ntok
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
argument_list|,
name|noperands
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|orig_insn
operator|->
name|ntok
operator|>
name|noperands
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"found too many (%d) operands for '%s':  Expected %d"
argument_list|)
argument_list|,
name|orig_insn
operator|->
name|ntok
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_insn
operator|->
name|opcode
argument_list|)
argument_list|,
name|noperands
argument_list|)
expr_stmt|;
comment|/* If there are not enough operands, we will assert above.  If there      are too many, just cut out the extras here.  */
name|orig_insn
operator|->
name|ntok
operator|=
name|noperands
expr_stmt|;
if|if
condition|(
name|tinsn_has_invalid_symbolic_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If the instruction will definitely need to be relaxed, it is better      to expand it now for better scheduling.  Decide whether to expand      now....  */
name|do_expand
operator|=
operator|(
operator|!
name|orig_insn
operator|->
name|is_specific_opcode
operator|&&
name|use_transform
argument_list|()
operator|)
expr_stmt|;
comment|/* Calls should be expanded to longcalls only in the backend relaxation      so that the assembly scheduler will keep the L32R/CALLX instructions      adjacent.  */
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|orig_insn
operator|->
name|opcode
argument_list|)
condition|)
name|do_expand
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tinsn_has_symbolic_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
block|{
comment|/* The values of symbolic operands are not known yet, so only expand 	 now if an operand is "complex" (e.g., difference of symbols) and 	 will have to be stored as a literal regardless of the value.  */
if|if
condition|(
operator|!
name|tinsn_has_complex_operands
argument_list|(
name|orig_insn
argument_list|)
condition|)
name|do_expand
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xg_immeds_fit
argument_list|(
name|orig_insn
argument_list|)
condition|)
name|do_expand
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|do_expand
condition|)
name|xg_assembly_relax
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|istack_push
argument_list|(
name|istack
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the section flags are marked linkonce    or the name is .gnu.linkonce.*.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linkonce_len
init|=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce."
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|get_is_linkonce_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|link_once_flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|link_once_flags
operator|=
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
expr_stmt|;
comment|/* Flags might not be set yet.  */
if|if
condition|(
operator|!
name|link_once_flags
operator|&&
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
condition|)
name|link_once_flags
operator|=
name|SEC_LINK_ONCE
expr_stmt|;
return|return
operator|(
name|link_once_flags
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_add_literal_sym
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|sym_list
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
name|sym_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|literal_syms
expr_stmt|;
name|literal_syms
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|xtensa_create_literal_symbol
parameter_list|(
name|segT
name|sec
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
specifier|static
name|int
name|lit_num
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|".L_lit_sym%d"
argument_list|,
name|lit_num
argument_list|)
expr_stmt|;
comment|/* Create a local symbol.  If it is in a linkonce section, we have to      be careful to make sure that if it is used in a relocation that the      symbol will be in the output file.  */
if|if
condition|(
name|get_is_linkonce_section
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* symbolP->local = 1; */
block|}
else|else
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|xtensa_add_literal_sym
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|lit_num
operator|++
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* Currently all literals that are generated here are 32-bit L32R targets.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|xg_assemble_literal
parameter_list|(
comment|/* const */
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|emit_state
name|state
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* size = 4 for L32R.  It could easily be larger when we move to      larger constants.  Add a parameter later.  */
name|offsetT
name|litsize
init|=
literal|4
decl_stmt|;
name|offsetT
name|litalign
init|=
literal|2
decl_stmt|;
comment|/* 2^2 = 4 */
name|expressionS
name|saved_loc
decl_stmt|;
name|expressionS
modifier|*
name|emit_val
decl_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|saved_loc
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|ntok
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* must be only one token here */
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|emit_val
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|emit_val
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
name|int
name|size
init|=
name|emit_val
operator|->
name|X_add_number
operator|*
name|CHARS_PER_LITTLENUM
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|litsize
condition|)
block|{
comment|/* This happens when someone writes a "movi a2, big_number".  */
name|as_bad_where
argument_list|(
name|frag_now
operator|->
name|fr_file
argument_list|,
name|frag_now
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Force a 4-byte align here.  Note that this opens a new frag, so all      literals done with this function have a frag to themselves.  That's      important for the way text section literals work.  */
name|frag_align
argument_list|(
name|litalign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|litalign
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|emit_val
operator|->
name|X_op
condition|)
block|{
case|case
name|O_pltrel
case|:
name|p
operator|=
name|frag_more
argument_list|(
name|litsize
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|map_operator_to_reloc
argument_list|(
name|emit_val
operator|->
name|X_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|emit_val
operator|->
name|X_add_symbol
condition|)
name|emit_val
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
else|else
name|emit_val
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|litsize
argument_list|,
name|emit_val
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emit_expr
argument_list|(
name|emit_val
argument_list|,
name|litsize
argument_list|)
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|xtensa_create_literal_symbol
argument_list|(
name|now_seg
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|lit_sym
operator|=
name|frag_now
operator|->
name|fr_symbol
expr_stmt|;
comment|/* Go back.  */
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
name|lit_sym
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_assemble_literal_space
parameter_list|(
comment|/* const */
name|int
name|size
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|emit_state
name|state
decl_stmt|;
comment|/* We might have to do something about this alignment.  It only      takes effect if something is placed here.  */
name|offsetT
name|litalign
init|=
literal|2
decl_stmt|;
comment|/* 2^2 = 4 */
name|fragS
modifier|*
name|lit_saved_frag
decl_stmt|;
name|assert
argument_list|(
name|size
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xtensa_switch_to_literal_fragment
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* Force a 4-byte align here.  */
name|frag_align
argument_list|(
name|litalign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|litalign
argument_list|)
expr_stmt|;
name|xg_force_frag_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|lit_saved_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|xtensa_create_literal_symbol
argument_list|(
name|now_seg
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|xg_finish_frag
argument_list|(
literal|0
argument_list|,
name|RELAX_LITERAL
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Go back.  */
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frags
index|[
name|slot
index|]
operator|=
name|lit_saved_frag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put in a fixup record based on the opcode.    Return TRUE on success.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xg_add_opcode_fix
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|int
name|opnum
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|expressionS
modifier|*
name|expr
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|fmt_length
decl_stmt|;
name|fixS
modifier|*
name|the_fix
decl_stmt|;
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* First try the special cases for "alternate" relocs.  */
if|if
condition|(
name|opcode
operator|==
name|xtensa_l32r_opcode
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
condition|)
name|reloc
operator|=
name|encode_alt_reloc
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|xtensa_const16_opcode
condition|)
block|{
if|if
condition|(
name|expr
operator|->
name|X_op
operator|==
name|O_lo16
condition|)
block|{
name|reloc
operator|=
name|encode_reloc
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|expr
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|X_op
operator|==
name|O_hi16
condition|)
block|{
name|reloc
operator|=
name|encode_alt_reloc
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|expr
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opnum
operator|!=
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid relocation for operand %i of '%s'"
argument_list|)
argument_list|,
name|opnum
operator|+
literal|1
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Handle erroneous "@h" and "@l" expressions here before they propagate      into the symbol table where the generic portions of the assembler      won't know what to do with them.  */
if|if
condition|(
name|expr
operator|->
name|X_op
operator|==
name|O_lo16
operator|||
name|expr
operator|->
name|X_op
operator|==
name|O_hi16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid expression for operand %i of '%s'"
argument_list|)
argument_list|,
name|opnum
operator|+
literal|1
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Next try the generic relocs.  */
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
name|reloc
operator|=
name|encode_reloc
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_NONE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid relocation in instruction slot %i"
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|howto
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"undefined symbol for opcode \"%s\""
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fmt_length
operator|=
name|xtensa_format_length
argument_list|(
name|xtensa_default_isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|the_fix
operator|=
name|fix_new_exp
argument_list|(
name|fragP
argument_list|,
name|offset
argument_list|,
name|fmt_length
argument_list|,
name|expr
argument_list|,
name|howto
operator|->
name|pc_relative
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|the_fix
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
name|the_fix
operator|->
name|tc_fix_data
operator|.
name|X_add_symbol
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
name|the_fix
operator|->
name|tc_fix_data
operator|.
name|X_add_number
operator|=
name|expr
operator|->
name|X_add_number
expr_stmt|;
name|the_fix
operator|->
name|tc_fix_data
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xg_emit_insn_to_buf
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|offsetT
name|offset
parameter_list|,
name|bfd_boolean
name|build_fix
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|has_symbolic_immed
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|has_symbolic_immed
operator|=
name|tinsn_to_insnbuf
argument_list|(
name|tinsn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_symbolic_immed
operator|&&
name|build_fix
condition|)
block|{
comment|/* Add a fixup.  */
name|xtensa_format
name|fmt
init|=
name|xg_get_single_format
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|slot
init|=
name|xg_get_single_slot
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|opnum
init|=
name|get_relaxable_immed
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|tinsn
operator|->
name|tok
index|[
name|opnum
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|xg_add_opcode_fix
argument_list|(
name|tinsn
argument_list|,
name|opnum
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|exp
argument_list|,
name|fragP
argument_list|,
name|offset
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_resolve_literals
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|symbolS
modifier|*
name|lit_sym
parameter_list|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|get_special_literal_symbol
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lit_sym
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|==
name|sym
condition|)
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|lit_sym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_resolve_labels
parameter_list|(
name|TInsn
modifier|*
name|insn
parameter_list|,
name|symbolS
modifier|*
name|label_sym
parameter_list|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|get_special_label_symbol
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|==
name|sym
condition|)
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_symbol
operator|=
name|label_sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the instruction can write to the specified    integer register.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_register_writer
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|,
specifier|const
name|char
modifier|*
name|regset
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_ops
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|num_ops
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|char
name|inout
decl_stmt|;
name|inout
operator|=
name|xtensa_operand_inout
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inout
operator|==
literal|'o'
operator|||
name|inout
operator|==
literal|'m'
operator|)
operator|&&
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|1
condition|)
block|{
name|xtensa_regfile
name|opnd_rf
init|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|,
name|regset
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
operator|==
name|O_register
operator|)
operator|&&
operator|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_number
operator|==
name|regnum
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_bad_loopend_opcode
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|tinsn
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_call0_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx0_opcode
operator|||
name|opcode
operator|==
name|xtensa_call4_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx4_opcode
operator|||
name|opcode
operator|==
name|xtensa_call8_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx8_opcode
operator|||
name|opcode
operator|==
name|xtensa_call12_opcode
operator|||
name|opcode
operator|==
name|xtensa_callx12_opcode
operator|||
name|opcode
operator|==
name|xtensa_isync_opcode
operator|||
name|opcode
operator|==
name|xtensa_ret_opcode
operator|||
name|opcode
operator|==
name|xtensa_ret_n_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_n_opcode
operator|||
name|opcode
operator|==
name|xtensa_waiti_opcode
operator|||
name|opcode
operator|==
name|xtensa_rsr_lcount_opcode
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Labels that begin with ".Ln" or ".LM"  are unaligned.    This allows the debugger to add unaligned labels.    Also, the assembler generates stabs labels that need    not be aligned:  FAKE_LABEL_NAME . {"F", "L", "endfunc"}.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_unaligned_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
specifier|static
name|size_t
name|fake_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'n'
operator|||
name|name
index|[
literal|2
index|]
operator|==
literal|'M'
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* FAKE_LABEL_NAME followed by "F", "L" or "endfunc" */
if|if
condition|(
name|fake_size
operator|==
literal|0
condition|)
name|fake_size
operator|=
name|strlen
argument_list|(
name|FAKE_LABEL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|strncmp
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|name
argument_list|,
name|fake_size
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
name|fake_size
index|]
operator|==
literal|'F'
operator|||
name|name
index|[
name|fake_size
index|]
operator|==
literal|'L'
operator|||
operator|(
name|name
index|[
name|fake_size
index|]
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
literal|"endfunc"
argument_list|,
name|name
operator|+
name|fake_size
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|fragS
modifier|*
name|next_non_empty_frag
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|fragS
modifier|*
name|next_fragP
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
comment|/* Sometimes an empty will end up here due storage allocation issues.      So we have to skip until we find something legit.  */
while|while
condition|(
name|next_fragP
operator|&&
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
operator|||
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|next_fragP
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_frag_opcode_is_loop
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|,
name|xtensa_opcode
modifier|*
name|opcode
parameter_list|)
block|{
name|xtensa_opcode
name|out_opcode
decl_stmt|;
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|out_opcode
operator|=
name|get_opcode_from_buf
argument_list|(
name|next_fragP
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|out_opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|*
name|opcode
operator|=
name|out_opcode
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|frag_format_size
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|fmt_size
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|==
name|NULL
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|fmt_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* If the next format won't be changing due to relaxation, just      return the length of the first format.  */
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|fragP
operator|->
name|fr_literal
condition|)
return|return
name|fmt_size
return|;
comment|/* If during relaxation we have to pull an instruction out of a      multi-slot instruction, we will return the more conservative      number.  This works because alignment on bigger instructions      is more restrictive than alignment on smaller instructions.      This is more conservative than we would like, but it happens      infrequently.  */
if|if
condition|(
name|xtensa_format_num_slots
argument_list|(
name|xtensa_default_isa
argument_list|,
name|fmt
argument_list|)
operator|>
literal|1
condition|)
return|return
name|fmt_size
return|;
comment|/* If we aren't doing one of our own relaxations or it isn't      slot-based, then the insn size won't change.  */
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
condition|)
return|return
name|fmt_size
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
name|RELAX_SLOTS
condition|)
return|return
name|fmt_size
return|;
comment|/* If an instruction is about to grow, return the longer size.  */
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_IMMED_STEP1
operator|||
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_IMMED_STEP2
operator|||
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_IMMED_STEP3
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
condition|)
return|return
literal|2
operator|+
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
return|;
return|return
name|fmt_size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|next_frag_format_size
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
return|return
name|frag_format_size
argument_list|(
name|next_fragP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* In early Xtensa Processors, for reasons that are unclear, the ISA    required two-byte instructions to be treated as three-byte instructions    for loop instruction alignment.  This restriction was removed beginning    with Xtensa LX.  Now the only requirement on loop instruction alignment    is that the first instruction of the loop must appear at an address that    does not cross a fetch boundary.  */
end_comment

begin_function
specifier|static
name|int
name|get_loop_align_size
parameter_list|(
name|int
name|insn_size
parameter_list|)
block|{
if|if
condition|(
name|insn_size
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|xtensa_fetch_width
return|;
if|if
condition|(
name|enforce_three_byte_loop_align
operator|&&
name|insn_size
operator|==
literal|2
condition|)
return|return
literal|3
return|;
return|return
name|insn_size
return|;
block|}
end_function

begin_comment
comment|/* If the next legit fragment is an end-of-loop marker,    switch its state so it will instantiate a NOP.  */
end_comment

begin_function
specifier|static
name|void
name|update_next_frag_state
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|fragS
modifier|*
name|next_fragP
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
name|fragS
modifier|*
name|new_target
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|align_targets
condition|)
block|{
comment|/* We are guaranteed there will be one of these...   */
while|while
condition|(
operator|!
operator|(
name|next_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_UNREACHABLE
operator|||
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
operator|)
operator|)
condition|)
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
name|assert
argument_list|(
name|next_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_UNREACHABLE
operator|||
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* ...and one of these.  */
name|new_target
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|new_target
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|new_target
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_DESIRE_ALIGN
operator|||
name|new_target
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN
operator|)
operator|)
condition|)
name|new_target
operator|=
name|new_target
operator|->
name|fr_next
expr_stmt|;
name|assert
argument_list|(
name|new_target
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|new_target
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_DESIRE_ALIGN
operator|||
name|new_target
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|next_fragP
operator|&&
name|next_fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|next_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|next_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_LOOP_END
condition|)
block|{
name|next_fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LOOP_END_ADD_NOP
expr_stmt|;
return|return;
block|}
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_frag_is_branch_target
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* Sometimes an empty will end up here due to storage allocation issues,      so we have to skip until we find something legit.  */
for|for
control|(
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_frag_is_loop_target
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* Sometimes an empty will end up here due storage allocation issues.      So we have to skip until we find something legit. */
for|for
control|(
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|addressT
name|next_frag_pre_opcode_bytes
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
specifier|const
name|fragS
modifier|*
name|next_fragp
init|=
name|fragp
operator|->
name|fr_next
decl_stmt|;
name|xtensa_opcode
name|next_opcode
decl_stmt|;
if|if
condition|(
operator|!
name|next_frag_opcode_is_loop
argument_list|(
name|fragp
argument_list|,
operator|&
name|next_opcode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Sometimes an empty will end up here due to storage allocation issues,      so we have to skip until we find something legit.  */
while|while
condition|(
name|next_fragp
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|next_fragp
operator|=
name|next_fragp
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|next_fragp
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
condition|)
return|return
literal|0
return|;
comment|/* There is some implicit knowledge encoded in here.      The LOOP instructions that are NOT RELAX_IMMED have      been relaxed.  Note that we can assume that the LOOP      instruction is in slot 0 because loops aren't bundleable.  */
if|if
condition|(
name|next_fragp
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|>
name|RELAX_IMMED
condition|)
return|return
name|get_expanded_loop_offset
argument_list|(
name|next_opcode
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark a location where we can later insert literal frags.  Update    the section's literal_pool_loc, so subsequent literals can be    placed nearest to their use.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_mark_literal_pool_location
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Any labels pointing to the current location need      to be adjusted to after the literal pool.  */
name|emit_state
name|s
decl_stmt|;
name|fragS
modifier|*
name|pool_location
decl_stmt|;
if|if
condition|(
name|use_literal_section
condition|)
return|return;
comment|/* We stash info in these frags so we can later move the literal's      fixes into this frchain's fix list.  */
name|pool_location
operator|=
name|frag_now
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|lit_frchain
operator|=
name|frchain_now
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_LITERAL_POOL_BEGIN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|lit_seg
operator|=
name|now_seg
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_LITERAL_POOL_END
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
comment|/* Now put a frag into the literal pool that points to this location.  */
name|set_literal_pool_location
argument_list|(
name|now_seg
argument_list|,
name|pool_location
argument_list|)
expr_stmt|;
name|xtensa_switch_to_non_abs_literal_fragment
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Close whatever frag is there.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|pool_location
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a nop of the correct size into tinsn.  */
end_comment

begin_function
specifier|static
name|void
name|build_nop
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tinsn_init
argument_list|(
name|tinsn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|tinsn
operator|->
name|opcode
operator|=
name|xtensa_nop_n_opcode
expr_stmt|;
name|tinsn
operator|->
name|ntok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"opcode 'NOP.N' unavailable in this configuration"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|xtensa_nop_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|tinsn
operator|->
name|opcode
operator|=
name|xtensa_or_opcode
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|tinsn
operator|->
name|tok
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|tinsn
operator|->
name|tok
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tinsn
operator|->
name|ntok
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|tinsn
operator|->
name|opcode
operator|=
name|xtensa_nop_opcode
expr_stmt|;
name|assert
argument_list|(
name|tinsn
operator|->
name|opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble a NOP of the requested size in the buffer.  User must have    allocated "buf" with at least "size" bytes.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_nop
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|tinsn
decl_stmt|;
name|build_nop
argument_list|(
operator|&
name|tinsn
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|tinsn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes for the offset of the expanded loop    instruction.  This should be incorporated into the relaxation    specification but is hard-coded here.  This is used to auto-align    the loop instruction.  It is invalid to call this function if the    configuration does not have loops or if the opcode is not a loop    opcode.  */
end_comment

begin_function
specifier|static
name|addressT
name|get_expanded_loop_offset
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
comment|/* This is the OFFSET of the loop instruction in the expanded loop.      This MUST correspond directly to the specification of the loop      expansion.  It will be validated on fragment conversion.  */
name|assert
argument_list|(
name|opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loop_opcode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loopnez_opcode
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_loopgtz_opcode
condition|)
return|return
literal|6
return|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"get_expanded_loop_offset: invalid opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|fragS
modifier|*
name|get_literal_pool_location
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
return|return
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|literal_pool_loc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_literal_pool_location
parameter_list|(
name|segT
name|seg
parameter_list|,
name|fragS
modifier|*
name|literal_pool_loc
parameter_list|)
block|{
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|literal_pool_loc
operator|=
name|literal_pool_loc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set frag assembly state should be called when a new frag is    opened and after a frag has been closed.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_set_frag_assembly_state
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
if|if
condition|(
operator|!
name|density_supported
condition|)
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|=
name|TRUE
expr_stmt|;
comment|/* This function is called from subsegs_finish, which is called      after xtensa_end, so we can't use "use_transform" or      "use_schedule" here.  */
if|if
condition|(
operator|!
name|directive_state
index|[
name|directive_transform
index|]
condition|)
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|directive_state
index|[
name|directive_longcalls
index|]
condition|)
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_longcalls
operator|=
name|TRUE
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
operator|=
name|directive_state
index|[
name|directive_absolute_literals
index|]
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|relaxable_section
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
return|return
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_mark_frags_for_org
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
modifier|*
name|seclist
decl_stmt|;
comment|/* Walk over each fragment of all of the current segments.  If we find      a .org frag in any of the segments, mark all frags prior to it as      "no transform", which will prevent linker optimizations from messing      up the .org distance.  This should be done after      xtensa_find_unmarked_state_frags, because we don't want to worry here      about that function trashing the data we save here.  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
continue|continue;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
name|fragS
modifier|*
name|last_fragP
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* cvt_frag_to_fill has changed the fr_type of org frags to 		 rs_fill, so use the value as cached in rs_subtype here.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ORG
condition|)
block|{
while|while
condition|(
name|last_fragP
operator|!=
name|fragP
operator|->
name|fr_next
condition|)
block|{
name|last_fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
operator|=
name|TRUE
expr_stmt|;
name|last_fragP
operator|=
name|last_fragP
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_find_unmarked_state_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
modifier|*
name|seclist
decl_stmt|;
comment|/* Walk over each fragment of all of the current segments.  For each      unmarked fragment, mark it with the same info as the previous      fragment.  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
continue|continue;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
name|fragS
modifier|*
name|last_fragP
init|=
literal|0
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
condition|)
block|{
if|if
condition|(
name|last_fragP
operator|==
literal|0
condition|)
block|{
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"assembly state not set for first frag in section %s"
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
operator|=
name|TRUE
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|=
name|last_fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
operator|=
name|last_fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_longcalls
operator|=
name|last_fragP
operator|->
name|tc_frag_data
operator|.
name|use_longcalls
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
operator|=
name|last_fragP
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
condition|)
name|last_fragP
operator|=
name|fragP
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_find_unaligned_branch_targets
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_insnbuf
name|insnbuf
init|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
decl_stmt|;
while|while
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|frag
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
condition|)
block|{
name|int
name|op_size
decl_stmt|;
name|addressT
name|branch_align
decl_stmt|,
name|frag_addr
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|frag
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|op_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|branch_align
operator|=
literal|1
operator|<<
name|branch_align_power
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|frag_addr
operator|=
name|frag
operator|->
name|fr_address
operator|%
name|branch_align
expr_stmt|;
if|if
condition|(
name|frag_addr
operator|+
name|op_size
operator|>
name|branch_align
condition|)
name|as_warn_where
argument_list|(
name|frag
operator|->
name|fr_file
argument_list|,
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unaligned branch target: %d bytes at 0x%lx"
argument_list|)
argument_list|,
name|op_size
argument_list|,
operator|(
name|long
operator|)
name|frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|xtensa_insnbuf_free
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_find_unaligned_loops
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|xtensa_insnbuf
name|insnbuf
init|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
decl_stmt|;
while|while
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|frag
operator|->
name|tc_frag_data
operator|.
name|is_first_loop_insn
condition|)
block|{
name|int
name|op_size
decl_stmt|;
name|addressT
name|frag_addr
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|frag
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|op_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|frag_addr
operator|=
name|frag
operator|->
name|fr_address
operator|%
name|xtensa_fetch_width
expr_stmt|;
if|if
condition|(
name|frag_addr
operator|+
name|op_size
operator|>
name|xtensa_fetch_width
condition|)
name|as_warn_where
argument_list|(
name|frag
operator|->
name|fr_file
argument_list|,
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unaligned loop: %d bytes at 0x%lx"
argument_list|)
argument_list|,
name|op_size
argument_list|,
operator|(
name|long
operator|)
name|frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|xtensa_insnbuf_free
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xg_apply_fix_value
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
name|val
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|bfd_boolean
name|alt_reloc
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|char
modifier|*
specifier|const
name|fixpos
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
operator|(
name|void
operator|)
name|decode_reloc
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|,
operator|&
name|slot
argument_list|,
operator|&
name|alt_reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_reloc
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected fix"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fixpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable fix"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable fix"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CONST16 immediates are not PC-relative, despite the fact that we      reuse the normal PC-relative operand relocations for the low part      of a CONST16 operand.  */
if|if
condition|(
name|opcode
operator|==
name|xtensa_const16_opcode
condition|)
return|return
literal|0
return|;
name|xtensa_insnbuf_set_operand
argument_list|(
name|slotbuf
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|opcode
argument_list|,
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fixpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* External Functions and Other GAS Hooks.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|xtensa_target_format
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-xtensa-be"
else|:
literal|"elf32-xtensa-le"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xtensa_file_arch_init
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_set_private_flags
argument_list|(
name|abfd
argument_list|,
literal|0x100
operator||
literal|0x200
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|current_section
init|=
name|now_seg
decl_stmt|;
name|int
name|current_subsec
init|=
name|now_subseg
decl_stmt|;
name|xtensa_isa
name|isa
decl_stmt|;
name|xtensa_default_isa
operator|=
name|xtensa_isa_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isa
operator|=
name|xtensa_default_isa
expr_stmt|;
name|linkrelax
operator|=
literal|1
expr_stmt|;
comment|/* Set up the literal sections.  */
name|memset
argument_list|(
operator|&
name|default_lit_sections
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|default_lit_sections
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
name|xg_init_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
name|xtensa_addi_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"addi"
argument_list|)
expr_stmt|;
name|xtensa_addmi_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"addmi"
argument_list|)
expr_stmt|;
name|xtensa_call0_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call0"
argument_list|)
expr_stmt|;
name|xtensa_call4_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call4"
argument_list|)
expr_stmt|;
name|xtensa_call8_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call8"
argument_list|)
expr_stmt|;
name|xtensa_call12_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"call12"
argument_list|)
expr_stmt|;
name|xtensa_callx0_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx0"
argument_list|)
expr_stmt|;
name|xtensa_callx4_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx4"
argument_list|)
expr_stmt|;
name|xtensa_callx8_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx8"
argument_list|)
expr_stmt|;
name|xtensa_callx12_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"callx12"
argument_list|)
expr_stmt|;
name|xtensa_const16_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"const16"
argument_list|)
expr_stmt|;
name|xtensa_entry_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"entry"
argument_list|)
expr_stmt|;
name|xtensa_movi_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"movi"
argument_list|)
expr_stmt|;
name|xtensa_movi_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"movi.n"
argument_list|)
expr_stmt|;
name|xtensa_isync_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"isync"
argument_list|)
expr_stmt|;
name|xtensa_jx_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"jx"
argument_list|)
expr_stmt|;
name|xtensa_l32r_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"l32r"
argument_list|)
expr_stmt|;
name|xtensa_loop_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loop"
argument_list|)
expr_stmt|;
name|xtensa_loopnez_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loopnez"
argument_list|)
expr_stmt|;
name|xtensa_loopgtz_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"loopgtz"
argument_list|)
expr_stmt|;
name|xtensa_nop_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
name|xtensa_nop_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"nop.n"
argument_list|)
expr_stmt|;
name|xtensa_or_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|xtensa_ret_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"ret"
argument_list|)
expr_stmt|;
name|xtensa_ret_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"ret.n"
argument_list|)
expr_stmt|;
name|xtensa_retw_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"retw"
argument_list|)
expr_stmt|;
name|xtensa_retw_n_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"retw.n"
argument_list|)
expr_stmt|;
name|xtensa_rsr_lcount_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"rsr.lcount"
argument_list|)
expr_stmt|;
name|xtensa_waiti_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"waiti"
argument_list|)
expr_stmt|;
name|init_op_placement_info_table
argument_list|()
expr_stmt|;
comment|/* Set up the assembly state.  */
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
condition|)
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TC_INIT_FIX_DATA hook */
end_comment

begin_function
name|void
name|xtensa_init_fix_data
parameter_list|(
name|fixS
modifier|*
name|x
parameter_list|)
block|{
name|x
operator|->
name|tc_fix_data
operator|.
name|slot
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|tc_fix_data
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|tc_fix_data
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tc_frob_label hook */
end_comment

begin_function
name|void
name|xtensa_frob_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|float
name|freq
decl_stmt|;
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"labels are not valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|freq
operator|=
name|get_subseg_target_freq
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
expr_stmt|;
comment|/* Since the label was already attached to a frag associated with the      previous basic block, it now needs to be reset to the current frag.  */
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|generating_literals
condition|)
name|xtensa_add_literal_sym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|xtensa_add_insn_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_loop_target
condition|)
block|{
if|if
condition|(
operator|(
name|get_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
operator|&
name|FLAG_IS_BAD_LOOPEND
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid last instruction for a zero-overhead loop"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_LOOP_END
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* No target aligning in the absolute section.  */
if|if
condition|(
name|now_seg
operator|!=
name|absolute_section
operator|&&
name|do_align_targets
argument_list|()
operator|&&
operator|!
name|is_unaligned_label
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|generating_literals
condition|)
block|{
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|freq
argument_list|,
name|RELAX_DESIRE_ALIGN_IF_TARGET
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to mark the following properties even if we aren't aligning.  */
comment|/* If the label is already known to be a branch target, i.e., a      forward branch, mark the frag accordingly.  Backward branches      are handled by xg_add_branch_and_loop_targets.  */
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_branch_target
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
comment|/* Loops only go forward, so they can be identified here.  */
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|is_loop_target
condition|)
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
operator|=
name|TRUE
expr_stmt|;
name|dwarf2_emit_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tc_unrecognized_line hook */
end_comment

begin_function
name|int
name|xtensa_unrecognized_line
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'{'
case|:
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
operator|==
literal|0
condition|)
block|{
comment|/* PR8110: Cannot emit line number info inside a FLIX bundle 	     when using --gstabs.  Temporarily disable debug info.  */
name|generate_lineno_debug
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
block|{
name|xt_saved_debug_type
operator|=
name|debug_type
expr_stmt|;
name|debug_type
operator|=
name|DEBUG_NONE
expr_stmt|;
block|}
name|cur_vinsn
operator|.
name|inside_bundle
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"extra opening brace"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|finish_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"extra closing brace"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* md_flush_pending_output hook */
end_comment

begin_function
name|void
name|xtensa_flush_pending_output
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This line fixes a bug where automatically generated gstabs info      separates a function label from its entry instruction, ending up      with the literal position between the function label and the entry      instruction and crashing code.  It only happens with --gstabs and      --text-section-literals, and when several other obscure relaxation      conditions are met.  */
if|if
condition|(
name|outputting_stabs_line_debug
condition|)
return|return;
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing closing brace"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a non-zero instruction fragment, close it.  */
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
operator|&&
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|FALSE
expr_stmt|;
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We had an error while parsing an instruction.  The string might look    like this: "insn arg1, arg2 }".  If so, we need to see the closing    brace and reset some fields.  Otherwise, the vinsn never gets closed    and the num_slots field will grow past the end of the array of slots,    and bad things happen.  */
end_comment

begin_function
specifier|static
name|void
name|error_reset_cur_vinsn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'}'
operator|||
operator|*
operator|(
name|input_line_pointer
operator|-
literal|1
operator|)
operator|==
literal|'}'
operator|||
operator|*
operator|(
name|input_line_pointer
operator|-
literal|2
operator|)
operator|==
literal|'}'
condition|)
name|xg_clear_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|,
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|opnamelen
decl_stmt|;
name|bfd_boolean
name|has_underbar
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|arg_strings
index|[
name|MAX_INSN_ARGS
index|]
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|TInsn
name|orig_insn
decl_stmt|;
comment|/* Original instruction from the input.  */
name|tinsn_init
argument_list|(
operator|&
name|orig_insn
argument_list|)
expr_stmt|;
comment|/* Split off the opcode.  */
name|opnamelen
operator|=
name|strspn
argument_list|(
name|str
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz_/0123456789."
argument_list|)
expr_stmt|;
name|opname
operator|=
name|xmalloc
argument_list|(
name|opnamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opname
argument_list|,
name|str
argument_list|,
name|opnamelen
argument_list|)
expr_stmt|;
name|opname
index|[
name|opnamelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|num_args
operator|=
name|tokenize_arguments
argument_list|(
name|arg_strings
argument_list|,
name|str
operator|+
name|opnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|==
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xg_translate_idioms
argument_list|(
operator|&
name|opname
argument_list|,
operator|&
name|num_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
return|return;
comment|/* Check for an underbar prefix.  */
if|if
condition|(
operator|*
name|opname
operator|==
literal|'_'
condition|)
block|{
name|has_underbar
operator|=
name|TRUE
expr_stmt|;
name|opname
operator|+=
literal|1
expr_stmt|;
block|}
name|orig_insn
operator|.
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|orig_insn
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
name|orig_insn
operator|.
name|is_specific_opcode
operator|=
operator|(
name|has_underbar
operator|||
operator|!
name|use_transform
argument_list|()
operator|)
expr_stmt|;
name|orig_insn
operator|.
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_insn
operator|.
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|xtensa_format
name|fmt
init|=
name|xtensa_format_lookup
argument_list|(
name|isa
argument_list|,
name|opname
argument_list|)
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode or format name '%s'"
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"format names only valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_vinsn
operator|.
name|format
operator|!=
name|XTENSA_UNDEFINED
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"multiple formats specified for one bundle; using '%s'"
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|cur_vinsn
operator|.
name|format
operator|=
name|fmt
expr_stmt|;
name|free
argument_list|(
name|has_underbar
condition|?
name|opname
operator|-
literal|1
else|:
name|opname
argument_list|)
expr_stmt|;
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Parse the arguments.  */
if|if
condition|(
name|parse_arguments
argument_list|(
operator|&
name|orig_insn
argument_list|,
name|num_args
argument_list|,
name|arg_strings
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error"
argument_list|)
argument_list|)
expr_stmt|;
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Free the opcode and argument strings, now that they've been parsed.  */
name|free
argument_list|(
name|has_underbar
condition|?
name|opname
operator|-
literal|1
else|:
name|opname
argument_list|)
expr_stmt|;
name|opname
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num_args
operator|--
operator|>
literal|0
condition|)
name|free
argument_list|(
name|arg_strings
index|[
name|num_args
index|]
argument_list|)
expr_stmt|;
comment|/* Get expressions for invisible operands.  */
if|if
condition|(
name|get_invisible_operands
argument_list|(
operator|&
name|orig_insn
argument_list|)
condition|)
block|{
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Check for the right number and type of arguments.  */
if|if
condition|(
name|tinsn_check_arguments
argument_list|(
operator|&
name|orig_insn
argument_list|)
condition|)
block|{
name|error_reset_cur_vinsn
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* A FLIX bundle may be spread across multiple input lines.  We want to      report the first such line in the debug information.  Record the line      number for each TInsn (assume the file name doesn't change), so the      first line can be found later.  */
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|orig_insn
operator|.
name|linenum
argument_list|)
expr_stmt|;
name|xg_add_branch_and_loop_targets
argument_list|(
operator|&
name|orig_insn
argument_list|)
expr_stmt|;
comment|/* Check that immediate value for ENTRY is>= 16.  */
if|if
condition|(
name|orig_insn
operator|.
name|opcode
operator|==
name|xtensa_entry_opcode
operator|&&
name|orig_insn
operator|.
name|ntok
operator|>=
literal|3
condition|)
block|{
name|expressionS
modifier|*
name|exp
init|=
operator|&
name|orig_insn
operator|.
name|tok
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_add_number
operator|<
literal|16
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"entry instruction with stack decrement< 16"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finish it off:      assemble_tokens (opcode, tok, ntok);      expand the tokens from the orig_insn into the      stack of instructions that will not expand      unless required at relaxation time.  */
if|if
condition|(
operator|!
name|cur_vinsn
operator|.
name|inside_bundle
condition|)
name|emit_single_op
argument_list|(
operator|&
name|orig_insn
argument_list|)
expr_stmt|;
else|else
comment|/* We are inside a bundle.  */
block|{
name|cur_vinsn
operator|.
name|slots
index|[
name|cur_vinsn
operator|.
name|num_slots
index|]
operator|=
name|orig_insn
expr_stmt|;
name|cur_vinsn
operator|.
name|num_slots
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'}'
operator|||
operator|*
operator|(
name|input_line_pointer
operator|-
literal|1
operator|)
operator|==
literal|'}'
operator|||
operator|*
operator|(
name|input_line_pointer
operator|-
literal|2
operator|)
operator|==
literal|'}'
condition|)
name|finish_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
block|}
comment|/* We've just emitted a new instruction so clear the list of labels.  */
name|xtensa_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* HANDLE_ALIGN hook */
end_comment

begin_comment
comment|/* For a .align directive, we mark the previous block with the alignment    information.  This will be placed in the object file in the    property section corresponding to this section.  */
end_comment

begin_function
name|void
name|xtensa_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
if|if
condition|(
name|linkrelax
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|&&
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|)
operator|&&
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|>
literal|0
operator|&&
name|fragP
operator|->
name|fr_offset
operator|>
literal|0
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_align
operator|=
name|TRUE
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|alignment
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_test
condition|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unaligned entry instruction"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linkrelax
operator|&&
name|fragP
operator|->
name|fr_type
operator|==
name|rs_org
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_ORG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TC_FRAG_INIT hook */
end_comment

begin_function
name|void
name|xtensa_frag_init
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine.  */
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|char
modifier|*
name|insn_p
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|uint32
name|opnd_value
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
name|bfd_boolean
name|alt_reloc
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_XTENSA_ASM_EXPAND
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|insn_p
operator|=
operator|&
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
index|[
name|fixP
operator|->
name|fx_where
index|]
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|insn_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"bad instruction format"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode_reloc
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|,
operator|&
name|slot
argument_list|,
operator|&
name|alt_reloc
argument_list|)
operator|!=
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid relocation"
argument_list|)
argument_list|)
expr_stmt|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
comment|/* Check for "alternate" relocations (operand not specified).  None      of the current uses for these are really PC-relative.  */
if|if
condition|(
name|alt_reloc
operator|||
name|opcode
operator|==
name|xtensa_const16_opcode
condition|)
block|{
if|if
condition|(
name|opcode
operator|!=
name|xtensa_l32r_opcode
operator|&&
name|opcode
operator|!=
name|xtensa_const16_opcode
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid relocation for '%s' instruction"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|opnum
operator|=
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|opnd_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|)
operator|!=
literal|1
operator|||
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnum
argument_list|,
operator|&
name|opnd_value
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid relocation for operand %d of '%s'"
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
operator|-
name|opnd_value
return|;
block|}
end_function

begin_comment
comment|/* TC_FORCE_RELOCATION hook */
end_comment

begin_function
name|int
name|xtensa_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT0_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT1_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT2_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT3_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT4_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT5_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT6_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT7_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT8_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT9_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT10_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT11_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT12_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT13_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT14_ALT
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|linkrelax
operator|&&
name|fix
operator|->
name|fx_addsy
operator|&&
name|relaxable_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* TC_VALIDATE_FIX_SUB hook */
end_comment

begin_function
name|int
name|xtensa_validate_fix_sub
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
name|segT
name|add_symbol_segment
decl_stmt|,
name|sub_symbol_segment
decl_stmt|;
comment|/* The difference of two symbols should be resolved by the assembler when      linkrelax is not set.  If the linker may relax the section containing      the symbols, then an Xtensa DIFF relocation must be generated so that      the linker knows to adjust the difference value.  */
if|if
condition|(
operator|!
name|linkrelax
operator|||
name|fix
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Make sure both symbols are in the same segment, and that segment is      "normal" and relaxable.  If the segment is not "normal", then the      fix is not valid.  If the segment is not "relaxable", then the fix      should have been handled earlier.  */
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEG_NORMAL
argument_list|(
name|add_symbol_segment
argument_list|)
operator|||
operator|!
name|relaxable_section
argument_list|(
name|add_symbol_segment
argument_list|)
condition|)
return|return
literal|0
return|;
name|sub_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
return|return
operator|(
name|sub_symbol_segment
operator|==
name|add_symbol_segment
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NO_PSEUDO_DOT hook */
end_comment

begin_comment
comment|/* This function has nothing to do with pseudo dots, but this is the    nearest macro to where the check needs to take place.  FIXME: This    seems wrong.  */
end_comment

begin_function
name|bfd_boolean
name|xtensa_check_inside_bundle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cur_vinsn
operator|.
name|inside_bundle
operator|&&
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directives are not valid inside bundles"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This function must always return FALSE because it is called via a      macro that has nothing to do with bundling.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* md_elf_section_change_hook */
end_comment

begin_function
name|void
name|xtensa_elf_section_change_hook
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up the assembly state.  */
if|if
condition|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_assembly_state_set
condition|)
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tc_fix_adjustable hook */
end_comment

begin_function
name|bfd_boolean
name|xtensa_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* An offset is not allowed in combination with the difference of two      symbols, but that cannot be easily detected after a local symbol      has been adjusted to a (section+offset) form.  Return 0 so that such      an fix will not be adjusted.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|&&
name|fixP
operator|->
name|fx_offset
operator|&&
name|relaxable_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|fixpos
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|valueT
name|val
init|=
literal|0
decl_stmt|;
comment|/* Subtracted symbols are only allowed for a few relocation types, and      unless linkrelax is enabled, they should not make it to this point.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
operator|!
operator|(
name|linkrelax
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8
operator|)
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_XTENSA_DIFF8
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_XTENSA_DIFF16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_XTENSA_DIFF32
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* An offset is only allowed when it results from adjusting a 	     local symbol into a section-relative offset.  If the offset 	     came from the original expression, tc_fix_adjustable will have 	     prevented the fix from being converted to a section-relative 	     form so that we can flag the error here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_offset
operator|!=
literal|0
operator|&&
operator|!
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent subtraction with an offset"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|+
name|fixP
operator|->
name|fx_offset
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|)
expr_stmt|;
comment|/* The difference value gets written out, and the DIFF reloc 	     identifies the address of the subtracted symbol (i.e., the one 	     with the lowest address).  */
operator|*
name|valP
operator|=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|-=
name|val
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|=
operator|*
name|valP
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* fall through */
case|case
name|BFD_RELOC_XTENSA_PLT
case|:
name|md_number_to_chars
argument_list|(
name|fixpos
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|0
expr_stmt|;
comment|/* Use the standard overflow check.  */
break|break;
case|case
name|BFD_RELOC_XTENSA_SLOT0_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT1_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT2_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT3_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT4_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT5_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT6_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT7_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT8_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT9_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT10_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT11_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT12_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT13_OP
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT14_OP
case|:
if|if
condition|(
name|linkrelax
condition|)
block|{
comment|/* Write the tentative value of a PC-relative relocation to a 	     local symbol into the instruction.  The value will be ignored 	     by the linker, and it makes the object file disassembly 	     readable when all branch targets are encoded in relocations.  */
name|assert
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
operator|&&
operator|!
name|S_FORCE_RELOC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|+
name|fixP
operator|->
name|fx_offset
operator|-
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|xg_apply_fix_value
argument_list|(
name|fixP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|=
operator|*
name|valP
expr_stmt|;
if|if
condition|(
name|xg_apply_fix_value
argument_list|(
name|fixP
argument_list|,
name|val
argument_list|)
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT0_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT1_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT2_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT3_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT4_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT5_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT6_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT7_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT8_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT9_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT10_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT11_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT12_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT13_ALT
case|:
case|case
name|BFD_RELOC_XTENSA_SLOT14_ALT
case|:
comment|/* These all need to be resolved at link-time.  Do nothing now.  */
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unhandled local relocation fix %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|idx
init|=
name|i
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|idx
operator|=
operator|(
name|prec
operator|-
literal|1
operator|-
name|i
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|idx
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|total_frag_text_expansion
argument_list|(
name|fragP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* Make sure none of our internal relocations make it this far.      They'd better have been fully resolved by this point.  */
name|assert
argument_list|(
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent `%s' relocation in object file"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|!=
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error? cannot generate `%s' relocation"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Checks for resource conflicts between instructions.  */
end_comment

begin_comment
comment|/* The func unit stuff could be implemented as bit-vectors rather    than the iterative approach here.  If it ends up being too    slow, we will switch it.  */
end_comment

begin_function
name|resource_table
modifier|*
name|new_resource_table
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|cycles
parameter_list|,
name|int
name|nu
parameter_list|,
name|unit_num_copies_func
name|uncf
parameter_list|,
name|opcode_num_units_func
name|onuf
parameter_list|,
name|opcode_funcUnit_use_unit_func
name|ouuf
parameter_list|,
name|opcode_funcUnit_use_stage_func
name|ousf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|resource_table
modifier|*
name|rt
init|=
operator|(
name|resource_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|resource_table
argument_list|)
argument_list|)
decl_stmt|;
name|rt
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|rt
operator|->
name|cycles
operator|=
name|cycles
expr_stmt|;
name|rt
operator|->
name|allocated_cycles
operator|=
name|cycles
expr_stmt|;
name|rt
operator|->
name|num_units
operator|=
name|nu
expr_stmt|;
name|rt
operator|->
name|unit_num_copies
operator|=
name|uncf
expr_stmt|;
name|rt
operator|->
name|opcode_num_units
operator|=
name|onuf
expr_stmt|;
name|rt
operator|->
name|opcode_unit_use
operator|=
name|ouuf
expr_stmt|;
name|rt
operator|->
name|opcode_unit_stage
operator|=
name|ousf
expr_stmt|;
name|rt
operator|->
name|units
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|cycles
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cycles
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|units
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|nu
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_function
name|void
name|clear_resource_table
parameter_list|(
name|resource_table
modifier|*
name|rt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|allocated_cycles
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rt
operator|->
name|num_units
condition|;
name|j
operator|++
control|)
name|rt
operator|->
name|units
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We never shrink it, just fake it into thinking so.  */
end_comment

begin_function
name|void
name|resize_resource_table
parameter_list|(
name|resource_table
modifier|*
name|rt
parameter_list|,
name|int
name|cycles
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|old_cycles
decl_stmt|;
name|rt
operator|->
name|cycles
operator|=
name|cycles
expr_stmt|;
if|if
condition|(
name|cycles
operator|<=
name|rt
operator|->
name|allocated_cycles
condition|)
return|return;
name|old_cycles
operator|=
name|rt
operator|->
name|allocated_cycles
expr_stmt|;
name|rt
operator|->
name|allocated_cycles
operator|=
name|cycles
expr_stmt|;
name|rt
operator|->
name|units
operator|=
name|xrealloc
argument_list|(
name|rt
operator|->
name|units
argument_list|,
name|rt
operator|->
name|allocated_cycles
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_cycles
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|units
index|[
name|i
index|]
operator|=
name|xrealloc
argument_list|(
name|rt
operator|->
name|units
index|[
name|i
index|]
argument_list|,
name|rt
operator|->
name|num_units
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old_cycles
init|;
name|i
operator|<
name|cycles
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|units
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
name|rt
operator|->
name|num_units
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|resources_available
parameter_list|(
name|resource_table
modifier|*
name|rt
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|uses
init|=
call|(
name|rt
operator|->
name|opcode_num_units
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_funcUnit
name|unit
init|=
call|(
name|rt
operator|->
name|opcode_unit_use
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|stage
init|=
call|(
name|rt
operator|->
name|opcode_unit_stage
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|copies_in_use
init|=
name|rt
operator|->
name|units
index|[
name|stage
operator|+
name|cycle
index|]
index|[
name|unit
index|]
decl_stmt|;
name|int
name|copies
init|=
call|(
name|rt
operator|->
name|unit_num_copies
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|copies_in_use
operator|>=
name|copies
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|reserve_resources
parameter_list|(
name|resource_table
modifier|*
name|rt
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|uses
init|=
call|(
name|rt
operator|->
name|opcode_num_units
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_funcUnit
name|unit
init|=
call|(
name|rt
operator|->
name|opcode_unit_use
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|stage
init|=
call|(
name|rt
operator|->
name|opcode_unit_stage
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Note that this allows resources to be oversubscribed.  That's 	 essential to the way the optional scheduler works. 	 resources_available reports when a resource is over-subscribed, 	 so it's easy to tell.  */
name|rt
operator|->
name|units
index|[
name|stage
operator|+
name|cycle
index|]
index|[
name|unit
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|release_resources
parameter_list|(
name|resource_table
modifier|*
name|rt
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|uses
init|=
call|(
name|rt
operator|->
name|opcode_num_units
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_funcUnit
name|unit
init|=
call|(
name|rt
operator|->
name|opcode_unit_use
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|stage
init|=
call|(
name|rt
operator|->
name|opcode_unit_stage
call|)
argument_list|(
name|rt
operator|->
name|data
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|rt
operator|->
name|units
index|[
name|stage
operator|+
name|cycle
index|]
index|[
name|unit
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|->
name|units
index|[
name|stage
operator|+
name|cycle
index|]
index|[
name|unit
index|]
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wrapper functions make parameterized resource reservation    more convenient.  */
end_comment

begin_function
name|int
name|opcode_funcUnit_use_unit
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|xtensa_funcUnit_use
modifier|*
name|use
init|=
name|xtensa_opcode_funcUnit_use
argument_list|(
name|data
argument_list|,
name|opcode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
return|return
name|use
operator|->
name|unit
return|;
block|}
end_function

begin_function
name|int
name|opcode_funcUnit_use_stage
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|xtensa_funcUnit_use
modifier|*
name|use
init|=
name|xtensa_opcode_funcUnit_use
argument_list|(
name|data
argument_list|,
name|opcode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
return|return
name|use
operator|->
name|stage
return|;
block|}
end_function

begin_comment
comment|/* Note that this function does not check issue constraints, but    solely whether the hardware is available to execute the given    instructions together.  It also doesn't check if the tinsns    write the same state, or access the same tieports.  That is    checked by check_t1_t2_reads_and_writes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|resources_conflict
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|resource_table
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
comment|/* This is the most common case by far.  Optimize it.  */
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|rt
operator|=
name|new_resource_table
argument_list|(
name|isa
argument_list|,
name|xtensa_isa_num_pipe_stages
argument_list|(
name|isa
argument_list|)
argument_list|,
name|xtensa_isa_num_funcUnits
argument_list|(
name|isa
argument_list|)
argument_list|,
operator|(
name|unit_num_copies_func
operator|)
name|xtensa_funcUnit_num_copies
argument_list|,
operator|(
name|opcode_num_units_func
operator|)
name|xtensa_opcode_num_funcUnit_uses
argument_list|,
name|opcode_funcUnit_use_unit
argument_list|,
name|opcode_funcUnit_use_stage
argument_list|)
expr_stmt|;
block|}
name|clear_resource_table
argument_list|(
name|rt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|resources_available
argument_list|(
name|rt
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|reserve_resources
argument_list|(
name|rt
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* finish_vinsn, emit_single_op and helper functions.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|find_vinsn_conflicts
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_format
name|xg_find_narrowest_format
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xg_assemble_vliw_tokens
parameter_list|(
name|vliw_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We have reached the end of a bundle; emit into the frag.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vinsn
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
name|IStack
name|slotstack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
if|if
condition|(
name|find_vinsn_conflicts
argument_list|(
name|vinsn
argument_list|)
condition|)
block|{
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First, find a format that works.  */
if|if
condition|(
name|vinsn
operator|->
name|format
operator|==
name|XTENSA_UNDEFINED
condition|)
name|vinsn
operator|->
name|format
operator|=
name|xg_find_narrowest_format
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|format
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"couldn't find a valid instruction format"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    ops were: "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" %s;"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|!=
name|xtensa_format_num_slots
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"format '%s' allows %d slots, but there are %d opcodes"
argument_list|)
argument_list|,
name|xtensa_format_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|)
argument_list|,
name|xtensa_format_num_slots
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|)
argument_list|,
name|vinsn
operator|->
name|num_slots
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|resources_conflict
argument_list|(
name|vinsn
argument_list|)
condition|)
block|{
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"illegal resource usage in bundle"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    ops were: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s;"
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
name|XTENSA_UNDEFINED
condition|)
block|{
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bfd_boolean
name|e
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|saved_density
init|=
name|density_supported
decl_stmt|;
comment|/* We don't want to narrow ops inside multi-slot bundles.  */
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|>
literal|1
condition|)
name|density_supported
operator|=
name|FALSE
expr_stmt|;
name|istack_init
argument_list|(
operator|&
name|slotstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|==
name|xtensa_nop_opcode
condition|)
block|{
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xg_expand_assembly_insn
argument_list|(
operator|&
name|slotstack
argument_list|,
operator|&
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|e
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|density_supported
operator|=
name|saved_density
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|slotstack
operator|.
name|ninsn
condition|;
name|j
operator|++
control|)
block|{
name|TInsn
modifier|*
name|insn
init|=
operator|&
name|slotstack
operator|.
name|insn
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
condition|)
block|{
name|assert
argument_list|(
name|lit_sym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lit_sym
operator|=
name|xg_assemble_literal
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lit_sym
condition|)
name|xg_resolve_literals
argument_list|(
name|insn
argument_list|,
name|lit_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|slotstack
operator|.
name|ninsn
operator|-
literal|1
condition|)
name|emit_single_op
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|opcode_fits_format_slot
argument_list|(
name|slotstack
operator|.
name|insn
index|[
name|slotstack
operator|.
name|ninsn
operator|-
literal|1
index|]
operator|.
name|opcode
argument_list|,
name|vinsn
operator|->
name|format
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|=
name|slotstack
operator|.
name|insn
index|[
name|slotstack
operator|.
name|ninsn
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|emit_single_op
argument_list|(
operator|&
name|slotstack
operator|.
name|insn
index|[
name|slotstack
operator|.
name|ninsn
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|format
operator|==
name|XTENSA_UNDEFINED
condition|)
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|xtensa_nop_opcode
expr_stmt|;
else|else
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|=
name|slotstack
operator|.
name|insn
index|[
name|slotstack
operator|.
name|ninsn
operator|-
literal|1
index|]
expr_stmt|;
name|vinsn
operator|->
name|format
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
block|}
block|}
comment|/* Now check resource conflicts on the modified bundle.  */
if|if
condition|(
name|resources_conflict
argument_list|(
name|vinsn
argument_list|)
condition|)
block|{
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"illegal resource usage in bundle"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    ops were: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s;"
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First, find a format that works.  */
if|if
condition|(
name|vinsn
operator|->
name|format
operator|==
name|XTENSA_UNDEFINED
condition|)
name|vinsn
operator|->
name|format
operator|=
name|xg_find_narrowest_format
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
name|xg_assemble_vliw_tokens
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
name|vinsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an vliw instruction, what conflicts are there in register    usage and in writes to states and queues?     This function does two things:    1. Reports an error when a vinsn contains illegal combinations       of writes to registers states or queues.    2. Marks individual tinsns as not relaxable if the combination       contains antidependencies.     Job 2 handles things like swap semantics in instructions that need    to be relaxed.  For example,  	addi a0, a1, 100000     normally would be relaxed to  	l32r a0, some_label 	add a0, a1, a0     _but_, if the above instruction is bundled with an a0 reader, e.g.,  	{ addi a0, a1, 10000 ; add a2, a0, a4 ; }     then we can't relax it into  	l32r a0, some_label 	{ add a0, a1, a0 ; add a2, a0, a4 ; }     because the value of a0 is trashed before the second add can read it.  */
end_comment

begin_function_decl
specifier|static
name|char
name|check_t1_t2_reads_and_writes
parameter_list|(
name|TInsn
modifier|*
parameter_list|,
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bfd_boolean
name|find_vinsn_conflicts
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|branches
init|=
literal|0
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|assert
argument_list|(
operator|!
name|past_xtensa_end
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|op1
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op1
operator|->
name|is_specific_opcode
condition|)
name|op1
operator|->
name|keep_wide
operator|=
name|TRUE
expr_stmt|;
else|else
name|op1
operator|->
name|keep_wide
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|op1
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|op1
operator|->
name|opcode
argument_list|)
operator|==
literal|1
condition|)
name|branches
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|TInsn
modifier|*
name|op2
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|j
index|]
decl_stmt|;
name|char
name|conflict_type
init|=
name|check_t1_t2_reads_and_writes
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|conflict_type
condition|)
block|{
case|case
literal|'c'
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcodes '%s' (slot %d) and '%s' (slot %d) write the same register"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op1
operator|->
name|opcode
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op2
operator|->
name|opcode
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'d'
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcodes '%s' (slot %d) and '%s' (slot %d) write the same state"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op1
operator|->
name|opcode
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op2
operator|->
name|opcode
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'e'
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcodes '%s' (slot %d) and '%s' (slot %d) write the same port"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op1
operator|->
name|opcode
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op2
operator|->
name|opcode
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'f'
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcodes '%s' (slot %d) and '%s' (slot %d) both have volatile port accesses"
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op1
operator|->
name|opcode
argument_list|)
argument_list|,
name|i
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|op2
operator|->
name|opcode
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
default|default:
comment|/* Everything is OK.  */
break|break;
block|}
name|op2
operator|->
name|is_specific_opcode
operator|=
operator|(
name|op2
operator|->
name|is_specific_opcode
operator|||
name|conflict_type
operator|==
literal|'a'
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|branches
operator|>
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple branches or jumps in the same bundle"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check how the state used by t1 and t2 relate.    Cases found are:     case A: t1 reads a register t2 writes (an antidependency within a bundle)    case B: no relationship between what is read and written (both could            read the same reg though)    case C: t1 writes a register t2 writes (a register conflict within a            bundle)    case D: t1 writes a state that t2 also writes    case E: t1 writes a tie queue that t2 also writes    case F: two volatile queue accesses */
end_comment

begin_function
specifier|static
name|char
name|check_t1_t2_reads_and_writes
parameter_list|(
name|TInsn
modifier|*
name|t1
parameter_list|,
name|TInsn
modifier|*
name|t2
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_regfile
name|t1_regfile
decl_stmt|,
name|t2_regfile
decl_stmt|;
name|int
name|t1_reg
decl_stmt|,
name|t2_reg
decl_stmt|;
name|int
name|t1_base_reg
decl_stmt|,
name|t1_last_reg
decl_stmt|;
name|int
name|t2_base_reg
decl_stmt|,
name|t2_last_reg
decl_stmt|;
name|char
name|t1_inout
decl_stmt|,
name|t2_inout
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|conflict
init|=
literal|'b'
decl_stmt|;
name|int
name|t1_states
decl_stmt|;
name|int
name|t2_states
decl_stmt|;
name|int
name|t1_interfaces
decl_stmt|;
name|int
name|t2_interfaces
decl_stmt|;
name|bfd_boolean
name|t1_volatile
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|t2_volatile
init|=
name|FALSE
decl_stmt|;
comment|/* Check registers.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t2
operator|->
name|ntok
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|t2_regfile
operator|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|t2_base_reg
operator|=
name|t2
operator|->
name|tok
index|[
name|j
index|]
operator|.
name|X_add_number
expr_stmt|;
name|t2_last_reg
operator|=
name|t2_base_reg
operator|+
name|xtensa_operand_num_regs
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t1
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|t1_regfile
operator|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1_regfile
operator|!=
name|t2_regfile
condition|)
continue|continue;
name|t1_inout
operator|=
name|xtensa_operand_inout
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t2_inout
operator|=
name|xtensa_operand_inout
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_operand_is_known_reg
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|0
operator|||
name|xtensa_operand_is_known_reg
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t1_inout
operator|==
literal|'m'
operator|||
name|t1_inout
operator|==
literal|'o'
operator|||
name|t2_inout
operator|==
literal|'m'
operator|||
name|t2_inout
operator|==
literal|'o'
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
block|}
name|t1_base_reg
operator|=
name|t1
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_add_number
expr_stmt|;
name|t1_last_reg
operator|=
operator|(
name|t1_base_reg
operator|+
name|xtensa_operand_num_regs
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|t1_reg
operator|=
name|t1_base_reg
init|;
name|t1_reg
operator|<
name|t1_last_reg
condition|;
name|t1_reg
operator|++
control|)
block|{
for|for
control|(
name|t2_reg
operator|=
name|t2_base_reg
init|;
name|t2_reg
operator|<
name|t2_last_reg
condition|;
name|t2_reg
operator|++
control|)
block|{
if|if
condition|(
name|t1_reg
operator|!=
name|t2_reg
condition|)
continue|continue;
if|if
condition|(
name|t2_inout
operator|==
literal|'i'
operator|&&
operator|(
name|t1_inout
operator|==
literal|'m'
operator|||
name|t1_inout
operator|==
literal|'o'
operator|)
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|==
literal|'i'
operator|&&
operator|(
name|t2_inout
operator|==
literal|'m'
operator|||
name|t2_inout
operator|==
literal|'o'
operator|)
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|!=
literal|'i'
operator|&&
name|t2_inout
operator|!=
literal|'i'
condition|)
return|return
literal|'c'
return|;
block|}
block|}
block|}
block|}
comment|/* Check states.  */
name|t1_states
operator|=
name|xtensa_opcode_num_stateOperands
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|t2_states
operator|=
name|xtensa_opcode_num_stateOperands
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t2_states
condition|;
name|j
operator|++
control|)
block|{
name|xtensa_state
name|t2_so
init|=
name|xtensa_stateOperand_state
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|t2_inout
operator|=
name|xtensa_stateOperand_inout
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t1_states
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_state
name|t1_so
init|=
name|xtensa_stateOperand_state
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|t1_inout
operator|=
name|xtensa_stateOperand_inout
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1_so
operator|!=
name|t2_so
condition|)
continue|continue;
if|if
condition|(
name|t2_inout
operator|==
literal|'i'
operator|&&
operator|(
name|t1_inout
operator|==
literal|'m'
operator|||
name|t1_inout
operator|==
literal|'o'
operator|)
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|==
literal|'i'
operator|&&
operator|(
name|t2_inout
operator|==
literal|'m'
operator|||
name|t2_inout
operator|==
literal|'o'
operator|)
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|!=
literal|'i'
operator|&&
name|t2_inout
operator|!=
literal|'i'
condition|)
return|return
literal|'d'
return|;
block|}
block|}
comment|/* Check tieports.  */
name|t1_interfaces
operator|=
name|xtensa_opcode_num_interfaceOperands
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|t2_interfaces
operator|=
name|xtensa_opcode_num_interfaceOperands
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t2_interfaces
condition|;
name|j
operator|++
control|)
block|{
name|xtensa_interface
name|t2_int
init|=
name|xtensa_interfaceOperand_interface
argument_list|(
name|isa
argument_list|,
name|t2
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|t2_class
init|=
name|xtensa_interface_class_id
argument_list|(
name|isa
argument_list|,
name|t2_int
argument_list|)
decl_stmt|;
name|t2_inout
operator|=
name|xtensa_interface_inout
argument_list|(
name|isa
argument_list|,
name|t2_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_interface_has_side_effect
argument_list|(
name|isa
argument_list|,
name|t2_int
argument_list|)
operator|==
literal|1
condition|)
name|t2_volatile
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t1_interfaces
condition|;
name|i
operator|++
control|)
block|{
name|xtensa_interface
name|t1_int
init|=
name|xtensa_interfaceOperand_interface
argument_list|(
name|isa
argument_list|,
name|t1
operator|->
name|opcode
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|t1_class
init|=
name|xtensa_interface_class_id
argument_list|(
name|isa
argument_list|,
name|t1_int
argument_list|)
decl_stmt|;
name|t1_inout
operator|=
name|xtensa_interface_inout
argument_list|(
name|isa
argument_list|,
name|t1_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_interface_has_side_effect
argument_list|(
name|isa
argument_list|,
name|t1_int
argument_list|)
operator|==
literal|1
condition|)
name|t1_volatile
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|t1_volatile
operator|&&
name|t2_volatile
operator|&&
operator|(
name|t1_class
operator|==
name|t2_class
operator|)
condition|)
return|return
literal|'f'
return|;
if|if
condition|(
name|t1_int
operator|!=
name|t2_int
condition|)
continue|continue;
if|if
condition|(
name|t2_inout
operator|==
literal|'i'
operator|&&
name|t1_inout
operator|==
literal|'o'
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|==
literal|'i'
operator|&&
name|t2_inout
operator|==
literal|'o'
condition|)
block|{
name|conflict
operator|=
literal|'a'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t1_inout
operator|!=
literal|'i'
operator|&&
name|t2_inout
operator|!=
literal|'i'
condition|)
return|return
literal|'e'
return|;
block|}
block|}
return|return
name|conflict
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_format
name|xg_find_narrowest_format
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
comment|/* Right now we assume that the ops within the vinsn are properly      ordered for the slots that the programmer wanted them in.  In      other words, we don't rearrange the ops in hopes of finding a      better format.  The scheduler handles that.  */
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|format
decl_stmt|;
name|vliw_insn
name|v_copy
init|=
operator|*
name|vinsn
decl_stmt|;
name|xtensa_opcode
name|nop_opcode
init|=
name|xtensa_nop_opcode
decl_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
condition|)
return|return
name|xg_get_single_format
argument_list|(
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
return|;
for|for
control|(
name|format
operator|=
literal|0
init|;
name|format
operator|<
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
condition|;
name|format
operator|++
control|)
block|{
name|v_copy
operator|=
operator|*
name|vinsn
expr_stmt|;
if|if
condition|(
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|format
argument_list|)
operator|==
name|v_copy
operator|.
name|num_slots
condition|)
block|{
name|int
name|slot
decl_stmt|;
name|int
name|fit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|v_copy
operator|.
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
operator|==
name|nop_opcode
condition|)
block|{
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|isa
argument_list|,
name|format
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|opcode_fits_format_slot
argument_list|(
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
argument_list|,
name|format
argument_list|,
name|slot
argument_list|)
condition|)
name|fit
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|v_copy
operator|.
name|num_slots
operator|>
literal|1
condition|)
block|{
name|TInsn
name|widened
decl_stmt|;
comment|/* Try the widened version.  */
if|if
condition|(
operator|!
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|keep_wide
operator|&&
operator|!
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|is_specific_opcode
operator|&&
name|xg_is_single_relaxable_insn
argument_list|(
operator|&
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
argument_list|,
operator|&
name|widened
argument_list|,
name|TRUE
argument_list|)
operator|&&
name|opcode_fits_format_slot
argument_list|(
name|widened
operator|.
name|opcode
argument_list|,
name|format
argument_list|,
name|slot
argument_list|)
condition|)
block|{
name|v_copy
operator|.
name|slots
index|[
name|slot
index|]
operator|=
name|widened
expr_stmt|;
name|fit
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fit
operator|==
name|v_copy
operator|.
name|num_slots
condition|)
block|{
operator|*
name|vinsn
operator|=
name|v_copy
expr_stmt|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|format
argument_list|,
name|vinsn
operator|->
name|insnbuf
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|format
operator|=
name|format
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|format
operator|==
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|format
return|;
block|}
end_function

begin_comment
comment|/* Return the additional space needed in a frag    for possible relaxations of any ops in a VLIW insn.    Also fill out the relaxations that might be required of    each tinsn in the vinsn.  */
end_comment

begin_function
specifier|static
name|int
name|relaxation_requirements
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|,
name|bfd_boolean
modifier|*
name|pfinish_frag
parameter_list|)
block|{
name|bfd_boolean
name|finish_frag
init|=
name|FALSE
decl_stmt|;
name|int
name|extra_space
init|=
literal|0
decl_stmt|;
name|int
name|slot
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tinsn_has_symbolic_operands
argument_list|(
name|tinsn
argument_list|)
condition|)
block|{
comment|/* A narrow instruction could be widened later to help 	     alignment issues.  */
if|if
condition|(
name|xg_is_single_relaxable_insn
argument_list|(
name|tinsn
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
operator|&&
operator|!
name|tinsn
operator|->
name|is_specific_opcode
operator|&&
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
condition|)
block|{
comment|/* Difference in bytes between narrow and wide insns...  */
name|extra_space
operator|+=
literal|1
expr_stmt|;
name|tinsn
operator|->
name|subtype
operator|=
name|RELAX_NARROW
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|workaround_b_j_loop_end
operator|&&
name|tinsn
operator|->
name|opcode
operator|==
name|xtensa_jx_opcode
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
comment|/* Add 2 of these.  */
name|extra_space
operator|+=
literal|3
expr_stmt|;
comment|/* for the nop size */
name|tinsn
operator|->
name|subtype
operator|=
name|RELAX_ADD_NOP_IF_PRE_LOOP_END
expr_stmt|;
block|}
comment|/* Need to assemble it with space for the relocation.  */
if|if
condition|(
name|xg_is_relaxable_insn
argument_list|(
name|tinsn
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|tinsn
operator|->
name|is_specific_opcode
condition|)
block|{
name|int
name|max_size
init|=
name|xg_get_max_insn_widen_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|int
name|max_literal_size
init|=
name|xg_get_max_insn_widen_literal_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
decl_stmt|;
name|tinsn
operator|->
name|literal_space
operator|=
name|max_literal_size
expr_stmt|;
name|tinsn
operator|->
name|subtype
operator|=
name|RELAX_IMMED
expr_stmt|;
name|extra_space
operator|+=
name|max_size
expr_stmt|;
block|}
else|else
block|{
comment|/* A fix record will be added for this instruction prior 		 to relaxation, so make it end the frag.  */
name|finish_frag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pfinish_frag
operator|=
name|finish_frag
expr_stmt|;
return|return
name|extra_space
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_tinsn
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|chosen_slot
decl_stmt|;
name|vinsn
operator|->
name|format
operator|=
name|xg_get_single_format
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|vinsn
operator|->
name|format
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|num_slots
operator|=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|)
expr_stmt|;
name|chosen_slot
operator|=
name|xg_get_single_slot
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|slot
operator|==
name|chosen_slot
condition|)
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
operator|=
operator|*
name|tinsn
expr_stmt|;
else|else
block|{
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
operator|.
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|emit_single_op
parameter_list|(
name|TInsn
modifier|*
name|orig_insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|IStack
name|istack
decl_stmt|;
comment|/* put instructions into here */
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|label_sym
init|=
name|NULL
decl_stmt|;
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
comment|/* Special-case for "movi aX, foo" which is guaranteed to need relaxing.      Because the scheduling and bundling characteristics of movi and      l32r or const16 are so different, we can do much better if we relax      it prior to scheduling and bundling, rather than after.  */
if|if
condition|(
operator|(
name|orig_insn
operator|->
name|opcode
operator|==
name|xtensa_movi_opcode
operator|||
name|orig_insn
operator|->
name|opcode
operator|==
name|xtensa_movi_n_opcode
operator|)
operator|&&
operator|!
name|cur_vinsn
operator|.
name|inside_bundle
operator|&&
operator|(
name|orig_insn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_symbol
operator|||
name|orig_insn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_pltrel
operator|)
operator|&&
operator|!
name|orig_insn
operator|->
name|is_specific_opcode
operator|&&
name|use_transform
argument_list|()
condition|)
name|xg_assembly_relax
argument_list|(
operator|&
name|istack
argument_list|,
name|orig_insn
argument_list|,
name|now_seg
argument_list|,
name|frag_now
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xg_expand_assembly_insn
argument_list|(
operator|&
name|istack
argument_list|,
name|orig_insn
argument_list|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|insn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|insn_type
condition|)
block|{
case|case
name|ITYPE_LITERAL
case|:
name|assert
argument_list|(
name|lit_sym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lit_sym
operator|=
name|xg_assemble_literal
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITYPE_LABEL
case|:
block|{
specifier|static
name|int
name|relaxed_sym_idx
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|FAKE_LABEL_NAME
argument_list|)
operator|+
literal|12
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"%s_rl_%x"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|relaxed_sym_idx
operator|++
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|label_sym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|label_sym
operator|=
name|symbol_find_or_make
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|label_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ITYPE_INSN
case|:
block|{
name|vliw_insn
name|v
decl_stmt|;
if|if
condition|(
name|lit_sym
condition|)
name|xg_resolve_literals
argument_list|(
name|insn
argument_list|,
name|lit_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_sym
condition|)
name|xg_resolve_labels
argument_list|(
name|insn
argument_list|,
name|label_sym
argument_list|)
expr_stmt|;
name|xg_init_vinsn
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|bundle_tinsn
argument_list|(
name|insn
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|finish_vinsn
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|xg_free_vinsn
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|total_frag_text_expansion
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|int
name|slot
decl_stmt|;
name|int
name|total_expansion
init|=
literal|0
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAX_SLOTS
condition|;
name|slot
operator|++
control|)
name|total_expansion
operator|+=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
name|slot
index|]
expr_stmt|;
return|return
name|total_expansion
return|;
block|}
end_function

begin_comment
comment|/* Emit a vliw instruction to the current fragment.  */
end_comment

begin_function
specifier|static
name|void
name|xg_assemble_vliw_tokens
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|)
block|{
name|bfd_boolean
name|finish_frag
decl_stmt|;
name|bfd_boolean
name|is_jump
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|is_branch
init|=
name|FALSE
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
name|int
name|extra_space
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|unsigned
name|current_line
decl_stmt|,
name|best_linenum
decl_stmt|;
name|char
modifier|*
name|current_file
decl_stmt|;
name|best_linenum
operator|=
name|UINT_MAX
expr_stmt|;
if|if
condition|(
name|generating_literals
condition|)
block|{
specifier|static
name|int
name|reported
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reported
operator|<
literal|4
condition|)
name|as_bad_where
argument_list|(
name|frag_now
operator|->
name|fr_file
argument_list|,
name|frag_now
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"cannot assemble into a literal fragment"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reported
operator|==
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"..."
argument_list|)
argument_list|)
expr_stmt|;
name|reported
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frag_now_fix
argument_list|()
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|||
operator|(
name|vinsn_has_specific_opcodes
argument_list|(
name|vinsn
argument_list|)
operator|&&
name|use_transform
argument_list|()
operator|)
operator|||
operator|!
name|use_transform
argument_list|()
operator|!=
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
operator|||
operator|(
name|directive_state
index|[
name|directive_longcalls
index|]
operator|!=
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|use_longcalls
operator|)
operator|||
operator|(
name|directive_state
index|[
name|directive_absolute_literals
index|]
operator|!=
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
operator|)
operator|)
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|workaround_a0_b_retw
operator|&&
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
operator|&&
operator|(
name|get_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
operator|&
name|FLAG_IS_A0_WRITER
operator|)
operator|!=
literal|0
operator|&&
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
name|has_a0_b_retw
operator|=
name|TRUE
expr_stmt|;
comment|/* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW. 	 After the first assembly pass we will check all of them and 	 add a nop if needed.  */
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_A0_B_RETW
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_A0_B_RETW
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
comment|/* See if the instruction implies an aligned section.  */
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Also determine the best line number for debug info.  */
name|best_linenum
operator|=
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|linenum
operator|<
name|best_linenum
condition|?
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|linenum
else|:
name|best_linenum
expr_stmt|;
block|}
comment|/* Special cases for instructions that force an alignment... */
comment|/* None of these opcodes are bundle-able.  */
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|int
name|max_fill
decl_stmt|;
comment|/* Remember the symbol that marks the end of the loop in the frag 	 that marks the start of the loop.  This way we can easily find 	 the end of the loop at the beginning, without adding special code 	 to mark the loop instructions themselves.  */
name|symbolS
modifier|*
name|target_sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|target_sym
operator|=
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_symbol
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|max_fill
operator|=
name|get_text_align_max_fill_size
argument_list|(
name|get_text_align_power
argument_list|(
name|xtensa_fetch_width
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_no_density
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_transform
argument_list|()
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_fill
argument_list|,
name|max_fill
argument_list|,
name|RELAX_ALIGN_NEXT_OPCODE
argument_list|,
name|target_sym
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_CHECK_ALIGN_NEXT_OPCODE
argument_list|,
name|target_sym
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|xtensa_entry_opcode
operator|&&
operator|!
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|is_specific_opcode
condition|)
block|{
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
name|xtensa_move_labels
argument_list|(
name|frag_now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_align_test
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|workaround_a0_b_retw
operator|&&
name|use_transform
argument_list|()
condition|)
name|set_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|FLAG_IS_A0_WRITER
argument_list|,
name|is_register_writer
argument_list|(
operator|&
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
argument_list|,
literal|"a"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|FLAG_IS_BAD_LOOPEND
argument_list|,
name|is_bad_loopend_opcode
argument_list|(
operator|&
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|set_last_insn_flags
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|,
name|FLAG_IS_BAD_LOOPEND
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|insn_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|format
argument_list|)
expr_stmt|;
name|extra_space
operator|=
name|relaxation_requirements
argument_list|(
name|vinsn
argument_list|,
operator|&
name|finish_frag
argument_list|)
expr_stmt|;
comment|/* vinsn_to_insnbuf will produce the error.  */
if|if
condition|(
name|vinsn
operator|->
name|format
operator|!=
name|XTENSA_UNDEFINED
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
name|insn_size
operator|+
name|extra_space
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
block|}
name|vinsn_to_insnbuf
argument_list|(
name|vinsn
argument_list|,
name|f
argument_list|,
name|frag_now
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinsn
operator|->
name|format
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Temporarily set the logical line number to the one we want to appear      in the debug information.  */
name|as_where
argument_list|(
operator|&
name|current_file
argument_list|,
operator|&
name|current_line
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|current_file
argument_list|,
name|best_linenum
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|insn_size
operator|+
name|extra_space
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|current_file
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
decl_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
operator|=
name|tinsn
operator|->
name|subtype
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|slot_symbols
index|[
name|slot
index|]
operator|=
name|tinsn
operator|->
name|symbol
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|slot_offsets
index|[
name|slot
index|]
operator|=
name|tinsn
operator|->
name|offset
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frags
index|[
name|slot
index|]
operator|=
name|tinsn
operator|->
name|literal_frag
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|literal_space
operator|!=
literal|0
condition|)
name|xg_assemble_literal_space
argument_list|(
name|tinsn
operator|->
name|literal_space
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|subtype
operator|==
name|RELAX_NARROW
condition|)
name|assert
argument_list|(
name|vinsn
operator|->
name|num_slots
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_is_jump
argument_list|(
name|isa
argument_list|,
name|tinsn
operator|->
name|opcode
argument_list|)
operator|==
literal|1
condition|)
name|is_jump
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|tinsn
operator|->
name|opcode
argument_list|)
operator|==
literal|1
condition|)
name|is_branch
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|subtype
operator|||
name|tinsn
operator|->
name|symbol
operator|||
name|tinsn
operator|->
name|offset
operator|||
name|tinsn
operator|->
name|literal_frag
operator|||
name|is_jump
operator|||
name|is_branch
condition|)
name|finish_frag
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vinsn_has_specific_opcodes
argument_list|(
name|vinsn
argument_list|)
operator|&&
name|use_transform
argument_list|()
condition|)
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_specific_opcode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|finish_frag
condition|)
block|{
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
name|extra_space
argument_list|,
name|extra_space
argument_list|,
name|RELAX_SLOTS
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
comment|/* Special cases for loops:      close_loop_end should be inserted AFTER short_loop.      Make sure that CLOSE loops are processed BEFORE short_loops      when converting them.  */
comment|/* "short_loop": Add a NOP if the loop is< 4 bytes.  */
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|is_specific_opcode
condition|)
block|{
if|if
condition|(
name|workaround_short_loop
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
name|maybe_has_short_loop
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_SHORT_LOOP
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|RELAX_ADD_NOP_IF_SHORT_LOOP
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* "close_loop_end": Add up to 12 bytes of NOPs to keep a 	 loop at least 12 bytes away from another loop's end.  */
if|if
condition|(
name|workaround_close_loop_end
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
name|maybe_has_close_loop_end
operator|=
name|TRUE
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|12
argument_list|,
literal|12
argument_list|,
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_transform
argument_list|()
condition|)
block|{
if|if
condition|(
name|is_jump
condition|)
block|{
name|assert
argument_list|(
name|finish_frag
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|UNREACHABLE_MAX_WIDTH
argument_list|,
name|UNREACHABLE_MAX_WIDTH
argument_list|,
name|RELAX_UNREACHABLE
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_branch
operator|&&
name|do_align_targets
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|finish_frag
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|UNREACHABLE_MAX_WIDTH
argument_list|,
name|UNREACHABLE_MAX_WIDTH
argument_list|,
name|RELAX_MAYBE_UNREACHABLE
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_MAYBE_DESIRE_ALIGN
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, if the original opcode was a call...  */
if|if
condition|(
name|do_align_targets
argument_list|()
operator|&&
name|xtensa_opcode_is_call
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|->
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|float
name|freq
init|=
name|get_subseg_total_freq
argument_list|(
name|now_seg
argument_list|,
name|now_subseg
argument_list|)
decl_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
operator|(
name|int
operator|)
name|freq
argument_list|,
name|RELAX_DESIRE_ALIGN
argument_list|,
name|frag_now
operator|->
name|fr_symbol
argument_list|,
name|frag_now
operator|->
name|fr_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vinsn_has_specific_opcodes
argument_list|(
name|vinsn
argument_list|)
operator|&&
name|use_transform
argument_list|()
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* xtensa_end and helper functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xtensa_cleanup_align_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_fix_target_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_mark_narrow_branches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_mark_zcl_first_insns
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_fix_a0_b_retw_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_fix_b_j_loop_end_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_fix_close_loop_end_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_fix_short_loop_frags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_sanity_check
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_add_config_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|xtensa_end
parameter_list|(
name|void
parameter_list|)
block|{
name|directive_balance
argument_list|()
expr_stmt|;
name|xtensa_flush_pending_output
argument_list|()
expr_stmt|;
name|past_xtensa_end
operator|=
name|TRUE
expr_stmt|;
name|xtensa_move_literals
argument_list|()
expr_stmt|;
name|xtensa_reorder_segments
argument_list|()
expr_stmt|;
name|xtensa_cleanup_align_frags
argument_list|()
expr_stmt|;
name|xtensa_fix_target_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|workaround_a0_b_retw
operator|&&
name|has_a0_b_retw
condition|)
name|xtensa_fix_a0_b_retw_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|workaround_b_j_loop_end
condition|)
name|xtensa_fix_b_j_loop_end_frags
argument_list|()
expr_stmt|;
comment|/* "close_loop_end" should be processed BEFORE "short_loop".  */
if|if
condition|(
name|workaround_close_loop_end
operator|&&
name|maybe_has_close_loop_end
condition|)
name|xtensa_fix_close_loop_end_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|workaround_short_loop
operator|&&
name|maybe_has_short_loop
condition|)
name|xtensa_fix_short_loop_frags
argument_list|()
expr_stmt|;
if|if
condition|(
name|align_targets
condition|)
name|xtensa_mark_narrow_branches
argument_list|()
expr_stmt|;
name|xtensa_mark_zcl_first_insns
argument_list|()
expr_stmt|;
name|xtensa_sanity_check
argument_list|()
expr_stmt|;
name|xtensa_add_config_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_cleanup_align_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|||
operator|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
operator|)
operator|)
operator|)
operator|&&
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
block|{
name|fragS
modifier|*
name|next
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|fr_fix
operator|==
literal|0
operator|&&
name|next
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|next
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
condition|)
block|{
name|frag_wane
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
comment|/* If we don't widen branch targets, then they 	       will be easier to align.  */
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
operator|&&
name|fragP
operator|->
name|fr_opcode
operator|==
name|fragP
operator|->
name|fr_literal
operator|&&
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
condition|)
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
condition|)
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_unreachable
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_DESIRE_ALIGN_IF_TARGET fragments.  If there is a branch    target in the next fragment, convert this to RELAX_DESIRE_ALIGN.    Otherwise, convert to a .fill 0.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_fix_target_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_DESIRE_ALIGN_IF_TARGET
condition|)
block|{
if|if
condition|(
name|next_frag_is_branch_target
argument_list|(
name|fragP
argument_list|)
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_DESIRE_ALIGN
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|bfd_boolean
name|is_narrow_branch_guaranteed_in_range
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_mark_narrow_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_IMMED
condition|)
block|{
name|vliw_insn
name|vinsn
decl_stmt|;
name|vinsn_from_chars
argument_list|(
operator|&
name|vinsn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|vinsn
operator|.
name|slots
index|[
literal|0
index|]
argument_list|,
name|fragP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinsn
operator|.
name|num_slots
operator|==
literal|1
operator|&&
name|xtensa_opcode_is_branch
argument_list|(
name|xtensa_default_isa
argument_list|,
name|vinsn
operator|.
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|1
operator|&&
name|xg_get_single_size
argument_list|(
name|vinsn
operator|.
name|slots
index|[
literal|0
index|]
operator|.
name|opcode
argument_list|)
operator|==
literal|2
operator|&&
name|is_narrow_branch_guaranteed_in_range
argument_list|(
name|fragP
argument_list|,
operator|&
name|vinsn
operator|.
name|slots
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_SLOTS
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|=
name|RELAX_NARROW
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_aligning_branch
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* A branch is typically widened only when its target is out of    range.  However, we would like to widen them to align a subsequent    branch target when possible.     Because the branch relaxation code is so convoluted, the optimal solution    (combining the two cases) is difficult to get right in all circumstances.    We therefore go with an "almost as good" solution, where we only    use for alignment narrow branches that definitely will not expand to a    jump and a branch.  These functions find and mark these cases.  */
end_comment

begin_comment
comment|/* The range in bytes of BNEZ.N and BEQZ.N.  The target operand is encoded    as PC + 4 + imm6, where imm6 is a 6-bit immediate ranging from 0 to 63.    We start counting beginning with the frag after the 2-byte branch, so the    maximum offset is (4 - 2) + 63 = 65.  */
end_comment

begin_define
define|#
directive|define
name|MAX_IMMED6
value|65
end_define

begin_function_decl
specifier|static
name|offsetT
name|unrelaxed_frag_max_size
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bfd_boolean
name|is_narrow_branch_guaranteed_in_range
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|TInsn
modifier|*
name|tinsn
parameter_list|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
name|expr
operator|->
name|X_add_symbol
decl_stmt|;
name|offsetT
name|max_distance
init|=
name|expr
operator|->
name|X_add_number
decl_stmt|;
name|fragS
modifier|*
name|target_frag
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|target_frag
operator|=
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|max_distance
operator|+=
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|target_frag
operator|->
name|fr_address
operator|)
expr_stmt|;
if|if
condition|(
name|is_branch_jmp_to_next
argument_list|(
name|tinsn
argument_list|,
name|fragP
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The branch doesn't branch over it's own frag,      but over the subsequent ones.  */
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
while|while
condition|(
name|fragP
operator|!=
name|NULL
operator|&&
name|fragP
operator|!=
name|target_frag
operator|&&
name|max_distance
operator|<=
name|MAX_IMMED6
condition|)
block|{
name|max_distance
operator|+=
name|unrelaxed_frag_max_size
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|max_distance
operator|<=
name|MAX_IMMED6
operator|&&
name|fragP
operator|==
name|target_frag
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_mark_zcl_first_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_CHECK_ALIGN_NEXT_OPCODE
operator|)
condition|)
block|{
comment|/* Find the loop frag.  */
name|fragS
modifier|*
name|targ_frag
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
comment|/* Find the first insn frag.  */
name|targ_frag
operator|=
name|next_non_empty_frag
argument_list|(
name|targ_frag
argument_list|)
expr_stmt|;
comment|/* Of course, sometimes (mostly for toy test cases) a 		   zero-cost loop instruction is the last in a section.  */
if|if
condition|(
name|targ_frag
condition|)
block|{
name|targ_frag
operator|->
name|tc_frag_data
operator|.
name|is_first_loop_insn
operator|=
name|TRUE
expr_stmt|;
comment|/* Do not widen a frag that is the first instruction of a 		       zero-cost loop.  It makes that loop harder to align.  */
if|if
condition|(
name|targ_frag
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|targ_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
operator|(
name|targ_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
operator|)
condition|)
block|{
if|if
condition|(
name|targ_frag
operator|->
name|tc_frag_data
operator|.
name|is_aligning_branch
condition|)
name|targ_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|=
name|RELAX_IMMED
expr_stmt|;
else|else
block|{
name|frag_wane
argument_list|(
name|targ_frag
argument_list|)
expr_stmt|;
name|targ_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_CHECK_ALIGN_NEXT_OPCODE
condition|)
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_A0_B_RETW.  If the next instruction is a    conditional branch or a retw/retw.n, convert this frag to one that    will generate a NOP.  In any case close it off with a .fill 0.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|next_instrs_are_b_retw
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_fix_a0_b_retw_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_A0_B_RETW
condition|)
block|{
if|if
condition|(
name|next_instrs_are_b_retw
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"instruction sequence (write a0, branch, retw) may trigger hardware errata"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_instrs_are_b_retw
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
specifier|const
name|fragS
modifier|*
name|next_fragP
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|bfd_boolean
name|branch_seen
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check for the conditional branch.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|next_fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|branch_seen
operator|=
operator|(
name|branch_seen
operator|||
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|branch_seen
condition|)
return|return
name|FALSE
return|;
name|offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|next_fragP
operator|->
name|fr_fix
condition|)
block|{
name|next_fragP
operator|=
name|next_non_empty_frag
argument_list|(
name|next_fragP
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check for the retw/retw.n.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|next_fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
comment|/* Because RETW[.N] is not bundleable, a VLIW bundle here means that we      have no problems.  */
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_retw_opcode
operator|||
name|opcode
operator|==
name|xtensa_retw_n_opcode
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_PRE_LOOP_END.  If there is one instruction and a    loop end label, convert this frag to one that will generate a NOP.    In any case close it off with a .fill 0.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|next_instr_is_loop_end
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_fix_b_j_loop_end_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_PRE_LOOP_END
condition|)
block|{
if|if
condition|(
name|next_instr_is_loop_end
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branching or jumping to a loop end may trigger hardware errata"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|next_instr_is_loop_end
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|const
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|next_fragP
operator|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|next_frag_is_loop_target
argument_list|(
name|next_fragP
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the size is>= 3 then there is more than one instruction here.      The hardware bug will not fire.  */
if|if
condition|(
name|next_fragP
operator|->
name|fr_fix
operator|>
literal|3
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all of the    RELAX_ADD_NOP_IF_CLOSE_LOOP_END.  If there is an loop end that is    not MY loop's loop end within 12 bytes, add enough nops here to    make it at least 12 bytes away.  In any case close it off with a    .fill 0.  */
end_comment

begin_function_decl
specifier|static
name|offsetT
name|min_bytes_to_other_loop_end
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_fix_close_loop_end_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
name|current_target
init|=
name|NULL
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
operator|)
operator|||
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_CHECK_ALIGN_NEXT_OPCODE
operator|)
operator|)
condition|)
name|current_target
operator|=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_target
operator|&&
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
condition|)
block|{
name|offsetT
name|min_bytes
decl_stmt|;
name|int
name|bytes_added
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|REQUIRED_LOOP_DIVIDING_BYTES
value|12
comment|/* Max out at 12.  */
name|min_bytes
operator|=
name|min_bytes_to_other_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|current_target
argument_list|,
name|REQUIRED_LOOP_DIVIDING_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_bytes
operator|<
name|REQUIRED_LOOP_DIVIDING_BYTES
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"loop end too close to another loop end may trigger hardware errata"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|min_bytes
operator|+
name|bytes_added
operator|<
name|REQUIRED_LOOP_DIVIDING_BYTES
condition|)
block|{
name|int
name|length
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|<
name|length
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"fr_var %lu< length %d"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_var
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
name|assemble_nop
argument_list|(
name|length
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|length
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|length
expr_stmt|;
block|}
name|bytes_added
operator|+=
name|length
expr_stmt|;
block|}
block|}
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_machine_dependent
operator|||
name|fragP
operator|->
name|fr_subtype
operator|!=
name|RELAX_ADD_NOP_IF_CLOSE_LOOP_END
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|offsetT
name|unrelaxed_frag_min_size
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|offsetT
name|min_bytes_to_other_loop_end
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|fragS
modifier|*
name|current_target
parameter_list|,
name|offsetT
name|max_size
parameter_list|)
block|{
name|offsetT
name|offset
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|current_fragP
decl_stmt|;
for|for
control|(
name|current_fragP
operator|=
name|fragP
init|;
name|current_fragP
condition|;
name|current_fragP
operator|=
name|current_fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|current_fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
operator|&&
name|current_fragP
operator|!=
name|current_target
condition|)
return|return
name|offset
return|;
name|offset
operator|+=
name|unrelaxed_frag_min_size
argument_list|(
name|current_fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|max_size
condition|)
return|return
name|max_size
return|;
block|}
return|return
name|max_size
return|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|unrelaxed_frag_min_size
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|offsetT
name|size
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
comment|/* Add fill size.  */
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
condition|)
name|size
operator|+=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|offsetT
name|unrelaxed_frag_max_size
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|offsetT
name|size
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* Empty frags created by the obstack allocation scheme 	 end up with type 0.  */
break|break;
case|case
name|rs_fill
case|:
case|case
name|rs_org
case|:
case|case
name|rs_space
case|:
name|size
operator|+=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
case|case
name|rs_leb128
case|:
case|case
name|rs_cfa
case|:
case|case
name|rs_dwarf2dbg
case|:
comment|/* No further adjustments needed.  */
break|break;
case|case
name|rs_machine_dependent
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
name|RELAX_DESIRE_ALIGN
condition|)
name|size
operator|+=
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
default|default:
comment|/* We had darn well better know how big it is.  */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Re-process all of the fragments looking to convert all    of the RELAX_ADD_NOP_IF_SHORT_LOOP.  If:     A)      1) the instruction size count to the loop end label         is too short (<= 2 instructions),      2) loop has a jump or branch in it     or B)      1) workaround_all_short_loops is TRUE      2) The generating loop was a  'loopgtz' or 'loopnez'      3) the instruction size count to the loop end label is too short         (<= 2 instructions)    then convert this frag (and maybe the next one) to generate a NOP.    In any case close it off with a .fill 0.  */
end_comment

begin_function_decl
specifier|static
name|int
name|count_insns_to_loop_end
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|branch_before_loop_end
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_fix_short_loop_frags
parameter_list|(
name|void
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* When this routine is called, all of the subsections are still intact      so we walk over subsections instead of sections.  */
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
name|current_target
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|current_opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
operator|)
operator|||
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_CHECK_ALIGN_NEXT_OPCODE
operator|)
operator|)
condition|)
block|{
name|TInsn
name|t_insn
decl_stmt|;
name|fragS
modifier|*
name|loop_frag
init|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
decl_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|loop_frag
operator|->
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_target
operator|=
name|symbol_get_frag
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|current_opcode
operator|=
name|t_insn
operator|.
name|opcode
expr_stmt|;
name|assert
argument_list|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|current_opcode
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_SHORT_LOOP
condition|)
block|{
if|if
condition|(
name|count_insns_to_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|,
name|TRUE
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
operator|&&
operator|(
name|branch_before_loop_end
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
operator|||
operator|(
name|workaround_all_short_loops
operator|&&
name|current_opcode
operator|!=
name|XTENSA_UNDEFINED
operator|&&
name|current_opcode
operator|!=
name|xtensa_loop_opcode
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"loop containing less than three instructions may trigger hardware errata"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|unrelaxed_frag_min_insn_count
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|count_insns_to_loop_end
parameter_list|(
name|fragS
modifier|*
name|base_fragP
parameter_list|,
name|bfd_boolean
name|count_relax_add
parameter_list|,
name|int
name|max_count
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
init|=
name|NULL
decl_stmt|;
name|int
name|insn_count
init|=
literal|0
decl_stmt|;
name|fragP
operator|=
name|base_fragP
expr_stmt|;
for|for
control|(
init|;
name|fragP
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|insn_count
operator|+=
name|unrelaxed_frag_min_insn_count
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_count
operator|>=
name|max_count
condition|)
return|return
name|max_count
return|;
if|if
condition|(
name|count_relax_add
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ADD_NOP_IF_SHORT_LOOP
condition|)
block|{
comment|/* In order to add the appropriate number of 	         NOPs, we count an instruction for downstream 	         occurrences.  */
name|insn_count
operator|++
expr_stmt|;
if|if
condition|(
name|insn_count
operator|>=
name|max_count
condition|)
return|return
name|max_count
return|;
block|}
block|}
block|}
return|return
name|insn_count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unrelaxed_frag_min_insn_count
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|int
name|insn_count
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
return|return
name|insn_count
return|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Decode the fixed instructions.  */
while|while
condition|(
name|offset
operator|<
name|fragP
operator|->
name|fr_fix
condition|)
block|{
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"undecodable instruction in instruction frag"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn_count
return|;
block|}
name|offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|insn_count
operator|++
expr_stmt|;
block|}
return|return
name|insn_count
return|;
block|}
end_function

begin_function_decl
specifier|static
name|bfd_boolean
name|unrelaxed_frag_has_b_j
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bfd_boolean
name|branch_before_loop_end
parameter_list|(
name|fragS
modifier|*
name|base_fragP
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|base_fragP
init|;
name|fragP
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|unrelaxed_frag_has_b_j
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|unrelaxed_frag_has_b_j
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Decode the fixed instructions.  */
while|while
condition|(
name|offset
operator|<
name|fragP
operator|->
name|fr_fix
condition|)
block|{
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|get_opcode_from_buf
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|==
literal|1
operator|||
name|xtensa_opcode_is_jump
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|TRUE
return|;
block|}
name|offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Checks to be made after initial assembly but before relaxation.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|is_empty_loop
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_local_forward_loop
parameter_list|(
specifier|const
name|TInsn
modifier|*
parameter_list|,
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_sanity_check
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|frchP
operator|=
name|seg_info
argument_list|(
name|s
argument_list|)
operator|->
name|frchainP
init|;
name|frchP
condition|;
name|frchP
operator|=
name|frchP
operator|->
name|frch_next
control|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Walk over all of the fragments in a subsection.  */
for|for
control|(
name|fragP
operator|=
name|frchP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_IMMED
condition|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|TInsn
name|t_insn
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|t_insn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|is_empty_loop
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
condition|)
block|{
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid empty loop"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_local_forward_loop
argument_list|(
operator|&
name|t_insn
argument_list|,
name|fragP
argument_list|)
condition|)
block|{
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"loop target does not follow "
literal|"loop instruction in section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LOOP_IMMED_OPN
value|1
end_define

begin_comment
comment|/* Return TRUE if the loop target is the next non-zero fragment.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_empty_loop
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|!=
name|ITYPE_INSN
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|LOOP_IMMED_OPN
condition|)
return|return
name|FALSE
return|;
name|expr
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|LOOP_IMMED_OPN
index|]
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Walk through the zero-size fragments from this one.  If we find      the target fragment, then this is a zero-size loop.  */
for|for
control|(
name|next_fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|next_fragP
operator|!=
name|NULL
condition|;
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|next_fragP
operator|==
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|next_fragP
operator|->
name|fr_fix
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_local_forward_loop
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|const
name|expressionS
modifier|*
name|expr
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_type
operator|!=
name|ITYPE_INSN
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|insn
operator|->
name|ntok
operator|<=
name|LOOP_IMMED_OPN
condition|)
return|return
name|FALSE
return|;
name|expr
operator|=
operator|&
name|insn
operator|->
name|tok
index|[
name|LOOP_IMMED_OPN
index|]
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|FALSE
return|;
name|symbolP
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Walk through fragments until we find the target.      If we do not find the target, then this is an invalid loop.  */
for|for
control|(
name|next_fragP
operator|=
name|fragP
operator|->
name|fr_next
init|;
name|next_fragP
operator|!=
name|NULL
condition|;
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|next_fragP
operator|==
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|XTINFO_NAME
value|"Xtensa_Info"
end_define

begin_define
define|#
directive|define
name|XTINFO_NAMESZ
value|12
end_define

begin_define
define|#
directive|define
name|XTINFO_TYPE
value|1
end_define

begin_function
specifier|static
name|void
name|xtensa_add_config_info
parameter_list|(
name|void
parameter_list|)
block|{
name|asection
modifier|*
name|info_sec
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|info_sec
operator|=
name|subseg_new
argument_list|(
literal|".xtensa.info"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|info_sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|data
argument_list|,
literal|"USE_ABSOLUTE_LITERALS=%d\nABI=%d\n"
argument_list|,
name|XSHAL_USE_ABSOLUTE_LITERALS
argument_list|,
name|XSHAL_ABI
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Add enough null terminators to pad to a word boundary.  */
do|do
name|data
index|[
name|sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
do|while
condition|(
operator|(
name|sz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
do|;
comment|/* Follow the standard note section layout:      First write the length of the name string.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|XTINFO_NAMESZ
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Next comes the length of the "descriptor", i.e., the actual data.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|sz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Write the note type.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|XTINFO_TYPE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Write the name field.  */
name|p
operator|=
name|frag_more
argument_list|(
name|XTINFO_NAMESZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|XTINFO_NAME
argument_list|,
name|XTINFO_NAMESZ
argument_list|)
expr_stmt|;
comment|/* Finally, write the descriptor.  */
name|p
operator|=
name|frag_more
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Alignment Functions.  */
end_comment

begin_function
specifier|static
name|int
name|get_text_align_power
parameter_list|(
name|unsigned
name|target_size
parameter_list|)
block|{
if|if
condition|(
name|target_size
operator|<=
literal|4
condition|)
return|return
literal|2
return|;
name|assert
argument_list|(
name|target_size
operator|==
literal|8
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_text_align_max_fill_size
parameter_list|(
name|int
name|align_pow
parameter_list|,
name|bfd_boolean
name|use_nops
parameter_list|,
name|bfd_boolean
name|use_no_density
parameter_list|)
block|{
if|if
condition|(
operator|!
name|use_nops
condition|)
return|return
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
if|if
condition|(
name|use_no_density
condition|)
return|return
literal|3
operator|*
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
return|return
literal|1
operator|+
operator|(
literal|1
operator|<<
name|align_pow
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate the minimum bytes of fill needed at "address" to align a    target instruction of size "target_size" so that it does not cross a    power-of-two boundary specified by "align_pow".  If "use_nops" is FALSE,    the fill can be an arbitrary number of bytes.  Otherwise, the space must    be filled by NOP instructions.  */
end_comment

begin_function
specifier|static
name|int
name|get_text_align_fill_size
parameter_list|(
name|addressT
name|address
parameter_list|,
name|int
name|align_pow
parameter_list|,
name|int
name|target_size
parameter_list|,
name|bfd_boolean
name|use_nops
parameter_list|,
name|bfd_boolean
name|use_no_density
parameter_list|)
block|{
name|addressT
name|alignment
decl_stmt|,
name|fill
decl_stmt|,
name|fill_limit
decl_stmt|,
name|fill_step
decl_stmt|;
name|bfd_boolean
name|skip_one
init|=
name|FALSE
decl_stmt|;
name|alignment
operator|=
operator|(
literal|1
operator|<<
name|align_pow
operator|)
expr_stmt|;
name|assert
argument_list|(
name|target_size
operator|>
literal|0
operator|&&
name|alignment
operator|>=
operator|(
name|addressT
operator|)
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_nops
condition|)
block|{
name|fill_limit
operator|=
name|alignment
expr_stmt|;
name|fill_step
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|use_no_density
condition|)
block|{
comment|/* Combine 2- and 3-byte NOPs to fill anything larger than one.  */
name|fill_limit
operator|=
name|alignment
operator|*
literal|2
expr_stmt|;
name|fill_step
operator|=
literal|1
expr_stmt|;
name|skip_one
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill with 3-byte NOPs -- can only fill multiples of 3.  */
name|fill_limit
operator|=
name|alignment
operator|*
literal|3
expr_stmt|;
name|fill_step
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Try all fill sizes until finding one that works.  */
for|for
control|(
name|fill
operator|=
literal|0
init|;
name|fill
operator|<
name|fill_limit
condition|;
name|fill
operator|+=
name|fill_step
control|)
block|{
if|if
condition|(
name|skip_one
operator|&&
name|fill
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|address
operator|+
name|fill
operator|)
operator|>>
name|align_pow
operator|==
operator|(
name|address
operator|+
name|fill
operator|+
name|target_size
operator|-
literal|1
operator|)
operator|>>
name|align_pow
condition|)
return|return
name|fill
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|branch_align_power
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
comment|/* If the Xtensa processor has a fetch width of 8 bytes, and the section      is aligned to at least an 8-byte boundary, then a branch target need      only fit within an 8-byte aligned block of memory to avoid a stall.      Otherwise, try to fit branch targets within 4-byte aligned blocks      (which may be insufficient, e.g., if the section has no alignment, but      it's good enough).  */
if|if
condition|(
name|xtensa_fetch_width
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|get_recorded_alignment
argument_list|(
name|sec
argument_list|)
operator|>=
literal|3
condition|)
return|return
literal|3
return|;
block|}
else|else
name|assert
argument_list|(
name|xtensa_fetch_width
operator|==
literal|4
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* This will assert if it is not possible.  */
end_comment

begin_function
specifier|static
name|int
name|get_text_align_nop_count
parameter_list|(
name|offsetT
name|fill_size
parameter_list|,
name|bfd_boolean
name|use_no_density
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_no_density
condition|)
block|{
name|assert
argument_list|(
name|fill_size
operator|%
literal|3
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|fill_size
operator|/
literal|3
operator|)
return|;
block|}
name|assert
argument_list|(
name|fill_size
operator|!=
literal|1
argument_list|)
expr_stmt|;
comment|/* Bad argument.  */
while|while
condition|(
name|fill_size
operator|>
literal|1
condition|)
block|{
name|int
name|insn_size
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|2
operator|||
name|fill_size
operator|==
literal|4
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fill_size
operator|-=
name|insn_size
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|fill_size
operator|!=
literal|1
argument_list|)
expr_stmt|;
comment|/* Bad algorithm.  */
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_text_align_nth_nop_size
parameter_list|(
name|offsetT
name|fill_size
parameter_list|,
name|int
name|n
parameter_list|,
name|bfd_boolean
name|use_no_density
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_no_density
condition|)
return|return
literal|3
return|;
name|assert
argument_list|(
name|fill_size
operator|!=
literal|1
argument_list|)
expr_stmt|;
comment|/* Bad argument.  */
while|while
condition|(
name|fill_size
operator|>
literal|1
condition|)
block|{
name|int
name|insn_size
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|2
operator|||
name|fill_size
operator|==
literal|4
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fill_size
operator|-=
name|insn_size
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|==
name|count
condition|)
return|return
name|insn_size
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For the given fragment, find the appropriate address    for it to begin at if we are using NOPs to align it.  */
end_comment

begin_function
specifier|static
name|addressT
name|get_noop_aligned_address
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|addressT
name|address
parameter_list|)
block|{
comment|/* The rule is: get next fragment's FIRST instruction.  Find      the smallest number of bytes that need to be added to      ensure that the next fragment's FIRST instruction will fit      in a single word.       E.G.,   2 bytes : 0, 1, 2 mod 4 	     3 bytes: 0, 1 mod 4       If the FIRST instruction MIGHT be relaxed,      assume that it will become a 3-byte instruction.       Note again here that LOOP instructions are not bundleable,      and this relaxation only applies to LOOP opcodes.  */
name|int
name|fill_size
init|=
literal|0
decl_stmt|;
name|int
name|first_insn_size
decl_stmt|;
name|int
name|loop_insn_size
decl_stmt|;
name|addressT
name|pre_opcode_bytes
decl_stmt|;
name|int
name|align_power
decl_stmt|;
name|fragS
modifier|*
name|first_insn
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|bfd_boolean
name|is_loop
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_ALIGN_NEXT_OPCODE
argument_list|)
expr_stmt|;
comment|/* Find the loop frag.  */
name|first_insn
operator|=
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/* Now find the first insn frag.  */
name|first_insn
operator|=
name|next_non_empty_frag
argument_list|(
name|first_insn
argument_list|)
expr_stmt|;
name|is_loop
operator|=
name|next_frag_opcode_is_loop
argument_list|(
name|fragP
argument_list|,
operator|&
name|opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_loop
argument_list|)
expr_stmt|;
name|loop_insn_size
operator|=
name|xg_get_single_size
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|pre_opcode_bytes
operator|=
name|next_frag_pre_opcode_bytes
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|pre_opcode_bytes
operator|+=
name|loop_insn_size
expr_stmt|;
comment|/* For loops, the alignment depends on the size of the      instruction following the loop, not the LOOP instruction.  */
if|if
condition|(
name|first_insn
operator|==
name|NULL
condition|)
name|first_insn_size
operator|=
name|xtensa_fetch_width
expr_stmt|;
else|else
name|first_insn_size
operator|=
name|get_loop_align_size
argument_list|(
name|frag_format_size
argument_list|(
name|first_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it was 8, then we'll need a larger alignment for the section.  */
name|align_power
operator|=
name|get_text_align_power
argument_list|(
name|first_insn_size
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|align_power
argument_list|)
expr_stmt|;
name|fill_size
operator|=
name|get_text_align_fill_size
argument_list|(
name|address
operator|+
name|pre_opcode_bytes
argument_list|,
name|align_power
argument_list|,
name|first_insn_size
argument_list|,
name|TRUE
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
argument_list|)
expr_stmt|;
return|return
name|address
operator|+
name|fill_size
return|;
block|}
end_function

begin_comment
comment|/* 3 mechanisms for relaxing an alignment:     Align to a power of 2.    Align so the next fragment's instruction does not cross a word boundary.    Align the current instruction so that if the next instruction        were 3 bytes, it would not cross a word boundary.     We can align with:     zeros    - This is easy; always insert zeros.    nops     - 3-byte and 2-byte instructions               2 - 2-byte nop               3 - 3-byte nop               4 - 2 2-byte nops>=5 : 3-byte instruction + fn (n-3)    widening - widen previous instructions.  */
end_comment

begin_function
specifier|static
name|offsetT
name|get_aligned_diff
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|addressT
name|address
parameter_list|,
name|offsetT
modifier|*
name|max_diff
parameter_list|)
block|{
name|addressT
name|target_address
decl_stmt|,
name|loop_insn_offset
decl_stmt|;
name|int
name|target_size
decl_stmt|;
name|xtensa_opcode
name|loop_opcode
decl_stmt|;
name|bfd_boolean
name|is_loop
decl_stmt|;
name|int
name|align_power
decl_stmt|;
name|offsetT
name|opt_diff
decl_stmt|;
name|offsetT
name|branch_align
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_DESIRE_ALIGN
case|:
name|target_size
operator|=
name|next_frag_format_size
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_size
operator|==
name|XTENSA_UNDEFINED
condition|)
name|target_size
operator|=
literal|3
expr_stmt|;
name|align_power
operator|=
name|branch_align_power
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|branch_align
operator|=
literal|1
operator|<<
name|align_power
expr_stmt|;
comment|/* Don't count on the section alignment being as large as the target.  */
if|if
condition|(
name|target_size
operator|>
name|branch_align
condition|)
name|target_size
operator|=
name|branch_align
expr_stmt|;
name|opt_diff
operator|=
name|get_text_align_fill_size
argument_list|(
name|address
argument_list|,
name|align_power
argument_list|,
name|target_size
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|max_diff
operator|=
operator|(
name|opt_diff
operator|+
name|branch_align
operator|-
operator|(
name|target_size
operator|+
operator|(
operator|(
name|address
operator|+
name|opt_diff
operator|)
operator|%
name|branch_align
operator|)
operator|)
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|max_diff
operator|>=
name|opt_diff
argument_list|)
expr_stmt|;
return|return
name|opt_diff
return|;
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
name|target_size
operator|=
name|get_loop_align_size
argument_list|(
name|next_frag_format_size
argument_list|(
name|fragP
argument_list|)
argument_list|)
expr_stmt|;
name|loop_insn_offset
operator|=
literal|0
expr_stmt|;
name|is_loop
operator|=
name|next_frag_opcode_is_loop
argument_list|(
name|fragP
argument_list|,
operator|&
name|loop_opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_loop
argument_list|)
expr_stmt|;
comment|/* If the loop has been expanded then the LOOP instruction 	 could be at an offset from this fragment.  */
if|if
condition|(
name|next_non_empty_frag
argument_list|(
name|fragP
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|!=
name|RELAX_IMMED
condition|)
name|loop_insn_offset
operator|=
name|get_expanded_loop_offset
argument_list|(
name|loop_opcode
argument_list|)
expr_stmt|;
comment|/* In an ideal world, which is what we are shooting for here, 	 we wouldn't need to use any NOPs immediately prior to the 	 LOOP instruction.  If this approach fails, relax_frag_loop_align 	 will call get_noop_aligned_address.  */
name|target_address
operator|=
name|address
operator|+
name|loop_insn_offset
operator|+
name|xg_get_single_size
argument_list|(
name|loop_opcode
argument_list|)
expr_stmt|;
name|align_power
operator|=
name|get_text_align_power
argument_list|(
name|target_size
argument_list|)
operator|,
name|opt_diff
operator|=
name|get_text_align_fill_size
argument_list|(
name|target_address
argument_list|,
name|align_power
argument_list|,
name|target_size
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|max_diff
operator|=
name|xtensa_fetch_width
operator|-
operator|(
operator|(
name|target_address
operator|+
name|opt_diff
operator|)
operator|%
name|xtensa_fetch_width
operator|)
operator|-
name|target_size
operator|+
name|opt_diff
expr_stmt|;
name|assert
argument_list|(
operator|*
name|max_diff
operator|>=
name|opt_diff
argument_list|)
expr_stmt|;
return|return
name|opt_diff
return|;
default|default:
break|break;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_relax_frag Hook and Helper Functions.  */
end_comment

begin_function_decl
specifier|static
name|long
name|relax_frag_loop_align
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|relax_frag_for_align
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|relax_frag_immed
parameter_list|(
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|,
name|xtensa_format
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the number of bytes added to this fragment, given that the    input has been stretched already by "stretch".  */
end_comment

begin_function
name|long
name|xtensa_relax_frag
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
parameter_list|,
name|int
modifier|*
name|stretched_p
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|unreported
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
decl_stmt|;
name|long
name|new_stretch
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|int
name|lit_size
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|vbuf
init|=
name|NULL
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|num_slots
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
comment|/* Always convert.  */
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|relax_seen
condition|)
name|new_stretch
operator|=
name|relax_frag_loop_align
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_LOOP_END
case|:
comment|/* Do nothing.  */
break|break;
case|case
name|RELAX_LOOP_END_ADD_NOP
case|:
comment|/* Add a NOP and switch to .fill 0.  */
name|new_stretch
operator|=
name|relax_frag_add_nop
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* Do nothing. The narrowing before this frag will either align          it or not.  */
break|break;
case|case
name|RELAX_LITERAL
case|:
case|case
name|RELAX_LITERAL_FINAL
case|:
return|return
literal|0
return|;
case|case
name|RELAX_LITERAL_NR
case|:
name|lit_size
operator|=
literal|4
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_FINAL
expr_stmt|;
name|assert
argument_list|(
name|unreported
operator|==
name|lit_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|lit_size
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|lit_size
expr_stmt|;
name|new_stretch
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|RELAX_SLOTS
case|:
if|if
condition|(
name|vbuf
operator|==
name|NULL
condition|)
name|vbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|vbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|vbuf
argument_list|)
expr_stmt|;
name|num_slots
operator|=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
condition|)
block|{
case|case
name|RELAX_NARROW
case|:
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|relax_seen
condition|)
name|new_stretch
operator|+=
name|relax_frag_for_align
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
case|case
name|RELAX_IMMED_STEP1
case|:
case|case
name|RELAX_IMMED_STEP2
case|:
case|case
name|RELAX_IMMED_STEP3
case|:
comment|/* Place the immediate.  */
name|new_stretch
operator|+=
name|relax_frag_immed
argument_list|(
name|now_seg
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
operator|-
name|RELAX_IMMED
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|stretched_p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This is OK; see the note in xg_assemble_vliw_tokens.  */
break|break;
block|}
block|}
break|break;
case|case
name|RELAX_LITERAL_POOL_BEGIN
case|:
case|case
name|RELAX_LITERAL_POOL_END
case|:
case|case
name|RELAX_MAYBE_UNREACHABLE
case|:
case|case
name|RELAX_MAYBE_DESIRE_ALIGN
case|:
comment|/* No relaxation required.  */
break|break;
case|case
name|RELAX_FILL_NOP
case|:
case|case
name|RELAX_UNREACHABLE
case|:
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|relax_seen
condition|)
name|new_stretch
operator|+=
name|relax_frag_for_align
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relaxation state"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell gas we need another relaxation pass.  */
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|relax_seen
condition|)
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|relax_seen
operator|=
name|TRUE
expr_stmt|;
operator|*
name|stretched_p
operator|=
literal|1
expr_stmt|;
block|}
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|new_stretch
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|relax_frag_loop_align
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|addressT
name|old_address
decl_stmt|,
name|old_next_address
decl_stmt|,
name|old_size
decl_stmt|;
name|addressT
name|new_address
decl_stmt|,
name|new_next_address
decl_stmt|,
name|new_size
decl_stmt|;
name|addressT
name|growth
decl_stmt|;
comment|/* All the frags with relax_frag_for_alignment prior to this one in the      section have been done, hopefully eliminating the need for a NOP here.      But, this will put it in if necessary.  */
comment|/* Calculate the old address of this fragment and the next fragment.  */
name|old_address
operator|=
name|fragP
operator|->
name|fr_address
operator|-
name|stretch
expr_stmt|;
name|old_next_address
operator|=
operator|(
name|fragP
operator|->
name|fr_address
operator|-
name|stretch
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|old_size
operator|=
name|old_next_address
operator|-
name|old_address
expr_stmt|;
comment|/* Calculate the new address of this fragment and the next fragment.  */
name|new_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|new_next_address
operator|=
name|get_noop_aligned_address
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|new_next_address
operator|-
name|new_address
expr_stmt|;
name|growth
operator|=
name|new_size
operator|-
name|old_size
expr_stmt|;
comment|/* Fix up the text_expansion field and return the new growth.  */
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|+=
name|growth
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Add a NOP instruction.  */
end_comment

begin_function
specifier|static
name|long
name|relax_frag_add_nop
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|char
modifier|*
name|nop_buf
init|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|length
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|assemble_nop
argument_list|(
name|length
argument_list|,
name|nop_buf
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|<
name|length
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"fr_var (%ld)< length (%d)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_var
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|length
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function_decl
specifier|static
name|long
name|future_alignment_required
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|long
name|relax_frag_for_align
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
comment|/* Overview of the relaxation procedure for alignment:      We can widen with NOPs or by widening instructions or by filling      bytes after jump instructions.  Find the opportune places and widen      them if necessary.  */
name|long
name|stretch_me
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_FILL_NOP
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
operator|||
operator|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
operator|)
argument_list|)
expr_stmt|;
name|stretch_me
operator|=
name|future_alignment_required
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
name|diff
operator|=
name|stretch_me
operator|-
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
comment|/* We expanded on a previous pass.  Can we shrink now?  */
name|long
name|shrink
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|-
name|stretch_me
decl_stmt|;
if|if
condition|(
name|shrink
operator|<=
name|stretch
operator|&&
name|stretch
operator|>
literal|0
condition|)
block|{
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|=
name|stretch_me
expr_stmt|;
return|return
operator|-
name|shrink
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Below here, diff> 0.  */
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|=
name|stretch_me
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the next frag that should be aligned.     By "address" we mean the address it _would_ be at if there    is no action taken to align it between here and the target frag.    In other words, if no narrows and no fill nops are used between    here and the frag to align, _even_if_ some of the frags we use    to align targets have already expanded on a previous relaxation    pass.     Also, count each frag that may be used to help align the target.     Return 0 if there are no frags left in the chain that need to be    aligned.  */
end_comment

begin_function
specifier|static
name|addressT
name|find_address_of_next_align_frag
parameter_list|(
name|fragS
modifier|*
modifier|*
name|fragPP
parameter_list|,
name|int
modifier|*
name|wide_nops
parameter_list|,
name|int
modifier|*
name|narrow_nops
parameter_list|,
name|int
modifier|*
name|widens
parameter_list|,
name|bfd_boolean
modifier|*
name|paddable
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
init|=
operator|*
name|fragPP
decl_stmt|;
name|addressT
name|address
init|=
name|fragP
operator|->
name|fr_address
decl_stmt|;
comment|/* Do not reset the counts to 0.  */
while|while
condition|(
name|fragP
condition|)
block|{
comment|/* Limit this to a small search.  */
if|if
condition|(
operator|*
name|widens
operator|>=
operator|(
name|int
operator|)
name|xtensa_fetch_width
condition|)
block|{
operator|*
name|fragPP
operator|=
name|fragP
expr_stmt|;
return|return
literal|0
return|;
block|}
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
condition|)
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
condition|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_UNREACHABLE
case|:
operator|*
name|paddable
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|RELAX_FILL_NOP
case|:
operator|(
operator|*
name|wide_nops
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
condition|)
operator|(
operator|*
name|narrow_nops
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|RELAX_SLOTS
case|:
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
condition|)
block|{
operator|(
operator|*
name|widens
operator|)
operator|++
expr_stmt|;
break|break;
block|}
name|address
operator|+=
name|total_frag_text_expansion
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
empty_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
name|address
operator|+=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
case|case
name|RELAX_DESIRE_ALIGN
case|:
operator|*
name|fragPP
operator|=
name|fragP
expr_stmt|;
return|return
name|address
return|;
case|case
name|RELAX_MAYBE_UNREACHABLE
case|:
case|case
name|RELAX_MAYBE_DESIRE_ALIGN
case|:
comment|/* Do nothing.  */
break|break;
default|default:
comment|/* Just punt if we don't know the type.  */
operator|*
name|fragPP
operator|=
name|fragP
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Just punt if we don't know the type.  */
operator|*
name|fragPP
operator|=
name|fragP
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
operator|*
name|fragPP
operator|=
name|fragP
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|long
name|bytes_to_stretch
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|long
name|future_alignment_required
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fragS
modifier|*
name|this_frag
init|=
name|fragP
decl_stmt|;
name|long
name|address
decl_stmt|;
name|int
name|num_widens
init|=
literal|0
decl_stmt|;
name|int
name|wide_nops
init|=
literal|0
decl_stmt|;
name|int
name|narrow_nops
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|paddable
init|=
name|FALSE
decl_stmt|;
name|offsetT
name|local_opt_diff
decl_stmt|;
name|offsetT
name|opt_diff
decl_stmt|;
name|offsetT
name|max_diff
decl_stmt|;
name|int
name|stretch_amount
init|=
literal|0
decl_stmt|;
name|int
name|local_stretch_amount
decl_stmt|;
name|int
name|global_stretch_amount
decl_stmt|;
name|address
operator|=
name|find_address_of_next_align_frag
argument_list|(
operator|&
name|fragP
argument_list|,
operator|&
name|wide_nops
argument_list|,
operator|&
name|narrow_nops
argument_list|,
operator|&
name|num_widens
argument_list|,
operator|&
name|paddable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|address
condition|)
block|{
if|if
condition|(
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|is_aligning_branch
condition|)
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|=
name|RELAX_IMMED
expr_stmt|;
else|else
name|frag_wane
argument_list|(
name|this_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|local_opt_diff
operator|=
name|get_aligned_diff
argument_list|(
name|fragP
argument_list|,
name|address
argument_list|,
operator|&
name|max_diff
argument_list|)
expr_stmt|;
name|opt_diff
operator|=
name|local_opt_diff
expr_stmt|;
name|assert
argument_list|(
name|opt_diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|max_diff
operator|>=
name|opt_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_diff
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fragP
condition|)
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
while|while
condition|(
name|fragP
operator|&&
name|opt_diff
operator|<
name|max_diff
operator|&&
name|address
condition|)
block|{
comment|/* We only use these to determine if we can exit early 	     because there will be plenty of ways to align future 	     align frags.  */
name|int
name|glob_widens
init|=
literal|0
decl_stmt|;
name|int
name|dnn
init|=
literal|0
decl_stmt|;
name|int
name|dw
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|glob_pad
init|=
literal|0
decl_stmt|;
name|address
operator|=
name|find_address_of_next_align_frag
argument_list|(
operator|&
name|fragP
argument_list|,
operator|&
name|glob_widens
argument_list|,
operator|&
name|dnn
argument_list|,
operator|&
name|dw
argument_list|,
operator|&
name|glob_pad
argument_list|)
expr_stmt|;
comment|/* If there is a padable portion, then skip.  */
if|if
condition|(
name|glob_pad
operator|||
name|glob_widens
operator|>=
operator|(
literal|1
operator|<<
name|branch_align_power
argument_list|(
name|now_seg
argument_list|)
operator|)
condition|)
name|address
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
condition|)
block|{
name|offsetT
name|next_m_diff
decl_stmt|;
name|offsetT
name|next_o_diff
decl_stmt|;
comment|/* Downrange frags haven't had stretch added to them yet.  */
name|address
operator|+=
name|stretch
expr_stmt|;
comment|/* The address also includes any text expansion from this 		 frag in a previous pass, but we don't want that.  */
name|address
operator|-=
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
comment|/* Assume we are going to move at least opt_diff.  In 		 reality, we might not be able to, but assuming that 		 we will helps catch cases where moving opt_diff pushes 		 the next target from aligned to unaligned.  */
name|address
operator|+=
name|opt_diff
expr_stmt|;
name|next_o_diff
operator|=
name|get_aligned_diff
argument_list|(
name|fragP
argument_list|,
name|address
argument_list|,
operator|&
name|next_m_diff
argument_list|)
expr_stmt|;
comment|/* Now cleanup for the adjustments to address.  */
name|next_o_diff
operator|+=
name|opt_diff
expr_stmt|;
name|next_m_diff
operator|+=
name|opt_diff
expr_stmt|;
if|if
condition|(
name|next_o_diff
operator|<=
name|max_diff
operator|&&
name|next_o_diff
operator|>
name|opt_diff
condition|)
name|opt_diff
operator|=
name|next_o_diff
expr_stmt|;
if|if
condition|(
name|next_m_diff
operator|<
name|max_diff
condition|)
name|max_diff
operator|=
name|next_m_diff
expr_stmt|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
comment|/* If there are enough wideners in between, do it.  */
if|if
condition|(
name|paddable
condition|)
block|{
if|if
condition|(
name|this_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
condition|)
block|{
name|assert
argument_list|(
name|opt_diff
operator|<=
name|UNREACHABLE_MAX_WIDTH
argument_list|)
expr_stmt|;
return|return
name|opt_diff
return|;
block|}
return|return
literal|0
return|;
block|}
name|local_stretch_amount
operator|=
name|bytes_to_stretch
argument_list|(
name|this_frag
argument_list|,
name|wide_nops
argument_list|,
name|narrow_nops
argument_list|,
name|num_widens
argument_list|,
name|local_opt_diff
argument_list|)
expr_stmt|;
name|global_stretch_amount
operator|=
name|bytes_to_stretch
argument_list|(
name|this_frag
argument_list|,
name|wide_nops
argument_list|,
name|narrow_nops
argument_list|,
name|num_widens
argument_list|,
name|opt_diff
argument_list|)
expr_stmt|;
comment|/* If the condition below is true, then the frag couldn't 	 stretch the correct amount for the global case, so we just 	 optimize locally.  We'll rely on the subsequent frags to get 	 the correct alignment in the global case.  */
if|if
condition|(
name|global_stretch_amount
operator|<
name|local_stretch_amount
condition|)
name|stretch_amount
operator|=
name|local_stretch_amount
expr_stmt|;
else|else
name|stretch_amount
operator|=
name|global_stretch_amount
expr_stmt|;
if|if
condition|(
name|this_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_SLOTS
operator|&&
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
literal|0
index|]
operator|==
name|RELAX_NARROW
condition|)
name|assert
argument_list|(
name|stretch_amount
operator|<=
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_FILL_NOP
condition|)
block|{
if|if
condition|(
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|is_no_density
condition|)
name|assert
argument_list|(
name|stretch_amount
operator|==
literal|3
operator|||
name|stretch_amount
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|stretch_amount
operator|<=
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stretch_amount
return|;
block|}
end_function

begin_comment
comment|/* The idea: widen everything you can to get a target or loop aligned,    then start using NOPs.     When we must have a NOP, here is a table of how we decide    (so you don't have to fight through the control flow below):     wide_nops   = the number of wide NOPs available for aligning    narrow_nops = the number of narrow NOPs available for aligning 		 (a subset of wide_nops)    widens      = the number of narrow instructions that should be widened     Desired   wide   narrow    Diff      nop    nop      widens    1           0      0         1    2           0      1         0    3a          1      0         0     b          0      1         1 (case 3a makes this case unnecessary)    4a          1      0         1     b          0      2         0     c          0      1         2 (case 4a makes this case unnecessary)    5a          1      0         2     b          1      1         0     c          0      2         1 (case 5b makes this case unnecessary)    6a          2      0         0     b          1      0         3     c          0      1         4 (case 6b makes this case unnecessary)     d          1      1         1 (case 6a makes this case unnecessary)     e          0      2         2 (case 6a makes this case unnecessary)     f          0      3         0 (case 6a makes this case unnecessary)    7a          1      0         4     b          2      0         1     c          1      1         2 (case 7b makes this case unnecessary)     d          0      1         5 (case 7a makes this case unnecessary)     e          0      2         3 (case 7b makes this case unnecessary)     f          0      3         1 (case 7b makes this case unnecessary)     g          1      2         1 (case 7b makes this case unnecessary) */
end_comment

begin_function
specifier|static
name|long
name|bytes_to_stretch
parameter_list|(
name|fragS
modifier|*
name|this_frag
parameter_list|,
name|int
name|wide_nops
parameter_list|,
name|int
name|narrow_nops
parameter_list|,
name|int
name|num_widens
parameter_list|,
name|int
name|desired_diff
parameter_list|)
block|{
name|int
name|bytes_short
init|=
name|desired_diff
operator|-
name|num_widens
decl_stmt|;
name|assert
argument_list|(
name|desired_diff
operator|>=
literal|0
operator|&&
name|desired_diff
operator|<
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_diff
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|wide_nops
operator|>
literal|0
operator|||
name|num_widens
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Always prefer widening to NOP-filling.  */
if|if
condition|(
name|bytes_short
operator|<
literal|0
condition|)
block|{
comment|/* There are enough RELAX_NARROW frags after this one 	 to align the target without widening this frag in any way.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bytes_short
operator|==
literal|0
condition|)
block|{
comment|/* Widen every narrow between here and the align target 	 and the align target will be properly aligned.  */
if|if
condition|(
name|this_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_FILL_NOP
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/* From here we will need at least one NOP to get an alignment.      However, we may not be able to align at all, in which case,      don't widen.  */
if|if
condition|(
name|this_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_FILL_NOP
condition|)
block|{
switch|switch
condition|(
name|desired_diff
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|0
return|;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|&&
name|narrow_nops
operator|==
literal|1
condition|)
return|return
literal|2
return|;
comment|/* case 2 */
return|return
literal|0
return|;
case|case
literal|3
case|:
if|if
condition|(
name|wide_nops
operator|>
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|3
return|;
comment|/* case 3a */
case|case
literal|4
case|:
if|if
condition|(
name|num_widens
operator|>=
literal|1
operator|&&
name|wide_nops
operator|==
literal|1
condition|)
return|return
literal|3
return|;
comment|/* case 4a */
if|if
condition|(
operator|!
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|is_no_density
operator|&&
name|narrow_nops
operator|==
literal|2
condition|)
return|return
literal|2
return|;
comment|/* case 4b */
return|return
literal|0
return|;
case|case
literal|5
case|:
if|if
condition|(
name|num_widens
operator|>=
literal|2
operator|&&
name|wide_nops
operator|==
literal|1
condition|)
return|return
literal|3
return|;
comment|/* case 5a */
comment|/* We will need two nops.  Are there enough nops 	     between here and the align target?  */
if|if
condition|(
name|wide_nops
operator|<
literal|2
operator|||
name|narrow_nops
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Are there other nops closer that can serve instead?  */
if|if
condition|(
name|wide_nops
operator|>
literal|2
operator|&&
name|narrow_nops
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Take the density one first, because there might not be 	     another density one available.  */
if|if
condition|(
operator|!
name|this_frag
operator|->
name|tc_frag_data
operator|.
name|is_no_density
condition|)
return|return
literal|2
return|;
comment|/* case 5b narrow */
else|else
return|return
literal|3
return|;
comment|/* case 5b wide */
return|return
literal|0
return|;
case|case
literal|6
case|:
if|if
condition|(
name|wide_nops
operator|==
literal|2
condition|)
return|return
literal|3
return|;
comment|/* case 6a */
elseif|else
if|if
condition|(
name|num_widens
operator|>=
literal|3
operator|&&
name|wide_nops
operator|==
literal|1
condition|)
return|return
literal|3
return|;
comment|/* case 6b */
return|return
literal|0
return|;
case|case
literal|7
case|:
if|if
condition|(
name|wide_nops
operator|==
literal|1
operator|&&
name|num_widens
operator|>=
literal|4
condition|)
return|return
literal|3
return|;
comment|/* case 7a */
elseif|else
if|if
condition|(
name|wide_nops
operator|==
literal|2
operator|&&
name|num_widens
operator|>=
literal|1
condition|)
return|return
literal|3
return|;
comment|/* case 7b */
return|return
literal|0
return|;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We will need a NOP no matter what, but should we widen 	 this instruction to help?  	 This is a RELAX_NARROW frag.  */
switch|switch
condition|(
name|desired_diff
condition|)
block|{
case|case
literal|1
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|2
case|:
case|case
literal|3
case|:
return|return
literal|0
return|;
case|case
literal|4
case|:
if|if
condition|(
name|wide_nops
operator|>=
literal|1
operator|&&
name|num_widens
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* case 4a */
return|return
literal|0
return|;
case|case
literal|5
case|:
if|if
condition|(
name|wide_nops
operator|>=
literal|1
operator|&&
name|num_widens
operator|==
literal|2
condition|)
return|return
literal|1
return|;
comment|/* case 5a */
return|return
literal|0
return|;
case|case
literal|6
case|:
if|if
condition|(
name|wide_nops
operator|>=
literal|2
condition|)
return|return
literal|0
return|;
comment|/* case 6a */
elseif|else
if|if
condition|(
name|wide_nops
operator|>=
literal|1
operator|&&
name|num_widens
operator|==
literal|3
condition|)
return|return
literal|1
return|;
comment|/* case 6b */
return|return
literal|0
return|;
case|case
literal|7
case|:
if|if
condition|(
name|wide_nops
operator|>=
literal|1
operator|&&
name|num_widens
operator|==
literal|4
condition|)
return|return
literal|1
return|;
comment|/* case 7a */
elseif|else
if|if
condition|(
name|wide_nops
operator|>=
literal|2
operator|&&
name|num_widens
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* case 7b */
return|return
literal|0
return|;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|relax_frag_immed
parameter_list|(
name|segT
name|segP
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
parameter_list|,
name|int
name|min_steps
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
modifier|*
name|stretched_p
parameter_list|,
name|bfd_boolean
name|estimate_only
parameter_list|)
block|{
name|TInsn
name|tinsn
decl_stmt|;
name|int
name|old_size
decl_stmt|;
name|bfd_boolean
name|negatable_branch
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|branch_jmp_to_next
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|wide_insn
init|=
name|FALSE
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|IStack
name|istack
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
name|int
name|num_steps
decl_stmt|;
name|fragS
modifier|*
name|lit_fragP
decl_stmt|;
name|int
name|num_text_bytes
decl_stmt|,
name|num_literal_bytes
decl_stmt|;
name|int
name|literal_diff
decl_stmt|,
name|total_text_diff
decl_stmt|,
name|this_text_diff
decl_stmt|,
name|first
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
name|vinsn_from_chars
argument_list|(
operator|&
name|cur_vinsn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_vinsn
operator|.
name|num_slots
operator|>
literal|1
condition|)
name|wide_insn
operator|=
name|TRUE
expr_stmt|;
name|tinsn
operator|=
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|tinsn
argument_list|,
name|fragP
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|estimate_only
operator|&&
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|tinsn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|workaround_b_j_loop_end
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|branch_jmp_to_next
operator|=
name|is_branch_jmp_to_next
argument_list|(
operator|&
name|tinsn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
name|negatable_branch
operator|=
operator|(
name|xtensa_opcode_is_branch
argument_list|(
name|isa
argument_list|,
name|tinsn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
name|old_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* Special case: replace a branch to the next instruction with a NOP.      This is required to work around a hardware bug in T1040.0 and also      serves as an optimization.  */
if|if
condition|(
name|branch_jmp_to_next
operator|&&
operator|(
operator|(
name|old_size
operator|==
literal|2
operator|)
operator|||
operator|(
name|old_size
operator|==
literal|3
operator|)
operator|)
operator|&&
operator|!
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Here is the fun stuff: Get the immediate field from this      instruction.  If it fits, we are done.  If not, find the next      instruction sequence that fits.  */
name|frag_offset
operator|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|num_steps
operator|=
name|xg_assembly_relax
argument_list|(
operator|&
name|istack
argument_list|,
operator|&
name|tinsn
argument_list|,
name|segP
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|min_steps
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_steps
operator|<
name|min_steps
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: relaxation failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|num_steps
operator|>
name|RELAX_IMMED_MAXSTEPS
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: relaxation requires too many steps"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
operator|=
operator|(
name|int
operator|)
name|RELAX_IMMED
operator|+
name|num_steps
expr_stmt|;
comment|/* Figure out the number of bytes needed.  */
name|lit_fragP
operator|=
literal|0
expr_stmt|;
name|num_literal_bytes
operator|=
name|get_num_stack_literal_bytes
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|literal_diff
operator|=
name|num_literal_bytes
operator|-
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_expansion
index|[
name|slot
index|]
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|istack
operator|.
name|insn
index|[
name|first
index|]
operator|.
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|first
operator|++
expr_stmt|;
name|num_text_bytes
operator|=
name|get_num_stack_text_bytes
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_insn
condition|)
block|{
name|num_text_bytes
operator|+=
name|old_size
expr_stmt|;
if|if
condition|(
name|opcode_fits_format_slot
argument_list|(
name|istack
operator|.
name|insn
index|[
name|first
index|]
operator|.
name|opcode
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
condition|)
name|num_text_bytes
operator|-=
name|xg_get_single_size
argument_list|(
name|istack
operator|.
name|insn
index|[
name|first
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
name|total_text_diff
operator|=
name|num_text_bytes
operator|-
name|old_size
expr_stmt|;
name|this_text_diff
operator|=
name|total_text_diff
operator|-
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
name|slot
index|]
expr_stmt|;
comment|/* It MUST get larger.  If not, we could get an infinite loop.  */
name|assert
argument_list|(
name|num_text_bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|literal_diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total_text_diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
name|slot
index|]
operator|=
name|total_text_diff
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_expansion
index|[
name|slot
index|]
operator|=
name|num_literal_bytes
expr_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
name|slot
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_expansion
index|[
name|slot
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Find the associated expandable literal for this.  */
if|if
condition|(
name|literal_diff
operator|!=
literal|0
condition|)
block|{
name|lit_fragP
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frags
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|lit_fragP
condition|)
block|{
name|assert
argument_list|(
name|literal_diff
operator|==
literal|4
argument_list|)
expr_stmt|;
name|lit_fragP
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|+=
name|literal_diff
expr_stmt|;
comment|/* We expect that the literal section state has NOT been 	     modified yet.  */
name|assert
argument_list|(
name|lit_fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
name|lit_fragP
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL
argument_list|)
expr_stmt|;
name|lit_fragP
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_NR
expr_stmt|;
comment|/* We need to mark this section for another iteration 	     of relaxation.  */
operator|(
operator|*
name|stretched_p
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|negatable_branch
operator|&&
name|istack
operator|.
name|ninsn
operator|>
literal|1
condition|)
name|update_next_frag_state
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
name|this_text_diff
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_convert_frag Hook and Helper Functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|convert_frag_align_next_opcode
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_frag_narrow
parameter_list|(
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|xtensa_format
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_frag_fill_nop
parameter_list|(
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_frag_immed
parameter_list|(
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|xtensa_format
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|vbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|num_slots
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|new_logical_line
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fragp
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|RELAX_ALIGN_NEXT_OPCODE
case|:
comment|/* Always convert.  */
name|convert_frag_align_next_opcode
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_DESIRE_ALIGN
case|:
comment|/* Do nothing.  If not aligned already, too bad.  */
break|break;
case|case
name|RELAX_LITERAL
case|:
case|case
name|RELAX_LITERAL_FINAL
case|:
break|break;
case|case
name|RELAX_SLOTS
case|:
if|if
condition|(
name|vbuf
operator|==
name|NULL
condition|)
name|vbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|vbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragp
operator|->
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|vbuf
argument_list|)
expr_stmt|;
name|num_slots
operator|=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
switch|switch
condition|(
name|fragp
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
condition|)
block|{
case|case
name|RELAX_NARROW
case|:
name|convert_frag_narrow
argument_list|(
name|sec
argument_list|,
name|fragp
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_IMMED
case|:
case|case
name|RELAX_IMMED_STEP1
case|:
case|case
name|RELAX_IMMED_STEP2
case|:
case|case
name|RELAX_IMMED_STEP3
case|:
comment|/* Place the immediate.  */
name|convert_frag_immed
argument_list|(
name|sec
argument_list|,
name|fragp
argument_list|,
name|fragp
operator|->
name|tc_frag_data
operator|.
name|slot_subtypes
index|[
name|slot
index|]
operator|-
name|RELAX_IMMED
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This is OK because some slots could have 		 relaxations and others have none.  */
break|break;
block|}
block|}
break|break;
case|case
name|RELAX_UNREACHABLE
case|:
name|memset
argument_list|(
operator|&
name|fragp
operator|->
name|fr_literal
index|[
name|fragp
operator|->
name|fr_fix
index|]
argument_list|,
literal|0
argument_list|,
name|fragp
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|-=
name|fragp
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
name|frag_wane
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_MAYBE_UNREACHABLE
case|:
case|case
name|RELAX_MAYBE_DESIRE_ALIGN
case|:
name|frag_wane
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_FILL_NOP
case|:
name|convert_frag_fill_nop
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAX_LITERAL_NR
case|:
if|if
condition|(
name|use_literal_section
condition|)
block|{
comment|/* This should have been handled during relaxation.  When 	     relaxing a code segment, literals sometimes need to be 	     added to the corresponding literal segment.  If that 	     literal segment has already been relaxed, then we end up 	     in this situation.  Marking the literal segments as data 	     would make this happen less often (since GAS always relaxes 	     code before data), but we could still get into trouble if 	     there are instructions in a segment that is not marked as 	     containing code.  Until we can implement a better solution, 	     cheat and adjust the addresses of all the following frags. 	     This could break subsequent alignments, but the linker's 	     literal coalescing will do that anyway.  */
name|fragS
modifier|*
name|f
decl_stmt|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_LITERAL_FINAL
expr_stmt|;
name|assert
argument_list|(
name|fragp
operator|->
name|tc_frag_data
operator|.
name|unreported_expansion
operator|==
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fragp
operator|->
name|fr_literal
index|[
name|fragp
operator|->
name|fr_fix
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|-=
literal|4
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fragp
operator|->
name|fr_next
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
name|f
operator|->
name|fr_address
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid relaxation fragment result"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragp
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|new_logical_line
argument_list|(
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_frag_align_next_opcode
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
name|char
modifier|*
name|nop_buf
decl_stmt|;
comment|/* Location for Writing.  */
name|bfd_boolean
name|use_no_density
init|=
name|fragp
operator|->
name|tc_frag_data
operator|.
name|is_no_density
decl_stmt|;
name|addressT
name|aligned_address
decl_stmt|;
name|offsetT
name|fill_size
decl_stmt|;
name|int
name|nop
decl_stmt|,
name|nop_count
decl_stmt|;
name|aligned_address
operator|=
name|get_noop_aligned_address
argument_list|(
name|fragp
argument_list|,
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fill_size
operator|=
name|aligned_address
operator|-
operator|(
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
operator|)
expr_stmt|;
name|nop_count
operator|=
name|get_text_align_nop_count
argument_list|(
name|fill_size
argument_list|,
name|use_no_density
argument_list|)
expr_stmt|;
name|nop_buf
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
for|for
control|(
name|nop
operator|=
literal|0
init|;
name|nop
operator|<
name|nop_count
condition|;
name|nop
operator|++
control|)
block|{
name|int
name|nop_size
decl_stmt|;
name|nop_size
operator|=
name|get_text_align_nth_nop_size
argument_list|(
name|fill_size
argument_list|,
name|nop
argument_list|,
name|use_no_density
argument_list|)
expr_stmt|;
name|assemble_nop
argument_list|(
name|nop_size
argument_list|,
name|nop_buf
argument_list|)
expr_stmt|;
name|nop_buf
operator|+=
name|nop_size
expr_stmt|;
block|}
name|fragp
operator|->
name|fr_fix
operator|+=
name|fill_size
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|-=
name|fill_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_frag_narrow
parameter_list|(
name|segT
name|segP
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|TInsn
name|tinsn
decl_stmt|,
name|single_target
decl_stmt|;
name|int
name|size
decl_stmt|,
name|old_size
decl_stmt|,
name|diff
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
name|assert
argument_list|(
name|slot
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|tinsn
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_aligning_branch
operator|==
literal|1
condition|)
block|{
name|assert
argument_list|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|==
literal|1
operator|||
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|convert_frag_immed
argument_list|(
name|segP
argument_list|,
name|fragP
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* No conversion.  */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|fragP
operator|->
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Frags in this relaxation state should only contain      single instruction bundles.  */
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|tinsn
argument_list|,
name|fragP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just convert it to a wide form....  */
name|size
operator|=
literal|0
expr_stmt|;
name|old_size
operator|=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|single_target
argument_list|)
expr_stmt|;
name|frag_offset
operator|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
if|if
condition|(
operator|!
name|xg_is_single_relaxable_insn
argument_list|(
operator|&
name|tinsn
argument_list|,
operator|&
name|single_target
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unable to widen instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|xg_get_single_size
argument_list|(
name|single_target
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|xg_emit_insn_to_buf
argument_list|(
operator|&
name|single_target
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|diff
operator|=
name|size
operator|-
name|old_size
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|<=
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|diff
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|diff
expr_stmt|;
comment|/* clean it up */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_frag_fill_nop
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|char
modifier|*
name|loc
init|=
operator|&
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
index|]
decl_stmt|;
name|int
name|size
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
decl_stmt|;
name|assert
argument_list|(
operator|(
name|unsigned
operator|)
name|size
operator|==
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* No conversion.  */
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|assemble_nop
argument_list|(
name|size
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|size
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|fixS
modifier|*
name|fix_new_exp_in_seg
parameter_list|(
name|segT
parameter_list|,
name|subsegT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_frag_immed_finish_loop
parameter_list|(
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|TInsn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|convert_frag_immed
parameter_list|(
name|segT
name|segP
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|int
name|min_steps
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|char
modifier|*
name|immed_instr
init|=
name|fragP
operator|->
name|fr_opcode
decl_stmt|;
name|TInsn
name|orig_tinsn
decl_stmt|;
name|bfd_boolean
name|expanded
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|branch_jmp_to_next
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|fr_opcode
init|=
name|fragP
operator|->
name|fr_opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|bfd_boolean
name|wide_insn
init|=
name|FALSE
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|bfd_boolean
name|is_loop
decl_stmt|;
name|assert
argument_list|(
name|fr_opcode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xg_clear_vinsn
argument_list|(
operator|&
name|cur_vinsn
argument_list|)
expr_stmt|;
name|vinsn_from_chars
argument_list|(
operator|&
name|cur_vinsn
argument_list|,
name|fr_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_vinsn
operator|.
name|num_slots
operator|>
literal|1
condition|)
name|wide_insn
operator|=
name|TRUE
expr_stmt|;
name|orig_tinsn
operator|=
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|orig_tinsn
argument_list|,
name|fragP
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|is_loop
operator|=
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|orig_tinsn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
expr_stmt|;
if|if
condition|(
name|workaround_b_j_loop_end
operator|&&
operator|!
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|branch_jmp_to_next
operator|=
name|is_branch_jmp_to_next
argument_list|(
operator|&
name|orig_tinsn
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_jmp_to_next
operator|&&
operator|!
name|next_frag_is_loop_target
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
comment|/* Conversion just inserts a NOP and marks the fix as completed.  */
name|bytes
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|4
condition|)
block|{
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|isa
argument_list|,
name|cur_vinsn
operator|.
name|format
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|+=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
name|assert
argument_list|(
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|3
argument_list|)
expr_stmt|;
name|build_nop
argument_list|(
operator|&
name|cur_vinsn
operator|.
name|slots
index|[
literal|0
index|]
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
block|}
name|vinsn_to_insnbuf
argument_list|(
operator|&
name|cur_vinsn
argument_list|,
name|fr_opcode
argument_list|,
name|frag_now
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|cur_vinsn
operator|.
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fr_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Here is the fun stuff:  Get the immediate field from this 	 instruction.  If it fits, we're done.  If not, find the next 	 instruction sequence that fits.  */
name|IStack
name|istack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbolS
modifier|*
name|lit_sym
init|=
name|NULL
decl_stmt|;
name|int
name|total_size
init|=
literal|0
decl_stmt|;
name|int
name|target_offset
init|=
literal|0
decl_stmt|;
name|int
name|old_size
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|symbolS
modifier|*
name|gen_label
init|=
name|NULL
decl_stmt|;
name|offsetT
name|frag_offset
decl_stmt|;
name|bfd_boolean
name|first
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|last_is_jump
decl_stmt|;
comment|/* It does not fit.  Find something that does and          convert immediately.  */
name|frag_offset
operator|=
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
expr_stmt|;
name|istack_init
argument_list|(
operator|&
name|istack
argument_list|)
expr_stmt|;
name|xg_assembly_relax
argument_list|(
operator|&
name|istack
argument_list|,
operator|&
name|orig_tinsn
argument_list|,
name|segP
argument_list|,
name|fragP
argument_list|,
name|frag_offset
argument_list|,
name|min_steps
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* Assemble this right inline.  */
comment|/* First, create the mapping from a label name to the REAL label.  */
name|target_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
name|fragS
modifier|*
name|lit_frag
decl_stmt|;
switch|switch
condition|(
name|tinsn
operator|->
name|insn_type
condition|)
block|{
case|case
name|ITYPE_LITERAL
case|:
if|if
condition|(
name|lit_sym
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple literals in expansion"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First find the appropriate space in the literal pool.  */
name|lit_frag
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frags
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|lit_frag
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no registered fragment for literal"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|ntok
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"number of literal tokens != 1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the literal symbol and add a fixup.  */
name|lit_sym
operator|=
name|lit_frag
operator|->
name|fr_symbol
expr_stmt|;
break|break;
case|case
name|ITYPE_LABEL
case|:
if|if
condition|(
name|align_targets
operator|&&
operator|!
name|is_loop
condition|)
block|{
name|fragS
modifier|*
name|unreach
init|=
name|fragP
operator|->
name|fr_next
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|unreach
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|unreach
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_UNREACHABLE
operator|||
name|unreach
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
operator|)
operator|)
condition|)
block|{
name|unreach
operator|=
name|unreach
operator|->
name|fr_next
expr_stmt|;
block|}
name|assert
argument_list|(
name|unreach
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
operator|&&
operator|(
name|unreach
operator|->
name|fr_subtype
operator|==
name|RELAX_MAYBE_UNREACHABLE
operator|||
name|unreach
operator|->
name|fr_subtype
operator|==
name|RELAX_UNREACHABLE
operator|)
argument_list|)
expr_stmt|;
name|target_offset
operator|+=
name|unreach
operator|->
name|tc_frag_data
operator|.
name|text_expansion
index|[
literal|0
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|gen_label
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|gen_label
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
name|target_offset
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITYPE_INSN
case|:
if|if
condition|(
name|first
operator|&&
name|wide_insn
condition|)
block|{
name|target_offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|opcode_fits_format_slot
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
condition|)
name|target_offset
operator|+=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
name|target_offset
operator|+=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|total_size
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
name|last_is_jump
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|.
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|istack
operator|.
name|insn
index|[
name|i
index|]
decl_stmt|;
name|fragS
modifier|*
name|lit_frag
decl_stmt|;
name|int
name|size
decl_stmt|;
name|segT
name|target_seg
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc_type
decl_stmt|;
switch|switch
condition|(
name|tinsn
operator|->
name|insn_type
condition|)
block|{
case|case
name|ITYPE_LITERAL
case|:
name|lit_frag
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|literal_frags
index|[
name|slot
index|]
expr_stmt|;
comment|/* Already checked.  */
name|assert
argument_list|(
name|lit_frag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lit_sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tinsn
operator|->
name|ntok
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* Add a fixup.  */
name|target_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|lit_sym
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|target_seg
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|map_operator_to_reloc
argument_list|(
name|tinsn
operator|->
name|tok
index|[
literal|0
index|]
operator|.
name|X_op
argument_list|)
expr_stmt|;
name|fix_new_exp_in_seg
argument_list|(
name|target_seg
argument_list|,
literal|0
argument_list|,
name|lit_frag
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
operator|&
name|tinsn
operator|->
name|tok
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITYPE_LABEL
case|:
break|break;
case|case
name|ITYPE_INSN
case|:
name|xg_resolve_labels
argument_list|(
name|tinsn
argument_list|,
name|gen_label
argument_list|)
expr_stmt|;
name|xg_resolve_literals
argument_list|(
name|tinsn
argument_list|,
name|lit_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_insn
operator|&&
name|first
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|opcode_fits_format_slot
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
condition|)
block|{
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
operator|=
operator|*
name|tinsn
expr_stmt|;
block|}
else|else
block|{
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|opcode
operator|=
name|xtensa_format_slot_nop_opcode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|cur_vinsn
operator|.
name|slots
index|[
name|slot
index|]
operator|.
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
name|vinsn_to_insnbuf
argument_list|(
operator|&
name|cur_vinsn
argument_list|,
name|immed_instr
argument_list|,
name|fragP
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|cur_vinsn
operator|.
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|immed_instr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opcode_fits_format_slot
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|)
condition|)
block|{
name|xg_emit_insn_to_buf
argument_list|(
name|tinsn
argument_list|,
name|immed_instr
operator|+
name|size
argument_list|,
name|fragP
argument_list|,
name|immed_instr
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
name|size
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|size
operator|+=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|xg_emit_insn_to_buf
argument_list|(
name|tinsn
argument_list|,
name|immed_instr
argument_list|,
name|fragP
argument_list|,
name|immed_instr
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|immed_instr
operator|+=
name|size
expr_stmt|;
name|total_size
operator|+=
name|size
expr_stmt|;
break|break;
block|}
block|}
name|diff
operator|=
name|total_size
operator|-
name|old_size
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
name|expanded
operator|=
name|TRUE
expr_stmt|;
name|assert
argument_list|(
name|diff
operator|<=
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|-=
name|diff
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|diff
expr_stmt|;
block|}
comment|/* Check for undefined immediates in LOOP instructions.  */
if|if
condition|(
name|is_loop
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|orig_tinsn
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unresolved loop target symbol: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|=
name|orig_tinsn
operator|.
name|tok
index|[
literal|1
index|]
operator|.
name|X_op_symbol
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unresolved loop target symbol: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|expanded
operator|&&
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|orig_tinsn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
condition|)
name|convert_frag_immed_finish_loop
argument_list|(
name|segP
argument_list|,
name|fragP
argument_list|,
operator|&
name|orig_tinsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
operator|&&
name|is_direct_call_opcode
argument_list|(
name|orig_tinsn
operator|.
name|opcode
argument_list|)
condition|)
block|{
comment|/* Add an expansion note on the expanded instruction.  */
name|fix_new_exp_in_seg
argument_list|(
name|now_seg
argument_list|,
literal|0
argument_list|,
name|fragP
argument_list|,
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|orig_tinsn
operator|.
name|tok
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_XTENSA_ASM_EXPAND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a new fix expression into the desired segment.  We have to    switch to that segment to do this.  */
end_comment

begin_function
specifier|static
name|fixS
modifier|*
name|fix_new_exp_in_seg
parameter_list|(
name|segT
name|new_seg
parameter_list|,
name|subsegT
name|new_subseg
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|bfd_reloc_code_real_type
name|r_type
parameter_list|)
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
name|segT
name|seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|subseg
init|=
name|now_subseg
decl_stmt|;
name|assert
argument_list|(
name|new_seg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|new_seg
argument_list|,
name|new_subseg
argument_list|)
expr_stmt|;
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
return|return
name|new_fix
return|;
block|}
end_function

begin_comment
comment|/* Relax a loop instruction so that it can span loop>256 bytes.                    loop    as, .L1           .L0:                   rsr     as, LEND                   wsr     as, LBEG                   addi    as, as, lo8 (label-.L1)                   addmi   as, as, mid8 (label-.L1)                   wsr     as, LEND                   isync                   rsr     as, LCOUNT                   addi    as, as, 1           .L1:<<body>>           label: */
end_comment

begin_function
specifier|static
name|void
name|convert_frag_immed_finish_loop
parameter_list|(
name|segT
name|segP
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|TInsn
modifier|*
name|tinsn
parameter_list|)
block|{
name|TInsn
name|loop_insn
decl_stmt|;
name|TInsn
name|addi_insn
decl_stmt|;
name|TInsn
name|addmi_insn
decl_stmt|;
name|unsigned
name|long
name|target
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|loop_length
decl_stmt|,
name|loop_length_hi
decl_stmt|,
name|loop_length_lo
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|addressT
name|loop_offset
decl_stmt|;
name|addressT
name|addi_offset
init|=
literal|9
decl_stmt|;
name|addressT
name|addmi_offset
init|=
literal|12
decl_stmt|;
name|fragS
modifier|*
name|next_fragP
decl_stmt|;
name|int
name|target_count
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Get the loop offset.  */
name|loop_offset
operator|=
name|get_expanded_loop_offset
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
comment|/* Validate that there really is a LOOP at the loop_offset.  Because      loops are not bundleable, we can assume that the instruction will be      in slot 0.  */
name|tinsn_from_chars
argument_list|(
operator|&
name|loop_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|loop_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tinsn_immed_from_frag
argument_list|(
operator|&
name|loop_insn
argument_list|,
name|fragP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xtensa_opcode_is_loop
argument_list|(
name|isa
argument_list|,
name|loop_insn
operator|.
name|opcode
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|addi_offset
operator|+=
name|loop_offset
expr_stmt|;
name|addmi_offset
operator|+=
name|loop_offset
expr_stmt|;
name|assert
argument_list|(
name|tinsn
operator|->
name|ntok
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|target
operator|=
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
expr_stmt|;
elseif|else
if|if
condition|(
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
comment|/* Find the fragment.  */
name|symbolS
modifier|*
name|sym
init|=
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_symbol
decl_stmt|;
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|segP
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|absolute_section
argument_list|)
expr_stmt|;
name|target
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|+
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_add_number
operator|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid expression evaluation type %d"
argument_list|)
argument_list|,
name|tinsn
operator|->
name|tok
index|[
literal|1
index|]
operator|.
name|X_op
argument_list|)
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
name|loop_length
operator|=
name|target
operator|-
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
expr_stmt|;
name|loop_length_hi
operator|=
name|loop_length
operator|&
operator|~
literal|0x0ff
expr_stmt|;
name|loop_length_lo
operator|=
name|loop_length
operator|&
literal|0x0ff
expr_stmt|;
if|if
condition|(
name|loop_length_lo
operator|>=
literal|128
condition|)
block|{
name|loop_length_lo
operator|-=
literal|256
expr_stmt|;
name|loop_length_hi
operator|+=
literal|256
expr_stmt|;
block|}
comment|/* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most      32512.  If the loop is larger than that, then we just fail.  */
if|if
condition|(
name|loop_length_hi
operator|>
literal|32512
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"loop too long for LOOP instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|addi_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addi_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addi_insn
operator|.
name|opcode
operator|==
name|xtensa_addi_opcode
argument_list|)
expr_stmt|;
name|tinsn_from_chars
argument_list|(
operator|&
name|addmi_insn
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|+
name|addmi_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addmi_insn
operator|.
name|opcode
operator|==
name|xtensa_addmi_opcode
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|addi_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
name|loop_length_lo
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|addi_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
operator|=
name|TRUE
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|+
name|addi_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_expr_const
argument_list|(
operator|&
name|addmi_insn
operator|.
name|tok
index|[
literal|2
index|]
argument_list|,
name|loop_length_hi
argument_list|)
expr_stmt|;
name|tinsn_to_insnbuf
argument_list|(
operator|&
name|addmi_insn
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
operator|+
name|addmi_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Walk through all of the frags from here to the loop end      and mark them as no_transform to keep them from being modified      by the linker.  If we ever have a relocation for the      addi/addmi of the difference of two symbols we can remove this.  */
name|target_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|next_fragP
operator|=
name|fragP
init|;
name|next_fragP
operator|!=
name|NULL
condition|;
name|next_fragP
operator|=
name|next_fragP
operator|->
name|fr_next
control|)
block|{
name|next_fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|next_fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|)
name|target_count
operator|++
expr_stmt|;
if|if
condition|(
name|target_count
operator|==
literal|2
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A map that keeps information on a per-subsegment basis.  This is    maintained during initial assembly, but is invalid once the    subsegments are smashed together.  I.E., it cannot be used during    the relaxation.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|subseg_map_struct
block|{
comment|/* the key */
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
comment|/* the data */
name|unsigned
name|flags
decl_stmt|;
name|float
name|total_freq
decl_stmt|;
comment|/* fall-through + branch target frequency */
name|float
name|target_freq
decl_stmt|;
comment|/* branch target frequency alone */
name|struct
name|subseg_map_struct
modifier|*
name|next
decl_stmt|;
block|}
name|subseg_map
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|subseg_map
modifier|*
name|sseg_map
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|subseg_map
modifier|*
name|get_subseg_info
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
decl_stmt|;
for|for
control|(
name|subseg_e
operator|=
name|sseg_map
init|;
name|subseg_e
condition|;
name|subseg_e
operator|=
name|subseg_e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|seg
operator|==
name|subseg_e
operator|->
name|seg
operator|&&
name|subseg
operator|==
name|subseg_e
operator|->
name|subseg
condition|)
break|break;
block|}
return|return
name|subseg_e
return|;
block|}
end_function

begin_function
specifier|static
name|subseg_map
modifier|*
name|add_subseg_info
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
operator|(
name|subseg_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|subseg_map
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|subseg_e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|subseg_map
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_e
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
name|subseg_e
operator|->
name|subseg
operator|=
name|subseg
expr_stmt|;
name|subseg_e
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Start off considering every branch target very important.  */
name|subseg_e
operator|->
name|target_freq
operator|=
literal|1.0
expr_stmt|;
name|subseg_e
operator|->
name|total_freq
operator|=
literal|1.0
expr_stmt|;
name|subseg_e
operator|->
name|next
operator|=
name|sseg_map
expr_stmt|;
name|sseg_map
operator|=
name|subseg_e
expr_stmt|;
return|return
name|subseg_e
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|get_last_insn_flags
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
name|get_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
decl_stmt|;
if|if
condition|(
name|subseg_e
condition|)
return|return
name|subseg_e
operator|->
name|flags
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_last_insn_flags
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|,
name|unsigned
name|fl
parameter_list|,
name|bfd_boolean
name|val
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
name|get_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subseg_e
condition|)
name|subseg_e
operator|=
name|add_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|subseg_e
operator|->
name|flags
operator||=
name|fl
expr_stmt|;
else|else
name|subseg_e
operator|->
name|flags
operator|&=
operator|~
name|fl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|float
name|get_subseg_total_freq
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
name|get_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
decl_stmt|;
if|if
condition|(
name|subseg_e
condition|)
return|return
name|subseg_e
operator|->
name|total_freq
return|;
return|return
literal|1.0
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|get_subseg_target_freq
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
name|get_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
decl_stmt|;
if|if
condition|(
name|subseg_e
condition|)
return|return
name|subseg_e
operator|->
name|target_freq
return|;
return|return
literal|1.0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_subseg_freq
parameter_list|(
name|segT
name|seg
parameter_list|,
name|subsegT
name|subseg
parameter_list|,
name|float
name|total_f
parameter_list|,
name|float
name|target_f
parameter_list|)
block|{
name|subseg_map
modifier|*
name|subseg_e
init|=
name|get_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subseg_e
condition|)
name|subseg_e
operator|=
name|add_subseg_info
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|subseg_e
operator|->
name|total_freq
operator|=
name|total_f
expr_stmt|;
name|subseg_e
operator|->
name|target_freq
operator|=
name|target_f
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Segment Lists and emit_state Stuff.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_move_seg_list_to_beginning
parameter_list|(
name|seg_list
modifier|*
name|head
parameter_list|)
block|{
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|segT
name|literal_section
init|=
name|head
operator|->
name|seg
decl_stmt|;
comment|/* Move the literal section to the front of the section list.  */
name|assert
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|literal_section
operator|!=
name|stdoutput
operator|->
name|sections
condition|)
block|{
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
name|bfd_section_list_prepend
argument_list|(
name|stdoutput
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|mark_literal_frags
parameter_list|(
name|seg_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xtensa_move_literals
parameter_list|(
name|void
parameter_list|)
block|{
name|seg_list
modifier|*
name|segment
decl_stmt|;
name|frchainS
modifier|*
name|frchain_from
decl_stmt|,
modifier|*
name|frchain_to
decl_stmt|;
name|fragS
modifier|*
name|search_frag
decl_stmt|,
modifier|*
name|next_frag
decl_stmt|,
modifier|*
name|last_frag
decl_stmt|,
modifier|*
name|literal_pool
decl_stmt|,
modifier|*
name|insert_after
decl_stmt|;
name|fragS
modifier|*
modifier|*
name|frag_splice
decl_stmt|;
name|emit_state
name|state
decl_stmt|;
name|segT
name|dest_seg
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|,
modifier|*
name|next_fix
decl_stmt|,
modifier|*
modifier|*
name|fix_splice
decl_stmt|;
name|sym_list
modifier|*
name|lit
decl_stmt|;
name|mark_literal_frags
argument_list|(
name|literal_head
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_literal_section
condition|)
return|return;
for|for
control|(
name|segment
operator|=
name|literal_head
operator|->
name|next
init|;
name|segment
condition|;
name|segment
operator|=
name|segment
operator|->
name|next
control|)
block|{
comment|/* Keep the literals for .init and .fini in separate sections.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
argument_list|,
name|INIT_SECTION_NAME
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
argument_list|,
name|FINI_SECTION_NAME
argument_list|)
condition|)
continue|continue;
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|search_frag
operator|=
name|frchain_from
operator|->
name|frch_root
expr_stmt|;
name|literal_pool
operator|=
name|NULL
expr_stmt|;
name|frchain_to
operator|=
name|NULL
expr_stmt|;
name|frag_splice
operator|=
operator|&
operator|(
name|frchain_from
operator|->
name|frch_root
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
condition|)
block|{
name|assert
argument_list|(
name|search_frag
operator|->
name|fr_fix
operator|==
literal|0
operator|||
name|search_frag
operator|->
name|fr_type
operator|==
name|rs_align
argument_list|)
expr_stmt|;
name|search_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|assert
argument_list|(
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL_POOL_BEGIN
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
operator|&
name|state
argument_list|,
name|segment
operator|->
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that all the frags in this series are closed, and 	 that there is at least one left over of zero-size.  This 	 prevents us from making a segment with an frchain without any 	 frags in it.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|last_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
while|while
condition|(
name|search_frag
operator|!=
name|frag_now
condition|)
block|{
name|next_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
comment|/* First, move the frag out of the literal section and 	     to the appropriate place.  */
if|if
condition|(
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
condition|)
block|{
name|literal_pool
operator|=
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
name|assert
argument_list|(
name|literal_pool
operator|->
name|fr_subtype
operator|==
name|RELAX_LITERAL_POOL_BEGIN
argument_list|)
expr_stmt|;
name|frchain_to
operator|=
name|literal_pool
operator|->
name|tc_frag_data
operator|.
name|lit_frchain
expr_stmt|;
name|assert
argument_list|(
name|frchain_to
argument_list|)
expr_stmt|;
block|}
name|insert_after
operator|=
name|literal_pool
operator|->
name|tc_frag_data
operator|.
name|literal_frag
expr_stmt|;
name|dest_seg
operator|=
name|insert_after
operator|->
name|fr_next
operator|->
name|tc_frag_data
operator|.
name|lit_seg
expr_stmt|;
operator|*
name|frag_splice
operator|=
name|next_frag
expr_stmt|;
name|search_frag
operator|->
name|fr_next
operator|=
name|insert_after
operator|->
name|fr_next
expr_stmt|;
name|insert_after
operator|->
name|fr_next
operator|=
name|search_frag
expr_stmt|;
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|lit_seg
operator|=
name|dest_seg
expr_stmt|;
name|literal_pool
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|search_frag
expr_stmt|;
comment|/* Now move any fixups associated with this frag to the 	     right section.  */
name|fix
operator|=
name|frchain_from
operator|->
name|fix_root
expr_stmt|;
name|fix_splice
operator|=
operator|&
operator|(
name|frchain_from
operator|->
name|fix_root
operator|)
expr_stmt|;
while|while
condition|(
name|fix
condition|)
block|{
name|next_fix
operator|=
name|fix
operator|->
name|fx_next
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_frag
operator|==
name|search_frag
condition|)
block|{
operator|*
name|fix_splice
operator|=
name|next_fix
expr_stmt|;
name|fix
operator|->
name|fx_next
operator|=
name|frchain_to
operator|->
name|fix_root
expr_stmt|;
name|frchain_to
operator|->
name|fix_root
operator|=
name|fix
expr_stmt|;
if|if
condition|(
name|frchain_to
operator|->
name|fix_tail
operator|==
name|NULL
condition|)
name|frchain_to
operator|->
name|fix_tail
operator|=
name|fix
expr_stmt|;
block|}
else|else
name|fix_splice
operator|=
operator|&
operator|(
name|fix
operator|->
name|fx_next
operator|)
expr_stmt|;
name|fix
operator|=
name|next_fix
expr_stmt|;
block|}
name|search_frag
operator|=
name|next_frag
expr_stmt|;
block|}
if|if
condition|(
name|frchain_from
operator|->
name|fix_root
operator|!=
name|NULL
condition|)
block|{
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"fixes not all moved from %s"
argument_list|)
argument_list|,
name|segment
operator|->
name|seg
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|frchain_from
operator|->
name|fix_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|frchain_from
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|xtensa_restore_emit_state
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Now fix up the SEGMENT value for all the literal symbols.  */
for|for
control|(
name|lit
operator|=
name|literal_syms
init|;
name|lit
condition|;
name|lit
operator|=
name|lit
operator|->
name|next
control|)
block|{
name|symbolS
modifier|*
name|lit_sym
init|=
name|lit
operator|->
name|sym
decl_stmt|;
name|segT
name|dest_seg
init|=
name|symbol_get_frag
argument_list|(
name|lit_sym
argument_list|)
operator|->
name|tc_frag_data
operator|.
name|lit_seg
decl_stmt|;
if|if
condition|(
name|dest_seg
condition|)
name|S_SET_SEGMENT
argument_list|(
name|lit_sym
argument_list|,
name|dest_seg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk over all the frags for segments in a list and mark them as    containing literals.  As clunky as this is, we can't rely on frag_var    and frag_variant to get called in all situations.  */
end_comment

begin_function
specifier|static
name|void
name|mark_literal_frags
parameter_list|(
name|seg_list
modifier|*
name|segment
parameter_list|)
block|{
name|frchainS
modifier|*
name|frchain_from
decl_stmt|;
name|fragS
modifier|*
name|search_frag
decl_stmt|;
while|while
condition|(
name|segment
condition|)
block|{
name|frchain_from
operator|=
name|seg_info
argument_list|(
name|segment
operator|->
name|seg
argument_list|)
operator|->
name|frchainP
expr_stmt|;
name|search_frag
operator|=
name|frchain_from
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|search_frag
condition|)
block|{
name|search_frag
operator|->
name|tc_frag_data
operator|.
name|is_literal
operator|=
name|TRUE
expr_stmt|;
name|search_frag
operator|=
name|search_frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|segment
operator|=
name|segment
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_reorder_seg_list
parameter_list|(
name|seg_list
modifier|*
name|head
parameter_list|,
name|segT
name|after
parameter_list|)
block|{
comment|/* Move all of the sections in the section list to come      after "after" in the gnu segment list.  */
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|segT
name|literal_section
init|=
name|head
operator|->
name|seg
decl_stmt|;
comment|/* Move the literal section after "after".  */
name|assert
argument_list|(
name|literal_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|literal_section
operator|!=
name|after
condition|)
block|{
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
name|bfd_section_list_insert_after
argument_list|(
name|stdoutput
argument_list|,
name|after
argument_list|,
name|literal_section
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push all the literal segments to the end of the gnu list.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_reorder_segments
parameter_list|(
name|void
parameter_list|)
block|{
name|segT
name|sec
decl_stmt|;
name|segT
name|last_sec
init|=
literal|0
decl_stmt|;
name|int
name|old_count
init|=
literal|0
decl_stmt|;
name|int
name|new_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|last_sec
operator|=
name|sec
expr_stmt|;
name|old_count
operator|++
expr_stmt|;
block|}
comment|/* Now that we have the last section, push all the literal      sections to the end.  */
name|xtensa_reorder_seg_list
argument_list|(
name|literal_head
argument_list|,
name|last_sec
argument_list|)
expr_stmt|;
comment|/* Now perform the final error check.  */
for|for
control|(
name|sec
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
name|new_count
operator|++
expr_stmt|;
name|assert
argument_list|(
name|new_count
operator|==
name|old_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the emit state (seg, subseg, and frag related stuff) to the    correct location.  Return a emit_state which can be passed to    xtensa_restore_emit_state to return to current fragment.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_switch_to_literal_fragment
parameter_list|(
name|emit_state
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|directive_state
index|[
name|directive_absolute_literals
index|]
condition|)
block|{
name|segT
name|lit4_seg
init|=
name|cache_literal_section
argument_list|(
name|TRUE
argument_list|)
decl_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
name|result
argument_list|,
name|lit4_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|xtensa_switch_to_non_abs_literal_fragment
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Do a 4-byte align here.  */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_switch_to_non_abs_literal_fragment
parameter_list|(
name|emit_state
modifier|*
name|result
parameter_list|)
block|{
specifier|static
name|bfd_boolean
name|recursive
init|=
name|FALSE
decl_stmt|;
name|fragS
modifier|*
name|pool_location
init|=
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|segT
name|lit_seg
decl_stmt|;
name|bfd_boolean
name|is_init
init|=
operator|(
name|now_seg
operator|&&
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|INIT_SECTION_NAME
argument_list|)
operator|)
decl_stmt|;
name|bfd_boolean
name|is_fini
init|=
operator|(
name|now_seg
operator|&&
operator|!
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|FINI_SECTION_NAME
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|pool_location
operator|==
name|NULL
operator|&&
operator|!
name|use_literal_section
operator|&&
operator|!
name|recursive
operator|&&
operator|!
name|is_init
operator|&&
operator|!
name|is_fini
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"literal pool location required for text-section-literals; specify with .literal_position"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When we mark a literal pool location, we want to put a frag in 	 the literal pool that points to it.  But to do that, we want to 	 switch_to_literal_fragment.  But literal sections don't have 	 literal pools, so their location is always null, so we would 	 recurse forever.  This is kind of hacky, but it works.  */
name|recursive
operator|=
name|TRUE
expr_stmt|;
name|xtensa_mark_literal_pool_location
argument_list|()
expr_stmt|;
name|recursive
operator|=
name|FALSE
expr_stmt|;
block|}
name|lit_seg
operator|=
name|cache_literal_section
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|xtensa_switch_section_emit_state
argument_list|(
name|result
argument_list|,
name|lit_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_literal_section
operator|&&
operator|!
name|is_init
operator|&&
operator|!
name|is_fini
operator|&&
name|get_literal_pool_location
argument_list|(
name|now_seg
argument_list|)
operator|!=
name|pool_location
condition|)
block|{
comment|/* Close whatever frag is there.  */
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|tc_frag_data
operator|.
name|literal_frag
operator|=
name|pool_location
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_fill
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xtensa_set_frag_assembly_state
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this function before emitting data into the literal section.    This is a helper function for xtensa_switch_to_literal_fragment.    This is similar to a .section new_now_seg subseg. */
end_comment

begin_function
specifier|static
name|void
name|xtensa_switch_section_emit_state
parameter_list|(
name|emit_state
modifier|*
name|state
parameter_list|,
name|segT
name|new_now_seg
parameter_list|,
name|subsegT
name|new_now_subseg
parameter_list|)
block|{
name|state
operator|->
name|name
operator|=
name|now_seg
operator|->
name|name
expr_stmt|;
name|state
operator|->
name|now_seg
operator|=
name|now_seg
expr_stmt|;
name|state
operator|->
name|now_subseg
operator|=
name|now_subseg
expr_stmt|;
name|state
operator|->
name|generating_literals
operator|=
name|generating_literals
expr_stmt|;
name|generating_literals
operator|++
expr_stmt|;
name|subseg_set
argument_list|(
name|new_now_seg
argument_list|,
name|new_now_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use to restore the emitting into the normal place.  */
end_comment

begin_function
specifier|static
name|void
name|xtensa_restore_emit_state
parameter_list|(
name|emit_state
modifier|*
name|state
parameter_list|)
block|{
name|generating_literals
operator|=
name|state
operator|->
name|generating_literals
expr_stmt|;
name|subseg_set
argument_list|(
name|state
operator|->
name|now_seg
argument_list|,
name|state
operator|->
name|now_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predicate function used to look up a section in a particular group.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|match_section_group
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|gname
init|=
name|inf
decl_stmt|;
specifier|const
name|char
modifier|*
name|group_name
init|=
name|elf_group_name
argument_list|(
name|sec
argument_list|)
decl_stmt|;
return|return
operator|(
name|group_name
operator|==
name|gname
operator|||
operator|(
name|group_name
operator|!=
name|NULL
operator|&&
name|gname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|group_name
argument_list|,
name|gname
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the literal section to be used for the current text section.    The result may be cached in the default_lit_sections structure.  */
end_comment

begin_function
specifier|static
name|segT
name|cache_literal_section
parameter_list|(
name|bfd_boolean
name|use_abs_literals
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text_name
decl_stmt|,
modifier|*
name|group_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|base_name
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|segT
modifier|*
name|pcached
decl_stmt|;
name|segT
name|seg
decl_stmt|,
name|current_section
decl_stmt|;
name|int
name|current_subsec
decl_stmt|;
name|bfd_boolean
name|linkonce
init|=
name|FALSE
decl_stmt|;
comment|/* Save the current section/subsection.  */
name|current_section
operator|=
name|now_seg
expr_stmt|;
name|current_subsec
operator|=
name|now_subseg
expr_stmt|;
comment|/* Clear the cached values if they are no longer valid.  */
if|if
condition|(
name|now_seg
operator|!=
name|default_lit_sections
operator|.
name|current_text_seg
condition|)
block|{
name|default_lit_sections
operator|.
name|current_text_seg
operator|=
name|now_seg
expr_stmt|;
name|default_lit_sections
operator|.
name|lit_seg
operator|=
name|NULL
expr_stmt|;
name|default_lit_sections
operator|.
name|lit4_seg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check if the literal section is already cached.  */
if|if
condition|(
name|use_abs_literals
condition|)
name|pcached
operator|=
operator|&
name|default_lit_sections
operator|.
name|lit4_seg
expr_stmt|;
else|else
name|pcached
operator|=
operator|&
name|default_lit_sections
operator|.
name|lit_seg
expr_stmt|;
if|if
condition|(
operator|*
name|pcached
condition|)
return|return
operator|*
name|pcached
return|;
name|text_name
operator|=
name|default_lit_sections
operator|.
name|lit_prefix
expr_stmt|;
if|if
condition|(
operator|!
name|text_name
operator|||
operator|!
operator|*
name|text_name
condition|)
block|{
name|text_name
operator|=
name|segment_name
argument_list|(
name|current_section
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|elf_group_name
argument_list|(
name|current_section
argument_list|)
expr_stmt|;
name|linkonce
operator|=
operator|(
name|current_section
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
name|base_name
operator|=
name|use_abs_literals
condition|?
literal|".lit4"
else|:
literal|".literal"
expr_stmt|;
if|if
condition|(
name|group_name
condition|)
block|{
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|base_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|group_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s.%s"
argument_list|,
name|base_name
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|text_name
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suffix
operator|=
name|strchr
argument_list|(
name|text_name
operator|+
name|linkonce_len
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|linkonce_len
operator|+
name|strlen
argument_list|(
name|base_name
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|suffix
condition|?
name|strlen
argument_list|(
name|suffix
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|linkonce
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* If the section name ends with ".text", then replace that suffix 	 instead of appending an additional suffix.  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|text_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|5
operator|&&
name|strcmp
argument_list|(
name|text_name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
literal|5
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|strlen
argument_list|(
name|base_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
name|len
argument_list|,
name|base_name
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize section names to allow renaming literal sections.      The group name, if any, came from the current text section and      has already been canonicalized.  */
name|name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|seg
operator|=
name|bfd_get_section_by_name_if
argument_list|(
name|stdoutput
argument_list|,
name|name
argument_list|,
name|match_section_group
argument_list|,
operator|(
name|void
operator|*
operator|)
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|seg
operator|=
name|subseg_force_new
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_abs_literals
condition|)
block|{
comment|/* Add the newly created literal segment to the list.  */
name|seg_list
modifier|*
name|n
init|=
operator|(
name|seg_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|seg_list
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|literal_head
operator|->
name|next
expr_stmt|;
name|literal_head
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
operator|(
name|linkonce
condition|?
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|use_abs_literals
condition|?
name|SEC_DATA
else|:
name|SEC_CODE
operator|)
operator|)
expr_stmt|;
name|elf_group_name
argument_list|(
name|seg
argument_list|)
operator|=
name|group_name
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|pcached
operator|=
name|seg
expr_stmt|;
name|subseg_set
argument_list|(
name|current_section
argument_list|,
name|current_subsec
argument_list|)
expr_stmt|;
return|return
name|seg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Property Tables Stuff.  */
end_comment

begin_define
define|#
directive|define
name|XTENSA_INSN_SEC_NAME
value|".xt.insn"
end_define

begin_define
define|#
directive|define
name|XTENSA_LIT_SEC_NAME
value|".xt.lit"
end_define

begin_define
define|#
directive|define
name|XTENSA_PROP_SEC_NAME
value|".xt.prop"
end_define

begin_typedef
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|frag_predicate
function_decl|)
parameter_list|(
specifier|const
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|frag_flags_fn
function_decl|)
parameter_list|(
specifier|const
name|fragS
modifier|*
parameter_list|,
name|frag_flags
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|bfd_boolean
name|get_frag_is_literal
parameter_list|(
specifier|const
name|fragS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_create_property_segments
parameter_list|(
name|frag_predicate
parameter_list|,
name|frag_predicate
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|xt_section_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_create_xproperty_segments
parameter_list|(
name|frag_flags_fn
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|xt_section_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segment_info_type
modifier|*
name|retrieve_segment_info
parameter_list|(
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|section_has_property
parameter_list|(
name|segT
parameter_list|,
name|frag_predicate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|section_has_xproperty
parameter_list|(
name|segT
parameter_list|,
name|frag_flags_fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_xt_block_frags
parameter_list|(
name|segT
parameter_list|,
name|segT
parameter_list|,
name|xtensa_block_info
modifier|*
modifier|*
parameter_list|,
name|frag_predicate
parameter_list|,
name|frag_predicate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|xtensa_frag_flags_is_empty
parameter_list|(
specifier|const
name|frag_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtensa_frag_flags_init
parameter_list|(
name|frag_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_frag_property_flags
parameter_list|(
specifier|const
name|fragS
modifier|*
parameter_list|,
name|frag_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|frag_flags_to_number
parameter_list|(
specifier|const
name|frag_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_xt_prop_frags
parameter_list|(
name|segT
parameter_list|,
name|segT
parameter_list|,
name|xtensa_block_info
modifier|*
modifier|*
parameter_list|,
name|frag_flags_fn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set up property tables after relaxation.  */
end_comment

begin_function
name|void
name|xtensa_post_relax_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|xtensa_move_seg_list_to_beginning
argument_list|(
name|literal_head
argument_list|)
expr_stmt|;
name|xtensa_find_unmarked_state_frags
argument_list|()
expr_stmt|;
name|xtensa_mark_frags_for_org
argument_list|()
expr_stmt|;
name|xtensa_create_property_segments
argument_list|(
name|get_frag_is_literal
argument_list|,
name|NULL
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|xt_literal_sec
argument_list|)
expr_stmt|;
name|xtensa_create_xproperty_segments
argument_list|(
name|get_frag_property_flags
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|,
name|xt_prop_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_unaligned_branch_targets
condition|)
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|xtensa_find_unaligned_branch_targets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|xtensa_find_unaligned_loops
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is only meaningful after xtensa_move_literals.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_frag_is_literal
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|assert
argument_list|(
name|fragP
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_literal
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_create_property_segments
parameter_list|(
name|frag_predicate
name|property_function
parameter_list|,
name|frag_predicate
name|end_property_function
parameter_list|,
specifier|const
name|char
modifier|*
name|section_name_base
parameter_list|,
name|xt_section_type
name|sec_type
parameter_list|)
block|{
name|segT
modifier|*
name|seclist
decl_stmt|;
comment|/* Walk over all of the current segments.      Walk over each fragment      For each non-empty fragment,      Build a property record (append where possible).  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|section_has_property
argument_list|(
name|sec
argument_list|,
name|property_function
argument_list|)
condition|)
block|{
name|segT
name|insn_sec
init|=
name|xtensa_get_property_section
argument_list|(
name|sec
argument_list|,
name|section_name_base
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
init|=
name|retrieve_segment_info
argument_list|(
name|insn_sec
argument_list|)
decl_stmt|;
name|xtensa_block_info
modifier|*
modifier|*
name|xt_blocks
init|=
operator|&
name|xt_seg_info
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
decl_stmt|;
comment|/* Walk over all of the frchains here and add new sections.  */
name|add_xt_block_frags
argument_list|(
name|sec
argument_list|,
name|insn_sec
argument_list|,
name|xt_blocks
argument_list|,
name|property_function
argument_list|,
name|end_property_function
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we fill them out....  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|xtensa_block_info
modifier|*
name|block
decl_stmt|;
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|block
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|xtensa_block_info
modifier|*
name|cur_block
decl_stmt|;
comment|/* This is a section with some data.  */
name|int
name|num_recs
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|rec_size
decl_stmt|;
for|for
control|(
name|cur_block
operator|=
name|block
init|;
name|cur_block
condition|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
control|)
name|num_recs
operator|++
expr_stmt|;
name|rec_size
operator|=
name|num_recs
operator|*
literal|8
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|rec_size
argument_list|)
expr_stmt|;
comment|/* In order to make this work with the assembler, we have to 	     build some frags and then build the "fixups" for it.  It 	     would be easier to just set the contents then set the 	     arlents.  */
if|if
condition|(
name|num_recs
condition|)
block|{
comment|/* Allocate a fragment and leak it.  */
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|bfd_size_type
name|frag_size
decl_stmt|;
name|fixS
modifier|*
name|fixes
decl_stmt|;
name|frchainS
modifier|*
name|frchainP
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|frag_data
decl_stmt|;
name|frag_size
operator|=
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
operator|+
name|rec_size
expr_stmt|;
name|fragP
operator|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
name|frag_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fragP
argument_list|,
literal|0
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_address
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|=
name|rec_size
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
comment|/* The rest are zeros.  */
name|frchainP
operator|=
name|seginfo
operator|->
name|frchainP
expr_stmt|;
name|frchainP
operator|->
name|frch_root
operator|=
name|fragP
expr_stmt|;
name|frchainP
operator|->
name|frch_last
operator|=
name|fragP
expr_stmt|;
name|fixes
operator|=
operator|(
name|fixS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fixes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|fixes
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
operator|&
name|fixes
index|[
name|num_recs
operator|-
literal|1
index|]
expr_stmt|;
name|cur_block
operator|=
name|block
expr_stmt|;
name|frag_data
operator|=
operator|&
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_recs
condition|;
name|i
operator|++
control|)
block|{
name|fixS
modifier|*
name|fix
init|=
operator|&
name|fixes
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Write the fixup.  */
if|if
condition|(
name|i
operator|!=
name|num_recs
operator|-
literal|1
condition|)
name|fix
operator|->
name|fx_next
operator|=
operator|&
name|fixes
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|fix
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
name|fix
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fix
operator|->
name|fx_frag
operator|=
name|fragP
expr_stmt|;
name|fix
operator|->
name|fx_where
operator|=
name|i
operator|*
literal|8
expr_stmt|;
name|fix
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|cur_block
operator|->
name|sec
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_offset
operator|=
name|cur_block
operator|->
name|offset
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|fix
operator|->
name|fx_file
operator|=
literal|"Internal Assembly"
expr_stmt|;
name|fix
operator|->
name|fx_line
operator|=
literal|0
expr_stmt|;
comment|/* Write the length.  */
name|md_number_to_chars
argument_list|(
operator|&
name|frag_data
index|[
literal|4
operator|+
literal|8
operator|*
name|i
index|]
argument_list|,
name|cur_block
operator|->
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_create_xproperty_segments
parameter_list|(
name|frag_flags_fn
name|flag_fn
parameter_list|,
specifier|const
name|char
modifier|*
name|section_name_base
parameter_list|,
name|xt_section_type
name|sec_type
parameter_list|)
block|{
name|segT
modifier|*
name|seclist
decl_stmt|;
comment|/* Walk over all of the current segments.      Walk over each fragment.      For each fragment that has instructions,      build an instruction record (append where possible).  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|||
operator|(
name|flags
operator|&
name|SEC_MERGE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|section_has_xproperty
argument_list|(
name|sec
argument_list|,
name|flag_fn
argument_list|)
condition|)
block|{
name|segT
name|insn_sec
init|=
name|xtensa_get_property_section
argument_list|(
name|sec
argument_list|,
name|section_name_base
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
init|=
name|retrieve_segment_info
argument_list|(
name|insn_sec
argument_list|)
decl_stmt|;
name|xtensa_block_info
modifier|*
modifier|*
name|xt_blocks
init|=
operator|&
name|xt_seg_info
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
decl_stmt|;
comment|/* Walk over all of the frchains here and add new sections.  */
name|add_xt_prop_frags
argument_list|(
name|sec
argument_list|,
name|insn_sec
argument_list|,
name|xt_blocks
argument_list|,
name|flag_fn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we fill them out....  */
for|for
control|(
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
init|;
name|seclist
operator|&&
operator|*
name|seclist
condition|;
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|xtensa_block_info
modifier|*
name|block
decl_stmt|;
name|segT
name|sec
init|=
operator|*
name|seclist
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|block
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|blocks
index|[
name|sec_type
index|]
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|xtensa_block_info
modifier|*
name|cur_block
decl_stmt|;
comment|/* This is a section with some data.  */
name|int
name|num_recs
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|rec_size
decl_stmt|;
for|for
control|(
name|cur_block
operator|=
name|block
init|;
name|cur_block
condition|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
control|)
name|num_recs
operator|++
expr_stmt|;
name|rec_size
operator|=
name|num_recs
operator|*
operator|(
literal|8
operator|+
literal|4
operator|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|rec_size
argument_list|)
expr_stmt|;
comment|/* elf_section_data (sec)->this_hdr.sh_entsize = 12; */
comment|/* In order to make this work with the assembler, we have to build 	     some frags then build the "fixups" for it.  It would be easier to 	     just set the contents then set the arlents.  */
if|if
condition|(
name|num_recs
condition|)
block|{
comment|/* Allocate a fragment and (unfortunately) leak it.  */
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|bfd_size_type
name|frag_size
decl_stmt|;
name|fixS
modifier|*
name|fixes
decl_stmt|;
name|frchainS
modifier|*
name|frchainP
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|frag_data
decl_stmt|;
name|frag_size
operator|=
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
operator|+
name|rec_size
expr_stmt|;
name|fragP
operator|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
name|frag_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fragP
argument_list|,
literal|0
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_address
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|=
name|rec_size
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
comment|/* The rest are zeros.  */
name|frchainP
operator|=
name|seginfo
operator|->
name|frchainP
expr_stmt|;
name|frchainP
operator|->
name|frch_root
operator|=
name|fragP
expr_stmt|;
name|frchainP
operator|->
name|frch_last
operator|=
name|fragP
expr_stmt|;
name|fixes
operator|=
operator|(
name|fixS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fixes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
operator|*
name|num_recs
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|fixes
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
operator|&
name|fixes
index|[
name|num_recs
operator|-
literal|1
index|]
expr_stmt|;
name|cur_block
operator|=
name|block
expr_stmt|;
name|frag_data
operator|=
operator|&
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_recs
condition|;
name|i
operator|++
control|)
block|{
name|fixS
modifier|*
name|fix
init|=
operator|&
name|fixes
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Write the fixup.  */
if|if
condition|(
name|i
operator|!=
name|num_recs
operator|-
literal|1
condition|)
name|fix
operator|->
name|fx_next
operator|=
operator|&
name|fixes
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|fix
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
name|fix
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fix
operator|->
name|fx_frag
operator|=
name|fragP
expr_stmt|;
name|fix
operator|->
name|fx_where
operator|=
name|i
operator|*
operator|(
literal|8
operator|+
literal|4
operator|)
expr_stmt|;
name|fix
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|cur_block
operator|->
name|sec
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_offset
operator|=
name|cur_block
operator|->
name|offset
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|fix
operator|->
name|fx_file
operator|=
literal|"Internal Assembly"
expr_stmt|;
name|fix
operator|->
name|fx_line
operator|=
literal|0
expr_stmt|;
comment|/* Write the length.  */
name|md_number_to_chars
argument_list|(
operator|&
name|frag_data
index|[
literal|4
operator|+
operator|(
literal|8
operator|+
literal|4
operator|)
operator|*
name|i
index|]
argument_list|,
name|cur_block
operator|->
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|frag_data
index|[
literal|8
operator|+
operator|(
literal|8
operator|+
literal|4
operator|)
operator|*
name|i
index|]
argument_list|,
name|frag_flags_to_number
argument_list|(
operator|&
name|cur_block
operator|->
name|flags
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cur_block
operator|=
name|cur_block
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|segment_info_type
modifier|*
name|retrieve_segment_info
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|bfd_get_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
block|{
name|frchainS
modifier|*
name|frchainP
decl_stmt|;
name|seginfo
operator|=
operator|(
name|segment_info_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|seginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|bfd_section
operator|=
name|seg
expr_stmt|;
name|seginfo
operator|->
name|sym
operator|=
literal|0
expr_stmt|;
comment|/* We will not be dealing with these, only our special ones.  */
name|bfd_set_section_userdata
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|void
operator|*
operator|)
name|seginfo
argument_list|)
expr_stmt|;
name|frchainP
operator|=
operator|(
name|frchainS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|frchainS
argument_list|)
argument_list|)
expr_stmt|;
name|frchainP
operator|->
name|frch_root
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_last
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_next
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|frch_subseg
operator|=
literal|0
expr_stmt|;
name|frchainP
operator|->
name|fix_root
operator|=
name|NULL
expr_stmt|;
name|frchainP
operator|->
name|fix_tail
operator|=
name|NULL
expr_stmt|;
comment|/* Do not init the objstack.  */
comment|/* obstack_begin (&frchainP->frch_obstack, chunksize); */
comment|/* frchainP->frch_frag_now = fragP; */
name|frchainP
operator|->
name|frch_frag_now
operator|=
name|NULL
expr_stmt|;
name|seginfo
operator|->
name|frchainP
operator|=
name|frchainP
expr_stmt|;
block|}
return|return
name|seginfo
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|section_has_property
parameter_list|(
name|segT
name|sec
parameter_list|,
name|frag_predicate
name|property_function
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|property_function
argument_list|(
name|fragP
argument_list|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_fill
operator|||
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|section_has_xproperty
parameter_list|(
name|segT
name|sec
parameter_list|,
name|frag_flags_fn
name|property_function
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|frag_flags
name|prop_flags
decl_stmt|;
name|property_function
argument_list|(
name|fragP
argument_list|,
operator|&
name|prop_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_frag_flags_is_empty
argument_list|(
operator|&
name|prop_flags
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Two types of block sections exist right now: literal and insns.  */
end_comment

begin_function
specifier|static
name|void
name|add_xt_block_frags
parameter_list|(
name|segT
name|sec
parameter_list|,
name|segT
name|xt_block_sec
parameter_list|,
name|xtensa_block_info
modifier|*
modifier|*
name|xt_block
parameter_list|,
name|frag_predicate
name|property_function
parameter_list|,
name|frag_predicate
name|end_property_function
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seg_info
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
decl_stmt|;
name|bfd_vma
name|seg_offset
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|xt_seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|xt_block_sec
argument_list|)
expr_stmt|;
name|seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Build it if needed.  */
while|while
condition|(
operator|*
name|xt_block
operator|!=
name|NULL
condition|)
name|xt_block
operator|=
operator|&
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
expr_stmt|;
comment|/* We are either at NULL at the beginning or at the end.  */
comment|/* Walk through the frags.  */
name|seg_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg_info
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seg_info
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|property_function
argument_list|(
name|fragP
argument_list|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_fill
operator|||
name|fragP
operator|->
name|fr_fix
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|xt_block
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|offset
operator|+
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|size
operator|==
name|fragP
operator|->
name|fr_address
condition|)
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|size
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
else|else
name|xt_block
operator|=
operator|&
operator|(
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|xt_block
operator|==
name|NULL
condition|)
block|{
name|xtensa_block_info
modifier|*
name|new_block
init|=
operator|(
name|xtensa_block_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_block_info
argument_list|)
argument_list|)
decl_stmt|;
name|new_block
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|new_block
operator|->
name|offset
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|new_block
operator|->
name|size
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|new_block
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|xtensa_frag_flags_init
argument_list|(
operator|&
name|new_block
operator|->
name|flags
argument_list|)
expr_stmt|;
operator|*
name|xt_block
operator|=
name|new_block
expr_stmt|;
block|}
if|if
condition|(
name|end_property_function
operator|&&
name|end_property_function
argument_list|(
name|fragP
argument_list|)
condition|)
block|{
name|xt_block
operator|=
operator|&
operator|(
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Break the encapsulation of add_xt_prop_frags here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xtensa_frag_flags_is_empty
parameter_list|(
specifier|const
name|frag_flags
modifier|*
name|prop_flags
parameter_list|)
block|{
if|if
condition|(
name|prop_flags
operator|->
name|is_literal
operator|||
name|prop_flags
operator|->
name|is_insn
operator|||
name|prop_flags
operator|->
name|is_data
operator|||
name|prop_flags
operator|->
name|is_unreachable
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xtensa_frag_flags_init
parameter_list|(
name|frag_flags
modifier|*
name|prop_flags
parameter_list|)
block|{
name|memset
argument_list|(
name|prop_flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|frag_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_frag_property_flags
parameter_list|(
specifier|const
name|fragS
modifier|*
name|fragP
parameter_list|,
name|frag_flags
modifier|*
name|prop_flags
parameter_list|)
block|{
name|xtensa_frag_flags_init
argument_list|(
name|prop_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_literal
condition|)
name|prop_flags
operator|->
name|is_literal
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_specific_opcode
operator|||
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_transform
condition|)
name|prop_flags
operator|->
name|is_no_transform
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_unreachable
condition|)
name|prop_flags
operator|->
name|is_unreachable
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_insn
condition|)
block|{
name|prop_flags
operator|->
name|is_insn
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_loop_target
condition|)
name|prop_flags
operator|->
name|insn
operator|.
name|is_loop_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_branch_target
condition|)
name|prop_flags
operator|->
name|insn
operator|.
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_no_density
condition|)
name|prop_flags
operator|->
name|insn
operator|.
name|is_no_density
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|use_absolute_literals
condition|)
name|prop_flags
operator|->
name|insn
operator|.
name|is_abslit
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|is_align
condition|)
block|{
name|prop_flags
operator|->
name|is_align
operator|=
name|TRUE
expr_stmt|;
name|prop_flags
operator|->
name|alignment
operator|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|alignment
expr_stmt|;
if|if
condition|(
name|xtensa_frag_flags_is_empty
argument_list|(
name|prop_flags
argument_list|)
condition|)
name|prop_flags
operator|->
name|is_data
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|frag_flags_to_number
parameter_list|(
specifier|const
name|frag_flags
modifier|*
name|prop_flags
parameter_list|)
block|{
name|bfd_vma
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_literal
condition|)
name|num
operator||=
name|XTENSA_PROP_LITERAL
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_insn
condition|)
name|num
operator||=
name|XTENSA_PROP_INSN
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_data
condition|)
name|num
operator||=
name|XTENSA_PROP_DATA
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_unreachable
condition|)
name|num
operator||=
name|XTENSA_PROP_UNREACHABLE
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|insn
operator|.
name|is_loop_target
condition|)
name|num
operator||=
name|XTENSA_PROP_INSN_LOOP_TARGET
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|insn
operator|.
name|is_branch_target
condition|)
block|{
name|num
operator||=
name|XTENSA_PROP_INSN_BRANCH_TARGET
expr_stmt|;
name|num
operator|=
name|SET_XTENSA_PROP_BT_ALIGN
argument_list|(
name|num
argument_list|,
name|prop_flags
operator|->
name|insn
operator|.
name|bt_align_priority
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_flags
operator|->
name|insn
operator|.
name|is_no_density
condition|)
name|num
operator||=
name|XTENSA_PROP_INSN_NO_DENSITY
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_no_transform
condition|)
name|num
operator||=
name|XTENSA_PROP_NO_TRANSFORM
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|insn
operator|.
name|is_no_reorder
condition|)
name|num
operator||=
name|XTENSA_PROP_INSN_NO_REORDER
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|insn
operator|.
name|is_abslit
condition|)
name|num
operator||=
name|XTENSA_PROP_INSN_ABSLIT
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|->
name|is_align
condition|)
block|{
name|num
operator||=
name|XTENSA_PROP_ALIGN
expr_stmt|;
name|num
operator|=
name|SET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|num
argument_list|,
name|prop_flags
operator|->
name|alignment
argument_list|)
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xtensa_frag_flags_combinable
parameter_list|(
specifier|const
name|frag_flags
modifier|*
name|prop_flags_1
parameter_list|,
specifier|const
name|frag_flags
modifier|*
name|prop_flags_2
parameter_list|)
block|{
comment|/* Cannot combine with an end marker.  */
if|if
condition|(
name|prop_flags_1
operator|->
name|is_literal
operator|!=
name|prop_flags_2
operator|->
name|is_literal
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|is_insn
operator|!=
name|prop_flags_2
operator|->
name|is_insn
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|is_data
operator|!=
name|prop_flags_2
operator|->
name|is_data
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|is_insn
condition|)
block|{
comment|/* Properties of the beginning of the frag.  */
if|if
condition|(
name|prop_flags_2
operator|->
name|insn
operator|.
name|is_loop_target
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_2
operator|->
name|insn
operator|.
name|is_branch_target
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|insn
operator|.
name|is_no_density
operator|!=
name|prop_flags_2
operator|->
name|insn
operator|.
name|is_no_density
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|is_no_transform
operator|!=
name|prop_flags_2
operator|->
name|is_no_transform
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|insn
operator|.
name|is_no_reorder
operator|!=
name|prop_flags_2
operator|->
name|insn
operator|.
name|is_no_reorder
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|prop_flags_1
operator|->
name|insn
operator|.
name|is_abslit
operator|!=
name|prop_flags_2
operator|->
name|insn
operator|.
name|is_abslit
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|prop_flags_1
operator|->
name|is_align
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xt_block_aligned_size
parameter_list|(
specifier|const
name|xtensa_block_info
modifier|*
name|xt_block
parameter_list|)
block|{
name|bfd_vma
name|end_addr
decl_stmt|;
name|unsigned
name|align_bits
decl_stmt|;
if|if
condition|(
operator|!
name|xt_block
operator|->
name|flags
operator|.
name|is_align
condition|)
return|return
name|xt_block
operator|->
name|size
return|;
name|end_addr
operator|=
name|xt_block
operator|->
name|offset
operator|+
name|xt_block
operator|->
name|size
expr_stmt|;
name|align_bits
operator|=
name|xt_block
operator|->
name|flags
operator|.
name|alignment
expr_stmt|;
name|end_addr
operator|=
operator|(
operator|(
name|end_addr
operator|+
operator|(
operator|(
literal|1
operator|<<
name|align_bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
name|align_bits
operator|)
operator|<<
name|align_bits
expr_stmt|;
return|return
name|end_addr
operator|-
name|xt_block
operator|->
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xtensa_xt_block_combine
parameter_list|(
name|xtensa_block_info
modifier|*
name|xt_block
parameter_list|,
specifier|const
name|xtensa_block_info
modifier|*
name|xt_block_2
parameter_list|)
block|{
if|if
condition|(
name|xt_block
operator|->
name|sec
operator|!=
name|xt_block_2
operator|->
name|sec
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xt_block
operator|->
name|offset
operator|+
name|xt_block_aligned_size
argument_list|(
name|xt_block
argument_list|)
operator|!=
name|xt_block_2
operator|->
name|offset
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xt_block_2
operator|->
name|size
operator|==
literal|0
operator|&&
operator|(
operator|!
name|xt_block_2
operator|->
name|flags
operator|.
name|is_unreachable
operator|||
name|xt_block
operator|->
name|flags
operator|.
name|is_unreachable
operator|)
condition|)
block|{
if|if
condition|(
name|xt_block_2
operator|->
name|flags
operator|.
name|is_align
operator|&&
name|xt_block
operator|->
name|flags
operator|.
name|is_align
condition|)
block|{
comment|/* Nothing needed.  */
if|if
condition|(
name|xt_block
operator|->
name|flags
operator|.
name|alignment
operator|>=
name|xt_block_2
operator|->
name|flags
operator|.
name|alignment
condition|)
return|return
name|TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|xt_block_2
operator|->
name|flags
operator|.
name|is_align
condition|)
block|{
comment|/* Push alignment to previous entry.  */
name|xt_block
operator|->
name|flags
operator|.
name|is_align
operator|=
name|xt_block_2
operator|->
name|flags
operator|.
name|is_align
expr_stmt|;
name|xt_block
operator|->
name|flags
operator|.
name|alignment
operator|=
name|xt_block_2
operator|->
name|flags
operator|.
name|alignment
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|xtensa_frag_flags_combinable
argument_list|(
operator|&
name|xt_block
operator|->
name|flags
argument_list|,
operator|&
name|xt_block_2
operator|->
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|xt_block
operator|->
name|size
operator|+=
name|xt_block_2
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|xt_block_2
operator|->
name|flags
operator|.
name|is_align
condition|)
block|{
name|xt_block
operator|->
name|flags
operator|.
name|is_align
operator|=
name|TRUE
expr_stmt|;
name|xt_block
operator|->
name|flags
operator|.
name|alignment
operator|=
name|xt_block_2
operator|->
name|flags
operator|.
name|alignment
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_xt_prop_frags
parameter_list|(
name|segT
name|sec
parameter_list|,
name|segT
name|xt_block_sec
parameter_list|,
name|xtensa_block_info
modifier|*
modifier|*
name|xt_block
parameter_list|,
name|frag_flags_fn
name|property_function
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seg_info
decl_stmt|;
name|segment_info_type
modifier|*
name|xt_seg_info
decl_stmt|;
name|bfd_vma
name|seg_offset
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|xt_seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|xt_block_sec
argument_list|)
expr_stmt|;
name|seg_info
operator|=
name|retrieve_segment_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Build it if needed.  */
while|while
condition|(
operator|*
name|xt_block
operator|!=
name|NULL
condition|)
block|{
name|xt_block
operator|=
operator|&
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
expr_stmt|;
block|}
comment|/* We are either at NULL at the beginning or at the end.  */
comment|/* Walk through the frags.  */
name|seg_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg_info
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragP
operator|=
name|seg_info
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|xtensa_block_info
name|tmp_block
decl_stmt|;
name|tmp_block
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
name|tmp_block
operator|.
name|offset
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|tmp_block
operator|.
name|size
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|tmp_block
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|property_function
argument_list|(
name|fragP
argument_list|,
operator|&
name|tmp_block
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_frag_flags_is_empty
argument_list|(
operator|&
name|tmp_block
operator|.
name|flags
argument_list|)
condition|)
comment|/*&& fragP->fr_fix != 0) */
block|{
if|if
condition|(
operator|(
operator|*
name|xt_block
operator|)
operator|==
name|NULL
operator|||
operator|!
name|xtensa_xt_block_combine
argument_list|(
operator|*
name|xt_block
argument_list|,
operator|&
name|tmp_block
argument_list|)
condition|)
block|{
name|xtensa_block_info
modifier|*
name|new_block
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|xt_block
operator|)
operator|!=
name|NULL
condition|)
name|xt_block
operator|=
operator|&
operator|(
operator|*
name|xt_block
operator|)
operator|->
name|next
expr_stmt|;
name|new_block
operator|=
operator|(
name|xtensa_block_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_block_info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_block
operator|=
name|tmp_block
expr_stmt|;
operator|*
name|xt_block
operator|=
name|new_block
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* op_placement_info_table */
end_comment

begin_comment
comment|/* op_placement_info makes it easier to determine which    ops can go in which slots.  */
end_comment

begin_function
specifier|static
name|void
name|init_op_placement_info_table
parameter_list|(
name|void
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_insnbuf
name|ibuf
init|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|num_opcodes
init|=
name|xtensa_isa_num_opcodes
argument_list|(
name|isa
argument_list|)
decl_stmt|;
name|op_placement_table
operator|=
operator|(
name|op_placement_info_table
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|op_placement_info
argument_list|)
operator|*
name|num_opcodes
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
operator|<
name|MAX_FORMATS
argument_list|)
expr_stmt|;
for|for
control|(
name|opcode
operator|=
literal|0
init|;
name|opcode
operator|<
name|num_opcodes
condition|;
name|opcode
operator|++
control|)
block|{
name|op_placement_info
modifier|*
name|opi
init|=
operator|&
name|op_placement_table
index|[
name|opcode
index|]
decl_stmt|;
comment|/* FIXME: Make tinsn allocation dynamic.  */
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|>=
name|MAX_INSN_ARGS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many operands in instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|opi
operator|->
name|narrowest
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|opi
operator|->
name|narrowest_size
operator|=
literal|0x7F
expr_stmt|;
name|opi
operator|->
name|narrowest_slot
operator|=
literal|0
expr_stmt|;
name|opi
operator|->
name|formats
operator|=
literal|0
expr_stmt|;
name|opi
operator|->
name|num_formats
operator|=
literal|0
expr_stmt|;
name|opi
operator|->
name|issuef
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fmt
operator|=
literal|0
init|;
name|fmt
operator|<
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
condition|;
name|fmt
operator|++
control|)
block|{
name|opi
operator|->
name|slots
index|[
name|fmt
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|ibuf
argument_list|,
name|opcode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fmt_length
init|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
decl_stmt|;
name|opi
operator|->
name|issuef
operator|++
expr_stmt|;
name|set_bit
argument_list|(
name|fmt
argument_list|,
name|opi
operator|->
name|formats
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|slot
argument_list|,
name|opi
operator|->
name|slots
index|[
name|fmt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_length
operator|<
name|opi
operator|->
name|narrowest_size
operator|||
operator|(
name|fmt_length
operator|==
name|opi
operator|->
name|narrowest_size
operator|&&
operator|(
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|<
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|opi
operator|->
name|narrowest
argument_list|)
operator|)
operator|)
condition|)
block|{
name|opi
operator|->
name|narrowest
operator|=
name|fmt
expr_stmt|;
name|opi
operator|->
name|narrowest_size
operator|=
name|fmt_length
expr_stmt|;
name|opi
operator|->
name|narrowest_slot
operator|=
name|slot
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opi
operator|->
name|formats
condition|)
name|opi
operator|->
name|num_formats
operator|++
expr_stmt|;
block|}
block|}
name|xtensa_insnbuf_free
argument_list|(
name|isa
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|opcode_fits_format_slot
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
return|return
name|bit_is_set
argument_list|(
name|slot
argument_list|,
name|op_placement_table
index|[
name|opcode
index|]
operator|.
name|slots
index|[
name|fmt
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the opcode is available in a single slot format, return its size.  */
end_comment

begin_function
specifier|static
name|int
name|xg_get_single_size
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
return|return
name|op_placement_table
index|[
name|opcode
index|]
operator|.
name|narrowest_size
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_format
name|xg_get_single_format
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
return|return
name|op_placement_table
index|[
name|opcode
index|]
operator|.
name|narrowest
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xg_get_single_slot
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
return|return
name|op_placement_table
index|[
name|opcode
index|]
operator|.
name|narrowest_slot
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction Stack Functions (from "xtensa-istack.h").  */
end_comment

begin_function
name|void
name|istack_init
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|IStack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|istack_empty
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
return|return
operator|(
name|stack
operator|->
name|ninsn
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|istack_full
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
return|return
operator|(
name|stack
operator|->
name|ninsn
operator|==
name|MAX_ISTACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the top IStack entry.    It is an error to call this if istack_empty () is TRUE. */
end_comment

begin_function
name|TInsn
modifier|*
name|istack_top
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_empty
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
return|;
block|}
end_function

begin_comment
comment|/* Add a new TInsn to an IStack.    It is an error to call this if istack_full () is TRUE.  */
end_comment

begin_function
name|void
name|istack_push
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|,
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_full
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|insn
index|[
name|rec
index|]
operator|=
operator|*
name|insn
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear space for the next TInsn on the IStack and return a pointer    to it.  It is an error to call this if istack_full () is TRUE.  */
end_comment

begin_function
name|TInsn
modifier|*
name|istack_push_space
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
decl_stmt|;
name|TInsn
modifier|*
name|insn
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_full
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
expr_stmt|;
name|tinsn_init
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|++
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Remove the last pushed instruction.  It is an error to call this if    istack_empty () returns TRUE.  */
end_comment

begin_function
name|void
name|istack_pop
parameter_list|(
name|IStack
modifier|*
name|stack
parameter_list|)
block|{
name|int
name|rec
init|=
name|stack
operator|->
name|ninsn
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
operator|!
name|istack_empty
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ninsn
operator|--
expr_stmt|;
name|tinsn_init
argument_list|(
operator|&
name|stack
operator|->
name|insn
index|[
name|rec
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TInsn functions.  */
end_comment

begin_function
name|void
name|tinsn_init
parameter_list|(
name|TInsn
modifier|*
name|dst
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TInsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if ANY of the operands in the insn are symbolic.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_has_symbolic_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|tinsn_has_invalid_symbolic_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
break|break;
case|case
name|O_big
case|:
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
comment|/* Errors for these types are caught later.  */
break|break;
case|case
name|O_hi16
case|:
case|case
name|O_lo16
case|:
default|default:
comment|/* Symbolic immediates are only allowed on the last immediate 	     operand.  At this time, CONST16 is the only opcode where we 	     support non-PC-relative relocations.  */
if|if
condition|(
name|i
operator|!=
name|get_relaxable_immed
argument_list|(
name|insn
operator|->
name|opcode
argument_list|)
operator|||
operator|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
operator|!=
literal|1
operator|&&
name|insn
operator|->
name|opcode
operator|!=
name|xtensa_const16_opcode
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid symbolic operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* For assembly code with complex expressions (e.g. subtraction),    we have to build them in the literal pool so that    their results are calculated correctly after relaxation.    The relaxation only handles expressions that    boil down to SYMBOL + OFFSET.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_has_complex_operands
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|insn
operator|->
name|ntok
decl_stmt|;
name|assert
argument_list|(
name|insn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|tok
index|[
name|i
index|]
operator|.
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_lo16
case|:
case|case
name|O_hi16
case|:
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Encode a TInsn opcode and its constant operands into slotbuf.    Return TRUE if there is a symbol in the immediate field.  This    function assumes that:    1) The number of operands are correct.    2) The insn_type is ITYPE_INSN.    3) The opcode can be encoded in the specified format and slot.    4) Operands are either O_constant or O_symbol, and all constants fit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_to_slotbuf
parameter_list|(
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
name|bfd_boolean
name|has_fixup
init|=
name|FALSE
decl_stmt|;
name|int
name|noperands
init|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|tinsn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|!=
name|tinsn
operator|->
name|ntok
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"operand number mismatch"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
name|opcode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot encode opcode \"%s\" in the given format \"%s\""
argument_list|)
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|,
name|xtensa_format_name
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|tinsn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|line
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|uint32
name|opnd_value
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* The register number has already been checked in 	     expression_maybe_register, so we don't need to check here.  */
name|opnd_value
operator|=
name|expr
operator|->
name|X_add_number
expr_stmt|;
operator|(
name|void
operator|)
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|,
operator|&
name|opnd_value
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|,
name|opnd_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"xtensa-isa failure: %s"
argument_list|)
argument_list|,
name|xtensa_isa_error_msg
argument_list|(
name|isa
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|as_where
argument_list|(
operator|&
name|file_name
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
comment|/* It is a constant and we called this function 	     then we have to try to fit it.  */
name|xtensa_insnbuf_set_operand
argument_list|(
name|slotbuf
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|,
name|expr
operator|->
name|X_add_number
argument_list|,
name|file_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
name|has_fixup
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|has_fixup
return|;
block|}
end_function

begin_comment
comment|/* Encode a single TInsn into an insnbuf.  If the opcode can only be encoded    into a multi-slot instruction, fill the other slots with NOPs.    Return TRUE if there is a symbol in the immediate field.  See also the    assumptions listed for tinsn_to_slotbuf.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_to_insnbuf
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|xtensa_insnbuf
name|insnbuf
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
literal|0
decl_stmt|;
specifier|static
name|vliw_insn
name|vinsn
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|bfd_boolean
name|has_fixup
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|slotbuf
condition|)
block|{
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xg_init_vinsn
argument_list|(
operator|&
name|vinsn
argument_list|)
expr_stmt|;
block|}
name|xg_clear_vinsn
argument_list|(
operator|&
name|vinsn
argument_list|)
expr_stmt|;
name|bundle_tinsn
argument_list|(
name|tinsn
argument_list|,
operator|&
name|vinsn
argument_list|)
expr_stmt|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|.
name|format
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|.
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Only one slot may have a fix-up because the rest contains NOPs.  */
name|has_fixup
operator||=
name|tinsn_to_slotbuf
argument_list|(
name|vinsn
operator|.
name|format
argument_list|,
name|i
argument_list|,
operator|&
name|vinsn
operator|.
name|slots
index|[
name|i
index|]
argument_list|,
name|vinsn
operator|.
name|slotbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|vinsn
operator|.
name|format
argument_list|,
name|i
argument_list|,
name|insnbuf
argument_list|,
name|vinsn
operator|.
name|slotbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|has_fixup
return|;
block|}
end_function

begin_comment
comment|/* Check the instruction arguments.  Return TRUE on failure.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tinsn_check_arguments
parameter_list|(
specifier|const
name|TInsn
modifier|*
name|insn
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|insn
operator|->
name|opcode
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|>
name|insn
operator|->
name|ntok
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too few operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
operator|<
name|insn
operator|->
name|ntok
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Load an instruction from its encoded form.  */
end_comment

begin_function
specifier|static
name|void
name|tinsn_from_chars
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|char
modifier|*
name|f
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|vliw_insn
name|vinsn
decl_stmt|;
name|xg_init_vinsn
argument_list|(
operator|&
name|vinsn
argument_list|)
expr_stmt|;
name|vinsn_from_chars
argument_list|(
operator|&
name|vinsn
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|*
name|tinsn
operator|=
name|vinsn
operator|.
name|slots
index|[
name|slot
index|]
expr_stmt|;
name|xg_free_vinsn
argument_list|(
operator|&
name|vinsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tinsn_from_insnbuf
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
comment|/* Find the immed.  */
name|tinsn_init
argument_list|(
name|tinsn
argument_list|)
expr_stmt|;
name|tinsn
operator|->
name|insn_type
operator|=
name|ITYPE_INSN
expr_stmt|;
name|tinsn
operator|->
name|is_specific_opcode
operator|=
name|FALSE
expr_stmt|;
comment|/* must not be specific */
name|tinsn
operator|->
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|tinsn
operator|->
name|ntok
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tinsn
operator|->
name|ntok
condition|;
name|i
operator|++
control|)
block|{
name|set_expr_const
argument_list|(
operator|&
name|tinsn
operator|->
name|tok
index|[
name|i
index|]
argument_list|,
name|xtensa_insnbuf_get_operand
argument_list|(
name|slotbuf
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|tinsn
operator|->
name|opcode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the value of the relaxable immed from the fr_symbol and fr_offset.  */
end_comment

begin_function
specifier|static
name|void
name|tinsn_immed_from_frag
parameter_list|(
name|TInsn
modifier|*
name|tinsn
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_symbols
index|[
name|slot
index|]
condition|)
block|{
name|opnum
operator|=
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|set_expr_symbol_offset
argument_list|(
operator|&
name|tinsn
operator|->
name|tok
index|[
name|opnum
index|]
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_symbols
index|[
name|slot
index|]
argument_list|,
name|fragP
operator|->
name|tc_frag_data
operator|.
name|slot_offsets
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_stack_text_bytes
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|text_bytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|insn_type
operator|==
name|ITYPE_INSN
condition|)
name|text_bytes
operator|+=
name|xg_get_single_size
argument_list|(
name|tinsn
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
name|text_bytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_stack_literal_bytes
parameter_list|(
name|IStack
modifier|*
name|istack
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|lit_bytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istack
operator|->
name|ninsn
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|istack
operator|->
name|insn
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tinsn
operator|->
name|insn_type
operator|==
name|ITYPE_LITERAL
operator|&&
name|tinsn
operator|->
name|ntok
operator|==
literal|1
condition|)
name|lit_bytes
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|lit_bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* vliw_insn functions.  */
end_comment

begin_function
specifier|static
name|void
name|xg_init_vinsn
parameter_list|(
name|vliw_insn
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xg_clear_vinsn
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|insnbuf
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"out of memory"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|->
name|slotbuf
index|[
name|i
index|]
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slotbuf
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"out of memory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xg_clear_vinsn
parameter_list|(
name|vliw_insn
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|offsetof
argument_list|(
name|vliw_insn
argument_list|,
name|insnbuf
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|format
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|v
operator|->
name|num_slots
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|inside_bundle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|xt_saved_debug_type
operator|!=
name|DEBUG_NONE
condition|)
name|debug_type
operator|=
name|xt_saved_debug_type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SLOTS
condition|;
name|i
operator|++
control|)
name|v
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|vinsn_has_specific_opcodes
parameter_list|(
name|vliw_insn
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|v
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|is_specific_opcode
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xg_free_vinsn
parameter_list|(
name|vliw_insn
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xtensa_insnbuf_free
argument_list|(
name|xtensa_default_isa
argument_list|,
name|v
operator|->
name|insnbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SLOTS
condition|;
name|i
operator|++
control|)
name|xtensa_insnbuf_free
argument_list|(
name|xtensa_default_isa
argument_list|,
name|v
operator|->
name|slotbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode a vliw_insn into an insnbuf.  Return TRUE if there are any symbolic    operands.  See also the assumptions listed for tinsn_to_slotbuf.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vinsn_to_insnbuf
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|,
name|char
modifier|*
name|frag_offset
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|bfd_boolean
name|record_fixup
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
init|=
name|vinsn
operator|->
name|format
decl_stmt|;
name|xtensa_insnbuf
name|insnbuf
init|=
name|vinsn
operator|->
name|insnbuf
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|bfd_boolean
name|has_fixup
init|=
name|FALSE
decl_stmt|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|slot
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|slot
index|]
decl_stmt|;
name|bfd_boolean
name|tinsn_has_fixup
init|=
name|tinsn_to_slotbuf
argument_list|(
name|vinsn
operator|->
name|format
argument_list|,
name|slot
argument_list|,
name|tinsn
argument_list|,
name|vinsn
operator|->
name|slotbuf
index|[
name|slot
index|]
argument_list|)
decl_stmt|;
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|vinsn
operator|->
name|slotbuf
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinsn_has_fixup
condition|)
block|{
name|int
name|i
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|tinsn
operator|->
name|opcode
decl_stmt|;
name|int
name|noperands
init|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|has_fixup
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|expressionS
modifier|*
name|expr
init|=
operator|&
name|tinsn
operator|->
name|tok
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|X_op
condition|)
block|{
case|case
name|O_symbol
case|:
case|case
name|O_lo16
case|:
case|case
name|O_hi16
case|:
if|if
condition|(
name|get_relaxable_immed
argument_list|(
name|opcode
argument_list|)
operator|==
name|i
condition|)
block|{
comment|/* Add a fix record for the instruction, except if this 			 function is being called prior to relaxation, i.e., 			 if record_fixup is false, and the instruction might 			 be relaxed later.  */
if|if
condition|(
name|record_fixup
operator|||
name|tinsn
operator|->
name|is_specific_opcode
operator|||
operator|!
name|xg_is_relaxable_insn
argument_list|(
name|tinsn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|xg_add_opcode_fix
argument_list|(
name|tinsn
argument_list|,
name|i
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|expr
argument_list|,
name|fragP
argument_list|,
name|frag_offset
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|expr
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand"
argument_list|)
argument_list|)
expr_stmt|;
name|tinsn
operator|->
name|symbol
operator|=
name|expr
operator|->
name|X_add_symbol
expr_stmt|;
name|tinsn
operator|->
name|offset
operator|=
name|expr
operator|->
name|X_add_number
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbolic operand not allowed"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
case|case
name|O_register
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|has_fixup
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vinsn_from_chars
parameter_list|(
name|vliw_insn
modifier|*
name|vinsn
parameter_list|,
name|char
modifier|*
name|f
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
operator|!
name|insnbuf
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot decode instruction format"
argument_list|)
argument_list|)
expr_stmt|;
name|vinsn
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|vinsn
operator|->
name|num_slots
operator|=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinsn
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|TInsn
modifier|*
name|tinsn
init|=
operator|&
name|vinsn
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|i
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|tinsn_from_insnbuf
argument_list|(
name|tinsn
argument_list|,
name|slotbuf
argument_list|,
name|fmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression utilities.  */
end_comment

begin_comment
comment|/* Return TRUE if the expression is an integer constant.  */
end_comment

begin_function
name|bfd_boolean
name|expr_is_const
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|s
operator|->
name|X_op
operator|==
name|O_constant
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the expression constant.    Calling this is illegal if expr_is_const () returns TRUE.  */
end_comment

begin_function
name|offsetT
name|get_expr_const
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|expr_is_const
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Set the expression to a constant value.  */
end_comment

begin_function
name|void
name|set_expr_const
parameter_list|(
name|expressionS
modifier|*
name|s
parameter_list|,
name|offsetT
name|val
parameter_list|)
block|{
name|s
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|s
operator|->
name|X_add_number
operator|=
name|val
expr_stmt|;
name|s
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|expr_is_register
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|s
operator|->
name|X_op
operator|==
name|O_register
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the expression constant.    Calling this is illegal if expr_is_const () returns TRUE.  */
end_comment

begin_function
name|offsetT
name|get_expr_register
parameter_list|(
specifier|const
name|expressionS
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|expr_is_register
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Set the expression to a symbol + constant offset.  */
end_comment

begin_function
name|void
name|set_expr_symbol_offset
parameter_list|(
name|expressionS
modifier|*
name|s
parameter_list|,
name|symbolS
modifier|*
name|sym
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|s
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|s
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|s
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* unused */
name|s
operator|->
name|X_add_number
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the two expressions are equal.  */
end_comment

begin_function
name|bfd_boolean
name|expr_is_equal
parameter_list|(
name|expressionS
modifier|*
name|s1
parameter_list|,
name|expressionS
modifier|*
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|->
name|X_op
operator|!=
name|s2
operator|->
name|X_op
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_add_symbol
operator|!=
name|s2
operator|->
name|X_add_symbol
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_op_symbol
operator|!=
name|s2
operator|->
name|X_op_symbol
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s1
operator|->
name|X_add_number
operator|!=
name|s2
operator|->
name|X_add_number
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_expr
parameter_list|(
name|expressionS
modifier|*
name|dst
parameter_list|,
specifier|const
name|expressionS
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for the "--rename-section" option.  */
end_comment

begin_struct
struct|struct
name|rename_section_struct
block|{
name|char
modifier|*
name|old_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|rename_section_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|rename_section_struct
modifier|*
name|section_rename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the string "oldname=new_name(:oldname2=new_name2)*" and add    entries to the section_rename list.  Note: Specifying multiple    renamings separated by colons is not documented and is retained only    for backward compatibility.  */
end_comment

begin_function
specifier|static
name|void
name|build_section_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rename_section_struct
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|this_arg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|next_arg
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|this_arg
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
init|;
name|this_arg
operator|!=
name|NULL
condition|;
name|this_arg
operator|=
name|next_arg
control|)
block|{
name|char
modifier|*
name|old_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|;
if|if
condition|(
name|this_arg
condition|)
block|{
name|next_arg
operator|=
name|strchr
argument_list|(
name|this_arg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
condition|)
block|{
operator|*
name|next_arg
operator|=
literal|'\0'
expr_stmt|;
name|next_arg
operator|++
expr_stmt|;
block|}
block|}
name|old_name
operator|=
name|this_arg
expr_stmt|;
name|new_name
operator|=
name|strchr
argument_list|(
name|this_arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|old_name
operator|==
literal|'\0'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring extra '-rename-section' delimiter ':'"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|new_name
operator|||
name|new_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring invalid '-rename-section' specification: '%s'"
argument_list|)
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|new_name
operator|=
literal|'\0'
expr_stmt|;
name|new_name
operator|++
expr_stmt|;
comment|/* Check for invalid section renaming.  */
for|for
control|(
name|r
operator|=
name|section_rename
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|old_name
argument_list|,
name|old_name
argument_list|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"section %s renamed multiple times"
argument_list|)
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|new_name
argument_list|,
name|new_name
argument_list|)
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple sections remapped to output section %s"
argument_list|)
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
comment|/* Now add it.  */
name|r
operator|=
operator|(
expr|struct
name|rename_section_struct
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rename_section_struct
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|old_name
operator|=
name|xstrdup
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|r
operator|->
name|new_name
operator|=
name|xstrdup
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|section_rename
expr_stmt|;
name|section_rename
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|xtensa_section_rename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|rename_section_struct
modifier|*
name|r
init|=
name|section_rename
decl_stmt|;
for|for
control|(
name|r
operator|=
name|section_rename
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|old_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|r
operator|->
name|new_name
return|;
block|}
return|return
name|name
return|;
block|}
end_function

end_unit

