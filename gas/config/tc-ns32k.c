begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ns32k.c  -- Assemble on the National Semiconductor 32k series    Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*#define SHOW_NUM 1*/
end_comment

begin_comment
comment|/* Uncomment for debugging.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ns32k.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Macros.  */
end_comment

begin_define
define|#
directive|define
name|IIF_ENTRIES
value|13
end_define

begin_comment
comment|/* Number of entries in iif.  */
end_comment

begin_define
define|#
directive|define
name|PRIVATE_SIZE
value|256
end_define

begin_comment
comment|/* Size of my garbage memory.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ARGS
value|4
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|-1
end_define

begin_comment
comment|/* addr_mode returns this value when                                    plain constant or label is                                    encountered.  */
end_comment

begin_define
define|#
directive|define
name|IIF
parameter_list|(
name|ptr
parameter_list|,
name|a1
parameter_list|,
name|c1
parameter_list|,
name|e1
parameter_list|,
name|g1
parameter_list|,
name|i1
parameter_list|,
name|k1
parameter_list|,
name|m1
parameter_list|,
name|o1
parameter_list|,
name|q1
parameter_list|,
name|s1
parameter_list|,
name|u1
parameter_list|)
define|\
value|iif.iifP[ptr].type= a1;				\     iif.iifP[ptr].size= c1;				\     iif.iifP[ptr].object= e1;				\     iif.iifP[ptr].object_adjust= g1;			\     iif.iifP[ptr].pcrel= i1;				\     iif.iifP[ptr].pcrel_adjust= k1;			\     iif.iifP[ptr].im_disp= m1;				\     iif.iifP[ptr].relax_substate= o1;			\     iif.iifP[ptr].bit_fixP= q1;				\     iif.iifP[ptr].addr_mode= s1;			\     iif.iifP[ptr].bsr= u1;
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SEQUENT_COMPATABILITY
end_ifdef

begin_define
define|#
directive|define
name|LINE_COMMENT_CHARS
value|"|"
end_define

begin_define
define|#
directive|define
name|ABSOLUTE_PREFIX
value|'@'
end_define

begin_define
define|#
directive|define
name|IMMEDIATE_PREFIX
value|'#'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_COMMENT_CHARS
end_ifndef

begin_define
define|#
directive|define
name|LINE_COMMENT_CHARS
value|"#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
name|LINE_COMMENT_CHARS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_disp_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Displacement size for external refs.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ABSOLUTE_PREFIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IMMEDIATE_PREFIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ABSOLUTE_PREFIX
value|'@'
end_define

begin_comment
comment|/* One or the other MUST be defined.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|addr_mode
block|{
name|signed
name|char
name|mode
decl_stmt|;
comment|/* Addressing mode of operand (0-31).  */
name|signed
name|char
name|scaled_mode
decl_stmt|;
comment|/* Mode combined with scaled mode.  */
name|char
name|scaled_reg
decl_stmt|;
comment|/* Register used in scaled+1 (1-8).  */
name|char
name|float_flag
decl_stmt|;
comment|/* Set if R0..R7 was F0..F7 ie a 				   floating-point-register.  */
name|char
name|am_size
decl_stmt|;
comment|/* Estimated max size of general addr-mode 				   parts.  */
name|char
name|im_disp
decl_stmt|;
comment|/* If im_disp==1 we have a displacement.  */
name|char
name|pcrel
decl_stmt|;
comment|/* 1 if pcrel, this is really redundant info.  */
name|char
name|disp_suffix
index|[
literal|2
index|]
decl_stmt|;
comment|/* Length of displacement(s), 0=undefined.  */
name|char
modifier|*
name|disp
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pointer(s) at displacement(s) 				   or immediates(s)     (ascii).  */
name|char
name|index_byte
decl_stmt|;
comment|/* Index byte.  */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|addr_mode
name|addr_modeS
typedef|;
end_typedef

begin_decl_stmt
name|char
modifier|*
name|freeptr
decl_stmt|,
modifier|*
name|freeptr_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points at some number of free bytes.  */
end_comment

begin_decl_stmt
name|struct
name|hash_control
modifier|*
name|inst_hash_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_opcode
modifier|*
name|desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer at description of instruction.  */
end_comment

begin_decl_stmt
name|addr_modeS
name|addr_modeP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fd"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We don't want to support lowercase,                                    do we?  */
end_comment

begin_comment
comment|/* UPPERCASE denotes live names when an instruction is built, IIF is    used as an intermediate form to store the actual parts of the    instruction. A ns32k machine instruction can be divided into a    couple of sub PARTs. When an instruction is assembled the    appropriate PART get an assignment. When an IIF has been completed    it is converted to a FRAGment as specified in AS.H.  */
end_comment

begin_comment
comment|/* Internal structs.  */
end_comment

begin_struct
struct|struct
name|ns32k_option
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
name|unsigned
name|long
name|or
decl_stmt|;
name|unsigned
name|long
name|and
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|type
decl_stmt|;
comment|/* How to interpret object.  */
name|int
name|size
decl_stmt|;
comment|/* Estimated max size of object.  */
name|unsigned
name|long
name|object
decl_stmt|;
comment|/* Binary data.  */
name|int
name|object_adjust
decl_stmt|;
comment|/* Number added to object.  */
name|int
name|pcrel
decl_stmt|;
comment|/* True if object is pcrel.  */
name|int
name|pcrel_adjust
decl_stmt|;
comment|/* Length in bytes from the instruction 				   start to the	displacement.  */
name|int
name|im_disp
decl_stmt|;
comment|/* True if the object is a displacement.  */
name|relax_substateT
name|relax_substate
decl_stmt|;
comment|/* Initial relaxsubstate.  */
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
comment|/* Pointer at bit_fix struct.  */
name|int
name|addr_mode
decl_stmt|;
comment|/* What addrmode do we associate with this 				   iif-entry.  */
name|char
name|bsr
decl_stmt|;
comment|/* Sequent hack.  */
block|}
name|iif_entryT
typedef|;
end_typedef

begin_comment
comment|/* Internal Instruction Format.  */
end_comment

begin_struct
struct|struct
name|int_ins_form
block|{
name|int
name|instr_size
decl_stmt|;
comment|/* Max size of instruction in bytes.  */
name|iif_entryT
name|iifP
index|[
name|IIF_ENTRIES
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|int_ins_form
name|iif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expressionS
name|exprP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description of the PARTs in IIF   object[n]:    0	total length in bytes of entries in iif    1	opcode    2	index_byte_a    3	index_byte_b    4	disp_a_1    5	disp_a_2    6	disp_b_1    7	disp_b_2    8	imm_a    9	imm_b    10	implied1    11	implied2     For every entry there is a datalength in bytes. This is stored in size[n].   	 0,	the objectlength is not explicitly given by the instruction   		and the operand is undefined. This is a case for relaxation.   		Reserve 4 bytes for the final object.    	 1,	the entry contains one byte   	 2,	the entry contains two bytes   	 3,	the entry contains three bytes   	 4,	the entry contains four bytes   	etc     Furthermore, every entry has a data type identifier in type[n].     	 0,	the entry is void, ignore it.    	 1,	the entry is a binary number.   	 2,	the entry is a pointer at an expression.   		Where expression may be as simple as a single '1',   		and as complicated as  foo-bar+12,    		foo and bar may be undefined but suffixed by :{b|w|d} to   		control the length of the object.    	 3,	the entry is a pointer at a bignum struct     The low-order-byte corresponds to low physical memory.    Obviously a FRAGment must be created for each valid disp in PART whose    datalength is undefined (to bad) .    The case where just the expression is undefined is less severe and is    handled by fix. Here the number of bytes in the objectfile is known.    With this representation we simplify the assembly and separates the    machine dependent/independent parts in a more clean way (said OE).  */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|struct
name|ns32k_option
name|opt1
index|[]
init|=
comment|/* restore, exit.  */
block|{
block|{
literal|"r0"
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x40
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x20
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x10
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x08
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|opt2
index|[]
init|=
comment|/* save, enter.  */
block|{
block|{
literal|"r0"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x08
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x10
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x20
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x40
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|opt3
index|[]
init|=
comment|/* setcfg.  */
block|{
block|{
literal|"c"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"m"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"f"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"i"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|opt4
index|[]
init|=
comment|/* cinv.  */
block|{
block|{
literal|"a"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"i"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"d"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|opt5
index|[]
init|=
comment|/* String inst.  */
block|{
block|{
literal|"b"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"u"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"w"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|opt6
index|[]
init|=
comment|/* Plain reg ext,cvtp etc.  */
block|{
block|{
literal|"r0"
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x03
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x05
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x06
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x07
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NS32032
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NS32532
argument_list|)
end_if

begin_define
define|#
directive|define
name|NS32532
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|ns32k_option
name|cpureg_532
index|[]
init|=
comment|/* lpr spr.  */
block|{
block|{
literal|"us"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"dcr"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|"bpc"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"dsr"
block|,
literal|0x3
block|,
literal|0xff
block|}
block|,
block|{
literal|"car"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"usp"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"cfg"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|mmureg_532
index|[]
init|=
comment|/* lmr smr.  */
block|{
block|{
literal|"mcr"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"tear"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"ivar0"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"ivar1"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|cpureg_032
index|[]
init|=
comment|/* lpr spr.  */
block|{
block|{
literal|"upsr"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
name|mmureg_032
index|[]
init|=
comment|/* lmr smr.  */
block|{
block|{
literal|"bpr0"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"bpr1"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|"pf0"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"pf1"
block|,
literal|0x5
block|,
literal|0xff
block|}
block|,
block|{
literal|"sc"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"bcnt"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"eia"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NS32532
argument_list|)
end_if

begin_decl_stmt
name|struct
name|ns32k_option
modifier|*
name|cpureg
init|=
name|cpureg_532
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
modifier|*
name|mmureg
init|=
name|mmureg_532
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|ns32k_option
modifier|*
name|cpureg
init|=
name|cpureg_032
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_option
modifier|*
name|mmureg
init|=
name|mmureg_032
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* So far empty.  */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IND
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<<2)+(y))
end_define

begin_comment
comment|/* Those are index's to relax groups in md_relax_table ie it must be    multiplied by 4 to point at a group start. Viz IND(x,y) Se function    relax_segment in write.c for more info.  */
end_comment

begin_define
define|#
directive|define
name|BRANCH
value|1
end_define

begin_define
define|#
directive|define
name|PCREL
value|2
end_define

begin_comment
comment|/* Those are index's to entries in a relax group.  */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|WORD
value|1
end_define

begin_define
define|#
directive|define
name|DOUBLE
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF
value|3
end_define

begin_comment
comment|/* Those limits are calculated from the displacement start in memory.    The ns32k uses the beginning of the instruction as displacement    base.  This type of displacements could be handled here by moving    the limit window up or down. I choose to use an internal    displacement base-adjust as there are other routines that must    consider this. Also, as we have two various offset-adjusts in the    ns32k (acb versus br/brs/jsr/bcond), two set of limits would have    had to be used.  Now we dont have to think about that.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
literal|63
operator|)
block|,
operator|(
operator|-
literal|64
operator|)
block|,
literal|1
block|,
name|IND
argument_list|(
argument|BRANCH
argument_list|,
argument|WORD
argument_list|)
block|}
block|,
block|{
operator|(
literal|8192
operator|)
block|,
operator|(
operator|-
literal|8192
operator|)
block|,
literal|2
block|,
name|IND
argument_list|(
argument|BRANCH
argument_list|,
argument|DOUBLE
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array used to test if mode contains displacements.    Value is true if mode contains displacement.  */
end_comment

begin_decl_stmt
name|char
name|disp_test
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array used to calculate max size of displacements.  */
end_comment

begin_decl_stmt
name|char
name|disp_size
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|evaluate_expr
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|resultP
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|md_number_to_disp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|md_number_to_imm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|md_number_to_field
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|bit_fixS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse a general operand into an addressingmode struct     In:  pointer at operand in ascii form         pointer at addr_mode struct for result         the level of recursion. (always 0 or 1)     Out: data in addr_mode struct.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|addr_mode
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|addr_modeS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|addr_mode
parameter_list|(
name|operand
parameter_list|,
name|addr_modeP
parameter_list|,
name|recursive_level
parameter_list|)
name|char
modifier|*
name|operand
decl_stmt|;
name|addr_modeS
modifier|*
name|addr_modeP
decl_stmt|;
name|int
name|recursive_level
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|strl
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|j
decl_stmt|;
name|mode
operator|=
name|DEFAULT
expr_stmt|;
comment|/* Default.  */
name|addr_modeP
operator|->
name|scaled_mode
operator|=
literal|0
expr_stmt|;
comment|/* Why not.  */
name|addr_modeP
operator|->
name|scaled_reg
operator|=
literal|0
expr_stmt|;
comment|/* If 0, not scaled index.  */
name|addr_modeP
operator|->
name|float_flag
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Not set in this function.  */
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|str
operator|=
name|operand
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strl
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* The following three case statements controls the mode-chars 	 this is the place to ed if you want to change them.  */
ifdef|#
directive|ifdef
name|ABSOLUTE_PREFIX
case|case
name|ABSOLUTE_PREFIX
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
break|break;
name|addr_modeP
operator|->
name|mode
operator|=
literal|21
expr_stmt|;
comment|/* absolute */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IMMEDIATE_PREFIX
case|case
name|IMMEDIATE_PREFIX
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
break|break;
name|addr_modeP
operator|->
name|mode
operator|=
literal|20
expr_stmt|;
comment|/* immediate */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
case|case
literal|'.'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
switch|switch
condition|(
name|str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
if|if
condition|(
name|str
index|[
literal|2
index|]
operator|!=
literal|'\000'
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
literal|27
expr_stmt|;
comment|/* pc-relative */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|2
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid syntax in PC-relative addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ext("
argument_list|,
literal|4
argument_list|)
operator|)
operator|&&
name|strl
operator|>
literal|7
condition|)
block|{
comment|/* external */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|4
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|2
expr_stmt|;
do|do
block|{
comment|/* disp[0]'s termination point.  */
name|j
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'('
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|')'
condition|)
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|strl
operator|&&
name|i
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
operator|(
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|'-'
operator|||
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid syntax in External addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|str
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* null terminate disp[0] */
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|str
operator|+
name|j
operator|+
literal|2
expr_stmt|;
name|addr_modeP
operator|->
name|mode
operator|=
literal|22
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|strl
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strl
condition|)
block|{
case|case
literal|2
case|:
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|addr_modeP
operator|->
name|float_flag
operator|=
literal|1
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'r'
case|:
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
literal|1
index|]
operator|<
literal|'8'
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|str
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Drop through.  */
case|case
literal|3
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"tos"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
literal|23
expr_stmt|;
comment|/* TopOfStack */
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|strl
operator|>
literal|4
condition|)
block|{
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(fp"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|16
expr_stmt|;
comment|/* Memory Relative.  */
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(sp"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(sb"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|18
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DEFAULT
condition|)
block|{
comment|/* Memory relative.  */
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|j
operator|=
name|strl
operator|-
literal|5
expr_stmt|;
comment|/* Temp for end of disp[0].  */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|strl
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
index|]
operator|==
literal|')'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
index|]
operator|==
literal|'('
condition|)
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|strl
operator|>
operator|-
literal|1
operator|&&
name|i
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid syntax in Memory Relative addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|str
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
name|strl
operator|+
literal|1
expr_stmt|;
name|str
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* Null terminate disp[0] .  */
name|str
index|[
name|strl
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* Null terminate disp[1].  */
return|return
operator|-
literal|1
return|;
block|}
block|}
switch|switch
condition|(
name|str
index|[
name|strl
operator|-
literal|3
index|]
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|<
literal|'8'
operator|&&
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|==
literal|'('
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|-
literal|'0'
operator|+
literal|8
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* reg rel */
block|}
comment|/* Drop through.  */
default|default:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(fp"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(sp"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(sb"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(pc"
argument_list|,
literal|3
argument_list|)
condition|)
name|mode
operator|=
literal|27
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DEFAULT
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Memory space.  */
block|}
block|}
block|}
comment|/* No trailing ')' do we have a ']' ?  */
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
switch|switch
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|mode
operator|=
literal|28
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mode
operator|=
literal|29
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mode
operator|=
literal|30
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|mode
operator|=
literal|31
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid scaled-indexed mode, use (b,w,d,q)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|3
index|]
operator|!=
literal|':'
operator|||
name|str
index|[
name|strl
operator|-
literal|6
index|]
operator|!=
literal|'['
operator|||
name|str
index|[
name|strl
operator|-
literal|5
index|]
operator|==
literal|'r'
operator|||
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|<
literal|'0'
operator|||
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|>
literal|'7'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scaled index.  */
if|if
condition|(
name|recursive_level
operator|>
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Scaled-indexed addressing mode combined with scaled-index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr_modeP
operator|->
name|am_size
operator|+=
literal|1
expr_stmt|;
comment|/* scaled index byte.  */
name|j
operator|=
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* store temporary.  */
name|str
index|[
name|strl
operator|-
literal|6
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* nullterminate for recursive call.  */
name|i
operator|=
name|addr_mode
argument_list|(
name|str
argument_list|,
name|addr_modeP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|||
name|addr_modeP
operator|->
name|mode
operator|==
literal|20
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid or illegal addressing mode combined with scaled-index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|addr_modeP
operator|->
name|mode
expr_stmt|;
comment|/* Store the inferior mode.  */
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|addr_modeP
operator|->
name|scaled_reg
operator|=
name|j
operator|+
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|addr_modeP
operator|->
name|mode
operator|=
name|DEFAULT
expr_stmt|;
comment|/* Default to whatever.  */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ptr points at string addr_modeP points at struct with result This    routine calls addr_mode to determine the general addr.mode of the    operand. When this is ready it parses the displacements for size    specifying suffixes and determines size of immediate mode via    ns32k-opcode.  Also builds index bytes if needed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_addr_mode
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|addr_modeS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_addr_mode
parameter_list|(
name|ptr
parameter_list|,
name|addr_modeP
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addr_modeS
modifier|*
name|addr_modeP
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|;
name|addr_mode
argument_list|(
name|ptr
argument_list|,
name|addr_modeP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
name|DEFAULT
operator|||
name|addr_modeP
operator|->
name|scaled_mode
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Resolve ambiguous operands, this shouldn't be necessary if 	 one uses standard NSC operand syntax. But the sequent 	 compiler doesn't!!!  This finds a proper addressing mode 	 if it is implicitly stated. See ns32k-opcode.h.  */
operator|(
name|void
operator|)
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* This call takes time Sigh!  */
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
name|DEFAULT
condition|)
block|{
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_op_symbol
condition|)
name|addr_modeP
operator|->
name|mode
operator|=
name|desc
operator|->
name|default_model
expr_stmt|;
comment|/* We have a label.  */
else|else
name|addr_modeP
operator|->
name|mode
operator|=
name|desc
operator|->
name|default_modec
expr_stmt|;
comment|/* We have a constant.  */
block|}
else|else
block|{
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_op_symbol
condition|)
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|desc
operator|->
name|default_model
expr_stmt|;
else|else
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|desc
operator|->
name|default_modec
expr_stmt|;
block|}
comment|/* Must put this mess down in addr_mode to handle the scaled          case better.  */
block|}
comment|/* It appears as the sequent compiler wants an absolute when we have      a label without @. Constants becomes immediates besides the addr      case.  Think it does so with local labels too, not optimum, pcrel      is better.  When I have time I will make gas check this and      select pcrel when possible Actually that is trivial.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|addr_modeP
operator|->
name|scaled_reg
operator|)
condition|)
block|{
comment|/* Build indexbyte.  */
name|tmp
operator|--
expr_stmt|;
comment|/* Remember regnumber comes incremented for 				   flagpurpose.  */
name|tmp
operator||=
name|addr_modeP
operator|->
name|scaled_mode
operator|<<
literal|3
expr_stmt|;
name|addr_modeP
operator|->
name|index_byte
operator|=
operator|(
name|char
operator|)
name|tmp
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|+=
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|addr_modeP
operator|->
name|mode
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp_test
index|[
operator|(
name|unsigned
name|int
operator|)
name|addr_modeP
operator|->
name|mode
index|]
condition|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|suffix
decl_stmt|;
name|char
name|suffix_sub
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|toP
decl_stmt|;
name|char
modifier|*
name|fromP
decl_stmt|;
comment|/* There was a displacement, probe for length  specifying suffix.  */
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|addr_modeP
operator|->
name|mode
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp_test
index|[
operator|(
name|unsigned
name|int
operator|)
name|addr_modeP
operator|->
name|mode
index|]
condition|)
block|{
comment|/* There is a displacement.  */
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
literal|27
operator|||
name|addr_modeP
operator|->
name|scaled_mode
operator|==
literal|27
condition|)
comment|/* Do we have pcrel. mode.  */
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|1
expr_stmt|;
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|suffix_sub
operator|=
name|suffix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|toP
operator|=
name|addr_modeP
operator|->
name|disp
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* Suffix of expression, the largest size rules.  */
name|fromP
operator|=
name|toP
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fromP
operator|++
operator|)
condition|)
block|{
operator|*
name|toP
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
operator|*
name|fromP
condition|)
block|{
case|case
literal|'\0'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Premature end of suffix -- Defaulting to d"
argument_list|)
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|suffix_sub
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|suffix_sub
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|suffix_sub
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad suffix after ':' use {b|w|d} Defaulting to d"
argument_list|)
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|4
expr_stmt|;
block|}
name|fromP
operator|++
expr_stmt|;
name|toP
operator|--
expr_stmt|;
comment|/* So we write over the ':' */
if|if
condition|(
name|suffix
operator|<
name|suffix_sub
condition|)
name|suffix
operator|=
name|suffix_sub
expr_stmt|;
block|}
block|}
operator|*
name|toP
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate properly.  */
name|addr_modeP
operator|->
name|disp_suffix
index|[
name|i
index|]
operator|=
name|suffix
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|+=
name|suffix
condition|?
name|suffix
else|:
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
literal|20
condition|)
block|{
comment|/* Look in ns32k_opcode for size.  */
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|0
index|]
operator|=
name|addr_modeP
operator|->
name|am_size
operator|=
name|desc
operator|->
name|im_size
expr_stmt|;
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|addr_modeP
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Read an optionlist.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|optlist
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|ns32k_option
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|optlist
parameter_list|(
name|str
parameter_list|,
name|optionP
parameter_list|,
name|default_map
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The string to extract options from.  */
name|struct
name|ns32k_option
modifier|*
name|optionP
decl_stmt|;
comment|/* How to search the string.  */
name|unsigned
name|long
modifier|*
name|default_map
decl_stmt|;
comment|/* Default pattern and output.  */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|strlen1
decl_stmt|,
name|strlen2
decl_stmt|;
name|char
modifier|*
name|patternP
decl_stmt|,
modifier|*
name|strP
decl_stmt|;
name|strlen1
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen1
operator|<
literal|1
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Very short instr to option, ie you can't do it on a NULLstr"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|strlen2
operator|=
name|strlen
argument_list|(
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen1
condition|;
name|j
operator|++
control|)
block|{
name|patternP
operator|=
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
expr_stmt|;
name|strP
operator|=
operator|&
name|str
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|strlen2
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|strP
operator|++
operator|)
operator|!=
operator|*
operator|(
name|patternP
operator|++
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|k
operator|==
name|strlen2
condition|)
block|{
comment|/* match */
operator|*
name|default_map
operator||=
name|optionP
index|[
name|i
index|]
operator|.
name|or
expr_stmt|;
operator|*
name|default_map
operator|&=
name|optionP
index|[
name|i
index|]
operator|.
name|and
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Search struct for symbols.    This function is used to get the short integer form of reg names in    the instructions lmr, smr, lpr, spr return true if str is found in    list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|list_search
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|ns32k_option
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|list_search
parameter_list|(
name|str
parameter_list|,
name|optionP
parameter_list|,
name|default_map
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The string to match.  */
name|struct
name|ns32k_option
modifier|*
name|optionP
decl_stmt|;
comment|/* List to search.  */
name|unsigned
name|long
modifier|*
name|default_map
decl_stmt|;
comment|/* Default pattern and output.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
argument_list|,
name|str
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* Use strncmp to be safe.  */
operator|*
name|default_map
operator||=
name|optionP
index|[
name|i
index|]
operator|.
name|or
expr_stmt|;
operator|*
name|default_map
operator|&=
name|optionP
index|[
name|i
index|]
operator|.
name|and
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No such entry in list. (cpu/mmu register)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evaluate_expr
parameter_list|(
name|resultP
parameter_list|,
name|ptr
parameter_list|)
name|expressionS
modifier|*
name|resultP
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
name|tmp_line
decl_stmt|;
name|tmp_line
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|ptr
expr_stmt|;
name|expression
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmp_line
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert operands to iif-format and adds bitfields to the opcode.    Operands are parsed in such an order that the opcode is updated from    its most significant bit, that is when the operand need to alter the    opcode.    Be careful not to put to objects in the same iif-slot.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|encode_operand
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|encode_operand
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|operandsP
parameter_list|,
name|suffixP
parameter_list|,
name|im_size
parameter_list|,
name|opcode_bit_ptr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|operandsP
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffixP
decl_stmt|;
name|char
name|im_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
name|opcode_bit_ptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|d
decl_stmt|;
name|int
name|pcrel
decl_stmt|,
name|b
decl_stmt|,
name|loop
decl_stmt|,
name|pcrel_adjust
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|argc
condition|;
name|loop
operator|++
control|)
block|{
comment|/* What operand are we supposed to work on.  */
name|i
operator|=
name|operandsP
index|[
name|loop
operator|<<
literal|1
index|]
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal consistency error.  check ns32k-opcode.h"
argument_list|)
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
name|pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|d
operator|=
name|operandsP
index|[
operator|(
name|loop
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|)
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* Operand of sfsr turns out to be a nasty 				   specialcase.  */
name|opcode_bit_ptr
operator|-=
literal|5
expr_stmt|;
case|case
literal|'Z'
case|:
comment|/* Float not immediate.  */
case|case
literal|'F'
case|:
comment|/* 32 bit float	general form.  */
case|case
literal|'L'
case|:
comment|/* 64 bit float.  */
case|case
literal|'I'
case|:
comment|/* Integer not immediate.  */
case|case
literal|'B'
case|:
comment|/* Byte	 */
case|case
literal|'W'
case|:
comment|/* Word	 */
case|case
literal|'D'
case|:
comment|/* Double-word.  */
case|case
literal|'A'
case|:
comment|/* Double-word	gen-address-form ie no regs 				   allowed.  */
name|get_addr_mode
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|addr_modeP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr_modeP
operator|.
name|mode
operator|==
literal|20
operator|)
operator|&&
operator|(
name|d
operator|==
literal|'I'
operator|||
name|d
operator|==
literal|'Z'
operator|||
name|d
operator|==
literal|'A'
operator|)
condition|)
name|as_fatal
argument_list|(
name|d
operator|==
literal|'A'
condition|?
name|_
argument_list|(
literal|"Address of immediate operand"
argument_list|)
else|:
name|_
argument_list|(
literal|"Invalid immediate write operand."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_bit_ptr
operator|==
name|desc
operator|->
name|opcode_size
condition|)
name|b
operator|=
literal|4
expr_stmt|;
else|else
name|b
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|j
operator|=
name|b
init|;
name|j
operator|<
operator|(
name|b
operator|+
literal|2
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|addr_modeP
operator|.
name|disp
index|[
name|j
operator|-
name|b
index|]
condition|)
block|{
name|IIF
argument_list|(
name|j
argument_list|,
literal|2
argument_list|,
name|addr_modeP
operator|.
name|disp_suffix
index|[
name|j
operator|-
name|b
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr_modeP
operator|.
name|disp
index|[
name|j
operator|-
name|b
index|]
argument_list|,
literal|0
argument_list|,
name|addr_modeP
operator|.
name|pcrel
argument_list|,
name|iif
operator|.
name|instr_size
argument_list|,
name|addr_modeP
operator|.
name|im_disp
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|(
name|addr_modeP
operator|.
name|scaled_reg
condition|?
name|addr_modeP
operator|.
name|scaled_mode
else|:
name|addr_modeP
operator|.
name|mode
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|opcode_bit_ptr
operator|-=
literal|5
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
operator|(
operator|(
name|long
operator|)
name|addr_modeP
operator|.
name|mode
operator|)
operator|<<
name|opcode_bit_ptr
expr_stmt|;
if|if
condition|(
name|addr_modeP
operator|.
name|scaled_reg
condition|)
block|{
name|j
operator|=
name|b
operator|/
literal|2
expr_stmt|;
name|IIF
argument_list|(
name|j
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr_modeP
operator|.
name|index_byte
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
comment|/* Multiple instruction disp.  */
name|freeptr
operator|++
expr_stmt|;
comment|/* OVE:this is an useful hack.  */
name|sprintf
argument_list|(
name|freeptr
argument_list|,
literal|"((%s-1)*%d)"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|desc
operator|->
name|im_size
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|freeptr
expr_stmt|;
name|pcrel
operator|-=
literal|1
expr_stmt|;
comment|/* Make pcrel 0 in spite of what case 'p': 				   wants.  */
comment|/* fall thru */
case|case
literal|'p'
case|:
comment|/* Displacement - pc relative addressing.  */
name|pcrel
operator|+=
literal|1
expr_stmt|;
comment|/* fall thru */
case|case
literal|'d'
case|:
comment|/* Displacement.  */
name|iif
operator|.
name|instr_size
operator|+=
name|suffixP
index|[
name|i
index|]
condition|?
name|suffixP
index|[
name|i
index|]
else|:
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|12
argument_list|,
literal|2
argument_list|,
name|suffixP
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|pcrel
argument_list|,
name|pcrel_adjust
argument_list|,
literal|1
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Sequent-hack: the linker wants a bit set 				   when bsr.  */
name|pcrel
operator|=
literal|1
expr_stmt|;
name|iif
operator|.
name|instr_size
operator|+=
name|suffixP
index|[
name|i
index|]
condition|?
name|suffixP
index|[
name|i
index|]
else|:
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|12
argument_list|,
literal|2
argument_list|,
name|suffixP
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|pcrel
argument_list|,
name|pcrel_adjust
argument_list|,
literal|1
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quick */
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|,
literal|42
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|4
argument_list|,
name|opcode_bit_ptr
argument_list|,
operator|-
literal|8
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Register number (3 bits).  */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt6
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|3
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Setcfg instruction optionslist.  */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt3
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Cinv instruction optionslist.  */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt4
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
comment|/* Insert the regtype in opcode.  */
break|break;
case|case
literal|'S'
case|:
comment|/* String instruction options list.  */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt5
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
comment|/* Register list.  */
name|IIF
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|operandsP
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'u'
case|:
comment|/* Restore, exit.  */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt1
argument_list|,
operator|&
name|iif
operator|.
name|iifP
index|[
literal|10
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Save, enter.  */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt2
argument_list|,
operator|&
name|iif
operator|.
name|iifP
index|[
literal|10
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
break|break;
block|}
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MMU register.  */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|mmureg
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* CPU register.  */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|cpureg
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Inss exts.  */
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
comment|/* 1 byte is allocated after the opcode.  */
name|IIF
argument_list|(
literal|10
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
comment|/* i always 2 here.  */
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
comment|/* A bit_fix is targeted to 						     the byte.  */
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|IIF
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|,
literal|42
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
comment|/* i always 3 here.  */
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
name|b
operator|=
literal|2
operator|+
name|i
expr_stmt|;
comment|/* Put the extension byte after opcode.  */
name|IIF
argument_list|(
name|b
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Bad opcode-table-option, check in file ns32k-opcode.h"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* in:  instruction line    out: internal structure of instruction    that has been prepared for direct conversion to fragment(s) and    fixes in a systematical fashion    Return-value = recursive_level.  */
end_comment

begin_comment
comment|/* Build iif of one assembly text line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parse
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|parse
parameter_list|(
name|line
parameter_list|,
name|recursive_level
parameter_list|)
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|recursive_level
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|lineptr
decl_stmt|;
name|char
name|c
decl_stmt|,
name|suffix_separator
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|argc
decl_stmt|;
name|int
name|arg_type
decl_stmt|;
name|char
name|sqr
decl_stmt|,
name|sep
decl_stmt|;
name|char
name|suffix
index|[
name|MAX_ARGS
index|]
decl_stmt|,
modifier|*
name|argv
index|[
name|MAX_ARGS
index|]
decl_stmt|;
comment|/* No more than 4 operands.  */
if|if
condition|(
name|recursive_level
operator|<=
literal|0
condition|)
block|{
comment|/* Called from md_assemble.  */
for|for
control|(
name|lineptr
operator|=
name|line
init|;
operator|(
operator|*
name|lineptr
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|lineptr
operator|)
operator|!=
literal|' '
condition|;
name|lineptr
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|lineptr
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|lineptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|=
operator|(
expr|struct
name|ns32k_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|inst_hash_handle
argument_list|,
name|line
argument_list|)
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No such opcode"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
name|lineptr
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|lineptr
operator|=
name|line
expr_stmt|;
block|}
name|argc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|desc
operator|->
name|operands
condition|)
block|{
if|if
condition|(
operator|*
name|lineptr
operator|++
operator|!=
literal|'\0'
condition|)
block|{
name|sqr
operator|=
literal|'['
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|operands
index|[
name|argc
operator|<<
literal|1
index|]
condition|)
block|{
name|suffix
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|arg_type
operator|=
name|desc
operator|->
name|operands
index|[
operator|(
name|argc
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|arg_type
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'p'
case|:
case|case
literal|'H'
case|:
comment|/* The operand is supposed to be a displacement.  */
comment|/* Hackwarning: do not forget to update the 4                          cases above when editing ns32k-opcode.h.  */
name|suffix_separator
operator|=
literal|':'
expr_stmt|;
break|break;
default|default:
comment|/* If this char occurs we loose.  */
name|suffix_separator
operator|=
literal|'\255'
expr_stmt|;
break|break;
block|}
name|suffix
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 0 when no ':' is encountered.  */
name|argv
index|[
name|argc
index|]
operator|=
name|freeptr
expr_stmt|;
operator|*
name|freeptr
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lineptr
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|sep
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|sqr
condition|)
block|{
if|if
condition|(
name|sqr
operator|==
literal|'['
condition|)
block|{
name|sqr
operator|=
literal|']'
expr_stmt|;
name|sep
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sqr
operator|=
literal|'['
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|suffix_separator
condition|)
block|{
comment|/* ':' - label/suffix separator.  */
switch|switch
condition|(
name|lineptr
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad suffix, defaulting to d"
argument_list|)
argument_list|)
expr_stmt|;
name|suffix
index|[
name|argc
index|]
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|lineptr
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|lineptr
index|[
literal|1
index|]
operator|==
name|sep
condition|)
block|{
name|lineptr
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|lineptr
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
operator|*
name|freeptr
operator|++
operator|=
name|c
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
operator|*
name|freeptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|argc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\0'
condition|)
continue|continue;
name|lineptr
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Too many operands passed to instruction"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|argc
operator|!=
name|strlen
argument_list|(
name|desc
operator|->
name|operands
argument_list|)
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|desc
operator|->
name|default_args
argument_list|)
condition|)
block|{
comment|/* We can apply default, don't goof.  */
if|if
condition|(
name|parse
argument_list|(
name|desc
operator|->
name|default_args
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
comment|/* Check error in default.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Wrong numbers of operands in default, check ns32k-opcodes.h"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Wrong number of operands"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IIF_ENTRIES
condition|;
name|i
operator|++
control|)
comment|/* Mark all entries as void.  */
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
comment|/* Build opcode iif-entry.  */
name|iif
operator|.
name|instr_size
operator|=
name|desc
operator|->
name|opcode_size
operator|/
literal|8
expr_stmt|;
name|IIF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|iif
operator|.
name|instr_size
argument_list|,
name|desc
operator|->
name|opcode_seed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This call encodes operands to iif format.  */
if|if
condition|(
name|argc
condition|)
block|{
name|encode_operand
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|desc
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
operator|&
name|suffix
index|[
literal|0
index|]
argument_list|,
name|desc
operator|->
name|im_size
argument_list|,
name|desc
operator|->
name|opcode_size
argument_list|)
expr_stmt|;
block|}
return|return
name|recursive_level
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert iif to fragments.  From this point we start to dribble with    functions in other files than this one.(Except hash.c) So, if it's    possible to make an iif for an other CPU, you don't need to know    what frags, relax, obstacks, etc is in order to port this    assembler. You only need to know if it's possible to reduce your    cpu-instruction to iif-format (takes some work) and adopt the other    md_? parts according to given instructions Note that iif was    invented for the clean ns32k`s architecture.  */
end_comment

begin_comment
comment|/* GAS for the ns32k has a problem. PC relative displacements are    relative to the address of the opcode, not the address of the    operand. We used to keep track of the offset between the operand    and the opcode in pcrel_adjust for each frag and each fix. However,    we get into trouble where there are two or more pc-relative    operands and the size of the first one can't be determined. Then in    the relax phase, the size of the first operand will change and    pcrel_adjust will no longer be correct.  The current solution is    keep a pointer to the frag with the opcode in it and the offset in    that frag for each frag and each fix. Then, when needed, we can    always figure out how far it is between the opcode and the pcrel    object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For    objects not part of an instruction, the pointer to the opcode frag    is always zero.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|convert_iif
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|convert_iif
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bit_fixS
modifier|*
name|j
decl_stmt|;
name|fragS
modifier|*
name|inst_frag
decl_stmt|;
name|unsigned
name|int
name|inst_offset
decl_stmt|;
name|char
modifier|*
name|inst_opcode
decl_stmt|;
name|char
modifier|*
name|memP
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
name|type
decl_stmt|;
name|char
name|size
init|=
literal|0
decl_stmt|;
name|frag_grow
argument_list|(
name|iif
operator|.
name|instr_size
argument_list|)
expr_stmt|;
comment|/* This is important.  */
name|memP
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inst_opcode
operator|=
name|memP
expr_stmt|;
name|inst_offset
operator|=
operator|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
expr_stmt|;
name|inst_frag
operator|=
name|frag_now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IIF_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|type
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|type
operator|)
condition|)
block|{
comment|/* The object exist, so handle it.  */
switch|switch
condition|(
name|size
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
case|case
literal|42
case|:
name|size
operator|=
literal|0
expr_stmt|;
comment|/* It's a bitfix that operates on an existing object.  */
if|if
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
operator|->
name|fx_bit_base
condition|)
comment|/* Expand fx_bit_base to point at opcode.  */
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
operator|->
name|fx_bit_base
operator|=
operator|(
name|long
operator|)
name|inst_opcode
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|8
case|:
comment|/* bignum or doublefloat.  */
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|/* The final size in objectmemory is known.  */
name|memP
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|j
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* The object is pure binary.  */
if|if
condition|(
name|j
condition|)
block|{
name|md_number_to_field
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
argument_list|,
literal|0
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
argument_list|,
comment|/* Sequent hack.  */
name|inst_frag
argument_list|,
name|inst_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Good, just put them bytes out.  */
switch|switch
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
condition|)
block|{
case|case
literal|0
case|:
name|md_number_to_chars
argument_list|(
name|memP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"iif convert internal pcrel/binary"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* The object is a pointer at an expression, so                      unpack it, note that bignums may result from the                      expression.  */
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprP
operator|.
name|X_op
operator|==
name|O_big
operator|||
name|size
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|exprP
operator|.
name|X_add_number
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* We have a bignum ie a quad. This can only                              happens in a long suffixed instruction.  */
if|if
condition|(
name|k
operator|*
literal|2
operator|>
name|size
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bignum too big for long"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|3
condition|)
name|memP
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
operator|,
name|l
operator|+=
literal|2
control|)
name|md_number_to_chars
argument_list|(
name|memP
operator|+
name|l
argument_list|,
name|generic_bignum
index|[
name|l
operator|>>
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flonum.  */
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|4
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
operator|(
name|memP
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
operator|(
name|memP
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_op_symbol
operator|||
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
comment|/* The expression was undefined due to an                          undefined label. Create a fix so we can fix                          the object later.  */
name|exprP
operator|.
name|X_add_number
operator|+=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object_adjust
expr_stmt|;
name|fix_new_ns32k_exp
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
operator|&
name|exprP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
argument_list|,
name|j
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
argument_list|,
name|inst_frag
argument_list|,
name|inst_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
condition|)
block|{
name|md_number_to_field
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Good, just put them bytes out.  */
switch|switch
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
condition|)
block|{
case|case
literal|0
case|:
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"iif convert internal pcrel/pointer"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal logic error in iif.iifP[n].type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* Too bad, the object may be undefined as far as its 		 final nsize in object memory is concerned.  The size 		 of the object in objectmemory is not explicitly 		 given.  If the object is defined its length can be 		 determined and a fix can replace the frag.  */
block|{
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_op_symbol
operator|)
operator|&&
operator|!
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
comment|/* Size is unknown until link time so have to default.  */
name|size
operator|=
name|default_disp_size
expr_stmt|;
comment|/* Normally 4 bytes.  */
name|memP
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fix_new_ns32k_exp
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
operator|&
name|exprP
argument_list|,
literal|0
argument_list|,
comment|/* never iif.iifP[i].pcrel, */
literal|1
argument_list|,
comment|/* always iif.iifP[i].im_disp */
operator|(
name|bit_fixS
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|inst_frag
argument_list|,
name|inst_offset
argument_list|)
expr_stmt|;
break|break;
comment|/* Exit this absolute hack.  */
block|}
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_op_symbol
condition|)
block|{
comment|/* Frag it.  */
if|if
condition|(
name|exprP
operator|.
name|X_op_symbol
condition|)
block|{
comment|/* We cant relax this case.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't relax difference"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Size is not important.  This gets fixed by 			   relax, but we assume 0 in what follows.  */
name|memP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Max size.  */
name|size
operator|=
literal|0
expr_stmt|;
block|{
name|fragS
modifier|*
name|old_frag
init|=
name|frag_now
decl_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
comment|/* Max size.  */
literal|0
argument_list|,
comment|/* Size.  */
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|UNDEF
argument_list|)
argument_list|,
comment|/* Expecting                                                                 the worst.  */
name|exprP
operator|.
name|X_add_symbol
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|inst_opcode
argument_list|)
expr_stmt|;
name|frag_opcode_frag
argument_list|(
name|old_frag
argument_list|)
operator|=
name|inst_frag
expr_stmt|;
name|frag_opcode_offset
argument_list|(
name|old_frag
argument_list|)
operator|=
name|inst_offset
expr_stmt|;
name|frag_bsr
argument_list|(
name|old_frag
argument_list|)
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* This duplicates code in md_number_to_disp.  */
if|if
condition|(
operator|-
literal|64
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|63
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|-
literal|8192
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|8191
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|-
literal|0x20000000
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|0x1fffffff
condition|)
block|{
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Displacement to large for :d"
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
name|memP
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal logic error in iif.iifP[].type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* This functionality should really be in the bfd library.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|reloc
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|length
decl_stmt|,
name|index
decl_stmt|;
name|bfd_reloc_code_real_type
name|relocs
index|[]
init|=
block|{
name|BFD_RELOC_NS32K_IMM_8
block|,
name|BFD_RELOC_NS32K_IMM_16
block|,
name|BFD_RELOC_NS32K_IMM_32
block|,
name|BFD_RELOC_NS32K_IMM_8_PCREL
block|,
name|BFD_RELOC_NS32K_IMM_16_PCREL
block|,
name|BFD_RELOC_NS32K_IMM_32_PCREL
block|,
comment|/* ns32k displacements.  */
name|BFD_RELOC_NS32K_DISP_8
block|,
name|BFD_RELOC_NS32K_DISP_16
block|,
name|BFD_RELOC_NS32K_DISP_32
block|,
name|BFD_RELOC_NS32K_DISP_8_PCREL
block|,
name|BFD_RELOC_NS32K_DISP_16_PCREL
block|,
name|BFD_RELOC_NS32K_DISP_32_PCREL
block|,
comment|/* Normal 2's complement.  */
name|BFD_RELOC_8
block|,
name|BFD_RELOC_16
block|,
name|BFD_RELOC_32
block|,
name|BFD_RELOC_8_PCREL
block|,
name|BFD_RELOC_16_PCREL
block|,
name|BFD_RELOC_32_PCREL
block|}
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|length
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|length
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|length
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|index
operator|=
name|length
operator|+
literal|3
operator|*
name|pcrel
operator|+
literal|6
operator|*
name|type
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|index
operator|<
sizeof|sizeof
argument_list|(
name|relocs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|relocs
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|relocs
index|[
name|index
index|]
return|;
if|if
condition|(
name|pcrel
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte pc-relative relocation for storage type %d"
argument_list|)
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can not do %d byte relocation for storage type %d"
argument_list|)
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|freeptr
operator|=
name|freeptr_static
expr_stmt|;
name|parse
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Explode line to more fix form in iif.  */
name|convert_iif
argument_list|()
expr_stmt|;
comment|/* Convert iif to frags, fix's etc.  */
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|" \t\t\t%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* Build a hashtable of the instructions.  */
specifier|const
name|struct
name|ns32k_opcode
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|stat
decl_stmt|;
specifier|const
name|struct
name|ns32k_opcode
modifier|*
name|endop
decl_stmt|;
name|inst_hash_handle
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|endop
operator|=
name|ns32k_opcodes
operator|+
sizeof|sizeof
argument_list|(
name|ns32k_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ns32k_opcodes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|ns32k_opcodes
init|;
name|ptr
operator|<
name|endop
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|stat
operator|=
name|hash_insert
argument_list|(
name|inst_hash_handle
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
operator|)
condition|)
comment|/* Fatal.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash %s: %s"
argument_list|)
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
comment|/* Some private space please!  */
name|freeptr_static
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|PRIVATE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be equal to MAX_PRECISON in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant    of type TYPE, and emit the appropriate bytes.  The number of    LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
operator|--
name|wordP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert number to chars in correct order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|value
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a variant of md_numbers_to_chars. The reason for its'    existence is the fact that ns32k uses Huffman coded    displacements. This implies that the bit order is reversed in    displacements and that they are prefixed with a size-tag.     binary: msb -> lsb    0xxxxxxx				byte    10xxxxxx xxxxxxxx			word    11xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx	double word     This must be taken care of and we do it here!  */
end_comment

begin_function
specifier|static
name|void
name|md_number_to_disp
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|char
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|64
operator|||
name|val
operator|>
literal|63
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value of %ld out of byte displacement range."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0x7f
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|8192
operator|||
name|val
operator|>
literal|8191
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value of %ld out of word displacement range."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0x3fff
expr_stmt|;
name|val
operator||=
literal|0x8000
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|0x20000000
operator|||
name|val
operator|>=
literal|0x20000000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"value of %ld out of double word displacement range."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0xc0000000
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|24
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|16
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal logic error.  line %d, file \"%s\""
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|md_number_to_imm
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|char
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|24
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|16
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Internal logic error. line %d, file \"%s\""
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fast bitfiddling support.  */
end_comment

begin_comment
comment|/* Mask used to zero bitfield before oring in the true field.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|l_mask
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xfffffffe
block|,
literal|0xfffffffc
block|,
literal|0xfffffff8
block|,
literal|0xfffffff0
block|,
literal|0xffffffe0
block|,
literal|0xffffffc0
block|,
literal|0xffffff80
block|,
literal|0xffffff00
block|,
literal|0xfffffe00
block|,
literal|0xfffffc00
block|,
literal|0xfffff800
block|,
literal|0xfffff000
block|,
literal|0xffffe000
block|,
literal|0xffffc000
block|,
literal|0xffff8000
block|,
literal|0xffff0000
block|,
literal|0xfffe0000
block|,
literal|0xfffc0000
block|,
literal|0xfff80000
block|,
literal|0xfff00000
block|,
literal|0xffe00000
block|,
literal|0xffc00000
block|,
literal|0xff800000
block|,
literal|0xff000000
block|,
literal|0xfe000000
block|,
literal|0xfc000000
block|,
literal|0xf8000000
block|,
literal|0xf0000000
block|,
literal|0xe0000000
block|,
literal|0xc0000000
block|,
literal|0x80000000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|r_mask
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MASK_BITS
value|31
end_define

begin_comment
comment|/* Insert bitfield described by field_ptr and val at buf    This routine is written for modification of the first 4 bytes pointed    to by buf, to yield speed.    The ifdef stuff is for selection between a ns32k-dependent routine    and a general version. (My advice: use the general version!).  */
end_comment

begin_function
specifier|static
name|void
name|md_number_to_field
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|field_ptr
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|bit_fixS
modifier|*
name|field_ptr
decl_stmt|;
block|{
name|unsigned
name|long
name|object
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Define ENDIAN on a ns32k machine.  */
ifdef|#
directive|ifdef
name|ENDIAN
name|unsigned
name|long
modifier|*
name|mem_ptr
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|mem_ptr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_min
operator|<=
name|val
operator|&&
name|val
operator|<=
name|field_ptr
operator|->
name|fx_bit_max
condition|)
block|{
ifdef|#
directive|ifdef
name|ENDIAN
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_base
condition|)
comment|/* Override buf.  */
name|mem_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|field_ptr
operator|->
name|fx_bit_base
expr_stmt|;
else|else
name|mem_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|buf
expr_stmt|;
name|mem_ptr
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mem_ptr
operator|+
name|field_ptr
operator|->
name|fx_bit_base_adj
operator|)
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_base
condition|)
name|mem_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|field_ptr
operator|->
name|fx_bit_base
expr_stmt|;
else|else
name|mem_ptr
operator|=
name|buf
expr_stmt|;
name|mem_ptr
operator|+=
name|field_ptr
operator|->
name|fx_bit_base_adj
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENDIAN
comment|/* We have a nice ns32k machine with lowbyte at low-physical mem.  */
name|object
operator|=
operator|*
name|mem_ptr
expr_stmt|;
comment|/* get some bytes */
else|#
directive|else
comment|/* OVE Goof! the machine is a m68k or dito.  */
comment|/* That takes more byte fiddling.  */
name|object
operator|=
literal|0
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
endif|#
directive|endif
name|mask
operator|=
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|r_mask
index|[
name|field_ptr
operator|->
name|fx_bit_offset
index|]
operator|)
expr_stmt|;
name|mask
operator||=
operator|(
name|l_mask
index|[
name|field_ptr
operator|->
name|fx_bit_offset
operator|+
name|field_ptr
operator|->
name|fx_bit_size
index|]
operator|)
expr_stmt|;
name|object
operator|&=
name|mask
expr_stmt|;
name|val
operator|+=
name|field_ptr
operator|->
name|fx_bit_add
expr_stmt|;
name|object
operator||=
operator|(
operator|(
name|val
operator|<<
name|field_ptr
operator|->
name|fx_bit_offset
operator|)
operator|&
operator|(
name|mask
operator|^
literal|0xffffffff
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENDIAN
operator|*
name|mem_ptr
operator|=
name|object
expr_stmt|;
else|#
directive|else
name|mem_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bit field out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|md_pcrel_adjust
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|fragS
modifier|*
name|opcode_frag
decl_stmt|;
name|addressT
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|opcode_frag
operator|=
name|frag_opcode_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_frag
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|frag_opcode_offset
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|opcode_address
operator|=
name|offset
operator|+
name|opcode_frag
operator|->
name|fr_address
expr_stmt|;
return|return
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|opcode_address
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|md_fix_pcrel_adjust
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
name|fixP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|md_fix_pcrel_adjust
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|fragS
modifier|*
name|opcode_frag
decl_stmt|;
name|addressT
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|opcode_frag
operator|=
name|fix_opcode_frag
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_frag
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|fix_opcode_offset
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|opcode_address
operator|=
name|offset
operator|+
name|opcode_frag
operator|->
name|fr_address
expr_stmt|;
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|-
name|opcode_address
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixS (fixup of an instruction or data that we didn't have    enough info to complete immediately) to the data in a frag.     On the ns32k, everything is in a different format, so we have broken    out separate functions for each kind of thing we could be fixing.    They all get called from here.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
name|fix_bit_fixP
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* Bitfields to fix, sigh.  */
name|md_number_to_field
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fix_bit_fixP
argument_list|(
name|fixP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|fix_im_disp
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Immediate field.  */
name|md_number_to_imm
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Displacement field.  */
comment|/* Calculate offset.  */
name|md_number_to_disp
argument_list|(
name|buf
argument_list|,
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
name|val
operator|+
name|md_fix_pcrel_adjust
argument_list|(
name|fixP
argument_list|)
else|:
name|val
operator|)
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Pointer in a data object.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a relaxed displacement to ditto in final output.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
else|#
directive|else
function|void md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
endif|#
directive|endif
block|{
name|long
name|disp
decl_stmt|;
name|long
name|ext
init|=
literal|0
decl_stmt|;
comment|/* Address in gas core of the place to store the displacement.  */
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
decl_stmt|;
comment|/* Address in object code of the displacement.  */
name|int
name|object_address
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
case|:
name|ext
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|WORD
argument_list|)
case|:
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|DOUBLE
argument_list|)
case|:
name|ext
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ext
operator|==
literal|0
condition|)
return|return;
name|know
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|object_address
operator|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
expr_stmt|;
comment|/* The displacement of the address, from current location.  */
name|disp
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
operator|-
name|object_address
expr_stmt|;
name|disp
operator|+=
name|md_pcrel_adjust
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|buffer_address
argument_list|,
operator|(
name|long
operator|)
name|disp
argument_list|,
operator|(
name|int
operator|)
name|ext
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|ext
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function returns the estimated size a variable object will occupy,    one can say that we tries to guess the size of the objects before we    actually know it.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|UNDEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
comment|/* We don't relax symbols defined in another segment.  The 	     thing to do is to assume the object will occupy 4 bytes.  */
name|fix_new_ns32k
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|frag_bsr
argument_list|(
name|fragP
argument_list|)
argument_list|,
comment|/* Sequent hack.  */
name|frag_opcode_frag
argument_list|(
name|fragP
argument_list|)
argument_list|,
name|frag_opcode_offset
argument_list|(
name|fragP
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
if|#
directive|if
literal|0
block|fragP->fr_opcode[1] = 0xff;
endif|#
directive|endif
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/* Relaxable case.  Set up the initial guess for the variable 	 part of the frag.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Return the size of the variable part of the frag.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record.  */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|valueT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xEA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|valueT
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|valueT
operator|)
literal|0xEA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|valueT
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_DISP_SIZE
value|(OPTION_MD_BASE)
block|{
literal|"disp-size-default"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DISP_SIZE
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32032"
argument_list|)
condition|)
block|{
name|cpureg
operator|=
name|cpureg_032
expr_stmt|;
name|mmureg
operator|=
name|mmureg_032
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32532"
argument_list|)
condition|)
block|{
name|cpureg
operator|=
name|cpureg_532
expr_stmt|;
name|mmureg
operator|=
name|mmureg_532
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid architecture option -m%s, ignored"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|OPTION_DISP_SIZE
case|:
block|{
name|int
name|size
init|=
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|default_disp_size
operator|=
name|size
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid default displacement size \"%s\". Defaulting to %d."
argument_list|)
argument_list|,
name|arg
argument_list|,
name|default_disp_size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ NS32K options:\n\ -m32032 | -m32532	select variant of NS32K architecture\n\ --disp-size-default=<1|2|4>\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a bit_fixS in obstack 'notes'.    This struct is used to profile the normal fix. If the bit_fixP is a    valid pointer (not NULL) the bit_fix data will be used to format    the fix.  */
end_comment

begin_function
name|bit_fixS
modifier|*
name|bit_fix_new
parameter_list|(
name|size
parameter_list|,
name|offset
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|add
parameter_list|,
name|base_type
parameter_list|,
name|base_adj
parameter_list|)
name|char
name|size
decl_stmt|;
comment|/* Length of bitfield.  */
name|char
name|offset
decl_stmt|;
comment|/* Bit offset to bitfield.  */
name|long
name|min
decl_stmt|;
comment|/* Signextended min for bitfield.  */
name|long
name|max
decl_stmt|;
comment|/* Signextended max for bitfield.  */
name|long
name|add
decl_stmt|;
comment|/* Add mask, used for huffman prefix.  */
name|long
name|base_type
decl_stmt|;
comment|/* 0 or 1, if 1 it's exploded to opcode ptr.  */
name|long
name|base_adj
decl_stmt|;
block|{
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
name|bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|bit_fixS
argument_list|)
argument_list|)
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_size
operator|=
name|size
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_offset
operator|=
name|offset
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_base
operator|=
name|base_type
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_base_adj
operator|=
name|base_adj
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_max
operator|=
name|max
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_min
operator|=
name|min
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_add
operator|=
name|add
expr_stmt|;
return|return
name|bit_fixP
return|;
block|}
end_function

begin_function
name|void
name|fix_new_ns32k
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|im_disp
parameter_list|,
name|bit_fixP
parameter_list|,
name|bsr
parameter_list|,
name|opcode_frag
parameter_list|,
name|opcode_offset
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2  or 4 usually.  */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol.  */
name|long
name|offset
decl_stmt|;
comment|/* X_add_number.  */
name|int
name|pcrel
decl_stmt|;
comment|/* True if PC-relative relocation.  */
name|char
name|im_disp
decl_stmt|;
comment|/* True if the value to write is a 				   displacement.  */
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
comment|/* Pointer at struct of bit_fix's, ignored if 				   NULL.  */
name|char
name|bsr
decl_stmt|;
comment|/* Sequent-linker-hack: 1 when relocobject is 				   a bsr.  */
name|fragS
modifier|*
name|opcode_frag
decl_stmt|;
name|unsigned
name|int
name|opcode_offset
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
init|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bit_fixP
condition|?
name|NO_RELOC
else|:
name|reloc
argument_list|(
argument|size
argument_list|,
argument|pcrel
argument_list|,
argument|im_disp
argument_list|)
else|#
directive|else
name|NO_RELOC
endif|#
directive|endif
argument_list|)
decl_stmt|;
name|fix_opcode_frag
argument_list|(
name|fixP
argument_list|)
operator|=
name|opcode_frag
expr_stmt|;
name|fix_opcode_offset
argument_list|(
name|fixP
argument_list|)
operator|=
name|opcode_offset
expr_stmt|;
name|fix_im_disp
argument_list|(
name|fixP
argument_list|)
operator|=
name|im_disp
expr_stmt|;
name|fix_bsr
argument_list|(
name|fixP
argument_list|)
operator|=
name|bsr
expr_stmt|;
name|fix_bit_fixP
argument_list|(
name|fixP
argument_list|)
operator|=
name|bit_fixP
expr_stmt|;
comment|/* We have a MD overflow check for displacements.  */
name|fixP
operator|->
name|fx_no_overflow
operator|=
operator|(
name|im_disp
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fix_new_ns32k_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|,
name|pcrel
parameter_list|,
name|im_disp
parameter_list|,
name|bit_fixP
parameter_list|,
name|bsr
parameter_list|,
name|opcode_frag
parameter_list|,
name|opcode_offset
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2  or 4 usually.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
comment|/* Expression.  */
name|int
name|pcrel
decl_stmt|;
comment|/* True if PC-relative relocation.  */
name|char
name|im_disp
decl_stmt|;
comment|/* True if the value to write is a 				   displacement.  */
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
comment|/* Pointer at struct of bit_fix's, ignored if 				   NULL.  */
name|char
name|bsr
decl_stmt|;
comment|/* Sequent-linker-hack: 1 when relocobject is 				   a bsr.  */
name|fragS
modifier|*
name|opcode_frag
decl_stmt|;
name|unsigned
name|int
name|opcode_offset
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
init|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bit_fixP
condition|?
name|NO_RELOC
else|:
name|reloc
argument_list|(
argument|size
argument_list|,
argument|pcrel
argument_list|,
argument|im_disp
argument_list|)
else|#
directive|else
name|NO_RELOC
endif|#
directive|endif
argument_list|)
decl_stmt|;
name|fix_opcode_frag
argument_list|(
name|fixP
argument_list|)
operator|=
name|opcode_frag
expr_stmt|;
name|fix_opcode_offset
argument_list|(
name|fixP
argument_list|)
operator|=
name|opcode_offset
expr_stmt|;
name|fix_im_disp
argument_list|(
name|fixP
argument_list|)
operator|=
name|im_disp
expr_stmt|;
name|fix_bsr
argument_list|(
name|fixP
argument_list|)
operator|=
name|bsr
expr_stmt|;
name|fix_bit_fixP
argument_list|(
name|fixP
argument_list|)
operator|=
name|bit_fixP
expr_stmt|;
comment|/* We have a MD overflow check for displacements.  */
name|fixP
operator|->
name|fx_no_overflow
operator|=
operator|(
name|im_disp
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is TC_CONS_FIX_NEW, called by emit_expr in read.c.  */
end_comment

begin_function
name|void
name|cons_fix_new_ns32k
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2  or 4 usually.  */
name|expressionS
modifier|*
name|exp
decl_stmt|;
comment|/* Expression.  */
block|{
name|fix_new_ns32k_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine.  */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?  On the    ns32k, they're relative to the start of the instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|long
name|res
decl_stmt|;
name|res
operator|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
ifdef|#
directive|ifdef
name|SEQUENT_COMPATABILITY
if|if
condition|(
name|frag_bsr
argument_list|(
name|fixP
operator|->
name|fx_frag
argument_list|)
condition|)
name|res
operator|+=
literal|0x12
comment|/* FOO Kludge alert!  */
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|code
operator|=
name|reloc
argument_list|(
name|fixp
operator|->
name|fx_size
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|,
name|fix_im_disp
argument_list|(
name|fixp
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rel
operator|->
name|howto
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Cannot find relocation type for symbol %s, code %d"
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_function
name|void
name|cons_fix_new_ns32k
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* In:  Length of relocation (or of address) in chars: 1, 2 or 4.      Out: GNU LD relocation length code: 0, 1, or 2.  */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
operator|+
literal|4
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|r_symbolnum
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|24
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|25
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|27
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|fix_bsr
argument_list|(
name|fixP
argument_list|)
operator|<<
literal|28
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|fix_im_disp
argument_list|(
name|fixP
argument_list|)
operator|<<
literal|29
argument_list|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

end_unit

