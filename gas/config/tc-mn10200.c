begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mn10200.c -- Assembler code for the Matsushita 10200    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,    2005, 2006  Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mn10200.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|reg_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* bCC relaxing  */
block|{
literal|0x81
block|,
operator|-
literal|0x7e
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|0x8004
block|,
operator|-
literal|0x7ffb
block|,
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|0x800006
block|,
operator|-
literal|0x7ffff9
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* bCCx relaxing  */
block|{
literal|0x81
block|,
operator|-
literal|0x7e
block|,
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0x8004
block|,
operator|-
literal|0x7ffb
block|,
literal|6
block|,
literal|5
block|}
block|,
block|{
literal|0x800006
block|,
operator|-
literal|0x7ffff9
block|,
literal|8
block|,
literal|0
block|}
block|,
comment|/* jsr relaxing  */
block|{
literal|0x8004
block|,
operator|-
literal|0x7ffb
block|,
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0x800006
block|,
operator|-
literal|0x7ffff9
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* jmp relaxing  */
block|{
literal|0x81
block|,
operator|-
literal|0x7e
block|,
literal|2
block|,
literal|9
block|}
block|,
block|{
literal|0x8004
block|,
operator|-
literal|0x7ffb
block|,
literal|3
block|,
literal|10
block|}
block|,
block|{
literal|0x800006
block|,
operator|-
literal|0x7ffff9
block|,
literal|5
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fixups.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|5
end_define

begin_struct
struct|struct
name|mn10200_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mn10200_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mn10200_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|data_registers
index|[]
init|=
block|{
block|{
literal|"d0"
block|,
literal|0
block|}
block|,
block|{
literal|"d1"
block|,
literal|1
block|}
block|,
block|{
literal|"d2"
block|,
literal|2
block|}
block|,
block|{
literal|"d3"
block|,
literal|3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DATA_REG_NAME_CNT
define|\
value|(sizeof (data_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|address_registers
index|[]
init|=
block|{
block|{
literal|"a0"
block|,
literal|0
block|}
block|,
block|{
literal|"a1"
block|,
literal|1
block|}
block|,
block|{
literal|"a2"
block|,
literal|2
block|}
block|,
block|{
literal|"a3"
block|,
literal|3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDRESS_REG_NAME_CNT
define|\
value|(sizeof (address_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|other_registers
index|[]
init|=
block|{
block|{
literal|"mdr"
block|,
literal|0
block|}
block|,
block|{
literal|"psw"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OTHER_REG_NAME_CNT
define|\
value|(sizeof (other_registers) / sizeof (struct reg_name))
end_define

begin_comment
comment|/* reg_name_search does a binary search of the given register table    to see if "name" is a valid regiter name.  Returns the register    number from the array on success, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
specifier|const
name|struct
name|reg_name
modifier|*
name|regs
parameter_list|,
name|int
name|regcount
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().     in: Input_line_pointer points to 1st char of operand.     out: An expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|data_register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|data_registers
argument_list|,
name|DATA_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().     in: Input_line_pointer points to 1st char of operand.     out: An expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|address_register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|address_registers
argument_list|,
name|ADDRESS_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().     in: Input_line_pointer points to 1st char of operand.     out: An expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|other_register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|other_registers
argument_list|,
name|OTHER_REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"MN10200 options:\n\ none yet\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litp
parameter_list|,
name|int
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|static
name|unsigned
name|long
name|label_count
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|opcode
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xe0
case|:
name|opcode
operator|=
literal|0xe2
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|opcode
operator|=
literal|0xe0
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|opcode
operator|=
literal|0xe1
expr_stmt|;
break|break;
case|case
literal|0xe1
case|:
name|opcode
operator|=
literal|0xe3
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|opcode
operator|=
literal|0xe6
expr_stmt|;
break|break;
case|case
literal|0xe6
case|:
name|opcode
operator|=
literal|0xe4
expr_stmt|;
break|break;
case|case
literal|0xe7
case|:
name|opcode
operator|=
literal|0xe5
expr_stmt|;
break|break;
case|case
literal|0xe5
case|:
name|opcode
operator|=
literal|0xe7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|0xfc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|3
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|opcode
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xe0
case|:
name|opcode
operator|=
literal|0xe2
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|opcode
operator|=
literal|0xe0
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|opcode
operator|=
literal|0xe1
expr_stmt|;
break|break;
case|case
literal|0xe1
case|:
name|opcode
operator|=
literal|0xe3
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|opcode
operator|=
literal|0xe6
expr_stmt|;
break|break;
case|case
literal|0xe6
case|:
name|opcode
operator|=
literal|0xe4
expr_stmt|;
break|break;
case|case
literal|0xe7
case|:
name|opcode
operator|=
literal|0xe5
expr_stmt|;
break|break;
case|case
literal|0xe5
case|:
name|opcode
operator|=
literal|0xe7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|0xf4
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xe0
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_24_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|3
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|4
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xfc
case|:
name|opcode
operator|=
literal|0xfd
expr_stmt|;
break|break;
case|case
literal|0xfd
case|:
name|opcode
operator|=
literal|0xfc
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
name|opcode
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|opcode
operator|=
literal|0xfe
expr_stmt|;
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|opcode
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xe0
case|:
name|opcode
operator|=
literal|0xe2
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|opcode
operator|=
literal|0xe0
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|opcode
operator|=
literal|0xe1
expr_stmt|;
break|break;
case|case
literal|0xe1
case|:
name|opcode
operator|=
literal|0xe3
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|opcode
operator|=
literal|0xe6
expr_stmt|;
break|break;
case|case
literal|0xe6
case|:
name|opcode
operator|=
literal|0xe4
expr_stmt|;
break|break;
case|case
literal|0xe7
case|:
name|opcode
operator|=
literal|0xe5
expr_stmt|;
break|break;
case|case
literal|0xe5
case|:
name|opcode
operator|=
literal|0xe7
expr_stmt|;
break|break;
case|case
literal|0xec
case|:
name|opcode
operator|=
literal|0xed
expr_stmt|;
break|break;
case|case
literal|0xed
case|:
name|opcode
operator|=
literal|0xec
expr_stmt|;
break|break;
case|case
literal|0xee
case|:
name|opcode
operator|=
literal|0xef
expr_stmt|;
break|break;
case|case
literal|0xef
case|:
name|opcode
operator|=
literal|0xee
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xfc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|5
condition|)
block|{
comment|/* Reverse the condition of the first branch.  */
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|int
name|opcode
init|=
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0xfc
case|:
name|opcode
operator|=
literal|0xfd
expr_stmt|;
break|break;
case|case
literal|0xfd
case|:
name|opcode
operator|=
literal|0xfc
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
name|opcode
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|opcode
operator|=
literal|0xfe
expr_stmt|;
case|case
literal|0xe8
case|:
name|opcode
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|opcode
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xe0
case|:
name|opcode
operator|=
literal|0xe2
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|opcode
operator|=
literal|0xe0
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|opcode
operator|=
literal|0xe1
expr_stmt|;
break|break;
case|case
literal|0xe1
case|:
name|opcode
operator|=
literal|0xe3
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|opcode
operator|=
literal|0xe6
expr_stmt|;
break|break;
case|case
literal|0xe6
case|:
name|opcode
operator|=
literal|0xe4
expr_stmt|;
break|break;
case|case
literal|0xe7
case|:
name|opcode
operator|=
literal|0xe5
expr_stmt|;
break|break;
case|case
literal|0xe5
case|:
name|opcode
operator|=
literal|0xe7
expr_stmt|;
break|break;
case|case
literal|0xec
case|:
name|opcode
operator|=
literal|0xed
expr_stmt|;
break|break;
case|case
literal|0xed
case|:
name|opcode
operator|=
literal|0xec
expr_stmt|;
break|break;
case|case
literal|0xee
case|:
name|opcode
operator|=
literal|0xef
expr_stmt|;
break|break;
case|case
literal|0xef
case|:
name|opcode
operator|=
literal|0xee
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Create a fixup for the reversed conditional branch.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s_%ld"
argument_list|,
name|FAKE_LABEL_NAME
argument_list|,
name|label_count
operator|++
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the 	 final target.  */
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|3
index|]
operator|=
literal|0xf4
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|0xe0
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|5
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_24_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|6
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|7
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xf4
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
literal|0xe1
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_24_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|8
condition|)
block|{
name|fragP
operator|->
name|fr_literal
index|[
name|fragP
operator|->
name|fr_fix
index|]
operator|=
literal|0xea
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|9
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xfc
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|10
condition|)
block|{
name|int
name|offset
init|=
name|fragP
operator|->
name|fr_fix
decl_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
index|]
operator|=
literal|0xf4
expr_stmt|;
name|fragP
operator|->
name|fr_literal
index|[
name|offset
operator|+
literal|1
index|]
operator|=
literal|0xe0
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_24_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|5
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
specifier|register
specifier|const
name|struct
name|mn10200_opcode
modifier|*
name|op
decl_stmt|;
name|mn10200_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  The MN10200 instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
name|op
operator|=
name|mn10200_opcodes
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|op
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|mn10200_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
name|op
operator|++
expr_stmt|;
block|}
comment|/* This is both a simplification (we don't have to write md_apply_fix)      and support for future optimizations (branch shortening and similar      stuff in the linker.  */
name|linkrelax
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|check_operand
parameter_list|(
name|unsigned
name|long
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|struct
name|mn10200_operand
modifier|*
name|operand
parameter_list|,
name|offsetT
name|val
parameter_list|)
block|{
comment|/* No need to check 24bit or 32bit operands for a bit.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|<
literal|24
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_NOCHECK
operator|)
operator|==
literal|0
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    Then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_offset
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* FIXME: We should try more ways to resolve difference expressions 	   here.  At least this is better than silently ignoring the 	   subtrahend.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't resolve `%s' {%s section} - `%s' {%s section}"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_addsy
condition|?
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
else|:
literal|"0"
argument_list|,
name|segment_name
argument_list|(
name|fixp
operator|->
name|fx_addsy
condition|?
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
else|:
name|absolute_section
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|6
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|==
literal|8
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|md_relax_table
index|[
name|fragp
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We shouldn't ever get here because linkrelax is nonzero.  */
name|abort
argument_list|()
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mn10200_insert_operand
parameter_list|(
name|unsigned
name|long
modifier|*
name|insnp
parameter_list|,
name|unsigned
name|long
modifier|*
name|extensionp
parameter_list|,
specifier|const
name|struct
name|mn10200_operand
modifier|*
name|operand
parameter_list|,
name|offsetT
name|val
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|shift
parameter_list|)
block|{
comment|/* No need to check 24 or 32bit operands for a bit.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|<
literal|24
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_NOCHECK
operator|)
operator|==
literal|0
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
name|as_warn_value_out_of_range
argument_list|(
name|_
argument_list|(
literal|"operand"
argument_list|)
argument_list|,
name|test
argument_list|,
operator|(
name|offsetT
operator|)
name|min
argument_list|,
operator|(
name|offsetT
operator|)
name|max
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_EXTENDED
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|insnp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_REPEATED
operator|)
operator|!=
literal|0
condition|)
operator|*
name|insnp
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|operand
operator|->
name|shift
operator|+
name|shift
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|extensionp
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|insnp
operator||=
name|val
operator|&
literal|0xffff
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|mn10200_opcode
modifier|*
name|opcode
decl_stmt|;
name|struct
name|mn10200_opcode
modifier|*
name|next_opcode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|next_opindex
decl_stmt|,
name|relaxable
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|,
name|extension
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
decl_stmt|;
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the first opcode with the proper name.  */
name|opcode
operator|=
operator|(
expr|struct
name|mn10200_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mn10200_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|int
name|op_idx
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|int
name|extra_shift
init|=
literal|0
decl_stmt|;
name|relaxable
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|extension
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|op_idx
operator|=
literal|1
operator|,
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
operator|,
name|op_idx
operator|++
control|)
block|{
specifier|const
name|struct
name|mn10200_operand
modifier|*
name|operand
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
if|if
condition|(
name|next_opindex
operator|==
literal|0
condition|)
block|{
name|operand
operator|=
operator|&
name|mn10200_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
block|}
else|else
block|{
name|operand
operator|=
operator|&
name|mn10200_operands
index|[
name|next_opindex
index|]
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
block|}
name|errmsg
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_RELAX
condition|)
name|relaxable
operator|=
literal|1
expr_stmt|;
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_PAREN
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
comment|/* See if we can match the operands.  */
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_DREG
condition|)
block|{
if|if
condition|(
operator|!
name|data_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_AREG
condition|)
block|{
if|if
condition|(
operator|!
name|address_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_PSW
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"psw"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_MDR
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"mdr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
elseif|else
if|if
condition|(
name|data_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|address_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|other_register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|')'
operator|||
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ex
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_absent
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_register
case|:
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|MN10200_OPERAND_DREG
operator||
name|MN10200_OPERAND_AREG
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_2
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_5
condition|)
name|extra_shift
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_3
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_6
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_7
condition|)
name|extra_shift
operator|=
literal|16
expr_stmt|;
else|else
name|extra_shift
operator|=
literal|0
expr_stmt|;
name|mn10200_insert_operand
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|extension
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|extra_shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
comment|/* If this operand can be promoted, and it doesn't 		 fit into the allocated bitfield for this insn, 		 then promote it (ie this opcode does not match).  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|MN10200_OPERAND_PROMOTE
operator||
name|MN10200_OPERAND_RELAX
operator|)
operator|&&
operator|!
name|check_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mn10200_insert_operand
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|extension
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If this operand can be promoted, then this opcode didn't 		 match since we can't know if it needed promotion!  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_PROMOTE
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|str
operator|=
name|hold
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
break|break;
block|}
name|keep_going
label|:
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
condition|)
operator|++
name|str
expr_stmt|;
block|}
comment|/* Make sure we used all the operands!  */
if|if
condition|(
operator|*
name|str
operator|!=
literal|','
condition|)
name|match
operator|=
literal|1
expr_stmt|;
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|next_opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|next_opcode
expr_stmt|;
continue|continue;
block|}
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_1
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_2
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_4
condition|)
name|size
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_3
operator|||
name|opcode
operator|->
name|format
operator|==
name|FMT_5
condition|)
name|size
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_6
condition|)
name|size
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_7
condition|)
name|size
operator|=
literal|5
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Write out the instruction.  */
if|if
condition|(
name|relaxable
operator|&&
name|fc
operator|>
literal|0
condition|)
block|{
comment|/* On a 64-bit host the size of an 'int' is not the same 	 as the size of a pointer, so we need a union to convert 	 the opindex field of the fr_cgen structure into a char * 	 so that it can be stored in the frag.  We do not have 	 to worry about loosing accuracy as we are not going to 	 be even close to the 32bit limit of the int.  */
union|union
block|{
name|int
name|opindex
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
name|opindex_converter
union|;
name|int
name|type
decl_stmt|;
comment|/* bCC  */
if|if
condition|(
name|size
operator|==
literal|2
operator|&&
name|opcode
operator|->
name|opcode
operator|!=
literal|0xfc0000
condition|)
block|{
comment|/* Handle bra specially.  Basically treat it like jmp so 	     that we automatically handle 8, 16 and 32 bit offsets 	     correctly as well as jumps to an undefined address.  	     It is also important to not treat it like other bCC 	     instructions since the long forms of bra is different 	     from other bCC instructions.  */
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|==
literal|0xea00
condition|)
name|type
operator|=
literal|8
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
block|}
comment|/* jsr  */
elseif|else
if|if
condition|(
name|size
operator|==
literal|3
operator|&&
name|opcode
operator|->
name|opcode
operator|==
literal|0xfd0000
condition|)
name|type
operator|=
literal|6
expr_stmt|;
comment|/* jmp  */
elseif|else
if|if
condition|(
name|size
operator|==
literal|3
operator|&&
name|opcode
operator|->
name|opcode
operator|==
literal|0xfc0000
condition|)
name|type
operator|=
literal|8
expr_stmt|;
comment|/* bCCx  */
else|else
name|type
operator|=
literal|3
expr_stmt|;
name|opindex_converter
operator|.
name|opindex
operator|=
name|fixups
index|[
literal|0
index|]
operator|.
name|opindex
expr_stmt|;
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|8
operator|-
name|size
argument_list|,
name|type
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|opindex_converter
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
literal|8
operator|-
name|size
operator|>
literal|4
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
name|size
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
name|size
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|8
operator|-
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
name|size
argument_list|,
literal|0
argument_list|,
literal|8
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Oh, what a mess.  The instruction is in big endian format, but 	 16 and 24bit immediates are little endian!  */
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_3
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_6
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|==
name|FMT_7
condition|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|extension
operator|&
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|size
operator|>
literal|4
condition|?
literal|4
else|:
name|size
argument_list|)
expr_stmt|;
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|mn10200_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|mn10200_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|4
operator|-
name|size
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
comment|/* PC-relative offsets are from the first byte of the 		 next instruction, not from the start of the current 		 instruction.  */
if|if
condition|(
name|reloc_howto
operator|->
name|pc_relative
condition|)
name|fixP
operator|->
name|fx_offset
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|int
name|reloc
decl_stmt|,
name|pcrel
decl_stmt|,
name|reloc_size
decl_stmt|,
name|offset
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* How big is the reloc?  Remember SPLIT relocs are 		 implicitly 32bits.  */
name|reloc_size
operator|=
name|operand
operator|->
name|bits
expr_stmt|;
name|offset
operator|=
name|size
operator|-
name|reloc_size
operator|/
literal|8
expr_stmt|;
comment|/* Is the reloc pc-relative?  */
name|pcrel
operator|=
operator|(
name|operand
operator|->
name|flags
operator|&
name|MN10200_OPERAND_PCREL
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Choose a proper BFD relocation type.  */
if|if
condition|(
name|pcrel
condition|)
block|{
if|if
condition|(
name|reloc_size
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|24
condition|)
name|reloc
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reloc_size
operator|==
literal|32
condition|)
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|16
condition|)
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|24
condition|)
name|reloc
operator|=
name|BFD_RELOC_24
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Convert the size of the reloc into what fix_new_exp                  wants.  */
name|reloc_size
operator|=
name|reloc_size
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|==
literal|8
condition|)
name|reloc_size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|16
condition|)
name|reloc_size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|reloc_size
operator|==
literal|32
operator|||
name|reloc_size
operator|==
literal|24
condition|)
name|reloc_size
operator|=
literal|2
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|reloc_size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|pcrel
argument_list|,
operator|(
operator|(
name|bfd_reloc_code_real_type
operator|)
name|reloc
operator|)
argument_list|)
expr_stmt|;
comment|/* PC-relative offsets are from the first byte of the 		 next instruction, not from the start of the current 		 instruction.  */
if|if
condition|(
name|pcrel
condition|)
name|fixP
operator|->
name|fx_offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

