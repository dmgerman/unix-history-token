begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* m88k.c -- Assembler for the Motorola 88000    Contributed by Devon Bowen of Buffalo University    and Torbjorn Granlund of the Swedish Institute of Computer Science.    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"m88k-opcode.h"
end_include

begin_struct
struct|struct
name|field_val_assoc
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|field_val_assoc
name|cr_regs
index|[]
init|=
block|{
block|{
literal|"PID"
block|,
literal|0
block|}
block|,
block|{
literal|"PSR"
block|,
literal|1
block|}
block|,
block|{
literal|"EPSR"
block|,
literal|2
block|}
block|,
block|{
literal|"SSBR"
block|,
literal|3
block|}
block|,
block|{
literal|"SXIP"
block|,
literal|4
block|}
block|,
block|{
literal|"SNIP"
block|,
literal|5
block|}
block|,
block|{
literal|"SFIP"
block|,
literal|6
block|}
block|,
block|{
literal|"VBR"
block|,
literal|7
block|}
block|,
block|{
literal|"DMT0"
block|,
literal|8
block|}
block|,
block|{
literal|"DMD0"
block|,
literal|9
block|}
block|,
block|{
literal|"DMA0"
block|,
literal|10
block|}
block|,
block|{
literal|"DMT1"
block|,
literal|11
block|}
block|,
block|{
literal|"DMD1"
block|,
literal|12
block|}
block|,
block|{
literal|"DMA1"
block|,
literal|13
block|}
block|,
block|{
literal|"DMT2"
block|,
literal|14
block|}
block|,
block|{
literal|"DMD2"
block|,
literal|15
block|}
block|,
block|{
literal|"DMA2"
block|,
literal|16
block|}
block|,
block|{
literal|"SR0"
block|,
literal|17
block|}
block|,
block|{
literal|"SR1"
block|,
literal|18
block|}
block|,
block|{
literal|"SR2"
block|,
literal|19
block|}
block|,
block|{
literal|"SR3"
block|,
literal|20
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|field_val_assoc
name|fcr_regs
index|[]
init|=
block|{
block|{
literal|"FPECR"
block|,
literal|0
block|}
block|,
block|{
literal|"FPHS1"
block|,
literal|1
block|}
block|,
block|{
literal|"FPLS1"
block|,
literal|2
block|}
block|,
block|{
literal|"FPHS2"
block|,
literal|3
block|}
block|,
block|{
literal|"FPLS2"
block|,
literal|4
block|}
block|,
block|{
literal|"FPPT"
block|,
literal|5
block|}
block|,
block|{
literal|"FPRH"
block|,
literal|6
block|}
block|,
block|{
literal|"FPRL"
block|,
literal|7
block|}
block|,
block|{
literal|"FPIT"
block|,
literal|8
block|}
block|,
block|{
literal|"FPSR"
block|,
literal|62
block|}
block|,
block|{
literal|"FPCR"
block|,
literal|63
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|field_val_assoc
name|cmpslot
index|[]
init|=
block|{
comment|/* Integer	Floating point */
block|{
literal|"nc"
block|,
literal|0
block|}
block|,
block|{
literal|"cp"
block|,
literal|1
block|}
block|,
block|{
literal|"eq"
block|,
literal|2
block|}
block|,
block|{
literal|"ne"
block|,
literal|3
block|}
block|,
block|{
literal|"gt"
block|,
literal|4
block|}
block|,
block|{
literal|"le"
block|,
literal|5
block|}
block|,
block|{
literal|"lt"
block|,
literal|6
block|}
block|,
block|{
literal|"ge"
block|,
literal|7
block|}
block|,
block|{
literal|"hi"
block|,
literal|8
block|}
block|,
block|{
literal|"ou"
block|,
literal|8
block|}
block|,
block|{
literal|"ls"
block|,
literal|9
block|}
block|,
block|{
literal|"ib"
block|,
literal|9
block|}
block|,
block|{
literal|"lo"
block|,
literal|10
block|}
block|,
block|{
literal|"in"
block|,
literal|10
block|}
block|,
block|{
literal|"hs"
block|,
literal|11
block|}
block|,
block|{
literal|"ob"
block|,
literal|11
block|}
block|,
block|{
literal|"be"
block|,
literal|12
block|}
block|,
block|{
literal|"ue"
block|,
literal|12
block|}
block|,
block|{
literal|"nb"
block|,
literal|13
block|}
block|,
block|{
literal|"lg"
block|,
literal|13
block|}
block|,
block|{
literal|"he"
block|,
literal|14
block|}
block|,
block|{
literal|"ug"
block|,
literal|14
block|}
block|,
block|{
literal|"nh"
block|,
literal|15
block|}
block|,
block|{
literal|"ule"
block|,
literal|15
block|}
block|,
block|{
literal|"ul"
block|,
literal|16
block|}
block|,
block|{
literal|"uge"
block|,
literal|17
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|field_val_assoc
name|cndmsk
index|[]
init|=
block|{
block|{
literal|"gt0"
block|,
literal|1
block|}
block|,
block|{
literal|"eq0"
block|,
literal|2
block|}
block|,
block|{
literal|"ge0"
block|,
literal|3
block|}
block|,
block|{
literal|"lt0"
block|,
literal|12
block|}
block|,
block|{
literal|"ne0"
block|,
literal|13
block|}
block|,
block|{
literal|"le0"
block|,
literal|14
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|m88k_insn
block|{
name|unsigned
name|long
name|opcode
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|enum
name|reloc_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_bf
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_cmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_cnd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_bf2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|int
name|bc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_bf_offset_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|offsetp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_cr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|regnop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_fcr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|regnop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_imm16
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
expr|struct
name|m88k_insn
operator|*
name|insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_o6
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|match_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|field_val_assoc
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|regnop
operator|,
name|unsigned
name|int
name|reg_prefix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_vec9
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getval
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
name|unsigned
name|int
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_pcr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|param
operator|,
expr|struct
name|m88k_insn
operator|*
name|insn
operator|,
expr|enum
name|reloc_type
name|reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calcop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|m88k_opcode
operator|*
name|format
operator|,
name|char
operator|*
name|param
operator|,
expr|struct
name|m88k_insn
operator|*
name|insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These bits should be turned off in the first address of every segment */
end_comment

begin_decl_stmt
name|int
name|md_seg_align
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* as in 0f123.456 */
end_comment

begin_comment
comment|/* or    0H1.234E-12 (see exp chars above) */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dDfF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|4
block|}
block|,
block|{
literal|"def"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"bss"
block|,
name|s_lcomm
block|,
literal|1
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
comment|/* Force set to be treated as an instruction.  */
block|{
literal|"set"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|".set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Initialize hash table.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|m88k_opcodes
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|m88k_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
comment|/* Hash each mnemonic and record its position.  */
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|&
name|m88k_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't hash instruction '%s':%s"
argument_list|)
argument_list|,
name|m88k_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* Skip to next unique mnemonic or end of list.  */
for|for
control|(
name|i
operator|++
init|;
operator|!
name|strcmp
argument_list|(
name|m88k_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_function
name|void
name|md_assemble
parameter_list|(
name|op
parameter_list|)
name|char
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|param
decl_stmt|,
modifier|*
name|thisfrag
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|m88k_opcode
modifier|*
name|format
decl_stmt|;
name|struct
name|m88k_insn
name|insn
decl_stmt|;
name|assert
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Skip over instruction to find parameters.  */
for|for
control|(
name|param
operator|=
name|op
init|;
operator|*
name|param
operator|!=
literal|0
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|param
argument_list|)
condition|;
name|param
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|param
expr_stmt|;
operator|*
name|param
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try to find the instruction in the hash table.  */
if|if
condition|(
operator|(
name|format
operator|=
operator|(
expr|struct
name|m88k_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|op
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid mnemonic '%s'"
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try parsing this instruction into insn.  */
name|insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
operator|.
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|insn
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
while|while
condition|(
operator|!
name|calcop
argument_list|(
name|format
argument_list|,
name|param
argument_list|,
operator|&
name|insn
argument_list|)
condition|)
block|{
comment|/* If it doesn't parse try the next instruction.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|format
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|format
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
name|format
operator|++
expr_stmt|;
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Parameter syntax error"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Grow the current frag and plop in the opcode.  */
name|thisfrag
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|thisfrag
argument_list|,
name|insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If this instruction requires labels mark it for later.  */
switch|switch
condition|(
name|insn
operator|.
name|reloc
condition|)
block|{
case|case
name|NO_RELOC
case|:
break|break;
case|case
name|RELOC_LO16
case|:
case|case
name|RELOC_HI16
case|:
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|thisfrag
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_IW16
case|:
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|thisfrag
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|insn
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_PC16
case|:
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|thisfrag
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|exp
argument_list|,
literal|1
argument_list|,
name|insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_PC26
case|:
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|thisfrag
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|insn
operator|.
name|exp
argument_list|,
literal|1
argument_list|,
name|insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown relocation type"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|calcop
parameter_list|(
name|format
parameter_list|,
name|param
parameter_list|,
name|insn
parameter_list|)
name|struct
name|m88k_opcode
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|param
decl_stmt|;
name|struct
name|m88k_insn
modifier|*
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
init|=
name|format
operator|->
name|op_spec
decl_stmt|;
name|int
name|f
decl_stmt|;
name|unsigned
name|val
decl_stmt|;
name|unsigned
name|opcode
decl_stmt|;
name|unsigned
name|int
name|reg_prefix
init|=
literal|'r'
decl_stmt|;
name|insn
operator|->
name|opcode
operator|=
name|format
operator|->
name|opcode
expr_stmt|;
name|opcode
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|param
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|f
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|0
case|:
name|insn
operator|->
name|opcode
operator||=
name|opcode
expr_stmt|;
return|return
operator|(
operator|*
name|param
operator|==
literal|0
operator|||
operator|*
name|param
operator|==
literal|'\n'
operator|)
return|;
default|default:
if|if
condition|(
name|f
operator|!=
operator|*
name|param
operator|++
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'d'
case|:
name|param
operator|=
name|get_reg
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|,
name|reg_prefix
argument_list|)
expr_stmt|;
name|reg_prefix
operator|=
literal|'r'
expr_stmt|;
name|opcode
operator||=
name|val
operator|<<
literal|21
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|param
operator|=
name|get_o6
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
operator|(
operator|(
name|val
operator|>>
literal|2
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|reg_prefix
operator|=
literal|'x'
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|param
operator|=
name|get_reg
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|,
name|reg_prefix
argument_list|)
expr_stmt|;
name|reg_prefix
operator|=
literal|'r'
expr_stmt|;
name|opcode
operator||=
name|val
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|param
operator|=
name|get_reg
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|,
name|reg_prefix
argument_list|)
expr_stmt|;
name|reg_prefix
operator|=
literal|'r'
expr_stmt|;
name|opcode
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|param
operator|=
name|get_reg
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|val
operator|<<
literal|16
operator|)
operator||
name|val
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|param
operator|=
name|get_imm16
argument_list|(
name|param
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|param
operator|=
name|get_bf
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|param
operator|=
name|get_pcr
argument_list|(
name|param
argument_list|,
name|insn
argument_list|,
name|RELOC_PC16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|param
operator|=
name|get_pcr
argument_list|(
name|param
argument_list|,
name|insn
argument_list|,
name|RELOC_PC26
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|param
operator|=
name|get_cmp
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|param
operator|=
name|get_cnd
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|param
operator|=
name|get_cr
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
operator|<<
literal|5
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|param
operator|=
name|get_fcr
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
operator|<<
literal|5
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|param
operator|=
name|get_vec9
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|opcode
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Having this here repeats the warning somtimes. 	   But can't we stand that?  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Use of obsolete instruction"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|match_name
parameter_list|(
name|param
parameter_list|,
name|assoc_tab
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|struct
name|field_val_assoc
modifier|*
name|assoc_tab
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|name_len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|assoc_tab
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
condition|)
block|{
operator|*
name|valp
operator|=
name|assoc_tab
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
return|return
name|param
operator|+
name|name_len
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_reg
parameter_list|(
name|param
parameter_list|,
name|regnop
parameter_list|,
name|reg_prefix
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|regnop
decl_stmt|;
name|unsigned
name|int
name|reg_prefix
decl_stmt|;
block|{
name|unsigned
name|c
decl_stmt|;
name|unsigned
name|regno
decl_stmt|;
name|c
operator|=
operator|*
name|param
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|reg_prefix
condition|)
block|{
name|regno
operator|=
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
block|{
operator|*
name|regnop
operator|=
literal|0
expr_stmt|;
return|return
name|param
return|;
block|}
name|c
operator|=
operator|*
name|param
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|10
condition|)
block|{
name|regno
operator|=
name|regno
operator|*
literal|10
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
operator|+
literal|1
return|;
block|}
block|}
else|else
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|param
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
block|{
operator|*
name|regnop
operator|=
literal|31
expr_stmt|;
return|return
name|param
operator|+
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_imm16
parameter_list|(
name|param
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|struct
name|m88k_insn
modifier|*
name|insn
decl_stmt|;
block|{
name|enum
name|reloc_type
name|reloc
init|=
name|NO_RELOC
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
literal|"hi16"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
name|param
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|RELOC_HI16
expr_stmt|;
name|param
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
literal|"lo16"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
name|param
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|RELOC_LO16
expr_stmt|;
name|param
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
literal|"iw16"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
name|param
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|RELOC_IW16
expr_stmt|;
name|param
operator|+=
literal|4
expr_stmt|;
block|}
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|expression
argument_list|(
operator|&
name|insn
operator|->
name|exp
argument_list|)
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
name|val
operator|=
name|insn
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Insert the value now, and reset reloc to NO_RELOC.  */
if|if
condition|(
name|reloc
operator|==
name|NO_RELOC
condition|)
block|{
comment|/* Warn about too big expressions if not surrounded by xx16.  */
if|if
condition|(
name|val
operator|>
literal|0xffff
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expression truncated to 16 bits"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reloc
operator|==
name|RELOC_HI16
condition|)
name|val
operator|>>=
literal|16
expr_stmt|;
name|insn
operator|->
name|opcode
operator||=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc
operator|==
name|NO_RELOC
condition|)
comment|/* We accept a symbol even without lo16, hi16, etc, and assume        lo16 was intended.  */
name|reloc
operator|=
name|RELOC_LO16
expr_stmt|;
name|insn
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_pcr
parameter_list|(
name|param
parameter_list|,
name|insn
parameter_list|,
name|reloc
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|struct
name|m88k_insn
modifier|*
name|insn
decl_stmt|;
name|enum
name|reloc_type
name|reloc
decl_stmt|;
block|{
name|char
modifier|*
name|saveptr
decl_stmt|,
modifier|*
name|saveparam
decl_stmt|;
name|saveptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|expression
argument_list|(
operator|&
name|insn
operator|->
name|exp
argument_list|)
expr_stmt|;
name|saveparam
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|saveptr
expr_stmt|;
comment|/* Botch: We should relocate now if O_constant.  */
name|insn
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
return|return
name|saveparam
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_cmp
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|save_ptr
operator|=
name|param
expr_stmt|;
name|param
operator|=
name|match_name
argument_list|(
name|param
argument_list|,
name|cmpslot
argument_list|,
name|valp
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|valp
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|NULL
condition|)
block|{
name|param
operator|=
name|save_ptr
expr_stmt|;
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|32
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expression truncated to 5 bits"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|%=
literal|32
expr_stmt|;
block|}
block|}
operator|*
name|valp
operator|=
name|val
operator|<<
literal|21
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_cnd
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|param
argument_list|)
condition|)
block|{
name|param
operator|=
name|getval
argument_list|(
name|param
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|32
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expression truncated to 5 bits"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|%=
literal|32
expr_stmt|;
block|}
block|}
else|else
block|{
name|param
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|TOLOWER
argument_list|(
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|param
operator|=
name|match_name
argument_list|(
name|param
argument_list|,
name|cndmsk
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|val
operator|=
operator|*
name|valp
expr_stmt|;
block|}
operator|*
name|valp
operator|=
name|val
operator|<<
literal|21
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_bf2
parameter_list|(
name|param
parameter_list|,
name|bc
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|int
name|bc
decl_stmt|;
block|{
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|param
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|param
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|depth
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|bc
operator|&&
name|depth
operator|<=
literal|0
condition|)
return|return
name|param
return|;
name|param
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_bf_offset_expression
parameter_list|(
name|param
parameter_list|,
name|offsetp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|offsetp
decl_stmt|;
block|{
name|unsigned
name|offset
decl_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
name|param
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|param
index|[
literal|0
index|]
operator|=
name|TOLOWER
argument_list|(
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|param
index|[
literal|1
index|]
operator|=
name|TOLOWER
argument_list|(
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|param
operator|=
name|match_name
argument_list|(
name|param
argument_list|,
name|cmpslot
argument_list|,
name|offsetp
argument_list|)
expr_stmt|;
return|return
name|param
return|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
block|}
operator|*
name|offsetp
operator|=
name|offset
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_bf
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|xp
operator|=
name|get_bf2
argument_list|(
name|param
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
if|if
condition|(
operator|*
name|xp
operator|==
literal|0
condition|)
block|{
comment|/* We did not find '<'.  We have an offset (width implicitly 32).  */
name|param
operator|=
name|get_bf_offset_expression
argument_list|(
name|param
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
operator|*
name|xp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Overwrite the '<' */
name|param
operator|=
name|get_bf2
argument_list|(
name|xp
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|param
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|param
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Overwrite the '>' */
name|width
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|xp
operator|=
name|get_bf_offset_expression
argument_list|(
name|xp
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|xp
operator|+
literal|1
operator|!=
name|param
condition|)
return|return
name|NULL
return|;
block|}
operator|*
name|valp
operator|=
operator|(
operator|(
name|width
operator|%
literal|32
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|offset
operator|%
literal|32
operator|)
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_cr
parameter_list|(
name|param
parameter_list|,
name|regnop
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|regnop
decl_stmt|;
block|{
name|unsigned
name|regno
decl_stmt|;
name|unsigned
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
literal|"cr"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|param
operator|+=
literal|2
expr_stmt|;
name|regno
operator|=
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
block|{
operator|*
name|regnop
operator|=
literal|0
expr_stmt|;
return|return
name|param
return|;
block|}
name|c
operator|=
operator|*
name|param
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|10
condition|)
block|{
name|regno
operator|=
name|regno
operator|*
literal|10
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|64
condition|)
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
operator|+
literal|1
return|;
block|}
block|}
else|else
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
name|param
operator|=
name|match_name
argument_list|(
name|param
argument_list|,
name|cr_regs
argument_list|,
name|regnop
argument_list|)
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_fcr
parameter_list|(
name|param
parameter_list|,
name|regnop
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|regnop
decl_stmt|;
block|{
name|unsigned
name|regno
decl_stmt|;
name|unsigned
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|param
argument_list|,
literal|"fcr"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|param
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
block|{
operator|*
name|regnop
operator|=
literal|0
expr_stmt|;
return|return
name|param
return|;
block|}
name|c
operator|=
operator|*
name|param
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|10
condition|)
block|{
name|regno
operator|=
name|regno
operator|*
literal|10
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|64
condition|)
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
operator|+
literal|1
return|;
block|}
block|}
else|else
block|{
operator|*
name|regnop
operator|=
name|regno
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
name|param
operator|=
name|match_name
argument_list|(
name|param
argument_list|,
name|fcr_regs
argument_list|,
name|regnop
argument_list|)
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_vec9
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|val
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|1
operator|<<
literal|9
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expression truncated to 9 bits"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|val
operator|%
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
return|return
name|param
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_o6
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|val
decl_stmt|;
name|char
modifier|*
name|save_ptr
decl_stmt|;
name|save_ptr
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|param
expr_stmt|;
name|val
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|param
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_ptr
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x3
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Removed lower 2 bits of expression"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|param
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|hexval
parameter_list|(
name|z
parameter_list|)
define|\
value|(ISDIGIT (z) ? (z) - '0' :						\    ISLOWER (z) ? (z) - 'a' + 10 : 					\    ISUPPER (z) ? (z) - 'A' + 10 : (unsigned) -1)
end_define

begin_function
specifier|static
name|char
modifier|*
name|getval
parameter_list|(
name|param
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
name|unsigned
name|int
modifier|*
name|valp
decl_stmt|;
block|{
name|unsigned
name|int
name|val
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|param
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|c
operator|=
operator|*
name|param
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
name|c
operator|=
operator|*
name|param
operator|++
expr_stmt|;
name|c
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|<
literal|16
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|16
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|param
operator|++
expr_stmt|;
name|c
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
while|while
condition|(
name|c
operator|<
literal|8
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|8
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
while|while
condition|(
name|c
operator|<
literal|10
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|10
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|param
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
operator|*
name|valp
operator|=
name|val
expr_stmt|;
return|return
name|param
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xc0
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|RELOC_PC26
argument_list|)
expr_stmt|;
comment|/* Botch: Shouldn't this be RELOC_PC16? */
block|}
end_function

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|addressT
name|to_addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xc0
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|RELOC_PC26
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Relaxation should never occur"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|M88KCOFF
end_ifdef

begin_comment
comment|/* These functions are needed if we are linking with obj-coffbfd.c.    That file may be replaced by a more BFD oriented version at some    point.  If that happens, these functions should be reexamined.     Ian Lance Taylor, Cygnus Support, 13 July 1993.  */
end_comment

begin_comment
comment|/* Given a fixS structure (created by a call to fix_new, above),    return the BFD relocation type to use for it.  */
end_comment

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_LO16
case|:
return|return
name|R_LVRT16
return|;
case|case
name|RELOC_HI16
case|:
return|return
name|R_HVRT16
return|;
case|case
name|RELOC_PC16
case|:
return|return
name|R_PCR16L
return|;
case|case
name|RELOC_PC26
case|:
return|return
name|R_PCR26L
return|;
case|case
name|RELOC_32
case|:
return|return
name|R_VRT32
return|;
case|case
name|RELOC_IW16
case|:
return|return
name|R_VRT16
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply a fixS to the object file.  Since COFF does not use addends    in relocs, the addend is actually stored directly in the object    file itself.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_IW16
case|:
name|fixP
operator|->
name|fx_offset
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_LO16
case|:
name|fixP
operator|->
name|fx_offset
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_HI16
case|:
name|fixP
operator|->
name|fx_offset
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_PC16
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|RELOC_PC26
case|:
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x03
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|RELOC_32
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Where a PC relative offset is calculated from.  On the m88k they    are calculated from just after the instruction.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_PC16
case|:
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
operator|-
literal|2
return|;
case|case
name|RELOC_PC26
case|:
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Fill in rs_align_code fragments.  */
end_comment

begin_function
name|void
name|m88k_handle_align
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|nop_pattern
index|[]
init|=
block|{
literal|0xf4
block|,
literal|0x00
block|,
literal|0x58
block|,
literal|0x00
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|3
condition|)
block|{
name|int
name|fix
init|=
name|bytes
operator|&
literal|3
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|nop_pattern
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* M88KCOFF */
end_comment

end_unit

