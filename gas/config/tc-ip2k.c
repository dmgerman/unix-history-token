begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-ip2k.c -- Assembler for the Scenix IP2xxx.    Copyright (C) 2000, 2002, 2003, 2005, 2006 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/ip2k-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/ip2k-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/ip2k.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components describing    an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|ip2k_insn
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to detect when switching to code section where insn alignment is    implied.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_code_align
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mach selected from command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ip2k_mach
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|ip2k_mach_bitmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ip2k_elf_section_rtn
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|obj_elf_section
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_code_align
condition|)
block|{
comment|/* The s_align_ptwo function expects that we are just after a .align 	 directive and it will either try and read the align value or stop 	 if end of line so we must fake it out so it thinks we are at the 	 end of the line.  */
name|char
modifier|*
name|old_input_line_pointer
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
literal|"\n"
expr_stmt|;
name|s_align_ptwo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|force_code_align
operator|=
literal|0
expr_stmt|;
comment|/* Restore.  */
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ip2k_elf_section_text
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|char
modifier|*
name|old_input_line_pointer
decl_stmt|;
name|obj_elf_text
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* the s_align_ptwo function expects that we are just after a .align      directive and it will either try and read the align value or stop if      end of line so we must fake it out so it thinks we are at the end of      the line.  */
name|old_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
literal|"\n"
expr_stmt|;
name|s_align_ptwo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|force_code_align
operator|=
literal|0
expr_stmt|;
comment|/* Restore.  */
name|input_line_pointer
operator|=
name|old_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"text"
block|,
name|ip2k_elf_section_text
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|ip2k_elf_section_rtn
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_enum
enum|enum
name|options
block|{
name|OPTION_CPU_IP2022
init|=
name|OPTION_MD_BASE
block|,
name|OPTION_CPU_IP2022EXT
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"mip2022"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CPU_IP2022
block|}
block|,
block|{
literal|"mip2022ext"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CPU_IP2022EXT
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CPU_IP2022
case|:
name|ip2k_mach
operator|=
name|bfd_mach_ip2022
expr_stmt|;
name|ip2k_mach_bitmask
operator|=
literal|1
operator|<<
name|MACH_IP2022
expr_stmt|;
break|break;
case|case
name|OPTION_CPU_IP2022EXT
case|:
name|ip2k_mach
operator|=
name|bfd_mach_ip2022ext
expr_stmt|;
name|ip2k_mach_bitmask
operator|=
literal|1
operator|<<
name|MACH_IP2022EXT
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"IP2K specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mip2022               restrict to IP2022 insns \n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mip2022ext            permit extended IP2022 insn\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|ip2k_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
name|ip2k_mach_bitmask
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|ip2k_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
comment|/* Set the machine type.  */
name|bfd_default_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_ip2k
argument_list|,
name|ip2k_mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|ip2k_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|ip2k_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for special relocation required by SKIP instructions.  */
if|if
condition|(
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_SKIPA
argument_list|)
condition|)
comment|/* Unconditional skip has a 1-bit relocation of the current pc, so        that we emit either sb pcl.0 or snb pcl.0 depending on whether        the PCL (pc + 2)>> 1 is odd or even.  */
block|{
name|enum
name|cgen_parse_operand_result
name|result_type
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|curpc_plus_2
init|=
literal|".+2"
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|cgen_parse_address
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
operator|&
name|curpc_plus_2
argument_list|,
name|IP2K_OPERAND_ADDR16CJP
argument_list|,
name|BFD_RELOC_IP2K_PC_SKIP
argument_list|,
operator|&
name|result_type
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_pcrel_from\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the address of the delay slot. */
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|result
decl_stmt|;
name|result
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|type
condition|)
block|{
case|case
name|IP2K_OPERAND_FR
case|:
case|case
name|IP2K_OPERAND_ADDR16L
case|:
case|case
name|IP2K_OPERAND_ADDR16H
case|:
case|case
name|IP2K_OPERAND_LIT8
case|:
comment|/* These may have been processed at parse time.  */
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
literal|0
condition|)
name|result
operator|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IP2K_OPERAND_ADDR16CJP
case|:
name|result
operator|=
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
operator|||
name|result
operator|==
name|BFD_RELOC_NONE
condition|)
name|result
operator|=
name|BFD_RELOC_IP2K_ADDR16CJP
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IP2K_OPERAND_ADDR16P
case|:
name|result
operator|=
name|BFD_RELOC_IP2K_PAGE3
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on    OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* This loops outputs the LITTLENUMs in REVERSE order; in accord with      the ip2k endianness.  */
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    Force most of them, since the linker's bfd relocation engine    understands range limits better than gas' cgen fixup engine.    Consider the case of a fixup intermediate value being larger than    the instruction it will be eventually encoded within.  */
end_comment

begin_function
name|int
name|ip2k_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_IP2K_FR9
case|:
case|case
name|BFD_RELOC_IP2K_FR_OFFSET
case|:
case|case
name|BFD_RELOC_IP2K_BANK
case|:
case|case
name|BFD_RELOC_IP2K_ADDR16CJP
case|:
case|case
name|BFD_RELOC_IP2K_PAGE3
case|:
case|case
name|BFD_RELOC_IP2K_LO8DATA
case|:
case|case
name|BFD_RELOC_IP2K_HI8DATA
case|:
case|case
name|BFD_RELOC_IP2K_EX8DATA
case|:
case|case
name|BFD_RELOC_IP2K_LO8INSN
case|:
case|case
name|BFD_RELOC_IP2K_HI8INSN
case|:
case|case
name|BFD_RELOC_IP2K_PC_SKIP
case|:
case|case
name|BFD_RELOC_IP2K_TEXT
case|:
return|return
literal|1
return|;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fix
operator|->
name|fx_subsy
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fix
operator|->
name|fx_subsy
argument_list|)
operator|&&
name|fix
operator|->
name|fx_addsy
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
condition|)
block|{
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_IP2K_TEXT
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fix
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ip2k_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valueP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_IP2K_TEXT
operator|&&
operator|!
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|fixP
operator|->
name|fx_subsy
condition|)
block|{
operator|*
name|valueP
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|valueP
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_UNUSED
operator|+
name|IP2K_OPERAND_FR
condition|)
block|{
comment|/* Must be careful when we are fixing up an FR.  We could be 	 fixing up an offset to (SP) or (DP) in which case we don't 	 want to step on the top 2 bits of the FR operand.  The 	 gas_cgen_md_apply_fix doesn't know any better and overwrites 	 the entire operand.  We counter this by adding the bits 	 to the new value.  */
name|char
modifier|*
name|where
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
comment|/* Canonical name, since used a lot.  */
name|CGEN_CPU_DESC
name|cd
init|=
name|gas_cgen_cpu_desc
decl_stmt|;
name|CGEN_INSN_INT
name|insn_value
init|=
name|cgen_get_insn_value
argument_list|(
name|cd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Preserve (DP) or (SP) specification.  */
operator|*
name|valueP
operator|+=
operator|(
name|insn_value
operator|&
literal|0x180
operator|)
expr_stmt|;
block|}
name|gas_cgen_md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|valueP
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ip2k_elf_section_flags
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|attr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* This is used to detect when the section changes to an executable section.      This function is called by the elf section processing.  When we note an      executable section specifier we set an internal flag to denote when      word alignment should be forced.  */
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
name|force_code_align
operator|=
literal|1
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

end_unit

