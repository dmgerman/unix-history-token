begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-a29k.c -- Assemble for the AMD 29000.    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* John Gilmore has reorganized this module somewhat, to make it easier    to convert it to new machines' assemblers as desired.  There was too    much bloody rewriting required before.  There still probably is.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/a29k.h"
end_include

begin_comment
comment|/* Make it easier to clone this machine desc into another one.  */
end_comment

begin_define
define|#
directive|define
name|machine_opcode
value|a29k_opcode
end_define

begin_define
define|#
directive|define
name|machine_opcodes
value|a29k_opcodes
end_define

begin_define
define|#
directive|define
name|machine_ip
value|a29k_ip
end_define

begin_define
define|#
directive|define
name|machine_it
value|a29k_it
end_define

begin_define
define|#
directive|define
name|IMMEDIATE_BIT
value|0x01000000
end_define

begin_comment
comment|/* Turns RB into Immediate */
end_comment

begin_define
define|#
directive|define
name|ABSOLUTE_BIT
value|0x01000000
end_define

begin_comment
comment|/* Turns PC-relative to Absolute */
end_comment

begin_define
define|#
directive|define
name|CE_BIT
value|0x00800000
end_define

begin_comment
comment|/* Coprocessor enable in LOAD */
end_comment

begin_define
define|#
directive|define
name|UI_BIT
value|0x00000080
end_define

begin_comment
comment|/* Unsigned integer in CONVERT */
end_comment

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|machine_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlistp
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|reloc_offset
decl_stmt|;
comment|/* Offset of reloc within insn */
name|int
name|reloc
decl_stmt|;
block|}
name|the_insn
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|machine_ip
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static void print_insn PARAMS ((struct machine_it *insn)); */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_COFF
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|s_data1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_use
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|insert_sreg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_some_regs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|4
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"cputype"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* CPU as 29000 or 29050 */
block|{
literal|"reg"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
comment|/* Register equate, same as equ */
block|{
literal|"space"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Listing control */
block|{
literal|"sect"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Creation of coff sections */
ifndef|#
directive|ifndef
name|OBJ_COFF
comment|/* We can do this right with coff.  */
block|{
literal|"use"
block|,
name|s_use
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_HEADERS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|RELSZ
end_ifdef

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
name|RELSZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coff headers */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* something else headers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not bfdized*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We needed an unused char for line separation to work around the    lack of macros, using sed and such.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c.  Ideally it shouldn't have to know about it at    all, but nothing is ideal around here.  */
end_comment

begin_comment
comment|/*  *  anull bit - causes the branch delay slot instructions to not be executed  */
end_comment

begin_define
define|#
directive|define
name|ANNUL
value|(1<< 29)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_COFF
end_ifndef

begin_function
specifier|static
name|void
name|s_use
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".data"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".data1"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_data1
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Literals can't go in the text segment because you can't read from      instruction memory on some 29k's.  So, into initialized data.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".lit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
name|subseg_set
argument_list|(
name|SEG_DATA
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown segment type"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_data1
parameter_list|()
block|{
name|subseg_set
argument_list|(
name|SEG_DATA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/* Install symbol definition that maps REGNAME to REGNO.    FIXME-SOON:  These are not recognized in mixed case.  */
end_comment

begin_function
specifier|static
name|void
name|insert_sreg
parameter_list|(
name|regname
parameter_list|,
name|regnum
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* FIXME-SOON, put something in these syms so they won't be output      to the symbol table of the resulting object file.  */
comment|/* Must be large enough to hold the names of the special registers.  */
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|regname
argument_list|,
name|SEG_REGISTER
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|SEG_REGISTER
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install symbol definitions for assorted special registers.    See ASM29K Ref page 2-9.  */
end_comment

begin_function
specifier|static
name|void
name|define_some_regs
parameter_list|()
block|{
define|#
directive|define
name|SREG
value|256
comment|/* Protected special-purpose register names */
name|insert_sreg
argument_list|(
literal|"vab"
argument_list|,
name|SREG
operator|+
literal|0
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ops"
argument_list|,
name|SREG
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cps"
argument_list|,
name|SREG
operator|+
literal|2
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cfg"
argument_list|,
name|SREG
operator|+
literal|3
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cha"
argument_list|,
name|SREG
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"chd"
argument_list|,
name|SREG
operator|+
literal|5
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"chc"
argument_list|,
name|SREG
operator|+
literal|6
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rbp"
argument_list|,
name|SREG
operator|+
literal|7
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"tmc"
argument_list|,
name|SREG
operator|+
literal|8
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"tmr"
argument_list|,
name|SREG
operator|+
literal|9
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc0"
argument_list|,
name|SREG
operator|+
literal|10
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc1"
argument_list|,
name|SREG
operator|+
literal|11
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc2"
argument_list|,
name|SREG
operator|+
literal|12
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"mmu"
argument_list|,
name|SREG
operator|+
literal|13
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"lru"
argument_list|,
name|SREG
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* Additional protected special-purpose registers for the 29050 */
name|insert_sreg
argument_list|(
literal|"rsn"
argument_list|,
name|SREG
operator|+
literal|15
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rma0"
argument_list|,
name|SREG
operator|+
literal|16
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rmc0"
argument_list|,
name|SREG
operator|+
literal|17
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rma1"
argument_list|,
name|SREG
operator|+
literal|18
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rmc1"
argument_list|,
name|SREG
operator|+
literal|19
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"spc0"
argument_list|,
name|SREG
operator|+
literal|20
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"spc1"
argument_list|,
name|SREG
operator|+
literal|21
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"spc2"
argument_list|,
name|SREG
operator|+
literal|22
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"iba0"
argument_list|,
name|SREG
operator|+
literal|23
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ibc0"
argument_list|,
name|SREG
operator|+
literal|24
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"iba1"
argument_list|,
name|SREG
operator|+
literal|25
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ibc1"
argument_list|,
name|SREG
operator|+
literal|26
argument_list|)
expr_stmt|;
comment|/* Additional registers for the 29040.  */
name|insert_sreg
argument_list|(
literal|"dba"
argument_list|,
name|SREG
operator|+
literal|27
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"dbc"
argument_list|,
name|SREG
operator|+
literal|28
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cir"
argument_list|,
name|SREG
operator|+
literal|29
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cdr"
argument_list|,
name|SREG
operator|+
literal|30
argument_list|)
expr_stmt|;
comment|/* Unprotected special-purpose register names */
name|insert_sreg
argument_list|(
literal|"ipc"
argument_list|,
name|SREG
operator|+
literal|128
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ipa"
argument_list|,
name|SREG
operator|+
literal|129
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ipb"
argument_list|,
name|SREG
operator|+
literal|130
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"q"
argument_list|,
name|SREG
operator|+
literal|131
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"alu"
argument_list|,
name|SREG
operator|+
literal|132
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"bp"
argument_list|,
name|SREG
operator|+
literal|133
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fc"
argument_list|,
name|SREG
operator|+
literal|134
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cr"
argument_list|,
name|SREG
operator|+
literal|135
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fpe"
argument_list|,
name|SREG
operator|+
literal|160
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"inte"
argument_list|,
name|SREG
operator|+
literal|161
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fps"
argument_list|,
name|SREG
operator|+
literal|162
argument_list|)
expr_stmt|;
comment|/*  "",    SREG+163);	  Reserved */
name|insert_sreg
argument_list|(
literal|"exop"
argument_list|,
name|SREG
operator|+
literal|164
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc., that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|skipnext
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|strend
decl_stmt|,
modifier|*
name|strend2
decl_stmt|;
comment|/* Hash up all the opcodes for fast use later.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|skipnext
condition|)
block|{
name|skipnext
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Hack to avoid multiple opcode entries.  We pre-locate all the 	 variations (b/i field and P/A field) and handle them.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|&
literal|0x01000000
operator|)
operator|!=
literal|0
operator|||
operator|(
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|opcode
operator|&
literal|0x01000000
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator||
literal|0x01000000
operator|)
operator|!=
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|opcode
operator|)
condition|)
goto|goto
name|bad_table
goto|;
name|strend
operator|=
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|args
operator|+
name|strlen
argument_list|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strend2
operator|=
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|args
operator|+
name|strlen
argument_list|(
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|args
argument_list|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|strend
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'i'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'A'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
default|default:
name|bad_table
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't handle opcode %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OK, this is an i/b or A/P pair.  We skip the 	     higher-valued one, and let the code for operand checking 	     handle OR-ing in the bit.  */
name|skipnext
operator|=
literal|1
expr_stmt|;
block|}
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|machine_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't hash `%s': %s\n"
argument_list|,
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
name|define_some_regs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction.  Its label has already been handled    by the generic front end.  We just parse opcode and operands, and    produce the bytes of data and relocation.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|toP
decl_stmt|;
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|machine_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the opcode */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the symbol-dependent stuff */
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|NO_RELOC
condition|)
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|the_insn
operator|.
name|reloc_offset
operator|)
argument_list|,
literal|4
argument_list|,
comment|/* size */
operator|&
name|the_insn
operator|.
name|exp
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_operand
parameter_list|(
name|s
parameter_list|,
name|operandp
parameter_list|,
name|opt
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|operandp
decl_stmt|;
name|int
name|opt
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|operandp
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandp
operator|->
name|X_op
operator|==
name|O_absent
operator|&&
operator|!
name|opt
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Instruction parsing.  Takes a string containing the opcode.    Operands are at input_line_pointer.  Output is in the_insn.    Warnings or errors are generated.  */
end_comment

begin_function
specifier|static
name|void
name|machine_ip
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|struct
name|machine_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|expressionS
name|the_operand
decl_stmt|;
name|expressionS
modifier|*
name|operand
init|=
operator|&
name|the_operand
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Must handle `div0' opcode.  */
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
for|for
control|(
init|;
name|ISALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
operator|*
name|s
operator|=
name|TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
comment|/* FIXME-SOMEDAY more whitespace */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|machine_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode `%s'."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
name|opcode
operator|=
name|insn
operator|->
name|opcode
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the      operands match.       If an operand matches, we modify the_insn or opcode appropriately,      and do a "continue".  If an operand fails to match, we "break".  */
if|if
condition|(
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Prime the pump.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* end of args */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* We are truly done.  */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Too many operands: %s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Must match a comma */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
comment|/* Parse next operand.  */
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|,
name|args
index|[
literal|1
index|]
operator|==
literal|'I'
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Trap numbers (immediate field) */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
literal|256
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value of %ld is too large"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|operand
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_8
expr_stmt|;
name|the_insn
operator|.
name|reloc_offset
operator|=
literal|1
expr_stmt|;
comment|/* BIG-ENDIAN Byte 1 of insn */
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
comment|/* A general register or 8-bit immediate */
case|case
literal|'i'
case|:
comment|/* We treat the two cases identically since we mashed 	     them together in the opcode table.  */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_register
condition|)
goto|goto
name|general_reg
goto|;
comment|/* Make sure the 'i' case really exists.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
operator||
name|IMMEDIATE_BIT
operator|)
operator|!=
operator|(
name|insn
operator|+
literal|1
operator|)
operator|->
name|opcode
condition|)
break|break;
name|opcode
operator||=
name|IMMEDIATE_BIT
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
literal|256
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate value of %ld is too large"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|operand
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_8
expr_stmt|;
name|the_insn
operator|.
name|reloc_offset
operator|=
literal|3
expr_stmt|;
comment|/* BIG-ENDIAN Byte 3 of insn */
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* next operand must be a register */
case|case
literal|'c'
case|:
name|general_reg
label|:
comment|/* lrNNN or grNNN or %%expr or a user-def register name */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|!=
name|O_register
condition|)
break|break;
comment|/* Only registers */
name|know
argument_list|(
name|operand
operator|->
name|X_add_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operand
operator|->
name|X_op_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|operand
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|SREG
condition|)
break|break;
comment|/* No special registers */
comment|/* Got the register, now figure out where it goes in the 	     opcode.  */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'a'
case|:
name|opcode
operator||=
name|reg
operator|<<
literal|8
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'i'
case|:
name|opcode
operator||=
name|reg
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|opcode
operator||=
name|reg
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* 16 bit constant, zero-extended */
case|case
literal|'X'
case|:
comment|/* 16 bit constant, one-extended */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF
operator|)
operator|<<
literal|0
operator||
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF00
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_CONST
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
operator||
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|operand
operator|->
name|X_add_number
comment|/* avoid sign ext */
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_CONSTH
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
comment|/* PC-relative jump address */
case|case
literal|'A'
case|:
comment|/* Absolute jump address */
comment|/* These two are treated together since we folded the 	     opcode table entries together.  */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Make sure the 'A' case really exists.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|opcode
operator||
name|ABSOLUTE_BIT
operator|)
operator|!=
operator|(
name|insn
operator|+
literal|1
operator|)
operator|->
name|opcode
condition|)
break|break;
block|{
name|bfd_vma
name|v
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x1ffff
expr_stmt|;
name|v
operator|=
name|operand
operator|->
name|X_add_number
operator|&
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|as_bad
argument_list|(
literal|"call/jmp target out of range"
argument_list|)
expr_stmt|;
block|}
name|opcode
operator||=
name|ABSOLUTE_BIT
operator||
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x0003FC00
operator|)
operator|<<
literal|6
operator||
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x000003FC
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_JUMPTARG
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
comment|/* Assume PC-relative jump */
comment|/* FIXME-SOON, Do we figure out whether abs later, after              know sym val? */
continue|continue;
case|case
literal|'e'
case|:
comment|/* Coprocessor enable bit for LOAD/STORE insn */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|opcode
operator||=
name|CE_BIT
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* Control bits for LOAD/STORE instructions */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|128
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Special register number */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|!=
name|O_register
condition|)
break|break;
comment|/* Only registers */
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
name|SREG
condition|)
break|break;
comment|/* Not a special register */
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* UI bit of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|opcode
operator||=
name|UI_BIT
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* RND bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|8
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* ID bits of INV and IRETINV.  */
comment|/* This operand is optional.  */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_absent
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* FD bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* FS bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|operand
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|16
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|18
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Types or values of args don't match.  */
name|as_bad
argument_list|(
literal|"Invalid operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* This is identical to the md_atof in m68k.c.  I think this is right,    but I'm not sure.     Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write out big-endian.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
name|know
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* This is a hack.  There should be a better way to handle this.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_WDISP30
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
name|val
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_8
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP30
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_HI22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
break|break;
case|case
name|RELOC_LO10
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x03
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_BASE13
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP22
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RELOC_BASE22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_JUMPTARG
case|:
comment|/* 00XX00XX pattern in a word */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* The linker tries to support both AMD and old GNU style              R_IREL relocs.  That means that if the addend is exactly              the negative of the address within the section, the              linker will not handle it correctly.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|val
operator|!=
literal|0
operator|&&
name|val
operator|==
operator|-
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"the linker will not handle this relocation correctly"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|long
name|v
init|=
name|val
operator|>>
literal|17
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|v
operator|!=
operator|-
literal|1
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"call/jmp target out of range"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This case was supposed to be handled in machine_ip.  */
name|abort
argument_list|()
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
comment|/* Holds bits 0003FFFC of address */
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|RELOC_CONST
case|:
comment|/* 00XX00XX pattern in a word */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* Holds bits 0000XXXX */
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_CONSTH
case|:
comment|/* 00XX00XX pattern in a word */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
comment|/* Holds bits XXXX0000 */
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|NO_RELOC
case|:
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relocation type: 0x%02x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
return|return
operator|(
name|R_WORD
operator|)
return|;
case|case
name|RELOC_8
case|:
return|return
operator|(
name|R_BYTE
operator|)
return|;
case|case
name|RELOC_CONST
case|:
return|return
operator|(
name|R_ILOHALF
operator|)
return|;
case|case
name|RELOC_CONSTH
case|:
return|return
operator|(
name|R_IHIHALF
operator|)
return|;
case|case
name|RELOC_JUMPTARG
case|:
return|return
operator|(
name|R_IREL
operator|)
return|;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"need %o3\n"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* switch on type */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/* should never be called for 29k */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"a29k_convert_frag\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* should never be called for a29k */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"a29k_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* for debugging only */
end_comment

begin_endif
unit|static void print_insn (insn)      struct machine_it *insn; {   char *Reloc[] =   {     "RELOC_8",     "RELOC_16",     "RELOC_32",     "RELOC_DISP8",     "RELOC_DISP16",     "RELOC_DISP32",     "RELOC_WDISP30",     "RELOC_WDISP22",     "RELOC_HI22",     "RELOC_22",     "RELOC_13",     "RELOC_LO10",     "RELOC_SFA_BASE",     "RELOC_SFA_OFF13",     "RELOC_BASE10",     "RELOC_BASE13",     "RELOC_BASE22",     "RELOC_PC10",     "RELOC_PC22",     "RELOC_JMP_TBL",     "RELOC_SEGOFF16",     "RELOC_GLOB_DAT",     "RELOC_JMP_SLOT",     "RELOC_RELATIVE",     "NO_RELOC"   };    if (insn->error)     {       fprintf (stderr, "ERROR: %s\n");     }   fprintf (stderr, "opcode=0x%08x\n", insn->opcode);   fprintf (stderr, "reloc = %s\n", Reloc[insn->reloc]);   fprintf (stderr, "exp =  {\n");   fprintf (stderr, "\t\tX_add_symbol = %s\n", 	   insn->exp.X_add_symbol ? 	   (S_GET_NAME (insn->exp.X_add_symbol) ? 	    S_GET_NAME (insn->exp.X_add_symbol) : "???") : "0");   fprintf (stderr, "\t\tX_op_symbol = %s\n", 	   insn->exp.X_op_symbol ? 	   (S_GET_NAME (insn->exp.X_op_symbol) ? 	    S_GET_NAME (insn->exp.X_op_symbol) : "???") : "0");   fprintf (stderr, "\t\tX_add_number = %d\n", 	   insn->exp.X_add_number);   fprintf (stderr, "}\n"); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate internal representation of relocation info to target format.     On sparc/29k: first 4 bytes are normal unsigned long address, next three    bytes are index, most sig. byte first.  Byte 7 is broken up with    bit 7 as external, bits 6& 5 unused, and the lower    five bits as relocation type.  Next 4 bytes are long addend.  */
end_comment

begin_comment
comment|/* Thanx and a tip of the hat to Michael Bloom, mb@ttidca.tti.com */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
literal|0
operator|&
literal|0x60
operator|)
operator||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|&
literal|0x1F
operator|)
expr_stmt|;
comment|/* Also easy */
name|md_number_to_chars
argument_list|(
operator|&
name|where
index|[
literal|8
index|]
argument_list|,
name|fixP
operator|->
name|fx_addnumber
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called when a line is unrecognized.  This is used to handle    definitions of a29k style local labels.  */
end_comment

begin_function
name|int
name|a29k_unrecognized_line
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|lab
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'$'
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|lab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|lab
operator|=
name|lab
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
block|{
comment|/* Not a label definition.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"label \"$%d\" redefined"
argument_list|)
argument_list|,
name|lab
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|define_dollar_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Default the values of symbols known that should be "predefined".  We    don't bother to predefine them unless you actually use one, since there    are a lot of them.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|long
name|regnum
decl_stmt|;
name|char
name|testbuf
index|[
literal|5
operator|+
comment|/*SLOP*/
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'G'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* Perhaps a global or local register name */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'r'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
block|{
name|long
name|maxreg
decl_stmt|;
comment|/* Parse the number, make sure it has no extra zeroes or 	     trailing chars.  */
name|regnum
operator|=
name|atol
argument_list|(
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
name|maxreg
operator|=
literal|255
expr_stmt|;
else|else
name|maxreg
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|regnum
operator|>
name|maxreg
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|testbuf
argument_list|,
literal|"%ld"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|testbuf
argument_list|,
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* gr007 or lr7foo or whatever */
comment|/* We have a wiener!  Define and return a new symbol for it.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
name|regnum
operator|+=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
name|regnum
operator|+=
name|SREG
expr_stmt|;
return|return
operator|(
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_REGISTER
argument_list|,
operator|(
name|valueT
operator|)
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
operator|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
comment|/* We have a numeric register expression.  No biggy.  */
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Skip %% */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_constant
operator|||
name|expressionP
operator|->
name|X_add_number
operator|>
literal|255
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid expression after %%%%\n"
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* We are taking the 'address' of a register...this one is not 	 in the manual, but it *is* in traps/fpsymbol.h!  What they 	 seem to want is the register number, as an absolute number.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip& */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|!=
name|O_register
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register in& expression"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|ISDIGIT
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|long
name|lab
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* This is a local label.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|lab
operator|=
operator|(
name|long
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|dollar_label_defined
argument_list|(
name|lab
argument_list|)
condition|)
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|dollar_label_name
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|expressionP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|fieldnum
decl_stmt|,
name|fieldlimit
decl_stmt|;
name|LITTLENUM_TYPE
name|floatbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* $float(), $doubleN(), or $extendN() convert floating values 	 to integers.  */
name|s
operator|=
name|input_line_pointer
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|fieldnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"double"
argument_list|,
sizeof|sizeof
expr|"double"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"double"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'d'
expr_stmt|;
name|fieldlimit
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"float"
argument_list|,
sizeof|sizeof
expr|"float"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"float"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'f'
expr_stmt|;
name|fieldlimit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"extend"
argument_list|,
sizeof|sizeof
expr|"extend"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
expr|"extend"
operator|-
literal|1
expr_stmt|;
name|type
operator|=
literal|'x'
expr_stmt|;
name|fieldlimit
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|fieldnum
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|fieldnum
operator|>=
name|fieldlimit
condition|)
return|return;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
return|return;
operator|++
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|s
operator|=
name|atof_ieee
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|floatbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|s
operator|=
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|')'
condition|)
return|return;
operator|++
name|s
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_unsigned
operator|=
literal|1
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
operator|(
name|floatbuf
index|[
name|fieldnum
operator|*
literal|2
index|]
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|+
name|floatbuf
index|[
name|fieldnum
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the 29000, they're relative to the address of the instruction,    which we have set up as the address of the fixup too.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

end_unit

