begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SOM object file format.    Copyright 1993, 1994, 1998, 2000, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2,    or (at your option) any later version.     GAS is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|version_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copyright_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compiler_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unused by SOM.  */
end_comment

begin_function
name|void
name|obj_read_begin_hook
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Handle a .compiler directive.   This is intended to create the    compilation unit auxiliary header for MPE such that the linkeditor    can handle SOM extraction from archives. The format of the quoted    string is "sourcefile language version" and is delimited by blanks.  */
end_comment

begin_function
name|void
name|obj_som_compiler
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|language_name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|version_id
decl_stmt|;
if|if
condition|(
name|compiler_seen
condition|)
block|{
name|as_bad
argument_list|(
literal|"Only one .compiler pseudo-op per file!"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|buf
operator|=
name|input_line_pointer
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Expected quoted string"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Parse the quoted string into its component parts.  Skip the      quote.  */
name|filename
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|filename
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\000'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\000'
condition|)
block|{
name|as_bad
argument_list|(
literal|".compiler directive missing language and version"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|'\000'
expr_stmt|;
name|language_name
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\000'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\000'
condition|)
block|{
name|as_bad
argument_list|(
literal|".compiler directive missing version"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|'\000'
expr_stmt|;
name|version_id
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\000'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Remove the trailing quote.  */
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
literal|'\000'
expr_stmt|;
name|compiler_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_som_attach_compilation_unit
argument_list|(
name|stdoutput
argument_list|,
name|filename
argument_list|,
name|language_name
argument_list|,
literal|"GNU Tools"
argument_list|,
name|version_id
argument_list|)
condition|)
block|{
name|bfd_perror
argument_list|(
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
literal|"FATAL: Attaching compiler header %s"
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .version directive.  */
end_comment

begin_function
name|void
name|obj_som_version
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|version
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|version_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Only one .version pseudo-op per file!"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|version
operator|=
name|input_line_pointer
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected quoted string"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|version_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_som_attach_aux_hdr
argument_list|(
name|stdoutput
argument_list|,
name|VERSION_AUX_ID
argument_list|,
name|version
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"attaching version header %s: %s"
argument_list|)
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .copyright directive.   This probably isn't complete, but    it's of dubious value anyway and (IMHO) not worth the time to finish.    If you care about copyright strings that much, you fix it.  */
end_comment

begin_function
name|void
name|obj_som_copyright
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|copyright
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|copyright_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Only one .copyright pseudo-op per file!"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|copyright
operator|=
name|input_line_pointer
expr_stmt|;
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|is_a_char
argument_list|(
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
empty_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected quoted string"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|copyright_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_som_attach_aux_hdr
argument_list|(
name|stdoutput
argument_list|,
name|COPYRIGHT_AUX_ID
argument_list|,
name|copyright
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"attaching copyright header %s: %s"
argument_list|)
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any initialization necessary for stabs support.     For SOM we need to create the space which will contain the    two stabs subspaces.  Additionally we need to set up the    space/subspace relationships and set space/subspace attributes    which BFD does not understand.  */
end_comment

begin_function
name|void
name|obj_som_init_stab_section
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|segT
name|space
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
comment|/* Make the space which will contain the debug subspaces.  */
name|space
operator|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
literal|"$GDB_DEBUG$"
argument_list|)
expr_stmt|;
comment|/* Set SOM specific attributes for the space.  In particular we set      the space "defined", "private", "sort_key", and "spnum" values.       Due to a bug in pxdb (called by hpux linker), the sort keys      of the various stabs spaces/subspaces need to be "small".  We      reserve range 72/73 which appear to work well.  */
name|obj_set_section_attributes
argument_list|(
name|space
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|72
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|space
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set the containing space for both stab sections to be $GDB_DEBUG$      (just created above).  Also set some attributes which BFD does      not understand.  In particular, access bits, sort keys, and load      quadrant.  */
name|obj_set_subsection_attributes
argument_list|(
name|seg
argument_list|,
name|space
argument_list|,
literal|0x1f
argument_list|,
literal|73
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Make some space for the first special stab entry and zero the memory.      It contains information about the length of this file's      stab string and the like.  Using it avoids the need to      relocate the stab strings.       The $GDB_STRINGS$ space will be created as a side effect of      the call to get_stab_string_offset.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|file
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stroff
operator|==
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|stabu
operator|.
name|p
operator|=
name|p
expr_stmt|;
comment|/* Set the containing space for both stab sections to be $GDB_DEBUG$      (just created above).  Also set some attributes which BFD does      not understand.  In particular, access bits, sort keys, and load      quadrant.  */
name|seg
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
expr_stmt|;
name|obj_set_subsection_attributes
argument_list|(
name|seg
argument_list|,
name|space
argument_list|,
literal|0x1f
argument_list|,
literal|72
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in the counts in the first entry in a .stabs section.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_stab_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|PTR
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|strsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|strsz
decl_stmt|,
name|nsyms
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"$GDB_SYMBOLS$"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
condition|)
return|return;
name|strsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strsec
condition|)
name|strsz
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|strsec
argument_list|)
expr_stmt|;
else|else
name|strsz
operator|=
literal|0
expr_stmt|;
name|nsyms
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|/
literal|12
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|stabu
operator|.
name|p
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nsyms
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|strsz
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called late in the assembly phase to adjust the special    stab entry and to set the starting address for each code subspace.  */
end_comment

begin_function
name|void
name|som_frob_file
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|adjust_stab_sections
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_som_weak
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
block|{
literal|"weak"
block|,
name|obj_som_weak
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

