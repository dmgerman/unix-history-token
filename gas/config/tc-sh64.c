begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-sh64.c -- Assemble code for the SuperH SH SHcompact and SHmedia.    Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file defines SHmedia ISA-specific functions and includes tc-sh.c.    The SHcompact ISA is in all useful aspects the "old" sh4 as implemented    in tc-sh.c.  Not making this file part of tc-sh.c makes it easier to    keep a leaner sh[1-4]-only implementation.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_SH64
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/sh64-opc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_ELF
end_ifndef

begin_error
error|#
directive|error
error|This file assumes object output is in the ELF format
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Suffix used when we make "datalabel" symbol copies.  It must not    collide with anything that can normally appear in a symbol, "faked    symbol" or local symbol.  */
end_comment

begin_define
define|#
directive|define
name|DATALABEL_SUFFIX
value|" DL"
end_define

begin_comment
comment|/* See shmedia_md_apply_fix and shmedia_md_pcrel_from_section for usage.  */
end_comment

begin_define
define|#
directive|define
name|SHMEDIA_MD_PCREL_FROM_FIX
parameter_list|(
name|FIXP
parameter_list|)
define|\
value|((FIXP)->fx_size + (FIXP)->fx_where + (FIXP)->fx_frag->fr_address - 4)
end_define

begin_comment
comment|/* We use this internally to see which one is PT and which is a PTA/PTB    that should be error-checked.  We give it a better name here (but not    one that looks official).  Adding it to reloc.c would make it look too    much of a real reloc; it is just used temporarily as a fixup-type.  */
end_comment

begin_define
define|#
directive|define
name|SHMEDIA_BFD_RELOC_PT
value|BFD_RELOC_12_PCREL
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|shmedia_arg_type
name|type
decl_stmt|;
comment|/* These could go into a union, but that would uglify the code.  */
name|int
name|reg
decl_stmt|;
name|expressionS
name|immediate
decl_stmt|;
comment|/* If IMMEDIATE was a shift-expression, like "(S>> N)& 65535", where       N = 0, 16, 32, 48, used to extract a certain 16-bit-field to make up       a MOVI or SHORI relocation for a symbol, then we put the       corresponding reloc-type here and modify the "immediate" expression       to S.  Otherwise, this is just BFD_RELOC_NONE.  */
name|bfd_reloc_code_real_type
name|reloctype
decl_stmt|;
block|}
name|shmedia_operand_info
typedef|;
end_typedef

begin_comment
comment|/* Frag containing last base instruction.  This is put in the TC field in    a frag, so we can emit fixups for fr_opcode without needing to make    sure that the opcode is in the same frag as any variant operand.  */
end_comment

begin_decl_stmt
name|fragS
modifier|*
name|sh64_last_insn_frag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|shmedia_operand_info
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|long
name|ops_val
decl_stmt|;
block|}
name|shmedia_operands_info
typedef|;
end_typedef

begin_enum
enum|enum
name|sh64_abi_values
block|{
name|sh64_abi_unspecified
block|,
name|sh64_abi_32
block|,
name|sh64_abi_64
block|}
enum|;
end_enum

begin_comment
comment|/* What ISA are we assembling code for?  */
end_comment

begin_decl_stmt
name|enum
name|sh64_isa_values
name|sh64_isa_mode
init|=
name|sh64_isa_unspecified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What ABI was specified, if any (implicitly or explicitly)?  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|sh64_abi_values
name|sh64_abi
init|=
name|sh64_abi_unspecified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A note that says if we're in a sequence of insns without label    settings, segment or ISA mode changes or emitted data.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|seen_insn
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set to TRUE in shmedia_md_end, so that we don't emit any    .cranges entries when the assembler calls output functions while    grinding along after all input is seen.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sh64_end_of_assembly
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controlled by the option -no-mix, this invalidates mixing SHcompact and    SHmedia code in the same section, and also invalidates mixing data and    SHmedia code in the same section.  No .cranges will therefore be    emitted, unless -shcompact-const-crange is specified and there is a    constant pool in SHcompact code.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sh64_mix
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sh64_shcompact_const_crange
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controlled by the option -no-expand, this says whether or not we expand    MOVI and PT/PTA/PTB.  When we do not expand these insns to fit an    operand, we will emit errors for operands out of range and generate the    basic instruction and reloc for an external symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sh64_expand
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controlled by the option -expand-pt32, this says whether we expand    PT/PTA/PTB of an external symbol to (only) 32 or (the full) 64 bits    when -abi=64 is in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sh64_pt32
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When emitting a .cranges descriptor, we want to avoid getting recursive    calls through emit_expr.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|emitting_crange
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SHmedia mnemonics.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|shmedia_opcode_hash_control
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|shmedia_big_nop_pattern
index|[
literal|4
index|]
init|=
block|{
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|24
operator|)
operator|&
literal|255
block|,
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|16
operator|)
operator|&
literal|255
block|,
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|8
operator|)
operator|&
literal|255
block|,
name|SHMEDIA_NOP_OPC
operator|&
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|shmedia_little_nop_pattern
index|[
literal|4
index|]
init|=
block|{
name|SHMEDIA_NOP_OPC
operator|&
literal|255
block|,
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|8
operator|)
operator|&
literal|255
block|,
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|16
operator|)
operator|&
literal|255
block|,
operator|(
name|SHMEDIA_NOP_OPC
operator|>>
literal|24
operator|)
operator|&
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|shmedia_md_begin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmedia_parse_reg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|shmedia_arg_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_md_assemble
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_md_apply_fix
parameter_list|(
name|fixS
modifier|*
parameter_list|,
name|valueT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmedia_md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|segT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmedia_init_reloc
parameter_list|(
name|arelent
modifier|*
parameter_list|,
name|fixS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shmedia_get_operands
parameter_list|(
name|shmedia_opcode_info
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|shmedia_operands_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_sh64_mode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_sh64_abi
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_md_convert_frag
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|segT
parameter_list|,
name|fragS
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_check_limits
parameter_list|(
name|offsetT
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|,
name|fixS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_set_contents_type
parameter_list|(
name|enum
name|sh64_elf_cr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_get_operand
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|shmedia_operand_info
modifier|*
parameter_list|,
name|shmedia_arg_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|shmedia_immediate_op
parameter_list|(
name|char
modifier|*
parameter_list|,
name|shmedia_operand_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shmedia_parse_exp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|shmedia_operand_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmedia_frob_file_before_adjust
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_emit_crange
parameter_list|(
name|symbolS
modifier|*
parameter_list|,
name|symbolS
modifier|*
parameter_list|,
name|enum
name|sh64_elf_cr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_flush_last_crange
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_flag_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_update_contents_mark
parameter_list|(
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_vtable_entry
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_vtable_inherit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|strip_datalabels
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmedia_build_Mytes
parameter_list|(
name|shmedia_opcode_info
modifier|*
parameter_list|,
name|shmedia_operands_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|shmedia_opcode_info
modifier|*
name|shmedia_find_cooked_opcode
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|shmedia_mask_number
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"tc-sh.c"
end_include

begin_function
name|void
name|shmedia_md_end
parameter_list|(
name|void
parameter_list|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
comment|/* First, update the last range to include whatever data was last      emitted.  */
name|sh64_update_contents_mark
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Make sure frags generated after this point are not marked with the      wrong ISA; make them easily spottable.  We still want to distinguish      it from sh64_isa_unspecified when we compile for SHcompact or      SHmedia.  */
if|if
condition|(
name|sh64_isa_mode
operator|!=
name|sh64_isa_unspecified
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_sh5_guard
expr_stmt|;
name|sh64_end_of_assembly
operator|=
name|TRUE
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|sh64_flush_last_crange
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Iterate over segments and emit the last .cranges descriptor.  */
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
operator|!=
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|sy_next
control|)
block|{
name|symbolS
modifier|*
name|mainsym
init|=
operator|*
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
decl_stmt|;
comment|/* Is this a datalabel symbol; does it have a pointer to the main 	 symbol?  */
if|if
condition|(
name|mainsym
operator|!=
name|NULL
condition|)
block|{
comment|/* If the datalabel symbol is undefined, check if the main 	     symbol has changed in that respect.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|undefined_section
condition|)
block|{
name|segT
name|symseg
decl_stmt|;
name|symseg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|mainsym
argument_list|)
expr_stmt|;
comment|/* If the symbol is now defined to something that is not 		 global and without STO_SH5_ISA32, we just equate the 		 datalabel symbol to the main symbol, and the lack of 		 STO_SH5_ISA32 will handle the datalabelness.  */
if|if
condition|(
name|symseg
operator|!=
name|undefined_section
condition|)
block|{
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|mainsym
argument_list|)
operator|!=
name|STO_SH5_ISA32
condition|)
block|{
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|mainsym
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symp
argument_list|,
name|mainsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An undefined symbol has since we saw it at 			 "datalabel", been defined to a BranchTarget 			 symbol.  What we need to do here is very similar 			 to when we find the "datalabel" for a defined 			 symbol.  FIXME: Break out to common function.  */
name|symbol_set_value_expression
argument_list|(
name|symp
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|symseg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp
argument_list|,
name|symbol_get_frag
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symp
argument_list|,
name|mainsym
argument_list|)
expr_stmt|;
comment|/* Unset the BranchTarget mark that can be set at 			 attribute-copying.  */
name|S_SET_OTHER
argument_list|(
name|symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
operator|~
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
comment|/* The GLOBAL and WEAK attributes are not copied 			 over by copy_symbol_attributes.  Do it here.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|mainsym
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|symp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|mainsym
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A symbol that was defined at the time we saw 		     "datalabel" can since have been attributed with being 		     weak or global.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|mainsym
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|symp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|mainsym
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
operator|!=
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|sy_next
control|)
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
name|STO_SH5_ISA32
condition|)
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When resolving symbols, the main assembler has done us a misfavour.  It    has removed the equation to the main symbol for a datalabel reference    that should be equal to the main symbol, e.g. when it's a global or    weak symbol and is a non-BranchTarget symbol anyway.  We change that    back, so that relocs are against the main symbol, not the local "section    + offset" value.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_frob_file_before_adjust
parameter_list|(
name|void
parameter_list|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
operator|!=
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|sy_next
control|)
block|{
name|symbolS
modifier|*
name|mainsym
init|=
operator|*
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainsym
operator|!=
name|NULL
operator|&&
name|S_GET_OTHER
argument_list|(
name|mainsym
argument_list|)
operator|!=
name|STO_SH5_ISA32
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|mainsym
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|mainsym
argument_list|)
operator|)
condition|)
block|{
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|mainsym
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* For the "equation trick" to work, we have to set the section 	     to undefined.  */
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symp
argument_list|,
name|mainsym
argument_list|)
expr_stmt|;
comment|/* Don't forget to remove the STO_SH5_ISA32 attribute after 	     copying the other attributes.  */
name|S_SET_OTHER
argument_list|(
name|symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
operator|~
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We need to mark the current location after the alignment.  This is    copied code the caller, do_align.  We mark the frag location before and    after as we need and arrange to skip the same code in do_align.     An alternative to code duplication is to call the do_align recursively,    arranging to fall through into do_align if we're already here.  That    would require do_align as an incoming function parameter, since it's    static in read.c.  That solution was discarded a too kludgy.  */
end_comment

begin_function
name|void
name|sh64_do_align
parameter_list|(
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fill
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|max
parameter_list|)
block|{
comment|/* Update region, or put a data region in front.  */
name|sh64_update_contents_mark
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Only make a frag if we HAVE to...  */
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|fill
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|frag_align_code
argument_list|(
name|n
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|frag_align
argument_list|(
name|n
argument_list|,
operator|*
name|fill
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|frag_align_pattern
argument_list|(
name|n
argument_list|,
name|fill
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Update mark for current region with current type.  */
name|sh64_update_contents_mark
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MAX_MEM_FOR_RS_ALIGN_CODE worker.  We have to find out the ISA of    the current segment at this position.  We can't look just at    sh64_isa_shmedia, and we can't look at frag_now.  This is brittle:    callers are currently frag_align_code from subsegs_finish in write.c    (end of assembly) and frag_align_code from do_align in read.c (during    assembly).  */
end_comment

begin_function
name|int
name|sh64_max_mem_for_rs_align_code
parameter_list|(
name|void
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|fragS
modifier|*
name|mode_start_frag
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
comment|/* We don't use the contents type we find at the tc_segment_info_data,      since that does not give us absolute information about the ISA; the      contents type can presumably be CRT_DATA and we'd be none the wiser.      Instead we use the information stored at the frag of the symbol at      the start of this range.  If any information is missing or NULL,      assume SHcompact.  */
return|return
comment|/* If the current ISA mode is SHmedia, that's the mode that we're        going to assign to the new frag, so request enough memory for        it, even if we switch modes afterwards, otherwise we may        allocate too little memory and end up overflowing our buffer.  */
operator|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
operator|||
operator|(
name|sh64_isa_mode
operator|!=
name|sh64_isa_unspecified
operator|&&
name|seginfo
operator|!=
name|NULL
operator|&&
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|mode_start_frag
operator|=
operator|(
name|symbol_get_frag
argument_list|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
argument_list|)
operator|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|mode_start_frag
operator|->
name|tc_frag_data
operator|.
name|isa
operator|==
name|sh64_isa_shmedia
operator|)
operator|)
condition|?
operator|(
literal|3
operator|+
literal|4
operator|)
else|:
operator|(
literal|2
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Put in SHmedia NOP:s if the alignment was created when in SHmedia mode.  */
end_comment

begin_function
name|void
name|sh64_handle_align
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|int
name|bytes
init|=
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_fix
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
decl_stmt|;
if|if
condition|(
name|frag
operator|->
name|tc_frag_data
operator|.
name|isa
operator|==
name|sh64_isa_shmedia
operator|&&
name|frag
operator|->
name|fr_type
operator|==
name|rs_align_code
condition|)
block|{
while|while
condition|(
name|bytes
operator|&
literal|3
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|shmedia_big_nop_pattern
argument_list|,
sizeof|sizeof
name|shmedia_big_nop_pattern
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
sizeof|sizeof
name|shmedia_big_nop_pattern
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|shmedia_little_nop_pattern
argument_list|,
sizeof|sizeof
name|shmedia_little_nop_pattern
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
sizeof|sizeof
name|shmedia_little_nop_pattern
expr_stmt|;
block|}
block|}
else|else
comment|/* Punt to SHcompact function.  */
name|sh_handle_align
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set SEC_SH64_ISA32 for SHmedia sections.  */
end_comment

begin_function
name|void
name|shmedia_frob_section_type
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* This and elf32-sh64.c:sh64_elf_fake_sections are the only places      where we use anything else than ELF header flags to communicate the      section as containing SHmedia or other contents.  BFD SEC_* section      flags are running out and should not be overloaded with      target-specific semantics.  This target is ELF only (semantics not      defined for other formats), so we use the target-specific pointer      field of the ELF section data.  */
if|if
condition|(
name|seginfo
operator|&&
name|sh64_abi
operator|==
name|sh64_abi_32
condition|)
block|{
name|struct
name|sh64_section_data
modifier|*
name|sec_elf_data
decl_stmt|;
name|flagword
name|sec_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|emitted_ranges
operator|!=
literal|0
condition|)
name|sec_type
operator|=
name|SHF_SH5_ISA32_MIXED
expr_stmt|;
elseif|else
if|if
condition|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
operator|==
name|CRT_SH5_ISA32
condition|)
name|sec_type
operator|=
name|SHF_SH5_ISA32
expr_stmt|;
name|sec_elf_data
operator|=
name|sh64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sh64_info
expr_stmt|;
if|if
condition|(
name|sec_elf_data
operator|==
name|NULL
condition|)
block|{
name|sec_elf_data
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sec_elf_data
argument_list|)
argument_list|)
expr_stmt|;
name|sh64_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sh64_info
operator|=
name|sec_elf_data
expr_stmt|;
block|}
name|sec_elf_data
operator|->
name|contents_flags
operator|=
name|sec_type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called by write_object_file right before the symbol    table is written.  We subtract 1 from all symbols marked STO_SH5_ISA32,    as their values are temporarily incremented in shmedia_md_end, before    symbols values are used by relocs and fixups.     To increment all symbols and then decrement here is admittedly a    hackish solution.  The alternative is to add infrastructure and hooks    to symbol evaluation that evaluates symbols differently internally to    the value output into the object file, but at the moment that just    seems too much for little benefit.  */
end_comment

begin_function
name|void
name|sh64_adjust_symtab
parameter_list|(
name|void
parameter_list|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
block|{
name|symbolS
modifier|*
name|main_symbol
init|=
operator|*
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
decl_stmt|;
if|if
condition|(
name|main_symbol
condition|)
block|{
name|char
modifier|*
name|sym_name
init|=
operator|(
name|char
operator|*
operator|)
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
decl_stmt|;
comment|/* All datalabels not used in relocs should be gone by now.  	     We change those remaining to have the name of the main 	     symbol, and we set the ELF type of the symbol of the reloc to 	     STT_DATALABEL.  */
name|sym_name
index|[
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|-
name|strlen
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|STT_DATALABEL
expr_stmt|;
comment|/* Also set this symbol to "undefined", so we'll have only one 	     definition.  */
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
name|STO_SH5_ISA32
condition|)
block|{
comment|/* It's important to change the BFD symbol value, since it is now 	     set to the GAS symbolS value.  */
name|symp
operator|->
name|bsym
operator|->
name|value
operator|--
expr_stmt|;
comment|/* Note that we do *not* adjust symp->sy_value.X_add_number.  If 	     you do this, the test case in sh/sh64/immexpr2.s will fail. 	     This is because *after* symbols have been output but before 	     relocs are output, fixups are inspected one more time, and 	     some leftover expressions are resolved.  To resolve to the 	     same values, those expressions must have the same GAS symbol 	     values before as after symbols have been output.  We could 	     "symp->sy_value.X_add_number++" on the STO_SH5_ISA32 symbols 	     through tc_frob_file after symbols have been output, but that 	     would be too gross.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fill-in an allocated arelent.  */
end_comment

begin_function
specifier|static
name|int
name|shmedia_init_reloc
parameter_list|(
name|arelent
modifier|*
name|rel
parameter_list|,
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* Adjust parts of *relp according to *fixp, and tell that it has been      done, so default initializations will not happen.   */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMMU5
case|:
case|case
name|BFD_RELOC_SH_IMMU6
case|:
case|case
name|BFD_RELOC_SH_IMMS6
case|:
case|case
name|BFD_RELOC_SH_IMMS10
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY2
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY4
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY8
case|:
case|case
name|BFD_RELOC_SH_IMMS16
case|:
case|case
name|BFD_RELOC_SH_IMMU16
case|:
case|case
name|BFD_RELOC_SH_PT_16
case|:
case|case
name|BFD_RELOC_SH_GOT_LOW16
case|:
case|case
name|BFD_RELOC_SH_GOT_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_GOT_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_GOT_HI16
case|:
case|case
name|BFD_RELOC_SH_GOT10BY4
case|:
case|case
name|BFD_RELOC_SH_GOT10BY8
case|:
case|case
name|BFD_RELOC_SH_GOTPLT_LOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPLT_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPLT_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_GOTPLT_HI16
case|:
case|case
name|BFD_RELOC_SH_GOTPLT10BY4
case|:
case|case
name|BFD_RELOC_SH_GOTPLT10BY8
case|:
case|case
name|BFD_RELOC_SH_GOTOFF_LOW16
case|:
case|case
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_GOTOFF_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_GOTOFF_HI16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_LOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_HI16
case|:
case|case
name|BFD_RELOC_SH_PLT_LOW16
case|:
case|case
name|BFD_RELOC_SH_PLT_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_PLT_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_PLT_HI16
case|:
name|rel
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
operator|+
name|fixP
operator|->
name|fx_offset
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BFD_RELOC_SH_IMMS6BY32
case|:
comment|/* This must be resolved in assembly; we do not support it as a 	 reloc in an object file.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"This operand must be constant at assembly time"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* There are valid cases where we get here for other than SHmedia 	 relocs, so don't make a BAD_CASE out of this.  */
default|default:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Hook called from md_apply_fix in tc-sh.c.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valp
parameter_list|)
block|{
name|offsetT
name|val
init|=
operator|*
name|valp
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|unsigned
name|long
name|insn
init|=
name|target_big_endian
condition|?
name|bfd_getb32
argument_list|(
name|buf
argument_list|)
else|:
name|bfd_getl32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|bfd_reloc_code_real_type
name|orig_fx_r_type
init|=
name|fixP
operator|->
name|fx_r_type
decl_stmt|;
comment|/* Change a 64-bit pc-relative reloc into the correct type, just like      tc-sh.c:md_apply_fix.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|orig_fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
comment|/* Because write.c calls MD_PCREL_FROM_SECTION twice, we need to 	     undo one of the adjustments, if the relocation is not 	     actually for a symbol within the same segment (which we 	     cannot check, because we're not called from md_apply_fix, so 	     we have to keep the reloc).  FIXME: This is a bug in 	     write.c:fixup_segment affecting most targets that change 	     ordinary relocs to pcrel relocs in md_apply_fix.  */
name|fixP
operator|->
name|fx_offset
operator|=
operator|*
name|valp
operator|+
name|SHMEDIA_MD_PCREL_FROM_FIX
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PLT_LOW16
case|:
case|case
name|BFD_RELOC_SH_PLT_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_PLT_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_PLT_HI16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_LOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_GOTPC_HI16
case|:
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
empty_stmt|;
block|}
comment|/* We might need to change some relocs into the corresponding 	 PC-relative one.  */
switch|switch
condition|(
name|orig_fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_64
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_IMM_LOW16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_IMM_HI16_PCREL
expr_stmt|;
break|break;
case|case
name|SHMEDIA_BFD_RELOC_PT
case|:
comment|/* This is how we see a difference between PT and PTA when not 	     expanding (in which case we handle it in 	     shmedia_md_convert_frag).  Note that we don't see a 	     difference after the reloc is emitted.  */
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_SH_PT_16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PT_16
case|:
comment|/* This tells us there was a PTA or PTB insn explicitly 	     expressed as such (not as PT).  We "or" in a 1 into the 	     lowest bit in the (unused) destination field to tell the 	     linker that it should check the right ISA type of the 	     destination and not just change a PTA to PTB (if necessary).  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16_PCREL
case|:
comment|/* Already handled.  */
break|break;
default|default:
comment|/* Everything else that changes into a pc-relative relocation is 	     an error.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid operand expression"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|/* If an expression looked like it was PC-relative, but was completely      resolvable, we end up here with the result only in *VALP, and no      relocation will be emitted.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
block|{
comment|/* Emit error for an out-of-range value.  */
name|shmedia_check_limits
argument_list|(
operator|(
name|offsetT
operator|*
operator|)
name|valp
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
call|(
name|valueT
call|)
argument_list|(
name|val
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|65535
operator|<<
literal|16
operator|)
argument_list|)
operator|>>
operator|(
literal|16
operator|-
literal|10
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
call|(
name|valueT
call|)
argument_list|(
name|val
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|65535
operator|<<
literal|32
operator|)
argument_list|)
operator|>>
operator|(
literal|32
operator|-
literal|10
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
call|(
name|valueT
call|)
argument_list|(
name|val
operator|&
operator|(
operator|(
name|valueT
operator|)
literal|65535
operator|<<
literal|48
operator|)
argument_list|)
operator|>>
operator|(
literal|48
operator|-
literal|10
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS16
case|:
case|case
name|BFD_RELOC_SH_IMMU16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
literal|0x3ff
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY2
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
operator|(
literal|0x3ff
operator|<<
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|10
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY4
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
operator|(
literal|0x3ff
operator|<<
literal|2
operator|)
operator|)
operator|<<
operator|(
literal|10
operator|-
literal|2
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY8
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
operator|(
literal|0x3ff
operator|<<
literal|3
operator|)
operator|)
operator|<<
operator|(
literal|10
operator|-
literal|3
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_SHMEDIA_CODE
case|:
comment|/* We just ignore and remove this one for the moment.  FIXME: 	     Use it when implementing relaxing.  */
break|break;
case|case
name|BFD_RELOC_64
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHMEDIA_BFD_RELOC_PT
case|:
comment|/* Change a PT to PTB if the operand turned out to be SHcompact. 	     The basic opcode specified with PT is equivalent to PTA.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|insn
operator||=
name|SHMEDIA_PTB_BIT
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_SH_PT_16
case|:
if|if
condition|(
operator|!
name|sh64_expand
operator|||
name|sh_relax
condition|)
block|{
comment|/* Check if the operand of a PTA or PTB was for the "wrong" 		 ISA.  A PT had an incoming fixup of SHMEDIA_BFD_RELOC_PT, 		 which we have changed to the right type above.  */
if|if
condition|(
name|orig_fx_r_type
operator|!=
name|SHMEDIA_BFD_RELOC_PT
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"PTB operand is a SHmedia symbol"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"PTA operand is a SHcompact symbol"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator||
operator|(
operator|(
name|val
operator|&
operator|(
literal|0xffff
operator|<<
literal|2
operator|)
operator|)
operator|<<
operator|(
literal|10
operator|-
literal|2
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
comment|/* This isn't a BAD_CASE, because presumably we can get here 	     from unexpected operands.  Since we don't handle them, make 	     them syntax errors.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid expression in operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hook called from md_convert_frag in tc-sh.c.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|bfd_boolean
name|final
parameter_list|)
block|{
comment|/* Pointer to first byte in variable-sized part of the frag.	*/
name|char
modifier|*
name|var_partp
decl_stmt|;
comment|/* Pointer to first opcode byte in frag.  */
name|char
modifier|*
name|opcodep
decl_stmt|;
comment|/* Pointer to frag of opcode.  */
name|fragS
modifier|*
name|opc_fragP
init|=
name|fragP
operator|->
name|tc_frag_data
operator|.
name|opc_frag
decl_stmt|;
comment|/* Size in bytes of variable-sized part of frag.  */
name|int
name|var_part_size
init|=
literal|0
decl_stmt|;
comment|/* This is part of *fragP.  It contains all information about addresses      and offsets to varying parts.  */
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
name|bfd_boolean
name|reloc_needed
init|=
operator|(
operator|!
name|final
operator|||
name|sh_relax
operator|||
name|symbolP
operator|==
name|NULL
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|seg
operator|)
operator|)
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloctype
init|=
name|BFD_RELOC_NONE
decl_stmt|;
name|unsigned
name|long
name|var_part_offset
decl_stmt|;
comment|/* Where, in file space, does addr point?  */
name|bfd_vma
name|target_address
decl_stmt|;
name|bfd_vma
name|opcode_address
decl_stmt|;
comment|/* What was the insn?  */
name|unsigned
name|long
name|insn
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|var_part_offset
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|var_partp
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|var_part_offset
expr_stmt|;
name|opcodep
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|insn
operator|=
name|target_big_endian
condition|?
name|bfd_getb32
argument_list|(
name|opcodep
argument_list|)
else|:
name|bfd_getl32
argument_list|(
name|opcodep
argument_list|)
expr_stmt|;
name|target_address
operator|=
operator|(
operator|(
name|symbolP
operator|&&
name|final
operator|&&
operator|!
name|sh_relax
condition|?
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
else|:
literal|0
operator|)
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
expr_stmt|;
comment|/* The opcode that would be extended is the last four "fixed" bytes.  */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
literal|4
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
comment|/* We can get a PT to a relaxed SHcompact address if it is in the 	 same section; a mixed-ISA section.  Change the opcode to PTB if 	 so.  */
if|if
condition|(
operator|(
name|target_address
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|insn
operator||=
name|SHMEDIA_PTB_BIT
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
comment|/* Check that a PTA or PTB points to the right type of target.  We 	 can get here for a SHcompact target if we are in a mixed-ISA 	 section.  */
if|if
condition|(
operator|(
operator|(
name|target_address
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|==
literal|0
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"PTA operand is a SHcompact symbol"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|target_address
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"PTB operand is a SHmedia symbol"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When relaxing, we do not output the address in the insn, but 	 instead a 1 into the low bit.  This matches what the linker 	 expects to find for a BFD_RELOC_SH_PT_16 reloc, when it checks 	 correctness for PTA/PTB insn; used when the target address is 	 unknown (which is not the case here).  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|sh_relax
condition|?
literal|1
else|:
operator|(
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|/
literal|4
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Note that we do not emit info that this was originally a PT since 	 we have resolved to which one of PTA or PTB it will be.  */
if|if
condition|(
name|sh_relax
condition|)
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PT_16
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through */
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
comment|/* In the fixed bit, put in a MOVI.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SHMEDIA_MOVI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|8
operator|)
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Fill in a SHORI for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|8
operator|)
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* End with a "PTREL R25,TRd".  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_PTREL_OPC
operator||
operator|(
name|insn
operator|&
name|SHMEDIA_LIKELY_BIT
operator|)
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|10
operator|)
operator||
operator|(
name|insn
operator|&
operator|(
literal|7
operator|<<
literal|4
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We need relocs only if the target symbol was undefined or if 	 we're relaxing.  */
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|8
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|4
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
name|BFD_RELOC_SH_IMM_LOW16_PCREL
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL48
argument_list|)
case|:
comment|/* In the fixed bit, put in a MOVI.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SHMEDIA_MOVI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|12
operator|)
operator|)
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* The first SHORI, for the medium part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|12
operator|)
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Fill in a SHORI for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|12
operator|)
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* End with a "PTREL R25,TRd".  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|8
argument_list|,
name|SHMEDIA_PTREL_OPC
operator||
operator|(
name|insn
operator|&
name|SHMEDIA_LIKELY_BIT
operator|)
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|10
operator|)
operator||
operator|(
name|insn
operator|&
operator|(
literal|7
operator|<<
literal|4
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We need relocs only if the target symbol was undefined or if 	 we're relaxing.  */
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|12
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDHI16
else|:
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|8
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|4
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
name|BFD_RELOC_SH_IMM_LOW16_PCREL
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through */
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL64
argument_list|)
case|:
comment|/* In the fixed bit, put in a MOVI.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SHMEDIA_MOVI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|16
operator|)
operator|)
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* The first SHORI, for the medium-high part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|16
operator|)
operator|)
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the medium-low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|16
operator|)
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Fill in a SHORI for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|8
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
operator|(
name|opcode_address
operator|+
literal|16
operator|)
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* End with a "PTREL R25,TRd".  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|12
argument_list|,
name|SHMEDIA_PTREL_OPC
operator||
operator|(
name|insn
operator|&
name|SHMEDIA_LIKELY_BIT
operator|)
operator||
operator|(
name|SHMEDIA_TEMP_REG
operator|<<
literal|10
operator|)
operator||
operator|(
name|insn
operator|&
operator|(
literal|7
operator|<<
literal|4
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We need relocs only if the target symbol was undefined or if 	 we're relaxing.  */
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|16
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_HI16
else|:
name|BFD_RELOC_SH_IMM_HI16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|12
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDHI16
else|:
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|8
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|-
literal|4
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
name|BFD_RELOC_SH_IMM_LOW16_PCREL
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_GOTOFF
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_GOTOFF
expr_stmt|;
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|UNDEF_MOVI
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_64
argument_list|)
case|:
block|{
comment|/* We only get here for undefined symbols, so we can simplify 	   handling compared to those above; we have 0 in the parts that 	   will be filled with the symbol parts.  */
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* In the fixed bit, put in a MOVI.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SHMEDIA_MOVI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_HI16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_HI16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_HI16
operator|)
argument_list|)
expr_stmt|;
comment|/* The first SHORI, for the medium-high part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDHI16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_MEDHI16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDHI16
operator|)
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the medium-low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDLOW16
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill in a SHORI for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|8
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_LOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_LOW16
operator|)
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|12
expr_stmt|;
break|break;
block|}
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_GOTOFF
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_GOTOFF
expr_stmt|;
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|UNDEF_MOVI
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_32
argument_list|)
case|:
block|{
comment|/* Note that we only get here for undefined symbols.  */
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* A MOVI, for the high part.  */
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|SHMEDIA_MOVI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDLOW16
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill in a SHORI for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|?
name|BFD_RELOC_SH_GOTOFF_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_LOW16
operator|)
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_16
argument_list|)
case|:
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_needed
condition|)
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_IMM_LOW16_PCREL
argument_list|)
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_16
argument_list|)
case|:
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
name|target_address
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|var_part_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_PLT
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
goto|goto
name|movi_imm_32_pcrel_reloc_needed
goto|;
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_GOTPC
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_SH_GOTPC
expr_stmt|;
comment|/* Fall through.  */
name|movi_imm_32_pcrel_reloc_needed
label|:
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_32
argument_list|)
case|:
block|{
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
operator|)
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|4
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_LOW16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_LOW16_PCREL
operator|)
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_48
argument_list|)
case|:
block|{
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the medium part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|4
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|8
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_IMM_LOW16_PCREL
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|8
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_PLT
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
goto|goto
name|movi_imm_64_pcrel_reloc_needed
goto|;
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_GOTPC
argument_list|)
case|:
name|reloctype
operator|=
name|BFD_RELOC_SH_GOTPC
expr_stmt|;
comment|/* Fall through.  */
name|movi_imm_64_pcrel_reloc_needed
label|:
name|reloc_needed
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_64
argument_list|)
case|:
block|{
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|opcodep
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the medium-high part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the medium-low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A SHORI, for the low part.  */
name|md_number_to_chars
argument_list|(
name|var_partp
operator|+
literal|8
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|reloc_needed
condition|?
literal|0
else|:
operator|(
name|target_address
operator|-
name|opcode_address
operator|)
operator|)
operator|&
literal|65535
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_needed
condition|)
block|{
name|fix_new
argument_list|(
name|opc_fragP
argument_list|,
name|opcodep
operator|-
name|opc_fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_HI16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_HI16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_HI16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_HI16_PCREL
operator|)
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|4
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_MEDHI16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDHI16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
operator|)
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|8
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_MEDLOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_MEDLOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
operator|)
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|var_partp
operator|-
name|fragP
operator|->
name|fr_literal
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|12
argument_list|,
literal|1
argument_list|,
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_IMM_LOW16_PCREL
else|:
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|?
name|BFD_RELOC_SH_GOTPC_LOW16
else|:
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|?
name|BFD_RELOC_SH_PLT_LOW16
else|:
operator|(
name|abort
argument_list|()
operator|,
name|BFD_RELOC_SH_IMM_LOW16_PCREL
operator|)
argument_list|)
expr_stmt|;
block|}
name|var_part_size
operator|=
literal|12
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|var_part_size
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mask NUMBER (originating from a signed number) corresponding to the HOW    reloc.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|shmedia_mask_number
parameter_list|(
name|unsigned
name|long
name|number
parameter_list|,
name|bfd_reloc_code_real_type
name|how
parameter_list|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMMU5
case|:
name|number
operator|&=
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS6
case|:
case|case
name|BFD_RELOC_SH_IMMU6
case|:
name|number
operator|&=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS6BY32
case|:
name|number
operator|=
operator|(
name|number
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|6
operator|+
literal|5
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|5
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10
case|:
name|number
operator|&=
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY2
case|:
name|number
operator|=
operator|(
name|number
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|10
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY4
case|:
name|number
operator|=
operator|(
name|number
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|10
operator|+
literal|2
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY8
case|:
name|number
operator|=
operator|(
name|number
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|10
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS16
case|:
case|case
name|BFD_RELOC_SH_IMMU16
case|:
name|number
operator|&=
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|how
argument_list|)
expr_stmt|;
block|}
return|return
name|number
return|;
block|}
end_function

begin_comment
comment|/* Emit errors for values out-of-range, using as_bad_where if FRAGP is    non-NULL, as_bad otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_check_limits
parameter_list|(
name|offsetT
modifier|*
name|valp
parameter_list|,
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|offsetT
name|val
init|=
operator|*
name|valp
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMMU5
case|:
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 5-bit unsigned value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS6
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 6-bit signed value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMU6
case|:
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 6-bit unsigned value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS6BY32
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 11-bit signed value: %d"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&
literal|31
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a multiple of 32: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 10-bit signed value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY2
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 11-bit signed value: %d"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not an even value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY4
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 12-bit signed value: %d"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&
literal|3
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a multiple of 4: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS10BY8
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 13-bit signed value: %d"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&
literal|7
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a multiple of 8: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMS16
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not a 16-bit signed value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMMU16
case|:
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"invalid operand, not an 16-bit unsigned value: %d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PT_16
case|:
case|case
name|SHMEDIA_BFD_RELOC_PT
case|:
if|if
condition|(
name|val
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|*
literal|4
operator|||
name|val
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
literal|1
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"operand out of range for PT, PTA and PTB"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|%
literal|4
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|val
operator|-
literal|1
operator|)
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"operand not a multiple of 4 for PT, PTA or PTB: %d"
argument_list|)
expr_stmt|;
break|break;
comment|/* These have no limits; they take a 16-bit slice of a 32- or 64-bit 	 number.  */
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_SHMEDIA_CODE
case|:
break|break;
comment|/* This one has limits out of our reach.  */
case|case
name|BFD_RELOC_64
case|:
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
condition|)
block|{
if|if
condition|(
name|fixp
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|msg
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|msg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle an immediate operand by checking limits and noting it for later    evaluation if not computable yet, and return a bitfield suitable to    "or" into the opcode (non-zero if the value was a constant number).  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|shmedia_immediate_op
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|shmedia_operand_info
modifier|*
name|op
parameter_list|,
name|int
name|pcrel
parameter_list|,
name|bfd_reloc_code_real_type
name|how
parameter_list|)
block|{
name|unsigned
name|long
name|retval
init|=
literal|0
decl_stmt|;
comment|/* If this is not an absolute number, make it a fixup.  A constant in      place of a pc-relative operand also needs a fixup.  */
if|if
condition|(
name|op
operator|->
name|immediate
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|pcrel
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|op
operator|->
name|immediate
argument_list|,
name|pcrel
argument_list|,
name|how
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check that the number is within limits as represented by the 	 reloc, and return the number.  */
name|shmedia_check_limits
argument_list|(
operator|&
name|op
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
name|how
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|shmedia_mask_number
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|op
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
operator|<<
literal|10
return|;
block|}
end_function

begin_comment
comment|/* Try and parse a register name case-insensitively, return the number of    chars consumed.  */
end_comment

begin_function
specifier|static
name|int
name|shmedia_parse_reg
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|,
name|int
modifier|*
name|reg
parameter_list|,
name|shmedia_arg_type
name|argtype
parameter_list|)
block|{
name|int
name|l0
init|=
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|l1
init|=
name|l0
condition|?
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|l0
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_GREG_M
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'3'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_GREG_M
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_GREG_M
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'t'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'7'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_TREG_B
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'3'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FREG_G
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'v'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|4
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FVREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|==
literal|'0'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FVREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|4
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FVREG_G
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'d'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
operator|(
name|src
index|[
literal|3
index|]
operator|==
literal|'0'
operator|||
name|src
index|[
literal|3
index|]
operator|==
literal|'2'
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DREG_G
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FPREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
operator|(
name|src
index|[
literal|3
index|]
operator|==
literal|'0'
operator|||
name|src
index|[
literal|3
index|]
operator|==
literal|'2'
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FPREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|(
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FPREG_G
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'m'
operator|&&
name|strncasecmp
argument_list|(
name|src
argument_list|,
literal|"mtrx"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|4
index|]
operator|==
literal|'0'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FMREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|0
expr_stmt|;
return|return
literal|5
return|;
block|}
if|if
condition|(
name|src
index|[
literal|4
index|]
operator|==
literal|'1'
operator|&&
name|src
index|[
literal|5
index|]
operator|==
literal|'6'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FMREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|16
expr_stmt|;
return|return
literal|6
return|;
block|}
if|if
condition|(
name|src
index|[
literal|4
index|]
operator|==
literal|'3'
operator|&&
name|src
index|[
literal|5
index|]
operator|==
literal|'2'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FMREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|32
expr_stmt|;
return|return
literal|6
return|;
block|}
if|if
condition|(
name|src
index|[
literal|4
index|]
operator|==
literal|'4'
operator|&&
name|src
index|[
literal|5
index|]
operator|==
literal|'8'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_FMREG_G
expr_stmt|;
operator|*
name|reg
operator|=
literal|48
expr_stmt|;
return|return
literal|6
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'c'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'1'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_CREG_K
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|*
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'3'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_CREG_K
expr_stmt|;
operator|*
name|reg
operator|=
literal|60
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_CREG_K
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
comment|/* We either have an error, a symbol or a control register by predefined      name.  To keep things simple but still fast for normal cases, we do      linear search in the (not to big) table of predefined control      registers.  We only do this when we *expect* a control register.      Those instructions should be rare enough that linear searching is ok.      Or just read them into a hash-table in shmedia_md_begin.  Since they      cannot be specified in the same place of symbol operands, don't add      them there to the *main* symbol table as being in "reg_section".  */
if|if
condition|(
name|argtype
operator|==
name|A_CREG_J
operator|||
name|argtype
operator|==
name|A_CREG_K
condition|)
block|{
specifier|const
name|shmedia_creg_info
modifier|*
name|cregp
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cregp
operator|=
name|shmedia_creg_table
init|;
name|cregp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cregp
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cregp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|cregp
operator|->
name|name
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
name|src
index|[
name|len
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cregp
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mode
operator|=
name|A_CREG_K
expr_stmt|;
operator|*
name|reg
operator|=
name|cregp
operator|->
name|cregno
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from md_estimate_size_before_relax in tc-sh.c  */
end_comment

begin_function
specifier|static
name|int
name|shmedia_md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|old_fr_fix
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
comment|/* For ELF, we can't relax externally visible symbols; see tc-i386.c.  */
name|bfd_boolean
name|sym_relaxable
init|=
operator|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|UNDEF_SH64PCREL
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|UNDEF_SH64PCREL
argument_list|)
case|:
comment|/* Used to be to somewhere which was unknown.  */
if|if
condition|(
name|sym_relaxable
condition|)
block|{
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
comment|/* In this segment, so head for shortest.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|SH64PCREL16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
comment|/* We know the abs value, but we don't know where we will be 	     linked, so we must make it the longest.  Presumably we could 	     switch to a non-pcrel representation, but having absolute 	     values in PT operands should be rare enough not to be worth 	     adding that code.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|SH64PCREL32
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|UNDEF_SH64PCREL
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|UNDEF_SH64PCREL
argument_list|)
case|:
comment|/* Used to be to somewhere which was unknown.  */
if|if
condition|(
name|sym_relaxable
condition|)
block|{
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
comment|/* In this segment, so head for shortest.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|SH64PCREL16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
comment|/* We know the abs value, but we don't know where we will be 	     linked, so we must make it the longest.  Presumably we could 	     switch to a non-pcrel representation, but having absolute 	     values in PT operands should be rare enough not to be worth 	     adding that code.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|SH64PCREL64
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|UNDEF_MOVI
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|UNDEF_MOVI
argument_list|)
case|:
name|exp
operator|=
name|NULL
expr_stmt|;
comment|/* Look inside the "symbol".  If we find a PC-relative expression, 	 change this to a PC-relative, relaxable expression.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|&&
operator|(
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
name|int
name|what_high
init|=
name|what
operator|==
name|MOVI_IMM_32
condition|?
name|MOVI_32
else|:
name|MOVI_64
decl_stmt|;
name|expressionS
modifier|*
name|opexp
init|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
decl_stmt|;
name|expressionS
modifier|*
name|addexp
init|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
decl_stmt|;
comment|/* Change the MOVI expression to the "X" in "X - Y" and subtract 	     Y:s offset to this location from X.  Note that we can only 	     allow an Y which is offset from this frag.  */
if|if
condition|(
name|opexp
operator|!=
name|NULL
operator|&&
name|addexp
operator|!=
name|NULL
operator|&&
name|opexp
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|fragP
operator|==
name|symbol_get_frag
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
condition|)
block|{
comment|/* At this point, before relaxing, the add-number of opexp 		 is the offset from the fr_fix part.  */
name|fragP
operator|->
name|fr_offset
operator|=
operator|(
name|exp
operator|->
name|X_add_number
operator|-
operator|(
name|opexp
operator|->
name|X_add_number
operator|-
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_symbol
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|what
operator|=
name|what
operator|==
name|MOVI_IMM_32
condition|?
name|MOVI_IMM_32_PCREL
else|:
name|MOVI_IMM_64_PCREL
expr_stmt|;
comment|/* Check the "X" symbol to estimate the size of this 		 PC-relative expression.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|segment_type
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|MOVI_16
argument_list|)
expr_stmt|;
else|else
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|what_high
argument_list|)
expr_stmt|;
comment|/* This is now a PC-relative expression, fit to be relaxed.  */
block|}
else|else
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|what_high
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|absolute_section
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_constant
operator|)
condition|)
block|{
name|unsigned
name|long
name|insn
init|=
operator|(
name|target_big_endian
condition|?
name|bfd_getb32
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|)
else|:
name|bfd_getl32
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|)
operator|)
decl_stmt|;
name|offsetT
name|one
init|=
operator|(
name|offsetT
operator|)
literal|1
decl_stmt|;
name|offsetT
name|value
init|=
name|fragP
operator|->
name|fr_offset
operator|+
operator|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|?
literal|0
else|:
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|value
operator|>=
operator|(
operator|(
name|offsetT
operator|)
operator|-
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|value
operator|<
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
comment|/* Fits in 16-bit signed number.  */
name|int
name|what
init|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|MOVI_16
argument_list|)
expr_stmt|;
comment|/* Just "or" in the value.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|insn
operator||
operator|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|>=
operator|-
operator|(
name|one
operator|<<
literal|31
operator|)
operator|&&
operator|(
name|value
operator|<
operator|(
name|one
operator|<<
literal|31
operator|)
operator|||
operator|(
name|sh64_abi
operator|==
name|sh64_abi_32
operator|&&
name|value
operator|<
operator|(
name|one
operator|<<
literal|32
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* The value fits in a 32-bit signed number.  */
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Just "or" in the high bits of the value, making the first 		 MOVI.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the low bits.  Note that this insn lives 		 in the variable fragment part.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We took a piece of the variable part.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|MOVI_IMM_32
condition|)
block|{
comment|/* Value out of range.  */
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"MOVI operand is not a 32-bit signed value: 0x%8x%08x"
argument_list|)
argument_list|,
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0xffffffff
operator|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Must advance size, or we will get internal inconsistency 		 and fall into an assert.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Now we know we are allowed to expand to 48- and 64-bit values.  */
elseif|else
if|if
condition|(
name|value
operator|>=
operator|-
operator|(
name|one
operator|<<
literal|47
operator|)
operator|&&
name|value
operator|<
operator|(
name|one
operator|<<
literal|47
operator|)
condition|)
block|{
comment|/* The value fits in a 48-bit signed number.  */
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Just "or" in the high bits of the value, making the first 		 MOVI.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|32
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the middle bits.  Note that this insn lives 		 in the variable fragment part.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the low bits.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We took a piece of the variable part.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* A 64-bit number.  */
name|int
name|reg
init|=
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Just "or" in the high bits of the value, making the first 		 MOVI.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|insn
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|48
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the midhigh bits.  Note that this insn lives 		 in the variable fragment part.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|32
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the midlow bits.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
operator|+
literal|4
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Add a SHORI with the low bits.  */
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
operator|+
literal|8
argument_list|,
name|SHMEDIA_SHORI_OPC
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|10
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We took all of the variable part.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* MOVI expansions that get here have not been converted to 	     PC-relative frags, but instead expanded by 	     md_number_to_chars or by calling shmedia_md_convert_frag 	     with final == FALSE.  We must not have them around as 	     frags anymore; symbols would be prematurely evaluated 	     when relaxing.  We will not need to have md_convert_frag 	     called again with them; any further handling is through 	     the already emitted fixups.  */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
comment|/* For relaxation states that remain unchanged, report the          estimated length.  */
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_32
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_32
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCREL64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCREL64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16_64
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|SH64PCREL16PT_64
argument_list|,
name|SH64PCRELPLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32
argument_list|,
name|MOVI_GOTOFF
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_PLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_32_PCREL
argument_list|,
name|MOVI_GOTPC
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64
argument_list|,
name|MOVI_GOTOFF
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_16
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_48
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_64
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_PLT
argument_list|)
case|:
case|case
name|C
argument_list|(
name|MOVI_IMM_64_PCREL
argument_list|,
name|MOVI_GOTPC
argument_list|)
case|:
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|fragP
operator|->
name|fr_var
operator|+
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression, SH64-style.  Copied from tc-sh.c, but with    datatypes adjusted.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|shmedia_parse_exp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|shmedia_operand_info
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|op
operator|->
name|immediate
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|immediate
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand.  Store pointer to next character in *PTR.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_get_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|shmedia_operand_info
modifier|*
name|op
parameter_list|,
name|shmedia_arg_type
name|argtype
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|mode
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|shmedia_parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
operator|+
name|len
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a reg, so it must be a displacement.  */
operator|*
name|ptr
operator|=
name|shmedia_parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_IMMM
expr_stmt|;
comment|/* This is just an initialization; shmedia_get_operands will change 	 as needed.  */
name|op
operator|->
name|reloctype
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the operands for this insn; return NULL if invalid, else return    how much text was consumed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|shmedia_get_operands
parameter_list|(
name|shmedia_opcode_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|shmedia_operands_info
modifier|*
name|operands
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|arg
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
name|operands
operator|->
name|operands
operator|+
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|operands
operator|->
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No operand to get for these fields.  */
if|if
condition|(
name|info
operator|->
name|arg
index|[
name|i
index|]
operator|==
name|A_REUSE_PREV
condition|)
continue|continue;
name|shmedia_get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|operands
operator|->
name|operands
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Check operands type match.  */
switch|switch
condition|(
name|info
operator|->
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
name|A_GREG_M
case|:
case|case
name|A_GREG_N
case|:
case|case
name|A_GREG_D
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_GREG_M
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_FREG_G
case|:
case|case
name|A_FREG_H
case|:
case|case
name|A_FREG_F
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_FREG_G
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_FVREG_G
case|:
case|case
name|A_FVREG_H
case|:
case|case
name|A_FVREG_F
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_FVREG_G
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_FMREG_G
case|:
case|case
name|A_FMREG_H
case|:
case|case
name|A_FMREG_F
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_FMREG_G
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_FPREG_G
case|:
case|case
name|A_FPREG_H
case|:
case|case
name|A_FPREG_F
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_FPREG_G
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_DREG_G
case|:
case|case
name|A_DREG_H
case|:
case|case
name|A_DREG_F
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_DREG_G
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_TREG_A
case|:
case|case
name|A_TREG_B
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_TREG_B
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_CREG_J
case|:
case|case
name|A_CREG_K
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_CREG_K
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|A_IMMS16
case|:
case|case
name|A_IMMU16
case|:
comment|/* Check for an expression that looks like S& 65535 or 	     (S>> N)& 65535, where N = 0, 16, 32, 48.  	     Get the S and put at operands->operands[i].immediate, and 	     adjust operands->operands[i].reloctype.  */
block|{
name|expressionS
modifier|*
name|imm_expr
init|=
operator|&
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
decl_stmt|;
name|expressionS
modifier|*
name|right_expr
decl_stmt|;
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|==
name|A_IMMM
operator|&&
name|imm_expr
operator|->
name|X_op
operator|==
name|O_bit_and
operator|&&
name|imm_expr
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|right_expr
operator|=
name|symbol_get_value_expression
argument_list|(
name|imm_expr
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|->
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
name|right_expr
operator|->
name|X_add_number
operator|==
literal|0xffff
condition|)
block|{
name|symbolS
modifier|*
name|inner
init|=
name|imm_expr
operator|->
name|X_add_symbol
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloctype
init|=
name|BFD_RELOC_SH_IMM_LOW16
decl_stmt|;
name|expressionS
modifier|*
name|inner_expr
init|=
name|symbol_get_value_expression
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner_expr
operator|->
name|X_op
operator|==
name|O_right_shift
condition|)
block|{
name|expressionS
modifier|*
name|inner_right
decl_stmt|;
if|if
condition|(
name|inner_expr
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|inner_right
operator|=
name|symbol_get_value_expression
argument_list|(
name|inner_expr
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|->
name|X_op
operator|==
name|O_constant
operator|)
condition|)
block|{
name|offsetT
name|addnum
init|=
name|inner_right
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|addnum
operator|==
literal|0
operator|||
name|addnum
operator|==
literal|16
operator|||
name|addnum
operator|==
literal|32
operator|||
name|addnum
operator|==
literal|48
condition|)
block|{
name|reloctype
operator|=
operator|(
name|addnum
operator|==
literal|0
condition|?
name|BFD_RELOC_SH_IMM_LOW16
else|:
operator|(
name|addnum
operator|==
literal|16
condition|?
name|BFD_RELOC_SH_IMM_MEDLOW16
else|:
operator|(
name|addnum
operator|==
literal|32
condition|?
name|BFD_RELOC_SH_IMM_MEDHI16
else|:
name|BFD_RELOC_SH_IMM_HI16
operator|)
operator|)
operator|)
expr_stmt|;
name|inner
operator|=
name|inner_expr
operator|->
name|X_add_symbol
expr_stmt|;
name|inner_expr
operator|=
name|symbol_get_value_expression
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* I'm not sure I understand the logic, but evidently the 		   inner expression of a lone symbol is O_constant, with 		   the actual symbol in expr_section.  For a constant, the 		   section would be absolute_section.  For sym+offset, 		   it's O_symbol as always.  See expr.c:make_expr_symbol, 		   first statements.  */
if|if
condition|(
name|inner_expr
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|inner
argument_list|)
operator|!=
name|absolute_section
condition|)
block|{
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
operator|.
name|X_add_symbol
operator|=
name|inner
expr_stmt|;
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
operator|=
operator|*
name|symbol_get_value_expression
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|reloctype
operator|=
name|reloctype
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|A_IMMS6
case|:
case|case
name|A_IMMS6BY32
case|:
case|case
name|A_IMMS10
case|:
case|case
name|A_IMMS10BY1
case|:
case|case
name|A_IMMS10BY2
case|:
case|case
name|A_IMMS10BY4
case|:
case|case
name|A_IMMS10BY8
case|:
case|case
name|A_PCIMMS16BY4
case|:
case|case
name|A_PCIMMS16BY4_PT
case|:
case|case
name|A_IMMU5
case|:
case|case
name|A_IMMU6
case|:
if|if
condition|(
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|A_IMMM
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sh_check_fixup
argument_list|(
operator|&
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|immediate
argument_list|,
operator|&
name|operands
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|reloctype
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid PIC reference"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|info
operator|->
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
operator|&&
name|info
operator|->
name|arg
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Find an opcode at the start of *STR_P in the hash table, and set    *STR_P to the first character after the last one read.  */
end_comment

begin_function
specifier|static
name|shmedia_opcode_info
modifier|*
name|shmedia_find_cooked_opcode
parameter_list|(
name|char
modifier|*
modifier|*
name|str_p
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|int
name|nlen
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|str
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|op_end
index|]
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|op_end
argument_list|)
condition|;
name|op_end
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
name|op_start
index|[
name|nlen
index|]
decl_stmt|;
comment|/* The machine independent code will convert CMP/EQ into cmp/EQ 	 because it thinks the '/' is the end of the symbol.  Moreover, 	 all but the first sub-insn is a parallel processing insn won't 	 be capitalized.  Instead of hacking up the machine independent 	 code, we just deal with it here.  */
name|c
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|name
index|[
name|nlen
index|]
operator|=
name|c
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str_p
operator|=
name|op_end
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|shmedia_opcode_info
operator|*
operator|)
name|hash_find
argument_list|(
name|shmedia_opcode_hash_control
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build up an instruction, including allocating the frag.  */
end_comment

begin_function
specifier|static
name|int
name|shmedia_build_Mytes
parameter_list|(
name|shmedia_opcode_info
modifier|*
name|opcode
parameter_list|,
name|shmedia_operands_info
modifier|*
name|operands
parameter_list|)
block|{
name|unsigned
name|long
name|insn
init|=
name|opcode
operator|->
name|opcode_base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|insn_loc
init|=
name|frag_more
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|/* The parameter to dwarf2_emit_insn is actually the offset to the start      of the insn from the fix piece of instruction that was emitted.      Since we want .debug_line addresses to record (address | 1) for      SHmedia insns, we get the wanted effect by taking one off the size,      knowing it's a multiple of 4.  We count from the first fix piece of      the insn.  There must be no frags changes (frag_more or frag_var)      calls in-between the frag_more call we account for, and this      dwarf2_emit_insn call.  */
name|dwarf2_emit_insn
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* This is stored into any frag_var operand.  */
name|sh64_last_insn_frag
operator|=
name|frag_now
expr_stmt|;
comment|/* Loop over opcode info, emit an instruction.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|opcode
operator|->
name|arg
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|shmedia_arg_type
name|argtype
init|=
name|opcode
operator|->
name|arg
index|[
name|i
index|]
decl_stmt|;
name|shmedia_operand_info
modifier|*
name|opjp
init|=
operator|&
name|operands
operator|->
name|operands
index|[
name|j
index|]
decl_stmt|;
switch|switch
condition|(
name|argtype
condition|)
block|{
case|case
name|A_TREG_A
case|:
case|case
name|A_TREG_B
case|:
case|case
name|A_GREG_M
case|:
case|case
name|A_GREG_N
case|:
case|case
name|A_GREG_D
case|:
case|case
name|A_FREG_G
case|:
case|case
name|A_FREG_H
case|:
case|case
name|A_FREG_F
case|:
case|case
name|A_FVREG_G
case|:
case|case
name|A_FVREG_H
case|:
case|case
name|A_FVREG_F
case|:
case|case
name|A_FMREG_G
case|:
case|case
name|A_FMREG_H
case|:
case|case
name|A_FMREG_F
case|:
case|case
name|A_FPREG_G
case|:
case|case
name|A_FPREG_H
case|:
case|case
name|A_FPREG_F
case|:
case|case
name|A_DREG_G
case|:
case|case
name|A_DREG_H
case|:
case|case
name|A_DREG_F
case|:
case|case
name|A_CREG_J
case|:
case|case
name|A_CREG_K
case|:
comment|/* Six-bit register fields.  They just get filled with the 	     parsed register number.  */
name|insn
operator||=
operator|(
name|opjp
operator|->
name|reg
operator|<<
name|opcode
operator|->
name|nibbles
index|[
name|i
index|]
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_REUSE_PREV
case|:
comment|/* Copy the register for the previous operand to this position.  */
name|insn
operator||=
operator|(
name|operands
operator|->
name|operands
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|reg
operator|<<
name|opcode
operator|->
name|nibbles
index|[
name|i
index|]
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS6
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS6
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS6BY32
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS6BY32
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS10BY1
case|:
case|case
name|A_IMMS10
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS10
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS10BY2
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS10BY2
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS10BY4
case|:
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS10BY4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPLT32
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_GOTPLT10BY4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOT_PCREL
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_GOT10BY4
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid PIC reference"
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS10BY8
case|:
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMS10BY8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPLT32
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_GOTPLT10BY8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOT_PCREL
condition|)
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_GOT10BY8
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid PIC reference"
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMS16
case|:
comment|/* Sneak a peek if this is the MOVI insn.  If so, check if we 	     should expand it.  */
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOT_PCREL
condition|)
name|opjp
operator|->
name|reloctype
operator|=
name|BFD_RELOC_SH_GOT_LOW16
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPLT32
condition|)
name|opjp
operator|->
name|reloctype
operator|=
name|BFD_RELOC_SH_GOTPLT_LOW16
expr_stmt|;
if|if
condition|(
operator|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
operator|)
operator|&&
name|opcode
operator|->
name|opcode_base
operator|==
name|SHMEDIA_MOVI_OPC
operator|&&
operator|(
name|opjp
operator|->
name|immediate
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|opjp
operator|->
name|immediate
operator|.
name|X_add_number
operator|<
operator|-
literal|32768
operator|||
name|opjp
operator|->
name|immediate
operator|.
name|X_add_number
operator|>
literal|32767
operator|)
operator|&&
operator|(
name|sh64_expand
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
operator|||
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
operator|)
condition|)
block|{
name|int
name|what
init|=
name|sh64_abi
operator|==
name|sh64_abi_64
condition|?
name|MOVI_IMM_64
else|:
name|MOVI_IMM_32
decl_stmt|;
name|offsetT
name|max
init|=
name|sh64_abi
operator|==
name|sh64_abi_64
condition|?
name|MOVI_64
else|:
name|MOVI_32
decl_stmt|;
name|offsetT
name|min
init|=
name|MOVI_16
decl_stmt|;
name|offsetT
name|init
init|=
name|UNDEF_MOVI
decl_stmt|;
name|valueT
name|addvalue
init|=
name|opjp
operator|->
name|immediate
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|?
literal|0
else|:
name|opjp
operator|->
name|immediate
operator|.
name|X_add_number
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|opjp
operator|->
name|immediate
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|?
name|make_expr_symbol
argument_list|(
operator|&
name|opjp
operator|->
name|immediate
argument_list|)
else|:
name|opjp
operator|->
name|immediate
operator|.
name|X_add_symbol
decl_stmt|;
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_GOTOFF
condition|)
name|init
operator|=
name|max
operator|=
name|min
operator|=
name|MOVI_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|)
block|{
name|init
operator|=
name|max
operator|=
name|min
operator|=
name|MOVI_PLT
expr_stmt|;
name|what
operator|=
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|?
name|MOVI_IMM_64_PCREL
else|:
name|MOVI_IMM_32_PCREL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_SH_GOTPC
condition|)
block|{
name|init
operator|=
name|max
operator|=
name|min
operator|=
name|MOVI_GOTPC
expr_stmt|;
name|what
operator|=
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|?
name|MOVI_IMM_64_PCREL
else|:
name|MOVI_IMM_32_PCREL
operator|)
expr_stmt|;
block|}
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|max
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|min
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|what
argument_list|,
name|init
argument_list|)
argument_list|,
name|sym
argument_list|,
name|addvalue
argument_list|,
name|insn_loc
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
operator|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
operator|)
condition|?
name|BFD_RELOC_SH_IMMS16
else|:
name|opjp
operator|->
name|reloctype
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_PCIMMS16BY4
case|:
block|{
name|int
name|what
init|=
operator|(
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|&&
operator|!
name|sh64_pt32
operator|)
condition|?
name|SH64PCREL16_64
else|:
name|SH64PCREL16_32
operator|)
decl_stmt|;
name|offsetT
name|max
init|=
operator|(
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|&&
operator|!
name|sh64_pt32
operator|)
condition|?
name|SH64PCREL64
else|:
name|SH64PCREL32
operator|)
decl_stmt|;
name|offsetT
name|min
init|=
name|SH64PCREL16
decl_stmt|;
name|offsetT
name|init
init|=
name|UNDEF_SH64PCREL
decl_stmt|;
comment|/* Don't allow complex expressions here.  */
if|if
condition|(
name|opjp
operator|->
name|immediate
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand: expression in PT target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|)
name|init
operator|=
name|max
operator|=
name|min
operator|=
name|SH64PCRELPLT
expr_stmt|;
comment|/* If we're not expanding, then just emit a fixup.  */
if|if
condition|(
name|sh64_expand
operator|||
name|opjp
operator|->
name|reloctype
operator|!=
name|BFD_RELOC_NONE
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|max
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|min
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|what
argument_list|,
name|init
argument_list|)
argument_list|,
name|opjp
operator|->
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|opjp
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
name|insn_loc
argument_list|)
expr_stmt|;
else|else
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|1
argument_list|,
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|BFD_RELOC_SH_PT_16
else|:
name|opjp
operator|->
name|reloctype
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|A_PCIMMS16BY4_PT
case|:
block|{
name|int
name|what
init|=
operator|(
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|&&
operator|!
name|sh64_pt32
operator|)
condition|?
name|SH64PCREL16PT_64
else|:
name|SH64PCREL16PT_32
operator|)
decl_stmt|;
name|offsetT
name|max
init|=
operator|(
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|&&
operator|!
name|sh64_pt32
operator|)
condition|?
name|SH64PCREL64
else|:
name|SH64PCREL32
operator|)
decl_stmt|;
name|offsetT
name|min
init|=
name|SH64PCREL16
decl_stmt|;
name|offsetT
name|init
init|=
name|UNDEF_SH64PCREL
decl_stmt|;
comment|/* Don't allow complex expressions here.  */
if|if
condition|(
name|opjp
operator|->
name|immediate
operator|.
name|X_op_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand: expression in PT target"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_32_PLT_PCREL
condition|)
name|init
operator|=
name|max
operator|=
name|min
operator|=
name|SH64PCRELPLT
expr_stmt|;
comment|/* If we're not expanding, then just emit a fixup.  */
if|if
condition|(
name|sh64_expand
operator|||
name|opjp
operator|->
name|reloctype
operator|!=
name|BFD_RELOC_NONE
condition|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|max
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|min
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|what
argument_list|,
name|init
argument_list|)
argument_list|,
name|opjp
operator|->
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|opjp
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
name|insn_loc
argument_list|)
expr_stmt|;
else|else
comment|/* This reloc-type is just temporary, so we can distinguish 		 PTA from PT.  It is changed in shmedia_md_apply_fix to 		 BFD_RELOC_SH_PT_16.  */
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|1
argument_list|,
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
condition|?
name|SHMEDIA_BFD_RELOC_PT
else|:
name|opjp
operator|->
name|reloctype
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|A_IMMU5
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMU5
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMU6
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_IMMU6
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|A_IMMU16
case|:
name|insn
operator||=
name|shmedia_immediate_op
argument_list|(
name|insn_loc
argument_list|,
name|opjp
argument_list|,
literal|0
argument_list|,
operator|(
name|opjp
operator|->
name|reloctype
operator|==
name|BFD_RELOC_NONE
operator|)
condition|?
name|BFD_RELOC_SH_IMMU16
else|:
name|opjp
operator|->
name|reloctype
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
block|}
block|}
name|md_number_to_chars
argument_list|(
name|insn_loc
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Assemble a SHmedia instruction.  */
end_comment

begin_function
specifier|static
name|void
name|shmedia_md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|op_end
decl_stmt|;
name|shmedia_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|shmedia_operands_info
name|operands
decl_stmt|;
name|int
name|size
decl_stmt|;
name|opcode
operator|=
name|shmedia_find_cooked_opcode
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start a SHmedia code region, if there has been pseudoinsns or similar      seen since the last one.  */
if|if
condition|(
operator|!
name|seen_insn
condition|)
block|{
name|sh64_update_contents_mark
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|sh64_set_contents_type
argument_list|(
name|CRT_SH5_ISA32
argument_list|)
expr_stmt|;
name|seen_insn
operator|=
name|TRUE
expr_stmt|;
block|}
name|op_end
operator|=
name|shmedia_get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
operator|&
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_end
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands to %s"
argument_list|)
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|op_end
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"excess operands to %s"
argument_list|)
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|shmedia_build_Mytes
argument_list|(
name|opcode
argument_list|,
operator|&
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
block|}
end_function

begin_comment
comment|/* Hook called from md_begin in tc-sh.c.  */
end_comment

begin_function
name|void
name|shmedia_md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|shmedia_opcode_info
modifier|*
name|shmedia_opcode
decl_stmt|;
name|shmedia_opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Create opcode table for SHmedia mnemonics.  */
for|for
control|(
name|shmedia_opcode
operator|=
name|shmedia_table
init|;
name|shmedia_opcode
operator|->
name|name
condition|;
name|shmedia_opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|shmedia_opcode_hash_control
argument_list|,
name|shmedia_opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|shmedia_opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch instruction set.  Only valid if one of the --isa or --abi    options was specified.  */
end_comment

begin_function
specifier|static
name|void
name|s_sh64_mode
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
comment|/* Make sure data up to this location is handled according to the      previous ISA.  */
name|sh64_update_contents_mark
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the mode was not set before, explicitly or implicitly, then we're      not emitting SH64 code, so this pseudo is invalid.  */
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The `.mode %s' directive is not valid with this architecture"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"shcompact"
argument_list|)
operator|==
literal|0
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shcompact
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"shmedia"
argument_list|)
operator|==
literal|0
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shmedia
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid argument to .mode: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Make a new frag, marking it with the supposedly-changed ISA.  */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Contents type up to this new point is the same as before; don't add a      data region just because the new frag we created.  */
name|sh64_update_contents_mark
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that the right ABI is used.  Only valid if one of the --isa or    --abi options was specified.  */
end_comment

begin_function
specifier|static
name|void
name|s_sh64_abi
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the mode was not set before, explicitly or implicitly, then we're      not emitting SH64 code, so this pseudo is invalid.  */
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_unspecified
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The `.abi %s' directive is not valid with this architecture"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_abi
operator|!=
name|sh64_abi_64
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`.abi 64' but command-line options do not specify 64-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_abi
operator|!=
name|sh64_abi_32
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`.abi 32' but command-line options do not specify 32-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid argument to .abi: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is the first target-specific function called after    parsing command-line options.  Therefore we set default values from    command-line options here and do some sanity checking we couldn't do    when options were being parsed.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sh64_target_format
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TE_NetBSD
comment|/* For NetBSD, if the ISA is unspecified, always use SHmedia.  */
if|if
condition|(
name|preset_target_arch
operator|==
literal|0
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shmedia
expr_stmt|;
comment|/* If the ABI is unspecified, select a default: based on how      we were configured: sh64 == sh64_abi_64, else sh64_abi_32.  */
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_unspecified
condition|)
block|{
if|if
condition|(
name|preset_target_arch
operator|!=
literal|0
operator|||
name|sh64_isa_mode
operator|==
name|sh64_isa_shcompact
condition|)
name|sh64_abi
operator|=
name|sh64_abi_32
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_CPU
argument_list|,
literal|"sh64"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sh64_abi
operator|=
name|sh64_abi_64
expr_stmt|;
else|else
name|sh64_abi
operator|=
name|sh64_abi_32
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_LINUX
if|if
condition|(
name|preset_target_arch
operator|==
literal|0
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shmedia
expr_stmt|;
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_unspecified
condition|)
name|sh64_abi
operator|=
name|sh64_abi_32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shmedia
expr_stmt|;
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_32
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|sh64_isa_mode
operator|=
name|sh64_isa_shcompact
expr_stmt|;
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shcompact
operator|&&
name|sh64_abi
operator|==
name|sh64_abi_unspecified
condition|)
name|sh64_abi
operator|=
name|sh64_abi_32
expr_stmt|;
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
operator|&&
name|sh64_abi
operator|==
name|sh64_abi_unspecified
condition|)
name|sh64_abi
operator|=
name|sh64_abi_64
expr_stmt|;
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
operator|&&
operator|!
name|sh64_mix
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-no-mix is invalid without specifying SHcompact or SHmedia"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
operator|||
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
operator|)
operator|&&
name|sh64_shcompact_const_crange
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-shcompact-const-crange is invalid without SHcompact"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh64_pt32
operator|&&
name|sh64_abi
operator|!=
name|sh64_abi_64
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-expand-pt32 only valid with -abi=64"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sh64_expand
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-no-expand only valid with SHcompact or SHmedia"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh64_pt32
operator|&&
operator|!
name|sh64_expand
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-expand-pt32 invalid together with -no-expand"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_NetBSD
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf64-sh64-nbsd"
else|:
literal|"elf64-sh64l-nbsd"
operator|)
return|;
else|else
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-sh64-nbsd"
else|:
literal|"elf32-sh64l-nbsd"
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf64-sh64big-linux"
else|:
literal|"elf64-sh64-linux"
operator|)
return|;
else|else
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-sh64big-linux"
else|:
literal|"elf32-sh64-linux"
operator|)
return|;
else|#
directive|else
comment|/* When the ISA is not one of SHmedia or SHcompact, use the old SH      object format.  */
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_unspecified
condition|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-sh"
else|:
literal|"elf32-shl"
operator|)
return|;
elseif|else
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf64-sh64"
else|:
literal|"elf64-sh64l"
operator|)
return|;
else|else
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-sh64"
else|:
literal|"elf32-sh64l"
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The worker function of TARGET_MACH.  */
end_comment

begin_function
name|int
name|sh64_target_mach
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We need to explicitly set bfd_mach_sh5 instead of the default 0.  But      we only do this for the 64-bit ABI: if we do it for the 32-bit ABI,      the SH5 info in the bfd_arch_info structure will be selected.      However correct, as the machine has 64-bit addresses, functions      expected to emit 32-bit data for addresses will start failing.  For      example, the dwarf2dbg.c functions will emit 64-bit debugging format,      and we don't want that in the 32-bit ABI.       We could have two bfd_arch_info structures for SH64; one for the      32-bit ABI and one for the rest (64-bit ABI).  But that would be a      bigger kludge: it's a flaw in the BFD design, and we need to just      work around it by having the default machine set here in the      assembler.  For everything else but the assembler, the various bfd      functions will set the machine type right to bfd_mach_sh5 from object      file header flags regardless of the 0 here.  */
return|return
operator|(
name|sh64_abi
operator|==
name|sh64_abi_64
operator|)
condition|?
name|bfd_mach_sh5
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is MD_PCREL_FROM_SECTION, we we define so it is called instead of    md_pcrel_from (in tc-sh.c).  */
end_comment

begin_function
name|valueT
name|shmedia_md_pcrel_from_section
parameter_list|(
name|struct
name|fix
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|know
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
comment|/* Use the ISA for the instruction to decide which offset to use.  We      can glean it from the fisup type.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
case|case
name|BFD_RELOC_SH_IMM_LOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMM_HI16_PCREL
case|:
case|case
name|BFD_RELOC_SH_IMMU5
case|:
case|case
name|BFD_RELOC_SH_IMMU6
case|:
case|case
name|BFD_RELOC_SH_IMMS6
case|:
case|case
name|BFD_RELOC_SH_IMMS10
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY2
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY4
case|:
case|case
name|BFD_RELOC_SH_IMMS10BY8
case|:
case|case
name|BFD_RELOC_SH_IMMS16
case|:
case|case
name|BFD_RELOC_SH_IMMU16
case|:
case|case
name|BFD_RELOC_SH_PT_16
case|:
case|case
name|SHMEDIA_BFD_RELOC_PT
case|:
comment|/* PC-relative relocs are relative to the address of the last generated 	 instruction, i.e. fx_size - 4.  */
return|return
name|SHMEDIA_MD_PCREL_FROM_FIX
argument_list|(
name|fixP
argument_list|)
return|;
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_64_PCREL
case|:
name|know
argument_list|(
literal|0
comment|/* Shouldn't get here.  */
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If section was SHcompact, use its function.  */
return|return
operator|(
name|valueT
operator|)
name|md_pcrel_from_section
argument_list|(
name|fixP
argument_list|,
name|sec
argument_list|)
return|;
block|}
name|know
argument_list|(
literal|0
comment|/* Shouldn't get here.  */
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create one .cranges descriptor from two symbols, STARTSYM marking begin    and ENDSYM marking end, and CR_TYPE specifying the type.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_emit_crange
parameter_list|(
name|symbolS
modifier|*
name|startsym
parameter_list|,
name|symbolS
modifier|*
name|endsym
parameter_list|,
name|enum
name|sh64_elf_cr_type
name|cr_type
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
name|asection
modifier|*
name|cranges
init|=
name|bfd_make_section_old_way
argument_list|(
name|stdoutput
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
decl_stmt|;
comment|/* Temporarily change to the .cranges section.  */
name|subseg_set
argument_list|(
name|cranges
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Emit the cr_addr part.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|startsym
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Emit the cr_size part.  */
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|endsym
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|startsym
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Emit the cr_size part.  */
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|cr_type
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now back to our regular program.  */
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the assembler is about to emit contents of some type into    SEG, so it is *known* that the type of that new contents is in    NEW_CONTENTS_TYPE.  If just switching back and forth between different    contents types (for example, with consecutive .mode pseudos), then this    function isn't called.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_set_contents_type
parameter_list|(
name|enum
name|sh64_elf_cr_type
name|new_contents_type
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
comment|/* We will not be called when emitting .cranges output, since callers      stop that.  Validize that assumption.  */
name|know
argument_list|(
operator|!
name|emitting_crange
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
condition|)
block|{
name|symbolS
modifier|*
name|symp
init|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_contents_mark
decl_stmt|;
name|enum
name|sh64_elf_cr_type
name|contents_type
init|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
decl_stmt|;
comment|/* If it was just SHcompact switching between code and constant 	 pool, don't change contents type.  Just make sure we don't set 	 the contents type to data, as that would join with a data-region 	 in SHmedia mode.  */
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shcompact
operator|&&
operator|!
name|sh64_shcompact_const_crange
condition|)
name|new_contents_type
operator|=
name|CRT_SH5_ISA16
expr_stmt|;
comment|/* If nothing changed, stop here.  */
if|if
condition|(
name|contents_type
operator|==
name|new_contents_type
condition|)
return|return;
comment|/* If we're in 64-bit ABI mode, we do not emit .cranges, as it is 	 only specified for 32-bit addresses.  It could presumably be 	 extended, but in 64-bit ABI mode we don't have SHcompact code, so 	 we would only use it to mark code and data.  */
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
block|{
comment|/* Make the code type "sticky".  We don't want to set the 	     sections contents type to data if there's any code in it as 	     we don't have .cranges in 64-bit mode to notice the 	     difference.  */
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
operator|=
operator|(
name|new_contents_type
operator|==
name|CRT_SH5_ISA32
operator|||
name|contents_type
operator|==
name|CRT_SH5_ISA32
operator|)
condition|?
name|CRT_SH5_ISA32
else|:
name|new_contents_type
expr_stmt|;
return|return;
block|}
comment|/* If none was marked, create a start symbol for this range and 	 perhaps as a closing symbol for the old one.  */
if|if
condition|(
name|symp
operator|==
name|NULL
condition|)
name|symp
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
comment|/* We will use this symbol, so don't leave a pointer behind.  */
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_contents_mark
operator|=
name|NULL
expr_stmt|;
comment|/* We'll be making only datalabel references to it, if we emit a 	 .cranges descriptor, so remove any code flag.  */
name|S_SET_OTHER
argument_list|(
name|symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
operator|~
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
comment|/* If we have already marked the start of a range, we need to close 	 and emit it before marking a new one, so emit a new .cranges 	 descriptor into the .cranges section.  */
if|if
condition|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
condition|)
block|{
comment|/* If we're not supposed to emit mixed-mode sections, make it an 	     error, but continue processing.  */
if|if
condition|(
operator|!
name|sh64_mix
operator|&&
operator|(
name|new_contents_type
operator|==
name|CRT_SH5_ISA32
operator|||
name|contents_type
operator|==
name|CRT_SH5_ISA32
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"SHmedia code not allowed in same section as constants and SHcompact code"
argument_list|)
argument_list|)
expr_stmt|;
name|emitting_crange
operator|=
name|TRUE
expr_stmt|;
name|sh64_emit_crange
argument_list|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
argument_list|,
name|symp
argument_list|,
name|contents_type
argument_list|)
expr_stmt|;
name|emitting_crange
operator|=
name|FALSE
expr_stmt|;
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|emitted_ranges
operator|++
expr_stmt|;
block|}
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
operator|=
name|symp
expr_stmt|;
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_subseg
operator|=
name|now_subseg
expr_stmt|;
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
operator|=
name|new_contents_type
expr_stmt|;
comment|/* Always reset this, so the SHcompact code will emit a reloc when 	 it prepares to relax.  */
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|in_code
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No segment info for current section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook when defining symbols and labels.  We set the ST_OTHER field if    the symbol is "shmedia" (with "bitor 1" automatically applied).  Simple    semantics for a label being "shmedia" : It was defined when .mode    SHmedia was in effect, and it was defined in a code section.  It    doesn't matter whether or not an assembled opcode is nearby.  */
end_comment

begin_function
name|void
name|sh64_frob_label
parameter_list|(
name|symbolS
modifier|*
name|symp
parameter_list|)
block|{
name|segT
name|seg
init|=
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|symbolS
modifier|*
name|null
init|=
name|NULL
decl_stmt|;
comment|/* Reset the tc marker for all newly created symbols.  */
name|symbol_set_tc
argument_list|(
name|symp
argument_list|,
operator|(
name|symbolS
operator|*
operator|*
operator|)
operator|&
name|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|!=
name|NULL
operator|&&
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
operator|&&
name|subseg_text_p
argument_list|(
name|seg
argument_list|)
condition|)
name|S_SET_OTHER
argument_list|(
name|symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator||
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the "datalabel" qualifier.  We need to call "operand", but it's    static, so a function pointer is passed here instead.  FIXME: A target    hook for qualifiers is needed; we currently use the md_parse_name    symbol hook.  */
end_comment

begin_function
name|int
name|sh64_consume_datalabel
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|enum
name|expr_mode
name|mode
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|segT
function_decl|(
modifier|*
name|operandf
function_decl|)
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|enum
name|expr_mode
parameter_list|)
parameter_list|)
block|{
specifier|static
name|int
name|parsing_datalabel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"datalabel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|save_parsing_datalabel
init|=
name|parsing_datalabel
decl_stmt|;
if|if
condition|(
name|parsing_datalabel
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"duplicate datalabel operator ignored"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
operator|*
name|cp
expr_stmt|;
name|parsing_datalabel
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|operandf
call|)
argument_list|(
name|exp
argument_list|,
name|expr_normal
argument_list|)
expr_stmt|;
name|parsing_datalabel
operator|=
name|save_parsing_datalabel
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_PIC_reloc
condition|)
block|{
name|symbolS
modifier|*
name|symp
init|=
name|exp
operator|->
name|X_add_symbol
decl_stmt|;
name|segT
name|symseg
init|=
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
decl_stmt|;
comment|/* If the symbol is defined to something that is already a 	     datalabel, we don't need to bother with any special handling.  */
if|if
condition|(
name|symseg
operator|!=
name|undefined_section
operator|&&
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|!=
name|STO_SH5_ISA32
condition|)
comment|/* Do nothing.  */
empty_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|dl_symp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dl_name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Now we copy the datalabel-qualified symbol into a symbol 		 with the same name, but with " DL" appended.  We mark the 		 symbol using the TC_SYMFIELD_TYPE field with a pointer to 		 the main symbol, so we don't have to inspect all symbol 		 names.  Note that use of "datalabel" is not expected to 		 be a common case.  */
name|strcpy
argument_list|(
name|dl_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dl_name
argument_list|,
name|DATALABEL_SUFFIX
argument_list|)
expr_stmt|;
comment|/* A FAKE_LABEL_NAME marks "$" or ".".  There can be any 		 number of them and all have the same (faked) name; we 		 must make a new one each time.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
operator|==
literal|0
condition|)
name|dl_symp
operator|=
name|symbol_make
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
else|else
name|dl_symp
operator|=
name|symbol_find_or_make
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|dl_symp
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|dl_symp
argument_list|,
name|symseg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|dl_symp
argument_list|,
name|symbol_get_frag
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_tc
argument_list|(
name|dl_symp
argument_list|,
operator|&
name|symp
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|dl_symp
argument_list|,
name|symp
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
name|dl_symp
expr_stmt|;
comment|/* Unset the BranchTarget mark that can be set at symbol 		 creation or attributes copying.  */
name|S_SET_OTHER
argument_list|(
name|dl_symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|dl_symp
argument_list|)
operator|&
operator|~
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
comment|/* The GLOBAL and WEAK attributes are not copied over by 		 copy_symbol_attributes.  Do it here.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|dl_symp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|dl_symp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Complain about other types of operands than symbol, unless they 	 have already been complained about.  A constant is always a 	 datalabel.  Removing the low bit would therefore be wrong. 	 Complaining about it would also be wrong.  */
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|!=
name|O_illegal
operator|&&
name|exp
operator|->
name|X_op
operator|!=
name|O_absent
operator|&&
name|exp
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid DataLabel expression"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|sh_parse_name
argument_list|(
name|name
argument_list|,
name|exp
argument_list|,
name|mode
argument_list|,
name|cp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is called just before symbols are being output.  It    returns zero when a symbol must be output, non-zero otherwise.    Datalabel references that were fully resolved to local symbols are not    necessary to output.  We also do not want to output undefined symbols    that are not used in relocs.  For symbols that are used in a reloc, it    does not matter what we set here.  If it is *not* used in a reloc, then    it was probably the datalabel counterpart that was used in a reloc;    then we need not output the main symbol.  */
end_comment

begin_function
name|int
name|sh64_exclude_symbol
parameter_list|(
name|symbolS
modifier|*
name|symp
parameter_list|)
block|{
name|symbolS
modifier|*
name|main_symbol
init|=
operator|*
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
decl_stmt|;
return|return
name|main_symbol
operator|!=
name|NULL
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If we haven't seen an insn since the last update, and location    indicators have moved (a new frag, new location within frag) we have    emitted data, so change contents type to data.  Forget that we have    seen a sequence of insns and store the current location so we can mark    a new region if needed.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_update_contents_mark
parameter_list|(
name|bfd_boolean
name|update_type
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|symp
init|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_contents_mark
decl_stmt|;
if|if
condition|(
name|symp
operator|==
name|NULL
condition|)
block|{
name|symp
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_contents_mark
operator|=
name|symp
expr_stmt|;
block|}
else|else
block|{
comment|/* If we have moved location since last flush, we need to emit a 	     data range.  The previous contents type ended at the location 	     of the last update.  */
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|!=
name|frag_now_fix
argument_list|()
operator|||
name|symbol_get_frag
argument_list|(
name|symp
argument_list|)
operator|!=
name|frag_now
operator|)
condition|)
block|{
name|enum
name|sh64_elf_cr_type
name|contents_type
init|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
decl_stmt|;
if|if
condition|(
name|update_type
operator|&&
name|contents_type
operator|!=
name|CRT_DATA
operator|&&
name|contents_type
operator|!=
name|CRT_NONE
operator|&&
operator|!
name|seen_insn
condition|)
block|{
name|sh64_set_contents_type
argument_list|(
name|CRT_DATA
argument_list|)
expr_stmt|;
name|symp
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|last_contents_mark
expr_stmt|;
block|}
comment|/* If the symbol wasn't used up to make up a new range 		 descriptor, update it to this new location.  */
if|if
condition|(
name|symp
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|seen_insn
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the assembler is about to output some data, or maybe it's    just switching segments.  */
end_comment

begin_function
name|void
name|sh64_flush_pending_output
parameter_list|(
name|void
parameter_list|)
block|{
name|sh64_update_contents_mark
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|sh_flush_pending_output
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush out the last crange descriptor after all insns have been emitted.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_flush_last_crange
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|,
name|void
modifier|*
name|countparg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
comment|/* Only emit .cranges descriptors if we would make it more than one.  */
operator|&&
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|emitted_ranges
operator|!=
literal|0
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
comment|/* We need a closing symbol, so switch to the indicated section and 	 emit it.  */
comment|/* Change to the section we're about to handle.  */
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_subseg
argument_list|)
expr_stmt|;
name|symp
operator|=
name|symbol_new
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
comment|/* We'll be making a datalabel reference to it, so remove any code          flag.  */
name|S_SET_OTHER
argument_list|(
name|symp
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symp
argument_list|)
operator|&
operator|~
name|STO_SH5_ISA32
argument_list|)
expr_stmt|;
name|sh64_emit_crange
argument_list|(
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mode_start_symbol
argument_list|,
name|symp
argument_list|,
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|contents_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If and only if we see a call to md_number_to_chars without flagging the    start of an insn, we set the contents type to CRT_DATA, and only when    in SHmedia mode.  Note that by default we don't bother changing when    going from SHcompact to data, as the constant pools in GCC-generated    SHcompact code would create an inordinate amount of .cranges    descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_flag_output
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sh64_isa_mode
operator|!=
name|sh64_isa_unspecified
operator|&&
operator|!
name|seen_insn
operator|&&
operator|!
name|sh64_end_of_assembly
operator|&&
operator|!
name|emitting_crange
condition|)
block|{
name|md_flush_pending_output
argument_list|()
expr_stmt|;
name|sh64_set_contents_type
argument_list|(
name|CRT_DATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Vtables don't need "datalabel" but we allow it by simply deleting    any we find.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strip_datalabels
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|,
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
for|for
control|(
name|src
operator|=
name|input_line_pointer
operator|,
name|dest
operator|=
name|input_line_pointer
init|;
operator|*
name|src
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|src
argument_list|,
literal|"datalabel"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|&&
name|ISSPACE
argument_list|(
name|src
index|[
literal|9
index|]
argument_list|)
operator|&&
operator|(
name|src
operator|==
name|start
operator|||
operator|!
operator|(
name|ISALNUM
argument_list|(
name|src
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|||
name|src
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
name|src
operator|+=
literal|10
expr_stmt|;
else|else
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dest
operator|<
name|src
condition|)
operator|*
name|dest
operator|=
literal|'\n'
expr_stmt|;
return|return
name|src
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sh64_vtable_entry
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|eol
init|=
name|strip_datalabels
argument_list|()
decl_stmt|;
name|obj_elf_vtable_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|eol
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sh64_vtable_inherit
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|eol
init|=
name|strip_datalabels
argument_list|()
decl_stmt|;
name|obj_elf_vtable_inherit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|eol
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sh64_fake_label
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
operator|-
literal|1
operator|)
condition|)
return|return
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
sizeof|sizeof
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|DATALABEL_SUFFIX
argument_list|)
operator|==
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

