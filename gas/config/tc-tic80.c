begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-tic80.c -- Assemble for the TI TMS320C80 (MV)    Copyright 1996, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic80.h"
end_include

begin_define
define|#
directive|define
name|internal_error
parameter_list|(
name|what
parameter_list|)
define|\
value|as_fatal (_("internal error:%s:%d: %s\n"), __FILE__, __LINE__, what)
end_define

begin_define
define|#
directive|define
name|internal_error_a
parameter_list|(
name|what
parameter_list|,
name|arg
parameter_list|)
define|\
value|as_fatal (_("internal error:%s:%d: %s %ld\n"), __FILE__, __LINE__, what, arg)
end_define

begin_escape
end_escape

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";*#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a single    line. The semicolon is such a character by default and should not be    explicitly listed.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0f1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:     pseudo-op name without dot    function to call to execute this pseudo-op    integer arg to pass to the function  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|4
block|}
block|,
comment|/* Do byte alignment, default is a 4 byte boundary  */
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
comment|/* FIXME: Should this be machine independent?  */
block|{
literal|"bss"
block|,
name|s_lcomm_bytes
block|,
literal|1
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* For compatibility with TI tools  */
block|{
literal|"section"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* Standard COFF .section pseudo-op  */
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tic80_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tic80_opcode
modifier|*
name|find_opcode
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tic80_opcode
operator|*
operator|,
name|expressionS
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tic80_opcode
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_operands
name|PARAMS
argument_list|(
operator|(
name|expressionS
name|exp
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_overflow
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|num
operator|,
name|int
name|bits
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Replace short PC relative instructions with long form when    necessary.  Currently this is off by default or when given the    -no-relax option.  Turning it on by using the -relax option forces    all PC relative instructions to use the long form, which is why it    is currently not the default.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tic80_relax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|internal_error
argument_list|(
name|_
argument_list|(
literal|"Relaxation is a luxury we can't afford"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|4
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof ()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|input_line_pointer
operator|=
name|t
expr_stmt|;
block|}
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the constant value in NUM will fit in a field of    width BITS if it has flags FLAGS.  */
end_comment

begin_function
specifier|static
name|int
name|const_overflow
parameter_list|(
name|num
parameter_list|,
name|bits
parameter_list|,
name|flags
parameter_list|)
name|unsigned
name|long
name|num
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Only need to check fields less than 32 bits wide.  */
if|if
condition|(
name|bits
operator|>=
literal|32
condition|)
return|return
name|retval
return|;
if|if
condition|(
name|flags
operator|&
name|TIC80_OPERAND_SIGNED
condition|)
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|retval
operator|=
operator|(
name|long
operator|)
name|num
operator|>
name|max
operator|||
operator|(
name|long
operator|)
name|num
operator|<
name|min
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|num
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* get_operands () parses a string of operands and fills in a passed    array of expressions in EXP.     Note that we use O_absent expressions to record additional information    about the previous non-O_absent expression, such as ":m" or ":s"    modifiers or register numbers enclosed in parens like "(r10)".     Returns the number of expressions that were placed in EXP.  */
end_comment

begin_function
specifier|static
name|int
name|get_operands
parameter_list|(
name|exp
parameter_list|)
name|expressionS
name|exp
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|numexp
init|=
literal|0
decl_stmt|;
name|int
name|parens
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Skip leading whitespace.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Check to see if we have any operands left to parse.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
break|break;
comment|/* Notice scaling or direct memory operand modifiers and save them in 	 an O_absent expression after the expression that they modify.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'m'
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* This is a ":m" modifier.  */
name|exp
index|[
name|numexp
index|]
operator|.
name|X_add_number
operator|=
name|TIC80_OPERAND_M_SI
operator||
name|TIC80_OPERAND_M_LI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'s'
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* This is a ":s" modifier.  */
name|exp
index|[
name|numexp
index|]
operator|.
name|X_add_number
operator|=
name|TIC80_OPERAND_SCALED
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"':' not followed by 'm' or 's'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numexp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Handle leading '(' on operands that use them, by recording that we 	 have entered a paren nesting level and then continuing.  We complain 	 about multiple nesting.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
operator|++
name|parens
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"paren nesting"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Handle trailing ')' on operands that use them, by reducing the 	 nesting level and then continuing.  We complain if there were too 	 many closures.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* Record that we have left a paren group and continue.  */
if|if
condition|(
operator|--
name|parens
operator|<
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"mismatched parenthesis"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Begin operand parsing at the current scan point.  */
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
index|[
name|numexp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numexp
operator|++
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
name|parens
condition|)
block|{
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|exp
index|[
name|numexp
operator|++
index|]
operator|.
name|X_add_number
operator|=
name|TIC80_OPERAND_PARENS
expr_stmt|;
block|}
comment|/* Mark the end of the valid operands with an illegal expression.  */
name|exp
index|[
name|numexp
index|]
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
return|return
operator|(
name|numexp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* find_opcode() gets a pointer to the entry in the opcode table that    matches the instruction being assembled, or returns NULL if no such match    is found.     First it parses all the operands and save them as expressions.  Note that    we use O_absent expressions to record additional information about the    previous non-O_absent expression, such as ":m" or ":s" modifiers or    register numbers enclosed in parens like "(r10)".     It then looks at all opcodes with the same name and uses the operands to    choose the correct opcode.  */
end_comment

begin_function
specifier|static
name|struct
name|tic80_opcode
modifier|*
name|find_opcode
parameter_list|(
name|opcode
parameter_list|,
name|myops
parameter_list|)
name|struct
name|tic80_opcode
modifier|*
name|opcode
decl_stmt|;
name|expressionS
name|myops
index|[]
decl_stmt|;
block|{
name|int
name|numexp
decl_stmt|;
comment|/* Number of expressions from parsing operands */
name|int
name|expi
decl_stmt|;
comment|/* Index of current expression to match */
name|int
name|opi
decl_stmt|;
comment|/* Index of current operand to match */
name|int
name|match
init|=
literal|0
decl_stmt|;
comment|/* Set to 1 when an operand match is found */
name|struct
name|tic80_opcode
modifier|*
name|opc
init|=
name|opcode
decl_stmt|;
comment|/* Pointer to current opcode table entry */
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|end
decl_stmt|;
comment|/* Pointer to end of opcode table */
comment|/* First parse all the operands so we only have to do it once.  There may      be more expressions generated than there are operands.  */
name|numexp
operator|=
name|get_operands
argument_list|(
name|myops
argument_list|)
expr_stmt|;
comment|/* For each opcode with the same name, try to match it against the parsed      operands.  */
name|end
operator|=
name|tic80_opcodes
operator|+
name|tic80_num_opcodes
expr_stmt|;
while|while
condition|(
operator|!
name|match
operator|&&
operator|(
name|opc
operator|<
name|end
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|opc
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Start off assuming a match.  If we find a mismatch, then this is 	 reset and the operand/expr matching loop terminates with match 	 equal to zero, which allows us to try the next opcode.  */
name|match
operator|=
literal|1
expr_stmt|;
comment|/* For each expression, try to match it against the current operand 	 for the current opcode.  Upon any mismatch, we abandon further 	 matching for the current opcode table entry.  */
for|for
control|(
name|expi
operator|=
literal|0
operator|,
name|opi
operator|=
operator|-
literal|1
init|;
operator|(
name|expi
operator|<
name|numexp
operator|)
operator|&&
name|match
condition|;
name|expi
operator|++
control|)
block|{
name|int
name|bits
decl_stmt|,
name|flags
decl_stmt|,
name|X_op
decl_stmt|,
name|num
decl_stmt|;
name|X_op
operator|=
name|myops
index|[
name|expi
index|]
operator|.
name|X_op
expr_stmt|;
name|num
operator|=
name|myops
index|[
name|expi
index|]
operator|.
name|X_add_number
expr_stmt|;
comment|/* The O_absent expressions apply to the same operand as the most 	     recent non O_absent expression.  So only increment the operand 	     index when the current expression is not one of these special 	     expressions.  */
if|if
condition|(
name|X_op
operator|!=
name|O_absent
condition|)
block|{
name|opi
operator|++
expr_stmt|;
block|}
name|flags
operator|=
name|tic80_operands
index|[
name|opc
operator|->
name|operands
index|[
name|opi
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|bits
operator|=
name|tic80_operands
index|[
name|opc
operator|->
name|operands
index|[
name|opi
index|]
index|]
operator|.
name|bits
expr_stmt|;
switch|switch
condition|(
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
comment|/* Also check that registers that are supposed to be 		 even actually are even.  */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_GPR
operator|)
operator|!=
operator|(
name|num
operator|&
name|TIC80_OPERAND_GPR
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_FPA
operator|)
operator|!=
operator|(
name|num
operator|&
name|TIC80_OPERAND_FPA
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_CR
operator|)
operator|!=
operator|(
name|num
operator|&
name|TIC80_OPERAND_CR
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_EVEN
operator|)
operator|&&
operator|(
name|num
operator|&
literal|1
operator|)
operator|)
operator|||
name|const_overflow
argument_list|(
name|num
operator|&
operator|~
name|TIC80_OPERAND_MASK
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_ENDMASK
operator|)
operator|&&
operator|(
name|num
operator|==
literal|32
operator|)
condition|)
block|{
comment|/* Endmask values of 0 and 32 give identical                      results.  */
name|num
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|TIC80_OPERAND_FPA
operator||
name|TIC80_OPERAND_GPR
operator|)
operator|)
operator|||
name|const_overflow
argument_list|(
name|num
argument_list|,
name|bits
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_symbol
case|:
if|if
condition|(
operator|(
name|bits
operator|<
literal|32
operator|)
operator|&&
operator|(
name|flags
operator|&
name|TIC80_OPERAND_PCREL
operator|)
operator|&&
operator|!
name|tic80_relax
condition|)
block|{
comment|/* The default is to prefer the short form of PC 		     relative relocations.  This is the only form that 		     the TI assembler supports.  If the -relax option 		     is given, we never use the short forms. 		     FIXME: Should be able to choose "best-fit".  */
block|}
elseif|else
if|if
condition|(
operator|(
name|bits
operator|==
literal|32
operator|)
if|#
directive|if
literal|0
condition|&& (flags& TIC80_OPERAND_BASEREL)
endif|#
directive|endif
condition|)
block|{
comment|/* The default is to prefer the long form of base 		     relative relocations.  This is the only form that 		     the TI assembler supports.  If the -no-relax 		     option is given, we always use the long form of 		     PC relative relocations. 		     FIXME: Should be able to choose "best-fit".  */
block|}
else|else
block|{
comment|/* Symbols that don't match one of the above cases are 		     rejected as an operand.  */
name|match
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_absent
case|:
comment|/* If this is an O_absent expression, then it may be an 		 expression that supplies additional information about 		 the operand, such as ":m" or ":s" modifiers. Check to 		 see that the operand matches this requirement.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|num
operator|&
name|flags
operator|&
name|TIC80_OPERAND_M_SI
operator|)
operator|||
operator|(
name|num
operator|&
name|flags
operator|&
name|TIC80_OPERAND_M_LI
operator|)
operator|||
operator|(
name|num
operator|&
name|flags
operator|&
name|TIC80_OPERAND_SCALED
operator|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_big
case|:
if|if
condition|(
operator|(
name|num
operator|>
literal|0
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|TIC80_OPERAND_FLOAT
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_illegal
case|:
case|case
name|O_symbol_rva
case|:
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
case|case
name|O_logical_not
case|:
case|case
name|O_multiply
case|:
case|case
name|O_divide
case|:
case|case
name|O_modulus
case|:
case|case
name|O_left_shift
case|:
case|case
name|O_right_shift
case|:
case|case
name|O_bit_inclusive_or
case|:
case|case
name|O_bit_or_not
case|:
case|case
name|O_bit_exclusive_or
case|:
case|case
name|O_bit_and
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
case|case
name|O_lt
case|:
case|case
name|O_le
case|:
case|case
name|O_ge
case|:
case|case
name|O_gt
case|:
case|case
name|O_logical_and
case|:
case|case
name|O_logical_or
case|:
case|case
name|O_max
case|:
default|default:
name|internal_error_a
argument_list|(
name|_
argument_list|(
literal|"unhandled expression type"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|X_op
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|opc
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|match
condition|?
name|opc
else|:
name|NULL
operator|)
return|;
if|#
directive|if
literal|0
comment|/* Now search the opcode table table for one with operands that      matches what we've got.  */
block|while (!match)     {       match = 1;       for (i = 0; opcode->operands[i]; i++) 	{ 	  int flags = tic80_operands[opcode->operands[i]].flags; 	  int X_op = myops[i].X_op; 	  int num = myops[i].X_add_number;  	  if (X_op == 0) 	    { 	      match = 0; 	      break; 	    }  	  if (flags& (TIC80_OPERAND_GPR | TIC80_OPERAND_FPA | TIC80_OPERAND_CR)) 	    { 	      if ((X_op != O_register) || 		  ((flags& TIC80_OPERAND_GPR) != (num& TIC80_OPERAND_GPR)) || 		  ((flags& TIC80_OPERAND_FPA) != (num& TIC80_OPERAND_FPA)) || 		  ((flags& TIC80_OPERAND_CR) != (num& TIC80_OPERAND_CR))) 		{ 		  match = 0; 		  break; 		} 	    }  	  if (((flags& TIC80_OPERAND_MINUS)&& ((X_op != O_absent) || (num != TIC80_OPERAND_MINUS))) || 	      ((flags& TIC80_OPERAND_PLUS)&& ((X_op != O_absent) || (num != TIC80_OPERAND_PLUS))) || 	      ((flags& TIC80_OPERAND_ATMINUS)&& ((X_op != O_absent) || (num != TIC80_OPERAND_ATMINUS))) || 	      ((flags& TIC80_OPERAND_ATPAR)&& ((X_op != O_absent) || (num != TIC80_OPERAND_ATPAR))) || 	      ((flags& TIC80_OPERAND_ATSIGN)&& ((X_op != O_absent) || (num != TIC80_OPERAND_ATSIGN)))) 	    { 	      match = 0; 	      break; 	    } 	}
comment|/* We're only done if the operands matched so far AND there 	 are no more to check.  */
block|if (match&& myops[i].X_op == 0) 	break;       else 	match = 0;        next_opcode = opcode + 1;       if (next_opcode->opcode == 0) 	break;       if (strcmp (next_opcode->name, opcode->name)) 	break;       opcode = next_opcode;     }    if (!match)     {       as_bad (_("bad opcode or operands"));       return (0);     }
comment|/* Check that all registers that are required to be even are.      Also, if any operands were marked as registers, but were really      symbols, fix that here.  */
block|for (i = 0; opcode->operands[i]; i++)     {       if ((tic80_operands[opcode->operands[i]].flags& TIC80_OPERAND_EVEN)&& (myops[i].X_add_number& 1)) 	as_fatal (_("Register number must be EVEN"));       if (myops[i].X_op == O_register) 	{ 	  if (!(tic80_operands[opcode->operands[i]].flags& TIC80_OPERAND_REG)) 	    { 	      myops[i].X_op = O_symbol; 	      myops[i].X_add_symbol = 		symbol_find_or_make ((char *) myops[i].X_op_symbol); 	      myops[i].X_add_number = 0; 	      myops[i].X_op_symbol = NULL; 	    } 	}     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* build_insn takes a pointer to the opcode entry in the opcode table    and the array of operand expressions and writes out the instruction.     Note that the opcode word and extended word may be written to different    frags, with the opcode at the end of one frag and the extension at the    beginning of the next.  */
end_comment

begin_function
specifier|static
name|void
name|build_insn
parameter_list|(
name|opcode
parameter_list|,
name|opers
parameter_list|)
name|struct
name|tic80_opcode
modifier|*
name|opcode
decl_stmt|;
name|expressionS
modifier|*
name|opers
decl_stmt|;
block|{
name|int
name|expi
decl_stmt|;
comment|/* Index of current expression to match */
name|int
name|opi
decl_stmt|;
comment|/* Index of current operand to match */
name|unsigned
name|long
name|insn
index|[
literal|2
index|]
decl_stmt|;
comment|/* Instruction and long immediate (if any) */
name|char
modifier|*
name|f
decl_stmt|;
comment|/* Pointer to frag location for insn[0] */
name|fragS
modifier|*
name|ffrag
decl_stmt|;
comment|/* Frag containing location f */
name|char
modifier|*
name|fx
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to frag location for insn[1] */
name|fragS
modifier|*
name|fxfrag
decl_stmt|;
comment|/* Frag containing location fx */
comment|/* Start with the raw opcode bits from the opcode table.  */
name|insn
index|[
literal|0
index|]
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
comment|/* We are going to insert at least one 32 bit opcode so get the      frag now.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ffrag
operator|=
name|frag_now
expr_stmt|;
comment|/* For each operand expression, insert the appropriate bits into the      instruction.  */
for|for
control|(
name|expi
operator|=
literal|0
operator|,
name|opi
operator|=
operator|-
literal|1
init|;
name|opers
index|[
name|expi
index|]
operator|.
name|X_op
operator|!=
name|O_illegal
condition|;
name|expi
operator|++
control|)
block|{
name|int
name|bits
decl_stmt|,
name|shift
decl_stmt|,
name|flags
decl_stmt|,
name|X_op
decl_stmt|,
name|num
decl_stmt|;
name|X_op
operator|=
name|opers
index|[
name|expi
index|]
operator|.
name|X_op
expr_stmt|;
name|num
operator|=
name|opers
index|[
name|expi
index|]
operator|.
name|X_add_number
expr_stmt|;
comment|/* The O_absent expressions apply to the same operand as the most 	 recent non O_absent expression.  So only increment the operand 	 index when the current expression is not one of these special 	 expressions.  */
if|if
condition|(
name|X_op
operator|!=
name|O_absent
condition|)
block|{
name|opi
operator|++
expr_stmt|;
block|}
name|flags
operator|=
name|tic80_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|opi
index|]
index|]
operator|.
name|flags
expr_stmt|;
name|bits
operator|=
name|tic80_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|opi
index|]
index|]
operator|.
name|bits
expr_stmt|;
name|shift
operator|=
name|tic80_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|opi
index|]
index|]
operator|.
name|shift
expr_stmt|;
switch|switch
condition|(
name|X_op
condition|)
block|{
case|case
name|O_register
case|:
name|num
operator|&=
operator|~
name|TIC80_OPERAND_MASK
expr_stmt|;
name|insn
index|[
literal|0
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator||
operator|(
name|num
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_ENDMASK
operator|)
operator|&&
operator|(
name|num
operator|==
literal|32
operator|)
condition|)
block|{
comment|/* Endmask values of 0 and 32 give identical results.  */
name|num
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|TIC80_OPERAND_BITNUM
operator|)
condition|)
block|{
comment|/* BITNUM values are stored in one's complement form.  */
name|num
operator|=
operator|(
operator|~
name|num
operator|&
literal|0x1F
operator|)
expr_stmt|;
block|}
comment|/* Mask off upper bits, just it case it is signed and is 	     negative.  */
if|if
condition|(
name|bits
operator|<
literal|32
condition|)
block|{
name|num
operator|&=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|insn
index|[
literal|0
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator||
operator|(
name|num
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fx
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fxfrag
operator|=
name|frag_now
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
name|num
expr_stmt|;
block|}
break|break;
case|case
name|O_symbol
case|:
if|if
condition|(
name|bits
operator|==
literal|32
condition|)
block|{
name|fx
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fxfrag
operator|=
name|frag_now
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TIC80_OPERAND_PCREL
condition|)
block|{
name|fix_new_exp
argument_list|(
name|fxfrag
argument_list|,
name|fx
operator|-
operator|(
name|fxfrag
operator|->
name|fr_literal
operator|)
argument_list|,
literal|4
argument_list|,
operator|&
name|opers
index|[
name|expi
index|]
argument_list|,
literal|1
argument_list|,
name|R_MPPCR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|fxfrag
argument_list|,
name|fx
operator|-
operator|(
name|fxfrag
operator|->
name|fr_literal
operator|)
argument_list|,
literal|4
argument_list|,
operator|&
name|opers
index|[
name|expi
index|]
argument_list|,
literal|0
argument_list|,
name|R_RELLONGX
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TIC80_OPERAND_PCREL
condition|)
block|{
name|fix_new_exp
argument_list|(
name|ffrag
argument_list|,
name|f
operator|-
operator|(
name|ffrag
operator|->
name|fr_literal
operator|)
argument_list|,
literal|4
argument_list|,
comment|/* FIXME! how is this used?  */
operator|&
name|opers
index|[
name|expi
index|]
argument_list|,
literal|1
argument_list|,
name|R_MPPCR15W
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_error
argument_list|(
name|_
argument_list|(
literal|"symbol reloc that is not PC relative or 32 bits"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_absent
case|:
comment|/* Each O_absent expression can indicate exactly one              possible modifier.  */
if|if
condition|(
operator|(
name|num
operator|&
name|TIC80_OPERAND_M_SI
operator|)
operator|&&
operator|(
name|flags
operator|&
name|TIC80_OPERAND_M_SI
operator|)
condition|)
block|{
name|insn
index|[
literal|0
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator||
operator|(
literal|1
operator|<<
literal|17
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|&
name|TIC80_OPERAND_M_LI
operator|)
operator|&&
operator|(
name|flags
operator|&
name|TIC80_OPERAND_M_LI
operator|)
condition|)
block|{
name|insn
index|[
literal|0
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator||
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|&
name|TIC80_OPERAND_SCALED
operator|)
operator|&&
operator|(
name|flags
operator|&
name|TIC80_OPERAND_SCALED
operator|)
condition|)
block|{
name|insn
index|[
literal|0
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator||
operator|(
literal|1
operator|<<
literal|11
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|&
name|TIC80_OPERAND_PARENS
operator|)
operator|&&
operator|(
name|flags
operator|&
name|TIC80_OPERAND_PARENS
operator|)
condition|)
block|{
comment|/* No code to generate, just accept and discard this                  expression.  */
block|}
else|else
block|{
name|internal_error_a
argument_list|(
name|_
argument_list|(
literal|"unhandled operand modifier"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|opers
index|[
name|expi
index|]
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_big
case|:
name|fx
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fxfrag
operator|=
name|frag_now
expr_stmt|;
block|{
name|int
name|precision
init|=
literal|2
decl_stmt|;
name|long
name|exponent_bits
init|=
literal|8L
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|2
index|]
decl_stmt|;
comment|/* Value is still in generic_floating_point_number.  */
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|precision
argument_list|,
name|exponent_bits
argument_list|)
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
name|words
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
name|O_illegal
case|:
case|case
name|O_symbol_rva
case|:
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
case|case
name|O_logical_not
case|:
case|case
name|O_multiply
case|:
case|case
name|O_divide
case|:
case|case
name|O_modulus
case|:
case|case
name|O_left_shift
case|:
case|case
name|O_right_shift
case|:
case|case
name|O_bit_inclusive_or
case|:
case|case
name|O_bit_or_not
case|:
case|case
name|O_bit_exclusive_or
case|:
case|case
name|O_bit_and
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
case|case
name|O_lt
case|:
case|case
name|O_le
case|:
case|case
name|O_ge
case|:
case|case
name|O_gt
case|:
case|case
name|O_logical_and
case|:
case|case
name|O_logical_or
case|:
case|case
name|O_max
case|:
default|default:
name|internal_error_a
argument_list|(
name|_
argument_list|(
literal|"unhandled expression"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|X_op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write out the instruction, either 4 or 8 bytes.  */
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|fx
operator|!=
name|NULL
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|fx
argument_list|,
name|insn
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the main entry point for the machine-dependent assembler.  Gas    calls this function for each input line which does not contain a    pseudoop.    STR points to a NULL terminated machine dependent instruction.  This   function is supposed to emit the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|unsigned
name|char
modifier|*
name|input_line_save
decl_stmt|;
name|struct
name|tic80_opcode
modifier|*
name|opcode
decl_stmt|;
name|expressionS
name|myops
index|[
literal|16
index|]
decl_stmt|;
comment|/* Ensure there is something there to assemble.  */
name|assert
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Drop any leading whitespace.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Isolate the mnemonic from the rest of the string by finding the first      whitespace character and zapping it to a null byte.  */
for|for
control|(
name|scan
operator|=
name|str
init|;
operator|*
name|scan
operator|!=
literal|'\000'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|;
name|scan
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|scan
operator|!=
literal|'\000'
condition|)
operator|*
name|scan
operator|++
operator|=
literal|'\000'
expr_stmt|;
comment|/* Try to find this mnemonic in the hash table.  */
if|if
condition|(
operator|(
name|opcode
operator|=
operator|(
expr|struct
name|tic80_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|tic80_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid mnemonic: '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|scan
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
name|input_line_save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|opcode
operator|=
name|find_opcode
argument_list|(
name|opcode
argument_list|,
name|myops
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operands: '%s'"
argument_list|)
argument_list|,
name|input_line_save
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|input_line_save
expr_stmt|;
name|build_insn
argument_list|(
name|opcode
argument_list|,
name|myops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once at the start of assembly, after the command    line arguments have been parsed and all the machine independent    initializations have been completed.     It should set up all the tables, etc., that the machine dependent part of    the assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
specifier|register
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|op
decl_stmt|;
specifier|register
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|op_end
decl_stmt|;
specifier|const
name|struct
name|predefined_symbol
modifier|*
name|pdsp
decl_stmt|;
specifier|extern
name|int
name|coff_flags
decl_stmt|;
comment|/* Defined in obj-coff.c  */
comment|/* Set F_AR32WR in coff_flags, which will end up in the file header      f_flags field.  */
name|coff_flags
operator||=
name|F_AR32WR
expr_stmt|;
comment|/* TIc80 is 32 bit little endian.  */
comment|/* Insert unique names into hash table.  The TIc80 instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
name|tic80_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|tic80_opcodes
operator|+
name|tic80_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
name|tic80_opcodes
init|;
name|op
operator|<
name|op_end
condition|;
name|op
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|op
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|tic80_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert the predefined symbols into the symbol table.  We use      symbol_create rather than symbol_new so that these symbols don't      end up in the object files' symbol table.  Note that the values      of the predefined symbols include some upper bits that      distinguish the type of the symbol (register, bitnum, condition      code, etc) and these bits must be masked away before actually      inserting the values into the instruction stream.  For registers      we put these bits in the symbol table since we use them later and      there is no question that they aren't part of the register      number.  For constants we can't do that since the constant can be      any value, so they are masked off before putting them into the      symbol table.  */
name|pdsp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|pdsp
operator|=
name|tic80_next_predefined_symbol
argument_list|(
name|pdsp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|segT
name|segment
decl_stmt|;
name|valueT
name|valu
decl_stmt|;
name|int
name|symtype
decl_stmt|;
name|symtype
operator|=
name|PDS_VALUE
argument_list|(
name|pdsp
argument_list|)
operator|&
name|TIC80_OPERAND_MASK
expr_stmt|;
switch|switch
condition|(
name|symtype
condition|)
block|{
case|case
name|TIC80_OPERAND_GPR
case|:
case|case
name|TIC80_OPERAND_FPA
case|:
case|case
name|TIC80_OPERAND_CR
case|:
name|segment
operator|=
name|reg_section
expr_stmt|;
name|valu
operator|=
name|PDS_VALUE
argument_list|(
name|pdsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIC80_OPERAND_CC
case|:
case|case
name|TIC80_OPERAND_BITNUM
case|:
name|segment
operator|=
name|absolute_section
expr_stmt|;
name|valu
operator|=
name|PDS_VALUE
argument_list|(
name|pdsp
argument_list|)
operator|&
operator|~
name|TIC80_OPERAND_MASK
expr_stmt|;
break|break;
default|default:
name|internal_error_a
argument_list|(
name|_
argument_list|(
literal|"unhandled predefined symbol bits"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|symtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|PDS_NAME
argument_list|(
name|pdsp
argument_list|)
argument_list|,
name|segment
argument_list|,
name|valu
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The assembler adds md_shortopts to the string passed to getopt.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The assembler adds md_longopts to the machine independent long options    that are passed to getopt.  */
end_comment

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE)
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
define|#
directive|define
name|OPTION_NO_RELAX
value|(OPTION_RELAX + 1)
block|{
literal|"no-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_RELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The md_parse_option function will be called whenever getopt returns an    unrecognized code, presumably indicating a special code value which    appears in md_longopts for machine specific command line options.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_RELAX
case|:
name|tic80_relax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_RELAX
case|:
name|tic80_relax
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The md_show_usage function will be called whenever a usage message is    printed.  It should print a description of the machine specific options    found in md_longopts.  */
end_comment

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ TIc80 options:\n\ -relax			alter PC relative branch instructions to use long form when needed\n\ -no-relax		always use short PC relative branch instructions, error on overflow\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to simplify or even eliminate a fixup.  The return value is    ignored; perhaps it was once meaningful, but now it is historical.    To indicate that a fixup has been eliminated, set fixP->fx_done.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|dest
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|int
name|overflow
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|R_RELLONGX
case|:
name|md_number_to_chars
argument_list|(
name|dest
argument_list|,
operator|(
name|valueT
operator|)
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MPPCR
case|:
name|val
operator|>>=
literal|2
expr_stmt|;
name|val
operator|+=
literal|1
expr_stmt|;
comment|/* Target address computed from inst start */
name|md_number_to_chars
argument_list|(
name|dest
argument_list|,
operator|(
name|valueT
operator|)
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MPPCR15W
case|:
name|overflow
operator|=
operator|(
name|val
operator|<
operator|-
literal|65536L
operator|)
operator|||
operator|(
name|val
operator|>
literal|65532L
operator|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"PC offset 0x%lx outside range 0x%lx-0x%lx"
argument_list|)
argument_list|,
name|val
argument_list|,
operator|-
literal|65536L
argument_list|,
literal|65532L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|>>=
literal|2
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|*
name|dest
operator|&
literal|0x80
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7F
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|R_ABS
case|:
name|md_number_to_chars
argument_list|(
name|dest
argument_list|,
operator|(
name|valueT
operator|)
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error_a
argument_list|(
name|_
argument_list|(
literal|"unhandled relocation type in fixup"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.     For the TIc80, this is the address of the 32 bit opcode containing    the PC relative field.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|internal_error
argument_list|(
name|_
argument_list|(
literal|"md_convert_frag() not implemented yet"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|tc_coff_symbol_emit_hook
parameter_list|(
name|ignore
parameter_list|)
name|symbolS
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_if
if|#
directive|if
name|defined
name|OBJ_COFF
end_if

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
operator|(
name|fixP
operator|->
name|fx_r_type
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

end_unit

