begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-m32c.c -- Assembler for the Renesas M32C.    Copyright (C) 2005, 2006 Free Software Foundation.    Contributed by RedHat.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/m32c-desc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/m32c-opc.h"
end_include

begin_include
include|#
directive|include
file|"cgen.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32c.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/* Structure to hold all of the different components    describing an individual instruction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|orig_insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
if|#
directive|if
name|CGEN_INT_INSN_P
name|CGEN_INSN_INT
name|buffer
index|[
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(*(buf))
else|#
directive|else
name|unsigned
name|char
name|buffer
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|INSN_VALUE
parameter_list|(
name|buf
parameter_list|)
value|(buf)
endif|#
directive|endif
name|char
modifier|*
name|addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|num_fixups
decl_stmt|;
name|fixS
modifier|*
name|fixups
index|[
name|GAS_CGEN_MAX_FIXUPS
index|]
decl_stmt|;
name|int
name|indices
index|[
name|MAX_OPERAND_INSTANCES
index|]
decl_stmt|;
block|}
name|m32c_insn
typedef|;
end_typedef

begin_define
define|#
directive|define
name|rl_for
parameter_list|(
name|_insn
parameter_list|)
value|(CGEN_ATTR_CGEN_INSN_RL_TYPE_VALUE (&((_insn).insn->base->attrs)))
end_define

begin_define
define|#
directive|define
name|relaxable
parameter_list|(
name|_insn
parameter_list|)
value|(CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE (&((_insn).insn->base->attrs)))
end_define

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|M32C_SHORTOPTS
value|""
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
name|M32C_SHORTOPTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assembler options */
end_comment

begin_define
define|#
directive|define
name|OPTION_CPU_M16C
value|(OPTION_MD_BASE)
end_define

begin_define
define|#
directive|define
name|OPTION_CPU_M32C
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_LINKRELAX
value|(OPTION_MD_BASE + 2)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"m16c"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CPU_M16C
block|}
block|,
block|{
literal|"m32c"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CPU_M32C
block|}
block|,
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LINKRELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default machine */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MACHINE
value|bfd_mach_m16c
end_define

begin_define
define|#
directive|define
name|DEFAULT_FLAGS
value|EF_M32C_CPU_M16C
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|m32c_mach
init|=
name|bfd_mach_m16c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_mach
init|=
operator|(
literal|1
operator|<<
name|MACH_M16C
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|m32c_relax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to set in the elf header */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|m32c_flags
init|=
name|DEFAULT_FLAGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_isa
init|=
literal|1
operator|<<
operator|(
literal|7
operator|-
name|ISA_M16C
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CGEN_BITSET
name|m32c_isa
init|=
block|{
literal|1
block|,
operator|&
name|default_isa
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_isa
parameter_list|(
name|enum
name|isa_attr
name|isa_num
parameter_list|)
block|{
name|cgen_bitset_set
argument_list|(
operator|&
name|m32c_isa
argument_list|,
name|isa_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CPU_M16C
case|:
name|m32c_flags
operator|=
operator|(
name|m32c_flags
operator|&
operator|~
name|EF_M32C_CPU_MASK
operator|)
operator||
name|EF_M32C_CPU_M16C
expr_stmt|;
name|m32c_mach
operator|=
name|bfd_mach_m16c
expr_stmt|;
name|cpu_mach
operator|=
operator|(
literal|1
operator|<<
name|MACH_M16C
operator|)
expr_stmt|;
name|set_isa
argument_list|(
name|ISA_M16C
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_CPU_M32C
case|:
name|m32c_flags
operator|=
operator|(
name|m32c_flags
operator|&
operator|~
name|EF_M32C_CPU_MASK
operator|)
operator||
name|EF_M32C_CPU_M32C
expr_stmt|;
name|m32c_mach
operator|=
name|bfd_mach_m32c
expr_stmt|;
name|cpu_mach
operator|=
operator|(
literal|1
operator|<<
name|MACH_M32C
operator|)
expr_stmt|;
name|set_isa
argument_list|(
name|ISA_M32C
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LINKRELAX
case|:
name|m32c_relax
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" M32C specific command line options:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"3byte"
block|,
name|cons
block|,
literal|3
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the `cgen' interface.  */
comment|/* Set the machine number and endian.  */
name|gas_cgen_cpu_desc
operator|=
name|m32c_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_MACHS
argument_list|,
name|cpu_mach
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|CGEN_ENDIAN_BIG
argument_list|,
name|CGEN_CPU_OPEN_ISAS
argument_list|,
operator|&
name|m32c_isa
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
name|m32c_cgen_init_asm
argument_list|(
name|gas_cgen_cpu_desc
argument_list|)
expr_stmt|;
comment|/* This is a callback from cgen to gas to parse operands.  */
name|cgen_set_parse_operand_fn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|gas_cgen_parse_operand
argument_list|)
expr_stmt|;
comment|/* Set the ELF flags if desired. */
if|if
condition|(
name|m32c_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|m32c_flags
argument_list|)
expr_stmt|;
comment|/* Set the machine type */
name|bfd_default_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_m32c
argument_list|,
name|m32c_mach
argument_list|)
expr_stmt|;
name|insn_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m32c_md_end
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n_nops
decl_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
comment|/* Pad with nops for objdump.  */
name|n_nops
operator|=
operator|(
literal|32
operator|-
operator|(
operator|(
name|insn_size
operator|)
operator|%
literal|32
operator|)
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_nops
condition|;
name|i
operator|++
control|)
name|md_assemble
argument_list|(
literal|"nop"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|m32c_start_line_hook
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* not necessary....handled in the .cpu file */
block|char *s = input_line_pointer;   char *sg;    for (s = input_line_pointer ; s&& s[0] != '\n'; s++)     {       if (s[0] == ':') 	{
comment|/* Remove :g suffix.  Squeeze out blanks.  */
block|if (s[1] == 'g') 	    { 	      for (sg = s - 1; sg&& sg>= input_line_pointer; sg--) 		{ 		  sg[2] = sg[0]; 		} 	      sg[1] = ' '; 	      sg[2] = ' '; 	      input_line_pointer += 2; 	    } 	}     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Process [[indirect-operands]] in instruction str.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_indirect_operand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|new_str
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|ns
decl_stmt|;
name|int
name|ns_len
decl_stmt|;
name|char
modifier|*
name|ns_end
decl_stmt|;
enum|enum
name|indirect_type
block|{
name|none
block|,
name|relative
block|,
name|absolute
block|}
enum|;
name|enum
name|indirect_type
name|indirection
index|[
literal|3
index|]
init|=
block|{
name|none
block|,
name|none
block|,
name|none
block|}
decl_stmt|;
name|int
name|brace_n
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|operand
decl_stmt|;
name|s
operator|=
name|str
expr_stmt|;
name|operand
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|operand
operator|=
literal|2
expr_stmt|;
comment|/* [abs] where abs is not a0 or a1  */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'['
operator|&&
operator|!
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|==
literal|'0'
operator|||
name|s
index|[
literal|3
index|]
operator|==
literal|'1'
operator|)
operator|)
operator|&&
operator|(
name|ISBLANK
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|','
operator|)
condition|)
name|indirection
index|[
name|operand
index|]
operator|=
name|absolute
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|']'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|']'
condition|)
name|indirection
index|[
name|operand
index|]
operator|=
name|relative
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'['
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
name|indirection
index|[
name|operand
index|]
operator|=
name|relative
expr_stmt|;
block|}
if|if
condition|(
name|indirection
index|[
literal|1
index|]
operator|==
name|none
operator|&&
name|indirection
index|[
literal|2
index|]
operator|==
name|none
condition|)
return|return
name|FALSE
return|;
name|operand
operator|=
literal|1
expr_stmt|;
name|ns_len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|new_str
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ns_len
argument_list|)
expr_stmt|;
name|ns
operator|=
name|new_str
expr_stmt|;
name|ns_end
operator|=
name|ns
operator|+
name|ns_len
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|operand
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'['
operator|&&
operator|!
name|brace_n
index|[
name|operand
index|]
condition|)
block|{
name|brace_n
index|[
name|operand
index|]
operator|+=
literal|1
expr_stmt|;
comment|/* Squeeze [[ to [ if this is an indirect operand.  */
if|if
condition|(
name|indirection
index|[
name|operand
index|]
operator|!=
name|none
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'['
operator|&&
name|brace_n
index|[
name|operand
index|]
condition|)
block|{
name|brace_n
index|[
name|operand
index|]
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|']'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|']'
operator|&&
name|indirection
index|[
name|operand
index|]
operator|==
name|relative
condition|)
block|{
name|s
operator|+=
literal|1
expr_stmt|;
comment|/* skip one ].  */
name|brace_n
index|[
name|operand
index|]
operator|-=
literal|2
expr_stmt|;
comment|/* allow for 2 [.  */
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|']'
operator|&&
name|indirection
index|[
name|operand
index|]
operator|==
name|absolute
condition|)
block|{
name|brace_n
index|[
name|operand
index|]
operator|-=
literal|1
expr_stmt|;
continue|continue;
comment|/* skip closing ].  */
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|']'
condition|)
block|{
name|brace_n
index|[
name|operand
index|]
operator|-=
literal|1
expr_stmt|;
block|}
operator|*
name|ns
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|ns
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ns
operator|>=
name|ns_end
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
block|}
operator|*
name|ns
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|operand
operator|=
literal|1
init|;
name|operand
operator|<=
literal|2
condition|;
name|operand
operator|++
control|)
if|if
condition|(
name|brace_n
index|[
name|operand
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unmatched [[operand-%d]] %d\n"
argument_list|,
name|operand
argument_list|,
name|brace_n
index|[
name|operand
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirection
index|[
literal|1
index|]
operator|!=
name|none
operator|&&
name|indirection
index|[
literal|2
index|]
operator|!=
name|none
condition|)
name|md_assemble
argument_list|(
literal|"src-dest-indirect"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indirection
index|[
literal|1
index|]
operator|!=
name|none
condition|)
name|md_assemble
argument_list|(
literal|"src-indirect"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indirection
index|[
literal|2
index|]
operator|!=
name|none
condition|)
name|md_assemble
argument_list|(
literal|"dest-indirect"
argument_list|)
expr_stmt|;
name|md_assemble
argument_list|(
name|new_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_str
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|int
name|last_insn_had_delay_slot
init|=
literal|0
decl_stmt|;
name|m32c_insn
name|insn
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|finished_insnS
name|results
decl_stmt|;
name|int
name|rl_type
decl_stmt|;
if|if
condition|(
name|m32c_mach
operator|==
name|bfd_mach_m32c
operator|&&
name|m32c_indirect_operand
argument_list|(
name|str
argument_list|)
condition|)
return|return;
comment|/* Initialize GAS's cgen interface for a new instruction.  */
name|gas_cgen_init_parse
argument_list|()
expr_stmt|;
name|insn
operator|.
name|insn
operator|=
name|m32c_cgen_assemble_insn
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|str
argument_list|,
operator|&
name|insn
operator|.
name|fields
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|.
name|insn
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|results
operator|.
name|num_fixups
operator|=
literal|0
expr_stmt|;
comment|/* Doesn't really matter what we pass for RELAX_P here.  */
name|gas_cgen_finish_insn
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|insn
operator|.
name|buffer
argument_list|,
name|CGEN_FIELDS_BITSIZE
argument_list|(
operator|&
name|insn
operator|.
name|fields
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|results
argument_list|)
expr_stmt|;
name|last_insn_had_delay_slot
operator|=
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
operator|.
name|insn
argument_list|,
name|CGEN_INSN_DELAY_SLOT
argument_list|)
expr_stmt|;
name|insn_size
operator|=
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
operator|.
name|insn
argument_list|)
expr_stmt|;
name|rl_type
operator|=
name|rl_for
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We have to mark all the jumps, because we need to adjust them      when we delete bytes, but we only need to mark the displacements      if they're symbolic - if they're not, we've already picked the      shortest opcode by now.  The linker, however, will still have to      check any operands to see if they're the displacement type, since      we don't know (nor record) *which* operands are relaxable.  */
if|if
condition|(
name|m32c_relax
operator|&&
name|rl_type
operator|!=
name|RL_TYPE_NONE
operator|&&
operator|(
name|rl_type
operator|==
name|RL_TYPE_JUMP
operator|||
name|results
operator|.
name|num_fixups
operator|)
operator|&&
operator|!
name|relaxable
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|int
name|addend
init|=
name|results
operator|.
name|num_fixups
operator|+
literal|16
operator|*
name|insn_size
operator|/
literal|8
decl_stmt|;
switch|switch
condition|(
name|rl_for
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|RL_TYPE_JUMP
case|:
name|reloc
operator|=
name|BFD_RELOC_M32C_RL_JUMP
expr_stmt|;
break|break;
case|case
name|RL_TYPE_1ADDR
case|:
name|reloc
operator|=
name|BFD_RELOC_M32C_RL_1ADDR
expr_stmt|;
break|break;
case|case
name|RL_TYPE_2ADDR
case|:
name|reloc
operator|=
name|BFD_RELOC_M32C_RL_2ADDR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|insn
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|==
name|M32C_INSN_JMP16_S
operator|||
name|insn
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|==
name|M32C_INSN_JMP32_S
condition|)
name|addend
operator|=
literal|0x10
expr_stmt|;
name|fix_new
argument_list|(
name|results
operator|.
name|frag
argument_list|,
name|results
operator|.
name|addr
operator|-
name|results
operator|.
name|frag
operator|->
name|fr_literal
argument_list|,
literal|0
argument_list|,
name|abs_section_sym
argument_list|,
name|addend
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The syntax in the manual says constants begin with '#'.    We just ignore it.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
comment|/* In case of a syntax error, escape back to try next syntax combo. */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|gas_cgen_md_operand
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* The fields are:      1) most positive reach of this state,      2) most negative reach of this state,      3) how many bytes this mode will have in the variable part of the frag      4) which index into the table to try if we can't fit into this one.  */
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused */
comment|/* 1 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* marker for "don't know yet" */
comment|/* 2 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|2
block|,
literal|3
block|}
block|,
comment|/* jcnd16_5.b */
comment|/* 3 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* jcnd16_5.w */
comment|/* 4 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* jcnd16_5.a */
comment|/* 5 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* jcnd16.b */
comment|/* 6 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|5
block|,
literal|7
block|}
block|,
comment|/* jcnd16.w */
comment|/* 7 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* jcnd16.a */
comment|/* 8 */
block|{
literal|8
block|,
literal|1
block|,
literal|1
block|,
literal|9
block|}
block|,
comment|/* jmp16.s */
comment|/* 9 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|2
block|,
literal|10
block|}
block|,
comment|/* jmp16.b */
comment|/* 10 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|3
block|,
literal|11
block|}
block|,
comment|/* jmp16.w */
comment|/* 11 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* jmp16.a */
comment|/* 12 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|2
block|,
literal|13
block|}
block|,
comment|/* jcnd32.b */
comment|/* 13 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|5
block|,
literal|14
block|}
block|,
comment|/* jcnd32.w */
comment|/* 14 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* jcnd32.a */
comment|/* 15 */
block|{
literal|8
block|,
literal|1
block|,
literal|1
block|,
literal|16
block|}
block|,
comment|/* jmp32.s */
comment|/* 16 */
block|{
literal|127
block|,
operator|-
literal|128
block|,
literal|2
block|,
literal|17
block|}
block|,
comment|/* jmp32.b */
comment|/* 17 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|3
block|,
literal|18
block|}
block|,
comment|/* jmp32.w */
comment|/* 18 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* jmp32.a */
comment|/* 19 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|3
block|,
literal|20
block|}
block|,
comment|/* jsr16.w */
comment|/* 20 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* jsr16.a */
comment|/* 21 */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|3
block|,
literal|11
block|}
block|,
comment|/* jsr32.w */
comment|/* 22 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* jsr32.a */
comment|/* 23 */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
comment|/* adjnz pc8 */
comment|/* 24 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* adjnz disp8 pc8 */
comment|/* 25 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* adjnz disp16 pc8 */
comment|/* 26 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
comment|/* adjnz disp24 pc8 */
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|M32C_MACRO_JCND16_5_W
block|,
name|M32C_MACRO_JCND16_5_A
block|,
name|M32C_MACRO_JCND16_W
block|,
name|M32C_MACRO_JCND16_A
block|,
name|M32C_MACRO_JCND32_W
block|,
name|M32C_MACRO_JCND32_A
block|,
comment|/* the digit is the array index of the pcrel byte */
name|M32C_MACRO_ADJNZ_2
block|,
name|M32C_MACRO_ADJNZ_3
block|,
name|M32C_MACRO_ADJNZ_4
block|,
name|M32C_MACRO_ADJNZ_5
block|, }
name|M32C_Macros
enum|;
end_enum

begin_struct
specifier|static
struct|struct
block|{
name|int
name|insn
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|insn_for_extern
decl_stmt|;
name|int
name|pcrel_aim_offset
decl_stmt|;
block|}
name|subtype_mappings
index|[]
init|=
block|{
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|M32C_INSN_JCND16_5
block|,
literal|2
block|,
operator|-
name|M32C_MACRO_JCND16_5_A
block|,
literal|1
block|}
block|,
comment|/* 3 */
block|{
operator|-
name|M32C_MACRO_JCND16_5_W
block|,
literal|5
block|,
operator|-
name|M32C_MACRO_JCND16_5_A
block|,
literal|4
block|}
block|,
comment|/* 4 */
block|{
operator|-
name|M32C_MACRO_JCND16_5_A
block|,
literal|6
block|,
operator|-
name|M32C_MACRO_JCND16_5_A
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
name|M32C_INSN_JCND16
block|,
literal|3
block|,
operator|-
name|M32C_MACRO_JCND16_A
block|,
literal|1
block|}
block|,
comment|/* 6 */
block|{
operator|-
name|M32C_MACRO_JCND16_W
block|,
literal|6
block|,
operator|-
name|M32C_MACRO_JCND16_A
block|,
literal|4
block|}
block|,
comment|/* 7 */
block|{
operator|-
name|M32C_MACRO_JCND16_A
block|,
literal|7
block|,
operator|-
name|M32C_MACRO_JCND16_A
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
name|M32C_INSN_JMP16_S
block|,
literal|1
block|,
name|M32C_INSN_JMP16_A
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
name|M32C_INSN_JMP16_B
block|,
literal|2
block|,
name|M32C_INSN_JMP16_A
block|,
literal|1
block|}
block|,
comment|/* 10 */
block|{
name|M32C_INSN_JMP16_W
block|,
literal|3
block|,
name|M32C_INSN_JMP16_A
block|,
literal|2
block|}
block|,
comment|/* 11 */
block|{
name|M32C_INSN_JMP16_A
block|,
literal|4
block|,
name|M32C_INSN_JMP16_A
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
name|M32C_INSN_JCND32
block|,
literal|2
block|,
operator|-
name|M32C_MACRO_JCND32_A
block|,
literal|1
block|}
block|,
comment|/* 13 */
block|{
operator|-
name|M32C_MACRO_JCND32_W
block|,
literal|5
block|,
operator|-
name|M32C_MACRO_JCND32_A
block|,
literal|4
block|}
block|,
comment|/* 14 */
block|{
operator|-
name|M32C_MACRO_JCND32_A
block|,
literal|6
block|,
operator|-
name|M32C_MACRO_JCND32_A
block|,
literal|0
block|}
block|,
comment|/* 15 */
block|{
name|M32C_INSN_JMP32_S
block|,
literal|1
block|,
name|M32C_INSN_JMP32_A
block|,
literal|0
block|}
block|,
comment|/* 16 */
block|{
name|M32C_INSN_JMP32_B
block|,
literal|2
block|,
name|M32C_INSN_JMP32_A
block|,
literal|1
block|}
block|,
comment|/* 17 */
block|{
name|M32C_INSN_JMP32_W
block|,
literal|3
block|,
name|M32C_INSN_JMP32_A
block|,
literal|2
block|}
block|,
comment|/* 18 */
block|{
name|M32C_INSN_JMP32_A
block|,
literal|4
block|,
name|M32C_INSN_JMP32_A
block|,
literal|0
block|}
block|,
comment|/* 19 */
block|{
name|M32C_INSN_JSR16_W
block|,
literal|3
block|,
name|M32C_INSN_JSR16_A
block|,
literal|2
block|}
block|,
comment|/* 20 */
block|{
name|M32C_INSN_JSR16_A
block|,
literal|4
block|,
name|M32C_INSN_JSR16_A
block|,
literal|0
block|}
block|,
comment|/* 21 */
block|{
name|M32C_INSN_JSR32_W
block|,
literal|3
block|,
name|M32C_INSN_JSR32_A
block|,
literal|2
block|}
block|,
comment|/* 22 */
block|{
name|M32C_INSN_JSR32_A
block|,
literal|4
block|,
name|M32C_INSN_JSR32_A
block|,
literal|0
block|}
block|,
comment|/* 23 */
block|{
operator|-
name|M32C_MACRO_ADJNZ_2
block|,
literal|3
block|,
operator|-
name|M32C_MACRO_ADJNZ_2
block|,
literal|0
block|}
block|,
comment|/* 24 */
block|{
operator|-
name|M32C_MACRO_ADJNZ_3
block|,
literal|4
block|,
operator|-
name|M32C_MACRO_ADJNZ_3
block|,
literal|0
block|}
block|,
comment|/* 25 */
block|{
operator|-
name|M32C_MACRO_ADJNZ_4
block|,
literal|5
block|,
operator|-
name|M32C_MACRO_ADJNZ_4
block|,
literal|0
block|}
block|,
comment|/* 26 */
block|{
operator|-
name|M32C_MACRO_ADJNZ_5
block|,
literal|6
block|,
operator|-
name|M32C_MACRO_ADJNZ_5
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_MAPPINGS
value|(sizeof (subtype_mappings) / sizeof (subtype_mappings[0]))
end_define

begin_function
name|void
name|m32c_prepare_relax_scan
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|offsetT
modifier|*
name|aim
parameter_list|,
name|relax_substateT
name|this_state
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
if|if
condition|(
name|symbolP
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
operator|*
name|aim
operator|=
literal|0
expr_stmt|;
comment|/* Adjust for m32c pcrel not being relative to the next opcode.  */
operator|*
name|aim
operator|+=
name|subtype_mappings
index|[
name|this_state
index|]
operator|.
name|pcrel_aim_offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|insn_to_subtype
parameter_list|(
name|int
name|inum
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|strncmp
argument_list|(
name|insn
operator|->
name|base
operator|->
name|mnemonic
argument_list|,
literal|"adjnz"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|insn
operator|->
name|base
operator|->
name|mnemonic
argument_list|,
literal|"sbjnz"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|=
literal|23
operator|+
name|insn
operator|->
name|base
operator|->
name|bitsize
operator|/
literal|8
operator|-
literal|3
expr_stmt|;
comment|/*printf("mapping %d used for %s\n", i, insn->base->mnemonic);*/
return|return
name|i
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MAPPINGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inum
operator|==
name|subtype_mappings
index|[
name|i
index|]
operator|.
name|insn
condition|)
block|{
comment|/*printf("mapping %d used\n", i);*/
return|return
name|i
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an initial guess of the length by which a fragment must grow to    hold a branch to reach its destination.    Also updates fr_type/fr_subtype as necessary.     Called just before doing relaxation.    Any symbol that is now undefined will not become defined.    The guess for fr_var is ACTUALLY the growth beyond fr_fix.    Whatever we do to grow fr_fix or fr_var contributes to our returned value.    Although it may not be explicit in the frag, pretend fr_var starts with a    0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|where
init|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|insn_to_subtype
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
name|int
name|new_insn
decl_stmt|;
name|new_insn
operator|=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn_for_extern
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|insn_to_subtype
argument_list|(
name|new_insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|&&
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|!=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
operator|&&
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
operator|>
literal|0
condition|)
block|{
name|int
name|new_insn
init|=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
decl_stmt|;
if|if
condition|(
name|new_insn
operator|>=
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
operator|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|-
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|num
operator|+
name|new_insn
operator|)
expr_stmt|;
block|}
block|}
return|return
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|bytes
operator|-
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
name|where
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size.     Called after relaxation is finished.    fragP->fr_type == rs_machine_dependent.    fragP->fr_subtype is the subtype of what the address relaxed to.  */
end_comment

begin_function
specifier|static
name|int
name|target_address_for
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
name|int
name|rv
init|=
name|frag
operator|->
name|fr_offset
decl_stmt|;
name|symbolS
modifier|*
name|sym
init|=
name|frag
operator|->
name|fr_symbol
decl_stmt|;
if|if
condition|(
name|sym
condition|)
name|rv
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/*printf("target_address_for returns %d\n", rv);*/
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|addend
decl_stmt|;
name|int
name|operand
decl_stmt|;
name|int
name|new_insn
decl_stmt|;
name|int
name|where
init|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|int
name|rl_where
init|=
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
decl_stmt|;
name|int
name|op_base
init|=
literal|0
decl_stmt|;
name|int
name|op_op
init|=
literal|0
decl_stmt|;
name|int
name|rl_addend
init|=
literal|0
decl_stmt|;
name|addend
operator|=
name|target_address_for
argument_list|(
name|fragP
argument_list|)
operator|-
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
operator|)
expr_stmt|;
name|new_insn
operator|=
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|=
name|where
operator|+
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|bytes
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|subtype_mappings
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|insn
condition|)
block|{
case|case
name|M32C_INSN_JCND16_5
case|:
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_8
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x21
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND16_5_W
case|:
name|op
index|[
literal|0
index|]
operator|^=
literal|0x04
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0xf4
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|addend
operator|-
literal|3
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
operator|(
name|addend
operator|-
literal|3
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP16_W
expr_stmt|;
name|op_base
operator|=
literal|2
expr_stmt|;
name|op_op
operator|=
literal|3
expr_stmt|;
name|rl_addend
operator|=
literal|0x51
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND16_5_A
case|:
name|op
index|[
literal|0
index|]
operator|^=
literal|0x04
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|5
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0xfc
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP16_A
expr_stmt|;
name|op_base
operator|=
literal|2
expr_stmt|;
name|op_op
operator|=
literal|3
expr_stmt|;
name|rl_addend
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JCND16
case|:
name|op
index|[
literal|2
index|]
operator|=
name|addend
operator|-
literal|2
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_16_8
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|2
expr_stmt|;
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND16_W
case|:
name|op
index|[
literal|1
index|]
operator|^=
literal|0x04
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|4
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0xf4
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|addend
operator|-
literal|4
expr_stmt|;
name|op
index|[
literal|5
index|]
operator|=
operator|(
name|addend
operator|-
literal|4
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|where
operator|+=
literal|3
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP16_W
expr_stmt|;
name|op_base
operator|=
literal|3
expr_stmt|;
name|op_op
operator|=
literal|4
expr_stmt|;
name|rl_addend
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND16_A
case|:
name|op
index|[
literal|1
index|]
operator|^=
literal|0x04
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|5
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0xfc
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|where
operator|+=
literal|3
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP16_A
expr_stmt|;
name|op_base
operator|=
literal|3
expr_stmt|;
name|op_op
operator|=
literal|4
expr_stmt|;
name|rl_addend
operator|=
literal|0x71
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP16_S
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0x60
operator||
operator|(
operator|(
name|addend
operator|-
literal|2
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_5_3
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|0
expr_stmt|;
name|rl_addend
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP16_B
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xfe
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_8
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x21
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP16_W
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xf4
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|addend
operator|-
literal|1
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP16_A
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xfc
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x41
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JCND32
case|:
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_8
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x21
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND32_W
case|:
name|op
index|[
literal|0
index|]
operator|^=
literal|0x40
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0xce
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|addend
operator|-
literal|3
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
operator|(
name|addend
operator|-
literal|3
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP32_W
expr_stmt|;
name|op_base
operator|=
literal|2
expr_stmt|;
name|op_op
operator|=
literal|3
expr_stmt|;
name|rl_addend
operator|=
literal|0x51
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_JCND32_A
case|:
name|op
index|[
literal|0
index|]
operator|^=
literal|0x40
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|5
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0xcc
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|new_insn
operator|=
name|M32C_INSN_JMP32_A
expr_stmt|;
name|op_base
operator|=
literal|2
expr_stmt|;
name|op_op
operator|=
literal|3
expr_stmt|;
name|rl_addend
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP32_S
case|:
name|addend
operator|=
operator|(
operator|(
name|addend
operator|-
literal|2
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
literal|0x4a
operator||
operator|(
name|addend
operator|&
literal|0x01
operator|)
operator||
operator|(
operator|(
name|addend
operator|<<
literal|3
operator|)
operator|&
literal|0x30
operator|)
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB32_JMP_S
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|0
expr_stmt|;
name|rl_addend
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP32_B
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xbb
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_8
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x21
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP32_W
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xce
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|addend
operator|-
literal|1
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JMP32_A
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xcc
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x41
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JSR16_W
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xf5
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|addend
operator|-
literal|1
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JSR16_A
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xfd
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x41
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JSR32_W
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xcf
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|addend
operator|-
literal|1
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|addend
operator|-
literal|1
operator|)
operator|>>
literal|8
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_16
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
break|break;
case|case
name|M32C_INSN_JSR32_A
case|:
name|op
index|[
literal|0
index|]
operator|=
literal|0xcd
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_8_24
expr_stmt|;
name|op_base
operator|=
literal|0
expr_stmt|;
name|op_op
operator|=
literal|1
expr_stmt|;
name|rl_addend
operator|=
literal|0x41
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_ADJNZ_2
case|:
name|rl_addend
operator|=
literal|0x31
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|addend
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_16_8
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_ADJNZ_3
case|:
name|rl_addend
operator|=
literal|0x41
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|addend
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_24_8
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_ADJNZ_4
case|:
name|rl_addend
operator|=
literal|0x51
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|addend
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_32_8
expr_stmt|;
break|break;
case|case
operator|-
name|M32C_MACRO_ADJNZ_5
case|:
name|rl_addend
operator|=
literal|0x61
expr_stmt|;
name|op
index|[
literal|5
index|]
operator|=
name|addend
expr_stmt|;
name|operand
operator|=
name|M32C_OPERAND_LAB_40_8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\nHey!  Need more opcode converters! missing: %d %s\n\n"
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|->
name|base
operator|->
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|m32c_relax
condition|)
block|{
if|if
condition|(
name|operand
operator|!=
name|M32C_OPERAND_LAB_8_24
condition|)
name|fragP
operator|->
name|fr_offset
operator|=
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|rl_where
argument_list|,
literal|0
argument_list|,
name|abs_section_sym
argument_list|,
name|rl_addend
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_M32C_RL_JUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|sec
operator|||
name|operand
operator|==
name|M32C_OPERAND_LAB_8_24
operator|||
operator|(
name|m32c_relax
operator|&&
operator|(
name|operand
operator|!=
name|M32C_OPERAND_LAB_5_3
operator|&&
name|operand
operator|!=
name|M32C_OPERAND_LAB32_JMP_S
operator|)
operator|)
condition|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|gas_cgen_record_fixup
argument_list|(
name|fragP
argument_list|,
name|where
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|insn
argument_list|,
operator|(
name|fragP
operator|->
name|fr_fix
operator|-
name|where
operator|)
operator|*
literal|8
argument_list|,
name|cgen_operand_lookup_by_num
argument_list|(
name|gas_cgen_cpu_desc
argument_list|,
name|operand
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_cgen
operator|.
name|opinfo
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|sec
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
comment|/* The symbol is undefined (or is defined but not in this section).        Let the linker figure it out.  */
return|return
literal|0
return|;
return|return
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.    Returns BFD_RELOC_NONE if no reloc type can be found.    *FIXP may be modified if desired.  */
end_comment

begin_function
name|bfd_reloc_code_real_type
name|md_cgen_lookup_reloc
parameter_list|(
specifier|const
name|CGEN_INSN
modifier|*
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|CGEN_OPERAND
modifier|*
name|operand
parameter_list|,
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|op_reloc
block|{
comment|/* A CGEN operand type that can be a relocatable expression.  */
name|CGEN_OPERAND_TYPE
name|operand
decl_stmt|;
comment|/* The appropriate BFD reloc type to use for that.  */
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
comment|/* The offset from the start of the instruction to the field to be        relocated, in bytes.  */
name|int
name|offset
decl_stmt|;
block|}
name|op_reloc_table
index|[]
init|=
block|{
comment|/* PC-REL relocs for 8-bit fields.  */
block|{
name|M32C_OPERAND_LAB_8_8
block|,
name|BFD_RELOC_8_PCREL
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_LAB_16_8
block|,
name|BFD_RELOC_8_PCREL
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_LAB_24_8
block|,
name|BFD_RELOC_8_PCREL
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_LAB_32_8
block|,
name|BFD_RELOC_8_PCREL
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_LAB_40_8
block|,
name|BFD_RELOC_8_PCREL
block|,
literal|5
block|}
block|,
comment|/* PC-REL relocs for 16-bit fields.  */
block|{
name|M32C_OPERAND_LAB_8_16
block|,
name|BFD_RELOC_16_PCREL
block|,
literal|1
block|}
block|,
comment|/* Absolute relocs for 8-bit fields.  */
block|{
name|M32C_OPERAND_IMM_8_QI
block|,
name|BFD_RELOC_8
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_IMM_16_QI
block|,
name|BFD_RELOC_8
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_IMM_24_QI
block|,
name|BFD_RELOC_8
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_IMM_32_QI
block|,
name|BFD_RELOC_8
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_IMM_40_QI
block|,
name|BFD_RELOC_8
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_IMM_48_QI
block|,
name|BFD_RELOC_8
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_IMM_56_QI
block|,
name|BFD_RELOC_8
block|,
literal|7
block|}
block|,
block|{
name|M32C_OPERAND_DSP_8_S8
block|,
name|BFD_RELOC_8
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_S8
block|,
name|BFD_RELOC_8
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_S8
block|,
name|BFD_RELOC_8
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_S8
block|,
name|BFD_RELOC_8
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_DSP_40_S8
block|,
name|BFD_RELOC_8
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_DSP_48_S8
block|,
name|BFD_RELOC_8
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_DSP_8_U8
block|,
name|BFD_RELOC_8
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_U8
block|,
name|BFD_RELOC_8
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_U8
block|,
name|BFD_RELOC_8
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_U8
block|,
name|BFD_RELOC_8
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_DSP_40_U8
block|,
name|BFD_RELOC_8
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_DSP_48_U8
block|,
name|BFD_RELOC_8
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_16_S11_UNPREFIXED
block|,
name|BFD_RELOC_8
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_16_U11_UNPREFIXED
block|,
name|BFD_RELOC_8
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_24_S11_PREFIXED
block|,
name|BFD_RELOC_8
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_24_U11_PREFIXED
block|,
name|BFD_RELOC_8
block|,
literal|3
block|}
block|,
comment|/* Absolute relocs for 16-bit fields.  */
block|{
name|M32C_OPERAND_IMM_8_HI
block|,
name|BFD_RELOC_16
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_IMM_16_HI
block|,
name|BFD_RELOC_16
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_IMM_24_HI
block|,
name|BFD_RELOC_16
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_IMM_32_HI
block|,
name|BFD_RELOC_16
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_IMM_40_HI
block|,
name|BFD_RELOC_16
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_IMM_48_HI
block|,
name|BFD_RELOC_16
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_IMM_56_HI
block|,
name|BFD_RELOC_16
block|,
literal|7
block|}
block|,
block|{
name|M32C_OPERAND_IMM_64_HI
block|,
name|BFD_RELOC_16
block|,
literal|8
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_S16
block|,
name|BFD_RELOC_16
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_S16
block|,
name|BFD_RELOC_16
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_S16
block|,
name|BFD_RELOC_16
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_DSP_40_S16
block|,
name|BFD_RELOC_16
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_DSP_8_U16
block|,
name|BFD_RELOC_16
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_U16
block|,
name|BFD_RELOC_16
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_U16
block|,
name|BFD_RELOC_16
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_U16
block|,
name|BFD_RELOC_16
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_DSP_40_U16
block|,
name|BFD_RELOC_16
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_DSP_48_U16
block|,
name|BFD_RELOC_16
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_16_S19_UNPREFIXED
block|,
name|BFD_RELOC_16
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_16_U19_UNPREFIXED
block|,
name|BFD_RELOC_16
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_24_S19_PREFIXED
block|,
name|BFD_RELOC_16
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_24_U19_PREFIXED
block|,
name|BFD_RELOC_16
block|,
literal|3
block|}
block|,
comment|/* Absolute relocs for 24-bit fields.  */
block|{
name|M32C_OPERAND_LAB_8_24
block|,
name|BFD_RELOC_24
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_8_S24
block|,
name|BFD_RELOC_24
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_8_U24
block|,
name|BFD_RELOC_24
block|,
literal|1
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_U24
block|,
name|BFD_RELOC_24
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_U24
block|,
name|BFD_RELOC_24
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_U24
block|,
name|BFD_RELOC_24
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_DSP_40_U24
block|,
name|BFD_RELOC_24
block|,
literal|5
block|}
block|,
block|{
name|M32C_OPERAND_DSP_48_U24
block|,
name|BFD_RELOC_24
block|,
literal|6
block|}
block|,
block|{
name|M32C_OPERAND_DSP_16_U20
block|,
name|BFD_RELOC_24
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_DSP_24_U20
block|,
name|BFD_RELOC_24
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_DSP_32_U20
block|,
name|BFD_RELOC_24
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_16_U27_UNPREFIXED
block|,
name|BFD_RELOC_24
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_BITBASE32_24_U27_PREFIXED
block|,
name|BFD_RELOC_24
block|,
literal|3
block|}
block|,
comment|/* Absolute relocs for 32-bit fields.  */
block|{
name|M32C_OPERAND_IMM_16_SI
block|,
name|BFD_RELOC_32
block|,
literal|2
block|}
block|,
block|{
name|M32C_OPERAND_IMM_24_SI
block|,
name|BFD_RELOC_32
block|,
literal|3
block|}
block|,
block|{
name|M32C_OPERAND_IMM_32_SI
block|,
name|BFD_RELOC_32
block|,
literal|4
block|}
block|,
block|{
name|M32C_OPERAND_IMM_40_SI
block|,
name|BFD_RELOC_32
block|,
literal|5
block|}
block|,    }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|op_reloc_table
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
specifier|const
name|struct
name|op_reloc
modifier|*
name|or
init|=
operator|&
name|op_reloc_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|or
operator|->
name|operand
operator|==
name|operand
operator|->
name|type
condition|)
block|{
name|fixP
operator|->
name|fx_where
operator|+=
name|or
operator|->
name|offset
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|-=
name|or
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|&&
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|!=
name|BFD_RELOC_NONE
condition|)
return|return
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
return|;
return|return
name|or
operator|->
name|reloc
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: tc-m32c.c:md_cgen_lookup_reloc Unimplemented relocation for operand %s\n"
argument_list|,
name|operand
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_NONE
return|;
block|}
end_function

begin_function
name|void
name|m32c_cons_fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|type
operator|=
name|BFD_RELOC_24
expr_stmt|;
break|break;
case|case
literal|4
case|:
default|default:
name|type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m32c_apply_fix
parameter_list|(
name|struct
name|fix
modifier|*
name|f
parameter_list|,
name|valueT
modifier|*
name|t
parameter_list|,
name|segT
name|s
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_JUMP
operator|||
name|f
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_1ADDR
operator|||
name|f
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_2ADDR
condition|)
return|return;
name|gas_cgen_md_apply_fix
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|fixS
modifier|*
name|fx
parameter_list|)
block|{
if|if
condition|(
name|fx
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_JUMP
operator|||
name|fx
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_1ADDR
operator|||
name|fx
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M32C_RL_2ADDR
condition|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fx
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fx
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fx
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fx
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fx
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
return|return
name|gas_cgen_tc_gen_reloc
argument_list|(
name|sec
argument_list|,
name|fx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|m32c_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|int
name|reloc
init|=
name|fixp
operator|->
name|fx_r_type
decl_stmt|;
if|if
condition|(
name|reloc
operator|>
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc
operator|-=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|M32C_OPERAND_DSP_32_S16
case|:
case|case
name|M32C_OPERAND_DSP_32_U16
case|:
case|case
name|M32C_OPERAND_IMM_32_HI
case|:
case|case
name|M32C_OPERAND_DSP_16_S16
case|:
case|case
name|M32C_OPERAND_DSP_16_U16
case|:
case|case
name|M32C_OPERAND_IMM_16_HI
case|:
case|case
name|M32C_OPERAND_DSP_24_S16
case|:
case|case
name|M32C_OPERAND_DSP_24_U16
case|:
case|case
name|M32C_OPERAND_IMM_24_HI
case|:
return|return
literal|1
return|;
comment|/* If we're doing linker relaxing, we need to keep all the 	   pc-relative jumps in case we need to fix them due to 	   deleted bytes between the jump and its destination.  */
case|case
name|M32C_OPERAND_LAB_8_8
case|:
case|case
name|M32C_OPERAND_LAB_8_16
case|:
case|case
name|M32C_OPERAND_LAB_8_24
case|:
case|case
name|M32C_OPERAND_LAB_16_8
case|:
case|case
name|M32C_OPERAND_LAB_24_8
case|:
case|case
name|M32C_OPERAND_LAB_32_8
case|:
case|case
name|M32C_OPERAND_LAB_40_8
case|:
if|if
condition|(
name|m32c_relax
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
return|return
literal|1
return|;
case|case
name|BFD_RELOC_M32C_RL_JUMP
case|:
case|case
name|BFD_RELOC_M32C_RL_1ADDR
case|:
case|case
name|BFD_RELOC_M32C_RL_2ADDR
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
if|if
condition|(
name|m32c_relax
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a value out to the object file, using the appropriate endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* FIXME: Some targets allow other format chars for bigger sizes here.  */
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to md_atof()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|m32c_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|int
name|reloc
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
name|reloc
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|reloc
operator|>
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc
operator|-=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|M32C_OPERAND_DSP_32_S16
case|:
case|case
name|M32C_OPERAND_DSP_32_U16
case|:
case|case
name|M32C_OPERAND_IMM_32_HI
case|:
case|case
name|M32C_OPERAND_DSP_16_S16
case|:
case|case
name|M32C_OPERAND_DSP_16_U16
case|:
case|case
name|M32C_OPERAND_IMM_16_HI
case|:
case|case
name|M32C_OPERAND_DSP_24_S16
case|:
case|case
name|M32C_OPERAND_DSP_24_U16
case|:
case|case
name|M32C_OPERAND_IMM_24_HI
case|:
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
condition|)
return|return
literal|0
return|;
block|}
comment|/* Do not adjust relocations involving symbols in merged sections.       A reloc patching in the value of some symbol S plus some addend A      can be produced in different ways:       1) It might simply be a reference to the data at S + A.  Clearly,         if linker merging shift that data around, the value patched in         by the reloc needs to be adjusted accordingly.       2) Or, it might be a reference to S, with A added in as a constant 	bias.  For example, given code like this:  	  static int S[100];  	  ... S[i - 8] ...  	it would be reasonable for the compiler to rearrange the array 	reference to something like:  	  ... (S-8)[i] ...  	and emit assembly code that refers to S - (8 * sizeof (int)), 	so the subtraction is done entirely at compile-time.  In this 	case, the reloc's addend A would be -(8 * sizeof (int)), and 	shifting around code or data at S + A should not affect the 	reloc: the reloc isn't referring to that code or data at all.       The linker has no way of knowing which case it has in hand.  So,      to disambiguate, we have the linker always treat reloc addends as      in case 2): they're constants that should be simply added to the      symbol value, just like the reloc says.  And we express case 1)      in different way: we have the compiler place a label at the real      target, and reference that label with an addend of zero.  (The      compiler is unlikely to reference code using a label plus an      offset anyway, since it doesn't know the sizes of the      instructions.)       The simplification being done by gas/write.c:adjust_reloc_syms,      however, turns the explicit-label usage into the label-plus-      offset usage, re-introducing the ambiguity the compiler avoided.      So we need to disable that simplification for symbols referring      to merged data.       This only affects object size a little bit.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|m32c_relax
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Worker function for m32c_is_colon_insn().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|restore_colon
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
name|restore_colon
parameter_list|(
name|int
name|advance_i_l_p_by
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
comment|/* Restore the colon, and advance input_line_pointer to      the end of the new symbol.  */
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|input_line_pointer
operator|+=
name|advance_i_l_p_by
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Determines if the symbol starting at START and ending in    a colon that was at the location pointed to by INPUT_LINE_POINTER    (but which has now been replaced bu a NUL) is in fact an    :Z, :S, :Q, or :G suffix.    If it is, then it restores the colon, advances INPUT_LINE_POINTER    to the real end of the instruction/symbol, and returns the character    that really terminated the symbol.  Otherwise it returns 0.  */
end_comment

begin_function
name|char
name|m32c_is_colon_insn
parameter_list|(
name|char
modifier|*
name|start
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|i_l_p
init|=
name|input_line_pointer
decl_stmt|;
comment|/* Check to see if the text following the colon is 'G' */
if|if
condition|(
name|TOLOWER
argument_list|(
name|i_l_p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|2
argument_list|)
return|;
comment|/* Check to see if the text following the colon is 'Q' */
if|if
condition|(
name|TOLOWER
argument_list|(
name|i_l_p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'q'
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|2
argument_list|)
return|;
comment|/* Check to see if the text following the colon is 'S' */
if|if
condition|(
name|TOLOWER
argument_list|(
name|i_l_p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'s'
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|2
argument_list|)
return|;
comment|/* Check to see if the text following the colon is 'Z' */
if|if
condition|(
name|TOLOWER
argument_list|(
name|i_l_p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'z'
operator|&&
operator|(
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|i_l_p
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|restore_colon
argument_list|(
literal|2
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

