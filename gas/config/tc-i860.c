begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-i860.c -- Assembler for the Intel i860 architecture.    Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     Brought back from the dead and completely reworked    by Jason Eckhardt<jle@cygnus.com>.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with GAS; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i860.h"
end_include

begin_include
include|#
directive|include
file|"elf/i860.h"
end_include

begin_comment
comment|/* The opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These characters always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#!/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These characters start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to separate the mantissa from the exponent    in floating point numbers.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that indicate this number is a floating point constant.    As in 0f12.456 or 0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register prefix (depends on syntax).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reg_prefix
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_FIXUPS
value|2
end_define

begin_struct
struct|struct
name|i860_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|enum
name|expand_type
name|expand
decl_stmt|;
struct|struct
name|i860_fi
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|valueT
name|fup
decl_stmt|;
block|}
name|fi
index|[
name|MAX_FIXUPS
index|]
struct|;
block|}
name|the_insn
struct|;
end_struct

begin_comment
comment|/* The current fixup count.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates error if a pseudo operation was expanded after a branch.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_expand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true, then warn if any pseudo operations were expanded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_warn_expand
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true, then XP support is enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_xp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true, then Intel syntax is enabled (default to AT&T/SVR4 syntax).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_intel_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|i860_process_insn
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_dual
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_enddual
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_atmp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_align_wrapper
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i860_get_expression
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_code_real_type
name|obtain_reloc_for_imm16
parameter_list|(
name|fixS
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_I860
end_ifdef

begin_function_decl
specifier|static
name|void
name|print_insn
parameter_list|(
name|struct
name|i860_it
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_wrapper
block|,
literal|0
block|}
block|,
block|{
literal|"dual"
block|,
name|s_dual
block|,
literal|0
block|}
block|,
block|{
literal|"enddual"
block|,
name|s_enddual
block|,
literal|0
block|}
block|,
block|{
literal|"atmp"
block|,
name|s_atmp
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dual-instruction mode handling.  */
end_comment

begin_enum
enum|enum
name|dual
block|{
name|DUAL_OFF
init|=
literal|0
block|,
name|DUAL_ON
block|,
name|DUAL_DDOT
block|,
name|DUAL_ONDDOT
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|dual
name|dual_mode
init|=
name|DUAL_OFF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle ".dual" directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_dual
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|target_intel_syntax
condition|)
name|dual_mode
operator|=
name|DUAL_ON
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Directive .dual available only with -mintel-syntax option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle ".enddual" directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_enddual
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|target_intel_syntax
condition|)
name|dual_mode
operator|=
name|DUAL_OFF
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Directive .enddual available only with -mintel-syntax option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporary register used when expanding assembler pseudo operations.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atmp
init|=
literal|31
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s_atmp
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|target_intel_syntax
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Directive .atmp available only with -mintel-syntax option"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"sp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|atmp
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"fp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|atmp
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"r"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|1
expr_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|0
operator|&&
name|temp
operator|<=
literal|31
condition|)
name|atmp
operator|=
name|temp
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown temporary pseudo register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown temporary pseudo register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle ".align" directive depending on syntax mode.    AT&T/SVR4 syntax uses the standard align directive.  However,     the Intel syntax additionally allows keywords for the alignment    parameter: ".align type", where type is one of {.short, .long,    .quad, .single, .double} representing alignments of 2, 4,    16, 4, and 8, respectively.  */
end_comment

begin_function
specifier|static
name|void
name|s_align_wrapper
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|parm
init|=
name|input_line_pointer
decl_stmt|;
if|if
condition|(
name|target_intel_syntax
condition|)
block|{
comment|/* Replace a keyword with the equivalent integer so the          standard align routine can parse the directive.  */
if|if
condition|(
name|strncmp
argument_list|(
name|parm
argument_list|,
literal|".short"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|parm
argument_list|,
literal|"     2"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|parm
argument_list|,
literal|".long"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|parm
argument_list|,
literal|"    4"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|parm
argument_list|,
literal|".quad"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|parm
argument_list|,
literal|"   16"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|parm
argument_list|,
literal|".single"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|parm
argument_list|,
literal|"      4"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|parm
argument_list|,
literal|".double"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|parm
argument_list|,
literal|"      8"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|s_align_bytes
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables and data structures that the MD part of the    assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|i860_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|lose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: losing opcode: `%s' \"%s\"\n"
argument_list|)
argument_list|,
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|i860_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Defective assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the register prefix for either Intel or AT&T/SVR4 syntax.  */
name|reg_prefix
operator|=
name|target_intel_syntax
condition|?
literal|0
else|:
literal|'%'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the core of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function emits the frags/bytes    it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|destp
decl_stmt|;
name|int
name|num_opcodes
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|i860_it
name|pseudo
index|[
literal|3
index|]
decl_stmt|;
name|assert
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
comment|/* Assemble the instruction.  */
name|i860_process_insn
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Check for expandable flag to produce pseudo-instructions.  This      is an undesirable feature that should be avoided.  */
if|if
condition|(
name|the_insn
operator|.
name|expand
operator|!=
literal|0
operator|&&
name|the_insn
operator|.
name|expand
operator|!=
name|XP_ONLY
operator|&&
operator|!
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|&
operator|(
name|OP_SEL_HA
operator||
name|OP_SEL_H
operator||
name|OP_SEL_L
operator||
name|OP_SEL_GOT
operator||
name|OP_SEL_GOTOFF
operator||
name|OP_SEL_PLT
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|pseudo
index|[
name|i
index|]
operator|=
name|the_insn
expr_stmt|;
name|fc
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|the_insn
operator|.
name|expand
condition|)
block|{
case|case
name|E_DELAY
case|:
name|num_opcodes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|E_MOV
case|:
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|NULL
operator|&&
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|-
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
break|break;
comment|/* Emit "or l%const,r0,ireg_dest".  */
name|pseudo
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x001f0000
operator|)
operator||
literal|0xe4000000
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_L
operator|)
expr_stmt|;
comment|/* Emit "orh h%const,ireg_dest,ireg_dest".  */
name|pseudo
index|[
literal|1
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x03ffffff
operator|)
operator||
literal|0xec000000
operator||
operator|(
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x001f0000
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_H
operator|)
expr_stmt|;
name|num_opcodes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_ADDR
case|:
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|NULL
operator|&&
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|-
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
break|break;
comment|/* Emit "orh ha%addr_expr,ireg_src2,r31".  */
name|pseudo
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
literal|0xec000000
operator||
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x03e00000
operator|)
operator||
operator|(
name|atmp
operator|<<
literal|16
operator|)
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_HA
operator|)
expr_stmt|;
comment|/* Emit "l%addr_expr(r31),ireg_dest".  We pick up the fixup 	     information from the original instruction.   */
name|pseudo
index|[
literal|1
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
operator|~
literal|0x03e00000
operator|)
operator||
operator|(
name|atmp
operator|<<
literal|21
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator||
name|OP_SEL_L
expr_stmt|;
name|num_opcodes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_U32
case|:
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|NULL
operator|&&
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|)
condition|)
break|break;
comment|/* Emit "$(opcode)h h%const,ireg_src2,r31".  */
name|pseudo
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0xf3e0ffff
operator|)
operator||
literal|0x0c000000
operator||
operator|(
name|atmp
operator|<<
literal|16
operator|)
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_H
operator|)
expr_stmt|;
comment|/* Emit "$(opcode) l%const,r31,ireg_dest".  */
name|pseudo
index|[
literal|1
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0xf01f0000
operator|)
operator||
literal|0x04000000
operator||
operator|(
name|atmp
operator|<<
literal|21
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_L
operator|)
expr_stmt|;
name|num_opcodes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_AND
case|:
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|NULL
operator|&&
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|)
condition|)
break|break;
comment|/* Emit "andnot h%const,ireg_src2,r31".  */
name|pseudo
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x03e0ffff
operator|)
operator||
literal|0xd4000000
operator||
operator|(
name|atmp
operator|<<
literal|16
operator|)
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_H
operator|)
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|-
literal|1
operator|-
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* Emit "andnot l%const,r31,ireg_dest".  */
name|pseudo
index|[
literal|1
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x001f0000
operator|)
operator||
literal|0xd4000000
operator||
operator|(
name|atmp
operator|<<
literal|21
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_L
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|-
literal|1
operator|-
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|num_opcodes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_S32
case|:
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|NULL
operator|&&
operator|(
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|-
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
break|break;
comment|/* Emit "orh h%const,r0,r31".  */
name|pseudo
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
literal|0xec000000
operator||
operator|(
name|atmp
operator|<<
literal|16
operator|)
expr_stmt|;
name|pseudo
index|[
literal|0
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_H
operator|)
expr_stmt|;
comment|/* Emit "or l%const,r31,r31".  */
name|pseudo
index|[
literal|1
index|]
operator|.
name|opcode
operator|=
literal|0xe4000000
operator||
operator|(
name|atmp
operator|<<
literal|21
operator|)
operator||
operator|(
name|atmp
operator|<<
literal|16
operator|)
expr_stmt|;
name|pseudo
index|[
literal|1
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
operator|(
name|OP_IMM_S16
operator||
name|OP_SEL_L
operator|)
expr_stmt|;
comment|/* Emit "r31,ireg_src2,ireg_dest".  */
name|pseudo
index|[
literal|2
index|]
operator|.
name|opcode
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
operator|~
literal|0x0400ffff
operator|)
operator||
operator|(
name|atmp
operator|<<
literal|11
operator|)
expr_stmt|;
name|pseudo
index|[
literal|2
index|]
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|fup
operator|=
name|OP_IMM_S16
expr_stmt|;
name|num_opcodes
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|the_insn
operator|=
name|pseudo
index|[
literal|0
index|]
expr_stmt|;
comment|/* Warn if an opcode is expanded after a delayed branch.  */
if|if
condition|(
name|num_opcodes
operator|>
literal|1
operator|&&
name|last_expand
operator|==
literal|1
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expanded opcode after delayed branch: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Warn if an opcode is expanded in dual mode.  */
if|if
condition|(
name|num_opcodes
operator|>
literal|1
operator|&&
name|dual_mode
operator|!=
name|DUAL_OFF
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expanded opcode in dual mode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Notify if any expansions happen.  */
if|if
condition|(
name|target_warn_expand
operator|&&
name|num_opcodes
operator|>
literal|1
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"An instruction was expanded (%s)"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|tmp
decl_stmt|;
comment|/* Output the opcode.  Note that the i860 always reads instructions 	 as little-endian data.  */
name|destp
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_littleendian
argument_list|(
name|destp
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check for expanded opcode after branch or in dual mode.  */
name|last_expand
operator|=
name|the_insn
operator|.
name|fi
index|[
literal|0
index|]
operator|.
name|pcrel
expr_stmt|;
comment|/* Output the symbol-dependent stuff.  Only btne and bte will ever          loop more than once here, since only they (possibly) have more          than one fixup.  */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|fc
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|fi
index|[
name|tmp
index|]
operator|.
name|fup
operator|!=
name|OP_NONE
condition|)
block|{
name|fixS
modifier|*
name|fix
decl_stmt|;
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|destp
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|the_insn
operator|.
name|fi
index|[
name|tmp
index|]
operator|.
name|exp
argument_list|,
name|the_insn
operator|.
name|fi
index|[
name|tmp
index|]
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|fi
index|[
name|tmp
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
comment|/* Despite the odd name, this is a scratch field.  We use 	        it to encode operand type information.  */
name|fix
operator|->
name|fx_addnumber
operator|=
name|the_insn
operator|.
name|fi
index|[
name|tmp
index|]
operator|.
name|fup
expr_stmt|;
block|}
block|}
name|the_insn
operator|=
name|pseudo
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|num_opcodes
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Assemble the instruction pointed to by STR.  */
end_comment

begin_function
specifier|static
name|void
name|i860_process_insn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|i860_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|args_start
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|1
comment|/* For compiler warnings.  */
name|args
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
literal|0
expr_stmt|;
name|args_start
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|s
operator|=
name|str
init|;
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'.'
operator|||
operator|*
name|s
operator|==
literal|'3'
operator|||
operator|*
name|s
operator|==
literal|'2'
operator|||
operator|*
name|s
operator|==
literal|'1'
condition|;
operator|++
name|s
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
name|comma
operator|=
literal|1
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* Check for dual mode ("d.") opcode prefix.  */
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"d."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dual_mode
operator|==
name|DUAL_ON
condition|)
name|dual_mode
operator|=
name|DUAL_ONDDOT
expr_stmt|;
else|else
name|dual_mode
operator|=
name|DUAL_DDOT
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|i860_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dual_mode
operator|==
name|DUAL_DDOT
operator|||
name|dual_mode
operator|==
name|DUAL_ONDDOT
condition|)
name|str
operator|-=
literal|2
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|comma
condition|)
operator|*
operator|--
name|s
operator|=
literal|','
expr_stmt|;
name|args_start
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|t
decl_stmt|;
name|opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MAX_FIXUPS
condition|;
name|t
operator|++
control|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|t
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|t
index|]
operator|.
name|pcrel
operator|=
literal|0
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|t
index|]
operator|.
name|fup
operator|=
name|OP_NONE
expr_stmt|;
block|}
comment|/* Build the opcode, checking as we go that the operands match.  */
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
if|if
condition|(
name|fc
operator|>
name|MAX_FIXUPS
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
comment|/* End of args.  */
case|case
literal|'\0'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|match
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* These must match exactly.  */
case|case
literal|'+'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|','
case|:
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
comment|/* Must be at least one digit.  */
case|case
literal|'#'
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Next operand must be a register.  */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'d'
case|:
comment|/* Check for register prefix if necessary.  */
if|if
condition|(
name|reg_prefix
operator|&&
operator|*
name|s
operator|!=
name|reg_prefix
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|reg_prefix
condition|)
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Frame pointer.  */
case|case
literal|'f'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0x3
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
comment|/* Stack pointer.  */
case|case
literal|'s'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0x2
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
comment|/* Any register r0..r31.  */
case|case
literal|'r'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
literal|10
operator|*
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
operator|)
operator|>=
literal|32
condition|)
goto|goto
name|error
goto|;
block|}
else|else
name|c
operator|-=
literal|'0'
expr_stmt|;
name|mask
operator|=
name|c
expr_stmt|;
break|break;
comment|/* Not this opcode.  */
default|default:
goto|goto
name|error
goto|;
block|}
comment|/* Obtained the register, now place it in the opcode.  */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'1'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|11
expr_stmt|;
continue|continue;
case|case
literal|'2'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|21
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Next operand is a floating point register.  */
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
comment|/* Check for register prefix if necessary.  */
if|if
condition|(
name|reg_prefix
operator|&&
operator|*
name|s
operator|!=
name|reg_prefix
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|reg_prefix
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'f'
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|10
operator|*
operator|(
name|mask
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|32
condition|)
block|{
break|break;
block|}
block|}
else|else
name|mask
operator|-=
literal|'0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'e'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|11
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|21
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|)
operator|&&
name|mask
operator|!=
literal|0
operator|&&
operator|(
name|mask
operator|==
operator|(
operator|(
name|opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Pipelined instruction: fsrc1 = fdest"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
comment|/* Next operand must be a control register.  */
case|case
literal|'c'
case|:
comment|/* Check for register prefix if necessary.  */
if|if
condition|(
name|reg_prefix
operator|&&
operator|*
name|s
operator|!=
name|reg_prefix
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|reg_prefix
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"fir"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x0
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"psr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x1
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"dirbase"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x2
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|7
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"db"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x3
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"fsr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x4
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"epsr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x5
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
comment|/* The remaining control registers are XP only.  */
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"bear"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x6
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"ccr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x7
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"p0"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x8
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"p1"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0x9
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"p2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0xa
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_xp
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"p3"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator||=
literal|0xb
operator|<<
literal|21
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* 5-bit immediate in src1.  */
case|case
literal|'5'
case|:
if|if
condition|(
operator|!
name|i860_get_expression
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
name|expr_end
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_U5
expr_stmt|;
name|fc
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* 26-bit immediate, relative branch (lbroff).  */
case|case
literal|'l'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_BR26
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit split immediate, relative branch (sbroff).  */
case|case
literal|'r'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_BR16
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit split immediate.  */
case|case
literal|'s'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_SPLIT16
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit split immediate, byte aligned (st.b).  */
case|case
literal|'S'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_SPLIT16
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit split immediate, half-word aligned (st.s).  */
case|case
literal|'T'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_SPLIT16
operator||
name|OP_ENCODE1
operator||
name|OP_ALIGN2
operator|)
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit split immediate, word aligned (st.l).  */
case|case
literal|'U'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_SPLIT16
operator||
name|OP_ENCODE1
operator||
name|OP_ALIGN4
operator|)
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate.  */
case|case
literal|'i'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_S16
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate, byte aligned (ld.b).  */
case|case
literal|'I'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_IMM_S16
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate, half-word aligned (ld.s).  */
case|case
literal|'J'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_S16
operator||
name|OP_ENCODE1
operator||
name|OP_ALIGN2
operator|)
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate, word aligned (ld.l, {p}fld.l, fst.l).  */
case|case
literal|'K'
case|:
if|if
condition|(
name|insn
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_S16
operator||
name|OP_ENCODE1
operator||
name|OP_ALIGN4
operator|)
expr_stmt|;
else|else
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_S16
operator||
name|OP_ENCODE2
operator||
name|OP_ALIGN4
operator|)
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate, double-word aligned ({p}fld.d, fst.d).  */
case|case
literal|'L'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_S16
operator||
name|OP_ENCODE3
operator||
name|OP_ALIGN8
operator|)
expr_stmt|;
goto|goto
name|immediate
goto|;
comment|/* 16-bit immediate, quad-word aligned (fld.q, fst.q).  */
case|case
literal|'M'
case|:
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
operator|(
name|OP_IMM_S16
operator||
name|OP_ENCODE3
operator||
name|OP_ALIGN16
operator|)
expr_stmt|;
comment|/*FALLTHROUGH*/
comment|/* Handle the immediate for either the Intel syntax or 		 SVR4 syntax. The Intel syntax is "ha%immediate" 		 whereas SVR4 syntax is "[immediate]@ha".  */
name|immediate
label|:
if|if
condition|(
name|target_intel_syntax
operator|==
literal|0
condition|)
block|{
comment|/* AT&T/SVR4 syntax.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Note that if i860_get_expression() fails, we will still 	  	     have created U entries in the symbol table for the 		     'symbols' in the input string.  Try not to create U 		     symbols for registers, etc.  */
if|if
condition|(
operator|!
name|i860_get_expression
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|expr_end
expr_stmt|;
else|else
goto|goto
name|error
goto|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@ha"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_HA
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@h"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_H
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@l"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_L
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@gotoff"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@GOTOFF"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Assembler does not yet support PIC"
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_GOTOFF
expr_stmt|;
name|s
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@got"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@GOT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Assembler does not yet support PIC"
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_GOT
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@plt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"@PLT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Assembler does not yet support PIC"
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_PLT
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
name|the_insn
operator|.
name|expand
operator|=
name|insn
operator|->
name|expand
expr_stmt|;
name|fc
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Intel syntax.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"ha%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_HA
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"h%"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_H
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"l%"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|fup
operator||=
name|OP_SEL_L
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|the_insn
operator|.
name|expand
operator|=
name|insn
operator|->
name|expand
expr_stmt|;
comment|/* Note that if i860_get_expression() fails, we will still 		     have created U entries in the symbol table for the 		     'symbols' in the input string.  Try not to create U 		     symbols for registers, etc.  */
if|if
condition|(
operator|!
name|i860_get_expression
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|expr_end
expr_stmt|;
else|else
goto|goto
name|error
goto|;
name|fc
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* Args don't match.  */
if|if
condition|(
name|insn
index|[
literal|1
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|args_start
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands for %s"
argument_list|)
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
comment|/* Set the dual bit on this instruction if necessary.  */
if|if
condition|(
name|dual_mode
operator|!=
name|DUAL_OFF
condition|)
block|{
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x48000000
operator|||
name|opcode
operator|==
literal|0xb0000000
condition|)
block|{
comment|/* The instruction is a flop or a fnop, so set its dual bit 	     (but check that it is 8-byte aligned).  */
if|if
condition|(
operator|(
operator|(
name|frag_now
operator|->
name|fr_address
operator|+
name|frag_now_fix_octets
argument_list|()
operator|)
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|opcode
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"'d.%s' must be 8-byte aligned"
argument_list|)
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dual_mode
operator|==
name|DUAL_DDOT
condition|)
name|dual_mode
operator|=
name|DUAL_OFF
expr_stmt|;
elseif|else
if|if
condition|(
name|dual_mode
operator|==
name|DUAL_ONDDOT
condition|)
name|dual_mode
operator|=
name|DUAL_ON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dual_mode
operator|==
name|DUAL_DDOT
operator|||
name|dual_mode
operator|==
name|DUAL_ONDDOT
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Prefix 'd.' invalid for instruction `%s'"
argument_list|)
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
comment|/* Only recognize XP instructions when the user has requested it.  */
if|if
condition|(
name|insn
operator|->
name|expand
operator|==
name|XP_ONLY
operator|&&
operator|!
name|target_xp
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i860_get_expression
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|the_insn
operator|.
name|fi
index|[
name|fc
index|]
operator|.
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|undefined_section
operator|&&
operator|!
name|SEG_NORMAL
argument_list|(
name|seg
argument_list|)
condition|)
block|{
name|the_insn
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad segment"
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of    type TYPE, and store the appropriate bytes in *LITP.  The number of    LITTLENUMS emitted is stored in *SIZEP.  An error message is returned,    or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out in current endian mode.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This should never be called for i860.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"i860_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_I860
end_ifdef

begin_function
specifier|static
name|void
name|print_insn
parameter_list|(
name|struct
name|i860_it
modifier|*
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|->
name|error
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: %s\n"
argument_list|,
name|insn
operator|->
name|error
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"opcode = 0x%08lx\t"
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expand = 0x%x\t"
argument_list|,
name|insn
operator|->
name|expand
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reloc = %s\t\n"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|insn
operator|->
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exp =  {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_add_symbol = %s\n"
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
condition|?
operator|(
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|)
condition|?
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_op_symbol = %s\n"
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_op_symbol
condition|?
operator|(
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_op_symbol
argument_list|)
condition|?
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_op_symbol
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_add_number = %lx\n"
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_I860 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"VQ:"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_EXPAND
value|(OPTION_MD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|OPTION_XP
value|(OPTION_MD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|OPTION_INTEL_SYNTAX
value|(OPTION_MD_BASE + 4)
end_define

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
block|{
literal|"mwarn-expand"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_EXPAND
block|}
block|,
block|{
literal|"mxp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_XP
block|}
block|,
block|{
literal|"mintel-syntax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_INTEL_SYNTAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_EXPAND
case|:
name|target_warn_expand
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_XP
case|:
name|target_xp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_INTEL_SYNTAX
case|:
name|target_intel_syntax
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* SVR4 argument compatibility (-V): print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* SVR4 argument compatibility (-Qy, -Qn): controls whether        a .comment section should be emitted or not (ignored).  */
case|case
literal|'Q'
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -EL			  generate code for little endian mode (default)\n\   -EB			  generate code for big endian mode\n\   -mwarn-expand		  warn if pseudo operations are expanded\n\   -mxp			  enable i860XP support (disabled by default)\n\   -mintel-syntax	  enable Intel syntax (default to AT&T/SVR4)\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* SVR4 compatibility flags.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -V			  print assembler version number\n\   -Qy, -Qn		  ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The i860 denotes auto-increment with '++'.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|input_line_pointer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Byte alignment is fine.  */
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* On the i860, a PC-relative offset is relative to the address of the    offset plus its size.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* Determine the relocation needed for non PC-relative 16-bit immediates.    Also adjust the given immediate as necessary.  Finally, check that    all constraints (such as alignment) are satisfied.   */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|obtain_reloc_for_imm16
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|,
name|long
modifier|*
name|val
parameter_list|)
block|{
name|valueT
name|fup
init|=
name|fix
operator|->
name|fx_addnumber
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check alignment restrictions.  */
if|if
condition|(
operator|(
name|fup
operator|&
name|OP_ALIGN2
operator|)
operator|&&
operator|(
operator|*
name|val
operator|&
literal|0x1
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"This immediate requires 0 MOD 2 alignment"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fup
operator|&
name|OP_ALIGN4
operator|)
operator|&&
operator|(
operator|*
name|val
operator|&
literal|0x3
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"This immediate requires 0 MOD 4 alignment"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fup
operator|&
name|OP_ALIGN8
operator|)
operator|&&
operator|(
operator|*
name|val
operator|&
literal|0x7
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"This immediate requires 0 MOD 8 alignment"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fup
operator|&
name|OP_ALIGN16
operator|)
operator|&&
operator|(
operator|*
name|val
operator|&
literal|0xf
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"This immediate requires 0 MOD 16 alignment"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|&
name|OP_SEL_HA
condition|)
block|{
operator|*
name|val
operator|=
operator|(
operator|*
name|val
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|*
name|val
operator|&
literal|0x8000
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_HIGHADJ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_SEL_H
condition|)
block|{
operator|*
name|val
operator|>>=
literal|16
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_HIGH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_SEL_L
condition|)
block|{
name|int
name|num_encode
decl_stmt|;
if|if
condition|(
name|fup
operator|&
name|OP_IMM_SPLIT16
condition|)
block|{
if|if
condition|(
name|fup
operator|&
name|OP_ENCODE1
condition|)
block|{
name|num_encode
operator|=
literal|1
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_SPLIT1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_ENCODE2
condition|)
block|{
name|num_encode
operator|=
literal|2
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_SPLIT2
expr_stmt|;
block|}
else|else
block|{
name|num_encode
operator|=
literal|0
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_SPLIT0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fup
operator|&
name|OP_ENCODE1
condition|)
block|{
name|num_encode
operator|=
literal|1
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_LOW1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_ENCODE2
condition|)
block|{
name|num_encode
operator|=
literal|2
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_LOW2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_ENCODE3
condition|)
block|{
name|num_encode
operator|=
literal|3
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_LOW3
expr_stmt|;
block|}
else|else
block|{
name|num_encode
operator|=
literal|0
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_860_LOW0
expr_stmt|;
block|}
block|}
comment|/* Preserve size encode bits.  */
operator|*
name|val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|num_encode
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No selector.  What reloc do we generate (???)?  */
name|reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify or eliminate a fixup. To indicate that a fixup    has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,    we will have to generate a reloc entry.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|valueT
name|fup
decl_stmt|;
name|buf
operator|=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fix
operator|->
name|fx_where
expr_stmt|;
comment|/* Recall that earlier we stored the opcode little-endian.  */
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* We stored a fix-up in this oddly-named scratch field.  */
name|fup
operator|=
name|fix
operator|->
name|fx_addnumber
expr_stmt|;
comment|/* Determine the necessary relocations as well as inserting an      immediate into the instruction.   */
if|if
condition|(
name|fup
operator|&
name|OP_IMM_U5
condition|)
block|{
if|if
condition|(
name|val
operator|&
operator|~
literal|0x1f
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"5-bit immediate too large"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"5-bit field must be absolute"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|val
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_IMM_S16
condition|)
block|{
name|fix
operator|->
name|fx_r_type
operator|=
name|obtain_reloc_for_imm16
argument_list|(
name|fix
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Insert the immediate.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|insn
operator||=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_IMM_U16
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_IMM_SPLIT16
condition|)
block|{
name|fix
operator|->
name|fx_r_type
operator|=
name|obtain_reloc_for_imm16
argument_list|(
name|fix
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Insert the immediate.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|insn
operator||=
name|val
operator|&
literal|0x7ff
expr_stmt|;
name|insn
operator||=
operator|(
name|val
operator|&
literal|0xf800
operator|)
operator|<<
literal|5
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_IMM_BR16
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x3
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"A branch offset requires 0 MOD 4 alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
comment|/* Insert the immediate.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
block|{
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_860_PC16
expr_stmt|;
block|}
else|else
block|{
name|insn
operator||=
operator|(
name|val
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|val
operator|&
literal|0xf800
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fup
operator|&
name|OP_IMM_BR26
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x3
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"A branch offset requires 0 MOD 4 alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|2
expr_stmt|;
comment|/* Insert the immediate.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
block|{
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_860_PC26
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|insn
operator||=
operator|(
name|val
operator|&
literal|0x3ffffff
operator|)
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fup
operator|!=
name|OP_NONE
condition|)
block|{
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unrecognized fix-up (0x%08lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fup
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* I believe only fix-ups such as ".long .ep.main-main+0xc8000000"  	 reach here (???).  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
condition|)
block|{
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|insn
operator||=
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|fix
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a machine dependent reloc from a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
operator|->
name|howto
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"Cannot represent %s relocation in object file"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|i860_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
comment|/* Instructions are always stored little-endian on the i860.  */
specifier|static
specifier|const
name|unsigned
name|char
name|le_nop
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xA0
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* Make sure we are on a 4-byte boundary, in case someone has been      putting data into a text section.  */
if|if
condition|(
name|bytes
operator|&
literal|3
condition|)
block|{
name|int
name|fix
init|=
name|bytes
operator|&
literal|3
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|le_nop
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called after a user-defined label is seen.  We check    if the label has a double colon (valid in Intel syntax mode only),    in which case it should be externalized.  */
end_comment

begin_function
name|void
name|i860_check_label
parameter_list|(
name|symbolS
modifier|*
name|labelsym
parameter_list|)
block|{
comment|/* At this point, the current line pointer is sitting on the character      just after the first colon on the label.  */
if|if
condition|(
name|target_intel_syntax
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|labelsym
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

