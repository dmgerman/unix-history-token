begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms.c -- Write out a VAX/VMS object file    Copyright 1987, 1988, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001,    2002, 2003    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by David L. Kashtan */
end_comment

begin_comment
comment|/* Modified by Eric Youngdale to write VMS debug records for program    variables */
end_comment

begin_comment
comment|/* Want all of obj-vms.h (as obj-format.h, via targ-env.h, via as.h).  */
end_comment

begin_define
define|#
directive|define
name|WANT_VMS_OBJ_DEFS
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* What we do if there is a goof.  */
end_comment

begin_define
define|#
directive|define
name|error
value|as_fatal
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* These are of no use if we are cross assembling.  */
end_comment

begin_include
include|#
directive|include
file|<fab.h>
end_include

begin_comment
comment|/* Define File Access Block.  */
end_comment

begin_include
include|#
directive|include
file|<nam.h>
end_include

begin_comment
comment|/* Define NAM Block.  */
end_comment

begin_include
include|#
directive|include
file|<xab.h>
end_include

begin_comment
comment|/* Define XAB - all different types.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sys$open
argument_list|()
decl_stmt|,
name|sys$close
argument_list|()
decl_stmt|,
name|sys$asctim
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Version string of the compiler that produced the code we are    assembling.  (And this assembler, if we do not have compiler info).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|compiler_version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_hash_long_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -+ */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1; compatibility with gcc 1.x */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_show_after_trunc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -H */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_hash_mixed_case
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h NUM */
end_comment

begin_comment
comment|/* Flag that determines how we map names.  This takes several values, and    is set with the -h switch.  A value of zero implies names should be    upper case, and the presence of the -h switch inhibits the case hack.    No -h switch at all sets vms_name_mapping to 0, and allows case hacking.    A value of 2 (set with -h2) implies names should be    all lower case, with no case hack.  A value of 3 (set with -h3) implies    that case should be preserved.  */
end_comment

begin_comment
comment|/* If the -+ switch is given, then the hash is appended to any name that is    longer than 31 characters, regardless of the setting of the -h switch.  */
end_comment

begin_decl_stmt
name|char
name|vms_name_mapping
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|Entry_Point_Symbol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to "_main" */
end_comment

begin_comment
comment|/* We augment the "gas" symbol structure with this.  */
end_comment

begin_struct
struct|struct
name|VMS_Symbol
block|{
name|struct
name|VMS_Symbol
modifier|*
name|Next
decl_stmt|;
name|symbolS
modifier|*
name|Symbol
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Index
decl_stmt|;
name|int
name|Psect_Offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VMS_Symbol
modifier|*
name|VMS_Symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|VMS_Symbol
modifier|*
name|Ctors_Symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|VMS_Symbol
modifier|*
name|Dtors_Symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need this to keep track of the various input files, so that we can    give the debugger the correct source line.  */
end_comment

begin_struct
struct|struct
name|input_file
block|{
name|struct
name|input_file
modifier|*
name|next
decl_stmt|;
name|struct
name|input_file
modifier|*
name|same_file_fpnt
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|max_line
decl_stmt|;
name|int
name|min_line
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|flag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|spnt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|input_file
modifier|*
name|file_root
init|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Styles of PSECTS (program sections) that we generate; just shorthand    to avoid lists of section attributes.  Used by VMS_Psect_Spec().  */
end_comment

begin_enum
enum|enum
name|ps_type
block|{
name|ps_TEXT
block|,
name|ps_DATA
block|,
name|ps_COMMON
block|,
name|ps_CONST
block|,
name|ps_CTORS
block|,
name|ps_DTORS
block|}
enum|;
end_enum

begin_comment
comment|/* This enum is used to keep track of the various types of variables that    may be present.  */
end_comment

begin_enum
enum|enum
name|advanced_type
block|{
name|BASIC
block|,
name|POINTER
block|,
name|ARRAY
block|,
name|ENUM
block|,
name|STRUCT
block|,
name|UNION
block|,
name|FUNCTION
block|,
name|VOID
block|,
name|ALIAS
block|,
name|UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/* This structure contains the information from the stabs directives, and the    information is filled in by VMS_typedef_parse.  Everything that is needed    to generate the debugging record for a given symbol is present here.    This could be done more efficiently, using nested struct/unions, but for    now I am happy that it works.  */
end_comment

begin_struct
struct|struct
name|VMS_DBG_Symbol
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|next
decl_stmt|;
comment|/* Description of what this is.  */
name|enum
name|advanced_type
name|advanced
decl_stmt|;
comment|/* This record is for this type.  */
name|int
name|dbx_type
decl_stmt|;
comment|/* For advanced types this is the type referred to.  I.e., the type      a pointer points to, or the type of object that makes up an      array.  */
name|int
name|type2
decl_stmt|;
comment|/* Use this type when generating a variable def.  */
name|int
name|VMS_type
decl_stmt|;
comment|/* Used for arrays - this will be present for all.  */
name|int
name|index_min
decl_stmt|;
comment|/* Entries, but will be meaningless for non-arrays.  */
name|int
name|index_max
decl_stmt|;
comment|/* Size in bytes of the data type.  For an array, this is the size      of one element in the array.  */
name|int
name|data_size
decl_stmt|;
comment|/* Number of the structure/union/enum - used for ref.  */
name|int
name|struc_numb
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SYMTYPLST_SIZE
value|(1<<4)
end_define

begin_comment
comment|/* 16; Must be power of two.  */
end_comment

begin_define
define|#
directive|define
name|SYMTYP_HASH
parameter_list|(
name|x
parameter_list|)
value|((unsigned) (x)& (SYMTYPLST_SIZE - 1))
end_define

begin_decl_stmt
name|struct
name|VMS_DBG_Symbol
modifier|*
name|VMS_Symbol_type_list
index|[
name|SYMTYPLST_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need this structure to keep track of forward references to    struct/union/enum that have not been defined yet.  When they are    ultimately defined, then we can go back and generate the TIR    commands to make a back reference.  */
end_comment

begin_struct
struct|struct
name|forward_ref
block|{
name|struct
name|forward_ref
modifier|*
name|next
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|struc_numb
decl_stmt|;
name|char
name|resolved
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|forward_ref
modifier|*
name|f_ref_root
init|=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine is used to compare the names of certain types to various    fixed types that are known by the debugger.  */
end_comment

begin_define
define|#
directive|define
name|type_check
parameter_list|(
name|X
parameter_list|)
value|!strcmp (symbol_name, X)
end_define

begin_comment
comment|/* This variable is used to keep track of the name of the symbol we are    working on while we are parsing the stabs directives.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use this counter to assign numbers to all of the structures, unions    and enums that we define.  When we actually declare a variable to the    debugger, we can simply do it by number, rather than describing the    whole thing each time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|structure_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable is used to indicate that we are making the last attempt to    parse the stabs, and that we should define as much as we can, and ignore    the rest.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|final_pass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable is used to keep track of the current structure number    for a given variable.  If this is< 0, that means that the structure    has not yet been defined to the debugger.  This is still cool, since    the VMS object language has ways of fixing things up after the fact,    so we just make a note of this, and generate fixups at the end.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|struct_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to distinguish between D_float and G_float for telling    the debugger about doubles.  gcc outputs the same .stabs regardless    of whether -mg is used to select alternate doubles.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vax_g_doubles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local symbol references (used to handle N_ABS symbols; gcc does not    generate those, but they're possible with hand-coded assembler input)    are always made relative to some particular environment.  If the current    input has any such symbols, then we expect this to get incremented    exactly once and end up having all of them be in environment #0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Current_Environment
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every object file must specify an module name, which is also used by    traceback records.  Set in Write_VMS_MHD_Records().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Module_Name
index|[
literal|255
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable descriptors are used tell the debugger the data types of certain    more complicated variables (basically anything involving a structure,    union, enum, array or pointer).  Some non-pointer variables of the    basic types that the debugger knows about do not require a variable    descriptor.     Since it is impossible to have a variable descriptor longer than 128    bytes by virtue of the way that the VMS object language is set up,    it makes not sense to make the arrays any longer than this, or worrying    about dynamic sizing of the array.     These are the arrays and counters that we use to build a variable    descriptor.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DEBUG_RECORD
value|128
end_define

begin_decl_stmt
specifier|static
name|char
name|Local
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for variable descriptor.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Asuffix
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for array descriptor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Lpnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into Local.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Apoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into Asuffix.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to indicate we have written too much.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to calculate the total length of 				   variable descriptor plus array descriptor 				   - used for len byte.  */
end_comment

begin_comment
comment|/* Flag if we have told user about finding global constants in the text    section.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gave_compiler_message
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global data (Object records limited to 512 bytes by VAX-11 "C" runtime).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|VMS_Object_File_FD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File Descriptor for object file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Object_Record_Buffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for object file records.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|Object_Record_Offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of data.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Current_Object_Record_Type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of record in above.  */
end_comment

begin_comment
comment|/* Macros for moving data around.  Must work on big-endian systems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* These are more efficient for VMS->VMS systems.  */
end_comment

begin_define
define|#
directive|define
name|COPY_LONG
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
value|( *(long *) (dest) = (val) )
end_define

begin_define
define|#
directive|define
name|COPY_SHORT
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
value|( *(short *) (dest) = (val) )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COPY_LONG
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
value|md_number_to_chars ((dest), (val), 4)
end_define

begin_define
define|#
directive|define
name|COPY_SHORT
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
value|md_number_to_chars ((dest), (val), 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for placing data into the object record buffer.  */
end_comment

begin_define
define|#
directive|define
name|PUT_LONG
parameter_list|(
name|val
parameter_list|)
define|\
value|( COPY_LONG (&Object_Record_Buffer[Object_Record_Offset], (val)), \ 	  Object_Record_Offset += 4 )
end_define

begin_define
define|#
directive|define
name|PUT_SHORT
parameter_list|(
name|val
parameter_list|)
define|\
value|( COPY_SHORT (&Object_Record_Buffer[Object_Record_Offset], (val)), \ 	  Object_Record_Offset += 2 )
end_define

begin_define
define|#
directive|define
name|PUT_CHAR
parameter_list|(
name|val
parameter_list|)
value|(Object_Record_Buffer[Object_Record_Offset++] = (val))
end_define

begin_define
define|#
directive|define
name|PUT_COUNTED_STRING
parameter_list|(
name|cp
parameter_list|)
define|\
value|do 						\     { 						\       const char *p = (cp);			\       						\       PUT_CHAR ((char) strlen (p)); 		\       while (*p)				\ 	PUT_CHAR (*p++);			\     }						\   while (0)
end_define

begin_comment
comment|/* Macro for determining if a Name has psect attributes attached    to it.   */
end_comment

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING
value|"$$PsectAttributes_"
end_define

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING_LENGTH
value|18
end_define

begin_define
define|#
directive|define
name|HAS_PSECT_ATTRIBUTES
parameter_list|(
name|Name
parameter_list|)
define|\
value|(strncmp ((*Name == '_' ? Name + 1 : Name), \ 			  PSECT_ATTRIBUTES_STRING, \ 			  PSECT_ATTRIBUTES_STRING_LENGTH) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* in: segT   out: N_TYPE bits */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
name|N_ABS
block|,
name|N_TEXT
block|,
name|N_DATA
block|,
name|N_BSS
block|,
name|N_UNDF
block|,
comment|/* unknown */
name|N_UNDF
block|,
comment|/* error */
name|N_UNDF
block|,
comment|/* expression */
name|N_UNDF
block|,
comment|/* debug */
name|N_UNDF
block|,
comment|/* ntv */
name|N_UNDF
block|,
comment|/* ptv */
name|N_REGISTER
block|,
comment|/* register */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|segT
name|N_TYPE_seg
index|[
name|N_TYPE
operator|+
literal|2
index|]
init|=
block|{
comment|/* N_TYPE == 0x1E = 32-2 */
name|SEG_UNKNOWN
block|,
comment|/* N_UNDF == 0 */
name|SEG_GOOF
block|,
name|SEG_ABSOLUTE
block|,
comment|/* N_ABS == 2 */
name|SEG_GOOF
block|,
name|SEG_TEXT
block|,
comment|/* N_TEXT == 4 */
name|SEG_GOOF
block|,
name|SEG_DATA
block|,
comment|/* N_DATA == 6 */
name|SEG_GOOF
block|,
name|SEG_BSS
block|,
comment|/* N_BSS == 8 */
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_REGISTER
block|,
comment|/* dummy N_REGISTER for regs = 30 */
name|SEG_GOOF
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The following code defines the special types of pseudo-ops that we    use with VMS.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|const_flag
init|=
name|IN_DEFAULT_SECTION
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s_const
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* Since we don't need `arg', use it as our scratch variable so that      we won't get any "not used" warnings about it.  */
name|arg
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|arg
argument_list|)
expr_stmt|;
name|const_flag
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
block|{
literal|"const"
block|,
name|s_const
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obj_pseudo_table */
end_comment

begin_comment
comment|/* Routine to perform RESOLVE_SYMBOL_REDEFINITION().  */
end_comment

begin_function
name|int
name|vms_resolve_symbol_redef
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
comment|/* If the new symbol is .comm AND it has a size of zero,      we ignore it (i.e. the old symbol overrides it).  */
if|if
condition|(
name|SEGMENT_TO_SYMBOL_TYPE
argument_list|(
operator|(
name|int
operator|)
name|now_seg
argument_list|)
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|frag_now_fix
argument_list|()
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"compiler emitted zero-size common symbol `%s' already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If the old symbol is .comm and it has a size of zero,      we override it with the new symbol value.  */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"compiler redefined zero-size common symbol `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|sym
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Keep N_EXT bit.  */
name|sym
operator|->
name|sy_symbol
operator|.
name|n_type
operator||=
name|SEGMENT_TO_SYMBOL_TYPE
argument_list|(
operator|(
name|int
operator|)
name|now_seg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* `tc_frob_label' handler for colon(symbols.c), used to examine the    dummy label(s) gcc inserts at the beginning of each file it generates.    gcc 1.x put "gcc_compiled."; gcc 2.x (as of 2.7) puts "gcc2_compiled."    and "__gnu_language_<name>" and possibly "__vax_<type>_doubles".  */
end_comment

begin_function
name|void
name|vms_check_for_special_label
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
comment|/* Special labels only occur prior to explicit section directives.  */
if|if
condition|(
operator|(
name|const_flag
operator|&
name|IN_DEFAULT_SECTION
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|sym_name
init|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'_'
condition|)
operator|++
name|sym_name
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym_name
argument_list|,
literal|"__vax_g_doubles"
argument_list|)
condition|)
name|vax_g_doubles
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not necessary */
block|else if (!strcmp (sym_name, "__vax_d_doubles")) 	vax_g_doubles = 0;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* These are potential alternatives to tc-vax.c's md_parse_options().  */
block|else if (!strcmp (sym_name, "gcc_compiled.")) 	flag_one = 1;       else if (!strcmp (sym_name, "__gnu_language_cplusplus")) 	flag_hash_long_names = 1;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|obj_read_begin_hook
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|obj_crawl_symbol_chain
parameter_list|(
name|object_headers
modifier|*
name|headers
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|symbolPP
decl_stmt|;
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|symbolPP
operator|=
operator|&
name|symbol_rootP
expr_stmt|;
comment|/* -> last symbol chain link.  */
while|while
condition|(
operator|(
name|symbolP
operator|=
operator|*
name|symbolPP
operator|)
operator|!=
name|NULL
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* OK, here is how we decide which symbols go out into the 	brave new symtab.  Symbols that do are:  	* symbols with no name (stabd's?) 	* symbols with debug info in their N_TYPE 	* symbols with \1 as their 3rd character (numeric labels) 	* "local labels" needed for PIC fixups  	Symbols that don't are: 	* symbols that are registers  	All other symbols are output.  We complain if a deleted 	symbol was marked external.  */
if|if
condition|(
operator|!
name|S_IS_REGISTER
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
operator|++
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolPP
operator|=
operator|&
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Local symbol %s never defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unhook it from the chain.  */
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
name|H_SET_STRING_SIZE
argument_list|(
name|headers
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|headers
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VMS OBJECT FILE HACKING ROUTINES.  */
end_comment

begin_comment
comment|/* Create the VMS object file.  */
end_comment

begin_function
specifier|static
name|void
name|Create_VMS_Object_File
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|eunice
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0777
argument_list|,
literal|"var"
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0
argument_list|,
literal|"rfm=var"
argument_list|,
literal|"ctx=bin"
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !VMS */
endif|#
directive|endif
comment|/* !eunice */
comment|/* Deal with errors.  */
if|if
condition|(
name|VMS_Object_File_FD
operator|<
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Couldn't create VMS object file \"%s\""
argument_list|)
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
comment|/* Initialize object file hacking variables.  */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
name|Current_Object_Record_Type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the object record buffer to the object file.  */
end_comment

begin_function
specifier|static
name|void
name|Flush_VMS_Object_Record_Buffer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If the buffer is empty, there's nothing to do.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
return|return;
ifndef|#
directive|ifndef
name|VMS
comment|/* For cross-assembly purposes.  */
block|{
name|char
name|RecLen
index|[
literal|2
index|]
decl_stmt|;
comment|/* "Variable-length record" files have a two byte length field        prepended to each record.  It's normally out-of-band, and native        VMS output will insert it automatically for this type of file.        When cross-assembling, we must write it explicitly.  */
name|md_number_to_chars
argument_list|(
name|RecLen
argument_list|,
name|Object_Record_Offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
name|RecLen
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"I/O error writing VMS object file (length prefix)"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We also need to force the actual record to be an even number of        bytes.  For native output, that's automatic; when cross-assembling,        pad with a NUL byte if length is odd.  Do so _after_ writing the        pre-padded length.  Since our buffer is defined with even size,        an odd offset implies that it has some room left.  */
if|if
condition|(
operator|(
name|Object_Record_Offset
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|Object_Record_Buffer
index|[
name|Object_Record_Offset
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS */
comment|/* Write the data to the file.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
name|Object_Record_Buffer
argument_list|,
name|Object_Record_Offset
argument_list|)
operator|!=
name|Object_Record_Offset
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"I/O error writing VMS object file"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The buffer is now empty.  */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare a particular type of object file record.  */
end_comment

begin_function
specifier|static
name|void
name|Set_VMS_Object_File_Record
parameter_list|(
name|int
name|Type
parameter_list|)
block|{
comment|/* If the type matches, we are done.  */
if|if
condition|(
name|Type
operator|==
name|Current_Object_Record_Type
condition|)
return|return;
comment|/* Otherwise: flush the buffer.  */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* Remember the new type.  */
name|Current_Object_Record_Type
operator|=
name|Type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the VMS Object file.  */
end_comment

begin_function
specifier|static
name|void
name|Close_VMS_Object_File
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Flush (should never be necessary) and reset saved record-type context.  */
name|Set_VMS_Object_File_Record
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* For cross-assembly purposes.  */
block|{
name|char
name|RecLen
index|[
literal|2
index|]
decl_stmt|;
name|int
name|minus_one
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Write a 2 byte record-length field of -1 into the file, which        means end-of-block when read, hence end-of-file when occurring        in the file's last block.  It is only needed for variable-length        record files transferred to VMS as fixed-length record files        (typical for binary FTP; NFS shouldn't need it, but it won't hurt).  */
name|md_number_to_chars
argument_list|(
name|RecLen
argument_list|,
name|minus_one
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
name|RecLen
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* When written on a VMS system, the file header (cf inode) will record        the actual end-of-file position and no inline marker is needed.  */
endif|#
directive|endif
name|close
argument_list|(
name|VMS_Object_File_FD
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Text Information and Relocation routines. */
end_comment

begin_comment
comment|/* Stack Psect base followed by signed, varying-sized offset.    Common to several object records.  */
end_comment

begin_function
specifier|static
name|void
name|vms_tir_stack_psect
parameter_list|(
name|int
name|Psect_Index
parameter_list|,
name|int
name|Offset
parameter_list|,
name|int
name|Force
parameter_list|)
block|{
name|int
name|psect_width
decl_stmt|,
name|offset_width
decl_stmt|;
name|psect_width
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|Psect_Index
operator|>
literal|255
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|offset_width
operator|=
operator|(
name|Force
operator|||
name|Offset
operator|>
literal|32767
operator|||
name|Offset
operator|<
operator|-
literal|32768
operator|)
condition|?
literal|4
else|:
operator|(
name|Offset
operator|>
literal|127
operator|||
name|Offset
operator|<
operator|-
literal|128
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
define|#
directive|define
name|Sta_P
parameter_list|(
name|p
parameter_list|,
name|o
parameter_list|)
value|(((o)<<1) | ((p)-1))
comment|/* Byte or word psect; byte, word, or longword offset.  */
switch|switch
condition|(
name|Sta_P
argument_list|(
name|psect_width
argument_list|,
name|offset_width
argument_list|)
condition|)
block|{
case|case
name|Sta_P
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PB
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|(
name|char
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|(
name|char
operator|)
name|Offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sta_P
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PW
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|(
name|char
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sta_P
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|(
name|char
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sta_P
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPB
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
operator|(
name|char
operator|)
name|Offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sta_P
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sta_P
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
case|:
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|Sta_P
block|}
end_function

begin_comment
comment|/* Store immediate data in current Psect.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Store_Immediate_Data
parameter_list|(
specifier|const
name|char
modifier|*
name|Pointer
parameter_list|,
name|int
name|Size
parameter_list|,
name|int
name|Record_Type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* We can only store as most 128 bytes at a time due to the way that      TIR commands are encoded.  */
while|while
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|(
name|Size
operator|>
literal|128
operator|)
condition|?
literal|128
else|:
name|Size
expr_stmt|;
name|Size
operator|-=
name|i
expr_stmt|;
comment|/* If we cannot accommodate this record, flush the buffer.  */
if|if
condition|(
operator|(
name|Object_Record_Offset
operator|+
name|i
operator|+
literal|1
operator|)
operator|>=
sizeof|sizeof
name|Object_Record_Buffer
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* If the buffer is empty we must insert record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Store the count.  The Store Immediate TIR command is implied by          a negative command byte, and the length of the immediate data          is abs(command_byte).  So, we write the negated length value.  */
name|PUT_CHAR
argument_list|(
call|(
name|char
call|)
argument_list|(
operator|-
name|i
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now store the data.  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a data reference.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Set_Data
parameter_list|(
name|int
name|Psect_Index
parameter_list|,
name|int
name|Offset
parameter_list|,
name|int
name|Record_Type
parameter_list|,
name|int
name|Force
parameter_list|)
block|{
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Stack the Psect base with its offset.  */
name|vms_tir_stack_psect
argument_list|(
name|Psect_Index
argument_list|,
name|Offset
argument_list|,
name|Force
argument_list|)
expr_stmt|;
comment|/* Set relocation base.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a debugger reference to a struct, union or enum.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Store_Struct
parameter_list|(
name|int
name|Struct_Index
parameter_list|)
block|{
comment|/* We are writing a debug record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_STKDL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_L
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a debugger reference to partially define a struct, union or enum.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Def_Struct
parameter_list|(
name|int
name|Struct_Index
parameter_list|)
block|{
comment|/* We are writing a debug record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_DFLOC
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|VMS_Set_Struct
parameter_list|(
name|int
name|Struct_Index
parameter_list|)
block|{
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_STLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traceback Information routines.  */
end_comment

begin_comment
comment|/* Write the Traceback Module Begin record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Module_Begin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|256
index|]
decl_stmt|;
comment|/* Arrange to store the data locally (leave room for size byte).  */
name|cp
operator|=
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* Begin module.  */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_MODBEG
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* flags; not used */
comment|/* Language type == "C"     (FIXME:  this should be based on the input...)  */
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|DST_S_C_C
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
comment|/* Store the module name.  */
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|strlen
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
comment|/* Now we can store the record size.  */
name|Size
operator|=
operator|(
name|cp
operator|-
name|Local
operator|)
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
comment|/* Put it into the object record.  */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the Traceback Module End record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Module_End
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|Local
index|[
literal|2
index|]
decl_stmt|;
comment|/* End module.  */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_MODEND
expr_stmt|;
comment|/* Put it into the object record.  */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|2
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a Traceback Routine Begin record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Routine_Begin
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|int
name|Psect
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/* Strip the leading "_" from the name.  */
name|Name
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/* Get the text psect offset.  */
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* Set the record size.  */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/* DST type "routine begin".  */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_RTNBEG
expr_stmt|;
comment|/* Uses CallS/CallG.  */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Store the data so far.  */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/* Make sure we are still generating a OBJ_S_C_TBT record.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/* Stack the address.  */
name|vms_tir_stack_psect
argument_list|(
name|Psect
argument_list|,
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the data reference.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* Store the counted string as data.  */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a Traceback Routine End record.     We *must* search the symbol table to find the next routine, since the    assembler has a way of reassembling the symbol table OUT OF ORDER Thus    the next routine in the symbol list is not necessarily the next one in    memory.  For debugging to work correctly we must know the size of the    routine.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Routine_End
parameter_list|(
name|int
name|Max_Size
parameter_list|,
name|symbolS
modifier|*
name|sp
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|long
name|Size
init|=
literal|0x7fffffff
decl_stmt|;
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
name|valueT
name|sym_value
decl_stmt|,
name|sp_value
init|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
condition|)
block|{
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'L'
condition|)
continue|continue;
name|sym_value
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|>
name|sp_value
operator|&&
name|sym_value
operator|<
name|Size
condition|)
name|Size
operator|=
name|sym_value
expr_stmt|;
comment|/* Dummy labels like "gcc_compiled." should no longer reach here.  */
if|#
directive|if
literal|0
block|else
comment|/* Check if gcc_compiled. has size of zero.  */
block|if (sym_value == sp_value&& 		sp != symbolP&& 		(!strcmp (S_GET_NAME (sp), "gcc_compiled.") || 		 !strcmp (S_GET_NAME (sp), "gcc2_compiled."))) 	      Size = sym_value;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|Size
operator|==
literal|0x7fffffff
condition|)
name|Size
operator|=
name|Max_Size
expr_stmt|;
name|Size
operator|-=
name|sp_value
expr_stmt|;
comment|/* and get the size of the routine */
comment|/* Record Size.  */
name|Local
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
comment|/* DST type is "routine end".  */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_RTNEND
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unused */
comment|/* Size of routine.  */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
literal|3
index|]
argument_list|,
name|Size
argument_list|)
expr_stmt|;
comment|/* Store the record.  */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a Traceback Block Begin record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Block_Begin
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|int
name|Psect
parameter_list|,
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/* Set the record size.  */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/* DST type is "begin block"; we simulate with a phony routine.  */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_BLKBEG
expr_stmt|;
comment|/* Uses CallS/CallG.  */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Store the data so far.  */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/* Make sure we are still generating a debug record.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/* Now get the symbol address.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
comment|/* Get the text psect offset.  */
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* Store the data reference.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* Store the counted string as data.  */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a Traceback Block End record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Block_End
parameter_list|(
name|valueT
name|Size
parameter_list|)
block|{
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
comment|/* record length */
comment|/* DST type is "block end"; simulate with a phony end routine.  */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_BLKEND
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unused, must be zero */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
literal|3
index|]
argument_list|,
name|Size
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a Line number<-> Program Counter correlation record.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Line_PC_Correlation
parameter_list|(
name|int
name|Line_Number
parameter_list|,
name|int
name|Offset
parameter_list|,
name|int
name|Psect
parameter_list|,
name|int
name|Do_Delta
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Local
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|Do_Delta
operator|==
literal|0
condition|)
block|{
comment|/* If not delta, set our PC/Line number correlation.  */
name|cp
operator|=
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* Put size in Local[0] later.  */
comment|/* DST type is "Line Number/PC correlation".  */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
comment|/* Set Line number.  */
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|255
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SET_LINUM_B
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|Line_Number
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|65535
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SET_LINE_NUM
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|Line_Number
operator|-
literal|1
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SET_LINUM_L
expr_stmt|;
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|Line_Number
operator|-
literal|1
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Set PC.  */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SET_ABS_PC
expr_stmt|;
comment|/* Store size now that we know it, then output the data.  */
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* Account for the space that TIR_S_C_STO_PIDR will use for the PC.  */
name|Local
index|[
literal|0
index|]
operator|+=
literal|4
expr_stmt|;
comment|/* size includes length of another longword */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/* Make sure we are still generating a OBJ_S_C_TBT record.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
name|vms_tir_stack_psect
argument_list|(
name|Psect
argument_list|,
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* Do a PC offset of 0 to register the line number.  */
name|Local
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Increment PC by 0 and register line # */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Do_Delta
operator|<
literal|0
condition|)
block|{
comment|/* When delta is negative, terminate the line numbers.  */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
name|DST_S_C_TERM_L
expr_stmt|;
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
literal|3
index|]
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do a PC/Line delta.  */
name|cp
operator|=
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
if|if
condition|(
name|Line_Number
operator|>
literal|1
condition|)
block|{
comment|/* We need to increment the line number.  */
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|255
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_INCR_LINUM
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|65535
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_INCR_LINUM_W
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|Line_Number
operator|-
literal|1
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_INCR_LINUM_L
expr_stmt|;
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|Line_Number
operator|-
literal|1
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Increment the PC.  */
if|if
condition|(
name|Offset
operator|<=
literal|128
condition|)
block|{
comment|/* Small offsets are encoded as negative numbers, rather than the 	     usual non-negative type code followed by another data field.  */
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
operator|-
name|Offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Offset
operator|<=
literal|65535
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_DELTA_PC_W
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|Offset
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_DELTA_PC_L
expr_stmt|;
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|Offset
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Set size now that be know it, then output the data.  */
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Describe a source file to the debugger.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_TBT_Source_File
parameter_list|(
name|char
modifier|*
name|Filename
parameter_list|,
name|int
name|ID_Number
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rfo
decl_stmt|,
name|ffb
decl_stmt|,
name|ebk
decl_stmt|;
name|char
name|cdt
index|[
literal|8
index|]
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Used for native assembly */
name|unsigned
name|Status
decl_stmt|;
name|struct
name|FAB
name|fab
decl_stmt|;
comment|/* RMS file access block */
name|struct
name|NAM
name|nam
decl_stmt|;
comment|/* file name information */
name|struct
name|XABDAT
name|xabdat
decl_stmt|;
comment|/* date+time fields */
name|struct
name|XABFHC
name|xabfhc
decl_stmt|;
comment|/* file header characteristics */
name|char
name|resultant_string_buffer
index|[
literal|255
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Set up RMS structures:  */
comment|/* FAB -- file access block */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fab
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$b_bid
operator|=
name|FAB$C_BID
expr_stmt|;
name|fab
operator|.
name|fab$b_bln
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
name|fab
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|Filename
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
operator|(
name|unsigned
name|char
operator|)
name|strlen
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_nam
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nam
expr_stmt|;
name|fab
operator|.
name|fab$l_xab
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xabdat
expr_stmt|;
comment|/* NAM -- file name block.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nam
argument_list|)
expr_stmt|;
name|nam
operator|.
name|nam$b_bid
operator|=
name|NAM$C_BID
expr_stmt|;
name|nam
operator|.
name|nam$b_bln
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
name|nam
expr_stmt|;
name|nam
operator|.
name|nam$l_rsa
operator|=
name|resultant_string_buffer
expr_stmt|;
name|nam
operator|.
name|nam$b_rss
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
sizeof|sizeof
name|resultant_string_buffer
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XABs -- extended attributes blocks.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xabdat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|xabdat
argument_list|)
expr_stmt|;
name|xabdat
operator|.
name|xab$b_cod
operator|=
name|XAB$C_DAT
expr_stmt|;
name|xabdat
operator|.
name|xab$b_bln
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
name|xabdat
expr_stmt|;
name|xabdat
operator|.
name|xab$l_nxt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xabfhc
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xabfhc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|xabfhc
argument_list|)
expr_stmt|;
name|xabfhc
operator|.
name|xab$b_cod
operator|=
name|XAB$C_FHC
expr_stmt|;
name|xabfhc
operator|.
name|xab$b_bln
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
name|xabfhc
expr_stmt|;
name|xabfhc
operator|.
name|xab$l_nxt
operator|=
literal|0
expr_stmt|;
comment|/* Get the file information.  */
name|Status
operator|=
name|sys$open
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Status
operator|&
literal|1
operator|)
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Couldn't find source file \"%s\", status=%%X%x"
argument_list|)
argument_list|,
name|Filename
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sys$close
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
comment|/* Now extract fields of interest.  */
name|memcpy
argument_list|(
name|cdt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xabdat
operator|.
name|xab$q_cdt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* creation date */
name|ebk
operator|=
name|xabfhc
operator|.
name|xab$l_ebk
expr_stmt|;
comment|/* end-of-file block */
name|ffb
operator|=
name|xabfhc
operator|.
name|xab$w_ffb
expr_stmt|;
comment|/* first free byte of last block */
name|rfo
operator|=
name|xabfhc
operator|.
name|xab$b_rfo
expr_stmt|;
comment|/* record format */
name|len
operator|=
name|nam
operator|.
name|nam$b_rsl
expr_stmt|;
comment|/* length of Filename */
name|resultant_string_buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Filename
operator|=
name|resultant_string_buffer
expr_stmt|;
comment|/* full filename */
else|#
directive|else
comment|/* Cross-assembly */
comment|/* [Perhaps we ought to use actual values derived from stat() here?]  */
name|memset
argument_list|(
name|cdt
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* null VMS quadword binary time */
name|ebk
operator|=
name|ffb
operator|=
name|rfo
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
comment|/* a single byte is used as count prefix */
block|{
name|Filename
operator|+=
operator|(
name|len
operator|-
literal|255
operator|)
expr_stmt|;
comment|/* tail end is more significant */
name|len
operator|=
literal|255
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VMS */
name|cp
operator|=
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* fill in record length later */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SOURCE
expr_stmt|;
comment|/* DST type is "source file" */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_FORMFEED
expr_stmt|;
comment|/* formfeeds count as source records */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_DECLFILE
expr_stmt|;
comment|/* declare source file */
name|know
argument_list|(
name|cp
operator|==
operator|&
name|Local
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* fill in this length below */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* flags; must be zero */
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|ID_Number
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* file ID number */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cdt
argument_list|,
literal|8
argument_list|)
operator|,
name|cp
operator|+=
literal|8
expr_stmt|;
comment|/* creation date+time */
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|ebk
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
comment|/* end-of-file block */
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|ffb
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* first free byte of last block */
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|rfo
expr_stmt|;
comment|/* RMS record format */
comment|/* Filename.  */
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|len
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|Filename
operator|++
expr_stmt|;
comment|/* Library module name (none).  */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Now that size is known, fill it in and write out the record.  */
name|Local
index|[
literal|4
index|]
operator|=
name|cp
operator|-
operator|&
name|Local
index|[
literal|5
index|]
expr_stmt|;
comment|/* source file declaration size */
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* TBT record size */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Traceback information is described in terms of lines from compiler    listing files, not lines from source files.  We need to set up the    correlation between listing line numbers and source line numbers.    Since gcc's .stabn directives refer to the source lines, we just    need to describe a one-to-one correspondence.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_TBT_Source_Lines
parameter_list|(
name|int
name|ID_Number
parameter_list|,
name|int
name|Starting_Line_Number
parameter_list|,
name|int
name|Number_Of_Lines
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|chunk_limit
decl_stmt|;
name|char
name|Local
index|[
literal|128
index|]
decl_stmt|;
comment|/* room enough to describe 1310700 lines...  */
name|cp
operator|=
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
comment|/* Put size in Local[0] later.  */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SOURCE
expr_stmt|;
comment|/* DST type is "source file".  */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETFILE
expr_stmt|;
comment|/* Set Source File.  */
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|ID_Number
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* File ID Number.  */
comment|/* Set record number and define lines.  Since no longword form of      SRC_DEFLINES is available, we need to be able to cope with any huge      files a chunk at a time.  It doesn't matter for tracebacks, since      unspecified lines are mapped one-to-one and work out right, but it      does matter within the debugger.  Without this explicit mapping,      it will complain about lines not existing in the module.  */
name|chunk_limit
operator|=
operator|(
sizeof|sizeof
name|Local
operator|-
literal|5
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|Number_Of_Lines
operator|>
literal|65535
operator|*
name|chunk_limit
condition|)
comment|/* avoid buffer overflow */
name|Number_Of_Lines
operator|=
literal|65535
operator|*
name|chunk_limit
expr_stmt|;
while|while
condition|(
name|Number_Of_Lines
operator|>
literal|65535
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETREC_L
expr_stmt|;
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|Starting_Line_Number
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_DEFLINES_W
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
literal|65535
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
name|Starting_Line_Number
operator|+=
literal|65535
expr_stmt|;
name|Number_Of_Lines
operator|-=
literal|65535
expr_stmt|;
block|}
comment|/* Set record number and define lines, normal case.  */
if|if
condition|(
name|Starting_Line_Number
operator|<=
literal|65535
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETREC_W
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|Starting_Line_Number
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETREC_L
expr_stmt|;
name|COPY_LONG
argument_list|(
name|cp
argument_list|,
name|Starting_Line_Number
argument_list|)
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_DEFLINES_W
expr_stmt|;
name|COPY_SHORT
argument_list|(
name|cp
argument_list|,
name|Number_Of_Lines
argument_list|)
operator|,
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* Set size now that be know it, then output the data.  */
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|&
name|Local
index|[
literal|1
index|]
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debugger Information support routines. */
end_comment

begin_comment
comment|/* This routine locates a file in the list of files.  If an entry does    not exist, one is created.  For include files, a new entry is always    created such that inline functions can be properly debugged.  */
end_comment

begin_function
specifier|static
name|struct
name|input_file
modifier|*
name|find_file
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|input_file
modifier|*
name|same_file
init|=
literal|0
decl_stmt|;
name|struct
name|input_file
modifier|*
name|fpnt
decl_stmt|,
modifier|*
name|last
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sp_name
decl_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|spnt
operator|==
name|sp
condition|)
return|return
name|fpnt
return|;
name|last
operator|=
name|fpnt
expr_stmt|;
block|}
name|sp_name
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sp_name
argument_list|,
name|fpnt
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|flag
operator|==
literal|1
condition|)
return|return
name|fpnt
return|;
name|same_file
operator|=
name|fpnt
expr_stmt|;
break|break;
block|}
block|}
name|fpnt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|input_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_root
condition|)
name|file_root
operator|=
name|fpnt
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|fpnt
expr_stmt|;
name|fpnt
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|name
operator|=
name|sp_name
expr_stmt|;
name|fpnt
operator|->
name|min_line
operator|=
literal|0x7fffffff
expr_stmt|;
name|fpnt
operator|->
name|max_line
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|spnt
operator|=
name|sp
expr_stmt|;
name|fpnt
operator|->
name|same_file_fpnt
operator|=
name|same_file
expr_stmt|;
return|return
name|fpnt
return|;
block|}
end_function

begin_comment
comment|/* This routine converts a number string into an integer, and stops when    it sees an invalid character.  The return value is the address of the    character just past the last character read.  No error is generated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cvt_integer
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|rtn
parameter_list|)
block|{
name|int
name|ival
init|=
literal|0
decl_stmt|,
name|sgn
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
name|sgn
operator|=
operator|-
literal|1
operator|,
operator|++
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|>=
literal|'0'
operator|&&
operator|*
name|str
operator|<=
literal|'9'
condition|)
name|ival
operator|=
literal|10
operator|*
name|ival
operator|+
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|rtn
operator|=
name|sgn
operator|*
name|ival
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions and definitions are used to generate object    records that will describe program variables to the VMS debugger.     This file contains many of the routines needed to output debugging info    into the object file that the VMS debugger needs to understand symbols.    These routines are called very late in the assembly process, and thus    we can be fairly lax about changing things, since the GSD and the TIR    sections have already been output.  */
end_comment

begin_comment
comment|/* This routine fixes the names that are generated by C++, ".this" is a good    example.  The period does not work for the debugger, since it looks like    the syntax for a structure element, and thus it gets mightily confused.     We also use this to strip the PsectAttribute hack from the name before we    write a debugger record.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fix_name
parameter_list|(
name|char
modifier|*
name|pnt
parameter_list|)
block|{
name|char
modifier|*
name|pnt1
decl_stmt|;
comment|/* Kill any leading "_".  */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'_'
condition|)
name|pnt
operator|++
expr_stmt|;
comment|/* Is there a Psect Attribute to skip??  */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|pnt
argument_list|)
condition|)
block|{
comment|/* Yes: Skip it.  */
name|pnt
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
condition|)
block|{
if|if
condition|(
operator|(
name|pnt
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|pnt
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|pnt
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|pnt
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here we fix the .this -> $this conversion.  */
for|for
control|(
name|pnt1
operator|=
name|pnt
init|;
operator|*
name|pnt1
operator|!=
literal|0
condition|;
name|pnt1
operator|++
control|)
if|if
condition|(
operator|*
name|pnt1
operator|==
literal|'.'
condition|)
operator|*
name|pnt1
operator|=
literal|'$'
expr_stmt|;
return|return
name|pnt
return|;
block|}
end_function

begin_comment
comment|/* When defining a structure, this routine is called to find the name of    the actual structure.  It is assumed that str points to the equal sign    in the definition, and it moves backward until it finds the start of the    name.  If it finds a 0, then it knows that this structure def is in the    outermost level, and thus symbol_name points to the symbol name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_struct_name
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'\0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|symbol_name
return|;
operator|*
name|pnt
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|';'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'='
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
name|pnt
operator|+
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|pnt
operator|>
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
return|return
name|pnt
return|;
block|}
end_function

begin_comment
comment|/* Search symbol list for type number dbx_type.    Return a pointer to struct.  */
end_comment

begin_function
specifier|static
name|struct
name|VMS_DBG_Symbol
modifier|*
name|find_symbol
parameter_list|(
name|int
name|dbx_type
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|spnt
operator|=
name|VMS_Symbol_type_list
index|[
name|SYMTYP_HASH
argument_list|(
name|dbx_type
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|spnt
condition|)
block|{
if|if
condition|(
name|spnt
operator|->
name|dbx_type
operator|==
name|dbx_type
condition|)
break|break;
name|spnt
operator|=
name|spnt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|spnt
operator|||
name|spnt
operator|->
name|advanced
operator|!=
name|ALIAS
condition|)
return|return
name|spnt
return|;
return|return
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* obsolete */
end_comment

begin_comment
comment|/* This routine puts info into either Local or Asuffix, depending on the sign    of size.  The reason is that it is easier to build the variable descriptor    backwards, while the array descriptor is best built forwards.  In the end    they get put together, if there is not a struct/union/enum along the way.  */
end_comment

begin_endif
unit|static void push (int value, int size1) {   if (size1< 0)     {       size1 = -size1;       if (Lpnt< size1) 	{ 	  overflow = 1; 	  Lpnt = 1; 	  return; 	}       Lpnt -= size1;       md_number_to_chars (&Local[Lpnt + 1], value, size1);     }   else     {       if (Apoint + size1>= MAX_DEBUG_RECORD) 	{ 	  overflow = 1; 	  Apoint = MAX_DEBUG_RECORD - 1; 	  return; 	}       md_number_to_chars (&Asuffix[Apoint], value, size1);       Apoint += size1;     } }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fpush
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|Apoint
operator|+
name|size
operator|>=
name|MAX_DEBUG_RECORD
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Apoint
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|Asuffix
index|[
name|Apoint
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|value
expr_stmt|;
else|else
block|{
name|md_number_to_chars
argument_list|(
operator|&
name|Asuffix
index|[
name|Apoint
index|]
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Apoint
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rpush
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|Lpnt
operator|<
name|size
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Lpnt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|Local
index|[
name|Lpnt
operator|--
index|]
operator|=
operator|(
name|char
operator|)
name|value
expr_stmt|;
else|else
block|{
name|Lpnt
operator|-=
name|size
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|Local
index|[
name|Lpnt
operator|+
literal|1
index|]
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine generates the array descriptor for a given array.  */
end_comment

begin_function
specifier|static
name|void
name|array_suffix
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt2
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|int
name|rank
decl_stmt|;
name|int
name|total_size
decl_stmt|;
name|rank
operator|=
literal|0
expr_stmt|;
name|spnt
operator|=
name|spnt2
expr_stmt|;
while|while
condition|(
name|spnt
operator|->
name|advanced
operator|!=
name|ARRAY
condition|)
block|{
name|spnt
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spnt
condition|)
return|return;
block|}
name|spnt1
operator|=
name|spnt
expr_stmt|;
name|total_size
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|rank
operator|++
expr_stmt|;
name|total_size
operator|*=
operator|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
operator|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
name|total_size
operator|=
name|total_size
operator|*
name|spnt1
operator|->
name|data_size
expr_stmt|;
name|fpush
argument_list|(
name|spnt1
operator|->
name|data_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* element size */
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|fpush
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|fpush
argument_list|(
name|spnt1
operator|->
name|VMS_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* element type */
name|fpush
argument_list|(
name|DSC_K_CLASS_A
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* descriptor class */
name|fpush
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* base address */
name|fpush
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* scale factor -- not applicable */
name|fpush
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* digit count -- not applicable */
name|fpush
argument_list|(
literal|0xc0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* flags: multiplier block& bounds present */
name|fpush
argument_list|(
name|rank
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* number of dimensions */
name|fpush
argument_list|(
name|total_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* pointer to element [0][0]...[0] */
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|fpush
argument_list|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|fpush
argument_list|(
name|spnt1
operator|->
name|index_min
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|spnt1
operator|->
name|index_max
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine generates the start of a variable descriptor based upon    a struct/union/enum that has yet to be defined.  We define this spot as    a new location, and save four bytes for the address.  When the struct is    finally defined, then we can go back and plug in the correct address.  */
end_comment

begin_function
specifier|static
name|void
name|new_forward_ref
parameter_list|(
name|int
name|dbx_type
parameter_list|)
block|{
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|fpnt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|forward_ref
argument_list|)
argument_list|)
expr_stmt|;
name|fpnt
operator|->
name|next
operator|=
name|f_ref_root
expr_stmt|;
name|f_ref_root
operator|=
name|fpnt
expr_stmt|;
name|fpnt
operator|->
name|dbx_type
operator|=
name|dbx_type
expr_stmt|;
name|fpnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|fpnt
operator|->
name|resolved
operator|=
literal|'N'
expr_stmt|;
name|rpush
argument_list|(
name|DST_K_TS_IND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* indirect type specification */
name|total_len
operator|=
literal|5
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|struct_number
operator|=
operator|-
name|fpnt
operator|->
name|struc_numb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine generates the variable descriptor used to describe non-basic    variables.  It calls itself recursively until it gets to the bottom of it    all, and then builds the descriptor backwards.  It is easiest to do it    this way since we must periodically write length bytes, and it is easiest    if we know the value when it is time to write it.  */
end_comment

begin_function
specifier|static
name|int
name|gen1
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|,
name|int
name|array_suffix_len
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|spnt
operator|->
name|advanced
condition|)
block|{
case|case
name|VOID
case|:
name|rpush
argument_list|(
name|DBG_S_C_VOID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|1
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
if|if
condition|(
name|array_suffix_len
operator|==
literal|0
condition|)
block|{
name|rpush
argument_list|(
name|spnt
operator|->
name|VMS_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rpush
argument_list|(
name|DBG_S_C_BASIC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|2
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rpush
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rpush
argument_list|(
name|DST_K_VFLAGS_DSC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rpush
argument_list|(
name|DST_K_TS_DSC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Descriptor type specification.  */
name|total_len
operator|=
operator|-
literal|2
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
case|case
name|ENUM
case|:
name|struct_number
operator|=
name|spnt
operator|->
name|struc_numb
expr_stmt|;
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rpush
argument_list|(
name|DBG_S_C_STRUCT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|5
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|POINTER
case|:
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|spnt1
condition|)
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* (*void) is a special case, do not put pointer suffix.  */
name|rpush
argument_list|(
name|DBG_S_C_POINTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|3
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
name|ARRAY
case|:
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spnt1
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugger forward reference error, dbx type %d"
argument_list|)
argument_list|,
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* It is too late to generate forward references, so the user 	 gets a message.  This should only happen on a compiler error.  */
operator|(
name|void
operator|)
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|Apoint
expr_stmt|;
name|array_suffix
argument_list|(
name|spnt
argument_list|)
expr_stmt|;
name|array_suffix_len
operator|=
name|Apoint
operator|-
name|i
expr_stmt|;
switch|switch
condition|(
name|spnt1
operator|->
name|advanced
condition|)
block|{
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
break|break;
default|default:
name|rpush
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|2
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|rpush
argument_list|(
name|DST_K_VFLAGS_DSC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rpush
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Flags: element value spec included.  */
name|rpush
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* One dimension.  */
name|rpush
argument_list|(
name|DBG_S_C_COMPLEX_ARRAY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|total_len
operator|+=
name|array_suffix_len
operator|+
literal|8
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This generates a suffix for a variable.  If it is not a defined type yet,    then dbx_type contains the type we are expecting so we can generate a    forward reference.  This calls gen1 to build most of the descriptor, and    then it puts the icing on at the end.  It then dumps whatever is needed    to get a complete descriptor (i.e. struct reference, array suffix).  */
end_comment

begin_function
specifier|static
name|void
name|generate_suffix
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|,
name|int
name|dbx_type
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|pvoid
index|[
literal|6
index|]
init|=
block|{
literal|5
block|,
comment|/* record.length == 5 */
name|DST_K_TYPSPEC
block|,
comment|/* record.type == 1 (type specification) */
literal|0
block|,
comment|/* name.length == 0, no name follows */
literal|1
block|,
literal|0
block|,
comment|/* type.length == 1 {2 bytes, little endian} */
name|DBG_S_C_VOID
comment|/* type.type == 5 (pointer to unspecified) */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
name|Lpnt
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
name|struct_number
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|spnt
condition|)
name|new_forward_ref
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|!=
name|DBG_S_C_ADVANCED_TYPE
condition|)
return|return;
comment|/* no suffix needed */
name|gen1
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rpush
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no name (len==0) */
name|rpush
argument_list|(
name|DST_K_TYPSPEC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|4
expr_stmt|;
name|rpush
argument_list|(
name|total_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the variable descriptor overflows the record, output a descriptor      for a pointer to void.  */
if|if
condition|(
operator|(
name|total_len
operator|>=
name|MAX_DEBUG_RECORD
operator|)
operator|||
name|overflow
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Variable descriptor %d too complicated.  Defined as `void *'."
argument_list|)
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|pvoid
argument_list|,
literal|6
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Lpnt
operator|<
name|MAX_DEBUG_RECORD
operator|-
literal|1
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|Local
index|[
operator|++
name|Lpnt
index|]
expr_stmt|;
name|Lpnt
operator|=
name|i
expr_stmt|;
comment|/* We use this for reference to structure that has already been defined.  */
if|if
condition|(
name|struct_number
operator|>
literal|0
condition|)
block|{
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
block|}
comment|/* We use this for a forward reference to a structure that has yet to      be defined.  We store four bytes of zero to make room for the actual      address once it is known.  */
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|struct_number
operator|=
operator|-
name|struct_number
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|Lpnt
index|]
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|Lpnt
operator|+=
literal|4
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|Apoint
condition|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|Asuffix
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|Lpnt
operator|!=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "novel length" type doesn't work for simple atomic types.  */
end_comment

begin_define
define|#
directive|define
name|USE_BITSTRING_DESCRIPTOR
parameter_list|(
name|t
parameter_list|)
value|((t)->advanced == BASIC)
end_define

begin_undef
undef|#
directive|undef
name|SETUP_BASIC_TYPES
end_undef

begin_comment
comment|/* This routine generates a type description for a bitfield.  */
end_comment

begin_function
specifier|static
name|void
name|bitfield_suffix
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|13
expr_stmt|;
comment|/* rec.len==13 */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|DST_K_TYPSPEC
expr_stmt|;
comment|/* a type specification record */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* not named */
name|COPY_SHORT
argument_list|(
operator|&
name|Local
index|[
name|Lpnt
index|]
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* typ.len==9 */
name|Lpnt
operator|+=
literal|2
expr_stmt|;
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|DST_K_TS_NOV_LENG
expr_stmt|;
comment|/* This type is a "novel length" 					   incarnation of some other type.  */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|Lpnt
index|]
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* size in bits == novel length */
name|Lpnt
operator|+=
literal|4
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
comment|/* assert( spnt->struc_numb> 0 ); */
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
comment|/* output 4 more bytes */
block|}
end_function

begin_comment
comment|/* Formally define a builtin type, so that it can serve as the target of    an indirect reference.  It makes bitfield_suffix() easier by avoiding    the need to use a forward reference for the first occurrence of each    type used in a bitfield.  */
end_comment

begin_function
specifier|static
name|void
name|setup_basic_type
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SETUP_BASIC_TYPES
comment|/* This would be very useful if "novel length" fields actually worked      with basic types like they do with enumerated types.  However,      they do not, so this isn't worth doing just so that you can use      EXAMINE/TYPE=(__long_long_int) instead of EXAMINE/QUAD.  */
name|char
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|SETUP_SYNONYM_TYPES
comment|/* This determines whether compatible things like `int' and `long int'      ought to have distinct type records rather than sharing one.  */
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt2
decl_stmt|;
comment|/* First check whether this type has already been seen by another name.  */
for|for
control|(
name|spnt2
operator|=
name|VMS_Symbol_type_list
index|[
name|SYMTYP_HASH
argument_list|(
name|spnt
operator|->
name|VMS_type
argument_list|)
index|]
init|;
name|spnt2
condition|;
name|spnt2
operator|=
name|spnt2
operator|->
name|next
control|)
if|if
condition|(
name|spnt2
operator|!=
name|spnt
operator|&&
name|spnt2
operator|->
name|VMS_type
operator|==
name|spnt
operator|->
name|VMS_type
condition|)
block|{
name|spnt
operator|->
name|struc_numb
operator|=
name|spnt2
operator|->
name|struc_numb
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* `structure number' doesn't really mean `structure'; it means an index      into a linker maintained set of saved locations which can be referenced      again later.  */
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
comment|/* remember where this type lives */
comment|/* define the simple scalar type */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|6
operator|+
name|strlen
argument_list|(
name|symbol_name
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* rec.len */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|DST_K_TYPSPEC
expr_stmt|;
comment|/* rec.typ==type specification */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
comment|/* prefix name with "__" */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbol_name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
operator|*
name|p
operator|==
literal|' '
condition|?
literal|'_'
else|:
operator|*
name|p
expr_stmt|;
name|COPY_SHORT
argument_list|(
operator|&
name|Local
index|[
name|Lpnt
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* typ.len==2 */
name|Lpnt
operator|+=
literal|2
expr_stmt|;
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|DST_K_TS_ATOM
expr_stmt|;
comment|/* typ.kind is simple type */
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
comment|/* typ.type */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SETUP_BASIC_TYPES */
block|}
end_function

begin_comment
comment|/* This routine generates a symbol definition for a C symbol for the    debugger.  It takes a psect and offset for global symbols; if psect< 0,    then this is a local variable and the offset is relative to FP.  In this    case it can be either a variable (Offset< 0) or a parameter (Offset> 0).  */
end_comment

begin_function
specifier|static
name|void
name|VMS_DBG_record
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|,
name|int
name|Psect
parameter_list|,
name|int
name|Offset
parameter_list|,
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|char
modifier|*
name|Name_pnt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* If there are bad characters in name, convert them.  */
name|Name_pnt
operator|=
name|fix_name
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|Name_pnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|Psect
operator|<
literal|0
condition|)
block|{
comment|/* This is a local variable, referenced to SP.  */
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|Offset
operator|>
literal|0
operator|)
condition|?
name|DBG_C_FUNCTION_PARAM
else|:
name|DBG_C_LOCAL_SYM
expr_stmt|;
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VALKIND_ADDR
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|*
name|Name_pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|Name_pnt
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine parses the stabs entries in order to make the definition    for the debugger of local symbols and function parameters.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_local_stab_Parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnt
condition|)
return|return;
comment|/* Save this for later, and skip colon.  */
name|pnt1
operator|=
name|pnt
operator|++
expr_stmt|;
comment|/* Ignore static constants.  */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
return|return;
comment|/* There is one little catch that we must be aware of.  Sometimes function      parameters are optimized into registers, and the compiler, in its      infiite wisdom outputs stabs records for *both*.  In general we want to      use the register if it is present, so we must search the rest of the      symbols for this function to see if this parameter is assigned to a      register.  */
block|{
name|symbolS
modifier|*
name|sp1
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'p'
condition|)
block|{
for|for
control|(
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
init|;
name|sp1
condition|;
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|sp1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp1
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt2
operator|==
literal|'F'
operator|||
operator|*
name|pnt2
operator|==
literal|'f'
condition|)
break|break;
block|}
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp1
argument_list|)
operator|!=
name|N_RSYM
condition|)
continue|continue;
name|str1
operator|=
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
comment|/* and get the name */
name|pnt2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|pnt2
operator|!=
operator|*
name|str1
condition|)
break|break;
name|pnt2
operator|++
expr_stmt|;
name|str1
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str1
operator|==
literal|':'
operator|&&
operator|*
name|pnt2
operator|==
literal|':'
condition|)
return|return;
comment|/* They are the same!  Let's skip this one.  */
block|}
comment|/* Skip p in case no register.  */
name|pnt
operator|++
expr_stmt|;
block|}
block|}
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spnt
condition|)
comment|/* Dunno what this is.  */
return|return;
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
operator|-
literal|1
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* ...and restore the string.  */
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine parses a stabs entry to find the information required    to define a variable.  It is used for global and static variables.    Basically we need to know the address of the symbol.  With older    versions of the compiler, const symbols are treated differently, in    that if they are global they are written into the text psect.  The    global symbol entry for such a const is actually written as a program    entry point (Yuk!!), so if we cannot find a symbol in the list of    psects, we must search the entry points as well.  static consts are    even harder, since they are never assigned a memory address.  The    compiler passes a stab to tell us the value, but I am not sure what    to do with it.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_stab_parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|int
name|expected_type
parameter_list|,
name|int
name|type1
parameter_list|,
name|int
name|type2
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|symbolS
modifier|*
name|sp1
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnt
condition|)
comment|/* No colon present.  */
return|return;
comment|/* Save this for later. */
name|pnt1
operator|=
name|pnt
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
name|expected_type
condition|)
block|{
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spnt
condition|)
return|return;
comment|/*Dunno what this is*/
comment|/* Now we need to search the symbol table to find the psect and          offset for this variable.  */
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|vsp
operator|=
name|VMS_Symbols
expr_stmt|;
while|while
condition|(
name|vsp
condition|)
block|{
name|pnt
operator|=
name|S_GET_NAME
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|&&
operator|*
name|pnt
operator|++
operator|==
literal|'_'
comment|/* make sure name is the same and symbol type matches */
operator|&&
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|type1
operator|||
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|type2
operator|)
condition|)
break|break;
name|vsp
operator|=
name|vsp
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|vsp
condition|)
block|{
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return;
block|}
comment|/* The symbol was not in the symbol list, but it may be an          "entry point" if it was a constant.  */
for|for
control|(
name|sp1
operator|=
name|symbol_rootP
init|;
name|sp1
condition|;
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp1
argument_list|)
control|)
block|{
comment|/* Dispatch on STAB type.  */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp1
argument_list|)
operator|||
operator|(
name|S_GET_TYPE
argument_list|(
name|sp1
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
continue|continue;
name|pnt
operator|=
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'_'
condition|)
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|gave_compiler_message
operator|&&
name|expected_type
operator|==
literal|'G'
condition|)
block|{
name|char
modifier|*
name|long_const_msg
init|=
name|_
argument_list|(
literal|"\ ***Warning - the assembly code generated by the compiler has placed \n\  global constant(s) in the text psect.  These will not be available to \n\  other modules, since this is not the correct way to handle this. You \n\  have two options: 1) get a patched compiler that does not put global \n\  constants in the text psect, or 2) remove the 'const' keyword from \n\  definitions of global variables in your source module(s).  Don't say \n\  I didn't warn you! \n"
argument_list|)
decl_stmt|;
name|as_tsktsk
argument_list|(
name|long_const_msg
argument_list|)
expr_stmt|;
name|gave_compiler_message
operator|=
literal|1
expr_stmt|;
block|}
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp1
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* Fool assembler to not output this as a routine in the TBT.  */
name|pnt1
operator|=
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|'L'
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|sp1
argument_list|,
name|pnt1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* ...and restore the string.  */
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simpler interfaces into VMS_stab_parse().  */
end_comment

begin_function
specifier|static
name|void
name|VMS_GSYM_Parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
comment|/* Global variables */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'G'
argument_list|,
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
argument_list|,
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|VMS_LCSYM_Parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_BSS
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|VMS_STSYM_Parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_DATA
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For register symbols, we must figure out what range of addresses    within the psect are valid.  We will use the brackets in the stab    directives to give us guidance as to the PC range that this variable    is in scope.  I am still not completely comfortable with this but    as I learn more, I seem to get a better handle on what is going on.    Caveat Emptor.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_RSYM_Parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|symbolS
modifier|*
name|Current_Routine
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|bcnt
init|=
literal|0
decl_stmt|;
name|int
name|Min_Offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* min PC of validity */
name|int
name|Max_Offset
init|=
literal|0
decl_stmt|;
comment|/* max PC of validity */
for|for
control|(
name|symbolP
operator|=
name|sp
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|bcnt
operator|++
operator|==
literal|0
condition|)
name|Min_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
if|if
condition|(
operator|--
name|bcnt
operator|==
literal|0
condition|)
name|Max_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|Min_Offset
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|bcnt
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
block|}
comment|/* Check to see that the addresses were defined.  If not, then there      were no brackets in the function, and we must try to search for      the next function.  Since functions can be in any order, we should      search all of the symbol list to find the correct ending address.  */
if|if
condition|(
name|Min_Offset
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|Max_Source_Offset
decl_stmt|;
name|int
name|This_Offset
decl_stmt|;
name|Min_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|Max_Source_Offset
operator|=
name|Min_Offset
expr_stmt|;
comment|/* just in case no N_SLINEs found */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|This_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|This_Offset
operator|>
name|Min_Offset
operator|&&
name|This_Offset
operator|<
name|Max_Offset
condition|)
name|Max_Offset
operator|=
name|This_Offset
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
name|This_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|This_Offset
operator|>
name|Max_Source_Offset
condition|)
name|Max_Source_Offset
operator|=
name|This_Offset
expr_stmt|;
break|break;
block|}
comment|/* If this is the last routine, then we use the PC of the last source          line as a marker of the max PC for which this reg is valid.  */
if|if
condition|(
name|Max_Offset
operator|==
literal|0x7fffffff
condition|)
name|Max_Offset
operator|=
name|Max_Source_Offset
expr_stmt|;
block|}
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
expr_stmt|;
comment|/* save this for later*/
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|!=
literal|'r'
condition|)
return|return;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spnt
condition|)
return|return;
comment|/*Dunno what this is yet*/
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|pnt
operator|=
name|fix_name
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if there are bad characters in name, convert them */
name|len
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|25
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VFLAGS_TVS
expr_stmt|;
comment|/* trailing value specified */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* relative offset, beyond name */
name|i
operator|+=
literal|4
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|len
expr_stmt|;
comment|/* name length (ascic prefix) */
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VS_FOLLOWS
expr_stmt|;
comment|/* value specification follows */
name|COPY_SHORT
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* length of rest of record */
name|i
operator|+=
literal|2
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VS_ALLOC_SPLIT
expr_stmt|;
comment|/* split lifetime */
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
comment|/* one binding follows */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Min_Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Max_Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VALKIND_REG
expr_stmt|;
comment|/* nested value spec */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function examines a structure definition, checking all of the elements    to make sure that all of them are fully defined.  The only thing that we    kick out are arrays of undefined structs, since we do not know how big    they are.  All others we can handle with a normal forward reference.  */
end_comment

begin_function
specifier|static
name|int
name|forward_reference
parameter_list|(
name|char
modifier|*
name|pnt
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|,
modifier|*
name|spnt1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
comment|/* no forward references */
do|do
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|spnt
operator|&&
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|POINTER
operator|||
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
condition|)
block|{
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|&&
operator|!
name|spnt1
condition|)
return|return
literal|1
return|;
name|spnt
operator|=
name|spnt1
expr_stmt|;
block|}
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
do|;
return|return
literal|0
return|;
comment|/* no forward references found */
block|}
end_function

begin_comment
comment|/* Used to check a single element of a structure on the final pass.  */
end_comment

begin_function
specifier|static
name|int
name|final_forward_reference
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
while|while
condition|(
name|spnt
operator|&&
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|POINTER
operator|||
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
condition|)
block|{
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|&&
operator|!
name|spnt1
condition|)
return|return
literal|1
return|;
name|spnt
operator|=
name|spnt1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* no forward references found */
block|}
end_function

begin_comment
comment|/* This routine parses the stabs directives to find any definitions of dbx    type numbers.  It makes a note of all of them, creating a structure    element of VMS_DBG_Symbol that describes it.  This also generates the    info for the debugger that describes the struct/union/enum, so that    further references to these data types will be by number     We have to process pointers right away, since there can be references    to them later in the same stabs directive.  We cannot have forward    references to pointers, (but we can have a forward reference to a    pointer to a structure/enum/union) and this is why we process them    immediately.  After we process the pointer, then we search for defs    that are nested even deeper.     8/15/92: We have to process arrays right away too, because there can    be multiple references to identical array types in one structure    definition, and only the first one has the definition.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_typedef_parse
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
specifier|const
name|char
modifier|*
name|pnt2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dtype
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
comment|/* check for any nested def's */
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'a'
operator|||
name|str
index|[
literal|2
index|]
operator|!=
literal|'r'
operator|)
operator|&&
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* now find dbx_type of entry */
name|pnt
operator|=
name|str
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
block|{
comment|/* check for static constants */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
comment|/* for now we ignore them */
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
comment|/* and get back to the number */
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i1
argument_list|)
expr_stmt|;
comment|/* First see if this has been defined already, due to forward reference.  */
if|if
condition|(
operator|!
name|spnt
condition|)
block|{
name|i2
operator|=
name|SYMTYP_HASH
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|VMS_DBG_Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|next
operator|=
name|VMS_Symbol_type_list
index|[
name|i2
index|]
expr_stmt|;
name|VMS_Symbol_type_list
index|[
name|i2
index|]
operator|=
name|spnt
expr_stmt|;
name|spnt
operator|->
name|dbx_type
operator|=
name|i1
expr_stmt|;
comment|/* and save the type */
name|spnt
operator|->
name|type2
operator|=
name|spnt
operator|->
name|VMS_type
operator|=
name|spnt
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|spnt
operator|->
name|index_min
operator|=
name|spnt
operator|->
name|index_max
operator|=
name|spnt
operator|->
name|struc_numb
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For structs and unions, do a partial parse, otherwise we sometimes get      circular definitions that are impossible to resolve.  We read enough      info so that any reference to this type has enough info to be resolved.  */
comment|/* Point to character past equal sign.  */
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|&&
operator|*
name|pnt
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|type_check
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
comment|/* this is the void symbol */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|spnt
operator|->
name|advanced
operator|=
name|VOID
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type_check
argument_list|(
literal|"unknown type"
argument_list|)
condition|)
block|{
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|spnt
operator|->
name|advanced
operator|=
name|UNKNOWN
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|!=
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|spnt
operator|->
name|advanced
operator|=
name|ALIAS
expr_stmt|;
name|spnt
operator|->
name|type2
operator|=
name|i1
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|pnt1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugginer output: %d is an unknown untyped variable."
argument_list|)
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* do not know what this is */
block|}
comment|/* Point to character past equal sign.  */
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|pnt
condition|)
block|{
case|case
literal|'r'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|BASIC
expr_stmt|;
if|if
condition|(
name|type_check
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SSINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_USINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"signed char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_UCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_REAL4
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|vax_g_doubles
condition|?
name|DBG_S_C_REAL8_G
else|:
name|DBG_S_C_REAL8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long double"
argument_list|)
condition|)
block|{
comment|/* same as double, at least for now */
name|spnt
operator|->
name|VMS_type
operator|=
name|vax_g_doubles
condition|?
name|DBG_S_C_REAL8_G
else|:
name|DBG_S_C_REAL8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long long int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SQUAD
expr_stmt|;
comment|/* signed quadword */
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long long unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_UQUAD
expr_stmt|;
comment|/* unsigned quadword */
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"complex float"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_COMPLX4
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
operator|*
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"complex double"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|vax_g_doubles
condition|?
name|DBG_S_C_COMPLX8_G
else|:
name|DBG_S_C_COMPLX8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
operator|*
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"complex long double"
argument_list|)
condition|)
block|{
comment|/* same as complex double, at least for now */
name|spnt
operator|->
name|VMS_type
operator|=
name|vax_g_doubles
condition|?
name|DBG_S_C_COMPLX8_G
else|:
name|DBG_S_C_COMPLX8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
operator|*
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Shouldn't get here, but if we do, something 	     more substantial ought to be done...  */
name|spnt
operator|->
name|VMS_type
operator|=
literal|0
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|!=
literal|0
condition|)
name|setup_basic_type
argument_list|(
name|spnt
argument_list|)
expr_stmt|;
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|';'
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
name|spnt
operator|->
name|advanced
operator|=
operator|(
operator|*
name|pnt
operator|==
literal|'s'
operator|)
condition|?
name|STRUCT
else|:
name|UNION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_pass
operator|&&
name|forward_reference
argument_list|(
name|pnt
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|struc_numb
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|pnt1
operator|--
expr_stmt|;
name|pnt
operator|=
name|get_struct_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fpnt
operator|=
name|f_ref_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|11
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VFLAGS_NOVAL
expr_stmt|;
comment|/* structure definition only */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* hence value is unused */
name|i
operator|+=
literal|4
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|i2
operator|=
name|spnt
operator|->
name|data_size
operator|*
literal|8
expr_stmt|;
comment|/* number of bits */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnt
operator|!=
name|symbol_name
condition|)
block|{
name|pnt
operator|+=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
comment|/* Replace colon for later.  */
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|++
name|pnt1
operator|!=
literal|';'
condition|)
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt2
operator|=
name|pnt1
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dtype
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i3
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt1
operator|&&
operator|(
name|spnt1
operator|->
name|advanced
operator|==
name|BASIC
operator|||
name|spnt1
operator|->
name|advanced
operator|==
name|ENUM
operator|)
operator|&&
operator|(
operator|(
name|i3
operator|!=
name|spnt1
operator|->
name|data_size
operator|*
literal|8
operator|)
operator|||
operator|(
name|i2
operator|%
literal|8
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* bitfield */
if|if
condition|(
name|USE_BITSTRING_DESCRIPTOR
argument_list|(
name|spnt1
argument_list|)
condition|)
block|{
comment|/* This uses a type descriptor, which doesn't work if 		     the enclosing structure has been placed in a register. 		     Also, enum bitfields degenerate to simple integers.  */
name|int
name|unsigned_type
init|=
operator|(
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ULINT
operator|||
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_USINT
operator|||
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_UCHAR
operator|||
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_UQUAD
operator|||
name|spnt1
operator|->
name|advanced
operator|==
name|ENUM
operator|)
decl_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
name|fpush
argument_list|(
literal|19
operator|+
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|unsigned_type
condition|?
name|DBG_S_C_UBITU
else|:
name|DBG_S_C_SBITU
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|DST_K_VFLAGS_DSC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* specified by descriptor */
name|fpush
argument_list|(
literal|1
operator|+
name|len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* relative offset to descriptor */
name|fpush
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* length byte (ascic prefix) */
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
comment|/* name bytes */
name|fpush
argument_list|(
operator|*
name|pnt2
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|i3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* dsc length == size of bitfield */
comment|/* dsc type == un?signed bitfield */
name|fpush
argument_list|(
name|unsigned_type
condition|?
name|DBG_S_C_UBITU
else|:
name|DBG_S_C_SBITU
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|DSC_K_CLASS_UBS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* dsc class == unaligned bitstring */
name|fpush
argument_list|(
literal|0x00
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* dsc pointer == zeroes */
name|fpush
argument_list|(
name|i2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* start position */
name|VMS_Store_Immediate_Data
argument_list|(
name|Asuffix
argument_list|,
name|Apoint
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Use a "novel length" type specification, which works 		     right for register structures and for enum bitfields 		     but results in larger object modules.  */
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
comment|/* type spec follows */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_ITEM
expr_stmt|;
comment|/* value is a bit offset */
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* bit offset */
name|i
operator|+=
literal|4
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bitfield_suffix
argument_list|(
name|spnt1
argument_list|,
name|i3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Not a bitfield.  */
block|{
comment|/* Check if this is a forward reference.  */
if|if
condition|(
name|final_pass
operator|&&
name|final_forward_reference
argument_list|(
name|spnt1
argument_list|)
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugger output: structure element `%s' has undefined type"
argument_list|)
argument_list|,
name|pnt2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt1
condition|?
name|spnt1
operator|->
name|VMS_type
else|:
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_ITEM
expr_stmt|;
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* bit offset */
name|i
operator|+=
literal|4
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|spnt1
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|pnt1
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* length byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ENUM
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fpnt
operator|=
name|f_ref_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|3
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|4
operator|*
literal|8
expr_stmt|;
comment|/* enum values are 32 bits */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|len
expr_stmt|;
name|pnt2
operator|=
name|symbol_name
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
block|{
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|len
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_ITEM
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DST_K_VALKIND_LITERAL
expr_stmt|;
name|COPY_LONG
argument_list|(
operator|&
name|Local
index|[
name|i
index|]
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|len
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt
operator|=
name|pnt1
expr_stmt|;
comment|/* Skip final semicolon */
block|}
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* len byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ARRAY
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnt
condition|)
return|return
literal|1
return|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_min
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_max
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|&&
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'f'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|FUNCTION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_FUNCTION_ADDR
expr_stmt|;
comment|/* this masquerades as a basic type*/
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|POINTER
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|&&
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
break|break;
default|default:
name|spnt
operator|->
name|advanced
operator|=
name|UNKNOWN
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
literal|0
expr_stmt|;
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugger output: %d is an unknown type of variable."
argument_list|)
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unable to decipher */
block|}
comment|/* This removes the evidence of the definition so that the outer levels      of parsing do not have to worry about it.  */
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt1
operator|!=
literal|'\0'
condition|)
operator|*
name|pnt
operator|++
operator|=
operator|*
name|pnt1
operator|++
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is the root routine that parses the stabs entries for definitions.    it calls VMS_typedef_parse, which can in turn call itself.  We need to    be careful, since sometimes there are forward references to other symbol    types, and these cannot be resolved until we have completed the parse.     Also check and see if we are using continuation stabs, if we are, then    paste together the entire contents of the stab before we pass it to    VMS_typedef_parse.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_LSYM_Parse
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|parse_buffer
init|=
literal|0
decl_stmt|;
name|char
name|fixit
index|[
literal|10
index|]
decl_stmt|;
name|int
name|incomplete
decl_stmt|,
name|pass
decl_stmt|,
name|incom1
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|final_pass
operator|=
literal|0
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|incom1
operator|=
name|incomplete
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
control|)
block|{
comment|/* Deal with STAB symbols.  */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
name|N_GSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_STSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_FUN
case|:
comment|/* Sometimes these contain typedefs. */
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|str
expr_stmt|;
name|pnt
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'?'
condition|)
comment|/* Continuation stab.  */
block|{
name|symbolS
modifier|*
name|spnext
decl_stmt|;
name|int
name|tlen
init|=
literal|0
decl_stmt|;
name|spnext
operator|=
name|sp
expr_stmt|;
do|do
block|{
name|tlen
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
name|spnext
operator|=
name|symbol_next
argument_list|(
name|spnext
argument_list|)
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|spnext
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|pnt
operator|==
literal|'?'
condition|)
do|;
name|tlen
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|parse_buffer
operator|=
name|xmalloc
argument_list|(
name|tlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|parse_buffer
argument_list|,
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|parse_buffer
operator|+
name|strlen
argument_list|(
name|parse_buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|pnt2
operator|=
literal|'\0'
expr_stmt|;
name|spnext
operator|=
name|sp
expr_stmt|;
do|do
block|{
name|spnext
operator|=
name|symbol_next
argument_list|(
name|spnext
argument_list|)
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|spnext
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pnt2
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|pnt2
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
comment|/* Erase this string  */
comment|/* S_SET_NAME (spnext, str); */
if|if
condition|(
operator|*
name|pnt2
operator|!=
literal|'?'
condition|)
break|break;
operator|*
name|pnt2
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|str
operator|=
name|parse_buffer
expr_stmt|;
name|symbol_name
operator|=
name|str
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|incomplete
operator|+=
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_buffer
condition|)
block|{
comment|/*  At this point the parse buffer should just 			      contain name:nn.  If it does not, then we 			      are in real trouble.  Anyway, this is always 			      shorter than the original line.  */
name|pnt2
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pnt2
argument_list|,
name|parse_buffer
argument_list|)
expr_stmt|;
comment|/* S_SET_NAME (sp, pnt2); */
name|free
argument_list|(
name|parse_buffer
argument_list|)
operator|,
name|parse_buffer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put back colon to restore dbx_type.  */
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|pass
operator|++
expr_stmt|;
comment|/* Make one last pass, if needed, and define whatever we can          that is left.  */
if|if
condition|(
name|final_pass
operator|==
literal|0
operator|&&
name|incomplete
operator|==
name|incom1
condition|)
block|{
name|final_pass
operator|=
literal|1
expr_stmt|;
name|incom1
operator|++
expr_stmt|;
comment|/* Force one last pass through.  */
block|}
block|}
do|while
condition|(
name|incomplete
operator|!=
literal|0
operator|&&
name|incomplete
operator|!=
name|incom1
condition|)
do|;
if|if
condition|(
name|incomplete
operator|!=
literal|0
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugger output: Unable to resolve %d circular references."
argument_list|)
argument_list|,
name|incomplete
argument_list|)
expr_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
name|symbol_name
operator|=
literal|"\0"
expr_stmt|;
while|while
condition|(
name|fpnt
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|resolved
operator|!=
literal|'Y'
condition|)
block|{
if|if
condition|(
name|find_symbol
argument_list|(
name|fpnt
operator|->
name|dbx_type
argument_list|)
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"debugger forward reference error, dbx type %d"
argument_list|)
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|fixit
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|"%d=s4;"
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
block|}
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|Define_Local_Symbols
parameter_list|(
name|symbolS
modifier|*
name|s0P
parameter_list|,
name|symbolS
modifier|*
name|s2P
parameter_list|,
name|symbolS
modifier|*
name|Current_Routine
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|symbolS
modifier|*
name|s1P
decl_stmt|;
comment|/* Each symbol from s0P .. s2P (exclusive).  */
for|for
control|(
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s0P
argument_list|)
init|;
name|s1P
operator|!=
name|s2P
condition|;
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s1P
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|s1P
condition|)
break|break;
comment|/* and return */
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|s1P
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|char
modifier|*
name|pnt
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|s1P
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|s1P
argument_list|)
condition|)
continue|continue;
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|s1P
argument_list|)
condition|)
block|{
default|default:
comment|/* Not left or right brace.  */
continue|continue;
case|case
name|N_LSYM
case|:
case|case
name|N_PSYM
case|:
name|VMS_local_stab_Parse
argument_list|(
name|s1P
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RSYM
case|:
name|VMS_RSYM_Parse
argument_list|(
name|s1P
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function crawls the symbol chain searching for local symbols that    need to be described to the debugger.  When we enter a new scope with    a "{", it creates a new "block", which helps the debugger keep track    of which scope we are currently in.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|Define_Routine
parameter_list|(
name|symbolS
modifier|*
name|s0P
parameter_list|,
name|int
name|Level
parameter_list|,
name|symbolS
modifier|*
name|Current_Routine
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|symbolS
modifier|*
name|s1P
decl_stmt|;
name|valueT
name|Offset
decl_stmt|;
name|int
name|rcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s0P
argument_list|)
init|;
name|s1P
operator|!=
literal|0
condition|;
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s1P
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|s1P
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|char
modifier|*
name|pnt
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|s1P
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|s1P
argument_list|)
condition|)
continue|continue;
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|s1P
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
block|{
name|char
name|str
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"$%d"
argument_list|,
name|rcount
operator|++
argument_list|)
expr_stmt|;
name|VMS_TBT_Block_Begin
argument_list|(
name|s1P
argument_list|,
name|Text_Psect
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* Side-effect: fully resolve symbol.  */
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|s1P
argument_list|)
expr_stmt|;
name|Define_Local_Symbols
argument_list|(
name|s0P
argument_list|,
name|s1P
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
name|s1P
operator|=
name|Define_Routine
argument_list|(
name|s1P
argument_list|,
name|Level
operator|+
literal|1
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
name|VMS_TBT_Block_End
argument_list|(
name|S_GET_VALUE
argument_list|(
name|s1P
argument_list|)
operator|-
name|Offset
argument_list|)
expr_stmt|;
name|s0P
operator|=
name|s1P
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
return|return
name|s1P
return|;
block|}
block|}
comment|/* We end up here if there were no brackets in this function.      Define everything.  */
name|Define_Local_Symbols
argument_list|(
name|s0P
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
return|return
name|s1P
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
specifier|static
name|void
name|get_VMS_time_on_unix
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Manufacture a VMS-like time string on a Unix based system.  */
end_comment

begin_function
specifier|static
name|void
name|get_VMS_time_on_unix
parameter_list|(
name|char
modifier|*
name|Now
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|time_t
name|timeb
decl_stmt|;
name|time
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|ctime
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|pnt
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|Now
argument_list|,
literal|"%2s-%3s-%s %s"
argument_list|,
name|pnt
operator|+
literal|8
argument_list|,
name|pnt
operator|+
literal|4
argument_list|,
name|pnt
operator|+
literal|20
argument_list|,
name|pnt
operator|+
literal|11
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_comment
comment|/* Write the MHD (Module Header) records.  */
end_comment

begin_function
specifier|static
name|void
name|Write_VMS_MHD_Records
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp1
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
struct|struct
block|{
name|unsigned
name|short
name|len
decl_stmt|,
name|mbz
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
name|Descriptor
struct|;
endif|#
directive|endif
name|char
name|Now
index|[
literal|17
operator|+
literal|1
index|]
decl_stmt|;
comment|/* We are writing a module header record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
expr_stmt|;
comment|/* MAIN MODULE HEADER RECORD.  */
comment|/* Store record type and header type.  */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|MHD_S_C_MHD
argument_list|)
expr_stmt|;
comment|/* Structure level is 0.  */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_STRLVL
argument_list|)
expr_stmt|;
comment|/* Maximum record size is size of the object record buffer.  */
name|PUT_SHORT
argument_list|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME:  module name and version should be user 	     specifiable via `.ident' and/or `#pragma ident'.  */
comment|/* Get module name (the FILENAME part of the object file).  */
name|cp
operator|=
name|out_file_name
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|']'
operator|||
operator|*
name|cp
operator|==
literal|'>'
operator|||
operator|*
name|cp
operator|==
literal|':'
operator|||
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|cp1
operator|=
name|Module_Name
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp1
operator|++
operator|=
name|TOUPPER
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
comment|/* Limit it to 31 characters and store in the object record.  */
while|while
condition|(
operator|--
name|cp1
operator|>=
name|Module_Name
condition|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
condition|)
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|Module_Name
argument_list|)
operator|>
literal|31
condition|)
block|{
if|if
condition|(
name|flag_hash_long_names
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Module name truncated: %s\n"
argument_list|)
argument_list|,
name|Module_Name
argument_list|)
expr_stmt|;
name|Module_Name
index|[
literal|31
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|PUT_COUNTED_STRING
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
comment|/* Module Version is "V1.0".  */
name|PUT_COUNTED_STRING
argument_list|(
literal|"V1.0"
argument_list|)
expr_stmt|;
comment|/* Creation time is "now" (17 chars of time string): "dd-MMM-yyyy hh:mm".  */
ifndef|#
directive|ifndef
name|VMS
name|get_VMS_time_on_unix
argument_list|(
name|Now
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|Descriptor
operator|.
name|len
operator|=
sizeof|sizeof
name|Now
operator|-
literal|1
expr_stmt|;
name|Descriptor
operator|.
name|mbz
operator|=
literal|0
expr_stmt|;
comment|/* type& class unspecified */
name|Descriptor
operator|.
name|ptr
operator|=
name|Now
expr_stmt|;
operator|(
name|void
operator|)
name|sys$asctim
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|Descriptor
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
name|Now
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Patch time is "never" (17 zeros).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Force this to be a separate output record.  */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* LANGUAGE PROCESSOR NAME.  */
comment|/* Store record type and header type.  */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|MHD_S_C_LNM
argument_list|)
expr_stmt|;
comment|/* Store language processor name and version (not a counted string!).      This is normally supplied by the gcc driver for the command line      which invokes gas.  If absent, we fall back to gas's version.  */
name|cp
operator|=
name|compiler_version_string
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|"GNU AS  V"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|=
name|VERSION
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|>=
literal|' '
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* Force this to be a separate output record.  */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the EOM (End Of Module) record.  */
end_comment

begin_function
specifier|static
name|void
name|Write_VMS_EOM_Record
parameter_list|(
name|int
name|Psect
parameter_list|,
name|valueT
name|Offset
parameter_list|)
block|{
comment|/* We are writing an end-of-module record      (this assumes that the entry point will always be in a psect      represented by a single byte, which is the case for code in      Text_Psect==0).  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_EOM
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_EOM
argument_list|)
expr_stmt|;
comment|/* Record type.  */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Error severity level (we ignore it).  */
comment|/* Store the entry point, if it exists.  */
if|if
condition|(
name|Psect
operator|>=
literal|0
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the record; this will be our final output.  */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This hash routine borrowed from GNU-EMACS, and strengthened slightly    ERY.  */
end_comment

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|3
operator|)
operator|+
operator|(
name|hash
operator|<<
literal|15
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|28
operator|)
operator|+
name|c
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Generate a Case-Hacked VMS symbol name (limited to 31 chars).  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Case_Hack_Symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|In
parameter_list|,
name|char
modifier|*
name|Out
parameter_list|)
block|{
name|long
name|int
name|init
decl_stmt|;
name|long
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|pnt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|destructor
init|=
literal|0
decl_stmt|;
comment|/* Hack to allow for case sens in a destructor.  */
name|int
name|truncate
init|=
literal|0
decl_stmt|;
name|int
name|Case_Hack_Bits
init|=
literal|0
decl_stmt|;
name|int
name|Saw_Dollar
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|Hex_Table
index|[
literal|16
index|]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/* Kill any leading "_".  */
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
operator|&&
operator|(
operator|(
name|In
index|[
literal|1
index|]
operator|>
literal|'9'
operator|)
operator|||
operator|(
name|In
index|[
literal|1
index|]
operator|<
literal|'0'
operator|)
operator|)
condition|)
name|In
operator|++
expr_stmt|;
name|new_name
operator|=
name|Out
expr_stmt|;
comment|/* Save this for later.  */
if|#
directive|if
literal|0
block|if ((In[0] == '_')&& (In[1] == '$')&& (In[2] == '_'))     destructor = 1;
endif|#
directive|endif
comment|/* We may need to truncate the symbol, save the hash for later.  */
name|result
operator|=
operator|(
name|strlen
argument_list|(
name|In
argument_list|)
operator|>
literal|23
operator|)
condition|?
name|hash_string
argument_list|(
name|In
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Is there a Psect Attribute to skip?  */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|In
argument_list|)
condition|)
block|{
comment|/* Yes: Skip it.  */
name|In
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
while|while
condition|(
operator|*
name|In
condition|)
block|{
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|In
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|In
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|In
operator|++
expr_stmt|;
block|}
block|}
name|old_name
operator|=
name|In
expr_stmt|;
if|#
directive|if
literal|0
block|if (strlen (In)> 31&& flag_hash_long_names)     as_tsktsk ("Symbol name truncated: %s\n", In);
endif|#
directive|endif
comment|/* Do the case conversion.  */
comment|/* Maximum of 23 chars */
name|i
operator|=
literal|23
expr_stmt|;
while|while
condition|(
operator|*
name|In
operator|&&
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
condition|)
block|{
name|Case_Hack_Bits
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|In
operator|==
literal|'$'
condition|)
name|Saw_Dollar
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|destructor
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i
operator|==
literal|21
operator|)
condition|)
name|Saw_Dollar
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|vms_name_mapping
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|In
argument_list|)
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
name|Case_Hack_Bits
operator||=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|Out
operator|++
operator|=
name|TOUPPER
argument_list|(
operator|*
name|In
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ISLOWER
argument_list|(
operator|*
name|In
argument_list|)
condition|)
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
else|else
operator|*
name|Out
operator|++
operator|=
name|TOLOWER
argument_list|(
operator|*
name|In
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we saw a dollar sign, we don't do case hacking.  */
if|if
condition|(
name|flag_no_hash_mixed_case
operator|||
name|Saw_Dollar
condition|)
name|Case_Hack_Bits
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than 23 characters and everything is lowercase      we can insert the full 31 characters.  */
if|if
condition|(
operator|*
name|In
condition|)
block|{
comment|/* We have more than 23 characters          If we must add the case hack, then we have truncated the str.  */
name|pnt
operator|=
name|Out
expr_stmt|;
name|truncate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Case_Hack_Bits
operator|==
literal|0
condition|)
block|{
comment|/* And so far they are all lower case: 	     Check up to 8 more characters 	     and ensure that they are lowercase.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|In
index|[
name|i
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
literal|8
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|In
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|Saw_Dollar
operator|&&
operator|!
name|flag_no_hash_mixed_case
condition|)
break|break;
if|if
condition|(
name|In
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|8
operator|)
operator|||
operator|(
name|In
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* They are:  Copy up to 31 characters 	         to the output string.  */
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|In
operator|)
condition|)
switch|switch
condition|(
name|vms_name_mapping
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|Out
operator|++
operator|=
name|TOUPPER
argument_list|(
operator|*
name|In
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|Out
operator|++
operator|=
name|TOLOWER
argument_list|(
operator|*
name|In
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* If there were any uppercase characters in the name we      take on the case hacking string.  */
comment|/* Old behavior for regular GNU-C compiler.  */
if|if
condition|(
operator|!
name|flag_hash_long_names
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Case_Hack_Bits
operator|!=
literal|0
operator|)
operator|||
operator|(
name|truncate
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|truncate
operator|==
literal|0
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|Out
operator|++
operator|=
name|Hex_Table
index|[
name|Case_Hack_Bits
operator|&
literal|0xf
index|]
expr_stmt|;
name|Case_Hack_Bits
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|Out
operator|++
operator|=
literal|'X'
expr_stmt|;
block|}
else|else
block|{
name|Out
operator|=
name|pnt
expr_stmt|;
comment|/* Cut back to 23 characters maximum.  */
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|init
operator|=
name|result
operator|&
literal|0x01f
expr_stmt|;
operator|*
name|Out
operator|++
operator|=
operator|(
name|init
operator|<
literal|10
operator|)
condition|?
operator|(
literal|'0'
operator|+
name|init
operator|)
else|:
operator|(
literal|'A'
operator|+
name|init
operator|-
literal|10
operator|)
expr_stmt|;
name|result
operator|=
name|result
operator|>>
literal|5
expr_stmt|;
block|}
block|}
block|}
comment|/* Done.  */
operator|*
name|Out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|truncate
operator|==
literal|1
operator|&&
name|flag_hash_long_names
operator|&&
name|flag_show_after_trunc
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Symbol %s replaced by %s\n"
argument_list|)
argument_list|,
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a symbol name for a psect attribute specification.  */
end_comment

begin_define
define|#
directive|define
name|GLOBALSYMBOL_BIT
value|0x10000
end_define

begin_define
define|#
directive|define
name|GLOBALVALUE_BIT
value|0x20000
end_define

begin_function
specifier|static
name|void
name|VMS_Modify_Psect_Attributes
parameter_list|(
specifier|const
name|char
modifier|*
name|Name
parameter_list|,
name|int
modifier|*
name|Attribute_Pointer
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|Negate
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Value
decl_stmt|;
block|}
name|Attributes
index|[]
init|=
block|{
block|{
literal|"PIC"
block|,
name|GPS_S_M_PIC
block|}
block|,
block|{
literal|"LIB"
block|,
name|GPS_S_M_LIB
block|}
block|,
block|{
literal|"OVR"
block|,
name|GPS_S_M_OVR
block|}
block|,
block|{
literal|"REL"
block|,
name|GPS_S_M_REL
block|}
block|,
block|{
literal|"GBL"
block|,
name|GPS_S_M_GBL
block|}
block|,
block|{
literal|"SHR"
block|,
name|GPS_S_M_SHR
block|}
block|,
block|{
literal|"EXE"
block|,
name|GPS_S_M_EXE
block|}
block|,
block|{
literal|"RD"
block|,
name|GPS_S_M_RD
block|}
block|,
block|{
literal|"WRT"
block|,
name|GPS_S_M_WRT
block|}
block|,
block|{
literal|"VEC"
block|,
name|GPS_S_M_VEC
block|}
block|,
block|{
literal|"GLOBALSYMBOL"
block|,
name|GLOBALSYMBOL_BIT
block|}
block|,
block|{
literal|"GLOBALVALUE"
block|,
name|GLOBALVALUE_BIT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
comment|/* Kill leading "_".  */
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/* Check for a PSECT attribute list.  */
if|if
condition|(
operator|!
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
return|return;
comment|/* Skip the attribute list indicator.  */
name|Name
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
comment|/* Process the attributes ("_" separated, "$" terminated).  */
while|while
condition|(
operator|*
name|Name
operator|!=
literal|'$'
condition|)
block|{
comment|/* Assume not negating.  */
name|Negate
operator|=
literal|0
expr_stmt|;
comment|/* Check for "NO".  */
if|if
condition|(
operator|(
name|Name
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
condition|)
block|{
comment|/* We are negating (and skip the NO).  */
name|Negate
operator|=
literal|1
expr_stmt|;
name|Name
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Find the token delimiter.  */
name|cp
operator|=
name|Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'_'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'$'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Look for the token in the attribute list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
condition|;
name|i
operator|++
control|)
block|{
comment|/* If the strings match, set/clear the attr.  */
if|if
condition|(
name|strncmp
argument_list|(
name|Name
argument_list|,
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
argument_list|,
name|cp
operator|-
name|Name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Set or clear.  */
if|if
condition|(
name|Negate
condition|)
operator|*
name|Attribute_Pointer
operator|&=
operator|~
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
else|else
operator|*
name|Attribute_Pointer
operator||=
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
comment|/* Done.  */
break|break;
block|}
block|}
comment|/* Now skip the attribute.  */
name|Name
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|GBLSYM_REF
value|0
end_define

begin_define
define|#
directive|define
name|GBLSYM_DEF
value|1
end_define

begin_define
define|#
directive|define
name|GBLSYM_VAL
value|2
end_define

begin_define
define|#
directive|define
name|GBLSYM_LCL
value|4
end_define

begin_comment
comment|/* not GBL after all...  */
end_comment

begin_define
define|#
directive|define
name|GBLSYM_WEAK
value|8
end_define

begin_comment
comment|/* Define a global symbol (or possibly a local one).  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Global_Symbol_Spec
parameter_list|(
specifier|const
name|char
modifier|*
name|Name
parameter_list|,
name|int
name|Psect_Number
parameter_list|,
name|int
name|Psect_Offset
parameter_list|,
name|int
name|Flags
parameter_list|)
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/* We are writing a GSD record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the GSD record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* We are writing a Global (or local) symbol definition subrecord.  */
name|PUT_CHAR
argument_list|(
operator|(
name|Flags
operator|&
name|GBLSYM_LCL
operator|)
operator|!=
literal|0
condition|?
name|GSD_S_C_LSY
else|:
operator|(
operator|(
name|unsigned
operator|)
name|Psect_Number
operator|<=
literal|255
operator|)
condition|?
name|GSD_S_C_SYM
else|:
name|GSD_S_C_SYMW
argument_list|)
expr_stmt|;
comment|/* Data type is undefined.  */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Switch on Definition/Reference.  */
if|if
condition|(
operator|(
name|Flags
operator|&
name|GBLSYM_DEF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Reference.  */
name|PUT_SHORT
argument_list|(
operator|(
operator|(
name|Flags
operator|&
name|GBLSYM_VAL
operator|)
operator|==
literal|0
operator|)
condition|?
name|GSY_S_M_REL
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|GBLSYM_LCL
operator|)
operator|!=
literal|0
condition|)
comment|/* local symbols have extra field */
name|PUT_SHORT
argument_list|(
name|Current_Environment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|sym_flags
decl_stmt|;
comment|/* Definition          [ assert (LSY_S_M_DEF == GSY_S_M_DEF&& LSY_S_M_REL == GSY_S_M_REL); ].  */
name|sym_flags
operator|=
name|GSY_S_M_DEF
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|GBLSYM_WEAK
condition|)
name|sym_flags
operator||=
name|GSY_S_M_WEAK
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|GBLSYM_VAL
operator|)
operator|==
literal|0
condition|)
name|sym_flags
operator||=
name|GSY_S_M_REL
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|sym_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|GBLSYM_LCL
operator|)
operator|!=
literal|0
condition|)
comment|/* local symbols have extra field */
name|PUT_SHORT
argument_list|(
name|Current_Environment
argument_list|)
expr_stmt|;
comment|/* Psect Number.  */
if|if
condition|(
operator|(
name|Flags
operator|&
name|GBLSYM_LCL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|Psect_Number
operator|<=
literal|255
condition|)
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
else|else
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
comment|/* Offset.  */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, the global symbol name.  */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an environment to support local symbol references.    This is just to mollify the linker; we don't actually do    anything useful with it.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Local_Environment_Setup
parameter_list|(
specifier|const
name|char
modifier|*
name|Env_Name
parameter_list|)
block|{
comment|/* We are writing a GSD record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the GSD record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* We are writing an ENV subrecord.  */
name|PUT_CHAR
argument_list|(
name|GSD_S_C_ENV
argument_list|)
expr_stmt|;
operator|++
name|Current_Environment
expr_stmt|;
comment|/* index of environment being defined */
comment|/* ENV$W_FLAGS:  we are defining the next environment.  It's not nested.  */
name|PUT_SHORT
argument_list|(
name|ENV_S_M_DEF
argument_list|)
expr_stmt|;
comment|/* ENV$W_ENVINDX:  index is always 0 for non-nested definitions.  */
name|PUT_SHORT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* ENV$B_NAMLNG + ENV$T_NAME:  environment name in ASCIC format.  */
if|if
condition|(
operator|!
name|Env_Name
condition|)
name|Env_Name
operator|=
literal|""
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Env_Name
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define a psect.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_Psect_Spec
parameter_list|(
specifier|const
name|char
modifier|*
name|Name
parameter_list|,
name|int
name|Size
parameter_list|,
name|enum
name|ps_type
name|Type
parameter_list|,
name|struct
name|VMS_Symbol
modifier|*
name|vsp
parameter_list|)
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
name|int
name|Psect_Attributes
decl_stmt|;
comment|/* Generate the appropriate PSECT flags given the PSECT type.  */
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ps_TEXT
case|:
comment|/* Text psects are PIC,noOVR,REL,noGBL,SHR,EXE,RD,noWRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_EXE
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
break|break;
case|case
name|ps_DATA
case|:
comment|/* Data psects are PIC,noOVR,REL,noGBL,noSHR,noEXE,RD,WRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
expr_stmt|;
break|break;
case|case
name|ps_COMMON
case|:
comment|/* Common block psects are:  PIC,OVR,REL,GBL,noSHR,noEXE,RD,WRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
expr_stmt|;
break|break;
case|case
name|ps_CONST
case|:
comment|/* Const data psects are:  PIC,OVR,REL,GBL,noSHR,noEXE,RD,noWRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
break|break;
case|case
name|ps_CTORS
case|:
comment|/* Ctor psects are PIC,noOVR,REL,GBL,noSHR,noEXE,RD,noWRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
break|break;
case|case
name|ps_DTORS
case|:
comment|/* Dtor psects are PIC,noOVR,REL,GBL,noSHR,noEXE,RD,noWRT.  */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* impossible */
name|error
argument_list|(
name|_
argument_list|(
literal|"Unknown VMS psect type (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|Type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Modify the psect attributes according to any attribute string.  */
if|if
condition|(
name|vsp
operator|&&
name|S_GET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|N_ABS
condition|)
name|Psect_Attributes
operator||=
name|GLOBALVALUE_BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
name|VMS_Modify_Psect_Attributes
argument_list|(
name|Name
argument_list|,
operator|&
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/* Check for globalref/def/val.  */
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALVALUE_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* globalvalue symbols were generated before. This code          prevents unsightly psect buildup, and makes sure that          fixup references are emitted correctly.  */
name|vsp
operator|->
name|Psect_Index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* to catch errors */
name|S_SET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|,
name|N_UNDF
argument_list|)
expr_stmt|;
comment|/* make refs work */
return|return
literal|1
return|;
comment|/* decrement psect counter */
block|}
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALSYMBOL_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
condition|)
block|{
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|GBLSYM_REF
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
operator|-
literal|1
expr_stmt|;
name|S_SET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|,
name|N_UNDF
argument_list|)
expr_stmt|;
comment|/* Return and indicate no psect.  */
return|return
literal|1
return|;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|GBLSYM_DEF
argument_list|)
expr_stmt|;
comment|/* In this case we still generate the psect. */
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Globalsymbol attribute for symbol %s was unexpected."
argument_list|)
argument_list|,
name|Name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clear out the globalref/def stuff.  */
name|Psect_Attributes
operator|&=
literal|0xffff
expr_stmt|;
comment|/* We are writing a GSD record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the GSD record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* We are writing a PSECT definition subrecord.  */
name|PUT_CHAR
argument_list|(
name|GSD_S_C_PSC
argument_list|)
expr_stmt|;
comment|/* Psects are always LONGWORD aligned.  */
name|PUT_CHAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Specify the psect attributes.  */
name|PUT_SHORT
argument_list|(
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/* Specify the allocation.  */
name|PUT_LONG
argument_list|(
name|Size
argument_list|)
expr_stmt|;
comment|/* Finally, the psect name.  */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the pointer to a symbol we calculate how big the data at the    symbol is.  We do this by looking for the next symbol (local or global)    which will indicate the start of another datum.  */
end_comment

begin_function
specifier|static
name|offsetT
name|VMS_Initialized_Data_Size
parameter_list|(
name|symbolS
modifier|*
name|s0P
parameter_list|,
name|unsigned
name|End_Of_Data
parameter_list|)
block|{
name|symbolS
modifier|*
name|s1P
decl_stmt|;
name|valueT
name|s0P_val
init|=
name|S_GET_VALUE
argument_list|(
name|s0P
argument_list|)
decl_stmt|,
name|s1P_val
decl_stmt|,
name|nearest_val
init|=
operator|(
name|valueT
operator|)
name|End_Of_Data
decl_stmt|;
comment|/* Find the nearest symbol what follows this one.  */
for|for
control|(
name|s1P
operator|=
name|symbol_rootP
init|;
name|s1P
condition|;
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s1P
argument_list|)
control|)
block|{
comment|/* The data type must match.  */
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|s1P
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
name|s1P_val
operator|=
name|S_GET_VALUE
argument_list|(
name|s1P
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1P_val
operator|>
name|s0P_val
operator|&&
name|s1P_val
operator|<
name|nearest_val
condition|)
name|nearest_val
operator|=
name|s1P_val
expr_stmt|;
block|}
comment|/* Calculate its size.  */
return|return
call|(
name|offsetT
call|)
argument_list|(
name|nearest_val
operator|-
name|s0P_val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check symbol names for the Psect hack with a globalvalue, and then    generate globalvalues for those that have it.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Emit_Globalvalues
parameter_list|(
name|unsigned
name|text_siz
parameter_list|,
name|unsigned
name|data_siz
parameter_list|,
name|char
modifier|*
name|Data_Segment
parameter_list|)
block|{
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|stripped_name
decl_stmt|,
modifier|*
name|Name
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Attributes
decl_stmt|;
name|int
name|globalvalue
decl_stmt|;
name|int
name|typ
decl_stmt|,
name|abstyp
decl_stmt|;
comment|/* Scan the symbol table for globalvalues, and emit def/ref when      required.  These will be caught again later and converted to      N_UNDF.  */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|sy_next
control|)
block|{
name|typ
operator|=
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|abstyp
operator|=
operator|(
operator|(
name|typ
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_ABS
operator|)
expr_stmt|;
comment|/* See if this is something we want to look at.  */
if|if
condition|(
operator|!
name|abstyp
operator|&&
name|typ
operator|!=
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
operator|&&
name|typ
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
continue|continue;
comment|/* See if this has globalvalue specification.  */
name|Name
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|abstyp
condition|)
block|{
name|stripped_name
operator|=
literal|0
expr_stmt|;
name|Psect_Attributes
operator|=
name|GLOBALVALUE_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
block|{
name|stripped_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|Name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stripped_name
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|Psect_Attributes
operator|=
literal|0
expr_stmt|;
name|VMS_Modify_Psect_Attributes
argument_list|(
name|stripped_name
argument_list|,
operator|&
name|Psect_Attributes
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALVALUE_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|N_ABS
case|:
comment|/* Local symbol references will want 		 to have an environment defined.  */
if|if
condition|(
name|Current_Environment
operator|<
literal|0
condition|)
name|VMS_Local_Environment_Setup
argument_list|(
literal|".N_ABS"
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
literal|0
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_VAL
operator||
name|GBLSYM_LCL
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
literal|0
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_VAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GBLSYM_VAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|>
literal|4
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid data type for globalvalue"
argument_list|)
argument_list|)
expr_stmt|;
name|globalvalue
operator|=
name|md_chars_to_number
argument_list|(
name|Data_Segment
operator|+
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|-
name|text_siz
argument_list|,
name|Size
argument_list|)
expr_stmt|;
comment|/* Three times for good luck.  The linker seems to get confused 	         if there are fewer than three */
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GBLSYM_VAL
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
name|globalvalue
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_VAL
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
name|globalvalue
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_VAL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid globalvalue of %s"
argument_list|)
argument_list|,
name|stripped_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stripped_name
condition|)
name|free
argument_list|(
name|stripped_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define a procedure entry pt/mask.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Procedure_Entry_Pt
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|,
name|int
name|Psect_Number
parameter_list|,
name|int
name|Psect_Offset
parameter_list|,
name|int
name|Entry_Mask
parameter_list|)
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/* We are writing a GSD record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the GSD record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/* We are writing a Procedure Entry Pt/Mask subrecord.  */
name|PUT_CHAR
argument_list|(
operator|(
operator|(
name|unsigned
operator|)
name|Psect_Number
operator|<=
literal|255
operator|)
condition|?
name|GSD_S_C_EPM
else|:
name|GSD_S_C_EPMW
argument_list|)
expr_stmt|;
comment|/* Data type is undefined.  */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Flags = "RELOCATABLE" and "DEFINED".  */
name|PUT_SHORT
argument_list|(
name|GSY_S_M_DEF
operator||
name|GSY_S_M_REL
argument_list|)
expr_stmt|;
comment|/* Psect Number.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|Psect_Number
operator|<=
literal|255
condition|)
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
else|else
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
comment|/* Offset.  */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
comment|/* Entry mask.  */
name|PUT_SHORT
argument_list|(
name|Entry_Mask
argument_list|)
expr_stmt|;
comment|/* Finally, the global symbol name.  */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the current location counter to a particular Psect and Offset.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Set_Psect
parameter_list|(
name|int
name|Psect_Index
parameter_list|,
name|int
name|Offset
parameter_list|,
name|int
name|Record_Type
parameter_list|)
block|{
comment|/* We are writing a "Record_Type" record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert the record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Stack the Psect base + Offset.  */
name|vms_tir_stack_psect
argument_list|(
name|Psect_Index
argument_list|,
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set relocation base.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_SETRB
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store repeated immediate data in current Psect.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Store_Repeated_Data
parameter_list|(
name|int
name|Repeat_Count
parameter_list|,
name|char
modifier|*
name|Pointer
parameter_list|,
name|int
name|Size
parameter_list|,
name|int
name|Record_Type
parameter_list|)
block|{
comment|/* Ignore zero bytes/words/longwords.  */
switch|switch
condition|(
name|Size
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|Pointer
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|Pointer
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
break|break;
comment|/* else FALLTHRU */
case|case
literal|2
case|:
if|if
condition|(
name|Pointer
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
comment|/* else FALLTHRU */
case|case
literal|1
case|:
if|if
condition|(
name|Pointer
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
comment|/* zero value */
return|return;
default|default:
break|break;
block|}
comment|/* If the data is too big for a TIR_S_C_STO_RIVB sub-record      then we do it manually.  */
if|if
condition|(
name|Size
operator|>
literal|255
condition|)
block|{
while|while
condition|(
operator|--
name|Repeat_Count
operator|>=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Pointer
argument_list|,
name|Size
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are writing a "Record_Type" record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Stack the repeat count.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Repeat_Count
argument_list|)
expr_stmt|;
comment|/* And now the command and its data.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_RIVB
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Size
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|Size
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a Position Independent Reference.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Store_PIC_Symbol_Reference
parameter_list|(
name|symbolS
modifier|*
name|Symbol
parameter_list|,
name|int
name|Offset
parameter_list|,
name|int
name|PC_Relative
parameter_list|,
name|int
name|Psect
parameter_list|,
name|int
name|Psect_Offset
parameter_list|,
name|int
name|Record_Type
parameter_list|)
block|{
name|struct
name|VMS_Symbol
modifier|*
name|vsp
init|=
name|Symbol
operator|->
name|sy_obj
decl_stmt|;
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
name|int
name|local_sym
init|=
literal|0
decl_stmt|;
comment|/* We are writing a "Record_Type" record.  */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* If the buffer is empty we must insert record type.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Set to the appropriate offset in the Psect.      For a Code reference we need to fix the operand      specifier as well, so back up 1 byte;      for a Data reference we just store HERE.  */
name|VMS_Set_Psect
argument_list|(
name|Psect
argument_list|,
name|PC_Relative
condition|?
name|Psect_Offset
operator|-
literal|1
else|:
name|Psect_Offset
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Make sure we are still generating a "Record Type" record.  */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* Dispatch on symbol type (so we can stack its value).  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|Symbol
argument_list|)
condition|)
block|{
comment|/* Global symbol.  */
case|case
name|N_ABS
case|:
name|local_sym
operator|=
literal|1
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|N_ABS
operator||
name|N_EXT
case|:
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
case|case
name|N_UNDF
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
comment|/* Get the symbol name (case hacked).  */
name|VMS_Case_Hack_Symbol
argument_list|(
name|S_GET_NAME
argument_list|(
name|Symbol
argument_list|)
argument_list|,
name|Local
argument_list|)
expr_stmt|;
comment|/* Stack the global symbol value.  */
if|if
condition|(
operator|!
name|local_sym
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_GBL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Local symbols have an extra field.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_LSY
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Current_Environment
argument_list|)
expr_stmt|;
block|}
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offset
condition|)
block|{
comment|/* Stack the longword offset.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* Add the two, leaving the result on the stack.  */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_OPR_ADD
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Uninitialized local data.  */
case|case
name|N_BSS
case|:
comment|/* Stack the Psect (+offset).  */
name|vms_tir_stack_psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* Local text.  */
case|case
name|N_TEXT
case|:
comment|/* Stack the Psect (+offset).  */
name|vms_tir_stack_psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|S_GET_VALUE
argument_list|(
name|Symbol
argument_list|)
operator|+
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* Initialized local or global data.  */
case|case
name|N_DATA
case|:
ifndef|#
directive|ifndef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
comment|/* Stack the Psect (+offset).  */
name|vms_tir_stack_psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Store either a code or data reference.  */
name|PUT_CHAR
argument_list|(
name|PC_Relative
condition|?
name|TIR_S_C_STO_PICR
else|:
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check in the text area for an indirect pc-relative reference    and fix it up with addressing mode 0xff [PC indirect]     THIS SHOULD BE REPLACED BY THE USE OF TIR_S_C_STO_PIRR IN THE    PIC CODE GENERATING FIXUP ROUTINE.  */
end_comment

begin_function
specifier|static
name|void
name|VMS_Fix_Indirect_Reference
parameter_list|(
name|int
name|Text_Psect
parameter_list|,
name|addressT
name|Offset
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|fragS
modifier|*
name|text_frag_root
parameter_list|)
block|{
comment|/* The addressing mode byte is 1 byte before the address.  */
name|Offset
operator|--
expr_stmt|;
comment|/* Is it in THIS frag?  */
if|if
condition|(
operator|(
name|Offset
operator|<
name|fragP
operator|->
name|fr_address
operator|)
operator|||
operator|(
name|Offset
operator|>=
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
block|{
comment|/* We need to search for the fragment containing this          Offset.  */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|Offset
operator|>=
name|fragP
operator|->
name|fr_address
operator|)
operator|&&
operator|(
name|Offset
operator|<
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
break|break;
block|}
comment|/* If we couldn't find the frag, things are BAD!  */
if|if
condition|(
name|fragP
operator|==
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Couldn't find fixup fragment when checking for indirect reference"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for indirect PC relative addressing mode.  */
if|if
condition|(
name|fragP
operator|->
name|fr_literal
index|[
name|Offset
operator|-
name|fragP
operator|->
name|fr_address
index|]
operator|==
operator|(
name|char
operator|)
literal|0xff
condition|)
block|{
specifier|static
name|char
name|Address_Mode
init|=
operator|(
name|char
operator|)
literal|0xff
decl_stmt|;
comment|/* Yes: Store the indirect mode back into the image          to fix up the damage done by STO_PICR.  */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|Address_Mode
argument_list|,
literal|1
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If the procedure "main()" exists we have to add the instruction    "jsb c$main_args" at the beginning to be compatible with VAX-11 "C".     FIXME:  the macro name `HACK_DEC_C_STARTUP' should be renamed 	   to `HACK_VAXCRTL_STARTUP' because Digital's compiler  	   named "DEC C" uses run-time library "DECC$SHR", but this  	   startup code is for "VAXCRTL", the library for Digital's  	   older "VAX C".  Also, this extra code isn't needed for  	   supporting gcc because it already generates the VAXCRTL  	   startup call when compiling main().  The reference to  	   `flag_hash_long_names' looks very suspicious too;  	   probably an old-style command line option was inadvertently  	   overloaded here, then blindly converted into the new one.  */
end_comment

begin_function
name|void
name|vms_check_for_main
parameter_list|(
name|void
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
comment|/* JF */
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|fragS
modifier|*
modifier|*
name|prev_fragPP
decl_stmt|;
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
name|fragS
modifier|*
name|New_Frag
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* HACK_DEC_C_STARTUP */
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|symbol_find
argument_list|(
literal|"_main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
if|if
condition|(
operator|!
name|flag_hash_long_names
condition|)
block|{
endif|#
directive|endif
comment|/* Remember the entry point symbol.  */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
block|}
else|else
block|{
comment|/* Scan all the fragment chains for the one with "_main" 	     (Actually we know the fragment from the symbol, but we need 	     the previous fragment so we can change its pointer).  */
name|frchainP
operator|=
name|frchain_root
expr_stmt|;
while|while
condition|(
name|frchainP
condition|)
block|{
comment|/* Scan all the fragments in this chain, remembering 	         the "previous fragment".  */
name|prev_fragPP
operator|=
operator|&
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|fragP
operator|=
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragP
operator|&&
operator|(
name|fragP
operator|!=
name|frchainP
operator|->
name|frch_last
operator|)
condition|)
block|{
comment|/* Is this the fragment ?  */
if|if
condition|(
name|fragP
operator|==
name|symbolP
operator|->
name|sy_frag
condition|)
block|{
comment|/* Yes: Modify the fragment by replacing 		         it with a new fragment.  */
name|New_Frag
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|New_Frag
argument_list|)
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* The fragments are the same except 		        	that the "fixed" area is larger.  */
operator|*
name|New_Frag
operator|=
operator|*
name|fragP
expr_stmt|;
name|New_Frag
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* Copy the literal data opening a hole 		         2 bytes after "_main" (i.e. just after 		         the entry mask).  Into which we place 		         the JSB instruction.  */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|2
index|]
operator|=
literal|0x16
expr_stmt|;
comment|/* Jsb */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|3
index|]
operator|=
literal|0xef
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
condition|;
name|i
operator|++
control|)
name|New_Frag
operator|->
name|fr_literal
index|[
name|i
operator|+
literal|6
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
name|i
index|]
expr_stmt|;
comment|/* Now replace the old fragment with the 		         newly generated one.  */
operator|*
name|prev_fragPP
operator|=
name|New_Frag
expr_stmt|;
comment|/* Remember the entry point symbol.  */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* Scan the text area fixup structures 		         as offsets in the fragment may have changed.  */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* Look for references to this fragment.  */
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|==
name|fragP
condition|)
block|{
comment|/* Change the fragment pointer.  */
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* If the offset is after	the entry mask we need 			         to account for the JSB	instruction we just 			         inserted.  */
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|>=
literal|2
condition|)
name|fixP
operator|->
name|fx_where
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* Scan the symbols as offsets in the 		        fragment may have changed.  */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Look for references to this fragment.  */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|==
name|fragP
condition|)
block|{
comment|/* Change the fragment pointer.  */
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* If the offset is after	the entry mask we need 			         to account for the JSB	instruction we just 			         inserted.  */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|>=
literal|2
condition|)
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Make a symbol reference to "_c$main_args" so we 			  can get its address inserted into the	JSB 			  instruction.  */
name|symbolP
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
literal|"_C$MAIN_ARGS"
argument_list|)
expr_stmt|;
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_UNDF
argument_list|)
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_number
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_obj
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
name|symbolP
operator|->
name|sy_resolved
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_resolving
operator|=
literal|0
expr_stmt|;
comment|/* This actually inserts at the beginning of the list.  */
name|symbol_append
argument_list|(
name|symbol_rootP
argument_list|,
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
comment|/* Generate a text fixup structure 		         to get "_c$main_args" stored into the 		         JSB instruction.  */
name|fixP
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fixP
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|symbolP
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_next
operator|=
name|text_fix_root
expr_stmt|;
name|text_fix_root
operator|=
name|fixP
expr_stmt|;
comment|/* Now make sure we exit from the loop.  */
name|frchainP
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Try the next fragment.  */
name|prev_fragPP
operator|=
operator|&
name|fragP
operator|->
name|fr_next
expr_stmt|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
comment|/* Try the next fragment chain.  */
if|if
condition|(
name|frchainP
condition|)
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HACK_DEC_C_STARTUP */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Beginning of vms_write_object_file().  */
end_comment

begin_struct
specifier|static
struct|struct
name|vms_obj_state
block|{
comment|/* Next program section index to use.  */
name|int
name|psect_number
decl_stmt|;
comment|/* Psect index for code.  Always ends up #0.  */
name|int
name|text_psect
decl_stmt|;
comment|/* Psect index for initialized static variables.  */
name|int
name|data_psect
decl_stmt|;
comment|/* Psect index for uninitialized static variables.  */
name|int
name|bss_psect
decl_stmt|;
comment|/* Psect index for static constructors.  */
name|int
name|ctors_psect
decl_stmt|;
comment|/* Psect index for static destructors.  */
name|int
name|dtors_psect
decl_stmt|;
comment|/* Number of bytes used for local symbol data.  */
name|int
name|local_initd_data_size
decl_stmt|;
comment|/* Dynamic buffer for initialized data.  */
name|char
modifier|*
name|data_segment
decl_stmt|;
block|}
name|vms_obj_state
struct|;
end_struct

begin_define
define|#
directive|define
name|Psect_Number
value|vms_obj_state.psect_number
end_define

begin_define
define|#
directive|define
name|Text_Psect
value|vms_obj_state.text_psect
end_define

begin_define
define|#
directive|define
name|Data_Psect
value|vms_obj_state.data_psect
end_define

begin_define
define|#
directive|define
name|Bss_Psect
value|vms_obj_state.bss_psect
end_define

begin_define
define|#
directive|define
name|Ctors_Psect
value|vms_obj_state.ctors_psect
end_define

begin_define
define|#
directive|define
name|Dtors_Psect
value|vms_obj_state.dtors_psect
end_define

begin_define
define|#
directive|define
name|Local_Initd_Data_Size
value|vms_obj_state.local_initd_data_size
end_define

begin_define
define|#
directive|define
name|Data_Segment
value|vms_obj_state.data_segment
end_define

begin_define
define|#
directive|define
name|IS_GXX_VTABLE
parameter_list|(
name|symP
parameter_list|)
value|(strncmp (S_GET_NAME (symP), "__vt.", 5) == 0)
end_define

begin_define
define|#
directive|define
name|IS_GXX_XTOR
parameter_list|(
name|symP
parameter_list|)
value|(strncmp (S_GET_NAME (symP), "__GLOBAL_.", 10) == 0)
end_define

begin_define
define|#
directive|define
name|XTOR_SIZE
value|4
end_define

begin_escape
end_escape

begin_comment
comment|/* Perform text segment fixups.  */
end_comment

begin_function
specifier|static
name|void
name|vms_fixup_text_section
parameter_list|(
name|unsigned
name|text_siz
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|frag
modifier|*
name|text_frag_root
parameter_list|,
name|struct
name|frag
modifier|*
name|data_frag_root
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
name|offsetT
name|dif
decl_stmt|;
comment|/* Scan the text fragments.  */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* Stop if we get to the data fragments.  */
if|if
condition|(
name|fragP
operator|==
name|data_frag_root
condition|)
break|break;
comment|/* Ignore fragments with no data.  */
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_var
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Go to the appropriate offset in the Text Psect.  */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fragP
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* Store the "fixed" part.  */
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|fragP
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* Store the "variable" part.  */
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|&&
name|fragP
operator|->
name|fr_offset
condition|)
name|VMS_Store_Repeated_Data
argument_list|(
name|fragP
operator|->
name|fr_offset
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/* Now we go through the text segment fixups and generate      TIR records to fix up addresses within the Text Psect.  */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* We DO handle the case of "Symbol - Symbol" as 	 long as it is in the same segment.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
comment|/* They need to be in the same segment.  */
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data addsy and subsy don't have the same type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And they need to be in one that we can check the psect on.  */
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data addsy and subsy don't have an appropriate type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This had better not be PC relative!  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data is erroneously \"pcrel\""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subtract their values to get the difference.  */
name|dif
operator|=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|Local
argument_list|,
operator|(
name|valueT
operator|)
name|dif
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
comment|/* Now generate the fixup object records; 	     set the psect and store the data.  */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Size will HAVE to be "long".  */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
literal|4
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup datum is not a longword"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Symbol must be "added" (if it is ever 	 subtracted we can fix this assumption).  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup datum is not \"fixP->fx_addsy\""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the symbol value in a PIC fashion.  */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* Check for indirect address reference, which has to be fixed up 	     (as the linker will screw it up with TIR_S_C_STO_PICR).  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|VMS_Fix_Indirect_Reference
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|fixP
operator|->
name|fx_frag
argument_list|,
name|text_frag_root
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a buffer holding the data segment.  */
end_comment

begin_function
specifier|static
name|void
name|synthesize_data_segment
parameter_list|(
name|unsigned
name|data_siz
parameter_list|,
name|unsigned
name|text_siz
parameter_list|,
name|struct
name|frag
modifier|*
name|data_frag_root
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|char
modifier|*
name|fill_literal
decl_stmt|;
name|long
name|fill_size
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* Allocate the data segment.  */
name|Data_Segment
operator|=
name|xmalloc
argument_list|(
name|data_siz
argument_list|)
expr_stmt|;
comment|/* Run through the data fragments, filling in the segment.  */
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|i
operator|=
name|fragP
operator|->
name|fr_address
operator|-
name|text_siz
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|memcpy
argument_list|(
name|Data_Segment
operator|+
name|i
argument_list|,
name|fragP
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
operator|(
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
operator|)
operator|!=
literal|0
condition|)
block|{
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
name|memcpy
argument_list|(
name|Data_Segment
operator|+
name|i
argument_list|,
name|fill_literal
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform data segment fixups.  */
end_comment

begin_function
specifier|static
name|void
name|vms_fixup_data_section
parameter_list|(
name|unsigned
name|int
name|data_siz
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|text_siz
parameter_list|)
block|{
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|addressT
name|fr_address
decl_stmt|;
name|offsetT
name|dif
decl_stmt|;
name|valueT
name|val
decl_stmt|;
comment|/* Run through all the data symbols and store the data.  */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* Ignore anything other than data symbols.  */
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* Set the Psect + Offset.  */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* Store the data.  */
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Data_Segment
operator|+
name|val
operator|-
name|text_siz
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/* N_DATA symbol loop */
comment|/* Now we go through the data segment fixups and generate      TIR records to fix up addresses within the Data Psects.  */
for|for
control|(
name|fixP
operator|=
name|data_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* Find the symbol for the containing datum.  */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* Only bother with Data symbols.  */
name|sp
operator|=
name|vsp
operator|->
name|Symbol
expr_stmt|;
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* Ignore symbol if After fixup.  */
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fr_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|fixP
operator|->
name|fx_where
operator|+
name|fr_address
condition|)
continue|continue;
comment|/* See if the datum is here.  */
if|if
condition|(
name|val
operator|+
name|vsp
operator|->
name|Size
operator|<=
name|fixP
operator|->
name|fx_where
operator|+
name|fr_address
condition|)
continue|continue;
comment|/* We DO handle the case of "Symbol - Symbol" as 	     long as it is in the same segment.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
comment|/* They need to be in the same segment.  */
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data addsy and subsy don't have the same type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And they need to be in one that we can check the psect on.  */
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data addsy and subsy don't have an appropriate type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This had better not be PC relative!  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup data is erroneously \"pcrel\""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subtract their values to get the difference.  */
name|dif
operator|=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|Local
argument_list|,
operator|(
name|valueT
operator|)
name|dif
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
comment|/* Now generate the fixup object records; 	         set the psect and store the data.  */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|val
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
break|break;
comment|/* done with this fixup */
block|}
comment|/* Size will HAVE to be "long".  */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
literal|4
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup datum is not a longword"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Symbol must be "added" (if it is ever 	     subtracted we can fix this assumption).  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Fixup datum is not \"fixP->fx_addsy\""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the symbol value in a PIC fashion.  */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|val
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* Done with this fixup.  */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform ctors/dtors segment fixups.  */
end_comment

begin_function
specifier|static
name|void
name|vms_fixup_xtors_section
parameter_list|(
name|struct
name|VMS_Symbol
modifier|*
name|symbols
parameter_list|,
name|int
name|sect_no
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
comment|/* Run through all the symbols and store the data.  */
for|for
control|(
name|vsp
operator|=
name|symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
name|symbolS
modifier|*
name|sp
decl_stmt|;
comment|/* Set relocation base.  */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|sp
operator|=
name|vsp
operator|->
name|Symbol
expr_stmt|;
comment|/* Stack the Psect base with its offset.  */
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|OBJ_S_C_TIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the buffer if it is more than 75% full.  */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define symbols for the linker.  */
end_comment

begin_function
specifier|static
name|void
name|global_symbol_directory
parameter_list|(
name|unsigned
name|text_siz
parameter_list|,
name|unsigned
name|data_siz
parameter_list|)
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|Globalref
decl_stmt|,
name|define_as_global_symbol
decl_stmt|;
if|#
directive|if
literal|0
comment|/* The g++ compiler does not write out external references to      vtables correctly.  Check for this and holler if we see it      happening.  If that compiler bug is ever fixed we can remove      this.       (Jun'95: gcc 2.7.0's cc1plus still exhibits this behavior.)       This was reportedly fixed as of June 2, 1998.   */
block|for (sp = symbol_rootP; sp; sp = symbol_next (sp))     if (S_GET_RAW_TYPE (sp) == N_UNDF&& IS_GXX_VTABLE (sp))       { 	S_SET_TYPE (sp, N_UNDF | N_EXT); 	S_SET_OTHER (sp, 1); 	as_warn (_("g++ wrote an extern reference to `%s' as a routine.\nI will fix it, but I hope that it was note really a routine."), 		 S_GET_NAME (sp));       }
endif|#
directive|endif
comment|/* Now scan the symbols and emit the appropriate GSD records.  */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
control|)
block|{
name|define_as_global_symbol
operator|=
literal|0
expr_stmt|;
name|vsp
operator|=
literal|0
expr_stmt|;
comment|/* Dispatch on symbol type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* Global uninitialized data.  */
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
comment|/* Make a VMS data symbol entry.  */
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
comment|/* Make the psect for this data.  */
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
name|S_GET_OTHER
argument_list|(
name|sp
argument_list|)
condition|?
name|ps_CONST
else|:
name|ps_COMMON
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globalref
condition|)
name|Psect_Number
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
name|define_as_global_symbol
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* See if this is an external vtable.  We want to help the 	     linker find these things in libraries, so we make a symbol 	     reference.  This is not compatible with VAX-C usage for 	     variables, but since vtables are only used internally by 	     g++, we can get away with this hack.  */
name|define_as_global_symbol
operator|=
name|IS_GXX_VTABLE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Local uninitialized data.  */
case|case
name|N_BSS
case|:
comment|/* Make a VMS data symbol entry.  */
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Bss_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|-
name|bss_address_frag
operator|.
name|fr_address
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
break|break;
comment|/* Global initialized data.  */
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* Make a VMS data symbol entry.  */
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
comment|/* Make its psect.  */
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
name|S_GET_OTHER
argument_list|(
name|sp
argument_list|)
condition|?
name|ps_CONST
else|:
name|ps_COMMON
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globalref
condition|)
name|Psect_Number
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
name|define_as_global_symbol
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* See N_UNDF|N_EXT above for explanation.  */
name|define_as_global_symbol
operator|=
name|IS_GXX_VTABLE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Local initialized data.  */
case|case
name|N_DATA
case|:
block|{
name|char
modifier|*
name|sym_name
init|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
decl_stmt|;
comment|/* Always suppress local numeric labels.  */
if|if
condition|(
name|sym_name
operator|&&
name|strcmp
argument_list|(
name|sym_name
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Make a VMS data symbol entry.  */
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|Local_Initd_Data_Size
expr_stmt|;
name|Local_Initd_Data_Size
operator|+=
name|vsp
operator|->
name|Size
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
block|}
break|break;
comment|/* Global Text definition.  */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
block|{
if|if
condition|(
name|IS_GXX_XTOR
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|XTOR_SIZE
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
switch|switch
condition|(
operator|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
operator|)
index|[
literal|10
index|]
condition|)
block|{
case|case
literal|'I'
case|:
name|vsp
operator|->
name|Psect_Index
operator|=
name|Ctors_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
operator|(
name|Ctors_Symbols
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|Ctors_Symbols
operator|->
name|Psect_Offset
operator|+
name|XTOR_SIZE
operator|)
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|Ctors_Symbols
expr_stmt|;
name|Ctors_Symbols
operator|=
name|vsp
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|vsp
operator|->
name|Psect_Index
operator|=
name|Dtors_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
operator|(
name|Dtors_Symbols
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|Dtors_Symbols
operator|->
name|Psect_Offset
operator|+
name|XTOR_SIZE
operator|)
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|Dtors_Symbols
expr_stmt|;
name|Dtors_Symbols
operator|=
name|vsp
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't handle global xtors symbols yet."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unknown %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|unsigned
name|short
name|Entry_Mask
decl_stmt|;
comment|/* Get the entry mask.  */
name|fragP
operator|=
name|sp
operator|->
name|sy_frag
expr_stmt|;
comment|/* First frag might be empty if we're generating listings. 		   So skip empty rs_fill frags.  */
while|while
condition|(
name|fragP
operator|&&
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
comment|/* If first frag doesn't contain the data, what do we do? 		   If it's possibly smaller than two bytes, that would 		   imply that the entry mask is not stored where we're 		   expecting it.  		   If you can find a test case that triggers this, report 		   it (and tell me what the entry mask field ought to be), 		   and I'll try to fix it.  KR */
if|if
condition|(
name|fragP
operator|->
name|fr_fix
operator|<
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|Entry_Mask
operator|=
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|&
literal|0x00ff
operator|)
operator||
operator|(
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Define the procedure entry point.  */
name|VMS_Procedure_Entry_Pt
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|Entry_Mask
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Local Text definition.  */
case|case
name|N_TEXT
case|:
comment|/* Make a VMS data symbol entry.  */
if|if
condition|(
name|Text_Psect
operator|!=
operator|-
literal|1
condition|)
block|{
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Text_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
block|}
break|break;
comment|/* Global Reference.  */
case|case
name|N_UNDF
case|:
comment|/* Make a GSD global symbol reference record.  */
name|VMS_Global_Symbol_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|GBLSYM_REF
argument_list|)
expr_stmt|;
break|break;
comment|/* Absolute symbol.  */
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
comment|/* gcc doesn't generate these; 	     VMS_Emit_Globalvalue handles them though.	*/
name|vsp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|vsp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|4
expr_stmt|;
comment|/* always assume 32 bits */
name|vsp
operator|->
name|Psect_Index
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_obj
operator|=
name|vsp
expr_stmt|;
break|break;
comment|/* Anything else.  */
default|default:
comment|/* Ignore STAB symbols, including .stabs emitted by g++.  */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp
argument_list|)
operator|||
operator|(
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
operator|==
literal|22
operator|)
condition|)
break|break;
comment|/* 	   *	Error otherwise. 	   */
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"unhandled stab type %d"
argument_list|)
argument_list|,
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Global symbols have different linkage than external variables.  */
if|if
condition|(
name|define_as_global_symbol
condition|)
name|VMS_Global_Symbol_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
literal|0
argument_list|,
name|GBLSYM_DEF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugger symbol table information for symbols which    are local to a specific routine.  */
end_comment

begin_function
specifier|static
name|void
name|local_symbols_DST
parameter_list|(
name|symbolS
modifier|*
name|s0P
parameter_list|,
name|symbolS
modifier|*
name|Current_Routine
parameter_list|)
block|{
name|symbolS
modifier|*
name|s1P
decl_stmt|;
name|char
modifier|*
name|s0P_name
decl_stmt|,
modifier|*
name|pnt0
decl_stmt|,
modifier|*
name|pnt1
decl_stmt|;
name|s0P_name
operator|=
name|S_GET_NAME
argument_list|(
name|s0P
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s0P_name
operator|++
operator|!=
literal|'_'
condition|)
return|return;
for|for
control|(
name|s1P
operator|=
name|Current_Routine
init|;
name|s1P
condition|;
name|s1P
operator|=
name|symbol_next
argument_list|(
name|s1P
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
comment|/* redundant; RAW_TYPE != N_FUN suffices */
block|if (!S_IS_DEBUG (s1P)) 	continue;
endif|#
directive|endif
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|s1P
argument_list|)
operator|!=
name|N_FUN
condition|)
continue|continue;
name|pnt0
operator|=
name|s0P_name
expr_stmt|;
name|pnt1
operator|=
name|S_GET_NAME
argument_list|(
name|s1P
argument_list|)
expr_stmt|;
comment|/* We assume the two strings are never exactly equal...  */
while|while
condition|(
operator|*
name|pnt0
operator|++
operator|==
operator|*
name|pnt1
operator|++
condition|)
block|{ 	}
comment|/* Found it if s0P name is exhausted and s1P name has ":F" or ":f" next. 	 Note:  both pointers have advanced one past the non-matching char.  */
if|if
condition|(
operator|(
operator|*
name|pnt1
operator|==
literal|'F'
operator|||
operator|*
name|pnt1
operator|==
literal|'f'
operator|)
operator|&&
operator|*
operator|--
name|pnt1
operator|==
literal|':'
operator|&&
operator|*
operator|--
name|pnt0
operator|==
literal|'\0'
condition|)
block|{
name|Define_Routine
argument_list|(
name|s1P
argument_list|,
literal|0
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Construct and output the debug symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|vms_build_DST
parameter_list|(
name|unsigned
name|text_siz
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
name|Current_Routine
init|=
literal|0
decl_stmt|;
name|struct
name|input_file
modifier|*
name|Cur_File
init|=
literal|0
decl_stmt|;
name|offsetT
name|Cur_Offset
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|Cur_Line_Number
init|=
literal|0
decl_stmt|;
name|int
name|File_Number
init|=
literal|0
decl_stmt|;
name|int
name|Debugger_Offset
init|=
literal|0
decl_stmt|;
name|int
name|file_available
decl_stmt|;
name|int
name|dsc
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
comment|/* Write the Traceback Begin Module record.  */
name|VMS_TBT_Module_Begin
argument_list|()
expr_stmt|;
comment|/* Output debugging info for global variables and static variables      that are not specific to one routine.  We also need to examine      all stabs directives, to find the definitions to all of the      advanced data types, and this is done by VMS_LSYM_Parse.  This      needs to be done before any definitions are output to the object      file, since there can be forward references in the stabs      directives.  When through with parsing, the text of the stabs      directive is altered, with the definitions removed, so that later      passes will see directives as they would be written if the type      were already defined.       We also look for files and include files, and make a list of      them.  We examine the source file numbers to establish the actual      lines that code was generated from, and then generate offsets.  */
name|VMS_LSYM_Parse
argument_list|()
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Only deal with STAB symbols here.  */
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
continue|continue;
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_SLINE
case|:
name|dsc
operator|=
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsc
operator|>
name|Cur_File
operator|->
name|max_line
condition|)
name|Cur_File
operator|->
name|max_line
operator|=
name|dsc
expr_stmt|;
if|if
condition|(
name|dsc
operator|<
name|Cur_File
operator|->
name|min_line
condition|)
name|Cur_File
operator|->
name|min_line
operator|=
name|dsc
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
name|Cur_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|Cur_File
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|Cur_File
operator|->
name|min_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
name|Cur_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_GSYM
case|:
name|VMS_GSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LCSYM
case|:
name|VMS_LCSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
comment|/* For static constant symbols */
case|case
name|N_STSYM
case|:
name|VMS_STSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Now we take a quick sweep through the files and assign offsets      to each one.  This will essentially be the starting line number to      the debugger for each file.  Output the info for the debugger to      specify the files, and then tell it how many lines to use.  */
for|for
control|(
name|Cur_File
operator|=
name|file_root
init|;
name|Cur_File
condition|;
name|Cur_File
operator|=
name|Cur_File
operator|->
name|next
control|)
block|{
if|if
condition|(
name|Cur_File
operator|->
name|max_line
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Cur_File
operator|->
name|name
argument_list|,
literal|"GNU_GXX_INCLUDE:"
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flag_debug
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Cur_File
operator|->
name|name
argument_list|,
literal|"GNU_CC_INCLUDE:"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flag_debug
condition|)
continue|continue;
comment|/* show a few extra lines at the start of the region selected */
if|if
condition|(
name|Cur_File
operator|->
name|min_line
operator|>
literal|2
condition|)
name|Cur_File
operator|->
name|min_line
operator|-=
literal|2
expr_stmt|;
name|Cur_File
operator|->
name|offset
operator|=
name|Debugger_Offset
operator|-
name|Cur_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
name|Debugger_Offset
operator|+=
name|Cur_File
operator|->
name|max_line
operator|-
name|Cur_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Cur_File
operator|->
name|same_file_fpnt
condition|)
block|{
name|Cur_File
operator|->
name|file_number
operator|=
name|Cur_File
operator|->
name|same_file_fpnt
operator|->
name|file_number
expr_stmt|;
block|}
else|else
block|{
name|Cur_File
operator|->
name|file_number
operator|=
operator|++
name|File_Number
expr_stmt|;
name|file_available
operator|=
name|VMS_TBT_Source_File
argument_list|(
name|Cur_File
operator|->
name|name
argument_list|,
name|Cur_File
operator|->
name|file_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_available
condition|)
block|{
name|Cur_File
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|File_Number
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
name|VMS_TBT_Source_Lines
argument_list|(
name|Cur_File
operator|->
name|file_number
argument_list|,
name|Cur_File
operator|->
name|min_line
argument_list|,
name|Cur_File
operator|->
name|max_line
operator|-
name|Cur_File
operator|->
name|min_line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* for */
name|Cur_File
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Scan the symbols and write out the routines      (this makes the assumption that symbols are in      order of ascending text segment offset).  */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Deal with text symbols.  */
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
condition|)
block|{
comment|/* Ignore symbols starting with "L", as they are local symbols.  */
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'L'
condition|)
continue|continue;
comment|/* If there is a routine start defined, terminate it.  */
if|if
condition|(
name|Current_Routine
condition|)
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
comment|/* Check for& skip dummy labels like "gcc_compiled.". 	   * They're identified by the IN_DEFAULT_SECTION flag.  */
if|if
condition|(
operator|(
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|&
name|IN_DEFAULT_SECTION
operator|)
operator|!=
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Store the routine begin traceback info.  */
name|VMS_TBT_Routine_Begin
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
name|Current_Routine
operator|=
name|symbolP
expr_stmt|;
comment|/* Define symbols local to this routine.  */
name|local_symbols_DST
argument_list|(
name|symbolP
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
comment|/* Done.  */
continue|continue;
block|}
comment|/* Deal with STAB symbols.  */
elseif|else
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Dispatch on STAB type.  */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Line number.  */
case|case
name|N_SLINE
case|:
comment|/* Offset the line into the correct portion of the file.  */
if|if
condition|(
name|Cur_File
operator|->
name|file_number
operator|==
literal|0
condition|)
break|break;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* Sometimes the same offset gets several source lines 		 assigned to it.  We should be selective about which 		 lines we allow, we should prefer lines that are in 		 the main source file when debugging inline functions.  */
if|if
condition|(
name|val
operator|==
name|Cur_Offset
operator|&&
name|Cur_File
operator|->
name|file_number
operator|!=
literal|1
condition|)
break|break;
comment|/* Calculate actual debugger source line.  */
name|dsc
operator|=
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|+
name|Cur_File
operator|->
name|offset
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
name|dsc
argument_list|)
expr_stmt|;
comment|/* Define PC/Line correlation.  */
if|if
condition|(
name|Cur_Offset
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* First N_SLINE; set up initial correlation.  */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|dsc
argument_list|,
name|val
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dsc
operator|-
name|Cur_Line_Number
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Line delta is not +ve, we need to close the line and 		     start a new PC/Line correlation.  */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|val
operator|-
name|Cur_Offset
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|dsc
argument_list|,
name|val
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Line delta is +ve, all is well.  */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|dsc
operator|-
name|Cur_Line_Number
argument_list|,
name|val
operator|-
name|Cur_Offset
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Update the current line/PC info.  */
name|Cur_Line_Number
operator|=
name|dsc
expr_stmt|;
name|Cur_Offset
operator|=
name|val
expr_stmt|;
break|break;
comment|/* Source file.  */
case|case
name|N_SO
case|:
comment|/* Remember that we had a source file and emit 		 the source file debugger record.  */
name|Cur_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* We need to make sure that we are really in the actual 		 source file when we compute the maximum line number. 		 Otherwise the debugger gets really confused.  */
name|Cur_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* If there is a routine start defined, terminate it        (and the line numbers).  */
if|if
condition|(
name|Current_Routine
condition|)
block|{
comment|/* Terminate the line numbers.  */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|text_siz
operator|-
name|S_GET_VALUE
argument_list|(
name|Current_Routine
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Terminate the routine.  */
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
block|}
comment|/* Write the Traceback End Module TBT record.  */
name|VMS_TBT_Module_End
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a VAX/VMS object file (everything else has been done!).  */
end_comment

begin_function
name|void
name|vms_write_object_file
parameter_list|(
name|unsigned
name|text_siz
parameter_list|,
name|unsigned
name|data_siz
parameter_list|,
name|unsigned
name|bss_siz
parameter_list|,
name|fragS
modifier|*
name|text_frag_root
parameter_list|,
name|fragS
modifier|*
name|data_frag_root
parameter_list|)
block|{
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
comment|/* Initialize program section indices; values get updated later.  */
name|Psect_Number
operator|=
literal|0
expr_stmt|;
comment|/* next Psect Index to use */
name|Text_Psect
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Text Psect Index   */
name|Data_Psect
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Data Psect Index   JF: Was -1 */
name|Bss_Psect
operator|=
operator|-
literal|3
expr_stmt|;
comment|/* Bss Psect Index    JF: Was -1 */
name|Ctors_Psect
operator|=
operator|-
literal|4
expr_stmt|;
comment|/* Ctors Psect Index  */
name|Dtors_Psect
operator|=
operator|-
literal|5
expr_stmt|;
comment|/* Dtors Psect Index  */
comment|/* Initialize other state variables.  */
name|Data_Segment
operator|=
literal|0
expr_stmt|;
name|Local_Initd_Data_Size
operator|=
literal|0
expr_stmt|;
comment|/* Create the actual output file and populate it with required      "module header" information.  */
name|Create_VMS_Object_File
argument_list|()
expr_stmt|;
name|Write_VMS_MHD_Records
argument_list|()
expr_stmt|;
comment|/* Create the Data segment:       Since this is REALLY hard to do any other way,      we actually manufacture the data segment and      then store the appropriate values out of it.      We need to generate this early, so that globalvalues      can be properly emitted.  */
if|if
condition|(
name|data_siz
operator|>
literal|0
condition|)
name|synthesize_data_segment
argument_list|(
name|data_siz
argument_list|,
name|text_siz
argument_list|,
name|data_frag_root
argument_list|)
expr_stmt|;
comment|/* Global Symbol Directory.  */
comment|/* Emit globalvalues now.  We must do this before the text psect is      defined, or we will get linker warnings about multiply defined      symbols.  All of the globalvalues "reference" psect 0, although      it really does not have anything to do with it.  */
name|VMS_Emit_Globalvalues
argument_list|(
name|text_siz
argument_list|,
name|data_siz
argument_list|,
name|Data_Segment
argument_list|)
expr_stmt|;
comment|/* Define the Text Psect.  */
name|Text_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$code"
argument_list|,
name|text_siz
argument_list|,
name|ps_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Define the BSS Psect.  */
if|if
condition|(
name|bss_siz
operator|>
literal|0
condition|)
block|{
name|Bss_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$uninitialized_data"
argument_list|,
name|bss_siz
argument_list|,
name|ps_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Define symbols to the linker.  */
name|global_symbol_directory
argument_list|(
name|text_siz
argument_list|,
name|data_siz
argument_list|)
expr_stmt|;
comment|/* Define the Data Psect.  */
if|if
condition|(
name|data_siz
operator|>
literal|0
operator|&&
name|Local_Initd_Data_Size
operator|>
literal|0
condition|)
block|{
name|Data_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$data"
argument_list|,
name|Local_Initd_Data_Size
argument_list|,
name|ps_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Local initialized data (N_DATA) symbols need to be updated to the          proper value of Data_Psect now that it's actually been defined.          (A dummy value was used in global_symbol_directory() above.)  */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|0
operator|&&
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|N_DATA
condition|)
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
block|}
if|if
condition|(
name|Ctors_Symbols
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ps_name
init|=
literal|"$ctors"
decl_stmt|;
name|Ctors_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
name|ps_name
argument_list|,
name|Ctors_Symbols
operator|->
name|Psect_Offset
operator|+
name|XTOR_SIZE
argument_list|,
name|ps_CTORS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|ps_name
argument_list|,
name|Ctors_Psect
argument_list|,
literal|0
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_WEAK
argument_list|)
expr_stmt|;
for|for
control|(
name|vsp
operator|=
name|Ctors_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
name|vsp
operator|->
name|Psect_Index
operator|=
name|Ctors_Psect
expr_stmt|;
block|}
if|if
condition|(
name|Dtors_Symbols
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ps_name
init|=
literal|"$dtors"
decl_stmt|;
name|Dtors_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
name|ps_name
argument_list|,
name|Dtors_Symbols
operator|->
name|Psect_Offset
operator|+
name|XTOR_SIZE
argument_list|,
name|ps_DTORS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|ps_name
argument_list|,
name|Dtors_Psect
argument_list|,
literal|0
argument_list|,
name|GBLSYM_DEF
operator||
name|GBLSYM_WEAK
argument_list|)
expr_stmt|;
for|for
control|(
name|vsp
operator|=
name|Dtors_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
name|vsp
operator|->
name|Psect_Index
operator|=
name|Dtors_Psect
expr_stmt|;
block|}
comment|/* Text Information and Relocation Records.  */
comment|/* Write the text segment data.  */
if|if
condition|(
name|text_siz
operator|>
literal|0
condition|)
name|vms_fixup_text_section
argument_list|(
name|text_siz
argument_list|,
name|text_frag_root
argument_list|,
name|data_frag_root
argument_list|)
expr_stmt|;
comment|/* Write the data segment data, then discard it.  */
if|if
condition|(
name|data_siz
operator|>
literal|0
condition|)
block|{
name|vms_fixup_data_section
argument_list|(
name|data_siz
argument_list|,
name|text_siz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Data_Segment
argument_list|)
operator|,
name|Data_Segment
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|Ctors_Symbols
operator|!=
literal|0
condition|)
name|vms_fixup_xtors_section
argument_list|(
name|Ctors_Symbols
argument_list|,
name|Ctors_Psect
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dtors_Symbols
operator|!=
literal|0
condition|)
name|vms_fixup_xtors_section
argument_list|(
name|Dtors_Symbols
argument_list|,
name|Dtors_Psect
argument_list|)
expr_stmt|;
comment|/* Debugger Symbol Table Records.  */
name|vms_build_DST
argument_list|(
name|text_siz
argument_list|)
expr_stmt|;
comment|/* Wrap things up.  */
comment|/* Write the End Of Module record.  */
if|if
condition|(
name|Entry_Point_Symbol
condition|)
name|Write_VMS_EOM_Record
argument_list|(
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|Entry_Point_Symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Write_VMS_EOM_Record
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* All done, close the object file.  */
name|Close_VMS_Object_File
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

