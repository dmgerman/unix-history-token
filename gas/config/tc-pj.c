begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-    tc-pj.c -- Assemble code for Pico Java    Copyright 1999, 2000, 2001, 2002, 2003, 2005    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Contributed by Steve Chamberlain of Transmeta<sac@pobox.com>.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/pj.h"
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|pj_opc_info_t
name|pj_opc_info
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"/!#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pending_reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|little
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|target_big_endian
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|big
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|target_big_endian
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"ml"
block|,
name|little
block|,
literal|0
block|}
block|,
block|{
literal|"mb"
block|,
name|big
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"%hi16"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_reloc
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"confusing relocation expressions"
argument_list|)
argument_list|)
expr_stmt|;
name|pending_reloc
operator|=
name|BFD_RELOC_PJ_CODE_HI16
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"%lo16"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_reloc
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"confusing relocation expressions"
argument_list|)
argument_list|)
expr_stmt|;
name|pending_reloc
operator|=
name|BFD_RELOC_PJ_CODE_LO16
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an expression and then restore the input line pointer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_exp_save_ilp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|expressionS
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a    reloc for a cons.  We could use the definition there, except that    we want to handle magic pending reloc expressions specially.  */
end_comment

begin_function
name|void
name|pj_cons_fix_new_pj
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
specifier|static
name|int
name|rv
index|[
literal|5
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|BFD_RELOC_8
block|}
block|,
block|{
name|BFD_RELOC_PJ_CODE_DIR16
block|,
name|BFD_RELOC_16
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
name|BFD_RELOC_PJ_CODE_DIR32
block|,
name|BFD_RELOC_32
block|}
block|}
decl_stmt|;
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|pending_reloc
condition|?
name|pending_reloc
else|:
name|rv
index|[
name|nbytes
index|]
index|[
operator|(
name|now_seg
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
condition|?
literal|0
else|:
literal|1
index|]
argument_list|)
expr_stmt|;
name|pending_reloc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a reloc description character from the pj-opc.h table into    code which BFD can handle.  */
end_comment

begin_function
specifier|static
name|int
name|c_to_r
parameter_list|(
name|int
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|O_R8
case|:
return|return
name|BFD_RELOC_8_PCREL
return|;
case|case
name|O_U8
case|:
case|case
name|O_8
case|:
return|return
name|BFD_RELOC_8
return|;
case|case
name|O_R16
case|:
return|return
name|BFD_RELOC_PJ_CODE_REL16
return|;
case|case
name|O_U16
case|:
case|case
name|O_16
case|:
return|return
name|BFD_RELOC_PJ_CODE_DIR16
return|;
case|case
name|O_R32
case|:
return|return
name|BFD_RELOC_PJ_CODE_REL32
return|;
case|case
name|O_32
case|:
return|return
name|BFD_RELOC_PJ_CODE_DIR32
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handler for the ipush fake opcode,    turns ipush<foo> into sipush lo16<foo>, sethi hi16<foo>.  */
end_comment

begin_function
specifier|static
name|void
name|ipush_code
parameter_list|(
name|pj_opc_info_t
modifier|*
name|opcode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|frag_more
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|expressionS
name|arg
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
literal|0x11
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
literal|0xed
expr_stmt|;
name|parse_exp_save_ilp
argument_list|(
name|str
operator|+
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_reloc
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't have relocation for ipush"
argument_list|)
argument_list|)
expr_stmt|;
name|pending_reloc
operator|=
literal|0
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|b
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_PJ_CODE_DIR16
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|b
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_PJ_CODE_HI16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert names into the opcode table which are really mini macros,    not opcodes.  The fakeness is indicated with an opcode of -1.  */
end_comment

begin_function
specifier|static
name|void
name|fake_opcode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|pj_opc_info_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|pj_opc_info_t
modifier|*
name|fake
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pj_opc_info_t
argument_list|)
argument_list|)
decl_stmt|;
name|fake
operator|->
name|opcode
operator|=
operator|-
literal|1
expr_stmt|;
name|fake
operator|->
name|opcode_next
operator|=
operator|-
literal|1
expr_stmt|;
name|fake
operator|->
name|u
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fake
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter another entry into the opcode hash table so the same opcode    can have another name.  */
end_comment

begin_function
specifier|static
name|void
name|alias
parameter_list|(
specifier|const
name|char
modifier|*
name|new
parameter_list|,
specifier|const
name|char
modifier|*
name|old
parameter_list|)
block|{
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|old
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It sets    up the hash table with all the opcodes in it, and also initializes    some aliases for compatibility with other assemblers.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|pj_opc_info_t
modifier|*
name|opcode
decl_stmt|;
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert names into hash table.  */
for|for
control|(
name|opcode
operator|=
name|pj_opc_info
init|;
name|opcode
operator|->
name|u
operator|.
name|name
condition|;
name|opcode
operator|++
control|)
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* Insert the only fake opcode.  */
name|fake_opcode
argument_list|(
literal|"ipush"
argument_list|,
name|ipush_code
argument_list|)
expr_stmt|;
comment|/* Add some aliases for opcode names.  */
name|alias
argument_list|(
literal|"ifeq_s"
argument_list|,
literal|"ifeq"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"ifne_s"
argument_list|,
literal|"ifne"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"if_icmpge_s"
argument_list|,
literal|"if_icmpge"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"if_icmpne_s"
argument_list|,
literal|"if_icmpne"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"if_icmpeq_s"
argument_list|,
literal|"if_icmpeq"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"if_icmpgt_s"
argument_list|,
literal|"if_icmpgt"
argument_list|)
expr_stmt|;
name|alias
argument_list|(
literal|"goto_s"
argument_list|,
literal|"goto"
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to    a machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|pj_opc_info_t
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|char
name|pend
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
name|op_start
operator|=
name|str
expr_stmt|;
for|for
control|(
name|op_end
operator|=
name|str
init|;
operator|*
name|op_end
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
operator|&
literal|0xff
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
name|nlen
operator|++
expr_stmt|;
name|pend
operator|=
operator|*
name|op_end
expr_stmt|;
operator|*
name|op_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|(
name|pj_opc_info_t
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|op_start
argument_list|)
expr_stmt|;
operator|*
name|op_end
operator|=
name|pend
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode %s"
argument_list|)
argument_list|,
name|op_start
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* It's a fake opcode.  Dig out the args and pretend that was          what we were passed.  */
call|(
modifier|*
name|opcode
operator|->
name|u
operator|.
name|func
call|)
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|an
decl_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
name|opcode
operator|->
name|len
argument_list|)
expr_stmt|;
name|output
index|[
name|idx
operator|++
index|]
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|opcode_next
operator|!=
operator|-
literal|1
condition|)
name|output
index|[
name|idx
operator|++
index|]
operator|=
name|opcode
operator|->
name|opcode_next
expr_stmt|;
for|for
control|(
name|an
operator|=
literal|0
init|;
name|opcode
operator|->
name|arg
index|[
name|an
index|]
condition|;
name|an
operator|++
control|)
block|{
name|expressionS
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|','
operator|&&
name|an
operator|!=
literal|0
condition|)
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
literal|"expected expresssion"
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|parse_exp_save_ilp
argument_list|(
name|op_end
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|output
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|idx
argument_list|,
name|ASIZE
argument_list|(
name|opcode
operator|->
name|arg
index|[
name|an
index|]
argument_list|)
argument_list|,
operator|&
name|arg
argument_list|,
name|PCREL
argument_list|(
name|opcode
operator|->
name|arg
index|[
name|an
index|]
argument_list|)
argument_list|,
name|pending_reloc
condition|?
name|pending_reloc
else|:
name|c_to_r
argument_list|(
name|opcode
operator|->
name|arg
index|[
name|an
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|ASIZE
argument_list|(
name|opcode
operator|->
name|arg
index|[
name|an
index|]
argument_list|)
expr_stmt|;
name|pending_reloc
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|op_end
argument_list|)
condition|)
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
literal|"extra stuff on line ignored"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_reloc
condition|)
name|as_bad
argument_list|(
literal|"Something forgot to clean up\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP .  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_LITTLE
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_BIG
value|(OPTION_LITTLE + 1)
block|{
literal|"little"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE
block|}
block|,
block|{
literal|"big"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_LITTLE
case|:
name|little
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_BIG
case|:
name|big
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ PJ options:\n\ -little			generate little endian code\n\ -big			generate big endian code\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|long
name|val
init|=
operator|*
name|valP
decl_stmt|;
name|long
name|max
decl_stmt|,
name|min
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|max
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_PJ_CODE_REL16
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|0x8000
operator|||
name|val
operator|>=
literal|0x7fff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel too far"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PJ_CODE_HI16
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PJ_CODE_DIR16
case|:
case|case
name|BFD_RELOC_PJ_CODE_LO16
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
name|max
operator|=
literal|0xffff
expr_stmt|;
name|min
operator|=
operator|-
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
name|max
operator|=
literal|0xff
expr_stmt|;
name|min
operator|=
operator|-
literal|0xff
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PJ_CODE_DIR32
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|target_big_endian
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|target_big_endian
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|<
name|min
operator|||
name|val
operator|>
name|max
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  Always put values in an    executable section into big endian order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|valueT
name|use
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
operator|||
name|now_seg
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|r_type
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

end_unit

