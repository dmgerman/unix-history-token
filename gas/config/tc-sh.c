begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-sh.c -- Assemble code for the Hitachi Super-H    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written By Steve Chamberlain<sac@cygnus.com>  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"opcodes/sh-opc.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|sh_arg_type
name|type
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|expressionS
name|immediate
decl_stmt|;
block|}
name|sh_operand_info
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"!#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_uses
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_count_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sh_frob_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_uacons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sh_opcode_info
modifier|*
name|find_cooked_opcode
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|assemble_ppi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|sh_opcode_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|little
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|big
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_exp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_at
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_operands
name|PARAMS
argument_list|(
operator|(
name|sh_opcode_info
operator|*
operator|,
name|char
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sh_opcode_info
modifier|*
name|get_specific
name|PARAMS
argument_list|(
operator|(
name|sh_opcode_info
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_relax
name|PARAMS
argument_list|(
operator|(
name|sh_opcode_info
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insert_loop_bounds
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|build_Mytes
name|PARAMS
argument_list|(
operator|(
name|sh_opcode_info
operator|*
operator|,
name|sh_operand_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|sh_elf_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|inline
specifier|static
name|int
name|sh_PIC_related_p
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sh_check_fixup
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|inline
specifier|static
name|char
modifier|*
name|sh_end_of_match
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|big
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directive .big encountered when option -big required"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop further messages.  */
name|target_big_endian
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|little
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"directive .little encountered when option -little required"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop further messages.  */
name|target_big_endian
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"long"
block|,
name|sh_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"int"
block|,
name|sh_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|sh_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"short"
block|,
name|sh_elf_cons
block|,
literal|2
block|}
block|,
else|#
directive|else
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
endif|#
directive|endif
comment|/* OBJ_ELF */
block|{
literal|"big"
block|,
name|big
block|,
literal|0
block|}
block|,
block|{
literal|"form"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"little"
block|,
name|little
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"program"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"uses"
block|,
name|s_uses
block|,
literal|0
block|}
block|,
block|{
literal|"uaword"
block|,
name|s_uacons
block|,
literal|2
block|}
block|,
block|{
literal|"ualong"
block|,
name|s_uacons
block|,
literal|4
block|}
block|,
block|{
literal|"uaquad"
block|,
name|s_uacons
block|,
literal|8
block|}
block|,
block|{
literal|"2byte"
block|,
name|s_uacons
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|s_uacons
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|s_uacons
block|,
literal|8
block|}
block|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SH64
block|{
literal|"mode"
block|,
name|s_sh64_mode
block|,
literal|0
block|}
block|,
comment|/* Have the old name too.  */
block|{
literal|"isa"
block|,
name|s_sh64_mode
block|,
literal|0
block|}
block|,
comment|/* Assert that the right ABI is used.  */
block|{
literal|"abi"
block|,
name|s_sh64_abi
block|,
literal|0
block|}
block|,
block|{
literal|"vtable_inherit"
block|,
name|sh64_vtable_inherit
block|,
literal|0
block|}
block|,
block|{
literal|"vtable_entry"
block|,
name|sh64_vtable_entry
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* HAVE_SH64 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*int md_reloc_size; */
end_comment

begin_decl_stmt
name|int
name|sh_relax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if -relax seen */
end_comment

begin_comment
comment|/* Whether -small was seen.  */
end_comment

begin_decl_stmt
name|int
name|sh_small
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether -dsp was seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sh_dsp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bit mask of architectures that could    accomodate the insns seen so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|valid_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.  */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX(a,b)
end_define

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 4) + (length))
end_define

begin_define
define|#
directive|define
name|GET_WHAT
parameter_list|(
name|x
parameter_list|)
value|((x>>4))
end_define

begin_comment
comment|/* These are the three types of relaxable instrction.  */
end_comment

begin_comment
comment|/* These are the types of relaxable instructions; except for END which is    a marker.  */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_define
define|#
directive|define
name|COND_JUMP_DELAY
value|2
end_define

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|3
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SH64
end_ifdef

begin_comment
comment|/* A 16-bit (times four) pc-relative operand, at most expanded to 32 bits.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL16_32
value|4
end_define

begin_comment
comment|/* A 16-bit (times four) pc-relative operand, at most expanded to 64 bits.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL16_64
value|5
end_define

begin_comment
comment|/* Variants of the above for adjusting the insn to PTA or PTB according to    the label.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL16PT_32
value|6
end_define

begin_define
define|#
directive|define
name|SH64PCREL16PT_64
value|7
end_define

begin_comment
comment|/* A MOVI expansion, expanding to at most 32 or 64 bits.  */
end_comment

begin_define
define|#
directive|define
name|MOVI_IMM_32
value|8
end_define

begin_define
define|#
directive|define
name|MOVI_IMM_32_PCREL
value|9
end_define

begin_define
define|#
directive|define
name|MOVI_IMM_64
value|10
end_define

begin_define
define|#
directive|define
name|MOVI_IMM_64_PCREL
value|11
end_define

begin_define
define|#
directive|define
name|END
value|12
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SH64 */
end_comment

begin_define
define|#
directive|define
name|END
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SH64 */
end_comment

begin_define
define|#
directive|define
name|UNDEF_DISP
value|0
end_define

begin_define
define|#
directive|define
name|COND8
value|1
end_define

begin_define
define|#
directive|define
name|COND12
value|2
end_define

begin_define
define|#
directive|define
name|COND32
value|3
end_define

begin_define
define|#
directive|define
name|UNDEF_WORD_DISP
value|4
end_define

begin_define
define|#
directive|define
name|UNCOND12
value|1
end_define

begin_define
define|#
directive|define
name|UNCOND32
value|2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SH64
end_ifdef

begin_define
define|#
directive|define
name|UNDEF_SH64PCREL
value|0
end_define

begin_define
define|#
directive|define
name|SH64PCREL16
value|1
end_define

begin_define
define|#
directive|define
name|SH64PCREL32
value|2
end_define

begin_define
define|#
directive|define
name|SH64PCREL48
value|3
end_define

begin_define
define|#
directive|define
name|SH64PCREL64
value|4
end_define

begin_define
define|#
directive|define
name|SH64PCRELPLT
value|5
end_define

begin_define
define|#
directive|define
name|UNDEF_MOVI
value|0
end_define

begin_define
define|#
directive|define
name|MOVI_16
value|1
end_define

begin_define
define|#
directive|define
name|MOVI_32
value|2
end_define

begin_define
define|#
directive|define
name|MOVI_48
value|3
end_define

begin_define
define|#
directive|define
name|MOVI_64
value|4
end_define

begin_define
define|#
directive|define
name|MOVI_PLT
value|5
end_define

begin_define
define|#
directive|define
name|MOVI_GOTOFF
value|6
end_define

begin_define
define|#
directive|define
name|MOVI_GOTPC
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SH64 */
end_comment

begin_comment
comment|/* Branch displacements are from the address of the branch plus    four, thus all minimum and maximum values have 4 added to them.  */
end_comment

begin_define
define|#
directive|define
name|COND8_F
value|258
end_define

begin_define
define|#
directive|define
name|COND8_M
value|-252
end_define

begin_define
define|#
directive|define
name|COND8_LENGTH
value|2
end_define

begin_comment
comment|/* There is one extra instruction before the branch, so we must add    two more bytes to account for it.  */
end_comment

begin_define
define|#
directive|define
name|COND12_F
value|4100
end_define

begin_define
define|#
directive|define
name|COND12_M
value|-4090
end_define

begin_define
define|#
directive|define
name|COND12_LENGTH
value|6
end_define

begin_define
define|#
directive|define
name|COND12_DELAY_LENGTH
value|4
end_define

begin_comment
comment|/* ??? The minimum and maximum values are wrong, but this does not matter    since this relocation type is not supported yet.  */
end_comment

begin_define
define|#
directive|define
name|COND32_F
value|(1<<30)
end_define

begin_define
define|#
directive|define
name|COND32_M
value|-(1<<30)
end_define

begin_define
define|#
directive|define
name|COND32_LENGTH
value|14
end_define

begin_define
define|#
directive|define
name|UNCOND12_F
value|4098
end_define

begin_define
define|#
directive|define
name|UNCOND12_M
value|-4092
end_define

begin_define
define|#
directive|define
name|UNCOND12_LENGTH
value|2
end_define

begin_comment
comment|/* ??? The minimum and maximum values are wrong, but this does not matter    since this relocation type is not supported yet.  */
end_comment

begin_define
define|#
directive|define
name|UNCOND32_F
value|(1<<30)
end_define

begin_define
define|#
directive|define
name|UNCOND32_M
value|-(1<<30)
end_define

begin_define
define|#
directive|define
name|UNCOND32_LENGTH
value|14
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SH64
end_ifdef

begin_comment
comment|/* The trivial expansion of a SH64PCREL16 relaxation is just a "PT label,    TRd" as is the current insn, so no extra length.  Note that the "reach"    is calculated from the address *after* that insn, but the offset in the    insn is calculated from the beginning of the insn.  We also need to    take into account the implicit 1 coded as the "A" in PTA when counting    forward.  If PTB reaches an odd address, we trap that as an error    elsewhere, so we don't have to have different relaxation entries.  We    don't add a one to the negative range, since PTB would then have the    farthest backward-reaching value skipped, not generated at relaxation.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL16_F
value|(32767 * 4 - 4 + 1)
end_define

begin_define
define|#
directive|define
name|SH64PCREL16_M
value|(-32768 * 4 - 4)
end_define

begin_define
define|#
directive|define
name|SH64PCREL16_LENGTH
value|0
end_define

begin_comment
comment|/* The next step is to change that PT insn into      MOVI ((label - datalabel Ln)>> 16)& 65535, R25      SHORI (label - datalabel Ln)& 65535, R25     Ln:      PTREL R25,TRd    which means two extra insns, 8 extra bytes.  This is the limit for the    32-bit ABI.     The expressions look a bit bad since we have to adjust this to avoid overflow on a    32-bit host.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL32_F
value|((((long) 1<< 30) - 1) * 2 + 1 - 4)
end_define

begin_define
define|#
directive|define
name|SH64PCREL32_LENGTH
value|(2 * 4)
end_define

begin_comment
comment|/* Similarly, we just change the MOVI and add a SHORI for the 48-bit    expansion.  */
end_comment

begin_if
if|#
directive|if
name|BFD_HOST_64BIT_LONG
end_if

begin_comment
comment|/* The "reach" type is long, so we can only do this for a 64-bit-long    host.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL32_M
value|(((long) -1<< 30) * 2 - 4)
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_F
value|((((long) 1<< 47) - 1) - 4)
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_M
value|(((long) -1<< 47) - 4)
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_LENGTH
value|(3 * 4)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If the host does not have 64-bit longs, just make this state identical    in reach to the 32-bit state.  Note that we have a slightly incorrect    reach, but the correct one above will overflow a 32-bit number.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL32_M
value|(((long) -1<< 30) * 2)
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_F
value|SH64PCREL32_F
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_M
value|SH64PCREL32_M
end_define

begin_define
define|#
directive|define
name|SH64PCREL48_LENGTH
value|(3 * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_HOST_64BIT_LONG */
end_comment

begin_comment
comment|/* And similarly for the 64-bit expansion; a MOVI + SHORI + SHORI + SHORI    + PTREL sequence.  */
end_comment

begin_define
define|#
directive|define
name|SH64PCREL64_LENGTH
value|(4 * 4)
end_define

begin_comment
comment|/* For MOVI, we make the MOVI + SHORI... expansion you can see in the    SH64PCREL expansions.  The PCREL one is similar, but the other has no    pc-relative reach; it must be fully expanded in    shmedia_md_estimate_size_before_relax.  */
end_comment

begin_define
define|#
directive|define
name|MOVI_16_LENGTH
value|0
end_define

begin_define
define|#
directive|define
name|MOVI_16_F
value|(32767 - 4)
end_define

begin_define
define|#
directive|define
name|MOVI_16_M
value|(-32768 - 4)
end_define

begin_define
define|#
directive|define
name|MOVI_32_LENGTH
value|4
end_define

begin_define
define|#
directive|define
name|MOVI_32_F
value|((((long) 1<< 30) - 1) * 2 + 1 - 4)
end_define

begin_define
define|#
directive|define
name|MOVI_48_LENGTH
value|8
end_define

begin_if
if|#
directive|if
name|BFD_HOST_64BIT_LONG
end_if

begin_comment
comment|/* The "reach" type is long, so we can only do this for a 64-bit-long    host.  */
end_comment

begin_define
define|#
directive|define
name|MOVI_32_M
value|(((long) -1<< 30) * 2 - 4)
end_define

begin_define
define|#
directive|define
name|MOVI_48_F
value|((((long) 1<< 47) - 1) - 4)
end_define

begin_define
define|#
directive|define
name|MOVI_48_M
value|(((long) -1<< 47) - 4)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If the host does not have 64-bit longs, just make this state identical    in reach to the 32-bit state.  Note that we have a slightly incorrect    reach, but the correct one above will overflow a 32-bit number.  */
end_comment

begin_define
define|#
directive|define
name|MOVI_32_M
value|(((long) -1<< 30) * 2)
end_define

begin_define
define|#
directive|define
name|MOVI_48_F
value|MOVI_32_F
end_define

begin_define
define|#
directive|define
name|MOVI_48_M
value|MOVI_32_M
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_HOST_64BIT_LONG */
end_comment

begin_define
define|#
directive|define
name|MOVI_64_LENGTH
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SH64 */
end_comment

begin_define
define|#
directive|define
name|EMPTY
value|{ 0, 0, 0, 0 }
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[
name|C
argument_list|(
name|END
argument_list|,
literal|0
argument_list|)
index|]
init|=
block|{
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (COND_JUMP, COND8) */
block|{
name|COND8_F
block|,
name|COND8_M
block|,
name|COND8_LENGTH
block|,
name|C
argument_list|(
argument|COND_JUMP
argument_list|,
argument|COND12
argument_list|)
block|}
block|,
comment|/* C (COND_JUMP, COND12) */
block|{
name|COND12_F
block|,
name|COND12_M
block|,
name|COND12_LENGTH
block|,
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
block|, }
block|,
comment|/* C (COND_JUMP, COND32) */
block|{
name|COND32_F
block|,
name|COND32_M
block|,
name|COND32_LENGTH
block|,
literal|0
block|, }
block|,
comment|/* C (COND_JUMP, UNDEF_WORD_DISP) */
block|{
literal|0
block|,
literal|0
block|,
name|COND32_LENGTH
block|,
literal|0
block|, }
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (COND_JUMP_DELAY, COND8) */
block|{
name|COND8_F
block|,
name|COND8_M
block|,
name|COND8_LENGTH
block|,
name|C
argument_list|(
argument|COND_JUMP_DELAY
argument_list|,
argument|COND12
argument_list|)
block|}
block|,
comment|/* C (COND_JUMP_DELAY, COND12) */
block|{
name|COND12_F
block|,
name|COND12_M
block|,
name|COND12_DELAY_LENGTH
block|,
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND32
argument_list|)
block|, }
block|,
comment|/* C (COND_JUMP_DELAY, COND32) */
block|{
name|COND32_F
block|,
name|COND32_M
block|,
name|COND32_LENGTH
block|,
literal|0
block|, }
block|,
comment|/* C (COND_JUMP_DELAY, UNDEF_WORD_DISP) */
block|{
literal|0
block|,
literal|0
block|,
name|COND32_LENGTH
block|,
literal|0
block|, }
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (UNCOND_JUMP, UNCOND12) */
block|{
name|UNCOND12_F
block|,
name|UNCOND12_M
block|,
name|UNCOND12_LENGTH
block|,
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
block|, }
block|,
comment|/* C (UNCOND_JUMP, UNCOND32) */
block|{
name|UNCOND32_F
block|,
name|UNCOND32_M
block|,
name|UNCOND32_LENGTH
block|,
literal|0
block|, }
block|,
name|EMPTY
block|,
comment|/* C (UNCOND_JUMP, UNDEF_WORD_DISP) */
block|{
literal|0
block|,
literal|0
block|,
name|UNCOND32_LENGTH
block|,
literal|0
block|, }
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
ifdef|#
directive|ifdef
name|HAVE_SH64
comment|/* C (SH64PCREL16_32, SH64PCREL16) */
name|EMPTY
block|,
block|{
name|SH64PCREL16_F
block|,
name|SH64PCREL16_M
block|,
name|SH64PCREL16_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16_32
argument_list|,
argument|SH64PCREL32
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16_32, SH64PCREL32) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (SH64PCREL16_32, SH64PCRELPLT) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (SH64PCREL16_64, SH64PCREL16) */
name|EMPTY
block|,
block|{
name|SH64PCREL16_F
block|,
name|SH64PCREL16_M
block|,
name|SH64PCREL16_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16_64
argument_list|,
argument|SH64PCREL32
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16_64, SH64PCREL32) */
block|{
name|SH64PCREL32_F
block|,
name|SH64PCREL32_M
block|,
name|SH64PCREL32_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16_64
argument_list|,
argument|SH64PCREL48
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16_64, SH64PCREL48) */
block|{
name|SH64PCREL48_F
block|,
name|SH64PCREL48_M
block|,
name|SH64PCREL48_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16_64
argument_list|,
argument|SH64PCREL64
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16_64, SH64PCREL64) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL64_LENGTH
block|,
literal|0
block|}
block|,
comment|/* C (SH64PCREL16_64, SH64PCRELPLT) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (SH64PCREL16PT_32, SH64PCREL16) */
name|EMPTY
block|,
block|{
name|SH64PCREL16_F
block|,
name|SH64PCREL16_M
block|,
name|SH64PCREL16_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16PT_32
argument_list|,
argument|SH64PCREL32
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16PT_32, SH64PCREL32) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (SH64PCREL16PT_32, SH64PCRELPLT) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (SH64PCREL16PT_64, SH64PCREL16) */
name|EMPTY
block|,
block|{
name|SH64PCREL16_F
block|,
name|SH64PCREL16_M
block|,
name|SH64PCREL16_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16PT_64
argument_list|,
argument|SH64PCREL32
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16PT_64, SH64PCREL32) */
block|{
name|SH64PCREL32_F
block|,
name|SH64PCREL32_M
block|,
name|SH64PCREL32_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16PT_64
argument_list|,
argument|SH64PCREL48
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16PT_64, SH64PCREL48) */
block|{
name|SH64PCREL48_F
block|,
name|SH64PCREL48_M
block|,
name|SH64PCREL48_LENGTH
block|,
name|C
argument_list|(
argument|SH64PCREL16PT_64
argument_list|,
argument|SH64PCREL64
argument_list|)
block|}
block|,
comment|/* C (SH64PCREL16PT_64, SH64PCREL64) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL64_LENGTH
block|,
literal|0
block|}
block|,
comment|/* C (SH64PCREL16PT_64, SH64PCRELPLT) */
block|{
literal|0
block|,
literal|0
block|,
name|SH64PCREL64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_32, UNDEF_MOVI) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
comment|/* C (MOVI_IMM_32, MOVI_16) */
block|{
name|MOVI_16_F
block|,
name|MOVI_16_M
block|,
name|MOVI_16_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_32
argument_list|,
argument|MOVI_32
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_32, MOVI_32) */
block|{
name|MOVI_32_F
block|,
name|MOVI_32_M
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_32, MOVI_GOTOFF) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_32_PCREL, MOVI_16) */
name|EMPTY
block|,
block|{
name|MOVI_16_F
block|,
name|MOVI_16_M
block|,
name|MOVI_16_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_32_PCREL
argument_list|,
argument|MOVI_32
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_32_PCREL, MOVI_32) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_32_PCREL, MOVI_PLT) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_32_PCREL, MOVI_GOTPC) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_32_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_64, UNDEF_MOVI) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
comment|/* C (MOVI_IMM_64, MOVI_16) */
block|{
name|MOVI_16_F
block|,
name|MOVI_16_M
block|,
name|MOVI_16_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64
argument_list|,
argument|MOVI_32
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64, MOVI_32) */
block|{
name|MOVI_32_F
block|,
name|MOVI_32_M
block|,
name|MOVI_32_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64
argument_list|,
argument|MOVI_48
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64, MOVI_48) */
block|{
name|MOVI_48_F
block|,
name|MOVI_48_M
block|,
name|MOVI_48_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64
argument_list|,
argument|MOVI_64
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64, MOVI_64) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_64, MOVI_GOTOFF) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_16) */
name|EMPTY
block|,
block|{
name|MOVI_16_F
block|,
name|MOVI_16_M
block|,
name|MOVI_16_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64_PCREL
argument_list|,
argument|MOVI_32
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_32) */
block|{
name|MOVI_32_F
block|,
name|MOVI_32_M
block|,
name|MOVI_32_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64_PCREL
argument_list|,
argument|MOVI_48
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_48) */
block|{
name|MOVI_48_F
block|,
name|MOVI_48_M
block|,
name|MOVI_48_LENGTH
block|,
name|C
argument_list|(
argument|MOVI_IMM_64_PCREL
argument_list|,
argument|MOVI_64
argument_list|)
block|}
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_64) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_PLT) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
comment|/* C (MOVI_IMM_64_PCREL, MOVI_GOTPC) */
block|{
literal|0
block|,
literal|0
block|,
name|MOVI_64_LENGTH
block|,
literal|0
block|}
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
name|EMPTY
block|,
endif|#
directive|endif
comment|/* HAVE_SH64 */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|EMPTY
end_undef

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Determinet whether the symbol needs any kind of PIC relocation.  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
name|sh_PIC_related_p
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sym
operator|==
name|GOT_symbol
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_SH64
if|if
condition|(
name|sh_PIC_related_p
argument_list|(
operator|*
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp
operator|->
name|X_op
operator|==
name|O_PIC_reloc
operator|||
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the relocation type to be used to represent the    expression, that may be rearranged.  */
end_comment

begin_function
specifier|static
name|int
name|sh_check_fixup
parameter_list|(
name|main_exp
parameter_list|,
name|r_type_p
parameter_list|)
name|expressionS
modifier|*
name|main_exp
decl_stmt|;
name|bfd_reloc_code_real_type
modifier|*
name|r_type_p
decl_stmt|;
block|{
name|expressionS
modifier|*
name|exp
init|=
name|main_exp
decl_stmt|;
comment|/* This is here for backward-compatibility only.  GCC used to generated:  	f@PLT + . - (.LPCS# + 2)       but we'd rather be able to handle this as a PIC-related reference      plus/minus a symbol.  However, gas' parser gives us:  	O_subtract (O_add (f@PLT, .), .LPCS#+2)       so we attempt to transform this into:          O_subtract (f@PLT, O_subtract (.LPCS#+2, .))       which we can handle simply below.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
if|if
condition|(
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
condition|)
return|return
literal|1
return|;
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|exp
operator|&&
name|exp
operator|->
name|X_op
operator|==
name|O_add
operator|&&
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|exp
operator|->
name|X_add_symbol
decl_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
name|main_exp
operator|->
name|X_op_symbol
expr_stmt|;
name|main_exp
operator|->
name|X_op_symbol
operator|=
name|main_exp
operator|->
name|X_add_symbol
expr_stmt|;
name|main_exp
operator|->
name|X_add_symbol
operator|=
name|sym
expr_stmt|;
name|main_exp
operator|->
name|X_add_number
operator|+=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|exp
operator|=
name|main_exp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_add
operator|&&
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_symbol
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_add
operator|||
name|exp
operator|->
name|X_op
operator|==
name|O_subtract
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SH64
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|&&
operator|(
name|exp
operator|->
name|X_add_symbol
operator|==
name|GOT_symbol
operator|||
operator|(
name|GOT_symbol
operator|&&
operator|*
name|symbol_get_tc
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|GOT_symbol
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|r_type_p
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC_LOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC_MEDLOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC_MEDHI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC_HI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_NONE
case|:
case|case
name|BFD_RELOC_UNUSED
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|#
directive|else
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|==
name|GOT_symbol
condition|)
block|{
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPC
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|exp
operator|=
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_PIC_reloc
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SH64
switch|switch
condition|(
operator|*
name|r_type_p
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
case|case
name|BFD_RELOC_UNUSED
case|:
operator|*
name|r_type_p
operator|=
name|exp
operator|->
name|X_md
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM_LOW16
case|:
switch|switch
condition|(
name|exp
operator|->
name|X_md
condition|)
block|{
case|case
name|BFD_RELOC_32_GOTOFF
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTOFF_LOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_GOTPLT32
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPLT_LOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOT_LOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_PLT_LOW16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDLOW16
case|:
switch|switch
condition|(
name|exp
operator|->
name|X_md
condition|)
block|{
case|case
name|BFD_RELOC_32_GOTOFF
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_GOTPLT32
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPLT_MEDLOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOT_MEDLOW16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_PLT_MEDLOW16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SH_IMM_MEDHI16
case|:
switch|switch
condition|(
name|exp
operator|->
name|X_md
condition|)
block|{
case|case
name|BFD_RELOC_32_GOTOFF
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTOFF_MEDHI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_GOTPLT32
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPLT_MEDHI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOT_MEDHI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_PLT_MEDHI16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SH_IMM_HI16
case|:
switch|switch
condition|(
name|exp
operator|->
name|X_md
condition|)
block|{
case|case
name|BFD_RELOC_32_GOTOFF
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTOFF_HI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_GOTPLT32
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOTPLT_HI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_GOT_HI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
operator|*
name|r_type_p
operator|=
name|BFD_RELOC_SH_PLT_HI16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|r_type_p
operator|=
name|exp
operator|->
name|X_md
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exp
operator|==
name|main_exp
condition|)
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
else|else
block|{
name|main_exp
operator|->
name|X_add_symbol
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|main_exp
operator|->
name|X_add_number
operator|+=
name|exp
operator|->
name|X_add_number
expr_stmt|;
block|}
block|}
else|else
return|return
operator|(
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|sh_PIC_related_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add expression EXP of SIZE bytes to offset OFF of fragment FRAG.  */
end_comment

begin_function
name|void
name|sh_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|off
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|off
decl_stmt|,
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|r_type
init|=
name|BFD_RELOC_UNUSED
decl_stmt|;
if|if
condition|(
name|sh_check_fixup
argument_list|(
name|exp
argument_list|,
operator|&
name|r_type
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid PIC expression."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_UNUSED
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|r_type
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r_type
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SH64
case|case
literal|8
case|:
name|r_type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|error
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported BFD relocation size %u"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The regular cons() function, that reads constants, doesn't support    suffixes such as @GOT, @GOTOFF and @PLT, that generate    machine-specific relocation types.  So we must define it here.  */
end_comment

begin_comment
comment|/* Clobbers input_line_pointer, checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|sh_elf_cons
parameter_list|(
name|nbytes
parameter_list|)
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
block|{
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SH64
comment|/* Update existing range to include a previous insn, if there was one.  */
name|sh64_update_contents_mark
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* We need to make sure the contents type is set to data.  */
name|sh64_flag_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SH64 */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'!'
condition|)
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
operator|++
index|]
condition|)
empty_stmt|;
block|}
else|else
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|int
name|target_arch
decl_stmt|;
name|target_arch
operator|=
name|arch_sh1_up
operator|&
operator|~
operator|(
name|sh_dsp
condition|?
name|arch_sh3e_up
else|:
name|arch_sh_dsp_up
operator|)
expr_stmt|;
name|valid_arch
operator|=
name|target_arch
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SH64
name|shmedia_md_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  */
for|for
control|(
name|opcode
operator|=
name|sh_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|arch
operator|&
name|target_arch
operator|)
condition|)
continue|continue;
name|prev_name
operator|=
name|opcode
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make all the opcodes with the same name point to the same 	     string.  */
name|opcode
operator|->
name|name
operator|=
name|prev_name
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|reg_m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_x
decl_stmt|,
name|reg_y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_efg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_b
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IDENT_CHAR
parameter_list|(
name|c
parameter_list|)
value|(ISALNUM (c) || (c) == '_')
end_define

begin_comment
comment|/* Try to parse a reg name.  Return the number of chars consumed.  */
end_comment

begin_function
specifier|static
name|int
name|parse_reg
parameter_list|(
name|src
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|int
modifier|*
name|mode
decl_stmt|;
name|int
modifier|*
name|reg
decl_stmt|;
block|{
name|char
name|l0
init|=
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|char
name|l1
init|=
name|l0
condition|?
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* We use ! IDENT_CHAR for the next character after the register name, to      make sure that we won't accidentally recognize a symbol name such as      'sram' or sr_ram as being a reference to the register 'sr'.  */
if|if
condition|(
name|l0
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|l1
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'5'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|+
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l1
operator|>=
literal|'0'
operator|&&
name|l1
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|l1
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l1
operator|>=
literal|'0'
operator|&&
name|l1
operator|<=
literal|'7'
operator|&&
name|strncasecmp
argument_list|(
operator|&
name|src
index|[
literal|2
index|]
argument_list|,
literal|"_bank"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_B
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|l1
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|7
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'e'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_RE
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'s'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_RS
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|l1
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_A0_NUM
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_A0G_NUM
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l1
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_A1_NUM
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_A1G_NUM
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l1
operator|==
literal|'x'
operator|&&
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'1'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|4
operator|+
operator|(
name|l1
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'y'
operator|&&
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'1'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|6
operator|+
operator|(
name|l1
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'3'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|l1
operator|-
literal|'0'
decl_stmt|;
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|n
operator||
operator|(
operator|(
operator|~
name|n
operator|&
literal|2
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'i'
operator|&&
name|l1
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|l1
operator|==
literal|'s'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|8
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'x'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|8
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l1
operator|==
literal|'y'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|9
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'x'
operator|&&
name|l1
operator|>=
literal|'0'
operator|&&
name|l1
operator|<=
literal|'1'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_X0_NUM
operator|+
name|l1
operator|-
literal|'0'
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'y'
operator|&&
name|l1
operator|>=
literal|'0'
operator|&&
name|l1
operator|<=
literal|'1'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|A_Y0_NUM
operator|+
name|l1
operator|-
literal|'0'
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'m'
operator|&&
name|l1
operator|>=
literal|'0'
operator|&&
name|l1
operator|<=
literal|'1'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|DSP_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
name|l1
operator|==
literal|'0'
condition|?
name|A_M0_NUM
else|:
name|A_M1_NUM
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'s'
operator|&&
name|l1
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SSR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'s'
operator|&&
name|l1
operator|==
literal|'p'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SPC
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'s'
operator|&&
name|l1
operator|==
literal|'g'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SGR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'d'
operator|&&
name|l1
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DSR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'d'
operator|&&
name|l1
operator|==
literal|'b'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_DBR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'s'
operator|&&
name|l1
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_SR
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'s'
operator|&&
name|l1
operator|==
literal|'p'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|15
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'p'
operator|&&
name|l1
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_PR
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'p'
operator|&&
name|l1
operator|==
literal|'c'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* Don't use A_DISP_PC here - that would accept stuff like 'mova pc,r0'          and use an uninitialized immediate.  */
operator|*
name|mode
operator|=
name|A_PC
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'g'
operator|&&
name|l1
operator|==
literal|'b'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_GBR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'v'
operator|&&
name|l1
operator|==
literal|'b'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_VBR
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'m'
operator|&&
name|l1
operator|==
literal|'a'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'l'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_MACL
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'h'
condition|)
block|{
operator|*
name|mode
operator|=
name|A_MACH
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'m'
operator|&&
name|l1
operator|==
literal|'o'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'d'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|A_MOD
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'5'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|F_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|F_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'d'
operator|&&
name|l1
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'4'
operator|&&
operator|!
operator|(
operator|(
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|&
literal|1
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|D_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|10
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'8'
operator|&&
operator|!
operator|(
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|&
literal|1
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|D_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'x'
operator|&&
name|l1
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|3
index|]
operator|<=
literal|'4'
operator|&&
operator|!
operator|(
operator|(
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|&
literal|1
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|X_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|11
operator|+
name|src
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
literal|4
return|;
block|}
block|}
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|src
index|[
literal|2
index|]
operator|<=
literal|'8'
operator|&&
operator|!
operator|(
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|&
literal|1
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|X_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
literal|1
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'v'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'1'
operator|&&
name|src
index|[
literal|3
index|]
operator|==
literal|'2'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|V_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
literal|12
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|(
name|src
index|[
literal|2
index|]
operator|==
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|==
literal|'4'
operator|||
name|src
index|[
literal|2
index|]
operator|==
literal|'8'
operator|)
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|V_REG_N
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'p'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'u'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'l'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|FPUL_N
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'f'
operator|&&
name|l1
operator|==
literal|'p'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'s'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'c'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|FPSCR_N
expr_stmt|;
return|return
literal|5
return|;
block|}
if|if
condition|(
name|l0
operator|==
literal|'x'
operator|&&
name|l1
operator|==
literal|'m'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'t'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|TOLOWER
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
operator|==
literal|'x'
operator|&&
operator|!
name|IDENT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
operator|*
name|mode
operator|=
name|XMTRX_M4
expr_stmt|;
return|return
literal|5
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_exp
parameter_list|(
name|s
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|op
operator|->
name|immediate
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|immediate
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|op
operator|->
name|immediate
operator|.
name|X_op
operator|==
name|O_PIC_reloc
operator|||
name|sh_PIC_related_p
argument_list|(
name|op
operator|->
name|immediate
operator|.
name|X_add_symbol
argument_list|)
operator|||
name|sh_PIC_related_p
argument_list|(
name|op
operator|->
name|immediate
operator|.
name|X_op_symbol
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"misplaced PIC operand"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* The many forms of operand:     Rn                   Register direct    @Rn                  Register indirect    @Rn+                 Autoincrement    @-Rn                 Autodecrement    @(disp:4,Rn)    @(disp:8,GBR)    @(disp:8,PC)     @(R0,Rn)    @(R0,GBR)     disp:8    disp:12    #imm8    pr, gbr, vbr, macl, mach  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_at
parameter_list|(
name|src
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Must be predecrement.  */
name|src
operator|++
expr_stmt|;
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|A_REG_N
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal register after @-"
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_DEC_N
expr_stmt|;
name|src
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* Could be @(disp, rn), @(disp, gbr), @(disp, pc),  @(r0, gbr) or          @(r0, rn).  */
name|src
operator|++
expr_stmt|;
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|reg
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"must be @(r0,...)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* Now can be rn or gbr.  */
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|A_GBR
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_R0_GBR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_IND_R0_REG_N
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in @(r0,...)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in @(r0...)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Must be an @(disp,.. thing).  */
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|src
operator|++
expr_stmt|;
comment|/* Now can be rn, gbr or pc.  */
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|op
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|A_REG_N
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_REG_N
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_GBR
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_GBR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|A_PC
condition|)
block|{
comment|/* We want @(expr, pc) to uniformly address . + expr, 		     no matter if expr is a constant, or a more complex 		     expression, e.g. sym-. or sym1-sym2. 		     However, we also used to accept @(sym,pc) 		     as adressing sym, i.e. meaning the same as plain sym. 		     Some existing code does use the @(sym,pc) syntax, so 		     we give it the old semantics for now, but warn about 		     its use, so that users have some time to fix their code.  		     Note that due to this backward compatibility hack, 		     we'll get unexpected results when @(offset, pc) is used, 		     and offset is a symbol that is set later to an an address 		     difference, or an external symbol that is set to an 		     address difference in another source file, so we want to 		     eventually remove it.  */
if|if
condition|(
name|op
operator|->
name|immediate
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_PC
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Deprecated syntax."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|->
name|type
operator|=
name|A_DISP_PC_ABS
expr_stmt|;
comment|/* Such operands don't get corrected for PC==.+4, so 			 make the correction here.  */
name|op
operator|->
name|immediate
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in @(disp,[Rn, gbr, pc])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error in @(disp,[Rn, gbr, pc])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|src
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting )"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
name|src
operator|+=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|A_REG_N
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal register after @"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|char
name|l0
decl_stmt|,
name|l1
decl_stmt|;
name|src
operator|++
expr_stmt|;
name|l0
operator|=
name|TOLOWER
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TOLOWER
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l0
operator|==
literal|'r'
operator|&&
name|l1
operator|==
literal|'8'
operator|)
operator|||
operator|(
name|l0
operator|==
literal|'i'
operator|&&
operator|(
name|l1
operator|==
literal|'x'
operator|||
name|l1
operator|==
literal|'s'
operator|)
operator|)
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_PMOD_N
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|l0
operator|==
literal|'r'
operator|&&
name|l1
operator|==
literal|'9'
operator|)
operator|||
operator|(
name|l0
operator|==
literal|'i'
operator|&&
name|l1
operator|==
literal|'y'
operator|)
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_PMODY_N
expr_stmt|;
block|}
else|else
name|op
operator|->
name|type
operator|=
name|A_INC_N
expr_stmt|;
block|}
else|else
name|op
operator|->
name|type
operator|=
name|A_IND_N
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_operand
parameter_list|(
name|ptr
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|mode
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|src
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_IMM
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
operator|*
name|ptr
operator|=
name|parse_at
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
operator|(
name|op
operator|->
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
operator|*
name|ptr
operator|=
name|src
operator|+
name|len
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|mode
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Not a reg, the only thing left is a displacement.  */
operator|*
name|ptr
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|->
name|type
operator|=
name|A_DISP_PC
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
name|info
parameter_list|,
name|args
parameter_list|,
name|operand
parameter_list|)
name|sh_opcode_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|sh_operand_info
modifier|*
name|operand
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
name|args
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|0
index|]
condition|)
block|{
comment|/* The pre-processor will eliminate whitespace in front of '@' 	 after the first argument; we may be called multiple times 	 from assemble_ppi, so don't insist on finding whitespace here.  */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? Hack: psha/pshl have a varying operand number depending on 	     the type of the first operand.  We handle this by having the 	     three-operand version first and reducing the number of operands 	     parsed to two if we see that the first operand is an immediate.              This works because no insn with three operands has an immediate 	     as first operand.  */
if|if
condition|(
name|info
operator|->
name|arg
index|[
literal|2
index|]
operator|&&
name|operand
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|A_IMM
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|operand
index|[
literal|1
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|operand
index|[
literal|0
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|2
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Passed a pointer to a list of opcodes which use different    addressing modes, return the opcode which matches the opcodes    provided.  */
end_comment

begin_function
specifier|static
name|sh_opcode_info
modifier|*
name|get_specific
parameter_list|(
name|opcode
parameter_list|,
name|operands
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|sh_operand_info
modifier|*
name|operands
decl_stmt|;
block|{
name|sh_opcode_info
modifier|*
name|this_try
init|=
name|opcode
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|opcode
operator|->
name|name
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|opcode
operator|->
name|name
condition|)
block|{
name|this_try
operator|=
name|opcode
operator|++
expr_stmt|;
if|if
condition|(
name|this_try
operator|->
name|name
operator|!=
name|name
condition|)
block|{
comment|/* We've looked so far down the table that we've run out of 	     opcodes with the same name.  */
return|return
literal|0
return|;
block|}
comment|/* Look at both operands needed by the opcodes and provided by          the user - since an arg test will often fail on the same arg          again and again, we'll try and test the last failing arg the          first on each opcode try.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|this_try
operator|->
name|arg
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|sh_operand_info
modifier|*
name|user
init|=
name|operands
operator|+
name|n
decl_stmt|;
name|sh_arg_type
name|arg
init|=
name|this_try
operator|->
name|arg
index|[
name|n
index|]
decl_stmt|;
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|A_DISP_PC
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|==
name|A_DISP_PC_ABS
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|A_IMM
case|:
case|case
name|A_BDISP12
case|:
case|case
name|A_BDISP8
case|:
case|case
name|A_DISP_GBR
case|:
case|case
name|A_MACH
case|:
case|case
name|A_PR
case|:
case|case
name|A_MACL
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_R0
case|:
comment|/* opcode needs r0 */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|A_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_R0_GBR
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|A_R0_GBR
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|F_FR0
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|F_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_REG_N
case|:
case|case
name|A_INC_N
case|:
case|case
name|A_DEC_N
case|:
case|case
name|A_IND_N
case|:
case|case
name|A_IND_R0_REG_N
case|:
case|case
name|A_DISP_REG_N
case|:
case|case
name|F_REG_N
case|:
case|case
name|D_REG_N
case|:
case|case
name|X_REG_N
case|:
case|case
name|V_REG_N
case|:
case|case
name|FPUL_N
case|:
case|case
name|FPSCR_N
case|:
case|case
name|A_PMOD_N
case|:
case|case
name|A_PMODY_N
case|:
case|case
name|DSP_REG_N
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
name|reg_n
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|DX_REG_N
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|D_REG_N
operator|&&
name|user
operator|->
name|type
operator|!=
name|X_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_n
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|A_GBR
case|:
case|case
name|A_SR
case|:
case|case
name|A_VBR
case|:
case|case
name|A_DSR
case|:
case|case
name|A_MOD
case|:
case|case
name|A_RE
case|:
case|case
name|A_RS
case|:
case|case
name|A_SSR
case|:
case|case
name|A_SPC
case|:
case|case
name|A_SGR
case|:
case|case
name|A_DBR
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_REG_B
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
condition|)
goto|goto
name|fail
goto|;
name|reg_b
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|A_REG_M
case|:
case|case
name|A_INC_M
case|:
case|case
name|A_DEC_M
case|:
case|case
name|A_IND_M
case|:
case|case
name|A_IND_R0_REG_M
case|:
case|case
name|A_DISP_REG_M
case|:
case|case
name|DSP_REG_M
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
operator|-
name|A_REG_M
operator|+
name|A_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|DSP_REG_X
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|user
operator|->
name|reg
condition|)
block|{
case|case
name|A_X0_NUM
case|:
name|reg_x
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|A_X1_NUM
case|:
name|reg_x
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|A_A0_NUM
case|:
name|reg_x
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|A_A1_NUM
case|:
name|reg_x
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|DSP_REG_Y
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|user
operator|->
name|reg
condition|)
block|{
case|case
name|A_Y0_NUM
case|:
name|reg_y
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|A_Y1_NUM
case|:
name|reg_y
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|A_M0_NUM
case|:
name|reg_y
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|A_M1_NUM
case|:
name|reg_y
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|DSP_REG_E
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|user
operator|->
name|reg
condition|)
block|{
case|case
name|A_X0_NUM
case|:
name|reg_efg
operator|=
literal|0
operator|<<
literal|10
expr_stmt|;
break|break;
case|case
name|A_X1_NUM
case|:
name|reg_efg
operator|=
literal|1
operator|<<
literal|10
expr_stmt|;
break|break;
case|case
name|A_Y0_NUM
case|:
name|reg_efg
operator|=
literal|2
operator|<<
literal|10
expr_stmt|;
break|break;
case|case
name|A_A1_NUM
case|:
name|reg_efg
operator|=
literal|3
operator|<<
literal|10
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|DSP_REG_F
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|user
operator|->
name|reg
condition|)
block|{
case|case
name|A_Y0_NUM
case|:
name|reg_efg
operator||=
literal|0
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
name|A_Y1_NUM
case|:
name|reg_efg
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
name|A_X0_NUM
case|:
name|reg_efg
operator||=
literal|2
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
name|A_A1_NUM
case|:
name|reg_efg
operator||=
literal|3
operator|<<
literal|8
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|DSP_REG_G
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|user
operator|->
name|reg
condition|)
block|{
case|case
name|A_M0_NUM
case|:
name|reg_efg
operator||=
literal|0
operator|<<
literal|2
expr_stmt|;
break|break;
case|case
name|A_M1_NUM
case|:
name|reg_efg
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
break|break;
case|case
name|A_A0_NUM
case|:
name|reg_efg
operator||=
literal|2
operator|<<
literal|2
expr_stmt|;
break|break;
case|case
name|A_A1_NUM
case|:
name|reg_efg
operator||=
literal|3
operator|<<
literal|2
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|A_A0
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
name|A_A0_NUM
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_X0
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
name|A_X0_NUM
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_X1
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
name|A_X1_NUM
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_Y0
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
name|A_Y0_NUM
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|A_Y1
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|DSP_REG_N
operator|||
name|user
operator|->
name|reg
operator|!=
name|A_Y1_NUM
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|F_REG_M
case|:
case|case
name|D_REG_M
case|:
case|case
name|X_REG_M
case|:
case|case
name|V_REG_M
case|:
case|case
name|FPUL_M
case|:
case|case
name|FPSCR_M
case|:
comment|/* Opcode needs rn */
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|arg
operator|-
name|F_REG_M
operator|+
name|F_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|DX_REG_M
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|D_REG_N
operator|&&
name|user
operator|->
name|type
operator|!=
name|X_REG_N
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
name|user
operator|->
name|reg
expr_stmt|;
break|break;
case|case
name|XMTRX_M4
case|:
if|if
condition|(
name|user
operator|->
name|type
operator|!=
name|XMTRX_M4
condition|)
goto|goto
name|fail
goto|;
name|reg_m
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"unhandled %d\n"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|valid_arch
operator|&
name|this_try
operator|->
name|arch
operator|)
condition|)
goto|goto
name|fail
goto|;
name|valid_arch
operator|&=
name|this_try
operator|->
name|arch
expr_stmt|;
return|return
name|this_try
return|;
name|fail
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|where
parameter_list|,
name|how
parameter_list|,
name|pcrel
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|int
name|how
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|op
operator|->
name|immediate
argument_list|,
name|pcrel
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_relax
parameter_list|(
name|opcode
parameter_list|,
name|op
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|sh_operand_info
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|high_byte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP8
condition|)
block|{
name|int
name|what
init|=
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|1
index|]
operator|&
literal|4
operator|)
condition|?
name|COND_JUMP_DELAY
else|:
name|COND_JUMP
decl_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|COND32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|what
argument_list|,
name|COND8
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|what
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op
operator|->
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|op
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|high_byte
index|]
operator|=
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP12
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|md_relax_table
index|[
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
index|]
operator|.
name|rlx_length
argument_list|,
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op
operator|->
name|immediate
operator|.
name|X_add_symbol
argument_list|,
name|op
operator|->
name|immediate
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|high_byte
index|]
operator|=
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert ldrs& ldre with fancy relocations that relaxation can recognize.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|insert_loop_bounds
parameter_list|(
name|output
parameter_list|,
name|operand
parameter_list|)
name|char
modifier|*
name|output
decl_stmt|;
name|sh_operand_info
modifier|*
name|operand
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|end_sym
decl_stmt|;
comment|/* Since the low byte of the opcode will be overwritten by the reloc, we      can just stash the high byte into both bytes and ignore endianness.  */
name|output
index|[
literal|0
index|]
operator|=
literal|0x8c
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
literal|0x8c
expr_stmt|;
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_LOOP_START
argument_list|,
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_LOOP_END
argument_list|,
literal|1
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh_relax
condition|)
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* If the last loop insn is a two-byte-insn, it is in danger of being 	 swapped with the insn after it.  To prevent this, create a new 	 symbol - complete with SH_LABEL reloc - after the last loop insn. 	 If the last loop insn is four bytes long, the symbol will be 	 right in the middle, but four byte insns are not swapped anyways.  */
comment|/* A REPEAT takes 6 bytes.  The SH has a 32 bit address space. 	 Hence a 9 digit number should be enough to count all REPEATs.  */
name|name
operator|=
name|alloca
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"_R%x"
argument_list|,
name|count
operator|++
operator|&
literal|0x3fffffff
argument_list|)
expr_stmt|;
name|end_sym
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Make this a local symbol.  */
ifdef|#
directive|ifdef
name|OBJ_COFF
name|SF_SET_LOCAL
argument_list|(
name|end_sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
name|symbol_table_insert
argument_list|(
name|end_sym
argument_list|)
expr_stmt|;
name|end_sym
operator|->
name|sy_value
operator|=
name|operand
index|[
literal|1
index|]
operator|.
name|immediate
expr_stmt|;
name|end_sym
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+=
literal|2
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
name|end_sym
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_LABEL
argument_list|)
expr_stmt|;
block|}
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
literal|0x8e
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
literal|0x8e
expr_stmt|;
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_LOOP_START
argument_list|,
literal|1
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_LOOP_END
argument_list|,
literal|1
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|frag_more
argument_list|(
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now we know what sort of opcodes it is, let's build the bytes.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|build_Mytes
parameter_list|(
name|opcode
parameter_list|,
name|operand
parameter_list|)
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|sh_operand_info
modifier|*
name|operand
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|2
decl_stmt|;
name|int
name|low_byte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|nbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|nbuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|4
condition|;
name|index
operator|++
control|)
block|{
name|sh_nibble_type
name|i
init|=
name|opcode
operator|->
name|nibbles
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
name|nbuf
index|[
name|index
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|REG_N
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_n
expr_stmt|;
break|break;
case|case
name|REG_M
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_m
expr_stmt|;
break|break;
case|case
name|SDT_REG_N
case|:
if|if
condition|(
name|reg_n
operator|<
literal|2
operator|||
name|reg_n
operator|>
literal|5
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register: 'r%d'"
argument_list|)
argument_list|,
name|reg_n
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|index
index|]
operator|=
operator|(
name|reg_n
operator|&
literal|3
operator|)
operator||
literal|4
expr_stmt|;
break|break;
case|case
name|REG_NM
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_n
operator||
operator|(
name|reg_m
operator|>>
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|REG_B
case|:
name|nbuf
index|[
name|index
index|]
operator|=
name|reg_b
operator||
literal|0x08
expr_stmt|;
break|break;
case|case
name|IMM0_4BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY4
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM0_4BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY2
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM0_4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_4BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY4
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_4BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4BY2
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM4
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM0_8BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY4
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM0_8BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY2
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM0_8
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_8BY4
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY4
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_8BY2
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8BY2
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM1_8
case|:
name|insert
argument_list|(
name|output
operator|+
name|low_byte
argument_list|,
name|BFD_RELOC_SH_IMM8
argument_list|,
literal|0
argument_list|,
name|operand
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCRELIMM_8BY4
case|:
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_PCRELIMM8BY4
argument_list|,
name|operand
operator|->
name|type
operator|!=
name|A_DISP_PC_ABS
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCRELIMM_8BY2
case|:
name|insert
argument_list|(
name|output
argument_list|,
name|BFD_RELOC_SH_PCRELIMM8BY2
argument_list|,
name|operand
operator|->
name|type
operator|!=
name|A_DISP_PC_ABS
argument_list|,
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPEAT
case|:
name|output
operator|=
name|insert_loop_bounds
argument_list|(
name|output
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|index
index|]
operator|=
name|opcode
operator|->
name|nibbles
index|[
literal|3
index|]
expr_stmt|;
name|operand
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"failed for %d\n"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|output
index|[
literal|1
index|]
operator|=
operator|(
name|nbuf
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|nbuf
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|nbuf
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
operator|(
name|nbuf
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Find an opcode at the start of *STR_P in the hash table, and set    *STR_P to the first character after the last one read.  */
end_comment

begin_function
specifier|static
name|sh_opcode_info
modifier|*
name|find_cooked_opcode
parameter_list|(
name|str_p
parameter_list|)
name|char
modifier|*
modifier|*
name|str_p
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_end
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.      The pre-processor will eliminate whitespace in front of      any '@' after the first argument; we may be called from      assemble_ppi, so the opcode might be terminated by an '@'.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|)
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
literal|20
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
operator|&&
operator|*
name|op_end
operator|!=
literal|'@'
condition|;
name|op_end
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
name|op_start
index|[
name|nlen
index|]
decl_stmt|;
comment|/* The machine independent code will convert CMP/EQ into cmp/EQ 	 because it thinks the '/' is the end of the symbol.  Moreover, 	 all but the first sub-insn is a parallel processing insn won't 	 be capitalized.  Instead of hacking up the machine independent 	 code, we just deal with it here.  */
name|c
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|name
index|[
name|nlen
index|]
operator|=
name|c
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str_p
operator|=
name|op_end
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sh_opcode_info
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assemble a parallel processing insn.  */
end_comment

begin_define
define|#
directive|define
name|DDT_BASE
value|0xf000
end_define

begin_comment
comment|/* Base value for double data transfer insns */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|assemble_ppi
parameter_list|(
name|op_end
parameter_list|,
name|opcode
parameter_list|)
name|char
modifier|*
name|op_end
decl_stmt|;
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
block|{
name|int
name|movx
init|=
literal|0
decl_stmt|;
name|int
name|movy
init|=
literal|0
decl_stmt|;
name|int
name|cond
init|=
literal|0
decl_stmt|;
name|int
name|field_b
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|move_code
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sh_operand_info
name|operand
index|[
literal|3
index|]
decl_stmt|;
comment|/* Some insn ignore one or more register fields, e.g. psts machl,a0. 	 Make sure we encode a defined insn pattern.  */
name|reg_x
operator|=
literal|0
expr_stmt|;
name|reg_y
operator|=
literal|0
expr_stmt|;
name|reg_n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|!=
name|A_END
condition|)
name|op_end
operator|=
name|get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|get_specific
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands.  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands for opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
if|if
condition|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|!=
name|PPI
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"insn can't be combined with parallel processing insn"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|nibbles
index|[
literal|1
index|]
condition|)
block|{
case|case
name|NOPX
case|:
if|if
condition|(
name|movx
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple movx specifications"
argument_list|)
argument_list|)
expr_stmt|;
name|movx
operator|=
name|DDT_BASE
expr_stmt|;
break|break;
case|case
name|NOPY
case|:
if|if
condition|(
name|movy
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple movy specifications"
argument_list|)
argument_list|)
expr_stmt|;
name|movy
operator|=
name|DDT_BASE
expr_stmt|;
break|break;
case|case
name|MOVX
case|:
if|if
condition|(
name|movx
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple movx specifications"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n
operator|<
literal|4
operator|||
name|reg_n
operator|>
literal|5
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movx address register"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|&
literal|8
condition|)
block|{
if|if
condition|(
name|reg_m
operator|==
name|A_A1_NUM
condition|)
name|movx
operator|=
literal|1
operator|<<
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_m
operator|!=
name|A_A0_NUM
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movx dsp register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_x
operator|>
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movx dsp register"
argument_list|)
argument_list|)
expr_stmt|;
name|movx
operator|=
name|reg_x
operator|<<
literal|7
expr_stmt|;
block|}
name|movx
operator|+=
operator|(
operator|(
name|reg_n
operator|-
literal|4
operator|)
operator|<<
literal|9
operator|)
operator|+
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|<<
literal|2
operator|)
operator|+
name|DDT_BASE
expr_stmt|;
break|break;
case|case
name|MOVY
case|:
if|if
condition|(
name|movy
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple movy specifications"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|&
literal|8
condition|)
block|{
comment|/* Bit 3 in nibbles[2] is intended for bit 4 of the opcode, 		 so add 8 more.  */
name|movy
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|reg_m
operator|==
name|A_A1_NUM
condition|)
name|movy
operator|+=
literal|1
operator|<<
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_m
operator|!=
name|A_A0_NUM
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movy dsp register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_y
operator|>
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movy dsp register"
argument_list|)
argument_list|)
expr_stmt|;
name|movy
operator|=
name|reg_y
operator|<<
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|reg_n
operator|<
literal|6
operator|||
name|reg_n
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid movy address register"
argument_list|)
argument_list|)
expr_stmt|;
name|movy
operator|+=
operator|(
operator|(
name|reg_n
operator|-
literal|6
operator|)
operator|<<
literal|8
operator|)
operator|+
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|+
name|DDT_BASE
expr_stmt|;
break|break;
case|case
name|PSH
case|:
if|if
condition|(
name|operand
index|[
literal|0
index|]
operator|.
name|immediate
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"dsp immediate shift value not constant"
argument_list|)
argument_list|)
expr_stmt|;
name|field_b
operator|=
operator|(
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|operand
index|[
literal|0
index|]
operator|.
name|immediate
operator|.
name|X_add_number
operator|&
literal|127
operator|)
operator|<<
literal|4
operator||
name|reg_n
operator|)
expr_stmt|;
break|break;
case|case
name|PPI3
case|:
if|if
condition|(
name|field_b
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple parallel processing specifications"
argument_list|)
argument_list|)
expr_stmt|;
name|field_b
operator|=
operator|(
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|<<
literal|12
operator|)
operator|+
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|reg_x
operator|<<
literal|6
operator|)
operator|+
operator|(
name|reg_y
operator|<<
literal|4
operator|)
operator|+
name|reg_n
operator|)
expr_stmt|;
break|break;
case|case
name|PDC
case|:
if|if
condition|(
name|cond
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple condition specifications"
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|*
name|op_end
condition|)
goto|goto
name|skip_cond_check
goto|;
break|break;
case|case
name|PPIC
case|:
if|if
condition|(
name|field_b
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"multiple parallel processing specifications"
argument_list|)
argument_list|)
expr_stmt|;
name|field_b
operator|=
operator|(
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|2
index|]
operator|<<
literal|12
operator|)
operator|+
operator|(
name|opcode
operator|->
name|nibbles
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
name|cond
operator|+
operator|(
name|reg_x
operator|<<
literal|6
operator|)
operator|+
operator|(
name|reg_y
operator|<<
literal|4
operator|)
operator|+
name|reg_n
operator|)
expr_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PMUL
case|:
if|if
condition|(
name|field_b
condition|)
block|{
if|if
condition|(
operator|(
name|field_b
operator|&
literal|0xef00
operator|)
operator|!=
literal|0xa100
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"insn cannot be combined with pmuls"
argument_list|)
argument_list|)
expr_stmt|;
name|field_b
operator|-=
literal|0x8100
expr_stmt|;
switch|switch
condition|(
name|field_b
operator|&
literal|0xf
condition|)
block|{
case|case
name|A_X0_NUM
case|:
name|field_b
operator|+=
literal|0
operator|-
name|A_X0_NUM
expr_stmt|;
break|break;
case|case
name|A_Y0_NUM
case|:
name|field_b
operator|+=
literal|1
operator|-
name|A_Y0_NUM
expr_stmt|;
break|break;
case|case
name|A_A0_NUM
case|:
name|field_b
operator|+=
literal|2
operator|-
name|A_A0_NUM
expr_stmt|;
break|break;
case|case
name|A_A1_NUM
case|:
name|field_b
operator|+=
literal|3
operator|-
name|A_A1_NUM
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad padd / psub pmuls output operand"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate warning if the destination register for padd / psub 		   and pmuls is the same ( only for A0 or A1 ). 		   If the last nibble is 1010 then A0 is used in both 		   padd / psub and pmuls. If it is 1111 then A1 is used 		   as destination register in both padd / psub and pmuls.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|field_b
operator||
name|reg_efg
operator|)
operator|&
literal|0x000F
operator|)
operator|==
literal|0x000A
operator|)
operator|||
operator|(
operator|(
operator|(
name|field_b
operator||
name|reg_efg
operator|)
operator|&
literal|0x000F
operator|)
operator|==
literal|0x000F
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"destination register is same for parallel insns"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|field_b
operator|+=
literal|0x4000
operator|+
name|reg_efg
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cond
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"condition not followed by conditionalizable insn"
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|op_end
condition|)
break|break;
name|skip_cond_check
label|:
name|opcode
operator|=
name|find_cooked_opcode
argument_list|(
operator|&
name|op_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
operator|(
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized characters at end of parallel processing insn"
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|move_code
operator|=
name|movx
operator||
name|movy
expr_stmt|;
if|if
condition|(
name|field_b
condition|)
block|{
comment|/* Parallel processing insn.  */
name|unsigned
name|long
name|ppi_code
init|=
operator|(
name|movx
operator||
name|movy
operator||
literal|0xf800
operator|)
operator|<<
literal|16
operator||
name|field_b
decl_stmt|;
name|output
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|output
index|[
literal|3
index|]
operator|=
name|ppi_code
operator|>>
literal|8
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
name|ppi_code
expr_stmt|;
block|}
else|else
block|{
name|output
index|[
literal|2
index|]
operator|=
name|ppi_code
operator|>>
literal|8
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|=
name|ppi_code
expr_stmt|;
block|}
name|move_code
operator||=
literal|0xf800
expr_stmt|;
block|}
else|else
block|{
comment|/* Just a double data transfer.  */
name|output
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|output
index|[
literal|1
index|]
operator|=
name|move_code
operator|>>
literal|8
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|move_code
expr_stmt|;
block|}
else|else
block|{
name|output
index|[
literal|0
index|]
operator|=
name|move_code
operator|>>
literal|8
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|move_code
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|op_end
decl_stmt|;
name|sh_operand_info
name|operand
index|[
literal|3
index|]
decl_stmt|;
name|sh_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SH64
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
condition|)
block|{
name|shmedia_md_assemble
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* If we've seen pseudo-directives, make sure any emitted data or 	 frags are marked as data.  */
if|if
condition|(
name|seen_insn
operator|==
name|false
condition|)
block|{
name|sh64_update_contents_mark
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|sh64_set_contents_type
argument_list|(
name|CRT_SH5_ISA16
argument_list|)
expr_stmt|;
block|}
name|seen_insn
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_SH64 */
name|opcode
operator|=
name|find_cooked_opcode
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|op_end
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sh_relax
operator|&&
operator|!
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
comment|/* Output a CODE reloc to tell the linker that the following          bytes are instructions, not data.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_CODE
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|->
name|nibbles
index|[
literal|0
index|]
operator|==
name|PPI
condition|)
block|{
name|size
operator|=
name|assemble_ppi
argument_list|(
name|op_end
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP12
operator|||
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_BDISP8
condition|)
block|{
name|parse_exp
argument_list|(
name|op_end
operator|+
literal|1
argument_list|,
operator|&
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|build_relax
argument_list|(
name|opcode
argument_list|,
operator|&
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|->
name|arg
index|[
literal|0
index|]
operator|==
name|A_END
condition|)
block|{
comment|/* Ignore trailing whitespace.  If there is any, it has already 		 been compressed to a single space.  */
if|if
condition|(
operator|*
name|op_end
operator|==
literal|' '
condition|)
name|op_end
operator|++
expr_stmt|;
block|}
else|else
block|{
name|op_end
operator|=
name|get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|get_specific
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands.  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|size
operator|=
literal|2
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operands for opcode"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|op_end
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"excess operands: '%s'"
argument_list|)
argument_list|,
name|op_end
argument_list|)
expr_stmt|;
name|size
operator|=
name|build_Mytes
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|dwarf2_emit_insn
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This routine is called each time a label definition is seen.  It    emits a BFD_RELOC_SH_LABEL reloc if necessary.  */
end_comment

begin_function
name|void
name|sh_frob_label
parameter_list|()
block|{
specifier|static
name|fragS
modifier|*
name|last_label_frag
decl_stmt|;
specifier|static
name|int
name|last_label_offset
decl_stmt|;
if|if
condition|(
name|sh_relax
operator|&&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
if|if
condition|(
name|frag_now
operator|!=
name|last_label_frag
operator|||
name|offset
operator|!=
name|last_label_offset
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_LABEL
argument_list|)
expr_stmt|;
name|last_label_frag
operator|=
name|frag_now
expr_stmt|;
name|last_label_offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine is called when the assembler is about to output some    data.  It emits a BFD_RELOC_SH_DATA reloc if necessary.  */
end_comment

begin_function
name|void
name|sh_flush_pending_output
parameter_list|()
block|{
if|if
condition|(
name|sh_relax
operator|&&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_DATA
argument_list|)
expr_stmt|;
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|in_code
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|tc_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_crawl_symbol_chain \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_headers_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_headers_hook \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various routines to kill one day.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP .  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Handle the .uses pseudo-op.  This pseudo-op is used just before a    call instruction.  It refers to a label of the instruction which    loads the register which the call uses.  We use it to generate a    special reloc for the linker.  */
end_comment

begin_function
specifier|static
name|void
name|s_uses
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|ex
decl_stmt|;
if|if
condition|(
operator|!
name|sh_relax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".uses pseudo-op seen when not relaxing"
argument_list|)
argument_list|)
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .uses format"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|2
argument_list|,
operator|&
name|ex
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_USES
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_BIG
value|(OPTION_MD_BASE + 1)
define|#
directive|define
name|OPTION_LITTLE
value|(OPTION_BIG + 1)
define|#
directive|define
name|OPTION_SMALL
value|(OPTION_LITTLE + 1)
define|#
directive|define
name|OPTION_DSP
value|(OPTION_SMALL + 1)
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
block|{
literal|"big"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG
block|}
block|,
block|{
literal|"little"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE
block|}
block|,
block|{
literal|"small"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SMALL
block|}
block|,
block|{
literal|"dsp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DSP
block|}
block|,
ifdef|#
directive|ifdef
name|HAVE_SH64
define|#
directive|define
name|OPTION_ISA
value|(OPTION_DSP + 1)
define|#
directive|define
name|OPTION_ABI
value|(OPTION_ISA + 1)
define|#
directive|define
name|OPTION_NO_MIX
value|(OPTION_ABI + 1)
define|#
directive|define
name|OPTION_SHCOMPACT_CONST_CRANGE
value|(OPTION_NO_MIX + 1)
define|#
directive|define
name|OPTION_NO_EXPAND
value|(OPTION_SHCOMPACT_CONST_CRANGE + 1)
define|#
directive|define
name|OPTION_PT32
value|(OPTION_NO_EXPAND + 1)
block|{
literal|"isa"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ISA
block|}
block|,
block|{
literal|"abi"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ABI
block|}
block|,
block|{
literal|"no-mix"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MIX
block|}
block|,
block|{
literal|"shcompact-const-crange"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHCOMPACT_CONST_CRANGE
block|}
block|,
block|{
literal|"no-expand"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_EXPAND
block|}
block|,
block|{
literal|"expand-pt32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PT32
block|}
block|,
endif|#
directive|endif
comment|/* HAVE_SH64 */
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_RELAX
case|:
name|sh_relax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_BIG
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LITTLE
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SMALL
case|:
name|sh_small
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_DSP
case|:
name|sh_dsp
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SH64
case|case
name|OPTION_ISA
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"shmedia"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shcompact
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --isa=SHcompact with --isa=SHmedia"
argument_list|)
argument_list|)
expr_stmt|;
name|sh64_isa_mode
operator|=
name|sh64_isa_shmedia
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"shcompact"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shmedia
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --isa=SHmedia with --isa=SHcompact"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --abi=64 with --isa=SHcompact"
argument_list|)
argument_list|)
expr_stmt|;
name|sh64_isa_mode
operator|=
name|sh64_isa_shcompact
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Invalid argument to --isa option: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ABI
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_64
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --abi=32 with --abi=64"
argument_list|)
argument_list|)
expr_stmt|;
name|sh64_abi
operator|=
name|sh64_abi_32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sh64_abi
operator|==
name|sh64_abi_32
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --abi=64 with --abi=32"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh64_isa_mode
operator|==
name|sh64_isa_shcompact
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid combination: --isa=SHcompact with --abi=64"
argument_list|)
argument_list|)
expr_stmt|;
name|sh64_abi
operator|=
name|sh64_abi_64
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Invalid argument to --abi option: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MIX
case|:
name|sh64_mix
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_SHCOMPACT_CONST_CRANGE
case|:
name|sh64_shcompact_const_crange
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_EXPAND
case|:
name|sh64_expand
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_PT32
case|:
name|sh64_pt32
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_SH64 */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ SH options:\n\ -little			generate little endian code\n\ -big			generate big endian code\n\ -relax			alter jump instructions for long displacements\n\ -small			align sections to 4 byte boundaries, not 16\n\ -dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SH64
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -isa=[shmedia		set default instruction set for SH64\n\       | SHmedia\n\       | shcompact\n\       | SHcompact]\n\ -abi=[32|64]		set size of expanded SHmedia operands and object\n\ 			file type\n\ -shcompact-const-crange	emit code-range descriptors for constants in\n\ 			SHcompact code sections\n\ -no-mix			disallow SHmedia code in the same section as\n\ 			constants and SHcompact code\n\ -no-expand		do not expand MOVI, PT, PTA or PTB instructions\n\ -expand-pt32		with -abi=64, expand PT, PTA and PTB instructions\n\ 			to 32 bits only"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SH64 */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This struct is used to pass arguments to sh_count_relocs through    bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|sh_count_relocs
block|{
comment|/* Symbol we are looking for.  */
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* Count of relocs found.  */
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Count the number of fixups in a section which refer to a particular    symbol.  When using BFD_ASSEMBLER, this is called via    bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|sh_count_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|sh_count_relocs
modifier|*
name|info
init|=
operator|(
expr|struct
name|sh_count_relocs
operator|*
operator|)
name|data
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|sym
operator|=
name|info
operator|->
name|sym
expr_stmt|;
for|for
control|(
name|fix
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fix
operator|!=
name|NULL
condition|;
name|fix
operator|=
name|fix
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_addsy
operator|==
name|sym
condition|)
block|{
operator|++
name|info
operator|->
name|count
expr_stmt|;
name|fix
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the count relocs for a particular section.  When using    BFD_ASSEMBLER, this is called via bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|sh_frob_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|PTR
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|fix
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fix
operator|!=
name|NULL
condition|;
name|fix
operator|=
name|fix
operator|->
name|fx_next
control|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|fixS
modifier|*
name|fscan
decl_stmt|;
name|struct
name|sh_count_relocs
name|info
decl_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_USES
condition|)
continue|continue;
comment|/* The BFD_RELOC_SH_USES reloc should refer to a defined local 	 symbol in the same section.  */
name|sym
operator|=
name|fix
operator|->
name|fx_addsy
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|fix
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|||
name|fix
operator|->
name|fx_addnumber
operator|!=
literal|0
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|sec
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
endif|#
directive|endif
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|".uses does not refer to a local symbol in the same section"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Look through the fixups again, this time looking for one 	 at the same location as sym.  */
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
for|for
control|(
name|fscan
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fscan
operator|!=
name|NULL
condition|;
name|fscan
operator|=
name|fscan
operator|->
name|fx_next
control|)
if|if
condition|(
name|val
operator|==
name|fscan
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fscan
operator|->
name|fx_where
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_ALIGN
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_CODE
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_DATA
operator|&&
name|fscan
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_SH_LABEL
condition|)
break|break;
if|if
condition|(
name|fscan
operator|==
name|NULL
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't find fixup pointed to by .uses"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fscan
operator|->
name|fx_tcbit
condition|)
block|{
comment|/* We've already done this one.  */
continue|continue;
block|}
comment|/* The variable fscan should also be a fixup to a local symbol 	 in the same section.  */
name|sym
operator|=
name|fscan
operator|->
name|fx_addsy
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|fscan
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|||
name|fscan
operator|->
name|fx_addnumber
operator|!=
literal|0
operator|||
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|sec
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
endif|#
directive|endif
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|as_warn_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|".uses target does not refer to a local symbol in the same section"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now we look through all the fixups of all the sections, 	 counting the number of times we find a reference to sym.  */
name|info
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|info
operator|.
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|sh_count_relocs
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|iscan
decl_stmt|;
for|for
control|(
name|iscan
operator|=
name|SEG_E0
init|;
name|iscan
operator|<
name|SEG_UNKNOWN
condition|;
name|iscan
operator|++
control|)
name|sh_count_relocs
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|iscan
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|info
operator|.
name|count
operator|<
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Generate a BFD_RELOC_SH_COUNT fixup at the location of sym. 	 We have already adjusted the value of sym to include the 	 fragment address, so we undo that adjustment here.  */
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fscan
operator|->
name|fx_frag
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|-
name|fscan
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
literal|4
argument_list|,
operator|&
name|abs_symbol
argument_list|,
name|info
operator|.
name|count
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_COUNT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called after the symbol table has been completed,    but before the relocs or section contents have been written out.    If we have seen any .uses pseudo-ops, they point to an instruction    which loads a register with the address of a function.  We look    through the fixups to find where the function address is being    loaded from.  We then generate a COUNT reloc giving the number of    times that function address is referred to.  The linker uses this    information when doing relaxing, to decide when it can eliminate    the stored function address entirely.  */
end_comment

begin_function
name|void
name|sh_frob_file
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_SH64
name|shmedia_frob_file_before_adjust
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sh_relax
condition|)
return|return;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|sh_frob_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|iseg
decl_stmt|;
for|for
control|(
name|iseg
operator|=
name|SEG_E0
init|;
name|iseg
operator|<
name|SEG_UNKNOWN
condition|;
name|iseg
operator|++
control|)
name|sh_frob_section
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|iseg
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after relaxing.  Set the correct sizes of the fragments, and    create relocs so that md_apply_fix3 will fill in the correct values.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
else|#
directive|else
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
name|segT
name|seg
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|int
name|donerelax
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND8
argument_list|)
case|:
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP8BY2
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
case|:
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP12BY2
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement overflows 12-bit field"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement to defined symbol %s overflows 12-bit field"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement to undefined symbol %s overflows 12-bit field"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stabilize this frag, so we don't trip an assert.  */
name|fragP
operator|->
name|fr_fix
operator|+=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND12
argument_list|)
case|:
comment|/* A bcond won't fit, so turn it into a b!cond; bra disp; nop.  */
comment|/* I found that a relax failure for gcc.c-torture/execute/930628-1.c 	 was due to gas incorrectly relaxing an out-of-range conditional 	 branch with delay slot.  It turned:                      bf.s    L6              (slot mov.l   r12,@(44,r0))          into:  2c:  8f 01 a0 8b     bf.s    32<_main+32>   (slot bra       L6) 30:  00 09           nop 32:  10 cb           mov.l   r12,@(44,r0)          Therefore, branches with delay slots have to be handled 	 differently from ones without delay slots.  */
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
operator|)
decl_stmt|;
name|int
name|highbyte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|int
name|lowbyte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|delay
init|=
name|fragP
operator|->
name|fr_subtype
operator|==
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND12
argument_list|)
decl_stmt|;
comment|/* Toggle the true/false bit of the bcond.  */
name|buffer
index|[
name|highbyte
index|]
operator|^=
literal|0x2
expr_stmt|;
comment|/* If this is a delayed branch, we may not put the bra in the 	   slot.  So we change it to a non-delayed branch, like that: 	   b! cond slot_label; bra disp; slot_label: slot_insn 	   ??? We should try if swapping the conditional branch and 	   its delay-slot insn already makes the branch reach.  */
comment|/* Build a relocation to six / four bytes farther on.  */
name|subseg_change
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|section_symbol
argument_list|(
name|seg
argument_list|)
argument_list|,
else|#
directive|else
name|seg_info
argument_list|(
name|seg
argument_list|)
operator|->
name|dot
argument_list|,
endif|#
directive|endif
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
operator|(
name|delay
condition|?
literal|4
else|:
literal|6
operator|)
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP8BY2
argument_list|)
expr_stmt|;
comment|/* Set up a jump instruction.  */
name|buffer
index|[
name|highbyte
operator|+
literal|2
index|]
operator|=
literal|0xa0
expr_stmt|;
name|buffer
index|[
name|lowbyte
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_SH_PCDISP12BY2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|buffer
index|[
name|highbyte
index|]
operator|&=
operator|~
literal|0x4
expr_stmt|;
comment|/* Removes delay slot from branch.  */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in a NOP instruction.  */
name|buffer
index|[
name|highbyte
operator|+
literal|4
index|]
operator|=
literal|0x0
expr_stmt|;
name|buffer
index|[
name|lowbyte
operator|+
literal|4
index|]
operator|=
literal|0x9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|donerelax
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement overflows 8-bit field"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement to defined symbol %s overflows 8-bit field"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"displacement to undefined symbol %s overflows 8-bit field "
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stabilize this frag, so we don't trip an assert.  */
name|fragP
operator|->
name|fr_fix
operator|+=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|HAVE_SH64
name|shmedia_md_convert_frag
argument_list|(
name|headers
argument_list|,
name|seg
argument_list|,
name|fragP
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|donerelax
operator|&&
operator|!
name|sh_relax
condition|)
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"overflow in branch to %s; converted into longer instruction sequence"
argument_list|)
argument_list|,
operator|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
condition|?
name|S_GET_NAME
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|size
parameter_list|)
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
name|size
return|;
else|#
directive|else
comment|/* ! OBJ_ELF */
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* ! OBJ_ELF */
else|#
directive|else
comment|/* ! BFD_ASSEMBLER */
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* ! BFD_ASSEMBLER */
block|}
end_function

begin_comment
comment|/* This static variable is set by s_uacons to tell sh_cons_align that    the expession does not need to be aligned.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sh_no_align_cons
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This handles the unaligned space allocation pseudo-ops, such as    .uaword.  .uaword is just like .word, but the value does not need    to be aligned.  */
end_comment

begin_function
specifier|static
name|void
name|s_uacons
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
comment|/* Tell sh_cons_align not to align this value.  */
name|sh_no_align_cons
operator|=
literal|1
expr_stmt|;
name|cons
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If a .word, et. al., pseud-op is seen, warn if the value is not    aligned correctly.  Note that this can cause warnings to be issued    when assembling initialized structured which were declared with the    packed attribute.  FIXME: Perhaps we should require an option to    enable this warning?  */
end_comment

begin_function
name|void
name|sh_cons_align
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|int
name|nalign
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sh_no_align_cons
condition|)
block|{
comment|/* This is an unaligned pseudo-op.  */
name|sh_no_align_cons
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|nalign
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|nbytes
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|nalign
expr_stmt|;
name|nbytes
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nalign
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
operator|(
name|abs_section_offset
operator|&
operator|(
operator|(
literal|1
operator|<<
name|nalign
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"misaligned data"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align_test
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|nalign
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|nalign
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When relaxing, we need to output a reloc for any .align directive    that requests alignment to a four byte boundary or larger.  This is    also where we check for misaligned data.  */
end_comment

begin_function
name|void
name|sh_handle_align
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|int
name|bytes
init|=
name|frag
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_address
operator|-
name|frag
operator|->
name|fr_fix
decl_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_type
operator|==
name|rs_align_code
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|big_nop_pattern
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|little_nop_pattern
index|[]
init|=
block|{
literal|0x09
block|,
literal|0x00
block|}
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
decl_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|1
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
name|frag
operator|->
name|fr_fix
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|big_nop_pattern
argument_list|,
sizeof|sizeof
name|big_nop_pattern
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
sizeof|sizeof
name|big_nop_pattern
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|little_nop_pattern
argument_list|,
sizeof|sizeof
name|little_nop_pattern
argument_list|)
expr_stmt|;
name|frag
operator|->
name|fr_var
operator|=
sizeof|sizeof
name|little_nop_pattern
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|frag
operator|->
name|fr_type
operator|==
name|rs_align_test
condition|)
block|{
if|if
condition|(
name|bytes
operator|!=
literal|0
condition|)
name|as_warn_where
argument_list|(
name|frag
operator|->
name|fr_file
argument_list|,
name|frag
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"misaligned data"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sh_relax
operator|&&
operator|(
name|frag
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|frag
operator|->
name|fr_type
operator|==
name|rs_align_code
operator|)
operator|&&
name|frag
operator|->
name|fr_address
operator|+
name|frag
operator|->
name|fr_fix
operator|>
literal|0
operator|&&
name|frag
operator|->
name|fr_offset
operator|>
literal|1
operator|&&
name|now_seg
operator|!=
name|bss_section
condition|)
name|fix_new
argument_list|(
name|frag
argument_list|,
name|frag
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
name|frag
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_SH_ALIGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This macro decides whether a particular reloc is an entry in a    switch table.  It is used when relaxing, because the linker needs    to know about all such entries so that it can adjust them if    necessary.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_define
define|#
directive|define
name|SWITCH_TABLE_CONS
parameter_list|(
name|fix
parameter_list|)
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SWITCH_TABLE_CONS
parameter_list|(
name|fix
parameter_list|)
define|\
value|((fix)->fx_r_type == 0				\&& ((fix)->fx_size == 2				\        || (fix)->fx_size == 1				\        || (fix)->fx_size == 4))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWITCH_TABLE
parameter_list|(
name|fix
parameter_list|)
define|\
value|((fix)->fx_addsy != NULL				\&& (fix)->fx_subsy != NULL				\&& S_GET_SEGMENT ((fix)->fx_addsy) == text_section	\&& S_GET_SEGMENT ((fix)->fx_subsy) == text_section	\&& ((fix)->fx_r_type == BFD_RELOC_32			\        || (fix)->fx_r_type == BFD_RELOC_16		\        || (fix)->fx_r_type == BFD_RELOC_8		\        || SWITCH_TABLE_CONS (fix)))
end_define

begin_comment
comment|/* See whether we need to force a relocation into the output file.    This is used to force out switch and PC relative relocations when    relaxing.  */
end_comment

begin_function
name|int
name|sh_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LOOP_START
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LOOP_END
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|sh_relax
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|fix
operator|->
name|fx_pcrel
operator|||
name|SWITCH_TABLE
argument_list|(
name|fix
argument_list|)
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_COUNT
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_ALIGN
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_CODE
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_DATA
ifdef|#
directive|ifdef
name|HAVE_SH64
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_SHMEDIA_CODE
endif|#
directive|endif
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LABEL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
name|boolean
name|sh_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_PCDISP8BY2
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_PCDISP12BY2
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_PCRELIMM8BY2
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_PCRELIMM8BY4
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_SWITCH16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_SWITCH32
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TC_RELOC_RTSYM_LOC_FIXUP
argument_list|(
name|fixP
argument_list|)
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_RVA
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|sh_elf_final_processing
parameter_list|()
block|{
name|int
name|val
decl_stmt|;
comment|/* Set file-specific flags to indicate if this code needs      a processor with the sh-dsp / sh3e ISA to execute.  */
ifdef|#
directive|ifdef
name|HAVE_SH64
comment|/* SH5 and above don't know about the valid_arch arch_sh* bits defined      in sh-opc.h, so check SH64 mode before checking valid_arch.  */
if|if
condition|(
name|sh64_isa_mode
operator|!=
name|sh64_isa_unspecified
condition|)
name|val
operator|=
name|EF_SH5
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* HAVE_SH64 */
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh1
condition|)
name|val
operator|=
name|EF_SH1
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh2
condition|)
name|val
operator|=
name|EF_SH2
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh_dsp
condition|)
name|val
operator|=
name|EF_SH_DSP
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh3
condition|)
name|val
operator|=
name|EF_SH3
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh3_dsp
condition|)
name|val
operator|=
name|EF_SH_DSP
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh3e
condition|)
name|val
operator|=
name|EF_SH3E
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_arch
operator|&
name|arch_sh4
condition|)
name|val
operator|=
name|EF_SH4
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_SH_MACH_MASK
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Apply a fixup to the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|int
name|lowbyte
init|=
name|target_big_endian
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|highbyte
init|=
name|target_big_endian
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|long
name|val
init|=
operator|(
name|long
operator|)
operator|*
name|valP
decl_stmt|;
name|long
name|max
decl_stmt|,
name|min
decl_stmt|;
name|int
name|shift
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* A difference between two symbols, the second of which is in the      current section, is transformed in a PC-relative relocation to      the other symbol.  We have to adjust the relocation type here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_32
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
comment|/* Currently, we only support 32-bit PCREL relocations. 	     We'd need a new reloc type to handle 16_PCREL, and 	     8_PCREL is already taken for R_SH_SWITCH8, which 	     apparently does something completely different than what 	     we need.  FIXME.  */
case|case
name|BFD_RELOC_16
case|:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_8
case|:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* The function adjust_reloc_syms won't convert a reloc against a weak      symbol into a reloc against a section, but bfd_install_relocation      will screw up if the symbol is defined, so we have to adjust val here      to avoid the screw up later.       For ordinary relocs, this does not happen for ELF, since for ELF,      bfd_install_relocation uses the "special function" field of the      howto, and does not execute the code that needs to be undone, as long      as the special function does not return bfd_reloc_continue.      It can happen for GOT- and PLT-type relocs the way they are      described in elf32-sh.c as they use bfd_elf_generic_reloc, but it      doesn't matter here since those relocs don't use VAL; see below.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|val
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|max
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_IMM4
case|:
name|max
operator|=
literal|0xf
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|val
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM4BY2
case|:
name|max
operator|=
literal|0xf
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|1
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM4BY4
case|:
name|max
operator|=
literal|0xf
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
operator|*
name|buf
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|2
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM8BY2
case|:
name|max
operator|=
literal|0xff
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
operator|*
name|buf
operator|=
name|val
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_IMM8BY4
case|:
name|max
operator|=
literal|0xff
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_SH_IMM8
case|:
comment|/* Sometimes the 8 bit value is sign extended (e.g., add) and          sometimes it is not (e.g., and).  We permit any 8 bit value.          Note that adding further restrictions may invalidate          reasonable looking assembly code, such as ``and -0x1,r0''.  */
name|max
operator|=
literal|0xff
expr_stmt|;
name|min
operator|=
operator|-
literal|0xff
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCRELIMM8BY4
case|:
comment|/* The lower two bits of the PC are cleared before the          displacement is added in.  We can assume that the destination          is on a 4 byte bounday.  If this instruction is also on a 4          byte boundary, then we want 	   (target - here) / 4 	 and target - here is a multiple of 4. 	 Otherwise, we are on a 2 byte boundary, and we want 	   (target - (here - 2)) / 4 	 and target - here is not a multiple of 4.  Computing 	   (target - (here - 2)) / 4 == (target - here + 2) / 4 	 works for both cases, since in the first case the addition of 	 2 will be removed by the division.  target - here is in the 	 variable val.  */
name|val
operator|=
operator|(
name|val
operator|+
literal|2
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel too far"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCRELIMM8BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel too far"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCDISP8BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|-
literal|0x80
operator|||
name|val
operator|>
literal|0x7f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel too far"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_PCDISP12BY2
case|:
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|-
literal|0x800
operator|||
name|val
operator|>
literal|0x7ff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"pcrel too far"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|lowbyte
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|highbyte
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_USES
case|:
comment|/* Pass the value into sh_coff_reloc_mangle.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_COUNT
case|:
case|case
name|BFD_RELOC_SH_ALIGN
case|:
case|case
name|BFD_RELOC_SH_CODE
case|:
case|case
name|BFD_RELOC_SH_DATA
case|:
case|case
name|BFD_RELOC_SH_LABEL
case|:
comment|/* Nothing to do here.  */
break|break;
case|case
name|BFD_RELOC_SH_LOOP_START
case|:
case|case
name|BFD_RELOC_SH_LOOP_END
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
comment|/* Make the jump instruction point to the address of the operand.  At 	 runtime we merely add the offset to the actual PLT entry.  */
operator|*
name|valP
operator|=
literal|0xfffffffc
expr_stmt|;
name|val
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
condition|)
name|val
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SH_GOTPC
case|:
comment|/* This is tough to explain.  We end up with this one if we have          operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".          The goal here is to obtain the absolute address of the GOT,          and it is strongly preferable from a performance point of          view to avoid using a runtime relocation for this.  There are          cases where you have something like:           .long	_GLOBAL_OFFSET_TABLE_+[.-.L66]           and here no correction would be required.  Internally in the          assembler we treat operands of this form as not being pcrel          since the '.' is explicitly mentioned, and I wonder whether          it would simplify matters to do it this way.  Who knows.  In          earlier versions of the PIC patches, the pcrel_adjust field          was used to store the correction, but since the expression is          not pcrel, I felt it would be confusing to do it this way.  */
operator|*
name|valP
operator|-=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_SH_GOTPLT32
case|:
operator|*
name|valP
operator|=
literal|0
expr_stmt|;
comment|/* Fully resolved at runtime.  No addend.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOTOFF
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
ifdef|#
directive|ifdef
name|HAVE_SH64
name|shmedia_md_apply_fix3
argument_list|(
name|fixP
argument_list|,
name|valP
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"misaligned offset"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
name|val
operator|>>=
name|shift
expr_stmt|;
else|else
name|val
operator|=
operator|(
operator|(
name|val
operator|>>
name|shift
operator|)
operator||
operator|(
operator|(
name|long
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
operator|-
literal|1
operator|>>
name|shift
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|<
name|min
operator|||
name|val
operator|>
name|max
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called just before address relaxation.  Return the length    by which a fragment must grow to reach it's destination.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment_type
decl_stmt|;
block|{
name|int
name|what
decl_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|HAVE_SH64
return|return
name|shmedia_md_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|,
name|segment_type
argument_list|)
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
comment|/* Used to be a branch to somewhere which was unknown.  */
if|if
condition|(
operator|!
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|UNDEF_DISP
argument_list|)
case|:
name|what
operator|=
name|GET_WHAT
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* Used to be a branch to somewhere which was unknown.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
comment|/* Got a symbol and it's defined in this segment, become byte 	     sized - maybe it will fix up.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|COND8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
block|{
comment|/* Its got a segment, but its not ours, so it will always be long.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We know the abs value.  */
name|fragP
operator|->
name|fr_subtype
operator|=
name|C
argument_list|(
name|what
argument_list|,
name|COND8
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNCOND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND8
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|COND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND8
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND12
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|COND32
argument_list|)
case|:
case|case
name|C
argument_list|(
name|COND_JUMP_DELAY
argument_list|,
name|UNDEF_WORD_DISP
argument_list|)
case|:
comment|/* When relaxing a section for the second time, we don't need to 	 do anything besides return the current size.  */
break|break;
block|}
name|fragP
operator|->
name|fr_var
operator|=
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
expr_stmt|;
return|return
name|fragP
operator|->
name|fr_var
return|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|ptr
parameter_list|,
name|use
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|valueT
name|use
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_SH64
comment|/* We might need to set the contents type to data.  */
name|sh64_flag_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|number_to_chars_littleendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This version is used in obj-coff.c when not using BFD_ASSEMBLER.    eg for the sh-hms target.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
literal|2
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixP
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|sec
operator|)
condition|)
block|{
comment|/* The symbol is undefined (or is defined but not in this section, 	 or we're not sure about it being the final definition).  Let the 	 linker figure it out.  We need to adjust the subtraction of a 	 symbol to the position of the relocated data, though.  */
return|return
name|fixP
operator|->
name|fx_subsy
condition|?
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
else|:
literal|0
return|;
block|}
return|return
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|int
name|tc_coff_sizemachdep
parameter_list|(
name|frag
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
return|return
name|md_relax_table
index|[
name|frag
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_comment
comment|/* Map BFD relocs to SH COFF relocs.  */
end_comment

begin_struct
struct|struct
name|reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc
decl_stmt|;
name|int
name|sh_reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reloc_map
name|coff_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_32
block|,
name|R_SH_IMM32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_SH_IMM16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_SH_IMM8
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP8BY2
block|,
name|R_SH_PCDISP8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_PCDISP12BY2
block|,
name|R_SH_PCDISP
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4
block|,
name|R_SH_IMM4
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4BY2
block|,
name|R_SH_IMM4BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM4BY4
block|,
name|R_SH_IMM4BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8
block|,
name|R_SH_IMM8
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8BY2
block|,
name|R_SH_IMM8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM8BY4
block|,
name|R_SH_IMM8BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY2
block|,
name|R_SH_PCRELIMM8BY2
block|}
block|,
block|{
name|BFD_RELOC_SH_PCRELIMM8BY4
block|,
name|R_SH_PCRELIMM8BY4
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_SH_SWITCH8
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH16
block|,
name|R_SH_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH32
block|,
name|R_SH_SWITCH32
block|}
block|,
block|{
name|BFD_RELOC_SH_USES
block|,
name|R_SH_USES
block|}
block|,
block|{
name|BFD_RELOC_SH_COUNT
block|,
name|R_SH_COUNT
block|}
block|,
block|{
name|BFD_RELOC_SH_ALIGN
block|,
name|R_SH_ALIGN
block|}
block|,
block|{
name|BFD_RELOC_SH_CODE
block|,
name|R_SH_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_DATA
block|,
name|R_SH_DATA
block|}
block|,
block|{
name|BFD_RELOC_SH_LABEL
block|,
name|R_SH_LABEL
block|}
block|,
block|{
name|BFD_RELOC_UNUSED
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjust a reloc for the SH.  This is similar to the generic code,    but does some minor tweaking.  */
end_comment

begin_function
name|void
name|sh_coff_reloc_mangle
parameter_list|(
name|seg
parameter_list|,
name|fix
parameter_list|,
name|intr
parameter_list|,
name|paddr
parameter_list|)
name|segment_info_type
modifier|*
name|seg
decl_stmt|;
name|fixS
modifier|*
name|fix
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intr
decl_stmt|;
name|unsigned
name|int
name|paddr
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbol_ptr
init|=
name|fix
operator|->
name|fx_addsy
decl_stmt|;
name|symbolS
modifier|*
name|dot
decl_stmt|;
name|intr
operator|->
name|r_vaddr
operator|=
name|paddr
operator|+
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
operator|!
name|SWITCH_TABLE
argument_list|(
name|fix
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|reloc_map
modifier|*
name|rm
decl_stmt|;
for|for
control|(
name|rm
operator|=
name|coff_reloc_map
init|;
name|rm
operator|->
name|bfd_reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|;
name|rm
operator|++
control|)
if|if
condition|(
name|rm
operator|->
name|bfd_reloc
operator|==
operator|(
name|bfd_reloc_code_real_type
operator|)
name|fix
operator|->
name|fx_r_type
condition|)
break|break;
if|if
condition|(
name|rm
operator|->
name|bfd_reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can not represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fix
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
name|intr
operator|->
name|r_type
operator|=
name|rm
operator|->
name|sh_reloc
expr_stmt|;
name|intr
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|sh_relax
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
condition|)
name|intr
operator|->
name|r_type
operator|=
name|R_SH_SWITCH16
expr_stmt|;
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_8
condition|)
name|intr
operator|->
name|r_type
operator|=
name|R_SH_SWITCH8
expr_stmt|;
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
condition|)
name|intr
operator|->
name|r_type
operator|=
name|R_SH_SWITCH32
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* For a switch reloc, we set r_offset to the difference between          the reloc address and the subtrahend.  When the linker is          doing relaxing, it can use the determine the starting and          ending points of the switch difference expression.  */
name|intr
operator|->
name|r_offset
operator|=
name|intr
operator|->
name|r_vaddr
operator|-
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
block|}
comment|/* PC relative relocs are always against the current section.  */
if|if
condition|(
name|symbol_ptr
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_SH_PCRELIMM8BY2
case|:
case|case
name|BFD_RELOC_SH_PCRELIMM8BY4
case|:
case|case
name|BFD_RELOC_SH_PCDISP8BY2
case|:
case|case
name|BFD_RELOC_SH_PCDISP12BY2
case|:
case|case
name|BFD_RELOC_SH_USES
case|:
name|symbol_ptr
operator|=
name|seg
operator|->
name|dot
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_USES
condition|)
block|{
comment|/* We can't store the offset in the object file, since this 	 reloc does not take up any space, so we store it in r_offset. 	 The fx_addnumber field was set in md_apply_fix3.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_addnumber
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_COUNT
condition|)
block|{
comment|/* We can't store the count in the object file, since this reloc          does not take up any space, so we store it in r_offset.  The          fx_offset field was set when the fixup was created in          sh_coff_frob_file.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_offset
expr_stmt|;
comment|/* This reloc is always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_ALIGN
condition|)
block|{
comment|/* Store the alignment in the r_offset field.  */
name|intr
operator|->
name|r_offset
operator|=
name|fix
operator|->
name|fx_offset
expr_stmt|;
comment|/* This reloc is always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_CODE
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_DATA
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SH_LABEL
condition|)
block|{
comment|/* These relocs are always absolute.  */
name|symbol_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Turn the segment of the symbol into an offset.  */
if|if
condition|(
name|symbol_ptr
operator|!=
name|NULL
condition|)
block|{
name|dot
operator|=
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbol_ptr
argument_list|)
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
name|intr
operator|->
name|r_symndx
operator|=
name|dot
operator|->
name|sy_number
expr_stmt|;
else|else
name|intr
operator|->
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
name|intr
operator|->
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Create a reloc.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|fixp
operator|->
name|fx_addnumber
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
name|r_type
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|SWITCH_TABLE
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
name|rel
operator|->
name|addend
operator|=
name|rel
operator|->
name|address
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_16
condition|)
name|r_type
operator|=
name|BFD_RELOC_SH_SWITCH16
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_8
condition|)
name|r_type
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_32
condition|)
name|r_type
operator|=
name|BFD_RELOC_SH_SWITCH32
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_USES
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_COUNT
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_ALIGN
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_LOOP_START
operator|||
name|r_type
operator|==
name|BFD_RELOC_SH_LOOP_END
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_SH_LABEL
operator|&&
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SH64
elseif|else
if|if
condition|(
name|shmedia_init_reloc
argument_list|(
name|rel
argument_list|,
name|fixp
argument_list|)
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|BFD_RELOC_32
operator|||
name|r_type
operator|==
name|BFD_RELOC_32_GOTOFF
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|NULL
operator|||
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|inline
specifier|static
name|char
modifier|*
name|sh_end_of_match
parameter_list|(
name|cont
parameter_list|,
name|what
parameter_list|)
name|char
modifier|*
name|cont
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|what
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|cont
argument_list|,
name|what
argument_list|,
name|strlen
argument_list|(
name|what
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_part_of_name
argument_list|(
name|cont
index|[
name|len
index|]
argument_list|)
condition|)
return|return
name|cont
operator|+
name|len
return|;
return|return
name|NULL
return|;
block|}
end_block

begin_function
name|int
name|sh_parse_name
parameter_list|(
name|name
parameter_list|,
name|exprP
parameter_list|,
name|nextcharP
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|exprP
decl_stmt|;
name|char
modifier|*
name|nextcharP
decl_stmt|;
block|{
name|char
modifier|*
name|next
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|next_end
decl_stmt|;
name|int
name|reloc_type
decl_stmt|;
name|segT
name|segment
decl_stmt|;
name|exprP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|GOT_symbol
expr_stmt|;
name|no_suffix
label|:
comment|/* If we have an absolute symbol or a reg, then we know its 	     value now.  */
name|segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|absolute_section
condition|)
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segment
operator|==
name|reg_section
condition|)
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|exprP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|exprP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|exprP
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|exprP
operator|->
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nextcharP
operator|!=
literal|'@'
condition|)
goto|goto
name|no_suffix
goto|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|sh_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_GOTOFF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|sh_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"GOTPLT"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_SH_GOTPLT32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|sh_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next_end
operator|=
name|sh_end_of_match
argument_list|(
name|next
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|)
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32_PLT_PCREL
expr_stmt|;
else|else
goto|goto
name|no_suffix
goto|;
operator|*
name|input_line_pointer
operator|=
operator|*
name|nextcharP
expr_stmt|;
name|input_line_pointer
operator|=
name|next_end
expr_stmt|;
operator|*
name|nextcharP
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|exprP
operator|->
name|X_op
operator|=
name|O_PIC_reloc
expr_stmt|;
name|exprP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exprP
operator|->
name|X_md
operator|=
name|reloc_type
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

end_unit

