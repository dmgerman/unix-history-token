begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-v850.c -- Assembler code for the NEC V850    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006  Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/v850.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_comment
comment|/* Sign-extend a 16-bit number.  */
end_comment

begin_define
define|#
directive|define
name|SEXT16
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffff) ^ (~0x7fff)) + 0x8000)
end_define

begin_comment
comment|/* Temporarily holds the reloc in a cons expression.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|hold_cons_reloc
init|=
name|BFD_RELOC_UNUSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to TRUE if we want to be pedantic about signed overflows.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|warn_signed_overflows
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|warn_unsigned_overflows
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the target BFD machine number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|machine
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the target processor(s) for the assemble.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|processor_mask
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|reg_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_comment
comment|/* Characters which always start a comment.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|";#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* Conditional branches.  */
block|{
literal|0xff
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|0x1fffff
block|,
operator|-
literal|0x200000
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* Unconditional branches.  */
block|{
literal|0xff
block|,
operator|-
literal|0x100
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0x1fffff
block|,
operator|-
literal|0x200000
block|,
literal|4
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v850_relax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fixups.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|5
end_define

begin_struct
struct|struct
name|v850_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|v850_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fc
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|v850_seg_entry
block|{
name|segT
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|v850_seg_entry
name|v850_seg_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|".sdata"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_SMALL_DATA
block|}
block|,
block|{
name|NULL
block|,
literal|".tdata"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|".zdata"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|".sbss"
block|,
name|SEC_ALLOC
operator||
name|SEC_SMALL_DATA
block|}
block|,
block|{
name|NULL
block|,
literal|".tbss"
block|,
name|SEC_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|".zbss"
block|,
name|SEC_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|".rosdata"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_SMALL_DATA
block|}
block|,
block|{
name|NULL
block|,
literal|".rozdata"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|".scommon"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_IS_COMMON
block|}
block|,
block|{
name|NULL
block|,
literal|".tcommon"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IS_COMMON
block|}
block|,
block|{
name|NULL
block|,
literal|".zcommon"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IS_COMMON
block|}
block|,
block|{
name|NULL
block|,
literal|".call_table_data"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|".call_table_text"
block|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|".bss"
block|,
name|SEC_ALLOC
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SDATA_SECTION
value|0
end_define

begin_define
define|#
directive|define
name|TDATA_SECTION
value|1
end_define

begin_define
define|#
directive|define
name|ZDATA_SECTION
value|2
end_define

begin_define
define|#
directive|define
name|SBSS_SECTION
value|3
end_define

begin_define
define|#
directive|define
name|TBSS_SECTION
value|4
end_define

begin_define
define|#
directive|define
name|ZBSS_SECTION
value|5
end_define

begin_define
define|#
directive|define
name|ROSDATA_SECTION
value|6
end_define

begin_define
define|#
directive|define
name|ROZDATA_SECTION
value|7
end_define

begin_define
define|#
directive|define
name|SCOMMON_SECTION
value|8
end_define

begin_define
define|#
directive|define
name|TCOMMON_SECTION
value|9
end_define

begin_define
define|#
directive|define
name|ZCOMMON_SECTION
value|10
end_define

begin_define
define|#
directive|define
name|CALL_TABLE_DATA_SECTION
value|11
end_define

begin_define
define|#
directive|define
name|CALL_TABLE_TEXT_SECTION
value|12
end_define

begin_define
define|#
directive|define
name|BSS_SECTION
value|13
end_define

begin_function
specifier|static
name|void
name|do_v850_seg
parameter_list|(
name|int
name|i
parameter_list|,
name|subsegT
name|sub
parameter_list|)
block|{
name|struct
name|v850_seg_entry
modifier|*
name|seg
init|=
name|v850_seg_table
operator|+
name|i
decl_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|s
operator|!=
name|NULL
condition|)
name|subseg_set
argument_list|(
name|seg
operator|->
name|s
argument_list|,
name|sub
argument_list|)
expr_stmt|;
else|else
block|{
name|seg
operator|->
name|s
operator|=
name|subseg_new
argument_list|(
name|seg
operator|->
name|name
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
operator|->
name|s
argument_list|,
name|seg
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seg
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|seg_info
argument_list|(
name|seg
operator|->
name|s
argument_list|)
operator|->
name|bss
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|v850_seg
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|subsegT
name|sub
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|do_v850_seg
argument_list|(
name|i
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|v850_offset
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|temp
init|=
name|get_absolute_expression
argument_list|()
decl_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|temp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copied from obj_elf_common() in gas/config/obj-elf.c.  */
end_comment

begin_function
specifier|static
name|void
name|v850_comm
parameter_list|(
name|int
name|area
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|have_align
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after symbol-name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip ','.  */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%d.)< 0! Ignored."
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|temp
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|size
condition|)
comment|/* xgettext:c-format  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %d."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|have_align
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|have_align
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_align
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|have_align
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Common alignment negative; 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|align
decl_stmt|;
name|flagword
name|applicable
decl_stmt|;
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|applicable
operator|&=
name|SEC_ALLOC
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|SCOMMON_SECTION
case|:
name|do_v850_seg
argument_list|(
name|SBSS_SECTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZCOMMON_SECTION
case|:
name|do_v850_seg
argument_list|(
name|ZBSS_SECTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCOMMON_SECTION
case|:
name|do_v850_seg
argument_list|(
name|TBSS_SECTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|temp
condition|)
block|{
comment|/* Convert to a power of 2 alignment.  */
for|for
control|(
name|align
operator|=
literal|0
init|;
operator|(
name|temp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|temp
operator|>>=
literal|1
operator|,
operator|++
name|align
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Common alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|SCOMMON_SECTION
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|v850_seg_table
index|[
name|SBSS_SECTION
index|]
operator|.
name|s
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ZCOMMON_SECTION
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|v850_seg_table
index|[
name|ZBSS_SECTION
index|]
operator|.
name|s
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TCOMMON_SECTION
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|v850_seg_table
index|[
name|TBSS_SECTION
index|]
operator|.
name|s
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|SCOMMON_SECTION
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|v850_seg_table
index|[
name|SBSS_SECTION
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZCOMMON_SECTION
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|v850_seg_table
index|[
name|ZBSS_SECTION
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCOMMON_SECTION
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|v850_seg_table
index|[
name|TBSS_SECTION
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|allocate_common
label|:
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|SCOMMON_SECTION
case|:
case|case
name|ZCOMMON_SECTION
case|:
case|case
name|TCOMMON_SECTION
case|:
name|do_v850_seg
argument_list|(
name|area
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|v850_seg_table
index|[
name|area
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some use the dot, some don't.  Can we get some consistency??  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some say data, some say bss.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"bss\""
argument_list|,
literal|4
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"data\""
argument_list|,
literal|5
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|input_line_pointer
operator|!=
literal|'"'
condition|)
empty_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
goto|goto
name|bad_common_segment
goto|;
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
goto|goto
name|allocate_common
goto|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|{
name|bad_common_segment
label|:
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .common segment %s"
argument_list|)
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_machine
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|machine
operator|=
name|number
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|machine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
break|break;
case|case
name|bfd_mach_v850e
case|:
name|processor_mask
operator|=
name|PROCESSOR_V850E
expr_stmt|;
break|break;
case|case
name|bfd_mach_v850e1
case|:
name|processor_mask
operator|=
name|PROCESSOR_V850E
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|v850_longcode
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
if|if
condition|(
operator|!
name|v850_relax
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|1
condition|)
name|as_warn
argument_list|(
literal|".longcall pseudo-op seen when not relaxing"
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|".longjump pseudo-op seen when not relaxing"
argument_list|)
expr_stmt|;
block|}
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad .longcall format"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
literal|1
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_V850_LONGCALL
argument_list|)
expr_stmt|;
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_V850_LONGJUMP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"sdata"
block|,
name|v850_seg
block|,
name|SDATA_SECTION
block|}
block|,
block|{
literal|"tdata"
block|,
name|v850_seg
block|,
name|TDATA_SECTION
block|}
block|,
block|{
literal|"zdata"
block|,
name|v850_seg
block|,
name|ZDATA_SECTION
block|}
block|,
block|{
literal|"sbss"
block|,
name|v850_seg
block|,
name|SBSS_SECTION
block|}
block|,
block|{
literal|"tbss"
block|,
name|v850_seg
block|,
name|TBSS_SECTION
block|}
block|,
block|{
literal|"zbss"
block|,
name|v850_seg
block|,
name|ZBSS_SECTION
block|}
block|,
block|{
literal|"rosdata"
block|,
name|v850_seg
block|,
name|ROSDATA_SECTION
block|}
block|,
block|{
literal|"rozdata"
block|,
name|v850_seg
block|,
name|ROZDATA_SECTION
block|}
block|,
block|{
literal|"bss"
block|,
name|v850_seg
block|,
name|BSS_SECTION
block|}
block|,
block|{
literal|"offset"
block|,
name|v850_offset
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"zcomm"
block|,
name|v850_comm
block|,
name|ZCOMMON_SECTION
block|}
block|,
block|{
literal|"scomm"
block|,
name|v850_comm
block|,
name|SCOMMON_SECTION
block|}
block|,
block|{
literal|"tcomm"
block|,
name|v850_comm
block|,
name|TCOMMON_SECTION
block|}
block|,
block|{
literal|"v850"
block|,
name|set_machine
block|,
literal|0
block|}
block|,
block|{
literal|"call_table_data"
block|,
name|v850_seg
block|,
name|CALL_TABLE_DATA_SECTION
block|}
block|,
block|{
literal|"call_table_text"
block|,
name|v850_seg
block|,
name|CALL_TABLE_TEXT_SECTION
block|}
block|,
block|{
literal|"v850e"
block|,
name|set_machine
block|,
name|bfd_mach_v850e
block|}
block|,
block|{
literal|"v850e1"
block|,
name|set_machine
block|,
name|bfd_mach_v850e1
block|}
block|,
block|{
literal|"longcall"
block|,
name|v850_longcode
block|,
literal|1
block|}
block|,
block|{
literal|"longjump"
block|,
name|v850_longcode
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|v850_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is sorted.  Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"ep"
block|,
literal|30
block|}
block|,
comment|/* ep - element ptr.  */
block|{
literal|"gp"
block|,
literal|4
block|}
block|,
comment|/* gp - global ptr.  */
block|{
literal|"hp"
block|,
literal|2
block|}
block|,
comment|/* hp - handler stack ptr.  */
block|{
literal|"lp"
block|,
literal|31
block|}
block|,
comment|/* lp - link ptr.  */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|}
block|,
block|{
literal|"r27"
block|,
literal|27
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|}
block|,
block|{
literal|"r29"
block|,
literal|29
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"sp"
block|,
literal|3
block|}
block|,
comment|/* sp - stack ptr.  */
block|{
literal|"tp"
block|,
literal|5
block|}
block|,
comment|/* tp - text ptr.  */
block|{
literal|"zero"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_NAME_CNT
define|\
value|(sizeof (pre_defined_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|system_registers
index|[]
init|=
block|{
block|{
literal|"asid"
block|,
literal|23
block|}
block|,
block|{
literal|"bpc"
block|,
literal|22
block|}
block|,
block|{
literal|"bpav"
block|,
literal|24
block|}
block|,
block|{
literal|"bpam"
block|,
literal|25
block|}
block|,
block|{
literal|"bpdv"
block|,
literal|26
block|}
block|,
block|{
literal|"bpdm"
block|,
literal|27
block|}
block|,
block|{
literal|"ctbp"
block|,
literal|20
block|}
block|,
block|{
literal|"ctpc"
block|,
literal|16
block|}
block|,
block|{
literal|"ctpsw"
block|,
literal|17
block|}
block|,
block|{
literal|"dbpc"
block|,
literal|18
block|}
block|,
block|{
literal|"dbpsw"
block|,
literal|19
block|}
block|,
block|{
literal|"dir"
block|,
literal|21
block|}
block|,
block|{
literal|"ecr"
block|,
literal|4
block|}
block|,
block|{
literal|"eipc"
block|,
literal|0
block|}
block|,
block|{
literal|"eipsw"
block|,
literal|1
block|}
block|,
block|{
literal|"fepc"
block|,
literal|2
block|}
block|,
block|{
literal|"fepsw"
block|,
literal|3
block|}
block|,
block|{
literal|"psw"
block|,
literal|5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYSREG_NAME_CNT
define|\
value|(sizeof (system_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|system_list_registers
index|[]
init|=
block|{
block|{
literal|"PS"
block|,
literal|5
block|}
block|,
block|{
literal|"SR"
block|,
literal|0
operator|+
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYSREGLIST_NAME_CNT
define|\
value|(sizeof (system_list_registers) / sizeof (struct reg_name))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_name
name|cc_names
index|[]
init|=
block|{
block|{
literal|"c"
block|,
literal|0x1
block|}
block|,
block|{
literal|"e"
block|,
literal|0x2
block|}
block|,
block|{
literal|"ge"
block|,
literal|0xe
block|}
block|,
block|{
literal|"gt"
block|,
literal|0xf
block|}
block|,
block|{
literal|"h"
block|,
literal|0xb
block|}
block|,
block|{
literal|"l"
block|,
literal|0x1
block|}
block|,
block|{
literal|"le"
block|,
literal|0x7
block|}
block|,
block|{
literal|"lt"
block|,
literal|0x6
block|}
block|,
block|{
literal|"n"
block|,
literal|0x4
block|}
block|,
block|{
literal|"nc"
block|,
literal|0x9
block|}
block|,
block|{
literal|"ne"
block|,
literal|0xa
block|}
block|,
block|{
literal|"nh"
block|,
literal|0x3
block|}
block|,
block|{
literal|"nl"
block|,
literal|0x9
block|}
block|,
block|{
literal|"ns"
block|,
literal|0xc
block|}
block|,
block|{
literal|"nv"
block|,
literal|0x8
block|}
block|,
block|{
literal|"nz"
block|,
literal|0xa
block|}
block|,
block|{
literal|"p"
block|,
literal|0xc
block|}
block|,
block|{
literal|"s"
block|,
literal|0x4
block|}
block|,
block|{
literal|"sa"
block|,
literal|0xd
block|}
block|,
block|{
literal|"t"
block|,
literal|0x5
block|}
block|,
block|{
literal|"v"
block|,
literal|0x0
block|}
block|,
block|{
literal|"z"
block|,
literal|0x2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CC_NAME_CNT
define|\
value|(sizeof (cc_names) / sizeof (struct reg_name))
end_define

begin_comment
comment|/* Do a binary search of the given register table to see if NAME is a    valid regiter name.  Return the register number from the array on    success, or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
specifier|const
name|struct
name|reg_name
modifier|*
name|regs
parameter_list|,
name|int
name|regcount
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|accept_numbers
parameter_list|)
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* If the register name is a symbol, then evaluate it.  */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If the symbol is an alias for another name then use that. 	 If the symbol is an alias for a number, then return the number.  */
if|if
condition|(
name|symbol_equated_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|symbolP
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|accept_numbers
condition|)
block|{
name|int
name|reg
init|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|31
condition|)
return|return
name|reg
return|;
block|}
comment|/* Otherwise drop through and try parsing name normally.  */
block|}
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Summary of register_name().     in: Input_line_pointer points to 1st char of operand.     out: An expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Summary of system_register_name().     in:  INPUT_LINE_POINTER points to 1st char of operand. 	EXPRESSIONP points to an expression structure to be filled in. 	ACCEPT_NUMBERS is true iff numerical register names may be used. 	ACCEPT_LIST_NAMES is true iff the special names PS and SR may be 	accepted.     out: An expressionS structure in expressionP.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|system_register_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|,
name|bfd_boolean
name|accept_numbers
parameter_list|,
name|bfd_boolean
name|accept_list_names
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|system_registers
argument_list|,
name|SYSREG_NAME_CNT
argument_list|,
name|name
argument_list|,
name|accept_numbers
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|reg_number
operator|<
literal|0
operator|&&
name|accept_numbers
condition|)
block|{
comment|/* Reset input_line pointer.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|reg_number
operator|=
name|strtol
argument_list|(
name|input_line_pointer
argument_list|,
operator|&
name|input_line_pointer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Make sure that the register number is allowable.  */
if|if
condition|(
name|reg_number
operator|<
literal|0
operator|||
operator|(
name|reg_number
operator|>
literal|5
operator|&&
name|reg_number
operator|<
literal|16
operator|)
operator|||
name|reg_number
operator|>
literal|27
condition|)
name|reg_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|accept_list_names
condition|)
block|{
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|system_list_registers
argument_list|,
name|SYSREGLIST_NAME_CNT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Summary of cc_name().     in: INPUT_LINE_POINTER points to 1st char of operand.     out: An expressionS.   	The operand may have been a register: in this case, X_op == O_register,   	X_add_number is set to the register number, and truth is returned.   	Input_line_pointer->(next non-blank) char after operand, or is in   	its original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cc_name
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|cc_names
argument_list|,
name|CC_NAME_CNT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|skip_white_space
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Summary of parse_register_list ().     in: INPUT_LINE_POINTER  points to 1st char of a list of registers.        INSN		   is the partially constructed instruction.        OPERAND		   is the operand being inserted.     out: NULL if the parse completed successfully, otherwise a 	pointer to an error message is returned.  If the parse 	completes the correct bit fields in the instruction 	will be filled in.     Parses register lists with the syntax:       { rX }      { rX, rY }      { rX - rY }      { rX - rY, rZ }      etc     and also parses constant expressions whoes bits indicate the    registers in the lists.  The LSB in the expression refers to    the lowest numbered permissible register in the register list,    and so on upwards.  System registers are considered to be very    high numbers.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_register_list
parameter_list|(
name|unsigned
name|long
modifier|*
name|insn
parameter_list|,
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
specifier|static
name|int
name|type1_regs
index|[
literal|32
index|]
init|=
block|{
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|31
block|,
literal|29
block|,
literal|28
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|27
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|type2_regs
index|[
literal|32
index|]
init|=
block|{
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|31
block|,
literal|29
block|,
literal|28
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|27
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|type3_regs
index|[
literal|32
index|]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
literal|15
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|11
block|,
literal|10
block|,
literal|9
block|,
literal|8
block|}
decl_stmt|;
name|int
modifier|*
name|regs
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* Select a register array to parse.  */
switch|switch
condition|(
name|operand
operator|->
name|shift
condition|)
block|{
case|case
literal|0xffe00001
case|:
name|regs
operator|=
name|type1_regs
expr_stmt|;
break|break;
case|case
literal|0xfff8000f
case|:
name|regs
operator|=
name|type2_regs
expr_stmt|;
break|break;
case|case
literal|0xfff8001f
case|:
name|regs
operator|=
name|type3_regs
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown operand shift: %x\n"
argument_list|)
argument_list|,
name|operand
operator|->
name|shift
argument_list|)
expr_stmt|;
return|return
name|_
argument_list|(
literal|"internal failure in parse_register_list"
argument_list|)
return|;
block|}
name|skip_white_space
argument_list|()
expr_stmt|;
comment|/* If the expression starts with a curly brace it is a register list.      Otherwise it is a constant expression, whoes bits indicate which      registers are to be included in the list.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'{'
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
return|return
name|_
argument_list|(
literal|"constant expression or register list expected"
argument_list|)
return|;
if|if
condition|(
name|regs
operator|==
name|type1_regs
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
literal|0xFFFFF000
condition|)
return|return
name|_
argument_list|(
literal|"high bits set in register list expression"
argument_list|)
return|;
for|for
control|(
name|reg
operator|=
literal|20
init|;
name|reg
operator|<
literal|32
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
operator|(
name|reg
operator|-
literal|20
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
name|reg
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regs
operator|==
name|type2_regs
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
literal|0xFFFE0000
condition|)
return|return
name|_
argument_list|(
literal|"high bits set in register list expression"
argument_list|)
return|;
for|for
control|(
name|reg
operator|=
literal|1
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
operator|(
name|reg
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
name|reg
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|19
operator|)
expr_stmt|;
block|}
else|else
comment|/* regs == type3_regs  */
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
literal|0xFFFE0000
condition|)
return|return
name|_
argument_list|(
literal|"high bits set in register list expression"
argument_list|)
return|;
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
literal|32
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
operator|(
name|reg
operator|-
literal|16
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
name|reg
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|19
operator|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Parse the register list until a terminator (closing curly brace or      new-line) is found.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|register_name
argument_list|(
operator|&
name|exp
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Locate the given register in the list, and if it is there, 	     insert the corresponding bit into the instruction.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
name|exp
operator|.
name|X_add_number
condition|)
block|{
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|32
condition|)
return|return
name|_
argument_list|(
literal|"illegal register included in list"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|system_register_name
argument_list|(
operator|&
name|exp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|regs
operator|==
name|type1_regs
condition|)
block|{
return|return
name|_
argument_list|(
literal|"system registers cannot be included in list"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|regs
operator|==
name|type2_regs
condition|)
return|return
name|_
argument_list|(
literal|"PSW cannot be included in list"
argument_list|)
return|;
else|else
operator|*
name|insn
operator||=
literal|0x8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|<
literal|4
condition|)
operator|*
name|insn
operator||=
literal|0x80000
expr_stmt|;
else|else
return|return
name|_
argument_list|(
literal|"High value system registers cannot be included in list"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'}'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
comment|/* We have encountered a range of registers: rX - rY.  */
name|int
name|j
decl_stmt|;
name|expressionS
name|exp2
decl_stmt|;
comment|/* Skip the dash.  */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Get the second register in the range.  */
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|exp2
argument_list|)
condition|)
block|{
return|return
name|_
argument_list|(
literal|"second register should follow dash in register list"
argument_list|)
return|;
name|exp2
operator|.
name|X_add_number
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
comment|/* Add the rest of the registers in the range.  */
for|for
control|(
name|j
operator|=
name|exp
operator|.
name|X_add_number
operator|+
literal|1
init|;
name|j
operator|<=
name|exp2
operator|.
name|X_add_number
condition|;
name|j
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Locate the given register in the list, and if it is there, 		 insert the corresponding bit into the instruction.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
name|j
condition|)
block|{
operator|*
name|insn
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|32
condition|)
return|return
name|_
argument_list|(
literal|"illegal register included in list"
argument_list|)
return|;
block|}
block|}
else|else
break|break;
name|skip_white_space
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" V850 options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mwarn-signed-overflow    Warn if signed immediate values overflow\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mv850                    The code is targeted at the v850\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mv850e                   The code is targeted at the v850e\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mv850e1                  The code is targeted at the v850e1\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mv850any                 The code is generic, despite any processor specific instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"  -mrelax                   Enable relaxation\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'m'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warn-signed-overflow"
argument_list|)
operator|==
literal|0
condition|)
name|warn_signed_overflows
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warn-unsigned-overflow"
argument_list|)
operator|==
literal|0
condition|)
name|warn_unsigned_overflows
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"v850"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|machine
operator|=
literal|0
expr_stmt|;
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"v850e"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|machine
operator|=
name|bfd_mach_v850e
expr_stmt|;
name|processor_mask
operator|=
name|PROCESSOR_V850E
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"v850e1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|machine
operator|=
name|bfd_mach_v850e1
expr_stmt|;
name|processor_mask
operator|=
name|PROCESSOR_V850E1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"v850any"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Tell the world that this is for any v850 chip.  */
name|machine
operator|=
literal|0
expr_stmt|;
comment|/* But support instructions for the extended versions.  */
name|processor_mask
operator|=
name|PROCESSOR_V850E
expr_stmt|;
name|processor_mask
operator||=
name|PROCESSOR_V850E1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"relax"
argument_list|)
operator|==
literal|0
condition|)
name|v850_relax
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litp
parameter_list|,
name|int
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Very gross.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* This code performs some nasty type punning between the      fr_opcode field of the frag structure (a char *) and the      fx_r_type field of the fix structure (a bfd_reloc_code_real_type)      On a 64bit host this causes problems because these two fields      are not the same size, but since we know that we are only      ever storing small integers in the fields, it is safe to use      a union to convert between them.  */
union|union
name|u
block|{
name|bfd_reloc_code_real_type
name|fx_r_type
decl_stmt|;
name|char
modifier|*
name|fr_opcode
decl_stmt|;
block|}
name|opcode_converter
union|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opcode_converter
operator|.
name|fr_opcode
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* In range conditional or unconditional branch.  */
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
operator|||
name|fragP
operator|->
name|fr_subtype
operator|==
literal|2
condition|)
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
name|opcode_converter
operator|.
name|fx_r_type
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Out of range conditional branch.  Emit a branch around a jump.  */
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
operator|)
decl_stmt|;
comment|/* Reverse the condition of the first branch.  */
name|buffer
index|[
literal|0
index|]
operator|^=
literal|0x08
expr_stmt|;
comment|/* Mask off all the displacement bits.  */
name|buffer
index|[
literal|0
index|]
operator|&=
literal|0x8f
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|&=
literal|0x07
expr_stmt|;
comment|/* Now set the displacement bits so that we branch 	 around the unconditional branch.  */
name|buffer
index|[
literal|0
index|]
operator||=
literal|0x30
expr_stmt|;
comment|/* Now create the unconditional branch + fixup to the final 	 target.  */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
literal|2
argument_list|,
literal|0x00000780
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
name|opcode_converter
operator|.
name|fx_r_type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
block|}
comment|/* Out of range unconditional branch.  Emit a jump.  */
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|3
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|0x00000780
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_UNUSED
operator|+
name|opcode_converter
operator|.
name|fx_r_type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
specifier|const
name|struct
name|v850_opcode
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_CPU
argument_list|,
literal|"v850e1"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|machine
operator|==
operator|-
literal|1
condition|)
name|machine
operator|=
name|bfd_mach_v850e1
expr_stmt|;
if|if
condition|(
name|processor_mask
operator|==
operator|-
literal|1
condition|)
name|processor_mask
operator|=
name|PROCESSOR_V850E1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_CPU
argument_list|,
literal|"v850e"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|machine
operator|==
operator|-
literal|1
condition|)
name|machine
operator|=
name|bfd_mach_v850e
expr_stmt|;
if|if
condition|(
name|processor_mask
operator|==
operator|-
literal|1
condition|)
name|processor_mask
operator|=
name|PROCESSOR_V850E
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_CPU
argument_list|,
literal|"v850"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|machine
operator|==
operator|-
literal|1
condition|)
name|machine
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|processor_mask
operator|==
operator|-
literal|1
condition|)
name|processor_mask
operator|=
name|PROCESSOR_V850
expr_stmt|;
block|}
else|else
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unable to determine default target processor from string: %s"
argument_list|)
argument_list|,
name|TARGET_CPU
argument_list|)
expr_stmt|;
name|v850_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Insert unique names into hash table.  The V850 instruction set      has many identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
name|op
operator|=
name|v850_opcodes
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|op
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|name
expr_stmt|;
name|hash_insert
argument_list|(
name|v850_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
name|op
operator|++
expr_stmt|;
block|}
name|v850_seg_table
index|[
name|BSS_SECTION
index|]
operator|.
name|s
operator|=
name|bss_section
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_lo16
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
operator|-
literal|1
condition|)
return|return
name|BFD_RELOC_V850_LO16_SPLIT_OFFSET
return|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|16
operator|)
operator|&&
operator|!
operator|(
name|operand
operator|->
name|bits
operator|==
literal|15
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|17
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"lo() relocation used on an instruction which does "
literal|"not support it"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
block|}
return|return
name|BFD_RELOC_LO16
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_ctoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_CALLT_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|6
operator|||
name|operand
operator|->
name|shift
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ctoff() relocation used on an instruction which does not support it"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
return|return
name|BFD_RELOC_V850_CALLT_6_7_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_sdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_SDA_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|15
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|17
condition|)
return|return
name|BFD_RELOC_V850_SDA_15_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
operator|-
literal|1
condition|)
return|return
name|BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|16
operator|||
name|operand
operator|->
name|shift
operator|!=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"sdaoff() relocation used on an instruction which does not support it"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BFD_RELOC_64
return|;
comment|/* Used to indicate an error condition.  */
block|}
return|return
name|BFD_RELOC_V850_SDA_16_16_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_zdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
return|return
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|15
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|17
condition|)
return|return
name|BFD_RELOC_V850_ZDA_15_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
operator|-
literal|1
condition|)
return|return
name|BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|16
operator|||
name|operand
operator|->
name|shift
operator|!=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"zdaoff() relocation used on an instruction which does not support it"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Used to indicate an error condition.  */
return|return
name|BFD_RELOC_64
return|;
block|}
return|return
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|handle_tdaoff
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
comment|/* Data item, not an instruction.  */
return|return
name|BFD_RELOC_V850_TDA_7_7_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|6
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|1
condition|)
comment|/* sld.w/sst.w, operand: D8_6.  */
return|return
name|BFD_RELOC_V850_TDA_6_8_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|4
operator|&&
name|operand
operator|->
name|insert
operator|!=
name|NULL
condition|)
comment|/* sld.hu, operand: D5-4.  */
return|return
name|BFD_RELOC_V850_TDA_4_5_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|4
operator|&&
name|operand
operator|->
name|insert
operator|==
name|NULL
condition|)
comment|/* sld.bu, operand: D4.   */
return|return
name|BFD_RELOC_V850_TDA_4_4_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|16
condition|)
comment|/* set1& chums, operands: D16.  */
return|return
name|BFD_RELOC_V850_TDA_16_16_OFFSET
return|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|7
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"tdaoff() relocation used on an instruction which does not support it"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Used to indicate an error condition.  */
return|return
name|BFD_RELOC_64
return|;
block|}
return|return
name|operand
operator|->
name|insert
operator|!=
name|NULL
condition|?
name|BFD_RELOC_V850_TDA_7_8_OFFSET
comment|/* sld.h/sst.h, operand: D8_7.  */
else|:
name|BFD_RELOC_V850_TDA_7_7_OFFSET
return|;
comment|/* sld.b/sst.b, operand: D7.    */
block|}
end_function

begin_comment
comment|/* Warning: The code in this function relies upon the definitions    in the v850_operands[] array (defined in opcodes/v850-opc.c)    matching the hard coded values contained herein.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|v850_reloc_prefix
parameter_list|(
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|)
block|{
name|bfd_boolean
name|paren_skipped
init|=
name|FALSE
decl_stmt|;
comment|/* Skip leading opening parenthesis.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'('
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|paren_skipped
operator|=
name|TRUE
expr_stmt|;
block|}
define|#
directive|define
name|CHECK_
parameter_list|(
name|name
parameter_list|,
name|reloc
parameter_list|)
define|\
value|if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)	\     {									\       input_line_pointer += strlen (name);				\       return reloc;							\     }
name|CHECK_
argument_list|(
literal|"hi0"
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"hi"
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"lo"
argument_list|,
name|handle_lo16
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"sdaoff"
argument_list|,
name|handle_sdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"zdaoff"
argument_list|,
name|handle_zdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"tdaoff"
argument_list|,
name|handle_tdaoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"hilo"
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|CHECK_
argument_list|(
literal|"ctoff"
argument_list|,
name|handle_ctoff
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore skipped parenthesis.  */
if|if
condition|(
name|paren_skipped
condition|)
operator|--
name|input_line_pointer
expr_stmt|;
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|v850_insert_operand
parameter_list|(
name|unsigned
name|long
name|insn
parameter_list|,
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
parameter_list|,
name|offsetT
name|val
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
name|operand
operator|->
name|insert
argument_list|(
name|insn
argument_list|,
name|val
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_signed_overflows
operator|&&
name|strstr
argument_list|(
name|message
argument_list|,
literal|"out of range"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip warning...  */
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|warn_unsigned_overflows
operator|&&
name|strstr
argument_list|(
name|message
argument_list|,
literal|"out of range"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip warning...  */
block|}
elseif|else
if|if
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|warn_signed_overflows
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|warn_unsigned_overflows
condition|)
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|val
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* Restore min and mix to expected values for decimal ranges.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_signed_overflows
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
operator|)
operator|&&
operator|!
name|warn_unsigned_overflows
condition|)
name|min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"operand"
argument_list|)
argument_list|)
expr_stmt|;
name|as_bad_value_out_of_range
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
operator|(
name|offsetT
operator|)
name|min
argument_list|,
operator|(
name|offsetT
operator|)
name|max
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|copy_of_instruction
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|start_of_operands
decl_stmt|;
name|struct
name|v850_opcode
modifier|*
name|opcode
decl_stmt|;
name|struct
name|v850_opcode
modifier|*
name|next_opcode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|next_opindex
decl_stmt|;
name|int
name|relaxable
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|insn_size
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
decl_stmt|;
name|bfd_boolean
name|extra_data_after_insn
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|extra_data_len
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|extra_data
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|saved_input_line_pointer
decl_stmt|;
name|strncpy
argument_list|(
name|copy_of_instruction
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|copy_of_instruction
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the first opcode with the proper name.  */
name|opcode
operator|=
operator|(
expr|struct
name|v850_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|v850_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
name|start_of_operands
operator|=
name|str
expr_stmt|;
name|saved_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|processors
operator|&
name|processor_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"Target processor does not support this instruction."
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|relaxable
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|extra_data_after_insn
operator|=
name|FALSE
expr_stmt|;
name|input_line_pointer
operator|=
name|str
operator|=
name|start_of_operands
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
if|if
condition|(
name|next_opindex
operator|==
literal|0
condition|)
name|operand
operator|=
operator|&
name|v850_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
else|else
block|{
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|next_opindex
index|]
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
block|}
name|errmsg
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_RELAX
condition|)
name|relaxable
operator|=
literal|1
expr_stmt|;
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* lo(), hi(), hi0(), etc...  */
if|if
condition|(
operator|(
name|reloc
operator|=
name|v850_reloc_prefix
argument_list|(
name|operand
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* This is a fake reloc, used to indicate an error condition.  */
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_64
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
case|:
comment|/* To cope with "not1 7, zdaoff(0xfffff006)[r0]" 			 and the like.  */
comment|/* Fall through.  */
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_V850_LO16_SPLIT_OFFSET
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|ex
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_HI16
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_HI16_S
case|:
block|{
comment|/* Truncate, then sign extend the value.  */
name|int
name|temp
init|=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
decl_stmt|;
name|temp
operator|+=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|SEXT16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850E_IMMEDIATE32
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"immediate operand is too large"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|extra_data_after_insn
operator|=
name|TRUE
expr_stmt|;
name|extra_data_len
operator|=
literal|4
expr_stmt|;
name|extra_data
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reloc: %d\n"
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"AAARG -> unhandled constant reloc"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|>
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
name|fc
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_32
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850E_IMMEDIATE32
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"immediate operand is too large"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|extra_data_after_insn
operator|=
name|TRUE
expr_stmt|;
name|extra_data_len
operator|=
literal|4
expr_stmt|;
name|extra_data
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|>
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
name|fc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"invalid register name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_NOT_R0
operator|)
operator|&&
name|ex
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"register r0 cannot be used here"
argument_list|)
expr_stmt|;
comment|/* Force an error message to be generated by 			 skipping over any following potential matches 			 for this opcode.  */
name|opcode
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SRG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|system_register_name
argument_list|(
operator|&
name|ex
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"invalid system register name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_EP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|c
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"ep"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|start
argument_list|,
literal|"r30"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Put things back the way we found them.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
name|errmsg
operator|=
name|_
argument_list|(
literal|"expected EP register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
condition|)
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_CC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cc_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"invalid condition code name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850E_PUSH_POP
condition|)
block|{
name|errmsg
operator|=
name|parse_register_list
argument_list|(
operator|&
name|insn
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* The parse_register_list() function has already done 		     everything, so fake a dummy expression.  */
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850E_IMMEDIATE16
condition|)
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|&
literal|0xffff0000
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|&
literal|0xffff
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"constant too big to fit into instruction"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x001fffc0
operator|)
operator|==
literal|0x00130780
condition|)
name|ex
operator|.
name|X_add_number
operator|>>=
literal|16
expr_stmt|;
else|else
name|errmsg
operator|=
name|_
argument_list|(
literal|"constant too big to fit into instruction"
argument_list|)
expr_stmt|;
block|}
name|extra_data_after_insn
operator|=
name|TRUE
expr_stmt|;
name|extra_data_len
operator|=
literal|2
expr_stmt|;
name|extra_data
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850E_IMMEDIATE32
condition|)
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
name|extra_data_after_insn
operator|=
name|TRUE
expr_stmt|;
name|extra_data_len
operator|=
literal|4
expr_stmt|;
name|extra_data
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|exists
init|=
literal|0
decl_stmt|;
comment|/* It is possible that an alias has been defined that 		     matches a register name.  For example the code may 		     include a ".set ZERO, 0" directive, which matches 		     the register name "zero".  Attempt to reparse the 		     field as an expression, and only complain if we 		     cannot generate a constant.  */
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbol_find
argument_list|(
name|str
argument_list|)
operator|!=
name|NULL
condition|)
name|exists
operator|=
literal|1
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* If this register is actually occurring too early on 			 the parsing of the instruction, (because another 			 field is missing) then report this.  */
if|if
condition|(
name|opindex_ptr
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|v850_operands
index|[
name|opindex_ptr
index|[
literal|1
index|]
index|]
operator|.
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"syntax error: value is missing before the register name"
argument_list|)
expr_stmt|;
else|else
name|errmsg
operator|=
name|_
argument_list|(
literal|"syntax error: register not expected"
argument_list|)
expr_stmt|;
comment|/* If we created a symbol in the process of this 			 test then delete it now, so that it will not 			 be output with the real symbols...  */
if|if
condition|(
name|exists
operator|==
literal|0
operator|&&
name|ex
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|symbol_remove
argument_list|(
name|ex
operator|.
name|X_add_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|system_register_name
argument_list|(
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SRG
operator|)
operator|==
literal|0
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"syntax error: system register not expected"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cc_name
argument_list|(
operator|&
name|ex
argument_list|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_CC
operator|)
operator|==
literal|0
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"syntax error: condition code not expected"
argument_list|)
expr_stmt|;
else|else
block|{
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
comment|/* Special case: 		     If we are assembling a MOV instruction and the immediate 		     value does not fit into the bits available then create a 		     fake error so that the next MOV instruction will be 		     selected.  This one has a 32 bit immediate field.  */
if|if
condition|(
operator|(
operator|(
name|insn
operator|&
literal|0x07e0
operator|)
operator|==
literal|0x0200
operator|)
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|5
comment|/* Do not match the CALLT instruction.  */
operator|&&
name|ex
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|ex
operator|.
name|X_add_number
operator|<
operator|(
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
name|ex
operator|.
name|X_add_number
operator|>
operator|(
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|errmsg
operator|=
name|_
argument_list|(
literal|"immediate operand is too large"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errmsg
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|ex
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_absent
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
name|O_register
case|:
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|V850_OPERAND_REG
operator||
name|V850_OPERAND_SRG
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errmsg
operator|=
name|_
argument_list|(
literal|"invalid operand"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|copy_of_instruction
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|copy_of_instruction
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
break|break;
block|}
block|}
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|','
operator|||
operator|*
name|str
operator|==
literal|'['
operator|||
operator|*
name|str
operator|==
literal|']'
operator|||
operator|*
name|str
operator|==
literal|')'
condition|)
operator|++
name|str
expr_stmt|;
block|}
name|match
operator|=
literal|1
expr_stmt|;
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|next_opcode
operator|=
name|opcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next_opcode
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|next_opcode
operator|->
name|name
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcode
operator|=
name|next_opcode
expr_stmt|;
comment|/* Skip versions that are not supported by the target 		 processor.  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|processors
operator|&
name|processor_mask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
continue|continue;
block|}
name|as_bad
argument_list|(
literal|"%s: %s"
argument_list|,
name|copy_of_instruction
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|']'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
return|return;
block|}
break|break;
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
comment|/* xgettext:c-format  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* Tie dwarf2 debug info to the address at the start of the insn.      We can't do this after the insn has been output as the current      frag may have been closed off.  eg. by frag_var.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Write out the instruction.  */
if|if
condition|(
name|relaxable
operator|&&
name|fc
operator|>
literal|0
condition|)
block|{
comment|/* On a 64-bit host the size of an 'int' is not the same 	 as the size of a pointer, so we need a union to convert 	 the opindex field of the fr_cgen structure into a char * 	 so that it can be stored in the frag.  We do not have 	 to worry about loosing accuracy as we are not going to 	 be even close to the 32bit limit of the int.  */
union|union
block|{
name|int
name|opindex
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
name|opindex_converter
union|;
name|opindex_converter
operator|.
name|opindex
operator|=
name|fixups
index|[
literal|0
index|]
operator|.
name|opindex
expr_stmt|;
name|insn_size
operator|=
literal|2
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
literal|"br"
argument_list|)
condition|)
block|{
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|opindex_converter
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|6
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|fixups
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|opindex_converter
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Four byte insns have an opcode with the two high bits on.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0600
operator|)
operator|==
literal|0x0600
condition|)
name|insn_size
operator|=
literal|4
expr_stmt|;
else|else
name|insn_size
operator|=
literal|2
expr_stmt|;
comment|/* Special case: 32 bit MOV.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|==
literal|0x0620
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
name|insn_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_data_after_insn
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
name|extra_data_len
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|extra_data
argument_list|,
name|extra_data_len
argument_list|)
expr_stmt|;
name|extra_data_after_insn
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* Create any fixups.  At this point we do not use a      bfd_reloc_code_real_type, but instead just use the      BFD_RELOC_UNUSED plus the operand index.  This lets us easily      handle fixups for any operand type, although that is admittedly      not a very exciting feature.  We pick a BFD reloc type in      md_apply_fix.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
name|reloc
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|address
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
comment|/* XXX This will abort on an R_V850_8 reloc - 	     is this reloc actually used?  */
if|if
condition|(
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|address
operator|=
operator|(
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|+
name|insn_size
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_32
condition|)
name|address
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|address
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|tc_fix_data
operator|=
operator|(
name|void
operator|*
operator|)
name|operand
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_V850_LO16_SPLIT_OFFSET
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_DISP
operator|)
operator|!=
literal|0
argument_list|,
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|=
name|saved_input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGCALL
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGJUMP
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_ALIGN
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
operator|&&
name|fixp
operator|->
name|fx_pcrel
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
block|}
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
comment|/* xgettext:c-format  */
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|void
name|v850_handle_align
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|)
block|{
if|if
condition|(
name|v850_relax
operator|&&
name|frag
operator|->
name|fr_type
operator|==
name|rs_align
operator|&&
name|frag
operator|->
name|fr_address
operator|+
name|frag
operator|->
name|fr_fix
operator|>
literal|0
operator|&&
name|frag
operator|->
name|fr_offset
operator|>
literal|1
operator|&&
name|now_seg
operator|!=
name|bss_section
operator|&&
name|now_seg
operator|!=
name|v850_seg_table
index|[
name|SBSS_SECTION
index|]
operator|.
name|s
operator|&&
name|now_seg
operator|!=
name|v850_seg_table
index|[
name|TBSS_SECTION
index|]
operator|.
name|s
operator|&&
name|now_seg
operator|!=
name|v850_seg_table
index|[
name|ZBSS_SECTION
index|]
operator|.
name|s
condition|)
name|fix_new
argument_list|(
name|frag
argument_list|,
name|frag
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
operator|&
name|abs_symbol
argument_list|,
name|frag
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_V850_ALIGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return current size of variable part of frag.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|md_relax_table
index|[
name|fragp
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_function
name|long
name|v850_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|,
name|segT
name|section
parameter_list|)
block|{
comment|/* If the symbol is undefined, or in a section other than our own,      or it is weak (in which case it may well be in another section,      then let the linker figure it out.  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|section
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valueP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|valueT
name|value
init|=
operator|*
name|valueP
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGCALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGJUMP
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
operator|,
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_addnumber
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
comment|/* We don't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|v850_operands
index|[
name|opindex
index|]
expr_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  	 Note the instruction has been stored in little endian 	 format!  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|insn
operator|=
name|v850_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
comment|/* Nothing else to do here.  */
return|return;
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into relocs.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|22
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_V850_22_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|9
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_V850_9_PCREL
expr_stmt|;
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* We still have to insert the value into memory!  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|tc_fix_data
operator|!=
name|NULL
operator|&&
operator|(
operator|(
expr|struct
name|v850_operand
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
operator|)
operator|->
name|insert
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|struct
name|v850_operand
modifier|*
name|operand
init|=
operator|(
expr|struct
name|v850_operand
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* The variable "where" currently points at the exact point inside 	     the insn where we need to insert the value.  But we need to 	     extract the entire insn so we probably need to move "where" 	     back a few bytes.  */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|where
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|)
name|where
operator|-=
literal|3
expr_stmt|;
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
comment|/* Use the operand's insertion procedure, if present, in order to 	     make sure that the value is correctly stored in the insn.  */
name|insn
operator|=
name|operand
operator|->
name|insert
argument_list|(
name|insn
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
comment|/* Ignore message even if it is set.  */
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LO16_SPLIT_OFFSET
condition|)
name|bfd_putl32
argument_list|(
operator|(
operator|(
name|value
operator|<<
literal|16
operator|)
operator|&
literal|0xfffe0000
operator|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|5
operator|)
operator|&
literal|0x20
operator|)
operator||
operator|(
name|bfd_getl32
argument_list|(
name|where
argument_list|)
operator|&
operator|~
literal|0xfffe0020
operator|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|)
operator|*
name|where
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|)
name|bfd_putl16
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
condition|)
name|bfd_putl32
argument_list|(
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a cons expression.  We have to handle hi(), lo(), etc    on the v850.  */
end_comment

begin_function
name|void
name|parse_cons_expression_v850
parameter_list|(
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
comment|/* See if there's a reloc prefix like hi() we have to handle.  */
name|hold_cons_reloc
operator|=
name|v850_reloc_prefix
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do normal expression parsing.  */
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fixup for a cons expression.  If parse_cons_expression_v850    found a reloc prefix, then we use that reloc, else we choose an    appropriate one based on the size of the expression.  */
end_comment

begin_function
name|void
name|cons_fix_new_v850
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
if|if
condition|(
name|hold_cons_reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|hold_cons_reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|!=
name|NULL
condition|)
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|hold_cons_reloc
argument_list|)
expr_stmt|;
else|else
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hold_cons_reloc
argument_list|)
expr_stmt|;
name|hold_cons_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|v850_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Don't adjust function names.  */
if|if
condition|(
name|S_IS_FUNCTION
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|v850_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGCALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_LONGJUMP
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|v850_relax
operator|&&
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_ALIGN
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_22_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_V850_9_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|>=
name|BFD_RELOC_UNUSED
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fixP
argument_list|)
return|;
block|}
end_function

end_unit

