begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* b.out object file format    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2,    or (at your option) any later version.     GAS is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* In: segT   Out: N_TYPE bits  */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
name|N_ABS
block|,
name|N_TEXT
block|,
name|N_DATA
block|,
name|N_BSS
block|,
name|N_UNDF
block|,
comment|/* unknown  */
name|N_UNDF
block|,
comment|/* error  */
name|N_UNDF
block|,
comment|/* expression  */
name|N_UNDF
block|,
comment|/* debug  */
name|N_UNDF
block|,
comment|/* ntv  */
name|N_UNDF
block|,
comment|/* ptv  */
name|N_REGISTER
block|,
comment|/* register  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|segT
name|N_TYPE_seg
index|[
name|N_TYPE
operator|+
literal|2
index|]
init|=
block|{
comment|/* N_TYPE == 0x1E = 32-2  */
name|SEG_UNKNOWN
block|,
comment|/* N_UNDF == 0  */
name|SEG_GOOF
block|,
name|SEG_ABSOLUTE
block|,
comment|/* N_ABS == 2  */
name|SEG_GOOF
block|,
name|SEG_TEXT
block|,
comment|/* N_TEXT == 4  */
name|SEG_GOOF
block|,
name|SEG_DATA
block|,
comment|/* N_DATA == 6  */
name|SEG_GOOF
block|,
name|SEG_BSS
block|,
comment|/* N_BSS == 8  */
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_REGISTER
block|,
comment|/* dummy N_REGISTER for regs = 30  */
name|SEG_GOOF
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_bout_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
block|{
literal|"line"
block|,
name|obj_bout_line
block|,
literal|0
block|}
block|,
comment|/* Source code line number.  */
comment|/* coff debugging directives.  Currently ignored silently.  */
block|{
literal|"def"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* other stuff we don't handle */
block|{
literal|"ABORT"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
comment|/* End sentinel.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocation.  */
end_comment

begin_comment
comment|/* Crawl along a fixS chain. Emit the segment's relocations.  */
end_comment

begin_function
name|void
name|obj_emit_relocations
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Fixup chain for this segment.  */
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|==
literal|0
operator|||
name|fixP
operator|->
name|fx_r_type
operator|!=
name|NO_RELOC
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
name|sym
operator|=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|sym
expr_stmt|;
name|tc_bout_fix_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|fixP
argument_list|,
name|segment_address_in_file
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
block|}
comment|/* if there's a symbol  */
block|}
comment|/* for each fixup  */
block|}
end_function

begin_comment
comment|/* Aout file generation& utilities .  */
end_comment

begin_comment
comment|/* Convert a lvalue to machine dependent data.  */
end_comment

begin_function
name|void
name|obj_header_append
parameter_list|(
name|where
parameter_list|,
name|headers
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
comment|/* Always leave in host byte order.  */
name|headers
operator|->
name|header
operator|.
name|a_talign
operator|=
name|section_alignment
index|[
name|SEG_TEXT
index|]
expr_stmt|;
comment|/* Force to at least 2.  */
if|if
condition|(
name|headers
operator|->
name|header
operator|.
name|a_talign
operator|<
literal|2
condition|)
block|{
name|headers
operator|->
name|header
operator|.
name|a_talign
operator|=
literal|2
expr_stmt|;
block|}
name|headers
operator|->
name|header
operator|.
name|a_dalign
operator|=
name|section_alignment
index|[
name|SEG_DATA
index|]
expr_stmt|;
name|headers
operator|->
name|header
operator|.
name|a_balign
operator|=
name|section_alignment
index|[
name|SEG_BSS
index|]
expr_stmt|;
name|headers
operator|->
name|header
operator|.
name|a_tload
operator|=
literal|0
expr_stmt|;
name|headers
operator|->
name|header
operator|.
name|a_dload
operator|=
name|md_section_align
argument_list|(
name|SEG_DATA
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
name|headers
operator|->
name|header
operator|.
name|a_relaxable
operator|=
name|linkrelax
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_magic
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_magic
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_tload
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_tload
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_tload
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_dload
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_dload
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_dload
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_talign
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_talign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_talign
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_dalign
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_dalign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_dalign
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_balign
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_balign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_balign
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|header
operator|.
name|a_relaxable
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_relaxable
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
operator|.
name|a_relaxable
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|headers
operator|->
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! CROSS_COMPILE */
block|}
end_function

begin_function
name|void
name|obj_symbol_to_chars
parameter_list|(
name|where
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
operator|)
argument_list|,
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|S_GET_OFFSET
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|)
argument_list|,
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_value
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_emit_symbols
parameter_list|(
name|where
parameter_list|,
name|symbol_rootP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Emit all symbols left in the symbol chain.  */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Used to save the offset of the name.  It is used to point to 	 the string in memory but must be a file offset.  */
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|)
expr_stmt|;
comment|/* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|obj_symbol_to_chars
argument_list|(
name|where
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_bout_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Assume delimiter is part of expression.  */
comment|/* BSD4.2 as fails with delightful bug, so we are not being      incompatible here.  */
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|int
call|)
argument_list|(
name|get_absolute_expression
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_read_begin_hook
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|obj_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|symbolS
modifier|*
modifier|*
name|symbolPP
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|tc_crawl_symbol_chain
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|symbolPP
operator|=
operator|&
name|symbol_rootP
expr_stmt|;
comment|/* -> last symbol chain link.  */
while|while
condition|(
operator|(
name|symbolP
operator|=
operator|*
name|symbolPP
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flag_readonly_data_in_text
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
block|}
comment|/* if pushing data into text  */
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* Skip symbols which were equated to undefined or common 	 symbols.  */
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* OK, here is how we decide which symbols go out into the 	 brave new symtab.  Symbols that do are:  	 * symbols with no name (stabd's?) 	 * symbols with debug info in their N_TYPE  	 Symbols that don't are: 	 * symbols that are registers 	 * symbols with \1 as their 3rd character (numeric labels) 	 * "local labels" as defined by S_LOCAL_NAME(name) 	 if the -L switch was passed to gas.  	 All other symbols are output.  We complain if a deleted 	 symbol was marked external.  */
if|if
condition|(
literal|1
operator|&&
operator|!
name|S_IS_REGISTER
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
operator|!
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
ifdef|#
directive|ifdef
name|TC_I960
comment|/* FIXME-SOON this ifdef seems highly dubious to me.  xoxorich.  */
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
endif|#
directive|endif
comment|/* TC_I960 */
operator|||
operator|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\001'
operator|&&
operator|(
name|flag_keep_locals
operator|||
operator|!
name|S_LOCAL_NAME
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
operator|++
expr_stmt|;
comment|/* The + 1 after strlen account for the \0 at the end of 	     each string.  */
if|if
condition|(
operator|!
name|S_IS_STABD
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Ordinary case.  */
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* .Stabd case.  */
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolPP
operator|=
operator|&
operator|(
name|symbolP
operator|->
name|sy_next
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Local symbol %s never defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Oops.  */
comment|/* Unhook it from the chain.  */
operator|*
name|symbolPP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if this symbol should be in the output  */
block|}
comment|/* for each symbol  */
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|headers
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find strings by crawling along symbol table chain.  */
end_comment

begin_function
name|void
name|obj_emit_strings
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|string_byte_count
argument_list|,
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|string_byte_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
condition|)
name|append
argument_list|(
name|where
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Walk symbol chain.  */
block|}
end_function

end_unit

