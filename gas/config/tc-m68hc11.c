begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-m68hc11.c -- Assembler code for the Motorola 68HC11& 68HC12.    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Written by Stephane Carrez (stcarrez@nerim.fr)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68hc11.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#*"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATE_CONDITIONAL_BRANCH
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_PC_RELATIVE
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_INDEXED_OFFSET
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_INDEXED_PCREL
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_XBCC_BRANCH
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_CONDITIONAL_BRANCH_6812
value|(6)
end_define

begin_define
define|#
directive|define
name|STATE_BYTE
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_BITS5
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_WORD
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_BITS9
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_LONG
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_BITS16
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_UNDF
value|(3)
end_define

begin_comment
comment|/* Symbol undefined in pass1 */
end_comment

begin_comment
comment|/* This macro has no side-effects.  */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_define
define|#
directive|define
name|RELAX_STATE
parameter_list|(
name|s
parameter_list|)
value|((s)>> 2)
end_define

begin_define
define|#
directive|define
name|RELAX_LENGTH
parameter_list|(
name|s
parameter_list|)
value|((s)& 3)
end_define

begin_define
define|#
directive|define
name|IS_OPCODE
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
value|(((C1)& 0x0FF) == ((C2)& 0x0FF))
end_define

begin_comment
comment|/* This table describes how you change sizes for the various types of variable    size expressions.  This version only supports two kinds.  */
end_comment

begin_comment
comment|/* The fields are:    How far Forward this mode will reach.    How far Backward this mode will reach.    How many bytes this mode will add to the size of the frag.    Which mode to go to if the offset won't fit in this one.  */
end_comment

begin_decl_stmt
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* First entries aren't used.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For no good reason except.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* that the VAX doesn't either.  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for bcc<L>.      These insns are translated into b!cc +3 jmp L.  */
block|{
operator|(
literal|127
operator|)
block|,
operator|(
operator|-
literal|128
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_CONDITIONAL_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for bsr<L> and bra<L>.      These insns are translated into jsr and jmp.  */
block|{
operator|(
literal|127
operator|)
block|,
operator|(
operator|-
literal|128
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_PC_RELATIVE
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for indexed offset: 5-bits, 9-bits, 16-bits.  */
block|{
operator|(
literal|15
operator|)
block|,
operator|(
operator|-
literal|16
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_INDEXED_OFFSET
argument_list|,
argument|STATE_BITS9
argument_list|)
block|}
block|,
block|{
operator|(
literal|255
operator|)
block|,
operator|(
operator|-
literal|256
operator|)
block|,
literal|1
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_INDEXED_OFFSET
argument_list|,
argument|STATE_BITS16
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for PC relative offset: 5-bits, 9-bits, 16-bits.      For the 9-bit case, there will be a -1 correction to take into      account the new byte that's why the range is -255..256.  */
block|{
operator|(
literal|15
operator|)
block|,
operator|(
operator|-
literal|16
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_INDEXED_PCREL
argument_list|,
argument|STATE_BITS9
argument_list|)
block|}
block|,
block|{
operator|(
literal|256
operator|)
block|,
operator|(
operator|-
literal|255
operator|)
block|,
literal|1
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_INDEXED_PCREL
argument_list|,
argument|STATE_BITS16
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for dbeq/ibeq/tbeq r,<L>:      These insns are translated into db!cc +3 jmp L.  */
block|{
operator|(
literal|255
operator|)
block|,
operator|(
operator|-
literal|256
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_XBCC_BRANCH
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Relax for bcc<L> on 68HC12.      These insns are translated into lbcc<L>.  */
block|{
operator|(
literal|127
operator|)
block|,
operator|(
operator|-
literal|128
operator|)
block|,
literal|0
block|,
name|ENCODE_RELAX
argument_list|(
argument|STATE_CONDITIONAL_BRANCH_6812
argument_list|,
argument|STATE_WORD
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 68HC11 and 68HC12 registers.  They are numbered according to the 68HC12.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|register_id
block|{
name|REG_NONE
init|=
operator|-
literal|1
block|,
name|REG_A
init|=
literal|0
block|,
name|REG_B
init|=
literal|1
block|,
name|REG_CCR
init|=
literal|2
block|,
name|REG_D
init|=
literal|4
block|,
name|REG_X
init|=
literal|5
block|,
name|REG_Y
init|=
literal|6
block|,
name|REG_SP
init|=
literal|7
block|,
name|REG_PC
init|=
literal|8
block|}
name|register_id
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|operand
block|{
name|expressionS
name|exp
decl_stmt|;
name|register_id
name|reg1
decl_stmt|;
name|register_id
name|reg2
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
name|operand
typedef|;
end_typedef

begin_struct
struct|struct
name|m68hc11_opcode_def
block|{
name|long
name|format
decl_stmt|;
name|int
name|min_operands
decl_stmt|;
name|int
name|max_operands
decl_stmt|;
name|int
name|nb_modes
decl_stmt|;
name|int
name|used
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|m68hc11_opcode_def
modifier|*
name|m68hc11_opcode_defs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|m68hc11_nb_opcode_defs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|alias
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
block|}
name|alias
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|alias
name|alias_opcodes
index|[]
init|=
block|{
block|{
literal|"cpd"
block|,
literal|"cmpd"
block|}
block|,
block|{
literal|"cpx"
block|,
literal|"cmpx"
block|}
block|,
block|{
literal|"cpy"
block|,
literal|"cmpy"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|register_id
name|reg_name_search
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|register_id
name|register_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_opcode
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|,
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|print_opcode_format
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_whites
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_range
parameter_list|(
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_opcode_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_default_target
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_insn_format
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_operand
parameter_list|(
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup8
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup16
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup24
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
name|convert_branch
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|m68hc11_new_insn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_dbranch_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|,
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_indexed_byte
parameter_list|(
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_reg_mode
parameter_list|(
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|m68hc11_opcode
modifier|*
name|find
parameter_list|(
name|struct
name|m68hc11_opcode_def
modifier|*
parameter_list|,
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|m68hc11_opcode
modifier|*
name|find_opcode
parameter_list|(
name|struct
name|m68hc11_opcode_def
modifier|*
parameter_list|,
name|operand
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_jump_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|,
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
parameter_list|,
name|operand
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relaxable_symbol
parameter_list|(
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pseudo op to indicate a relax group.  */
end_comment

begin_function_decl
specifier|static
name|void
name|s_m68hc11_relax
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pseudo op to control the ELF flags.  */
end_comment

begin_function_decl
specifier|static
name|void
name|s_m68hc11_mode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Mark the symbols with STO_M68HC12_FAR to indicate the functions    are using 'rtc' for returning.  It is necessary to use 'call'    to invoke them.  This is also used by the debugger to correctly    find the stack frame.  */
end_comment

begin_function_decl
specifier|static
name|void
name|s_m68hc11_mark_symbol
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Controls whether relative branches can be turned into long branches.    When the relative offset is too large, the insn are changed:     bra -> jmp     bsr -> jsr     bcc -> b!cc +3            jmp L     dbcc -> db!cc +3             jmp L    Setting the flag forbidds this.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|flag_fixed_branches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force to use long jumps (absolute) instead of relative branches.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|flag_force_long_jumps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Change the direct addressing mode into an absolute addressing mode    when the insn does not support direct addressing.    For example, "clr *ZD0" is normally not possible and is changed    into "clr ZDO".  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|flag_strict_direct_addressing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an opcode has invalid operand, print out the syntax of the opcode    to stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|flag_print_insn_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dumps the list of instructions with syntax and then exit:    1 -> Only dumps the list (sorted by name)    2 -> Generate an example (or test) that can be compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|flag_print_opcodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|m68hc11_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current cpu (either cpu6811 or cpu6812).  This is determined automagically    by 'get_default_target' by looking at default BFD vector.  This is overridden    with the -m<cpu> option.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_architecture
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default cpu determined by 'get_default_target'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of opcodes in the sorted table (filtered by current cpu).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_opcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opcodes sorted by name and filtered by current cpu.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m68hc11_opcode
modifier|*
name|m68hc11_sorted_opcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF flags to set in the output file header.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|elf_flags
init|=
name|E_M68HC11_F64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the machine dependent pseudo-ops.  These are included so    the assembler can work on the output from the SUN C compiler, which    generates these.  */
end_comment

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* The following pseudo-ops are supported for MRI compatibility.  */
block|{
literal|"fcb"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"fdb"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"fcc"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"rmb"
block|,
name|s_space
block|,
literal|0
block|}
block|,
comment|/* Motorola ALIS.  */
block|{
literal|"xrefb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Same as xref  */
comment|/* Gcc driven relaxation.  */
block|{
literal|"relax"
block|,
name|s_m68hc11_relax
block|,
literal|0
block|}
block|,
comment|/* .mode instruction (ala SH).  */
block|{
literal|"mode"
block|,
name|s_m68hc11_mode
block|,
literal|0
block|}
block|,
comment|/* .far instruction.  */
block|{
literal|"far"
block|,
name|s_m68hc11_mark_symbol
block|,
name|STO_M68HC12_FAR
block|}
block|,
comment|/* .interrupt instruction.  */
block|{
literal|"interrupt"
block|,
name|s_m68hc11_mark_symbol
block|,
name|STO_M68HC12_INTERRUPT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Options and initialization.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"Sm:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_FORCE_LONG_BRANCH
value|(OPTION_MD_BASE)
block|{
literal|"force-long-branches"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FORCE_LONG_BRANCH
block|}
block|,
block|{
literal|"force-long-branchs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FORCE_LONG_BRANCH
block|}
block|,
comment|/* Misspelt version kept for backwards compatibility.  */
define|#
directive|define
name|OPTION_SHORT_BRANCHES
value|(OPTION_MD_BASE + 1)
block|{
literal|"short-branches"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHORT_BRANCHES
block|}
block|,
block|{
literal|"short-branchs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHORT_BRANCHES
block|}
block|,
comment|/* Misspelt version kept for backwards compatibility.  */
define|#
directive|define
name|OPTION_STRICT_DIRECT_MODE
value|(OPTION_MD_BASE + 2)
block|{
literal|"strict-direct-mode"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STRICT_DIRECT_MODE
block|}
block|,
define|#
directive|define
name|OPTION_PRINT_INSN_SYNTAX
value|(OPTION_MD_BASE + 3)
block|{
literal|"print-insn-syntax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PRINT_INSN_SYNTAX
block|}
block|,
define|#
directive|define
name|OPTION_PRINT_OPCODES
value|(OPTION_MD_BASE + 4)
block|{
literal|"print-opcodes"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PRINT_OPCODES
block|}
block|,
define|#
directive|define
name|OPTION_GENERATE_EXAMPLE
value|(OPTION_MD_BASE + 5)
block|{
literal|"generate-example"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GENERATE_EXAMPLE
block|}
block|,
define|#
directive|define
name|OPTION_MSHORT
value|(OPTION_MD_BASE + 6)
block|{
literal|"mshort"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MSHORT
block|}
block|,
define|#
directive|define
name|OPTION_MLONG
value|(OPTION_MD_BASE + 7)
block|{
literal|"mlong"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MLONG
block|}
block|,
define|#
directive|define
name|OPTION_MSHORT_DOUBLE
value|(OPTION_MD_BASE + 8)
block|{
literal|"mshort-double"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MSHORT_DOUBLE
block|}
block|,
define|#
directive|define
name|OPTION_MLONG_DOUBLE
value|(OPTION_MD_BASE + 9)
block|{
literal|"mlong-double"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MLONG_DOUBLE
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the target cpu for the assembler.  This is based on the configure    options and on the -m68hc11/-m68hc12 option.  If no option is specified,    we must get the default.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|m68hc11_arch_format
parameter_list|(
name|void
parameter_list|)
block|{
name|get_default_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
return|return
literal|"elf32-m68hc11"
return|;
else|else
return|return
literal|"elf32-m68hc12"
return|;
block|}
end_function

begin_function
name|enum
name|bfd_architecture
name|m68hc11_arch
parameter_list|(
name|void
parameter_list|)
block|{
name|get_default_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
return|return
name|bfd_arch_m68hc11
return|;
else|else
return|return
name|bfd_arch_m68hc12
return|;
block|}
end_function

begin_function
name|int
name|m68hc11_mach
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Listing header selected according to cpu.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|m68hc11_listing_header
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
return|return
literal|"M68HC11 GAS "
return|;
else|else
return|return
literal|"M68HC12 GAS "
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|get_default_target
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ Motorola 68HC11/68HC12/68HCS12 options:\n\   -m68hc11 | -m68hc12 |\n\   -m68hcs12               specify the processor [default %s]\n\   -mshort                 use 16-bit int ABI (default)\n\   -mlong                  use 32-bit int ABI\n\   -mshort-double          use 32-bit double ABI\n\   -mlong-double           use 64-bit double ABI (default)\n\   --force-long-branches   always turn relative branches into absolute ones\n\   -S,--short-branches     do not turn relative branches into absolute ones\n\                           when the offset is out of range\n\   --strict-direct-mode    do not turn the direct mode into extended mode\n\                           when the instruction does not support direct mode\n\   --print-insn-syntax     print the syntax of instruction in case of error\n\   --print-opcodes         print the list of instructions with syntax\n\   --generate-example      generate an example of each instruction\n\                           (used for testing)\n"
argument_list|)
argument_list|,
name|default_cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to identify the default target based on the BFD library.  */
end_comment

begin_function
specifier|static
name|void
name|get_default_target
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
name|bfd
name|abfd
decl_stmt|;
if|if
condition|(
name|current_architecture
operator|!=
literal|0
condition|)
return|return;
name|default_cpu
operator|=
literal|"unknown"
expr_stmt|;
name|target
operator|=
name|bfd_find_target
argument_list|(
literal|0
argument_list|,
operator|&
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|target
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target
operator|->
name|name
argument_list|,
literal|"elf32-m68hc12"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_architecture
operator|=
name|cpu6812
expr_stmt|;
name|default_cpu
operator|=
literal|"m68hc12"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target
operator|->
name|name
argument_list|,
literal|"elf32-m68hc11"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_architecture
operator|=
name|cpu6811
expr_stmt|;
name|default_cpu
operator|=
literal|"m68hc11"
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Default target `%s' is not supported."
argument_list|)
argument_list|,
name|target
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|m68hc11_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
decl_stmt|;
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"opcode table"
argument_list|,
name|m68hc11_hash
argument_list|)
expr_stmt|;
name|opc
operator|=
name|m68hc11_opcode_defs
expr_stmt|;
if|if
condition|(
name|opc
operator|==
literal|0
operator|||
name|m68hc11_nb_opcode_defs
operator|==
literal|0
condition|)
return|return;
comment|/* Dump the opcode statistics table.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Name   # Modes  Min ops  Max ops  Modes mask  # Used\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68hc11_nb_opcode_defs
condition|;
name|i
operator|++
operator|,
name|opc
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%-7.7s  %5d  %7d  %7d  0x%08lx  %7d\n"
argument_list|,
name|opc
operator|->
name|opcode
operator|->
name|name
argument_list|,
name|opc
operator|->
name|nb_modes
argument_list|,
name|opc
operator|->
name|min_operands
argument_list|,
name|opc
operator|->
name|max_operands
argument_list|,
name|opc
operator|->
name|format
argument_list|,
name|opc
operator|->
name|used
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|get_default_target
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* -S means keep external to 2 bit offset rather than 16 bit one.  */
case|case
name|OPTION_SHORT_BRANCHES
case|:
case|case
literal|'S'
case|:
name|flag_fixed_branches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_FORCE_LONG_BRANCH
case|:
name|flag_force_long_jumps
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_PRINT_INSN_SYNTAX
case|:
name|flag_print_insn_syntax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_PRINT_OPCODES
case|:
name|flag_print_opcodes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_STRICT_DIRECT_MODE
case|:
name|flag_strict_direct_addressing
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_GENERATE_EXAMPLE
case|:
name|flag_print_opcodes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OPTION_MSHORT
case|:
name|elf_flags
operator|&=
operator|~
name|E_M68HC11_I32
expr_stmt|;
break|break;
case|case
name|OPTION_MLONG
case|:
name|elf_flags
operator||=
name|E_M68HC11_I32
expr_stmt|;
break|break;
case|case
name|OPTION_MSHORT_DOUBLE
case|:
name|elf_flags
operator|&=
operator|~
name|E_M68HC11_F64
expr_stmt|;
break|break;
case|case
name|OPTION_MLONG_DOUBLE
case|:
name|elf_flags
operator||=
name|E_M68HC11_F64
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"68hc11"
argument_list|)
operator|==
literal|0
condition|)
name|current_architecture
operator|=
name|cpu6811
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"68hc12"
argument_list|)
operator|==
literal|0
condition|)
name|current_architecture
operator|=
name|cpu6812
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"68hcs12"
argument_list|)
operator|==
literal|0
condition|)
name|current_architecture
operator|=
name|cpu6812
operator||
name|cpu6812s
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Option `%s' is not recognized."
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_opcode
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
name|op1
parameter_list|,
name|struct
name|m68hc11_opcode
modifier|*
name|op2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|op1
operator|->
name|name
argument_list|,
name|op2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_CALL_SYMBOL
parameter_list|(
name|MODE
parameter_list|)
define|\
value|(((MODE)& (M6812_OP_PAGE|M6811_OP_IND16)) \   == ((M6812_OP_PAGE|M6811_OP_IND16)))
end_define

begin_comment
comment|/* Initialize the assembler.  Create the opcode hash table    (sorted on the names) with the M6811 opcode table    (from opcode library).  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcodes
decl_stmt|;
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|get_default_target
argument_list|()
expr_stmt|;
name|m68hc11_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Get a writable copy of the opcode table and sort it on the names.  */
name|opcodes
operator|=
operator|(
expr|struct
name|m68hc11_opcode
operator|*
operator|)
name|xmalloc
argument_list|(
name|m68hc11_num_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|m68hc11_opcode
argument_list|)
argument_list|)
expr_stmt|;
name|m68hc11_sorted_opcodes
operator|=
name|opcodes
expr_stmt|;
name|num_opcodes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68hc11_num_opcodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m68hc11_opcodes
index|[
name|i
index|]
operator|.
name|arch
operator|&
name|current_architecture
condition|)
block|{
name|opcodes
index|[
name|num_opcodes
index|]
operator|=
name|m68hc11_opcodes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|opcodes
index|[
name|num_opcodes
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|opcodes
index|[
name|num_opcodes
index|]
operator|.
name|format
operator|&
name|M6811_OP_JUMP_REL
operator|&&
operator|!
operator|(
name|opcodes
index|[
name|num_opcodes
index|]
operator|.
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
condition|)
block|{
name|num_opcodes
operator|++
expr_stmt|;
name|opcodes
index|[
name|num_opcodes
index|]
operator|=
name|m68hc11_opcodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|num_opcodes
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|alias_opcodes
index|[
name|j
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|m68hc11_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|alias_opcodes
index|[
name|j
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opcodes
index|[
name|num_opcodes
index|]
operator|=
name|m68hc11_opcodes
index|[
name|i
index|]
expr_stmt|;
name|opcodes
index|[
name|num_opcodes
index|]
operator|.
name|name
operator|=
name|alias_opcodes
index|[
name|j
index|]
operator|.
name|alias
expr_stmt|;
name|num_opcodes
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|qsort
argument_list|(
name|opcodes
argument_list|,
name|num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68hc11_opcode
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|cmp_opcode
argument_list|)
expr_stmt|;
name|opc
operator|=
operator|(
expr|struct
name|m68hc11_opcode_def
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|m68hc11_opcode_def
argument_list|)
argument_list|)
expr_stmt|;
name|m68hc11_opcode_defs
operator|=
name|opc
operator|--
expr_stmt|;
comment|/* Insert unique names into hash table.  The M6811 instruction set      has several identical opcode names that have different opcodes based      on the operands.  This hash table then provides a quick index to      the first opcode with a particular name in the opcode table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
operator|,
name|opcodes
operator|++
control|)
block|{
name|int
name|expect
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|opcodes
operator|->
name|name
argument_list|)
condition|)
block|{
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|opcodes
operator|->
name|name
expr_stmt|;
name|opc
operator|++
expr_stmt|;
name|opc
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|opc
operator|->
name|min_operands
operator|=
literal|100
expr_stmt|;
name|opc
operator|->
name|max_operands
operator|=
literal|0
expr_stmt|;
name|opc
operator|->
name|nb_modes
operator|=
literal|0
expr_stmt|;
name|opc
operator|->
name|opcode
operator|=
name|opcodes
expr_stmt|;
name|opc
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|hash_insert
argument_list|(
name|m68hc11_hash
argument_list|,
name|opcodes
operator|->
name|name
argument_list|,
name|opc
argument_list|)
expr_stmt|;
block|}
name|opc
operator|->
name|nb_modes
operator|++
expr_stmt|;
name|opc
operator|->
name|format
operator||=
name|opcodes
operator|->
name|format
expr_stmt|;
comment|/* See how many operands this opcode needs.  */
name|expect
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcodes
operator|->
name|format
operator|&
name|M6811_OP_MASK
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcodes
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcodes
operator|->
name|format
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcodes
operator|->
name|format
operator|&
operator|(
name|M6812_OP_IND16_P2
operator||
name|M6812_OP_IDX_P2
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
comment|/* Special case for call instruction.  */
if|if
condition|(
operator|(
name|opcodes
operator|->
name|format
operator|&
name|M6812_OP_PAGE
operator|)
operator|&&
operator|!
operator|(
name|opcodes
operator|->
name|format
operator|&
name|M6811_OP_IND16
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|expect
operator|<
name|opc
operator|->
name|min_operands
condition|)
name|opc
operator|->
name|min_operands
operator|=
name|expect
expr_stmt|;
if|if
condition|(
name|IS_CALL_SYMBOL
argument_list|(
name|opcodes
operator|->
name|format
argument_list|)
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|expect
operator|>
name|opc
operator|->
name|max_operands
condition|)
name|opc
operator|->
name|max_operands
operator|=
name|expect
expr_stmt|;
block|}
name|opc
operator|++
expr_stmt|;
name|m68hc11_nb_opcode_defs
operator|=
name|opc
operator|-
name|m68hc11_opcode_defs
expr_stmt|;
if|if
condition|(
name|flag_print_opcodes
condition|)
block|{
name|print_opcode_list
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|m68hc11_init_after_args
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Builtin help.  */
end_comment

begin_comment
comment|/* Return a string that represents the operand format for the instruction.    When example is true, this generates an example of operand.  This is used    to give an example and also to generate a test.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_opcode_format
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
parameter_list|,
name|int
name|example
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|format
init|=
name|opcode
operator|->
name|format
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_IMM8
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"#%d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"#<imm8>"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_IMM16
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"#%d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FFFF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"#<imm16>"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_IX
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d,X"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"<imm8>,X"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_IY
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d,X"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"<imm8>,X"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_IDX
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d,X"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"n,r"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_PAGE
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|", %d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
literal|",<page>"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_DIRECT
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"*Z%d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"*<abs8>"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"#$%02x"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"#<mask>"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_JUMP_REL
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_IND16
condition|)
block|{
if|if
condition|(
name|example
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"symbol%d"
argument_list|)
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"<abs>"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
block|{
if|if
condition|(
name|example
condition|)
block|{
if|if
condition|(
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|".+%d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"L%d"
argument_list|,
name|rand
argument_list|()
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
name|_
argument_list|(
literal|"<label>"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Prints the list of instructions with the possible operands.  */
end_comment

begin_function
specifier|static
name|void
name|print_opcode_list
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcodes
decl_stmt|;
name|int
name|example
init|=
name|flag_print_opcodes
operator|==
literal|2
decl_stmt|;
if|if
condition|(
name|example
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"# Example of `%s' instructions\n\t.sect .text\n_start:\n"
argument_list|)
argument_list|,
name|default_cpu
argument_list|)
expr_stmt|;
name|opcodes
operator|=
name|m68hc11_sorted_opcodes
expr_stmt|;
comment|/* Walk the list sorted on names (by md_begin).  We only report      one instruction per line, and we collect the different operand      formats.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
operator|,
name|opcodes
operator|++
control|)
block|{
name|char
modifier|*
name|fmt
init|=
name|print_opcode_format
argument_list|(
name|opcodes
argument_list|,
name|example
argument_list|)
decl_stmt|;
if|if
condition|(
name|example
condition|)
block|{
name|printf
argument_list|(
literal|"L%d:\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|opcodes
operator|->
name|name
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prev_name
argument_list|,
name|opcodes
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-5.5s "
argument_list|,
name|opcodes
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev_name
operator|=
operator|(
name|char
operator|*
operator|)
name|opcodes
operator|->
name|name
expr_stmt|;
block|}
if|if
condition|(
name|fmt
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  [%s]"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the instruction format.  This operation is called when some    instruction is not correct.  Instruction format is printed as an    error message.  */
end_comment

begin_function
specifier|static
name|void
name|print_insn_format
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|opc
operator|=
operator|(
expr|struct
name|m68hc11_opcode_def
operator|*
operator|)
name|hash_find
argument_list|(
name|m68hc11_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opc
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction `%s' is not recognized."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|opcode
operator|=
name|opc
operator|->
name|opcode
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction formats for `%s':"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|print_opcode_format
argument_list|(
name|opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\t%-5.5s %s"
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|opcode
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analysis of 68HC11 and 68HC12 operands.  */
end_comment

begin_comment
comment|/* reg_name_search() finds the register number given its name.    Returns the register number or REG_NONE on failure.  */
end_comment

begin_function
specifier|static
name|register_id
name|reg_name_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"x"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ix"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_X
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"y"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"iy"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_Y
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"a"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_A
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"b"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_B
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"d"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_D
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"sp"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_SP
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_PC
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"ccr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|REG_CCR
return|;
return|return
name|REG_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|skip_whites
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Check the string at input_line_pointer    to see if it is a valid register name.  */
end_comment

begin_function
specifier|static
name|register_id
name|register_name
parameter_list|(
name|void
parameter_list|)
block|{
name|register_id
name|reg_number
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
if|if
condition|(
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
return|return
name|REG_NONE
return|;
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
continue|continue;
name|c
operator|=
operator|*
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|!=
name|REG_NONE
condition|)
block|{
if|if
condition|(
name|c
condition|)
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
return|return
name|reg_number
return|;
block|}
if|if
condition|(
name|c
condition|)
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
return|return
name|reg_number
return|;
block|}
end_function

begin_define
define|#
directive|define
name|M6811_OP_CALL_ADDR
value|0x00800000
end_define

begin_define
define|#
directive|define
name|M6811_OP_PAGE_ADDR
value|0x04000000
end_define

begin_comment
comment|/* Parse a string of operands and return an array of expressions.     Operand      mode[0]         mode[1]       exp[0]       exp[1]    #n           M6811_OP_IMM16  -             O_*    *<exp>       M6811_OP_DIRECT -             O_*    .{+-}<exp>   M6811_OP_JUMP_REL -           O_*<exp>        M6811_OP_IND16  -             O_*    ,r N,r       M6812_OP_IDX    M6812_OP_REG  O_constant   O_register    n,-r         M6812_PRE_DEC   M6812_OP_REG  O_constant   O_register    n,+r         M6812_PRE_INC   " "    n,r-         M6812_POST_DEC  " "    n,r+         M6812_POST_INC  " "    A,r B,r D,r  M6811_OP_REG    M6812_OP_REG  O_register   O_register    [D,r]        M6811_OP_D_IDX  M6812_OP_REG  O_register   O_register    [n,r]        M6811_OP_D_IDX_2 M6812_OP_REG  O_constant   O_register  */
end_comment

begin_function
specifier|static
name|int
name|get_operand
parameter_list|(
name|operand
modifier|*
name|oper
parameter_list|,
name|int
name|which
parameter_list|,
name|long
name|opmode
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|register_id
name|reg
decl_stmt|;
name|oper
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|oper
operator|->
name|reg1
operator|=
name|REG_NONE
expr_stmt|;
name|oper
operator|->
name|reg2
operator|=
name|REG_NONE
expr_stmt|;
name|mode
operator|=
name|M6811_OP_NONE
expr_stmt|;
name|p
operator|=
name|skip_whites
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
block|{
name|input_line_pointer
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
operator|(
name|opmode
operator|&
operator|(
name|M6811_OP_DIRECT
operator||
name|M6811_OP_IND16
operator|)
operator|)
condition|)
block|{
name|mode
operator|=
name|M6811_OP_DIRECT
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|opmode
operator|&
operator|(
name|M6811_OP_IMM8
operator||
name|M6811_OP_IMM16
operator||
name|M6811_OP_BITMASK
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Immediate operand is not allowed for operand %d."
argument_list|)
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mode
operator|=
name|M6811_OP_IMM16
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%hi"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|mode
operator||=
name|M6811_OP_HIGH_ADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%lo"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|mode
operator||=
name|M6811_OP_LOW_ADDR
expr_stmt|;
block|}
comment|/* %page modifier is used to obtain only the page number          of the address of a function.  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%page"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|5
expr_stmt|;
name|mode
operator||=
name|M6811_OP_PAGE_ADDR
expr_stmt|;
block|}
comment|/* %addr modifier is used to obtain the physical address part          of the function (16-bit).  For 68HC12 the function will be          mapped in the 16K window at 0x8000 and the value will be          within that window (although the function address may not fit          in 16-bit).  See bfd/elf32-m68hc12.c for the translation.  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%addr"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|5
expr_stmt|;
name|mode
operator||=
name|M6811_OP_CALL_ADDR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|mode
operator|=
name|M6811_OP_JUMP_REL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Indirect indexed addressing is not valid for 68HC11."
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|mode
operator|=
name|M6812_OP_D_IDX
expr_stmt|;
name|p
operator|=
name|skip_whites
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
comment|/* Special handling of ,x and ,y.  */
block|{
name|p
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|reg
operator|=
name|register_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|REG_NONE
condition|)
block|{
name|oper
operator|->
name|reg1
operator|=
name|reg
expr_stmt|;
name|oper
operator|->
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|oper
operator|->
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|M6812_OP_IDX
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Spurious `,' or bad indirect register addressing mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Handle 68HC12 page specification in 'call foo,%page(bar)'.  */
elseif|else
if|if
condition|(
operator|(
name|opmode
operator|&
name|M6812_OP_PAGE
operator|)
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%page"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|5
expr_stmt|;
name|mode
operator|=
name|M6811_OP_PAGE_ADDR
operator||
name|M6812_OP_PAGE
operator||
name|M6811_OP_IND16
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M6811_OP_NONE
operator|||
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
name|reg
operator|=
name|register_name
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|REG_NONE
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|REG_NONE
condition|)
block|{
name|p
operator|=
name|skip_whites
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
operator|&&
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing second register or offset for indexed-indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|oper
operator|->
name|reg1
operator|=
name|reg
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|mode
operator||
name|M6812_OP_REG
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing second register for indexed-indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
name|p
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|reg
operator|=
name|register_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|REG_NONE
condition|)
block|{
name|p
operator|=
name|skip_whites
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing `]' to close indexed-indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|++
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|M6812_OP_D_IDX
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|oper
operator|->
name|reg2
operator|=
name|reg
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* In MRI mode, isolate the operand because we can't distinguish      operands from comments.  */
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
name|c
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|skip_whites
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse as an expression.  */
name|expression
argument_list|(
operator|&
name|oper
operator|->
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|expression
argument_list|(
operator|&
name|oper
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oper
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operand."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing operand."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M6811_OP_NONE
operator|||
name|mode
operator|==
name|M6811_OP_DIRECT
operator|||
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
block|{
name|p
operator|=
name|skip_whites
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|int
name|possible_mode
init|=
name|M6811_OP_NONE
decl_stmt|;
name|char
modifier|*
name|old_input_line
decl_stmt|;
name|old_input_line
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* 68HC12 pre increment or decrement.  */
if|if
condition|(
name|mode
operator|==
name|M6811_OP_NONE
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|possible_mode
operator|=
name|M6812_PRE_DEC
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|possible_mode
operator|=
name|M6812_PRE_INC
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|skip_whites
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|reg
operator|=
name|register_name
argument_list|()
expr_stmt|;
comment|/* Backtrack if we have a valid constant expression and 	     it does not correspond to the offset of the 68HC12 indexed 	     addressing mode (as in N,x).  */
if|if
condition|(
name|reg
operator|==
name|REG_NONE
operator|&&
name|mode
operator|==
name|M6811_OP_NONE
operator|&&
name|possible_mode
operator|!=
name|M6811_OP_NONE
condition|)
block|{
name|oper
operator|->
name|mode
operator|=
name|M6811_OP_IND16
operator||
name|M6811_OP_JUMP_REL
expr_stmt|;
name|input_line_pointer
operator|=
name|skip_whites
argument_list|(
name|old_input_line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|possible_mode
operator|!=
name|M6811_OP_NONE
condition|)
name|mode
operator|=
name|possible_mode
expr_stmt|;
if|if
condition|(
operator|(
name|current_architecture
operator|&
name|cpu6811
operator|)
operator|&&
name|possible_mode
operator|!=
name|M6811_OP_NONE
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Pre-increment mode is not valid for 68HC11"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Backtrack.  */
if|if
condition|(
name|which
operator|==
literal|0
operator|&&
name|opmode
operator|&
name|M6812_OP_IDX_P2
operator|&&
name|reg
operator|!=
name|REG_X
operator|&&
name|reg
operator|!=
name|REG_Y
operator|&&
name|reg
operator|!=
name|REG_PC
operator|&&
name|reg
operator|!=
name|REG_SP
condition|)
block|{
name|reg
operator|=
name|REG_NONE
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|==
name|REG_NONE
operator|&&
name|mode
operator|!=
name|M6811_OP_DIRECT
operator|&&
operator|!
operator|(
name|mode
operator|==
name|M6811_OP_NONE
operator|&&
name|opmode
operator|&
name|M6811_OP_IND16
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Wrong register in register indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|M6812_OP_D_IDX
condition|)
block|{
name|p
operator|=
name|skip_whites
argument_list|(
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing `]' to close register indirect operand."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|oper
operator|->
name|reg1
operator|=
name|reg
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|M6812_OP_D_IDX_2
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|reg
operator|!=
name|REG_NONE
condition|)
block|{
name|oper
operator|->
name|reg1
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M6811_OP_NONE
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|mode
operator|=
name|M6812_POST_DEC
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Post-decrement mode is not valid for 68HC11."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|mode
operator|=
name|M6812_POST_INC
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|&
name|cpu6811
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Post-increment mode is not valid for 68HC11."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mode
operator|=
name|M6812_OP_IDX
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
block|}
else|else
name|mode
operator||=
name|M6812_OP_IDX
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
return|return
literal|1
return|;
block|}
name|input_line_pointer
operator|=
name|old_input_line
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|M6812_OP_D_IDX_2
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid indexed indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* If the mode is not known until now, this is either a label      or an indirect address.  */
if|if
condition|(
name|mode
operator|==
name|M6811_OP_NONE
condition|)
name|mode
operator|=
name|M6811_OP_IND16
operator||
name|M6811_OP_JUMP_REL
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|oper
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|M6812_AUTO_INC_DEC
value|(M6812_PRE_INC | M6812_PRE_DEC \                             | M6812_POST_INC | M6812_POST_DEC)
end_define

begin_comment
comment|/* Checks that the number 'num' fits for a given mode.  */
end_comment

begin_function
specifier|static
name|int
name|check_range
parameter_list|(
name|long
name|num
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Auto increment and decrement are ok for [-8..8] without 0.  */
if|if
condition|(
name|mode
operator|&
name|M6812_AUTO_INC_DEC
condition|)
return|return
operator|(
name|num
operator|!=
literal|0
operator|&&
name|num
operator|<=
literal|8
operator|&&
name|num
operator|>=
operator|-
literal|8
operator|)
return|;
comment|/* The 68HC12 supports 5, 9 and 16-bit offsets.  */
if|if
condition|(
name|mode
operator|&
operator|(
name|M6812_INDEXED_IND
operator||
name|M6812_INDEXED
operator||
name|M6812_OP_IDX
operator|)
condition|)
name|mode
operator|=
name|M6811_OP_IND16
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|M6812_OP_JUMP_REL16
condition|)
name|mode
operator|=
name|M6811_OP_IND16
expr_stmt|;
name|mode
operator|&=
operator|~
name|M6811_OP_BRANCH
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|M6811_OP_IX
case|:
case|case
name|M6811_OP_IY
case|:
case|case
name|M6811_OP_DIRECT
case|:
return|return
operator|(
name|num
operator|>=
literal|0
operator|&&
name|num
operator|<=
literal|255
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|M6811_OP_BITMASK
case|:
case|case
name|M6811_OP_IMM8
case|:
case|case
name|M6812_OP_PAGE
case|:
return|return
operator|(
operator|(
operator|(
name|num
operator|&
literal|0xFFFFFF00
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|num
operator|&
literal|0xFFFFFF00
operator|)
operator|==
literal|0xFFFFFF00
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|M6811_OP_JUMP_REL
case|:
return|return
operator|(
name|num
operator|>=
operator|-
literal|128
operator|&&
name|num
operator|<=
literal|127
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|M6811_OP_IND16
case|:
case|case
name|M6811_OP_IND16
operator||
name|M6812_OP_PAGE
case|:
case|case
name|M6811_OP_IMM16
case|:
return|return
operator|(
operator|(
operator|(
name|num
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|num
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0xFFFF0000
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|M6812_OP_IBCC_MARKER
case|:
case|case
name|M6812_OP_TBCC_MARKER
case|:
case|case
name|M6812_OP_DBCC_MARKER
case|:
return|return
operator|(
name|num
operator|>=
operator|-
literal|256
operator|&&
name|num
operator|<=
literal|255
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|M6812_OP_TRAP_ID
case|:
return|return
operator|(
operator|(
name|num
operator|>=
literal|0x30
operator|&&
name|num
operator|<=
literal|0x39
operator|)
operator|||
operator|(
name|num
operator|>=
literal|0x40
operator|&&
name|num
operator|<=
literal|0x0ff
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Gas fixup generation.  */
end_comment

begin_comment
comment|/* Put a 1 byte expression described by 'oper'.  If this expression contains    unresolved symbols, generate an 8-bit fixup.  */
end_comment

begin_function
specifier|static
name|void
name|fixup8
parameter_list|(
name|expressionS
modifier|*
name|oper
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|M6812_OP_TRAP_ID
operator|&&
operator|!
name|check_range
argument_list|(
name|oper
operator|->
name|X_add_number
argument_list|,
name|M6812_OP_TRAP_ID
argument_list|)
condition|)
block|{
specifier|static
name|char
name|trap_id_warn_once
init|=
literal|0
decl_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Trap id `%ld' is out of range."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap_id_warn_once
operator|==
literal|0
condition|)
block|{
name|trap_id_warn_once
operator|=
literal|1
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Trap id must be within [0x30..0x39] or [0x40..0xff]."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|M6812_OP_TRAP_ID
operator|)
operator|&&
operator|!
name|check_range
argument_list|(
name|oper
operator|->
name|X_add_number
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of 8-bit range: `%ld'."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|oper
operator|->
name|X_add_number
operator|&
literal|0x0FF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|->
name|X_op
operator|!=
name|O_register
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|M6812_OP_TRAP_ID
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The trap id must be a constant."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M6811_OP_JUMP_REL
condition|)
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|1
argument_list|,
name|oper
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_8_PCREL
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_pcrel_adjust
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
comment|/* Now create an 8-bit fixup.  If there was some %hi, %lo 	     or %page modifier, generate the reloc accordingly.  */
if|if
condition|(
name|opmode
operator|&
name|M6811_OP_HIGH_ADDR
condition|)
name|reloc
operator|=
name|BFD_RELOC_M68HC11_HI8
expr_stmt|;
elseif|else
if|if
condition|(
name|opmode
operator|&
name|M6811_OP_LOW_ADDR
condition|)
name|reloc
operator|=
name|BFD_RELOC_M68HC11_LO8
expr_stmt|;
elseif|else
if|if
condition|(
name|opmode
operator|&
name|M6811_OP_PAGE_ADDR
condition|)
name|reloc
operator|=
name|BFD_RELOC_M68HC11_PAGE
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_8
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|1
argument_list|,
name|oper
argument_list|,
name|FALSE
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_8
condition|)
name|fixp
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Operand `%x' not recognized in fixup8."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put a 2 byte expression described by 'oper'.  If this expression contains    unresolved symbols, generate a 16-bit fixup.  */
end_comment

begin_function
specifier|static
name|void
name|fixup16
parameter_list|(
name|expressionS
modifier|*
name|oper
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|opmode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|oper
operator|->
name|X_add_number
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of 16-bit range: `%ld'."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|oper
operator|->
name|X_add_number
operator|&
literal|0x0FFFF
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|->
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
if|if
condition|(
operator|(
name|opmode
operator|&
name|M6811_OP_CALL_ADDR
operator|)
operator|&&
operator|(
name|mode
operator|&
name|M6811_OP_IMM16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_M68HC11_LO16
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|M6812_OP_JUMP_REL16
condition|)
name|reloc
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|M6812_OP_PAGE
condition|)
name|reloc
operator|=
name|BFD_RELOC_M68HC11_LO16
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_16
expr_stmt|;
comment|/* Now create a 16-bit fixup.  */
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|oper
argument_list|,
name|reloc
operator|==
name|BFD_RELOC_16_PCREL
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_16_PCREL
condition|)
name|fixp
operator|->
name|fx_pcrel_adjust
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_M68HC11_LO16
condition|)
name|fixp
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Operand `%x' not recognized in fixup16."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put a 3 byte expression described by 'oper'.  If this expression contains    unresolved symbols, generate a 24-bit fixup.  */
end_comment

begin_function
specifier|static
name|void
name|fixup24
parameter_list|(
name|expressionS
modifier|*
name|oper
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|opmode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|oper
operator|->
name|X_add_number
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of 16-bit range: `%ld'."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|oper
operator|->
name|X_add_number
operator|&
literal|0x0FFFFFF
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oper
operator|->
name|X_op
operator|!=
name|O_register
condition|)
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* Now create a 24-bit fixup.  */
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|3
argument_list|,
name|oper
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_M68HC11_24
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Operand `%x' not recognized in fixup16."
argument_list|)
argument_list|,
name|oper
operator|->
name|X_op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 68HC11 and 68HC12 code generation.  */
end_comment

begin_comment
comment|/* Translate the short branch/bsr instruction into a long branch.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|convert_branch
parameter_list|(
name|unsigned
name|char
name|code
parameter_list|)
block|{
if|if
condition|(
name|IS_OPCODE
argument_list|(
name|code
argument_list|,
name|M6812_BSR
argument_list|)
condition|)
return|return
name|M6812_JSR
return|;
elseif|else
if|if
condition|(
name|IS_OPCODE
argument_list|(
name|code
argument_list|,
name|M6811_BSR
argument_list|)
condition|)
return|return
name|M6811_JSR
return|;
elseif|else
if|if
condition|(
name|IS_OPCODE
argument_list|(
name|code
argument_list|,
name|M6811_BRA
argument_list|)
condition|)
return|return
operator|(
name|current_architecture
operator|&
name|cpu6812
operator|)
condition|?
name|M6812_JMP
else|:
name|M6811_JMP
return|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unexpected branch conversion with `%x'"
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Keep gcc happy.  */
return|return
name|M6811_JSR
return|;
block|}
end_function

begin_comment
comment|/* Start a new insn that contains at least 'size' bytes.  Record the    line information of that insn in the dwarf2 debug sections.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|m68hc11_new_insn
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Builds a jump instruction (bra, bcc, bsr).  */
end_comment

begin_function
specifier|static
name|void
name|build_jump_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
parameter_list|,
name|operand
name|operands
index|[]
parameter_list|,
name|int
name|nb_operands
parameter_list|,
name|int
name|jmp_mode
parameter_list|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
comment|/* The relative branch conversion is not supported for      brclr and brset.  */
name|assert
argument_list|(
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nb_operands
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|==
name|REG_NONE
operator|&&
name|operands
index|[
literal|0
index|]
operator|.
name|reg2
operator|==
name|REG_NONE
argument_list|)
expr_stmt|;
name|code
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|n
operator|=
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* Turn into a long branch:      - when force long branch option (and not for jbcc pseudos),      - when jbcc and the constant is out of -128..127 range,      - when branch optimization is allowed and branch out of range.  */
if|if
condition|(
operator|(
name|jmp_mode
operator|==
literal|0
operator|&&
name|flag_force_long_jumps
operator|)
operator|||
operator|(
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
operator|!
name|check_range
argument_list|(
name|n
argument_list|,
name|opcode
operator|->
name|format
argument_list|)
operator|&&
operator|(
name|jmp_mode
operator|==
literal|1
operator|||
name|flag_fixed_branches
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|frag
operator|=
name|frag_now
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_M68HC11_RL_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|M6811_BSR
operator|||
name|code
operator|==
name|M6811_BRA
operator|||
name|code
operator|==
name|M6812_BSR
condition|)
block|{
name|code
operator|=
name|convert_branch
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_architecture
operator|&
name|cpu6812
condition|)
block|{
comment|/* 68HC12: translate the bcc into a lbcc.  */
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|M6811_OPCODE_PAGE2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fixup16
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6812_OP_JUMP_REL16
argument_list|,
name|M6812_OP_JUMP_REL16
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 68HC11: translate the bcc into b!cc +3; jmp<L>.  */
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|code
operator|^=
literal|1
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|M6811_JMP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fixup16
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_IND16
argument_list|,
name|M6811_OP_IND16
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Branch with a constant that must fit in 8-bits.  */
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|n
argument_list|,
name|opcode
operator|->
name|format
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of range for a relative branch: `%ld'"
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_JUMP_REL16
condition|)
block|{
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|M6811_OPCODE_PAGE2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|n
operator|&
literal|0x0ffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|n
operator|&
literal|0x0FF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_JUMP_REL16
condition|)
block|{
name|frag
operator|=
name|frag_now
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_M68HC11_RL_JUMP
argument_list|)
expr_stmt|;
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|M6811_OPCODE_PAGE2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fixup16
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6812_OP_JUMP_REL16
argument_list|,
name|M6812_OP_JUMP_REL16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|opcode
decl_stmt|;
name|frag
operator|=
name|frag_now
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_M68HC11_RL_JUMP
argument_list|)
expr_stmt|;
comment|/* Branch offset must fit in 8-bits, don't do some relax.  */
if|if
condition|(
name|jmp_mode
operator|==
literal|0
operator|&&
name|flag_fixed_branches
condition|)
block|{
name|opcode
operator|=
name|m68hc11_new_insn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fixup8
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_JUMP_REL
argument_list|,
name|M6811_OP_JUMP_REL
argument_list|)
expr_stmt|;
block|}
comment|/* bra/bsr made be changed into jmp/jsr.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|M6811_BSR
operator|||
name|code
operator|==
name|M6811_BRA
operator|||
name|code
operator|==
name|M6812_BSR
condition|)
block|{
comment|/* Allocate worst case storage.  */
name|opcode
operator|=
name|m68hc11_new_insn
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_architecture
operator|&
name|cpu6812
condition|)
block|{
name|opcode
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH_6812
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opcode
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|opcode
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Builds a dbne/dbeq/tbne/tbeq instruction.  */
end_comment

begin_function
specifier|static
name|void
name|build_dbranch_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
parameter_list|,
name|operand
name|operands
index|[]
parameter_list|,
name|int
name|nb_operands
parameter_list|,
name|int
name|jmp_mode
parameter_list|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
comment|/* The relative branch conversion is not supported for      brclr and brset.  */
name|assert
argument_list|(
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nb_operands
operator|==
literal|2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|!=
name|REG_NONE
argument_list|)
expr_stmt|;
name|code
operator|=
name|opcode
operator|->
name|opcode
operator|&
literal|0x0FF
expr_stmt|;
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|operands
index|[
literal|1
index|]
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|code
operator|=
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|==
name|REG_NONE
operator|||
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|==
name|REG_CCR
operator|||
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|==
name|REG_PC
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for dbcc/tbcc instruction."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_IBCC_MARKER
condition|)
name|code
operator||=
literal|0x80
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_TBCC_MARKER
condition|)
name|code
operator||=
literal|0x40
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_EQ_MARKER
operator|)
condition|)
name|code
operator||=
literal|0x20
expr_stmt|;
comment|/* Turn into a long branch:      - when force long branch option (and not for jbcc pseudos),      - when jdbcc and the constant is out of -256..255 range,      - when branch optimization is allowed and branch out of range.  */
if|if
condition|(
operator|(
name|jmp_mode
operator|==
literal|0
operator|&&
name|flag_force_long_jumps
operator|)
operator|||
operator|(
name|operands
index|[
literal|1
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
operator|!
name|check_range
argument_list|(
name|n
argument_list|,
name|M6812_OP_IBCC_MARKER
argument_list|)
operator|&&
operator|(
name|jmp_mode
operator|==
literal|1
operator|||
name|flag_fixed_branches
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|code
operator|^=
literal|0x20
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|M6812_JMP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fixup16
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_IND16
argument_list|,
name|M6811_OP_IND16
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Branch with a constant that must fit in 9-bits.  */
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|n
argument_list|,
name|M6812_OP_IBCC_MARKER
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Operand out of range for a relative branch: `%ld'"
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|n
operator|<
literal|0
condition|)
name|code
operator||=
literal|0x10
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|n
operator|&
literal|0x0FF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Branch offset must fit in 8-bits, don't do some relax.  */
if|if
condition|(
name|jmp_mode
operator|==
literal|0
operator|&&
name|flag_fixed_branches
condition|)
block|{
name|fixup8
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_JUMP_REL
argument_list|,
name|M6811_OP_JUMP_REL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_XBCC_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OP_EXTENDED
value|(M6811_OP_PAGE2 | M6811_OP_PAGE3 | M6811_OP_PAGE4)
end_define

begin_comment
comment|/* Assemble the post index byte for 68HC12 extended addressing modes.  */
end_comment

begin_function
specifier|static
name|int
name|build_indexed_byte
parameter_list|(
name|operand
modifier|*
name|op
parameter_list|,
name|int
name|format
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|move_insn
parameter_list|)
block|{
name|unsigned
name|char
name|byte
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|long
name|val
decl_stmt|;
name|val
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|mode
operator|=
name|op
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|M6812_AUTO_INC_DEC
condition|)
block|{
name|byte
operator|=
literal|0x20
expr_stmt|;
if|if
condition|(
name|mode
operator|&
operator|(
name|M6812_POST_INC
operator||
name|M6812_POST_DEC
operator|)
condition|)
name|byte
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Increment/decrement value is out of range: `%ld'."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|M6812_POST_INC
operator||
name|M6812_PRE_INC
operator|)
condition|)
name|byte
operator||=
operator|(
name|val
operator|-
literal|1
operator|)
operator|&
literal|0x07
expr_stmt|;
else|else
name|byte
operator||=
operator|(
literal|8
operator|-
operator|(
operator|(
name|val
operator|)
operator|&
literal|7
operator|)
operator|)
operator||
literal|0x8
expr_stmt|;
block|}
switch|switch
condition|(
name|op
operator|->
name|reg1
condition|)
block|{
case|case
name|REG_NONE
case|:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Expecting a register."
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|REG_X
case|:
name|byte
operator||=
literal|0
expr_stmt|;
break|break;
case|case
name|REG_Y
case|:
name|byte
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
name|REG_SP
case|:
name|byte
operator||=
literal|0x80
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register for post/pre increment."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|M6812_OP_IDX
operator||
name|M6812_OP_D_IDX_2
operator|)
condition|)
block|{
switch|switch
condition|(
name|op
operator|->
name|reg1
condition|)
block|{
case|case
name|REG_X
case|:
name|byte
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REG_Y
case|:
name|byte
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REG_SP
case|:
name|byte
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|REG_PC
case|:
name|byte
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|!
name|check_range
argument_list|(
name|val
argument_list|,
name|M6812_OP_IDX
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Offset out of 16-bit range: %ld."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|move_insn
operator|&&
operator|!
operator|(
name|val
operator|>=
operator|-
literal|16
operator|&&
name|val
operator|<=
literal|15
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Offset out of 5-bit range for movw/movb insn: %ld."
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|val
operator|>=
operator|-
literal|16
operator|&&
name|val
operator|<=
literal|15
operator|&&
operator|!
operator|(
name|mode
operator|&
name|M6812_OP_D_IDX_2
operator|)
condition|)
block|{
name|byte
operator|=
name|byte
operator|<<
literal|6
expr_stmt|;
name|byte
operator||=
name|val
operator|&
literal|0x1f
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>=
operator|-
literal|256
operator|&&
name|val
operator|<=
literal|255
operator|&&
operator|!
operator|(
name|mode
operator|&
name|M6812_OP_D_IDX_2
operator|)
condition|)
block|{
name|byte
operator|=
name|byte
operator|<<
literal|3
expr_stmt|;
name|byte
operator||=
literal|0xe0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|byte
operator||=
literal|0x1
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|val
operator|&
literal|0x0FF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
block|{
name|byte
operator|=
name|byte
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|M6812_OP_D_IDX_2
condition|)
name|byte
operator||=
literal|0xe3
expr_stmt|;
else|else
name|byte
operator||=
literal|0xe2
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|val
operator|&
literal|0x0FFFF
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|&
name|M6812_OP_D_IDX_2
condition|)
block|{
name|byte
operator|=
operator|(
name|byte
operator|<<
literal|3
operator|)
operator||
literal|0xe3
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fixup16
argument_list|(
operator|&
name|op
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|reg1
operator|!=
name|REG_PC
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|offsetT
name|off
decl_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|op
operator|->
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|op
operator|->
name|exp
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* movb/movw cannot be relaxed.  */
if|if
condition|(
name|move_insn
condition|)
block|{
name|byte
operator|<<=
literal|6
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|1
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_M68HC12_5B
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|sym
argument_list|,
name|off
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* movb/movw cannot be relaxed.  */
if|if
condition|(
name|move_insn
condition|)
block|{
name|byte
operator|<<=
literal|6
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|1
argument_list|,
name|op
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|op
operator|->
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_M68HC12_5B
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|op
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|op
operator|->
name|exp
operator|.
name|X_add_number
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|3
return|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|M6812_OP_REG
operator||
name|M6812_OP_D_IDX
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|M6812_OP_D_IDX
condition|)
block|{
if|if
condition|(
name|op
operator|->
name|reg1
operator|!=
name|REG_D
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expecting register D for indexed indirect mode."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_insn
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Indexed indirect mode is not allowed for movb/movw."
argument_list|)
argument_list|)
expr_stmt|;
name|byte
operator|=
literal|0xE7
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|op
operator|->
name|reg1
condition|)
block|{
case|case
name|REG_A
case|:
name|byte
operator|=
literal|0xE4
expr_stmt|;
break|break;
case|case
name|REG_B
case|:
name|byte
operator|=
literal|0xE5
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid accumulator register."
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|REG_D
case|:
name|byte
operator|=
literal|0xE6
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|op
operator|->
name|reg2
condition|)
block|{
case|case
name|REG_X
case|:
break|break;
case|case
name|REG_Y
case|:
name|byte
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|REG_SP
case|:
name|byte
operator||=
operator|(
literal|2
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|REG_PC
case|:
name|byte
operator||=
operator|(
literal|3
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid indexed register."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Addressing mode not implemented yet."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assemble the 68HC12 register mode byte.  */
end_comment

begin_function
specifier|static
name|int
name|build_reg_mode
parameter_list|(
name|operand
modifier|*
name|op
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_SEX_MARKER
operator|&&
name|op
operator|->
name|reg1
operator|!=
name|REG_A
operator|&&
name|op
operator|->
name|reg1
operator|!=
name|REG_B
operator|&&
name|op
operator|->
name|reg1
operator|!=
name|REG_CCR
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid source register for this instruction, use 'tfr'."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|reg1
operator|==
name|REG_NONE
operator|||
name|op
operator|->
name|reg1
operator|==
name|REG_PC
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid source register."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_SEX_MARKER
operator|&&
name|op
operator|->
name|reg2
operator|!=
name|REG_D
operator|&&
name|op
operator|->
name|reg2
operator|!=
name|REG_X
operator|&&
name|op
operator|->
name|reg2
operator|!=
name|REG_Y
operator|&&
name|op
operator|->
name|reg2
operator|!=
name|REG_SP
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid destination register for this instruction, use 'tfr'."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|reg2
operator|==
name|REG_NONE
operator|||
name|op
operator|->
name|reg2
operator|==
name|REG_PC
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid destination register."
argument_list|)
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
name|op
operator|->
name|reg1
operator|<<
literal|4
operator|)
operator||
operator|(
name|op
operator|->
name|reg2
operator|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_EXG_MARKER
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* build_insn takes a pointer to the opcode entry in the opcode table,    the array of operand expressions and builds the corresponding instruction.    This operation only deals with non relative jumps insn (need special    handling).  */
end_comment

begin_function
specifier|static
name|void
name|build_insn
parameter_list|(
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
parameter_list|,
name|operand
name|operands
index|[]
parameter_list|,
name|int
name|nb_operands
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|long
name|format
decl_stmt|;
name|int
name|move_insn
init|=
literal|0
decl_stmt|;
comment|/* Put the page code instruction if there is one.  */
name|format
operator|=
name|opcode
operator|->
name|format
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_BRANCH
condition|)
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_M68HC11_RL_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|OP_EXTENDED
condition|)
block|{
name|int
name|page_code
decl_stmt|;
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_PAGE2
condition|)
name|page_code
operator|=
name|M6811_OPCODE_PAGE2
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|&
name|M6811_OP_PAGE3
condition|)
name|page_code
operator|=
name|M6811_OPCODE_PAGE3
expr_stmt|;
else|else
name|page_code
operator|=
name|M6811_OPCODE_PAGE4
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|page_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
else|else
name|f
operator|=
name|m68hc11_new_insn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|opcode
operator|->
name|opcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* The 68HC12 movb and movw instructions are special.  We have to handle      them in a special way.  */
if|if
condition|(
name|format
operator|&
operator|(
name|M6812_OP_IND16_P2
operator||
name|M6812_OP_IDX_P2
operator|)
condition|)
block|{
name|move_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_IDX
condition|)
block|{
name|build_indexed_byte
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
argument_list|,
name|format
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|format
operator|&=
operator|~
name|M6812_OP_IDX
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_IDX_P2
condition|)
block|{
name|build_indexed_byte
argument_list|(
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
name|format
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|format
operator|&=
operator|~
name|M6812_OP_IDX_P2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_DIRECT
operator||
name|M6811_OP_IMM8
operator|)
condition|)
block|{
name|fixup8
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|format
operator|&
operator|(
name|M6811_OP_DIRECT
operator||
name|M6811_OP_IMM8
operator||
name|M6812_OP_TRAP_ID
operator|)
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CALL_SYMBOL
argument_list|(
name|format
argument_list|)
operator|&&
name|nb_operands
operator|==
literal|1
condition|)
block|{
name|format
operator|&=
operator|~
name|M6812_OP_PAGE
expr_stmt|;
name|fixup24
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|format
operator|&
name|M6811_OP_IND16
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_IMM16
operator||
name|M6811_OP_IND16
operator|)
condition|)
block|{
name|fixup16
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|format
operator|&
operator|(
name|M6811_OP_IMM16
operator||
name|M6811_OP_IND16
operator||
name|M6812_OP_PAGE
operator|)
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_IX
operator||
name|M6811_OP_IY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|format
operator|&
name|M6811_OP_IX
operator|)
operator|&&
operator|(
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|!=
name|REG_X
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid indexed register, expecting register X."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|&
name|M6811_OP_IY
operator|)
operator|&&
operator|(
name|operands
index|[
literal|0
index|]
operator|.
name|reg1
operator|!=
name|REG_Y
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid indexed register, expecting register Y."
argument_list|)
argument_list|)
expr_stmt|;
name|fixup8
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_IX
argument_list|,
name|operands
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
operator|(
name|M6812_OP_IDX
operator||
name|M6812_OP_IDX_2
operator||
name|M6812_OP_IDX_1
operator||
name|M6812_OP_D_IDX
operator||
name|M6812_OP_D_IDX_2
operator|)
condition|)
block|{
name|build_indexed_byte
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
argument_list|,
name|format
argument_list|,
name|move_insn
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6812_OP_REG
operator|&&
name|current_architecture
operator|&
name|cpu6812
condition|)
block|{
name|build_reg_mode
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
block|{
name|fixup8
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_BITMASK
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_JUMP_REL
condition|)
block|{
name|fixup8
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_JUMP_REL
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6812_OP_IND16_P2
condition|)
block|{
name|fixup16
argument_list|(
operator|&
name|operands
index|[
literal|1
index|]
operator|.
name|exp
argument_list|,
name|M6811_OP_IND16
argument_list|,
name|operands
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_PAGE
condition|)
block|{
name|fixup8
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|M6812_OP_PAGE
argument_list|,
name|operands
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Opcode identification and operand analysis.  */
end_comment

begin_comment
comment|/* find() gets a pointer to an entry in the opcode table.  It must look at all    opcodes with the same name and use the operands to choose the correct    opcode.  Returns the opcode pointer if there was a match and 0 if none.  */
end_comment

begin_function
specifier|static
name|struct
name|m68hc11_opcode
modifier|*
name|find
parameter_list|(
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
parameter_list|,
name|operand
name|operands
index|[]
parameter_list|,
name|int
name|nb_operands
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|match
decl_stmt|,
name|pos
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|op_indirect
decl_stmt|;
name|op_indirect
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
name|opc
operator|->
name|opcode
expr_stmt|;
comment|/* Now search the opcode table table for one with operands      that matches what we've got.  We're only done if the operands matched so      far AND there are no more to check.  */
for|for
control|(
name|pos
operator|=
name|match
operator|=
literal|0
init|;
name|match
operator|==
literal|0
operator|&&
name|pos
operator|<
name|opc
operator|->
name|nb_modes
condition|;
name|pos
operator|++
operator|,
name|opcode
operator|++
control|)
block|{
name|int
name|poss_indirect
init|=
literal|0
decl_stmt|;
name|long
name|format
init|=
name|opcode
operator|->
name|format
decl_stmt|;
name|int
name|expect
decl_stmt|;
name|expect
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_MASK
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
operator|(
name|M6812_OP_IND16_P2
operator||
name|M6812_OP_IDX_P2
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_PAGE
operator|)
operator|&&
operator|(
operator|!
name|IS_CALL_SYMBOL
argument_list|(
name|opcode
operator|->
name|format
argument_list|)
operator|||
name|nb_operands
operator|==
literal|2
operator|)
condition|)
name|expect
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|expect
operator|==
name|nb_operands
operator|&&
name|i
operator|<
name|nb_operands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|mode
init|=
name|operands
index|[
name|i
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|M6811_OP_IMM16
condition|)
block|{
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_IMM8
operator||
name|M6811_OP_IMM16
operator||
name|M6811_OP_BITMASK
operator|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|mode
operator|==
name|M6811_OP_DIRECT
condition|)
block|{
if|if
condition|(
name|format
operator|&
name|M6811_OP_DIRECT
condition|)
continue|continue;
comment|/* If the operand is a page 0 operand, remember a 	         possible<abs-16> addressing mode.  We mark 	         this and continue to check other operands.  */
if|if
condition|(
name|format
operator|&
name|M6811_OP_IND16
operator|&&
name|flag_strict_direct_addressing
operator|&&
name|op_indirect
operator|==
literal|0
condition|)
block|{
name|poss_indirect
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|mode
operator|&
name|M6811_OP_IND16
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6811_OP_IND16
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_PAGE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_IND16_P2
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
block|{
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|mode
operator|&
name|M6812_OP_REG
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_REG
operator|)
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg2
operator|==
name|REG_NONE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_REG
operator|)
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_REG_2
operator|)
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg2
operator|!=
name|REG_NONE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_IDX
operator|)
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg2
operator|!=
name|REG_NONE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_IDX
operator|)
operator|&&
operator|(
name|format
operator|&
operator|(
name|M6812_OP_IND16_P2
operator||
name|M6812_OP_IDX_P2
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|format
operator|&
name|M6812_OP_IDX_P2
operator|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|mode
operator|&
name|M6812_OP_IDX
condition|)
block|{
if|if
condition|(
name|format
operator|&
name|M6811_OP_IX
operator|&&
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_X
condition|)
continue|continue;
if|if
condition|(
name|format
operator|&
name|M6811_OP_IY
operator|&&
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_Y
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|format
operator|&
operator|(
name|M6812_OP_IDX
operator||
name|M6812_OP_IDX_1
operator||
name|M6812_OP_IDX_2
operator|)
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_X
operator|||
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_Y
operator|||
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_SP
operator|||
name|operands
index|[
name|i
index|]
operator|.
name|reg1
operator|==
name|REG_PC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|format
operator|&
name|M6812_OP_IDX_P2
condition|)
continue|continue;
block|}
if|if
condition|(
name|mode
operator|&
name|format
operator|&
operator|(
name|M6812_OP_D_IDX
operator||
name|M6812_OP_D_IDX_2
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|mode
operator|&
name|M6812_AUTO_INC_DEC
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|format
operator|&
operator|(
name|M6812_OP_IDX
operator||
name|M6812_OP_IDX_1
operator||
name|M6812_OP_IDX_2
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|format
operator|&
name|M6812_OP_IDX_P2
condition|)
continue|continue;
block|}
break|break;
block|}
name|match
operator|=
name|i
operator|==
name|nb_operands
expr_stmt|;
comment|/* Operands are ok but an operand uses page 0 addressing mode          while the insn supports abs-16 mode.  Keep a reference to this          insns in case there is no insn supporting page 0 addressing.  */
if|if
condition|(
name|match
operator|&&
name|poss_indirect
condition|)
block|{
name|op_indirect
operator|=
name|opcode
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
break|break;
block|}
comment|/* Page 0 addressing is used but not supported by any insn.      If absolute addresses are supported, we use that insn.  */
if|if
condition|(
name|match
operator|==
literal|0
operator|&&
name|op_indirect
condition|)
block|{
name|opcode
operator|=
name|op_indirect
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
name|opcode
return|;
block|}
end_function

begin_comment
comment|/* Find the real opcode and its associated operands.  We use a progressive    approach here.  On entry, 'opc' points to the first opcode in the    table that matches the opcode name in the source line.  We try to    isolate an operand, find a possible match in the opcode table.    We isolate another operand if no match were found.  The table 'operands'    is filled while operands are recognized.     Returns the opcode pointer that matches the opcode name in the    source line and the associated operands.  */
end_comment

begin_function
specifier|static
name|struct
name|m68hc11_opcode
modifier|*
name|find_opcode
parameter_list|(
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
parameter_list|,
name|operand
name|operands
index|[]
parameter_list|,
name|int
modifier|*
name|nb_operands
parameter_list|)
block|{
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|opc
operator|->
name|max_operands
operator|==
literal|0
condition|)
block|{
operator|*
name|nb_operands
operator|=
literal|0
expr_stmt|;
return|return
name|opc
operator|->
name|opcode
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opc
operator|->
name|max_operands
condition|;
control|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|get_operand
argument_list|(
operator|&
name|operands
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|opc
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Special case where the bitmask of the bclr/brclr          instructions is not introduced by #.          Example: bclr 3,x $80.  */
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|opc
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
operator|&&
operator|(
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|&
name|M6811_OP_IND16
operator|)
condition|)
block|{
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|M6811_OP_IMM16
expr_stmt|;
block|}
name|i
operator|+=
name|result
expr_stmt|;
operator|*
name|nb_operands
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|opc
operator|->
name|min_operands
condition|)
block|{
name|opcode
operator|=
name|find
argument_list|(
name|opc
argument_list|,
name|operands
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Another special case for 'call foo,page' instructions.              Since we support 'call foo' and 'call foo,page' we must look              if the optional page specification is present otherwise we will              assemble immediately and treat the page spec as garbage.  */
if|if
condition|(
name|opcode
operator|&&
operator|!
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_PAGE
operator|)
condition|)
return|return
name|opcode
return|;
if|if
condition|(
name|opcode
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
return|return
name|opcode
return|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|M6812_XBCC_MARKER
value|(M6812_OP_TBCC_MARKER \                            | M6812_OP_DBCC_MARKER \                            | M6812_OP_IBCC_MARKER)
end_define

begin_escape
end_escape

begin_comment
comment|/* Gas line assembler entry point.  */
end_comment

begin_comment
comment|/* This is the main entry point for the machine-dependent assembler.  str    points to a machine-dependent instruction.  This function is supposed to    emit the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|m68hc11_opcode_def
modifier|*
name|opc
decl_stmt|;
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op_start
decl_stmt|,
modifier|*
name|op_end
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nlen
init|=
literal|0
decl_stmt|;
name|operand
name|operands
index|[
name|M6811_MAX_OPERANDS
index|]
decl_stmt|;
name|int
name|nb_operands
init|=
literal|0
decl_stmt|;
name|int
name|branch_optimize
init|=
literal|0
decl_stmt|;
name|int
name|alias_id
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the opcode end and get the opcode in 'name'.  The opcode is forced      lower case (the opcode table only has lower case op-codes).  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
init|;
operator|*
name|op_end
operator|&&
name|nlen
operator|<
literal|20
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|op_end
index|]
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
block|{
name|name
index|[
name|nlen
index|]
operator|=
name|TOLOWER
argument_list|(
name|op_start
index|[
name|nlen
index|]
argument_list|)
expr_stmt|;
name|nlen
operator|++
expr_stmt|;
block|}
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No instruction or missing opcode."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the opcode definition given its name.  */
name|opc
operator|=
operator|(
expr|struct
name|m68hc11_opcode_def
operator|*
operator|)
name|hash_find
argument_list|(
name|m68hc11_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If it's not recognized, look for 'jbsr' and 'jbxx'.  These are      pseudo insns for relative branch.  For these branches, we always      optimize them (turned into absolute branches) even if --short-branches      is given.  */
if|if
condition|(
name|opc
operator|==
name|NULL
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'j'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
name|opc
operator|=
operator|(
expr|struct
name|m68hc11_opcode_def
operator|*
operator|)
name|hash_find
argument_list|(
name|m68hc11_hash
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opc
operator|&&
operator|(
operator|!
operator|(
name|opc
operator|->
name|format
operator|&
name|M6811_OP_JUMP_REL
operator|)
operator|||
operator|(
name|opc
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
operator|)
condition|)
name|opc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opc
condition|)
name|branch_optimize
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The following test should probably be removed.  This is not conform      to Motorola assembler specs.  */
if|if
condition|(
name|opc
operator|==
name|NULL
operator|&&
name|flag_mri
condition|)
block|{
if|if
condition|(
operator|*
name|op_end
operator|==
literal|' '
operator|||
operator|*
name|op_end
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|*
name|op_end
operator|==
literal|' '
operator|||
operator|*
name|op_end
operator|==
literal|'\t'
condition|)
name|op_end
operator|++
expr_stmt|;
if|if
condition|(
name|nlen
operator|<
literal|19
operator|&&
operator|(
operator|*
name|op_end
operator|&&
operator|(
name|is_end_of_line
index|[
name|op_end
index|[
literal|1
index|]
index|]
operator|||
name|op_end
index|[
literal|1
index|]
operator|==
literal|' '
operator|||
name|op_end
index|[
literal|1
index|]
operator|==
literal|'\t'
operator|||
operator|!
name|ISALNUM
argument_list|(
name|op_end
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|*
name|op_end
operator|==
literal|'a'
operator|||
operator|*
name|op_end
operator|==
literal|'b'
operator|||
operator|*
name|op_end
operator|==
literal|'A'
operator|||
operator|*
name|op_end
operator|==
literal|'B'
operator|||
operator|*
name|op_end
operator|==
literal|'d'
operator|||
operator|*
name|op_end
operator|==
literal|'D'
operator|||
operator|*
name|op_end
operator|==
literal|'x'
operator|||
operator|*
name|op_end
operator|==
literal|'X'
operator|||
operator|*
name|op_end
operator|==
literal|'y'
operator|||
operator|*
name|op_end
operator|==
literal|'Y'
operator|)
condition|)
block|{
name|name
index|[
name|nlen
operator|++
index|]
operator|=
name|TOLOWER
argument_list|(
operator|*
name|op_end
operator|++
argument_list|)
expr_stmt|;
name|name
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
name|opc
operator|=
operator|(
expr|struct
name|m68hc11_opcode_def
operator|*
operator|)
name|hash_find
argument_list|(
name|m68hc11_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Identify a possible instruction alias.  There are some on the      68HC12 to emulate a few 68HC11 instructions.  */
if|if
condition|(
name|opc
operator|==
name|NULL
operator|&&
operator|(
name|current_architecture
operator|&
name|cpu6812
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68hc12_num_alias
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|m68hc12_alias
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alias_id
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|opc
operator|==
name|NULL
operator|&&
name|alias_id
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' is not recognized."
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|save
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|op_end
expr_stmt|;
if|if
condition|(
name|opc
condition|)
block|{
name|opc
operator|->
name|used
operator|++
expr_stmt|;
name|opcode
operator|=
name|find_opcode
argument_list|(
name|opc
argument_list|,
name|operands
argument_list|,
operator|&
name|nb_operands
argument_list|)
expr_stmt|;
block|}
else|else
name|opcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|||
name|alias_id
operator|>=
literal|0
operator|)
operator|&&
operator|!
name|flag_mri
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Garbage at end of instruction: `%s'."
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|alias_id
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|f
init|=
name|m68hc11_new_insn
argument_list|(
name|m68hc12_alias
index|[
name|alias_id
index|]
operator|.
name|size
argument_list|)
decl_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|f
argument_list|,
name|m68hc12_alias
index|[
name|alias_id
index|]
operator|.
name|code1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m68hc12_alias
index|[
name|alias_id
index|]
operator|.
name|size
operator|>
literal|1
condition|)
name|number_to_chars_bigendian
argument_list|(
name|f
operator|+
literal|1
argument_list|,
name|m68hc12_alias
index|[
name|alias_id
index|]
operator|.
name|code2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Opcode is known but does not have valid operands.  Print out the      syntax for this opcode.  */
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag_print_insn_syntax
condition|)
name|print_insn_format
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid operand for `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Treat dbeq/ibeq/tbeq instructions in a special way.  The branch is      relative and must be in the range -256..255 (9-bits).  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6812_XBCC_MARKER
operator|)
operator|&&
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_JUMP_REL
operator|)
condition|)
name|build_dbranch_insn
argument_list|(
name|opcode
argument_list|,
name|operands
argument_list|,
name|nb_operands
argument_list|,
name|branch_optimize
argument_list|)
expr_stmt|;
comment|/* Relative jumps instructions are taken care of separately.  We have to make      sure that the relative branch is within the range -128..127.  If it's out      of range, the instructions are changed into absolute instructions.      This is not supported for the brset and brclr instructions.  */
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|->
name|format
operator|&
operator|(
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
operator|)
operator|&&
operator|!
operator|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_BITMASK
operator|)
condition|)
name|build_jump_insn
argument_list|(
name|opcode
argument_list|,
name|operands
argument_list|,
name|nb_operands
argument_list|,
name|branch_optimize
argument_list|)
expr_stmt|;
else|else
name|build_insn
argument_list|(
name|opcode
argument_list|,
name|operands
argument_list|,
name|nb_operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pseudo op to control the ELF flags.  */
end_comment

begin_function
specifier|static
name|void
name|s_m68hc11_mode
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mshort"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elf_flags
operator|&=
operator|~
name|E_M68HC11_I32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mlong"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elf_flags
operator||=
name|E_M68HC11_I32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mshort-double"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elf_flags
operator|&=
operator|~
name|E_M68HC11_F64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mlong-double"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elf_flags
operator||=
name|E_M68HC11_F64
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid mode: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the symbols with STO_M68HC12_FAR to indicate the functions    are using 'rtc' for returning.  It is necessary to use 'call'    to invoke them.  This is also used by the debugger to correctly    find the stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|s_m68hc11_mark_symbol
parameter_list|(
name|int
name|mark
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|asymbol
modifier|*
name|bfdsym
decl_stmt|;
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|bfdsym
operator|=
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|elfsym
operator|=
name|elf_symbol_from
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|bfdsym
argument_list|)
argument_list|,
name|bfdsym
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|elfsym
argument_list|)
expr_stmt|;
comment|/* Mark the symbol far (using rtc for function return).  */
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator||=
name|mark
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_m68hc11_relax
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .relax format"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|&
name|ex
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_M68HC11_RL_GROUP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocation, relaxation and frag conversions.  */
end_comment

begin_comment
comment|/* PC-relative offsets are relative to the start of the    next instruction.  That is, the address of the offset, plus its    size, since the offset is always the last part of the insn.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M68HC11_RL_JUMP
condition|)
return|return
literal|0
return|;
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* If while processing a fixup, a reloc really needs to be created    then it is done here.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
literal|0
condition|)
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
else|else
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Relocation %d is not supported by object file format."
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Since we use Rel instead of Rela, encode the vtable entry to be      used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* We need a port-specific relaxation function to cope with sym2 - sym1    relative expressions with both symbols in the same segment (but not    necessarily in the same frag as this insn), for example:      ldab sym2-(sym1-2),pc     sym1:    The offset can be 5, 9 or 16 bits long.  */
end_comment

begin_function
name|long
name|m68hc11_relax_frag
parameter_list|(
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|growth
decl_stmt|;
name|offsetT
name|aim
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
name|relax_substateT
name|next_state
decl_stmt|;
name|relax_substateT
name|this_state
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|table
init|=
name|TC_GENERIC_RELAX_TABLE
decl_stmt|;
comment|/* We only have to cope with frags as prepared by      md_estimate_size_before_relax.  The STATE_BITS16 case may geet here      because of the different reasons that it's not relaxable.  */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS16
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS16
argument_list|)
case|:
comment|/* When we get to this state, the frag won't grow any more.  */
return|return
literal|0
return|;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS5
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS5
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS9
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS9
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|==
name|NULL
operator|||
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: fr_symbol %lx"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
if|if
condition|(
name|symbol_resolved_p
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: resolved symbol"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|aim
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency problem in %s: fr_subtype %d"
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
comment|/* The rest is stolen from relax_frag.  There's no obvious way to      share the code, but fortunately no requirement to keep in sync as      long as fragP->fr_symbol does not have its segment changed.  */
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
expr_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look forwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
expr_stmt|;
if|if
condition|(
name|growth
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|long
name|value
decl_stmt|;
name|long
name|disp
decl_stmt|;
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_literal
decl_stmt|;
comment|/* Address in object code of the displacement.  */
specifier|register
name|int
name|object_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
name|buffer_address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* The displacement of the address, from current location.  */
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|(
name|value
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
operator|-
name|object_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|disp
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* This relax is only for bsr and bra.  */
name|assert
argument_list|(
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BSR
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BRA
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6812_BSR
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|convert_branch
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH_6812
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|disp
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* Invert branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Branch offset.  */
name|buffer_address
index|[
literal|0
index|]
operator|=
name|M6811_JMP
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH_6812
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* Translate branch into a long branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|M6811_OPCODE_PAGE2
expr_stmt|;
name|fixp
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_pcrel_adjust
operator|=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS5
argument_list|)
case|:
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|!=
literal|0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
condition|)
name|value
operator|=
name|disp
expr_stmt|;
comment|/* fall through  */
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS5
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|<<
literal|6
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
name|value
operator|&
literal|0x1f
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS9
argument_list|)
case|:
comment|/* For a PC-relative offset, use the displacement with a -1 correction          to take into account the additional byte of the insn.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|!=
literal|0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
condition|)
name|value
operator|=
name|disp
operator|-
literal|1
expr_stmt|;
comment|/* fall through  */
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS9
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
literal|0xE0
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|1
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|value
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS16
argument_list|)
case|:
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS16
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
literal|0xe2
expr_stmt|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|&
literal|0x0ff
operator|)
operator|==
literal|0x0fa
operator|&&
name|fragP
operator|->
name|fr_symbol
operator|!=
literal|0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|absolute_section
condition|)
block|{
name|fixp
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_XBCC_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
if|if
condition|(
name|disp
operator|<
literal|0
condition|)
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
literal|0x10
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|disp
operator|&
literal|0x0FF
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_XBCC_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* Invert branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|0x20
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Branch offset.  */
name|buffer_address
index|[
literal|0
index|]
operator|=
name|M6812_JMP
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* On an ELF system, we can't relax a weak symbol.  The weak symbol    can be overridden at final link time by a non weak symbol.  We can    relax externally visible symbol because there is no shared library    and such symbol can't be overridden (unless they are weak).  */
end_comment

begin_function
specifier|static
name|int
name|relaxable_symbol
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|)
block|{
return|return
operator|!
name|S_IS_WEAK
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Force truly undefined symbols to their maximum size, and generally set up    the frag list to be relaxed.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|,
name|asection
modifier|*
name|segment
parameter_list|)
block|{
if|if
condition|(
name|RELAX_LENGTH
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_UNDF
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
operator|||
operator|!
name|relaxable_symbol
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|||
operator|(
name|segment
operator|!=
name|absolute_section
operator|&&
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
operator|==
name|STATE_INDEXED_OFFSET
operator|)
condition|)
block|{
comment|/* Non-relaxable cases.  */
name|int
name|old_fr_fix
decl_stmt|;
name|char
modifier|*
name|buffer_address
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|buffer_address
operator|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
expr_stmt|;
switch|switch
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|STATE_PC_RELATIVE
case|:
comment|/* This relax is only for bsr and bra.  */
name|assert
argument_list|(
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BSR
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BRA
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6812_BSR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_fixed_branches
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"bra or bsr with undefined symbol."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The symbol is undefined or in a separate section. 		 Turn bra into a jmp and bsr into a jsr.  The insn 		 becomes 3 bytes long (instead of 2).  A fixup is 		 necessary for the unresolved symbol address.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|convert_branch
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|++
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6811
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Skip next jmp insn (3 bytes).  */
comment|/* Don't use fr_opcode[2] because this may be 		 in a different frag.  */
name|buffer_address
index|[
literal|0
index|]
operator|=
name|M6811_JMP
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|++
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|STATE_INDEXED_OFFSET
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS5
argument_list|)
expr_stmt|;
comment|/* Return the size of the variable part of the frag. */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
else|else
block|{
comment|/* Switch the indexed operation to 16-bit mode.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|<<
literal|3
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
literal|0xe2
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INDEXED_PCREL
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS5
argument_list|)
expr_stmt|;
comment|/* Return the size of the variable part of the frag. */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
else|else
block|{
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|<<
literal|3
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator||=
literal|0xe2
expr_stmt|;
name|fixp
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|STATE_XBCC_BRANCH
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|0x20
expr_stmt|;
comment|/* Reverse sense of branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Skip next jmp insn (3 bytes).  */
comment|/* Don't use fr_opcode[2] because this may be 		 in a different frag.  */
name|buffer_address
index|[
literal|0
index|]
operator|=
name|M6812_JMP
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|++
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH_6812
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
comment|/* Translate into a lbcc branch.  */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
name|M6811_OPCODE_PAGE2
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Subtype %d is not recognized."
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/* Return the growth in the fixed part of the frag.  */
return|return
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
return|;
block|}
comment|/* Relaxable cases.  */
switch|switch
condition|(
name|RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
case|case
name|STATE_PC_RELATIVE
case|:
comment|/* This relax is only for bsr and bra.  */
name|assert
argument_list|(
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BSR
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6811_BRA
argument_list|)
operator|||
name|IS_OPCODE
argument_list|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|M6812_BSR
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6811
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INDEXED_OFFSET
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_OFFSET
argument_list|,
name|STATE_BITS5
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INDEXED_PCREL
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_INDEXED_PCREL
argument_list|,
name|STATE_BITS5
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_XBCC_BRANCH
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_XBCC_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_CONDITIONAL_BRANCH_6812
case|:
name|assert
argument_list|(
name|current_architecture
operator|&
name|cpu6812
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH_6812
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|>=
sizeof|sizeof
argument_list|(
name|md_relax_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|md_relax_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Subtype %d is not recognized."
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* Return the size of the variable part of the frag.  */
return|return
name|md_relax_table
index|[
name|fragP
operator|->
name|fr_subtype
index|]
operator|.
name|rlx_length
return|;
block|}
end_function

begin_comment
comment|/* See whether we need to force a relocation into the output file.  */
end_comment

begin_function
name|int
name|tc_m68hc11_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_M68HC11_RL_GROUP
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fixP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Here we decide which fixups can be adjusted to make them relative    to the beginning of the section instead of the symbol.  Basically    we need to make sure that the linker relaxation is done    correctly, so in some cases we force the original symbol to be    used.  */
end_comment

begin_function
name|int
name|tc_m68hc11_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* For the linker relaxation to work correctly, these relocs          need to be on the symbol itself.  */
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_M68HC11_RL_JUMP
case|:
case|case
name|BFD_RELOC_M68HC11_RL_GROUP
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_32
case|:
comment|/* The memory bank addressing translation also needs the original          symbol.  */
case|case
name|BFD_RELOC_M68HC11_LO16
case|:
case|case
name|BFD_RELOC_M68HC11_PAGE
case|:
case|case
name|BFD_RELOC_M68HC11_24
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|long
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|int
name|op_type
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* We don't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Expression too complex."
argument_list|)
argument_list|)
expr_stmt|;
name|op_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
comment|/* Patch the instruction with the resolved operand.  Elf relocation      info will also be generated to take care of linker/loader fixups.      The 68HC11 addresses only 64Kb, we are only concerned by 8 and 16-bit      relocs.  BFD_RELOC_8 is basically used for .page0 access (the linker      will warn for overflows).  BFD_RELOC_8_PCREL should not be generated      because it's either resolved or turned out into non-relative insns (see      relax table, bcc, bra, bsr transformations)       The BFD_RELOC_32 is necessary for the support of --gstabs.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24
case|:
case|case
name|BFD_RELOC_M68HC11_24
case|:
name|bfd_putb16
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
name|value
operator|&
literal|0x0ffff
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|where
operator|)
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_M68HC11_LO16
case|:
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|65537
operator|||
name|value
operator|>
literal|65535
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value out of 16-bit range."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M68HC11_HI8
case|:
name|value
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_M68HC11_LO8
case|:
case|case
name|BFD_RELOC_8
case|:
case|case
name|BFD_RELOC_M68HC11_PAGE
case|:
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|where
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8_PCREL
case|:
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|where
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|128
operator|||
name|value
operator|>
literal|127
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value %ld too large for 8-bit PC-relative branch."
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M68HC11_3B
case|:
if|if
condition|(
name|value
operator|<=
literal|0
operator|||
name|value
operator|>
literal|8
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Auto increment/decrement offset '%ld' is out of range."
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
index|[
literal|0
index|]
operator|&
literal|0x8
condition|)
name|value
operator|=
literal|8
operator|-
name|value
expr_stmt|;
else|else
name|value
operator|--
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|where
index|[
literal|0
index|]
operator||
operator|(
name|value
operator|&
literal|0x07
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M68HC12_5B
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|16
operator|||
name|value
operator|>
literal|15
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Offset out of 5-bit range for movw/movb insn: %ld"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|where
index|[
literal|0
index|]
operator||=
name|value
expr_stmt|;
else|else
name|where
index|[
literal|0
index|]
operator||=
operator|(
literal|0x10
operator||
operator|(
literal|16
operator|+
name|value
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_M68HC11_RL_JUMP
case|:
case|case
name|BFD_RELOC_M68HC11_RL_GROUP
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Line %d: unknown relocation type: 0x%x."
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the ELF specific flags.  */
end_comment

begin_function
name|void
name|m68hc11_elf_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_architecture
operator|&
name|cpu6812s
condition|)
name|elf_flags
operator||=
name|EF_M68HCS12_MACH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_M68HC11_ABI
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|elf_flags
expr_stmt|;
block|}
end_function

end_unit

