begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2014 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)  * ("CTSRD"), as part of the DARPA CRASH research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 1998 Robert Nordier  * All rights reserved.  *  * Redistribution and use in source and binary forms are freely  * permitted provided that the above copyright notice and this  * paragraph and the following disclaimer are duplicated in all  * such forms.  *  * This software is provided "AS IS" and without any express or  * implied warranties, including, without limitation, the implied  * warranties of merchantability and fitness for a particular  * purpose.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskmbr.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<beri.h>
end_include

begin_include
include|#
directive|include
file|<cfi.h>
end_include

begin_include
include|#
directive|include
file|<cons.h>
end_include

begin_include
include|#
directive|include
file|<mips.h>
end_include

begin_include
include|#
directive|include
file|<sdcard.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"rbx.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|beri_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|beri_argv
decl_stmt|,
modifier|*
modifier|*
name|beri_envv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|beri_memsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IO_KEYBOARD
value|1
end_define

begin_define
define|#
directive|define
name|IO_SERIAL
value|2
end_define

begin_define
define|#
directive|define
name|SECOND
value|1
end_define

begin_comment
comment|/* Circa that many ticks in a second. */
end_comment

begin_define
define|#
directive|define
name|ARGS
value|0x900
end_define

begin_define
define|#
directive|define
name|NOPT
value|14
end_define

begin_define
define|#
directive|define
name|MEM_BASE
value|0x12
end_define

begin_define
define|#
directive|define
name|MEM_EXT
value|0x15
end_define

begin_comment
comment|/*  * XXXRW: I think this has to do with whether boot2 expects a partition  * table?  */
end_comment

begin_define
define|#
directive|define
name|DRV_HARD
value|0x80
end_define

begin_define
define|#
directive|define
name|DRV_MASK
value|0x7f
end_define

begin_comment
comment|/* Default to using CFI flash. */
end_comment

begin_define
define|#
directive|define
name|TYPE_DEFAULT
value|BOOTINFO_DEV_TYPE_SDCARD
end_define

begin_comment
comment|/* Hard-coded assumption about location of JTAG-loaded kernel. */
end_comment

begin_define
define|#
directive|define
name|DRAM_KERNEL_ADDR
value|((void *)mips_phys_to_cached(0x20000))
end_define

begin_decl_stmt
specifier|extern
name|uint32_t
name|_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|optstr
index|[
name|NOPT
index|]
init|=
literal|"DhaCcdgmnpqrsv"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also 'P', 'S' */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|flags
index|[
name|NOPT
index|]
init|=
block|{
name|RBX_DUAL
block|,
name|RBX_SERIAL
block|,
name|RBX_ASKNAME
block|,
name|RBX_CDROM
block|,
name|RBX_CONFIG
block|,
name|RBX_KDB
block|,
name|RBX_GDB
block|,
name|RBX_MUTE
block|,
name|RBX_NOINTR
block|,
name|RBX_PAUSE
block|,
name|RBX_QUIET
block|,
name|RBX_DFLTROOT
block|,
name|RBX_SINGLE
block|,
name|RBX_VERBOSE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These must match BOOTINFO_DEV_TYPE constants. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dev_nm
index|[]
init|=
block|{
literal|"dram"
block|,
literal|"cfi"
block|,
literal|"sdcard"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|dev_nm_count
init|=
name|nitems
argument_list|(
name|dev_nm
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dmadat
name|__dmadat
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dsk
block|{
name|unsigned
name|type
decl_stmt|;
comment|/* BOOTINFO_DEV_TYPE_x object type. */
name|uintptr_t
name|unitptr
decl_stmt|;
comment|/* Unit number or pointer to object. */
name|uint8_t
name|slice
decl_stmt|;
name|uint8_t
name|part
decl_stmt|;
if|#
directive|if
literal|0
block|unsigned start;     int init;
endif|#
directive|endif
block|}
name|dsk
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|cmd
index|[
literal|512
index|]
decl_stmt|,
name|cmddup
index|[
literal|512
index|]
decl_stmt|,
name|knamebuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|kname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|opts
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int comspeed = SIOSPD;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|ioctrl
init|=
name|IO_KEYBOARD
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|exit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|putchar
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|boot_fromdram
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|boot_fromfs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dskread
parameter_list|(
name|void
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xputc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xgetc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|UFS_SMALL_CGBASE
end_define

begin_include
include|#
directive|include
file|"ufsread.c"
end_include

begin_function
specifier|static
specifier|inline
name|int
name|xfsread
parameter_list|(
name|ufs_ino_t
name|inode
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbyte
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|fsread
argument_list|(
name|inode
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|!=
name|nbyte
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid %s\n"
argument_list|,
literal|"format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|getstr
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|s
operator|=
name|cmd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|xgetc
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'\177'
case|:
case|case
literal|'\b'
case|:
if|if
condition|(
name|s
operator|>
name|cmd
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|s
operator|-
name|cmd
operator|<
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|-
literal|1
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|u_int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|envv
index|[]
parameter_list|,
name|uint64_t
name|memsize
parameter_list|)
block|{
name|uint8_t
name|autoboot
decl_stmt|;
name|ufs_ino_t
name|ino
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
comment|/* Arguments from Miniboot. */
name|beri_argc
operator|=
name|argc
expr_stmt|;
name|beri_argv
operator|=
name|argv
expr_stmt|;
name|beri_envv
operator|=
name|envv
expr_stmt|;
name|beri_memsize
operator|=
name|memsize
expr_stmt|;
name|dmadat
operator|=
operator|&
name|__dmadat
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXXRW: more here. */
block|v86.ctl = V86_FLAGS;     v86.efl = PSL_RESERVED_DEFAULT | PSL_I;     dsk.drive = *(uint8_t *)PTOV(ARGS);
endif|#
directive|endif
name|dsk
operator|.
name|type
operator|=
name|TYPE_DEFAULT
expr_stmt|;
if|#
directive|if
literal|0
block|dsk.unit = dsk.drive& DRV_MASK;     dsk.slice = *(uint8_t *)PTOV(ARGS + 1) + 1;
endif|#
directive|endif
name|bootinfo
operator|.
name|bi_version
operator|=
name|BOOTINFO_VERSION
expr_stmt|;
name|bootinfo
operator|.
name|bi_size
operator|=
sizeof|sizeof
argument_list|(
name|bootinfo
argument_list|)
expr_stmt|;
comment|/* Process configuration file */
name|autoboot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ino
operator|=
name|lookup
argument_list|(
name|PATH_CONFIG
argument_list|)
operator|)
operator|||
operator|(
name|ino
operator|=
name|lookup
argument_list|(
name|PATH_DOTCONFIG
argument_list|)
operator|)
condition|)
block|{
name|nbyte
operator|=
name|fsread
argument_list|(
name|ino
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmd
index|[
name|nbyte
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
condition|)
block|{
name|memcpy
argument_list|(
name|cmddup
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
argument_list|()
condition|)
name|autoboot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|OPT_CHECK
argument_list|(
name|RBX_QUIET
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|PATH_CONFIG
argument_list|,
name|cmddup
argument_list|)
expr_stmt|;
comment|/* Do not process this command twice */
operator|*
name|cmd
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Try to exec stage 3 boot loader. If interrupted by a keypress,      * or in case of failure, try to load a kernel directly instead.      */
if|if
condition|(
operator|!
name|kname
condition|)
block|{
name|kname
operator|=
name|PATH_LOADER
expr_stmt|;
if|if
condition|(
name|autoboot
operator|&&
operator|!
name|keyhit
argument_list|(
literal|3
operator|*
name|SECOND
argument_list|)
condition|)
block|{
name|boot_fromfs
argument_list|()
expr_stmt|;
name|kname
operator|=
name|PATH_KERNEL
expr_stmt|;
block|}
block|}
comment|/* Present the user with the boot2 prompt. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|autoboot
operator|||
operator|!
name|OPT_CHECK
argument_list|(
name|RBX_QUIET
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\nFreeBSD/mips boot\n"
literal|"Default: %s%ju:%s\n"
literal|"boot: "
argument_list|,
name|dev_nm
index|[
name|dsk
operator|.
name|type
index|]
argument_list|,
name|dsk
operator|.
name|unitptr
argument_list|,
name|kname
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (ioctrl& IO_SERIAL) 	    sio_flush();
endif|#
directive|endif
if|if
condition|(
operator|!
name|autoboot
operator|||
name|keyhit
argument_list|(
literal|3
operator|*
name|SECOND
argument_list|)
condition|)
name|getstr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|autoboot
operator|||
operator|!
name|OPT_CHECK
argument_list|(
name|RBX_QUIET
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|autoboot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parse
argument_list|()
condition|)
name|putchar
argument_list|(
literal|'\a'
argument_list|)
expr_stmt|;
else|else
name|load
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX - Needed for btxld to link the boot2 binary; do not remove. */
end_comment

begin_function
name|void
name|exit
parameter_list|(
name|int
name|x
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|boot
parameter_list|(
name|void
modifier|*
name|entryp
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|envv
index|[]
parameter_list|)
block|{
name|bootinfo
operator|.
name|bi_kernelname
operator|=
operator|(
name|bi_ptr_t
operator|)
name|kname
expr_stmt|;
name|bootinfo
operator|.
name|bi_boot2opts
operator|=
name|opts
operator|&
name|RBX_MASK
expr_stmt|;
name|bootinfo
operator|.
name|bi_boot_dev_type
operator|=
name|dsk
operator|.
name|type
expr_stmt|;
name|bootinfo
operator|.
name|bi_boot_dev_unitptr
operator|=
name|dsk
operator|.
name|unitptr
expr_stmt|;
name|bootinfo
operator|.
name|bi_memsize
operator|=
name|beri_memsize
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * XXXRW: A possible future way to distinguish Miniboot passing a memory      * size vs DTB..?      */
block|if (beri_memsize<= BERI_MEMVSDTB) 	bootinfo.bi_memsize = beri_memsize;     else 	bootinfo.bi_dtb = beri_memsize;
endif|#
directive|endif
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
specifier|const
name|char
operator|*
operator|*
argument_list|,
specifier|const
name|char
operator|*
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|entryp
operator|)
operator|(
name|argc
operator|,
name|argv
operator|,
name|envv
operator|,
operator|&
name|bootinfo
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Boot a kernel that has mysteriously (i.e., by JTAG) appeared in DRAM;  * assume that it is already properly relocated, etc, and invoke its entry  * address without question or concern.  */
end_comment

begin_function
specifier|static
name|void
name|boot_fromdram
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|kaddr
init|=
name|DRAM_KERNEL_ADDR
decl_stmt|;
comment|/* XXXRW: Something better here. */
name|Elf64_Ehdr
modifier|*
name|ehp
init|=
name|kaddr
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|ehp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid %s\n"
argument_list|,
literal|"format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|boot
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ehp
operator|->
name|e_entry
argument_list|,
name|beri_argc
argument_list|,
name|beri_argv
argument_list|,
name|beri_envv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|boot_fromfs
parameter_list|(
name|void
parameter_list|)
block|{
union|union
block|{
name|Elf64_Ehdr
name|eh
decl_stmt|;
block|}
name|hdr
union|;
specifier|static
name|Elf64_Phdr
name|ep
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|static Elf64_Shdr es[2];
endif|#
directive|endif
name|caddr_t
name|p
decl_stmt|;
name|ufs_ino_t
name|ino
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ino
operator|=
name|lookup
argument_list|(
name|kname
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ls
condition|)
name|printf
argument_list|(
literal|"No %s\n"
argument_list|,
name|kname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xfsread
argument_list|(
name|ino
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|IS_ELF
argument_list|(
name|hdr
operator|.
name|eh
argument_list|)
condition|)
block|{
name|fs_off
operator|=
name|hdr
operator|.
name|eh
operator|.
name|e_phoff
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|eh
operator|.
name|e_phnum
operator|&&
name|j
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xfsread
argument_list|(
name|ino
argument_list|,
name|ep
operator|+
name|j
argument_list|,
sizeof|sizeof
argument_list|(
name|ep
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ep
index|[
name|j
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
condition|)
name|j
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|p_paddr
expr_stmt|;
name|fs_off
operator|=
name|ep
index|[
name|i
index|]
operator|.
name|p_offset
expr_stmt|;
if|if
condition|(
name|xfsread
argument_list|(
name|ino
argument_list|,
name|p
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|)
condition|)
return|return;
block|}
name|p
operator|+=
name|roundup2
argument_list|(
name|ep
index|[
literal|1
index|]
operator|.
name|p_memsz
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bootinfo.bi_symtab = VTOP(p); 	if (hdr.eh.e_shnum == hdr.eh.e_shstrndx + 3) { 	    fs_off = hdr.eh.e_shoff + sizeof(es[0]) * 		(hdr.eh.e_shstrndx + 1); 	    if (xfsread(ino,&es, sizeof(es))) 		return; 	    for (i = 0; i< 2; i++) { 		*(Elf32_Word *)p = es[i].sh_size; 		p += sizeof(es[i].sh_size); 		fs_off = es[i].sh_offset; 		if (xfsread(ino, p, es[i].sh_size)) 		    return; 		p += es[i].sh_size; 	    } 	}
endif|#
directive|endif
name|addr
operator|=
name|hdr
operator|.
name|eh
operator|.
name|e_entry
expr_stmt|;
if|#
directive|if
literal|0
block|bootinfo.bi_esymtab = VTOP(p);
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Invalid %s\n"
argument_list|,
literal|"format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|boot
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|beri_argc
argument_list|,
name|beri_argv
argument_list|,
name|beri_envv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|load
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|dsk
operator|.
name|type
condition|)
block|{
case|case
name|BOOTINFO_DEV_TYPE_DRAM
case|:
name|boot_fromdram
argument_list|()
expr_stmt|;
break|break;
default|default:
name|boot_fromfs
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse
parameter_list|()
block|{
name|char
modifier|*
name|arg
init|=
name|cmd
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|unit
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
literal|0
block|int c, i, j;
else|#
directive|else
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|arg
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|arg
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|ep
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|arg
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'P'
condition|)
block|{
name|cp
operator|=
literal|"yes"
expr_stmt|;
if|#
directive|if
literal|0
block|} else { 			opts |= OPT_SET(RBX_DUAL) | OPT_SET(RBX_SERIAL); 			cp = "no"; 		    }
endif|#
directive|endif
name|printf
argument_list|(
literal|"Keyboard: %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
if|#
directive|if
literal|0
block|} else if (c == 'S') { 		    j = 0; 		    while ((unsigned int)(i = *arg++ - '0')<= 9) 			j = j * 10 + i; 		    if (j> 0&& i == -'0') { 			comspeed = j; 			break; 		    }
comment|/* Fall through to error below ('S' not in optstr[]). */
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|!=
name|optstr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|NOPT
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|opts
operator|^=
name|OPT_SET
argument_list|(
name|flags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ioctrl
operator|=
name|OPT_CHECK
argument_list|(
name|RBX_DUAL
argument_list|)
condition|?
operator|(
name|IO_SERIAL
operator||
name|IO_KEYBOARD
operator|)
else|:
name|OPT_CHECK
argument_list|(
name|RBX_SERIAL
argument_list|)
condition|?
name|IO_SERIAL
else|:
name|IO_KEYBOARD
expr_stmt|;
if|#
directive|if
literal|0
block|if (ioctrl& IO_SERIAL) { 	        if (sio_init(115200 / comspeed) != 0) 		    ioctrl&= ~IO_SERIAL; 	    }
endif|#
directive|endif
block|}
else|else
block|{
comment|/*- 	     * Parse a device/kernel name.  Format(s): 	     * 	     *   path 	     *   deviceX:path 	     * 	     * NB: Utterly incomprehensible but space-efficient ARM/i386 	     * parsing removed in favour of larger but easier-to-read C.  This 	     * is still not great, however -- e.g., relating to unit handling. 	     * 	     * TODO: it would be nice if a DRAM pointer could be specified 	     * here. 	     * 	     * XXXRW: Pick up pieces here. 	     */
comment|/* 	     * Search for a parens; if none, then it's just a path. 	     * Otherwise, it's a devicename. 	     */
name|arg
operator|--
expr_stmt|;
name|q
operator|=
name|strsep
argument_list|(
operator|&
name|arg
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid device: name too short\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * First, handle one-digit unit. 		 */
name|unit
operator|=
name|q
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|'0'
operator|||
name|unit
operator|>
literal|'9'
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid device: invalid unit\n"
argument_list|,
name|q
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|unit
operator|-=
literal|'0'
expr_stmt|;
name|q
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Next, find matching device. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_nm_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|dev_nm
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|dev_nm_count
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid device: no driver match\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dsk
operator|.
name|type
operator|=
name|i
expr_stmt|;
name|dsk
operator|.
name|unitptr
operator|=
name|unit
expr_stmt|;
comment|/* Someday: also a DRAM pointer? */
block|}
else|else
name|arg
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|ep
operator|-
name|arg
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|knamebuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|knamebuf
argument_list|,
name|arg
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kname
operator|=
name|knamebuf
expr_stmt|;
block|}
block|}
name|arg
operator|=
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drvread
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|lba
parameter_list|,
name|unsigned
name|nblk
parameter_list|)
block|{
comment|/* XXXRW: eventually, we may want to pass 'drive' and 'unit' here. */
switch|switch
condition|(
name|dsk
operator|.
name|type
condition|)
block|{
case|case
name|BOOTINFO_DEV_TYPE_CFI
case|:
return|return
operator|(
name|cfi_read
argument_list|(
name|buf
argument_list|,
name|lba
argument_list|,
name|nblk
argument_list|)
operator|)
return|;
case|case
name|BOOTINFO_DEV_TYPE_SDCARD
case|:
return|return
operator|(
name|altera_sdcard_read
argument_list|(
name|buf
argument_list|,
name|lba
argument_list|,
name|nblk
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dskread
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|lba
parameter_list|,
name|unsigned
name|nblk
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/*      * XXXRW: For now, assume no partition table around the file system; it's      * just in raw flash.      */
block|struct dos_partition *dp;     struct disklabel *d;     char *sec;     unsigned i;     uint8_t sl;      if (!dsk_meta) { 	sec = dmadat->secbuf; 	dsk.start = 0; 	if (drvread(sec, DOSBBSECTOR, 1)) 	    return -1; 	dp = (void *)(sec + DOSPARTOFF); 	sl = dsk.slice; 	if (sl< BASE_SLICE) { 	    for (i = 0; i< NDOSPART; i++) 		if (dp[i].dp_typ == DOSPTYP_386BSD&& 		    (dp[i].dp_flag& 0x80 || sl< BASE_SLICE)) { 		    sl = BASE_SLICE + i; 		    if (dp[i].dp_flag& 0x80 || 			dsk.slice == COMPATIBILITY_SLICE) 			break; 		} 	    if (dsk.slice == WHOLE_DISK_SLICE) 		dsk.slice = sl; 	} 	if (sl != WHOLE_DISK_SLICE) { 	    if (sl != COMPATIBILITY_SLICE) 		dp += sl - BASE_SLICE; 	    if (dp->dp_typ != DOSPTYP_386BSD) { 		printf("Invalid %s\n", "slice"); 		return -1; 	    } 	    dsk.start = le32toh(dp->dp_start); 	} 	if (drvread(sec, dsk.start + LABELSECTOR, 1)) 		return -1; 	d = (void *)(sec + LABELOFFSET); 	if (le32toh(d->d_magic) != DISKMAGIC || 	    le32toh(d->d_magic2) != DISKMAGIC) { 	    if (dsk.part != RAW_PART) { 		printf("Invalid %s\n", "label"); 		return -1; 	    } 	} else { 	    if (!dsk.init) { 		if (le16toh(d->d_type) == DTYPE_SCSI) 		    dsk.type = TYPE_DA; 		dsk.init++; 	    } 	    if (dsk.part>= le16toh(d->d_npartitions) || 		!(le32toh(d->d_partitions[dsk.part].p_size))) { 		printf("Invalid %s\n", "partition"); 		return -1; 	    } 	    dsk.start += le32toh(d->d_partitions[dsk.part].p_offset); 	    dsk.start -= le32toh(d->d_partitions[RAW_PART].p_offset); 	}     }     return drvread(buf, dsk.start + lba, nblk);
else|#
directive|else
return|return
name|drvread
argument_list|(
name|buf
argument_list|,
name|lba
argument_list|,
name|nblk
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|putchar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|xputc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|xputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xputc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ioctrl
operator|&
name|IO_KEYBOARD
condition|)
name|putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (ioctrl& IO_SERIAL) 	sio_putc(c);
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xgetc
parameter_list|(
name|int
name|fn
parameter_list|)
block|{
if|if
condition|(
name|OPT_CHECK
argument_list|(
name|RBX_NOINTR
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ioctrl
operator|&
name|IO_KEYBOARD
operator|&&
name|keyhit
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|fn
condition|?
literal|1
else|:
name|getc
argument_list|()
return|;
if|#
directive|if
literal|0
block|if (ioctrl& IO_SERIAL&& sio_ischar()) 	    return fn ? 1 : sio_getc();
endif|#
directive|endif
if|if
condition|(
name|fn
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

