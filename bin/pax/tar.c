begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)tar.c	8.2 (Berkeley) 4/18/94";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_comment
comment|/*  * Routines for reading, writing and header identify of various versions of tar  */
end_comment

begin_function_decl
specifier|static
name|u_long
name|tar_chksm
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|name_split
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ul_oct
parameter_list|(
name|u_long
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NET2_STAT
end_ifndef

begin_function_decl
specifier|static
name|int
name|uqd_oct
parameter_list|(
name|u_quad_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Routines common to all versions of tar  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tar_nodir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do not write dirs under old tar */
end_comment

begin_comment
comment|/*  * tar_endwr()  *	add the tar trailer of two null blocks  * Return:  *	0 if ok, -1 otherwise (what wr_skip returns)  */
end_comment

begin_function
name|int
name|tar_endwr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|NULLCNT
operator|*
name|BLKMULT
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tar_endrd()  *	no cleanup needed here, just return size of trailer (for append)  * Return:  *	size of trailer (2 * BLKMULT)  */
end_comment

begin_function
name|off_t
name|tar_endrd
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
call|(
name|off_t
call|)
argument_list|(
name|NULLCNT
operator|*
name|BLKMULT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tar_trail()  *	Called to determine if a header block is a valid trailer. We are passed  *	the block, the in_sync flag (which tells us we are in resync mode;  *	looking for a valid header), and cnt (which starts at zero) which is  *	used to count the number of empty blocks we have seen so far.  * Return:  *	0 if a valid trailer, -1 if not a valid trailer, or 1 if the block  *	could never contain a header.  */
end_comment

begin_function
name|int
name|tar_trail
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|in_resync
parameter_list|,
name|int
modifier|*
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * look for all zero, trailer is two consecutive blocks of zero 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLKMULT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
break|break;
block|}
comment|/* 	 * if not all zero it is not a trailer, but MIGHT be a header. 	 */
if|if
condition|(
name|i
operator|!=
name|BLKMULT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * When given a zero block, we must be careful! 	 * If we are not in resync mode, check for the trailer. Have to watch 	 * out that we do not mis-identify file data as the trailer, so we do 	 * NOT try to id a trailer during resync mode. During resync mode we 	 * might as well throw this block out since a valid header can NEVER be 	 * a block of all 0 (we must have a valid file name). 	 */
if|if
condition|(
operator|!
name|in_resync
operator|&&
operator|(
operator|++
operator|*
name|cnt
operator|>=
name|NULLCNT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ul_oct()  *	convert an unsigned long to an octal string. many oddball field  *	termination characters are used by the various versions of tar in the  *	different fields. term selects which kind to use. str is '0' padded  *	at the front to len. we are unable to use only one format as many old  *	tar readers are very cranky about this.  * Return:  *	0 if the number fit into the string, -1 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|ul_oct
parameter_list|(
name|u_long
name|val
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|term
parameter_list|)
block|{
name|char
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * term selects the appropriate character(s) for the end of the string 	 */
name|pt
operator|=
name|str
operator|+
name|len
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|term
condition|)
block|{
case|case
literal|3
case|:
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
comment|/* 	 * convert and blank pad if there is space 	 */
while|while
condition|(
name|pt
operator|>=
name|str
condition|)
block|{
operator|*
name|pt
operator|--
operator|=
literal|'0'
operator|+
call|(
name|char
call|)
argument_list|(
name|val
operator|&
literal|0x7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|val
operator|>>
literal|3
operator|)
operator|==
operator|(
name|u_long
operator|)
literal|0
condition|)
break|break;
block|}
while|while
condition|(
name|pt
operator|>=
name|str
condition|)
operator|*
name|pt
operator|--
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|(
name|u_long
operator|)
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NET2_STAT
end_ifndef

begin_comment
comment|/*  * uqd_oct()  *	convert an u_quad_t to an octal string. one of many oddball field  *	termination characters are used by the various versions of tar in the  *	different fields. term selects which kind to use. str is '0' padded  *	at the front to len. we are unable to use only one format as many old  *	tar readers are very cranky about this.  * Return:  *	0 if the number fit into the string, -1 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|uqd_oct
parameter_list|(
name|u_quad_t
name|val
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|term
parameter_list|)
block|{
name|char
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * term selects the appropriate character(s) for the end of the string 	 */
name|pt
operator|=
name|str
operator|+
name|len
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|term
condition|)
block|{
case|case
literal|3
case|:
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
operator|*
name|pt
operator|--
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pt
operator|--
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
comment|/* 	 * convert and blank pad if there is space 	 */
while|while
condition|(
name|pt
operator|>=
name|str
condition|)
block|{
operator|*
name|pt
operator|--
operator|=
literal|'0'
operator|+
call|(
name|char
call|)
argument_list|(
name|val
operator|&
literal|0x7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|val
operator|>>
literal|3
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
while|while
condition|(
name|pt
operator|>=
name|str
condition|)
operator|*
name|pt
operator|--
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|(
name|u_quad_t
operator|)
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * tar_chksm()  *	calculate the checksum for a tar block counting the checksum field as  *	all blanks (BLNKSUM is that value pre-calculated, the sum of 8 blanks).  *	NOTE: we use len to short circuit summing 0's on write since we ALWAYS  *	pad headers with 0.  * Return:  *	unsigned long checksum  */
end_comment

begin_function
specifier|static
name|u_long
name|tar_chksm
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|stop
decl_stmt|;
name|char
modifier|*
name|pt
decl_stmt|;
name|u_long
name|chksm
init|=
name|BLNKSUM
decl_stmt|;
comment|/* initial value is checksum field sum */
comment|/* 	 * add the part of the block before the checksum field 	 */
name|pt
operator|=
name|blk
expr_stmt|;
name|stop
operator|=
name|blk
operator|+
name|CHK_OFFSET
expr_stmt|;
while|while
condition|(
name|pt
operator|<
name|stop
condition|)
name|chksm
operator|+=
call|(
name|u_long
call|)
argument_list|(
operator|*
name|pt
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * move past the checksum field and keep going, spec counts the 	 * checksum field as the sum of 8 blanks (which is pre-computed as 	 * BLNKSUM). 	 * ASSUMED: len is greater than CHK_OFFSET. (len is where our 0 padding 	 * starts, no point in summing zero's) 	 */
name|pt
operator|+=
name|CHK_LEN
expr_stmt|;
name|stop
operator|=
name|blk
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|pt
operator|<
name|stop
condition|)
name|chksm
operator|+=
call|(
name|u_long
call|)
argument_list|(
operator|*
name|pt
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
name|chksm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for old BSD style tar (also made portable to sysV tar)  */
end_comment

begin_comment
comment|/*  * tar_id()  *	determine if a block given to us is a valid tar header (and not a USTAR  *	header). We have to be on the lookout for those pesky blocks of	all  *	zero's.  * Return:  *	0 if a tar header, -1 otherwise  */
end_comment

begin_function
name|int
name|tar_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|HD_TAR
modifier|*
name|hd
decl_stmt|;
name|HD_USTAR
modifier|*
name|uhd
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|BLKMULT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hd
operator|=
operator|(
name|HD_TAR
operator|*
operator|)
name|blk
expr_stmt|;
name|uhd
operator|=
operator|(
name|HD_USTAR
operator|*
operator|)
name|blk
expr_stmt|;
comment|/* 	 * check for block of zero's first, a simple and fast test, then make 	 * sure this is not a ustar header by looking for the ustar magic 	 * cookie. We should use TMAGLEN, but some USTAR archive programs are 	 * wrong and create archives missing the \0. Last we check the 	 * checksum. If this is ok we have to assume it is a valid header. 	 */
if|if
condition|(
name|hd
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|uhd
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|asc_ul
argument_list|(
name|hd
operator|->
name|chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|chksum
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|!=
name|tar_chksm
argument_list|(
name|blk
argument_list|,
name|BLKMULT
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tar_opt()  *	handle tar format specific -o options  * Return:  *	0 if ok -1 otherwise  */
end_comment

begin_function
name|int
name|tar_opt
parameter_list|(
name|void
parameter_list|)
block|{
name|OPLIST
modifier|*
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|opt_next
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|TAR_OPTION
argument_list|)
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|value
argument_list|,
name|TAR_NODIR
argument_list|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unknown tar format -o option/value pair %s=%s"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|)
expr_stmt|;
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"%s=%s is the only supported tar format option"
argument_list|,
name|TAR_OPTION
argument_list|,
name|TAR_NODIR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * we only support one option, and only when writing 		 */
if|if
condition|(
operator|(
name|act
operator|!=
name|APPND
operator|)
operator|&&
operator|(
name|act
operator|!=
name|ARCHIVE
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"%s=%s is only supported when writing."
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tar_nodir
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tar_rd()  *	extract the values out of block already determined to be a tar header.  *	store the values in the ARCHD parameter.  * Return:  *	0  */
end_comment

begin_function
name|int
name|tar_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|HD_TAR
modifier|*
name|hd
decl_stmt|;
name|char
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * we only get proper sized buffers passed to us 	 */
if|if
condition|(
name|tar_id
argument_list|(
name|buf
argument_list|,
name|BLKMULT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|org_name
operator|=
name|arcn
operator|->
name|name
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * copy out the name and values in the stat buffer 	 */
name|hd
operator|=
operator|(
name|HD_TAR
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * old tar format specifies the name always be null-terminated, 	 * but let's be robust to broken archives. 	 * the same applies to handling links below. 	 */
name|arcn
operator|->
name|nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|hd
operator|->
name|name
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|name
index|[
name|arcn
operator|->
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
call|(
name|mode_t
call|)
argument_list|(
name|asc_ul
argument_list|(
name|hd
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mode
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
operator|(
name|uid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
operator|(
name|gid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_atime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
comment|/* 	 * have to look at the last character, it may be a '/' and that is used 	 * to encode this as a directory 	 */
name|pt
operator|=
operator|&
operator|(
name|arcn
operator|->
name|name
index|[
name|arcn
operator|->
name|nlen
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|hd
operator|->
name|linkflag
condition|)
block|{
case|case
name|SYMTYPE
case|:
comment|/* 		 * symbolic link, need to get the link name and set the type in 		 * the st_mode so -v printing will look correct. 		 */
name|arcn
operator|->
name|type
operator|=
name|PAX_SLK
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|hd
operator|->
name|linkname
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
name|arcn
operator|->
name|ln_nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFLNK
expr_stmt|;
break|break;
case|case
name|LNKTYPE
case|:
comment|/* 		 * hard link, need to get the link name, set the type in the 		 * st_mode and st_nlink so -v printing will look better. 		 */
name|arcn
operator|->
name|type
operator|=
name|PAX_HLK
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|hd
operator|->
name|linkname
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
name|arcn
operator|->
name|ln_nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * no idea of what type this thing really points at, but 		 * we set something for printing only. 		 */
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
break|break;
case|case
name|DIRTYPE
case|:
comment|/* 		 * It is a directory, set the mode for -v printing 		 */
name|arcn
operator|->
name|type
operator|=
name|PAX_DIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFDIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AREGTYPE
case|:
case|case
name|REGTYPE
case|:
default|default:
comment|/* 		 * If we have a trailing / this is a directory and NOT a file. 		 */
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|pt
operator|==
literal|'/'
condition|)
block|{
comment|/* 			 * it is a directory, set the mode for -v printing 			 */
name|arcn
operator|->
name|type
operator|=
name|PAX_DIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFDIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * have a file that will be followed by data. Set the 			 * skip value to the size field and calculate the size 			 * of the padding. 			 */
name|arcn
operator|->
name|type
operator|=
name|PAX_REG
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
name|TAR_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|skip
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * strip off any trailing slash. 	 */
if|if
condition|(
operator|*
name|pt
operator|==
literal|'/'
condition|)
block|{
operator|*
name|pt
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|arcn
operator|->
name|nlen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tar_wr()  *	write a tar header for the file specified in the ARCHD to the archive.  *	Have to check for file types that cannot be stored and file names that  *	are too long. Be careful of the term (last arg) to ul_oct, each field  *	of tar has it own spec for the termination character(s).  *	ASSUMED: space after header in header block is zero filled  * Return:  *	0 if file has data to be written after the header, 1 if file has NO  *	data to write after the header, -1 if archive write failed  */
end_comment

begin_function
name|int
name|tar_wr
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|HD_TAR
modifier|*
name|hd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|HD_TAR
name|hdblk
decl_stmt|;
comment|/* 	 * check for those file system types which tar cannot store 	 */
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_DIR
case|:
comment|/* 		 * user asked that dirs not be written to the archive 		 */
if|if
condition|(
name|tar_nodir
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|PAX_CHR
case|:
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tar cannot archive a character device %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PAX_BLK
case|:
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tar cannot archive a block device %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PAX_SCK
case|:
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tar cannot archive a socket %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PAX_FIF
case|:
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tar cannot archive a fifo %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PAX_SLK
case|:
case|case
name|PAX_HLK
case|:
case|case
name|PAX_HRG
case|:
if|if
condition|(
name|arcn
operator|->
name|ln_nlen
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Link name too long for tar %s"
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PAX_REG
case|:
case|case
name|PAX_CTG
case|:
default|default:
break|break;
block|}
comment|/* 	 * check file name len, remember extra char for dirs (the / at the end) 	 */
name|len
operator|=
name|arcn
operator|->
name|nlen
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
condition|)
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File name too long for tar %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * copy the data out of the ARCHD into the tar header based on the type 	 * of the file. Remember many tar readers want the unused fields to be 	 * padded with zero. We set the linkflag field (type), the linkname 	 * (or zero if not used),the size, and set the padding (if any) to be 	 * added after the file data (0 for all other types, as they only have 	 * a header) 	 */
name|hd
operator|=
operator|&
name|hdblk
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
condition|)
block|{
comment|/* 		 * directories are the same as files, except have a filename 		 * that ends with a /, we add the slash here. No data follows, 		 * dirs, so no pad. 		 */
name|hd
operator|->
name|linkflag
operator|=
name|AREGTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
name|hd
operator|->
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SLK
condition|)
block|{
comment|/* 		 * no data follows this file, so no pad 		 */
name|hd
operator|->
name|linkflag
operator|=
name|SYMTYPE
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|linkname
index|[
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
block|{
comment|/* 		 * no data follows this file, so no pad 		 */
name|hd
operator|->
name|linkflag
operator|=
name|LNKTYPE
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|linkname
index|[
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* 		 * data follows this file, so set the pad 		 */
name|hd
operator|->
name|linkflag
operator|=
name|AREGTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|uqd_oct
argument_list|(
operator|(
name|u_quad_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File is too large for tar %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|arcn
operator|->
name|pad
operator|=
name|TAR_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * copy those fields that are independent of the type 	 */
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|,
name|hd
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|hd
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uid
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|,
name|hd
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gid
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * calculate and add the checksum, then write the header. A return of 	 * 0 tells the caller to now write the file data, 1 says no data needs 	 * to be written 	 */
if|if
condition|(
name|ul_oct
argument_list|(
name|tar_chksm
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_TAR
argument_list|)
argument_list|)
argument_list|,
name|hd
operator|->
name|chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|chksum
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|wr_rdbuf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_TAR
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BLKMULT
operator|-
sizeof|sizeof
argument_list|(
name|HD_TAR
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
name|out
label|:
comment|/* 	 * header field is out of range 	 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tar header field is too small for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Routines for POSIX ustar  */
comment|/*  * ustar_strd()  *	initialization for ustar read  * Return:  *	0 if ok, -1 otherwise  */
name|int
name|ustar_strd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|usrtb_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|grptb_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ustar_stwr()  *	initialization for ustar write  * Return:  *	0 if ok, -1 otherwise  */
name|int
name|ustar_stwr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|uidtb_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|gidtb_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ustar_id()  *	determine if a block given to us is a valid ustar header. We have to  *	be on the lookout for those pesky blocks of all zero's  * Return:  *	0 if a ustar header, -1 otherwise  */
name|int
name|ustar_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|HD_USTAR
modifier|*
name|hd
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|BLKMULT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hd
operator|=
operator|(
name|HD_USTAR
operator|*
operator|)
name|blk
expr_stmt|;
comment|/* 	 * check for block of zero's first, a simple and fast test then check 	 * ustar magic cookie. We should use TMAGLEN, but some USTAR archive 	 * programs are fouled up and create archives missing the \0. Last we 	 * check the checksum. If ok we have to assume it is a valid header. 	 */
if|if
condition|(
name|hd
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|hd
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|asc_ul
argument_list|(
name|hd
operator|->
name|chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|chksum
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|!=
name|tar_chksm
argument_list|(
name|blk
argument_list|,
name|BLKMULT
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ustar_rd()  *	extract the values out of block already determined to be a ustar header.  *	store the values in the ARCHD parameter.  * Return:  *	0  */
name|int
name|ustar_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|HD_USTAR
modifier|*
name|hd
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|dev_t
name|devmajor
decl_stmt|;
name|dev_t
name|devminor
decl_stmt|;
comment|/* 	 * we only get proper sized buffers 	 */
if|if
condition|(
name|ustar_id
argument_list|(
name|buf
argument_list|,
name|BLKMULT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|org_name
operator|=
name|arcn
operator|->
name|name
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
name|arcn
operator|->
name|nlen
operator|=
literal|0
expr_stmt|;
name|hd
operator|=
operator|(
name|HD_USTAR
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * see if the filename is split into two parts. if, so joint the parts. 	 * we copy the prefix first and add a / between the prefix and name. 	 */
name|dest
operator|=
name|arcn
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|hd
operator|->
name|prefix
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|cnt
operator|=
name|l_strncpy
argument_list|(
name|dest
argument_list|,
name|hd
operator|->
name|prefix
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|prefix
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|cnt
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * ustar format specifies the name may be unterminated 	 * if it fills the entire field.  this also applies to 	 * the prefix and the linkname. 	 */
name|arcn
operator|->
name|nlen
operator|=
name|cnt
operator|+
name|l_strncpy
argument_list|(
name|dest
argument_list|,
name|hd
operator|->
name|name
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|-
name|cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|name
index|[
name|arcn
operator|->
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * follow the spec to the letter. we should only have mode bits, strip 	 * off all other crud we may be passed. 	 */
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
call|(
name|mode_t
call|)
argument_list|(
name|asc_ul
argument_list|(
name|hd
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mode
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_atime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
comment|/* 	 * If we can find the ascii names for gname and uname in the password 	 * and group files we will use the uid's and gid they bind. Otherwise 	 * we use the uid and gid values stored in the header. (This is what 	 * the POSIX spec wants). 	 */
name|hd
operator|->
name|gname
index|[
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|gid_name
argument_list|(
name|hd
operator|->
name|gname
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
operator|(
name|gid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|hd
operator|->
name|uname
index|[
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|uid_name
argument_list|(
name|hd
operator|->
name|uname
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
operator|(
name|uid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
comment|/* 	 * set the defaults, these may be changed depending on the file type 	 */
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
operator|(
name|dev_t
operator|)
literal|0
expr_stmt|;
comment|/* 	 * set the mode and PAX type according to the typeflag in the header 	 */
switch|switch
condition|(
name|hd
operator|->
name|typeflag
condition|)
block|{
case|case
name|FIFOTYPE
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_FIF
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFIFO
expr_stmt|;
break|break;
case|case
name|DIRTYPE
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_DIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFDIR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
comment|/* 		 * Some programs that create ustar archives append a '/' 		 * to the pathname for directories. This clearly violates 		 * ustar specs, but we will silently strip it off anyway. 		 */
if|if
condition|(
name|arcn
operator|->
name|name
index|[
name|arcn
operator|->
name|nlen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|arcn
operator|->
name|name
index|[
operator|--
name|arcn
operator|->
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|BLKTYPE
case|:
case|case
name|CHRTYPE
case|:
comment|/* 		 * this type requires the rdev field to be set. 		 */
if|if
condition|(
name|hd
operator|->
name|typeflag
operator|==
name|BLKTYPE
condition|)
block|{
name|arcn
operator|->
name|type
operator|=
name|PAX_BLK
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFBLK
expr_stmt|;
block|}
else|else
block|{
name|arcn
operator|->
name|type
operator|=
name|PAX_CHR
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFCHR
expr_stmt|;
block|}
name|devmajor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|devminor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|devminor
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
name|TODEV
argument_list|(
name|devmajor
argument_list|,
name|devminor
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMTYPE
case|:
case|case
name|LNKTYPE
case|:
if|if
condition|(
name|hd
operator|->
name|typeflag
operator|==
name|SYMTYPE
condition|)
block|{
name|arcn
operator|->
name|type
operator|=
name|PAX_SLK
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFLNK
expr_stmt|;
block|}
else|else
block|{
name|arcn
operator|->
name|type
operator|=
name|PAX_HLK
expr_stmt|;
comment|/* 			 * so printing looks better 			 */
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 		 * copy the link name 		 */
name|arcn
operator|->
name|ln_nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|hd
operator|->
name|linkname
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
name|arcn
operator|->
name|ln_nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CONTTYPE
case|:
case|case
name|AREGTYPE
case|:
case|case
name|REGTYPE
case|:
default|default:
comment|/* 		 * these types have file data that follows. Set the skip and 		 * pad fields. 		 */
name|arcn
operator|->
name|type
operator|=
name|PAX_REG
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
name|TAR_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|skip
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * ustar_wr()  *	write a ustar header for the file specified in the ARCHD to the archive  *	Have to check for file types that cannot be stored and file names that  *	are too long. Be careful of the term (last arg) to ul_oct, we only use  *	'\0' for the termination character (this is different than picky tar)  *	ASSUMED: space after header in header block is zero filled  * Return:  *	0 if file has data to be written after the header, 1 if file has NO  *	data to write after the header, -1 if archive write failed  */
name|int
name|ustar_wr
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|HD_USTAR
modifier|*
name|hd
decl_stmt|;
name|char
modifier|*
name|pt
decl_stmt|;
name|HD_USTAR
name|hdblk
decl_stmt|;
comment|/* 	 * check for those file system types ustar cannot store 	 */
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SCK
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Ustar cannot archive a socket %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * check the length of the linkname 	 */
if|if
condition|(
operator|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|ln_nlen
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Link name too long for ustar %s"
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * split the path name into prefix and name fields (if needed). if 	 * pt != arcn->name, the name has to be split 	 */
if|if
condition|(
operator|(
name|pt
operator|=
name|name_split
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|nlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File name too long for ustar %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|hd
operator|=
operator|&
name|hdblk
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
comment|/* 	 * split the name, or zero out the prefix 	 */
if|if
condition|(
name|pt
operator|!=
name|arcn
operator|->
name|name
condition|)
block|{
comment|/* 		 * name was split, pt points at the / where the split is to 		 * occur, we remove the / and copy the first part to the prefix 		 */
operator|*
name|pt
operator|=
literal|'\0'
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|prefix
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|hd
operator|->
name|prefix
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * copy the name part. this may be the whole path or the part after 	 * the prefix.  both the name and prefix may fill the entire field. 	 */
name|l_strncpy
argument_list|(
name|hd
operator|->
name|name
argument_list|,
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * set the fields in the header that are type dependent 	 */
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_DIR
case|:
name|hd
operator|->
name|typeflag
operator|=
name|DIRTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devminor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|PAX_CHR
case|:
case|case
name|PAX_BLK
case|:
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CHR
condition|)
name|hd
operator|->
name|typeflag
operator|=
name|CHRTYPE
expr_stmt|;
else|else
name|hd
operator|->
name|typeflag
operator|=
name|BLKTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|MAJOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|hd
operator|->
name|devmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|MINOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|hd
operator|->
name|devminor
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|PAX_FIF
case|:
name|hd
operator|->
name|typeflag
operator|=
name|FIFOTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devminor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|PAX_SLK
case|:
case|case
name|PAX_HLK
case|:
case|case
name|PAX_HRG
case|:
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SLK
condition|)
name|hd
operator|->
name|typeflag
operator|=
name|SYMTYPE
expr_stmt|;
else|else
name|hd
operator|->
name|typeflag
operator|=
name|LNKTYPE
expr_stmt|;
comment|/* the link name may occupy the entire field in ustar */
name|l_strncpy
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devminor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|PAX_REG
case|:
case|case
name|PAX_CTG
case|:
default|default:
comment|/* 		 * file data with this type, set the padding 		 */
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
condition|)
name|hd
operator|->
name|typeflag
operator|=
name|CONTTYPE
expr_stmt|;
else|else
name|hd
operator|->
name|typeflag
operator|=
name|REGTYPE
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devmajor
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hd
operator|->
name|devminor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
name|TAR_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|uqd_oct
argument_list|(
operator|(
name|u_quad_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|size
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File is too long for ustar %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|l_strncpy
argument_list|(
name|hd
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
argument_list|)
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|version
argument_list|,
name|TVERSION
argument_list|,
name|TVERSLEN
argument_list|)
expr_stmt|;
comment|/* 	 * set the remaining fields. Some versions want all 16 bits of mode 	 * we better humor them (they really do not meet spec though).... 	 */
if|if
condition|(
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|,
name|hd
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mode
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|hd
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uid
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|,
name|hd
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gid
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|ul_oct
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|hd
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|mtime
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|uname
argument_list|,
name|name_uid
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|l_strncpy
argument_list|(
name|hd
operator|->
name|gname
argument_list|,
name|name_gid
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|gname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * calculate and store the checksum write the header to the archive 	 * return 0 tells the caller to now write the file data, 1 says no data 	 * needs to be written 	 */
if|if
condition|(
name|ul_oct
argument_list|(
name|tar_chksm
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_USTAR
argument_list|)
argument_list|)
argument_list|,
name|hd
operator|->
name|chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|chksum
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|wr_rdbuf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_USTAR
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BLKMULT
operator|-
sizeof|sizeof
argument_list|(
name|HD_USTAR
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
name|out
label|:
comment|/* 	 * header field is out of range 	 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Ustar header field is too small for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * name_split()  *	see if the name has to be split for storage in a ustar header. We try  *	to fit the entire name in the name field without splitting if we can.  *	The split point is always at a /  * Return  *	character pointer to split point (always the / that is to be removed  *	if the split is not needed, the points is set to the start of the file  *	name (it would violate the spec to split there). A NULL is returned if  *	the file name is too long  */
specifier|static
name|char
modifier|*
name|name_split
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* 	 * check to see if the file name is small enough to fit in the name 	 * field. if so just return a pointer to the name. 	 */
if|if
condition|(
name|len
operator|<=
name|TNMSZ
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|len
operator|>
operator|(
name|TPFSZ
operator|+
name|TNMSZ
operator|+
literal|1
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * we start looking at the biggest sized piece that fits in the name 	 * field. We walk forward looking for a slash to split at. The idea is 	 * to find the biggest piece to fit in the name field (or the smallest 	 * prefix we can find) 	 */
name|start
operator|=
name|name
operator|+
name|len
operator|-
name|TNMSZ
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|start
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|start
operator|!=
literal|'/'
operator|)
condition|)
operator|++
name|start
expr_stmt|;
comment|/* 	 * if we hit the end of the string, this name cannot be split, so we 	 * cannot store this file. 	 */
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|len
operator|=
name|start
operator|-
name|name
expr_stmt|;
comment|/* 	 * NOTE: /str where the length of str == TNMSZ can not be stored under 	 * the p1003.1-1990 spec for ustar. We could force a prefix of / and 	 * the file would then expand on extract to //str. The len == 0 below 	 * makes this special case follow the spec to the letter. 	 */
if|if
condition|(
operator|(
name|len
operator|>
name|TPFSZ
operator|)
operator|||
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * ok have a split point, return it to the caller 	 */
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

end_unit

