begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ar_subs.c,v 1.9 1997/12/10 22:18:25 eivind Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|sccsid
index|[]
init|=
literal|"@(#)ar_subs.c	8.2 (Berkeley) 4/18/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|wr_archive
name|__P
argument_list|(
operator|(
specifier|register
name|ARCHD
operator|*
operator|,
name|int
name|is_app
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_arc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_head
name|__P
argument_list|(
operator|(
specifier|register
name|ARCHD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|sigset_t
name|s_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Routines which control the overall operation modes of pax as specified by  * the user: list, append, read ...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hdbuf
index|[
name|BLKMULT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* space for archive header on read */
end_comment

begin_decl_stmt
name|u_long
name|flcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files processed */
end_comment

begin_comment
comment|/*  * list()  *	list the contents of an archive which match user supplied pattern(s)  *	(no pattern matches all).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|list
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|list
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|ARCHD
name|archd
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|arcn
operator|=
operator|&
name|archd
expr_stmt|;
comment|/* 	 * figure out archive type; pass any format specific options to the 	 * archive option processing routine; call the format init routine. We 	 * also save current time for ls_list() so we do not make a system 	 * call for each file we need to print. If verbose (vflag) start up 	 * the name and group caches. 	 */
if|if
condition|(
operator|(
name|get_arc
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|options
call|)
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|st_rd
call|)
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|vflag
operator|&&
operator|(
operator|(
name|uidtb_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|gidtb_start
argument_list|()
operator|<
literal|0
operator|)
operator|)
condition|)
return|return;
name|now
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * step through the archive until the format says it is done 	 */
while|while
condition|(
name|next_head
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * check for pattern, and user specified options match. 		 * When all patterns are matched we are done. 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|pat_match
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|res
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sel_chk
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * pattern resulted in a selected file 			 */
if|if
condition|(
name|pat_sel
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
condition|)
break|break;
comment|/* 			 * modify the name as requested by the user if name 			 * survives modification, do a listing of the file 			 */
if|if
condition|(
operator|(
name|res
operator|=
name|mod_name
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|ls_list
argument_list|(
name|arcn
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * skip to next archive format header using values calculated 		 * by the format header read routine 		 */
if|if
condition|(
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
comment|/* 	 * all done, let format have a chance to cleanup, and make sure that 	 * the patterns supplied by the user were all matched 	 */
call|(
name|void
call|)
argument_list|(
operator|*
name|frmt
operator|->
name|end_rd
argument_list|)
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|s_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ar_close
argument_list|()
expr_stmt|;
name|pat_chk
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * extract()  *	extract the member(s) of an archive as specified by user supplied  *	pattern(s) (no patterns extracts all members)  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|extract
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|extract
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|off_t
name|cnt
decl_stmt|;
name|ARCHD
name|archd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|arcn
operator|=
operator|&
name|archd
expr_stmt|;
comment|/* 	 * figure out archive type; pass any format specific options to the 	 * archive option processing routine; call the format init routine; 	 * start up the directory modification time and access mode database 	 */
if|if
condition|(
operator|(
name|get_arc
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|options
call|)
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|st_rd
call|)
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|dir_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * When we are doing interactive rename, we store the mapping of names 	 * so we can fix up hard links files later in the archive. 	 */
if|if
condition|(
name|iflag
operator|&&
operator|(
name|name_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * step through each entry on the archive until the format read routine 	 * says it is done 	 */
while|while
condition|(
name|next_head
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * check for pattern, and user specified options match. When 		 * all the patterns are matched we are done 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|pat_match
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|||
operator|(
name|sel_chk
argument_list|(
name|arcn
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * file is not selected. skip past any file data and 			 * padding and go back for the next archive member 			 */
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * with -u or -D only extract when the archive member is newer 		 * than the file with the same name in the file system (nos 		 * test of being the same type is required). 		 * NOTE: this test is done BEFORE name modifications as 		 * specified by pax. this operation can be confusing to the 		 * user who might expect the test to be done on an existing 		 * file AFTER the name mod. In honesty the pax spec is probably 		 * flawed in this respect. 		 */
if|if
condition|(
operator|(
name|uflag
operator|||
name|Dflag
operator|)
operator|&&
operator|(
operator|(
name|lstat
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|uflag
operator|&&
name|Dflag
condition|)
block|{
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|Dflag
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * this archive member is now been selected. modify the name. 		 */
if|if
condition|(
operator|(
name|pat_sel
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mod_name
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
comment|/* 			 * a bad name mod, skip and purge name from link table 			 */
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Non standard -Y and -Z flag. When the exisiting file is 		 * same age or newer skip 		 */
if|if
condition|(
operator|(
name|Yflag
operator|||
name|Zflag
operator|)
operator|&&
operator|(
operator|(
name|lstat
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|Yflag
operator|&&
name|Zflag
condition|)
block|{
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|Yflag
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|vflag
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * all ok, extract this member based on type 		 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_REG
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_CTG
operator|)
condition|)
block|{
comment|/* 			 * process archive members that are not regular files. 			 * throw out padding and any data that might follow the 			 * header (as determined by the format). 			 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
name|res
operator|=
name|lnk_creat
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|node_creat
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * we have a file with data here. If we can not create it, skip 		 * over the data and purge the name from hard link table 		 */
if|if
condition|(
operator|(
name|fd
operator|=
name|file_creat
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * extract the file from the archive and skip over padding and 		 * any unprocessed data 		 */
name|res
operator|=
call|(
modifier|*
name|frmt
operator|->
name|rd_data
call|)
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
name|file_close
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
operator|(
name|void
operator|)
name|rd_skip
argument_list|(
name|cnt
operator|+
name|arcn
operator|->
name|pad
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * all done, restore directory modes and times as required; make sure 	 * all patterns supplied by the user were matched; block off signals 	 * to avoid chance for multiple entry into the cleanup code. 	 */
call|(
name|void
call|)
argument_list|(
operator|*
name|frmt
operator|->
name|end_rd
argument_list|)
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|s_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ar_close
argument_list|()
expr_stmt|;
name|proc_dir
argument_list|()
expr_stmt|;
name|pat_chk
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * wr_archive()  *	Write an archive. used in both creating a new archive and appends on  *	previously written archive.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
specifier|static
name|void
name|wr_archive
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|,
name|int
name|is_app
argument_list|)
else|#
directive|else
decl|static
name|void
name|wr_archive
argument_list|(
name|arcn
argument_list|,
name|is_app
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|is_app
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|hlk
decl_stmt|;
specifier|register
name|int
name|wr_one
decl_stmt|;
name|off_t
name|cnt
decl_stmt|;
name|int
function_decl|(
modifier|*
name|wrf
function_decl|)
parameter_list|()
function_decl|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	 * if this format supports hard link storage, start up the database 	 * that detects them. 	 */
if|if
condition|(
operator|(
operator|(
name|hlk
operator|=
name|frmt
operator|->
name|hlk
operator|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|lnk_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * start up the file traversal code and format specific write 	 */
if|if
condition|(
operator|(
name|ftree_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|st_wr
call|)
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
name|wrf
operator|=
name|frmt
operator|->
name|wr
expr_stmt|;
comment|/* 	 * When we are doing interactive rename, we store the mapping of names 	 * so we can fix up hard links files later in the archive. 	 */
if|if
condition|(
name|iflag
operator|&&
operator|(
name|name_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * if this not append, and there are no files, we do no write a trailer 	 */
name|wr_one
operator|=
name|is_app
expr_stmt|;
comment|/* 	 * while there are files to archive, process them one at at time 	 */
while|while
condition|(
name|next_file
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * check if this file meets user specified options match. 		 */
if|if
condition|(
name|sel_chk
argument_list|(
name|arcn
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
comment|/* 			 * only archive if this file is newer than a file with 			 * the same name that is already stored on the archive 			 */
if|if
condition|(
operator|(
name|res
operator|=
name|chk_ftime
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
continue|continue;
block|}
comment|/* 		 * this file is considered selected now. see if this is a hard 		 * link to a file already stored 		 */
name|ftree_sel
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlk
operator|&&
operator|(
name|chk_lnk
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
condition|)
block|{
comment|/* 			 * we will have to read this file. by opening it now we 			 * can avoid writing a header to the archive for a file 			 * we were later unable to read (we also purge it from 			 * the link table). 			 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|arcn
operator|->
name|org_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to open %s to read"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Now modify the name as requested by the user 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|mod_name
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * name modification says to skip this file, close the 			 * file and purge link table entry 			 */
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|||
operator|(
name|docrc
operator|&&
operator|(
name|set_crc
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 			 * unable to obtain the crc we need, close the file, 			 * purge link table entry 			 */
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vflag
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|flcnt
expr_stmt|;
comment|/* 		 * looks safe to store the file, have the format specific 		 * routine write routine store the file header on the archive 		 */
if|if
condition|(
operator|(
name|res
operator|=
call|(
modifier|*
name|wrf
call|)
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
name|wr_one
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
comment|/* 			 * format write says no file data needs to be stored 			 * so we are done messing with this file 			 */
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Add file data to the archive, quit on write error. if we 		 * cannot write the entire file contents to the archive we 		 * must pad the archive to replace the missing file data 		 * (otherwise during an extract the file header for the file 		 * which FOLLOWS this one will not be where we expect it to 		 * be). 		 */
name|res
operator|=
call|(
modifier|*
name|frmt
operator|->
name|wr_data
call|)
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
break|break;
comment|/* 		 * pad as required, cnt is number of bytes not written 		 */
if|if
condition|(
operator|(
operator|(
name|cnt
operator|>
literal|0
operator|)
operator|&&
operator|(
name|wr_skip
argument_list|(
name|cnt
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|arcn
operator|->
name|pad
operator|>
literal|0
operator|)
operator|&&
operator|(
name|wr_skip
argument_list|(
name|arcn
operator|->
name|pad
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
break|break;
block|}
comment|/* 	 * tell format to write trailer; pad to block boundry; reset directory 	 * mode/access times, and check if all patterns supplied by the user 	 * were matched. block off signals to avoid chance for multiple entry 	 * into the cleanup code 	 */
if|if
condition|(
name|wr_one
condition|)
block|{
call|(
modifier|*
name|frmt
operator|->
name|end_wr
call|)
argument_list|()
expr_stmt|;
name|wr_fin
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|s_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ar_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|tflag
condition|)
name|proc_dir
argument_list|()
expr_stmt|;
name|ftree_chk
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * append()  *	Add file to previously written archive. Archive format specified by the  *	user must agree with archive. The archive is read first to collect  *	modification times (if -u) and locate the archive trailer. The archive  *	is positioned in front of the record with the trailer and wr_archive()  *	is called to add the new members.  *	PAX IMPLEMENTATION DETAIL NOTE:  *	-u is implemented by adding the new members to the end of the archive.  *	Care is taken so that these do not end up as links to the older  *	version of the same file already stored in the archive. It is expected  *	when extraction occurs these newer versions will over-write the older  *	ones stored "earlier" in the archive (this may be a bad assumption as  *	it depends on the implementation of the program doing the extraction).  *	It is really difficult to splice in members without either re-writing  *	the entire archive (from the point were the old version was), or having  *	assistance of the format specification in terms of a special update  *	header that invalidates a previous archive record. The posix spec left  *	the method used to implement -u unspecified. This pax is able to  *	over write existing files that it creates.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|append
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|append
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|ARCHD
name|archd
decl_stmt|;
name|FSUB
modifier|*
name|orgfrmt
decl_stmt|;
name|int
name|udev
decl_stmt|;
name|off_t
name|tlen
decl_stmt|;
name|arcn
operator|=
operator|&
name|archd
expr_stmt|;
name|orgfrmt
operator|=
name|frmt
expr_stmt|;
comment|/* 	 * Do not allow an append operation if the actual archive is of a 	 * different format than the user specified foramt. 	 */
if|if
condition|(
name|get_arc
argument_list|()
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|orgfrmt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|orgfrmt
operator|!=
name|frmt
operator|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot mix current archive format %s with %s"
argument_list|,
name|frmt
operator|->
name|name
argument_list|,
name|orgfrmt
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * pass the format any options and start up format 	 */
if|if
condition|(
operator|(
call|(
modifier|*
name|frmt
operator|->
name|options
call|)
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
call|(
modifier|*
name|frmt
operator|->
name|st_rd
call|)
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * if we only are adding members that are newer, we need to save the 	 * mod times for all files we see. 	 */
if|if
condition|(
name|uflag
operator|&&
operator|(
name|ftime_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * some archive formats encode hard links by recording the device and 	 * file serial number (inode) but copy the file anyway (multiple times) 	 * to the archive. When we append, we run the risk that newly added 	 * files may have the same device and inode numbers as those recorded 	 * on the archive but during a previous run. If this happens, when the 	 * archive is extracted we get INCORRECT hard links. We avoid this by 	 * remapping the device numbers so that newly added files will never 	 * use the same device number as one found on the archive. remapping 	 * allows new members to safely have links among themselves. remapping 	 * also avoids problems with file inode (serial number) truncations 	 * when the inode number is larger than storage space in the archive 	 * header. See the remap routines for more details. 	 */
if|if
condition|(
operator|(
name|udev
operator|=
name|frmt
operator|->
name|udev
operator|)
operator|&&
operator|(
name|dev_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * reading the archive may take a long time. If verbose tell the user 	 */
if|if
condition|(
name|vflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Reading archive to position at the end..."
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * step through the archive until the format says it is done 	 */
while|while
condition|(
name|next_head
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * check if this file meets user specified options. 		 */
if|if
condition|(
name|sel_chk
argument_list|(
name|arcn
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
operator|==
literal|1
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|uflag
condition|)
block|{
comment|/* 			 * see if this is the newest version of this file has 			 * already been seen, if so skip. 			 */
if|if
condition|(
operator|(
name|res
operator|=
name|chk_ftime
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
operator|==
literal|1
condition|)
break|break;
continue|continue;
block|}
block|}
comment|/* 		 * Store this device number. Device numbers seen during the 		 * read phase of append will cause newly appended files with a 		 * device number seen in the old part of the archive to be 		 * remapped to an unused device number. 		 */
if|if
condition|(
operator|(
name|udev
operator|&&
operator|(
name|add_dev
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|rd_skip
argument_list|(
name|arcn
operator|->
name|skip
operator|+
name|arcn
operator|->
name|pad
argument_list|)
operator|==
literal|1
operator|)
condition|)
break|break;
block|}
comment|/* 	 * done, finish up read and get the number of bytes to back up so we 	 * can add new members. The format might have used the hard link table, 	 * purge it. 	 */
name|tlen
operator|=
call|(
modifier|*
name|frmt
operator|->
name|end_rd
call|)
argument_list|()
expr_stmt|;
name|lnk_end
argument_list|()
expr_stmt|;
comment|/* 	 * try to postion for write, if this fails quit. if any error occurs, 	 * we will refuse to write 	 */
if|if
condition|(
name|appnd_start
argument_list|(
name|tlen
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * tell the user we are done reading. 	 */
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"done.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * go to the writing phase to add the new members 	 */
name|wr_archive
argument_list|(
name|arcn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * archive()  *	write a new archive  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|archive
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|archive
argument_list|()
endif|#
directive|endif
block|{
name|ARCHD
name|archd
decl_stmt|;
comment|/* 	 * if we only are adding members that are newer, we need to save the 	 * mod times for all files; set up for writing; pass the format any 	 * options write the archive 	 */
if|if
condition|(
operator|(
name|uflag
operator|&&
operator|(
name|ftime_start
argument_list|()
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|wr_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
call|(
modifier|*
name|frmt
operator|->
name|options
call|)
argument_list|()
operator|<
literal|0
condition|)
return|return;
name|wr_archive
argument_list|(
operator|&
name|archd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * copy()  *	copy files from one part of the file system to another. this does not  *	use any archive storage. The EFFECT OF THE COPY IS THE SAME as if an  *	archive was written and then extracted in the destination directory  *	(except the files are forced to be under the destination directory).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|copy
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|copy
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|fddest
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest_pt
decl_stmt|;
specifier|register
name|int
name|dlen
decl_stmt|;
specifier|register
name|int
name|drem
decl_stmt|;
name|int
name|fdsrc
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ARCHD
name|archd
decl_stmt|;
name|char
name|dirbuf
index|[
name|PAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|arcn
operator|=
operator|&
name|archd
expr_stmt|;
comment|/* 	 * set up the destination dir path and make sure it is a directory. We 	 * make sure we have a trailing / on the destination 	 */
name|dlen
operator|=
name|l_strncpy
argument_list|(
name|dirbuf
argument_list|,
name|dirptr
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dest_pt
operator|=
name|dirbuf
operator|+
name|dlen
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|dest_pt
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|dest_pt
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|++
name|dlen
expr_stmt|;
block|}
operator|*
name|dest_pt
operator|=
literal|'\0'
expr_stmt|;
name|drem
operator|=
name|PAXPATHLEN
operator|-
name|dlen
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirptr
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Cannot access destination directory %s"
argument_list|,
name|dirptr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Destination is not a directory %s"
argument_list|,
name|dirptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * start up the hard link table; file traversal routines and the 	 * modification time and access mode database 	 */
if|if
condition|(
operator|(
name|lnk_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|ftree_start
argument_list|()
operator|<
literal|0
operator|)
operator|||
operator|(
name|dir_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * When we are doing interactive rename, we store the mapping of names 	 * so we can fix up hard links files later in the archive. 	 */
if|if
condition|(
name|iflag
operator|&&
operator|(
name|name_start
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * set up to cp file trees 	 */
name|cp_start
argument_list|()
expr_stmt|;
comment|/* 	 * while there are files to archive, process them 	 */
while|while
condition|(
name|next_file
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdsrc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * check if this file meets user specified options 		 */
if|if
condition|(
name|sel_chk
argument_list|(
name|arcn
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * if there is already a file in the destination directory with 		 * the same name and it is newer, skip the one stored on the 		 * archive. 		 * NOTE: this test is done BEFORE name modifications as 		 * specified by pax. this can be confusing to the user who 		 * might expect the test to be done on an existing file AFTER 		 * the name mod. In honesty the pax spec is probably flawed in 		 * this respect 		 */
if|if
condition|(
name|uflag
operator|||
name|Dflag
condition|)
block|{
comment|/* 			 * create the destination name 			 */
if|if
condition|(
operator|*
operator|(
name|arcn
operator|->
name|name
operator|)
operator|==
literal|'/'
condition|)
name|res
operator|=
literal|1
expr_stmt|;
else|else
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|nlen
operator|-
name|res
operator|)
operator|>
name|drem
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Destination pathname too long %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dest_pt
argument_list|,
name|arcn
operator|->
name|name
operator|+
name|res
argument_list|,
name|drem
argument_list|)
expr_stmt|;
name|dirbuf
index|[
name|PAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * if existing file is same age or newer skip 			 */
name|res
operator|=
name|lstat
argument_list|(
name|dirbuf
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
operator|*
name|dest_pt
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uflag
operator|&&
name|Dflag
condition|)
block|{
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|Dflag
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
condition|)
continue|continue;
block|}
block|}
comment|/* 		 * this file is considered selected. See if this is a hard link 		 * to a previous file; modify the name as requested by the 		 * user; set the final destination. 		 */
name|ftree_sel
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk_lnk
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mod_name
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|||
operator|(
name|set_dest
argument_list|(
name|arcn
argument_list|,
name|dirbuf
argument_list|,
name|dlen
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* 			 * skip file, purge from link table 			 */
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Non standard -Y and -Z flag. When the exisiting file is 		 * same age or newer skip 		 */
if|if
condition|(
operator|(
name|Yflag
operator|||
name|Zflag
operator|)
operator|&&
operator|(
operator|(
name|lstat
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|Yflag
operator|&&
name|Zflag
condition|)
block|{
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|Yflag
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|<=
name|sb
operator|.
name|st_ctime
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<=
name|sb
operator|.
name|st_mtime
condition|)
continue|continue;
block|}
if|if
condition|(
name|vflag
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|flcnt
expr_stmt|;
comment|/* 		 * try to create a hard link to the src file if requested 		 * but make sure we are not trying to overwrite ourselves. 		 */
if|if
condition|(
name|lflag
condition|)
name|res
operator|=
name|cross_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|chk_same
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * have to create a new file 		 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_REG
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_CTG
operator|)
condition|)
block|{
comment|/* 			 * create a link or special file 			 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
name|res
operator|=
name|lnk_creat
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|node_creat
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * have to copy a regular file to the destination directory. 		 * first open source file and then create the destination file 		 */
if|if
condition|(
operator|(
name|fdsrc
operator|=
name|open
argument_list|(
name|arcn
operator|->
name|org_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to open %s to read"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|fddest
operator|=
name|file_creat
argument_list|(
name|arcn
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fdsrc
argument_list|)
expr_stmt|;
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * copy source file data to the destination file 		 */
name|cp_file
argument_list|(
name|arcn
argument_list|,
name|fdsrc
argument_list|,
name|fddest
argument_list|)
expr_stmt|;
name|file_close
argument_list|(
name|arcn
argument_list|,
name|fddest
argument_list|)
expr_stmt|;
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
operator|&
name|fdsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * restore directory modes and times as required; make sure all 	 * patterns were selected block off signals to avoid chance for 	 * multiple entry into the cleanup code. 	 */
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|s_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ar_close
argument_list|()
expr_stmt|;
name|proc_dir
argument_list|()
expr_stmt|;
name|ftree_chk
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * next_head()  *	try to find a valid header in the archive. Uses format specific  *	routines to extract the header and id the trailer. Trailers may be  *	located within a valid header or in an invalid header (the location  *	is format specific. The inhead field from the option table tells us  *	where to look for the trailer).  *	We keep reading (and resyncing) until we get enough contiguous data  *	to check for a header. If we cannot find one, we shift by a byte  *	add a new byte from the archive to the end of the buffer and try again.  *	If we get a read error, we throw out what we have (as we must have  *	contiguous data) and start over again.  *	ASSUMED: headers fit within a BLKMULT header.  * Return:  *	0 if we got a header, -1 if we are unable to ever find another one  *	(we reached the end of input, or we reached the limit on retries. see  *	the specs for rd_wrbuf() for more details)  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
specifier|static
name|int
name|next_head
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
decl|static
name|int
name|next_head
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|hdend
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|shftsz
decl_stmt|;
specifier|register
name|int
name|hsz
decl_stmt|;
specifier|register
name|int
name|in_resync
init|=
literal|0
decl_stmt|;
comment|/* set when we are in resync mode */
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* counter for trailer function */
comment|/* 	 * set up initial conditions, we want a whole frmt->hsz block as we 	 * have no data yet. 	 */
name|res
operator|=
name|hsz
operator|=
name|frmt
operator|->
name|hsz
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
name|shftsz
operator|=
name|hsz
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * keep looping until we get a contiguous FULL buffer 		 * (frmt->hsz is the proper size) 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|rd_wrbuf
argument_list|(
name|hdend
argument_list|,
name|res
argument_list|)
operator|)
operator|==
name|res
condition|)
break|break;
comment|/* 			 * some kind of archive read problem, try to resync the 			 * storage device, better give the user the bad news. 			 */
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|||
operator|(
name|rd_sync
argument_list|()
operator|<
literal|0
operator|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Premature end of file on archive read"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|in_resync
condition|)
block|{
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Archive I/O error, cannot continue"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Archive I/O error. Trying to recover."
argument_list|)
expr_stmt|;
operator|++
name|in_resync
expr_stmt|;
block|}
comment|/* 			 * oh well, throw it all out and start over 			 */
name|res
operator|=
name|hsz
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
block|}
comment|/* 		 * ok we have a contiguous buffer of the right size. Call the 		 * format read routine. If this was not a valid header and this 		 * format stores trailers outside of the header, call the 		 * format specific trailer routine to check for a trailer. We 		 * have to watch out that we do not mis-identify file data or 		 * block padding as a header or trailer. Format specific 		 * trailer functions must NOT check for the trailer while we 		 * are running in resync mode. Some trailer functions may tell 		 * us that this block cannot contain a valid header either, so 		 * we then throw out the entire block and start over. 		 */
if|if
condition|(
call|(
modifier|*
name|frmt
operator|->
name|rd
call|)
argument_list|(
name|arcn
argument_list|,
name|hdbuf
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|frmt
operator|->
name|inhead
condition|)
block|{
comment|/* 			 * this format has trailers outside of valid headers 			 */
if|if
condition|(
operator|(
name|ret
operator|=
call|(
modifier|*
name|frmt
operator|->
name|trail
call|)
argument_list|(
name|hdbuf
argument_list|,
name|in_resync
argument_list|,
operator|&
name|cnt
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * valid trailer found, drain input as required 				 */
name|ar_drain
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* 				 * we are in resync and we were told to throw 				 * the whole block out because none of the 				 * bytes in this block can be used to form a 				 * valid header 				 */
name|res
operator|=
name|hsz
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Brute force section. 		 * not a valid header. We may be able to find a header yet. So 		 * we shift over by one byte, and set up to read one byte at a 		 * time from the archive and place it at the end of the buffer. 		 * We will keep moving byte at a time until we find a header or 		 * get a read error and have to start over. 		 */
if|if
condition|(
operator|!
name|in_resync
condition|)
block|{
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to append, archive header flaw"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Invalid header, starting valid header search."
argument_list|)
expr_stmt|;
operator|++
name|in_resync
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|hdbuf
operator|+
literal|1
argument_list|,
name|hdbuf
argument_list|,
name|shftsz
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
name|hdend
operator|=
name|hdbuf
operator|+
name|shftsz
expr_stmt|;
block|}
comment|/* 	 * ok got a valid header, check for trailer if format encodes it in the 	 * the header. NOTE: the parameters are different than trailer routines 	 * which encode trailers outside of the header! 	 */
if|if
condition|(
name|frmt
operator|->
name|inhead
operator|&&
operator|(
call|(
modifier|*
name|frmt
operator|->
name|trail
call|)
argument_list|(
name|arcn
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * valid trailer found, drain input as required 		 */
name|ar_drain
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|++
name|flcnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get_arc()  *	Figure out what format an archive is. Handles archive with flaws by  *	brute force searches for a legal header in any supported format. The  *	format id routines have to be careful to NOT mis-identify a format.  *	ASSUMED: headers fit within a BLKMULT header.  * Return:  *	0 if archive found -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
specifier|static
name|int
name|get_arc
argument_list|(
name|void
argument_list|)
else|#
directive|else
decl|static
name|int
name|get_arc
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|hdsz
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|minhd
init|=
name|BLKMULT
decl_stmt|;
name|char
modifier|*
name|hdend
decl_stmt|;
name|int
name|notice
init|=
literal|0
decl_stmt|;
comment|/* 	 * find the smallest header size in all archive formats and then set up 	 * to read the archive. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ford
index|[
name|i
index|]
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fsub
index|[
name|ford
index|[
name|i
index|]
index|]
operator|.
name|hsz
operator|<
name|minhd
condition|)
name|minhd
operator|=
name|fsub
index|[
name|ford
index|[
name|i
index|]
index|]
operator|.
name|hsz
expr_stmt|;
block|}
if|if
condition|(
name|rd_start
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|res
operator|=
name|BLKMULT
expr_stmt|;
name|hdsz
operator|=
literal|0
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 			 * fill the buffer with at least the smallest header 			 */
name|i
operator|=
name|rd_wrbuf
argument_list|(
name|hdend
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|hdsz
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|hdsz
operator|>=
name|minhd
condition|)
break|break;
comment|/* 			 * if we cannot recover from a read error quit 			 */
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|rd_sync
argument_list|()
operator|<
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * when we get an error none of the data we already 			 * have can be used to create a legal header (we just 			 * got an error in the middle), so we throw it all out 			 * and refill the buffer with fresh data. 			 */
name|res
operator|=
name|BLKMULT
expr_stmt|;
name|hdsz
operator|=
literal|0
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
if|if
condition|(
operator|!
name|notice
condition|)
block|{
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot identify format. Searching..."
argument_list|)
expr_stmt|;
operator|++
name|notice
expr_stmt|;
block|}
block|}
comment|/* 		 * we have at least the size of the smallest header in any 		 * archive format. Look to see if we have a match. The array 		 * ford[] is used to specify the header id order to reduce the 		 * chance of incorrectly id'ing a valid header (some formats 		 * may be subsets of each other and the order would then be 		 * important). 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ford
index|[
name|i
index|]
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|fsub
index|[
name|ford
index|[
name|i
index|]
index|]
operator|.
name|id
operator|)
operator|(
name|hdbuf
operator|,
name|hdsz
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|frmt
operator|=
operator|&
operator|(
name|fsub
index|[
name|ford
index|[
name|i
index|]
index|]
operator|)
expr_stmt|;
comment|/* 			 * yuck, to avoid slow special case code in the extract 			 * routines, just push this header back as if it was 			 * not seen. We have left extra space at start of the 			 * buffer for this purpose. This is a bit ugly, but 			 * adding all the special case code is far worse. 			 */
name|pback
argument_list|(
name|hdbuf
argument_list|,
name|hdsz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * We have a flawed archive, no match. we start searching, but 		 * we never allow additions to flawed archives 		 */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot identify format. Searching..."
argument_list|)
expr_stmt|;
operator|++
name|notice
expr_stmt|;
block|}
comment|/* 		 * brute force search for a header that we can id. 		 * we shift through byte at a time. this is slow, but we cannot 		 * determine the nature of the flaw in the archive in a 		 * portable manner 		 */
if|if
condition|(
operator|--
name|hdsz
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|hdbuf
operator|+
literal|1
argument_list|,
name|hdbuf
argument_list|,
name|hdsz
argument_list|)
expr_stmt|;
name|res
operator|=
name|BLKMULT
operator|-
name|hdsz
expr_stmt|;
name|hdend
operator|=
name|hdbuf
operator|+
name|hdsz
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|BLKMULT
expr_stmt|;
name|hdend
operator|=
name|hdbuf
expr_stmt|;
name|hdsz
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* 	 * we cannot find a header, bow, apologize and quit 	 */
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Sorry, unable to determine archive format."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_decl_stmt

end_unit

