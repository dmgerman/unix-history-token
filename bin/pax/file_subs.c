begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: file_subs.c,v 1.4.2.2 1997/09/14 13:07:21 jkh Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|sccsid
index|[]
init|=
literal|"@(#)file_subs.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|mk_link
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|,
specifier|register
expr|struct
name|stat
operator|*
operator|,
specifier|register
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * routines that deal with file operations such as: creating, removing;  * and setting access modes, uid/gid and times of files  */
end_comment

begin_define
define|#
directive|define
name|FILEBITS
value|(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
end_define

begin_define
define|#
directive|define
name|SETBITS
value|(S_ISUID | S_ISGID)
end_define

begin_define
define|#
directive|define
name|ABITS
value|(FILEBITS | SETBITS)
end_define

begin_comment
comment|/*  * file_creat()  *	Create and open a file.  * Return:  *	file descriptor or -1 for failure  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|file_creat
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|file_creat
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|mode_t
name|file_mode
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
comment|/* 	 * assume file doesn't exist, so just try to create it, most times this 	 * works. We have to take special handling when the file does exist. To 	 * detect this, we use O_EXCL. For example when trying to create a 	 * file and a character device or fifo exists with the same name, we 	 * can accidently open the device by mistake (or block waiting to open) 	 * If we find that the open has failed, then figure spend the effore to 	 * figure out why. This strategy was found to have better average 	 * performance in common use than checking the file (and the path) 	 * first with lstat. 	 */
name|file_mode
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|FILEBITS
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_EXCL
argument_list|,
name|file_mode
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* 	 * the file seems to exist. First we try to get rid of it (found to be 	 * the second most common failure when traced). If this fails, only 	 * then we go to the expense to check and create the path to the file 	 */
if|if
condition|(
name|unlnk_exist
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * try to open it again, if this fails, check all the nodes in 		 * the path and give it a final try. if chk_path() finds that 		 * it cannot fix anything, we will skip the last attempt 		 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|file_mode
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
name|oerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|chk_path
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|oerrno
argument_list|,
literal|"Unable to create %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_close()  *	Close file descriptor to a file just created by pax. Sets modes,  *	ownership and times as required.  * Return:  *	0 for success, -1 for failure  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|file_close
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|,
name|int
name|fd
argument_list|)
else|#
directive|else
name|void
name|file_close
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to close file descriptor on %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * set owner/groups first as this may strip off mode bits we want 	 * then set file permission modes. Then set file access and 	 * modification times. 	 */
if|if
condition|(
name|pids
condition|)
name|res
operator|=
name|set_ids
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* 	 * IMPORTANT SECURITY NOTE: 	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT 	 * set uid/gid bits 	 */
if|if
condition|(
operator|!
name|pmode
operator|||
name|res
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&=
operator|~
operator|(
name|SETBITS
operator|)
expr_stmt|;
if|if
condition|(
name|pmode
condition|)
name|set_pmode
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|patime
operator|||
name|pmtime
condition|)
name|set_ftime
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * lnk_creat()  *	Create a hard link to arcn->ln_name from arcn->name. arcn->ln_name  *	must exist;  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|lnk_creat
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|lnk_creat
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * we may be running as root, so we have to be sure that link target 	 * is not a directory, so we lstat and check 	 */
if|if
condition|(
name|lstat
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to link to %s from %s"
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"A hard link to the directory %s is not allowed"
argument_list|,
name|arcn
operator|->
name|ln_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|mk_link
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
name|sb
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cross_lnk()  *	Create a hard link to arcn->org_name from arcn->name. Only used in copy  *	with the -l flag. No pax_warning or error if this does not succeed (we will  *	then just create the file)  * Return:  *	1 if copy() should try to create this file node  *	0 if cross_lnk() ok, -1 for fatal flaw (like linking to self).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|cross_lnk
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|cross_lnk
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
comment|/* 	 * try to make a link to orginal file (-l flag in copy mode). make sure 	 * we do not try to link to directories in case we are running as root 	 * (and it might succeed). 	 */
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|mk_link
argument_list|(
name|arcn
operator|->
name|org_name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|sb
operator|)
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * chk_same()  *	In copy mode if we are not trying to make hard links between the src  *	and destinations, make sure we are not going to overwrite ourselves by  *	accident. This slows things down a little, but we have to protect all  *	those people who make typing errors.  * Return:  *	1 the target does not exist, go ahead and copy  *	0 skip it file exists (-k) or may be the same as source file  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|chk_same
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|chk_same
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * if file does not exist, return. if file exists and -k, skip it 	 * quietly 	 */
if|if
condition|(
name|lstat
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|kflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * better make sure the user does not have src == dest by mistake 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|==
name|sb
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|==
name|sb
operator|.
name|st_ino
operator|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to copy %s, file would overwrite itself"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mk_link()  *	try to make a hard link between two files. if ign set, we do not  *	complain.  * Return:  *	0 if successful (or we are done with this file but no error, such as  *	finding the from file exists and the user has set -k).  *	1 when ign was set to indicates we could not make the link but we  *	should try to copy/extract the file as that might work (and is an  *	allowed option). -1 an error occurred.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
specifier|static
name|int
name|mk_link
argument_list|(
specifier|register
name|char
operator|*
name|to
argument_list|,
specifier|register
expr|struct
name|stat
operator|*
name|to_sb
argument_list|,
specifier|register
name|char
operator|*
name|from
argument_list|,
name|int
name|ign
argument_list|)
else|#
directive|else
decl|static
name|int
name|mk_link
argument_list|(
name|to
argument_list|,
name|to_sb
argument_list|,
name|from
argument_list|,
name|ign
argument_list|)
decl|register
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|to_sb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ign
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
comment|/* 	 * if from file exists, it has to be unlinked to make the link. If the 	 * file exists and -k is set, skip it quietly 	 */
if|if
condition|(
name|lstat
argument_list|(
name|from
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * make sure it is not the same file, protect the user 		 */
if|if
condition|(
operator|(
name|to_sb
operator|->
name|st_dev
operator|==
name|sb
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|to_sb
operator|->
name|st_ino
operator|==
name|sb
operator|.
name|st_ino
operator|)
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to link file %s to itself"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
empty_stmt|;
block|}
comment|/* 		 * try to get rid of the file, based on the type 		 */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|from
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to remove %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ign
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to remove %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * from file is gone (or did not exist), try to make the hard link. 	 * if it fails, check the path and try it again (if chk_path() says to 	 * try again) 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|link
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|oerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|chk_path
argument_list|(
name|from
argument_list|,
name|to_sb
operator|->
name|st_uid
argument_list|,
name|to_sb
operator|->
name|st_gid
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ign
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|oerrno
argument_list|,
literal|"Could not link to %s from %s"
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * all right the link was made 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * node_creat()  *	create an entry in the file system (other than a file or hard link).  *	If successful, sets uid/gid modes and times as required.  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|node_creat
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|node_creat
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|ign
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|oerrno
decl_stmt|;
specifier|register
name|int
name|pass
init|=
literal|0
decl_stmt|;
name|mode_t
name|file_mode
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * create node based on type, if that fails try to unlink the node and 	 * try again. finally check the path and try again. As noted in the 	 * file and link creation routines, this method seems to exhibit the 	 * best performance in general use workloads. 	 */
name|file_mode
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|FILEBITS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_DIR
case|:
name|res
operator|=
name|mkdir
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|file_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ign
condition|)
name|res
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PAX_CHR
case|:
name|file_mode
operator||=
name|S_IFCHR
expr_stmt|;
name|res
operator|=
name|mknod
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|file_mode
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAX_BLK
case|:
name|file_mode
operator||=
name|S_IFBLK
expr_stmt|;
name|res
operator|=
name|mknod
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|file_mode
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAX_FIF
case|:
name|res
operator|=
name|mkfifo
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|file_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAX_SCK
case|:
comment|/* 			 * Skip sockets, operation has no meaning under BSD 			 */
name|pax_warn
argument_list|(
literal|0
argument_list|,
literal|"%s skipped. Sockets cannot be copied or extracted"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|PAX_SLK
case|:
if|if
condition|(
operator|(
name|res
operator|=
name|symlink
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|PAX_CTG
case|:
case|case
name|PAX_HLK
case|:
case|case
name|PAX_HRG
case|:
case|case
name|PAX_REG
case|:
default|default:
comment|/* 			 * we should never get here 			 */
name|pax_warn
argument_list|(
literal|0
argument_list|,
literal|"%s has an unknown file type, skipping"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * if we were able to create the node break out of the loop, 		 * otherwise try to unlink the node and try again. if that 		 * fails check the full path and try a final time. 		 */
if|if
condition|(
name|res
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * we failed to make the node 		 */
name|oerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|(
name|ign
operator|=
name|unlnk_exist
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|type
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|++
name|pass
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|chk_path
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|oerrno
argument_list|,
literal|"Could not create: %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * we were able to create the node. set uid/gid, modes and times 	 */
if|if
condition|(
name|pids
condition|)
name|res
operator|=
name|set_ids
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
literal|0
expr_stmt|;
comment|/* 	 * IMPORTANT SECURITY NOTE: 	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT any 	 * set uid/gid bits 	 */
if|if
condition|(
operator|!
name|pmode
operator|||
name|res
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&=
operator|~
operator|(
name|SETBITS
operator|)
expr_stmt|;
if|if
condition|(
name|pmode
condition|)
name|set_pmode
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
condition|)
block|{
comment|/* 		 * Dirs must be processed again at end of extract to set times 		 * and modes to agree with those stored in the archive. However 		 * to allow extract to continue, we may have to also set owner 		 * rights. This allows nodes in the archive that are children 		 * of this directory to be extracted without failure. Both time 		 * and modes will be fixed after the entire archive is read and 		 * before pax exits. 		 */
if|if
condition|(
name|access
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|R_OK
operator||
name|W_OK
operator||
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lstat
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Could not access %s (stat)"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
name|set_pmode
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|file_mode
operator||
name|S_IRWXU
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We have to add rights to the dir, so we make 				 * sure to restore the mode. The mode must be 				 * restored AS CREATED and not as stored if 				 * pmode is not set. 				 */
name|set_pmode
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|FILEBITS
operator|)
operator||
name|S_IRWXU
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmode
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
name|sb
operator|.
name|st_mode
expr_stmt|;
block|}
comment|/* 			 * we have to force the mode to what was set here, 			 * since we changed it from the default as created. 			 */
name|add_dir
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|nlen
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|sb
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmode
operator|||
name|patime
operator|||
name|pmtime
condition|)
name|add_dir
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|nlen
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|sb
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|patime
operator|||
name|pmtime
condition|)
name|set_ftime
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * unlnk_exist()  *	Remove node from file system with the specified name. We pass the type  *	of the node that is going to replace it. When we try to create a  *	directory and find that it already exists, we allow processing to  *	continue as proper modes etc will always be set for it later on.  * Return:  *	0 is ok to proceed, no file with the specified name exists  *	-1 we were unable to remove the node, or we should not remove it (-k)  *	1 we found a directory and we were going to create a directory.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|unlnk_exist
argument_list|(
specifier|register
name|char
operator|*
name|name
argument_list|,
specifier|register
name|int
name|type
argument_list|)
else|#
directive|else
name|int
name|unlnk_exist
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * the file does not exist, or -k we are done 	 */
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|kflag
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * try to remove a directory, if it fails and we were going to 		 * create a directory anyway, tell the caller (return a 1) 		 */
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|PAX_DIR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to remove directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * try to get rid of all non-directory type nodes 	 */
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Could not unlink %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * chk_path()  *	We were trying to create some kind of node in the file system and it  *	failed. chk_path() makes sure the path up to the node exists and is  *	writeable. When we have to create a directory that is missing along the  *	path somewhere, the directory we create will be set to the same  *	uid/gid as the file has (when uid and gid are being preserved).  *	NOTE: this routine is a real performance loss. It is only used as a  *	last resort when trying to create entries in the file system.  * Return:  *	-1 when it could find nothing it is allowed to fix.  *	0 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|chk_path
argument_list|(
specifier|register
name|char
operator|*
name|name
argument_list|,
name|uid_t
name|st_uid
argument_list|,
name|gid_t
name|st_gid
argument_list|)
else|#
directive|else
name|int
name|chk_path
argument_list|(
name|name
argument_list|,
name|st_uid
argument_list|,
name|st_gid
argument_list|)
decl|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|st_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|st_gid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|char
modifier|*
name|spt
init|=
name|name
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	 * watch out for paths with nodes stored directly in / (e.g. /bozo) 	 */
if|if
condition|(
operator|*
name|spt
operator|==
literal|'/'
condition|)
operator|++
name|spt
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * work foward from the first / and check each part of the path 		 */
name|spt
operator|=
name|strchr
argument_list|(
name|spt
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|spt
operator|==
name|NULL
condition|)
break|break;
operator|*
name|spt
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * if it exists we assume it is a directory, it is not within 		 * the spec (at least it seems to read that way) to alter the 		 * file system for nodes NOT EXPLICITLY stored on the archive. 		 * If that assumption is changed, you would test the node here 		 * and figure out how to get rid of it (probably like some 		 * recursive unlink()) or fix up the directory permissions if 		 * required (do an access()). 		 */
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|spt
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * the path fails at this point, see if we can create the 		 * needed directory and continue on 		 */
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|spt
operator|=
literal|'/'
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * we were able to create the directory. We will tell the 		 * caller that we found something to fix, and it is ok to try 		 * and create the node again. 		 */
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pids
condition|)
operator|(
name|void
operator|)
name|set_ids
argument_list|(
name|name
argument_list|,
name|st_uid
argument_list|,
name|st_gid
argument_list|)
expr_stmt|;
comment|/* 		 * make sure the user doen't have some strange umask that 		 * causes this newly created directory to be unusable. We fix 		 * the modes and restore them back to the creation default at 		 * the end of pax 		 */
if|if
condition|(
operator|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
operator||
name|W_OK
operator||
name|X_OK
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|set_pmode
argument_list|(
name|name
argument_list|,
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|FILEBITS
operator|)
operator||
name|S_IRWXU
operator|)
argument_list|)
expr_stmt|;
name|add_dir
argument_list|(
name|name
argument_list|,
name|spt
operator|-
name|name
argument_list|,
operator|&
name|sb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|spt
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set_ftime()  *	Set the access time and modification time for a named file. If frc is  *	non-zero we force these times to be set even if the the user did not  *	request access and/or modification time preservation (this is also  *	used by -t to reset access times).  *	When ign is zero, only those times the user has asked for are set, the  *	other ones are left alone. We do not assume the un-documented feature  *	of many utimes() implementations that consider a 0 time value as a do  *	not set request.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|set_ftime
parameter_list|(
name|char
modifier|*
name|fnm
parameter_list|,
name|time_t
name|mtime
parameter_list|,
name|time_t
name|atime
parameter_list|,
name|int
name|frc
parameter_list|)
else|#
directive|else
function|void set_ftime
parameter_list|(
name|fnm
parameter_list|,
name|mtime
parameter_list|,
name|atime
parameter_list|,
name|frc
parameter_list|)
name|char
modifier|*
name|fnm
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|int
name|frc
decl_stmt|;
endif|#
directive|endif
block|{
specifier|static
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0L
block|,
literal|0L
block|}
block|,
block|{
literal|0L
block|,
literal|0L
block|}
block|}
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|atime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|mtime
expr_stmt|;
if|if
condition|(
operator|!
name|frc
operator|&&
operator|(
operator|!
name|patime
operator|||
operator|!
name|pmtime
operator|)
condition|)
block|{
comment|/* 		 * if we are not forcing, only set those times the user wants 		 * set. We get the current values of the times if we need them. 		 */
if|if
condition|(
name|lstat
argument_list|(
name|fnm
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|patime
condition|)
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|sb
operator|.
name|st_atime
expr_stmt|;
if|if
condition|(
operator|!
name|pmtime
condition|)
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
name|sys_warn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to obtain file stats %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * set the times 	 */
if|if
condition|(
name|utimes
argument_list|(
name|fnm
argument_list|,
name|tv
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Access/modification time set failed on: %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * set_ids()  *	set the uid and gid of a file system node  * Return:  *	0 when set, -1 on failure  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|int
name|set_ids
parameter_list|(
name|char
modifier|*
name|fnm
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|)
else|#
directive|else
function|int set_ids
parameter_list|(
name|fnm
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|)
name|char
modifier|*
name|fnm
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|chown
argument_list|(
name|fnm
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to set file uid/gid of %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set_pmode()  *	Set file access mode  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|set_pmode
parameter_list|(
name|char
modifier|*
name|fnm
parameter_list|,
name|mode_t
name|mode
parameter_list|)
else|#
directive|else
function|void set_pmode
parameter_list|(
name|fnm
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fnm
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
endif|#
directive|endif
block|{
name|mode
operator|&=
name|ABITS
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|fnm
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Could not set permissions on %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * file_write()  *	Write/copy a file (during copy or archive extract). This routine knows  *	how to copy files with lseek holes in it. (Which are read as file  *	blocks containing all 0's but do not have any file blocks associated  *	with the data). Typical examples of these are files created by dbm  *	variants (.pag files). While the file size of these files are huge, the  *	actual storage is quite small (the files are sparse). The problem is  *	the holes read as all zeros so are probably stored on the archive that  *	way (there is no way to determine if the file block is really a hole,  *	we only know that a file block of all zero's can be a hole).  *	At this writing, no major archive format knows how to archive files  *	with holes. However, on extraction (or during copy, -rw) we have to  *	deal with these files. Without detecting the holes, the files can  *	consume a lot of file space if just written to disk. This replacement  *	for write when passed the basic allocation size of a file system block,  *	uses lseek whenever it detects the input data is all 0 within that  *	file block. In more detail, the strategy is as follows:  *	While the input is all zero keep doing an lseek. Keep track of when we  *	pass over file block boundries. Only write when we hit a non zero  *	input. once we have written a file block, we continue to write it to  *	the end (we stop looking at the input). When we reach the start of the  *	next file block, start checking for zero blocks again. Working on file  *	block boundries significantly reduces the overhead when copying files  *	that are NOT very sparse. This overhead (when compared to a write) is  *	almost below the measurement resolution on many systems. Without it,  *	files with holes cannot be safely copied. It does has a side effect as  *	it can put holes into files that did not have them before, but that is  *	not a problem since the file contents are unchanged (in fact it saves  *	file space). (Except on paging files for diskless clients. But since we  *	cannot determine one of those file from here, we ignore them). If this  *	ever ends up on a system where CTG files are supported and the holes  *	are not desired, just do a conditional test in those routines that  *	call file_write() and have it call write() instead. BEFORE CLOSING THE  *	FILE, make sure to call file_flush() when the last write finishes with  *	an empty block. A lot of file systems will not create an lseek hole at  *	the end. In this case we drop a single 0 at the end to force the  *	trailing 0's in the file.  *	---Parameters---  *	rem: how many bytes left in this file system block  *	isempt: have we written to the file block yet (is it empty)  *	sz: basic file block allocation size  *	cnt: number of bytes on this write  *	str: buffer to write  * Return:  *	number of bytes written, -1 on write (or lseek) error.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|int
name|file_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
specifier|register
name|int
name|cnt
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|,
name|int
modifier|*
name|isempt
parameter_list|,
name|int
name|sz
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|int file_write
parameter_list|(
name|fd
parameter_list|,
name|str
parameter_list|,
name|cnt
parameter_list|,
name|rem
parameter_list|,
name|isempt
parameter_list|,
name|sz
parameter_list|,
name|name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|int
modifier|*
name|rem
decl_stmt|;
name|int
modifier|*
name|isempt
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|pt
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|wcnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|st
init|=
name|str
decl_stmt|;
comment|/* 	 * while we have data to process 	 */
while|while
condition|(
name|cnt
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|rem
condition|)
block|{
comment|/* 			 * We are now at the start of file system block again 			 * (or what we think one is...). start looking for 			 * empty blocks again 			 */
operator|*
name|isempt
operator|=
literal|1
expr_stmt|;
operator|*
name|rem
operator|=
name|sz
expr_stmt|;
block|}
comment|/* 		 * only examine up to the end of the current file block or 		 * remaining characters to write, whatever is smaller 		 */
name|wcnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
operator|*
name|rem
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|wcnt
expr_stmt|;
operator|*
name|rem
operator|-=
name|wcnt
expr_stmt|;
if|if
condition|(
operator|*
name|isempt
condition|)
block|{
comment|/* 			 * have not written to this block yet, so we keep 			 * looking for zero's 			 */
name|pt
operator|=
name|st
expr_stmt|;
name|end
operator|=
name|st
operator|+
name|wcnt
expr_stmt|;
comment|/* 			 * look for a zero filled buffer 			 */
while|while
condition|(
operator|(
name|pt
operator|<
name|end
operator|)
operator|&&
operator|(
operator|*
name|pt
operator|==
literal|'\0'
operator|)
condition|)
operator|++
name|pt
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|end
condition|)
block|{
comment|/* 				 * skip, buf is empty so far 				 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|wcnt
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"File seek on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|st
operator|=
name|pt
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * drat, the buf is not zero filled 			 */
operator|*
name|isempt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * have non-zero data in this file system block, have to write 		 */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|st
argument_list|,
name|wcnt
argument_list|)
operator|!=
name|wcnt
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed write to file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|st
operator|+=
name|wcnt
expr_stmt|;
block|}
return|return
operator|(
name|st
operator|-
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_flush()  *	when the last file block in a file is zero, many file systems will not  *	let us create a hole at the end. To get the last block with zeros, we  *	write the last BYTE with a zero (back up one byte and write a zero).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|file_flush
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|isempt
parameter_list|)
else|#
directive|else
function|void file_flush
parameter_list|(
name|fd
parameter_list|,
name|fname
parameter_list|,
name|isempt
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|isempt
decl_stmt|;
endif|#
directive|endif
block|{
specifier|static
name|char
name|blnk
index|[]
init|=
literal|"\0"
decl_stmt|;
comment|/* 	 * silly test, but make sure we are only called when the last block is 	 * filled with all zeros. 	 */
if|if
condition|(
operator|!
name|isempt
condition|)
return|return;
comment|/* 	 * move back one byte and write a zero 	 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed seek on file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|blnk
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed write to file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * rdfile_close()  *	close a file we have beed reading (to copy or archive). If we have to  *	reset access time (tflag) do so (the times are stored in arcn).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|rdfile_close
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|,
specifier|register
name|int
operator|*
name|fd
argument_list|)
else|#
directive|else
name|void
name|rdfile_close
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
comment|/* 	 * make sure the file is open 	 */
if|if
condition|(
operator|*
name|fd
operator|<
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|close
argument_list|(
operator|*
name|fd
argument_list|)
expr_stmt|;
operator|*
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tflag
condition|)
return|return;
comment|/* 	 * user wants last access time reset 	 */
name|set_ftime
argument_list|(
name|arcn
operator|->
name|org_name
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_atime
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * set_crc()  *	read a file to calculate its crc. This is a real drag. Archive formats  *	that have this, end up reading the file twice (we have to write the  *	header WITH the crc before writing the file contents. Oh well...  * Return:  *	0 if was able to calculate the crc, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|set_crc
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|,
specifier|register
name|int
name|fd
argument_list|)
else|#
directive|else
name|int
name|set_crc
argument_list|(
name|arcn
argument_list|,
name|fd
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|off_t
name|cpcnt
init|=
literal|0L
decl_stmt|;
name|u_long
name|size
decl_stmt|;
name|unsigned
name|long
name|crc
init|=
literal|0L
decl_stmt|;
name|char
name|tbuf
index|[
name|FILEBLK
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* 		 * hmm, no fd, should never happen. well no crc then. 		 */
name|arcn
operator|->
name|crc
operator|=
literal|0L
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|size
operator|=
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_blksize
operator|)
operator|>
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
condition|)
name|size
operator|=
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
comment|/* 	 * read all the bytes we think that there are in the file. If the user 	 * is trying to archive an active file, forget this file. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tbuf
argument_list|,
name|size
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|cpcnt
operator|+=
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
condition|;
operator|++
name|i
control|)
name|crc
operator|+=
operator|(
name|tbuf
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
comment|/* 	 * safety check. we want to avoid archiving files that are active as 	 * they can create inconsistant archive copies. 	 */
if|if
condition|(
name|cpcnt
operator|!=
name|arcn
operator|->
name|sb
operator|.
name|st_size
condition|)
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"File changed size %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed stat on %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|!=
name|sb
operator|.
name|st_mtime
condition|)
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"File %s was modified during read"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"File rewind failed on: %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
else|else
block|{
name|arcn
operator|->
name|crc
operator|=
name|crc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

